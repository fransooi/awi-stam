/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/host/webFrontEnd/dialogs.css":
/*!******************************************!*\
  !*** ./src/host/webFrontEnd/dialogs.css ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/host/webFrontEnd/diskDialog.css":
/*!*********************************************!*\
  !*** ./src/host/webFrontEnd/diskDialog.css ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/host/webFrontEnd/joystickDialog.css":
/*!*************************************************!*\
  !*** ./src/host/webFrontEnd/joystickDialog.css ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/host/webFrontEnd/keyMapDialog.css":
/*!***********************************************!*\
  !*** ./src/host/webFrontEnd/keyMapDialog.css ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/host/webFrontEnd/loaderDialog.css":
/*!***********************************************!*\
  !*** ./src/host/webFrontEnd/loaderDialog.css ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/host/webFrontEnd/scopes.css":
/*!*****************************************!*\
  !*** ./src/host/webFrontEnd/scopes.css ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/host/webFrontEnd/snapshots.css":
/*!********************************************!*\
  !*** ./src/host/webFrontEnd/snapshots.css ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/host/webFrontEnd/trays.css":
/*!****************************************!*\
  !*** ./src/host/webFrontEnd/trays.css ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/debug.js":
/*!**********************!*\
  !*** ./src/debug.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $xx: () => (/* binding */ $xx),
/* harmony export */   $xxxx: () => (/* binding */ $xxxx),
/* harmony export */   petsciiToChar: () => (/* binding */ petsciiToChar),
/* harmony export */   unimplementedWarning: () => (/* binding */ unimplementedWarning),
/* harmony export */   vetAddress: () => (/* binding */ vetAddress),
/* harmony export */   xx: () => (/* binding */ xx),
/* harmony export */   xxxx: () => (/* binding */ xxxx)
/* harmony export */ });
// TODO: this belongs in tools

const petsciiToChar = (
  /* 0x00 */ "����������������" + /* 0x10 */ "����������������" +
  /* 0x20 */" !\"#$%&'()*+,-./" + /* 0x30 */ "0123456789:;<=>?" +
  /* 0x40 */ "@abcdefghijklmno" + /* 0x50 */ "pqrstuvwxyz[£]↑←" +
  /* 0x60 */ "—ABCDEFGHIJKLMNO" + /* 0x70 */ "PQRSTUVWXYZ┼▒│▒▒" +
  /* 0x80 */ "����������������" + /* 0x90 */ "����������������" +
  /* 0xa0 */ " ▌▄▔▁▎▒▕▒▒▕├▗└┐▂" + /* 0xb0 */ "┌┴┬┤▎▍▕▔▔▃✓▖▝┘▘▚" +
  /* 0xc0 */ "─ABCDEFGHIJKLMNO" + /* 0xd0 */ "PQRSTUVWXYZ┼▒│▒▒" +
  /* 0xe0 */ " ▌▄▔▁▎▒▕▒▒▕├▗└┐▂" + /* 0xf0 */ "┌┴┬┤▎▍▕▔▔▃✓▖▝┘▘▒"
);

function toHexStr(val, digits=2) {
  return val.toString(16).padStart(digits, "0");
}

const xx   = val => toHexStr(val, 2);
const xxxx = val => toHexStr(val, 4);

const $xx   = val => `\$${xx(val)}`;
const $xxxx = val => `\$${xxxx(val)}`;

function vetAddress(addr) {
  if (
    (addr !== addr) // is NaN?
    || (typeof addr !== "number")
    || (addr !== Math.floor(addr))
    || (addr < 0)
    || (addr > 0xffff)
  ) {
    throw new Error(`Invalid bus address: ${addr}`);
  }
}

const encounteredWarnings = new Set();

function unimplementedWarning(problem, details) {

  // Remove this to show warnings when the target software tries exercising
  // unimplemented hardware functionality, but you'll see lots of false
  // positives.
  return;

  if (encounteredWarnings.has(problem)) return;
  
  console.warn("Unimplemented:", problem);
  if (details) console.log(details);

  encounteredWarnings.add(problem);
}


/***/ }),

/***/ "./src/host/audio-OscillatorNode.js":
/*!******************************************!*\
  !*** ./src/host/audio-OscillatorNode.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   attach: () => (/* binding */ attach)
/* harmony export */ });
/*
   SID output using the Web Audio API. Specifically, an output path built upon
   a network of OscillatorNode nodes. Maybe someday there'd be an alternative
   audio-AudioWorklet too, so to avoid confusion between the two, this file
   isn't called audio-WebAudio.
*/

const state = {
  regs: new Uint8Array(32),
  suspended: true,
};

// Square waves are as loud as it gets. Dial it down...
const MASTER_MULTIPLIER = 0.2;

// Divide hibyte/lobyte frequency by MASTER_TUNING to get Hz.
// TODO: this isn't accurate. Tables exist which could give a better number,
// eg. https://codebase64.org/doku.php?id=base:pal_frequency_table
//     https://codebase64.org/doku.php?id=base:ntsc_frequency_table
//
// Note that it's different for PAL vs NTSC
const MASTER_TUNING = 16.9;

// create web audio API context
const audioCtx = new (globalThis.AudioContext || globalThis.webkitAudioContext)();

// If the browser won't allow audio context creation immediately we'll continue
// regardless and hope that userDidInteract gets called to unblock it. If that
// doesn't happen, the emulator will slow dramatically the more the audio API
// is used.
state.suspended = (audioCtx.state === "suspended");

if (state.suspended) {
  // Listen out for events that could allow resumption (though most likely
  // it'll be the drag-and-drop that unblocks us).
  window.addEventListener(
    "load",
    () => {
      document.addEventListener("click",   userDidInteract);
      document.addEventListener("keydown", userDidInteract);
    }
  );

  // Resumption may be asynchronous, so start an interval poller that watches
  // out for it and tears down the listeners.
  const poller = setInterval(
    () => {
      if (audioCtx.state === "running") {
        state.suspended = false;
        console.log("AudioContext resumed");

        // Tear down the listeners that are trying to update `suspended`. We'll
        // still get events from drag-and-drop, but they're completely harmless.
        clearInterval(poller);
        document.removeEventListener("click",   userDidInteract);
        document.removeEventListener("keydown", userDidInteract);
      }
    },
    250
  );
}

// uiGain is the ultimate chain in the link, connecting the emulated network
// to the browser.
const uiGain = audioCtx.createGain();
uiGain.gain.value = 1;
uiGain.connect(audioCtx.destination);

// 'master' in the context of 'within the C64'
const masterGain = audioCtx.createGain();
masterGain.gain.value = 0;
masterGain.connect(uiGain);

let voices = [];

// The thresholder curve is a response table that maps input (-1, 1) to output
// (-1, 1). The WaveShaperNode API linearly interpolates between points in the
// table that the domain maps to, so we need a table with enough entries that
// that's unlikely to matter much. 256 will do.
const nThresholderCurvePoints = 256;
const thresholderCurve = new Float32Array(nThresholderCurvePoints);
for (let n = 0; n < nThresholderCurvePoints; n++) {
  thresholderCurve[n] = (n < (nThresholderCurvePoints / 2)) ? -1 : 1;
}

// Static noise data
const noiseBufferSize = 2 * audioCtx.sampleRate;
const noiseBuffer = audioCtx.createBuffer(1, noiseBufferSize, audioCtx.sampleRate);
const noiseData = noiseBuffer.getChannelData(0);

// Or, better, use the actual SID noise pattern. See:
// https://codebase64.org/doku.php?id=base:noise_waveform
for (let i = 0; i < noiseBufferSize; i++) {
  noiseData[i] = (Math.random() * 2) - 1;
}

// At time of writing, macOS Safari (v13.0.3) doesn't support
// ConstantSourceNode, so we'll monkey patch a stub in its place.
// Alternatively, we could use a buffer node with constant output, but I'm
// hoping Apple will eventually implement it.
if (globalThis.ConstantSourceNode === undefined) {
  console.warn("Your browser doesn't support ConstantSourceNode. Pulse width modulation disabled.");
  globalThis.ConstantSourceNode = function () {
    this.start   = () => {};
    this.connect = () => {};
    this.offset  = {};
  };
}

// Set up voices
[0, 1, 2].forEach(
  voice => {

    const oscillator  = audioCtx.createOscillator();
    const whiteNoise  = audioCtx.createBufferSource();
    const voiceGain   = audioCtx.createGain();
    const waveGain    = audioCtx.createGain();
    const noiseGain   = audioCtx.createGain();
    const thresholder = audioCtx.createWaveShaper();

    // voiceGain: sets a voice volume (for the ADSR envelope), flowing in to
    // the master gain.
    voiceGain.gain.value = 0;
    voiceGain.connect(masterGain);

    // thresholder: to implement rectangle waves. Its inputs are a triangle
    // wave (from waveGain) and a variable DC offset (from dcSource).
    // It sums them and thresholds the output to (-1, 1).
    thresholder.curve = thresholderCurve;
    thresholder.connect(waveGain);

    // dcSource: set by the pulse width registers, to influence the thresholder.
    const dcSource = new ConstantSourceNode(audioCtx);
    dcSource.start();
    dcSource.connect(thresholder);

    // oscillator: the wave generator that will be used for triangle, sawtooth,
    // and rectangle waveforms.
    oscillator.type = "triangle";
    oscillator.frequency.value = 440;  // hertz
    oscillator.connect(waveGain);
    oscillator.start();

    // whiteNoise: the generator that will be used for the noise waveform.
    whiteNoise.buffer = noiseBuffer;
    whiteNoise.loop = true;
    whiteNoise.connect(noiseGain);
    whiteNoise.start(0);

    // noiseGain: sits between the whiteNoise generator and voiceGain to
    // determine whether or not noise will go out on the voice (all or
    // nothing).
    noiseGain.gain.value = 0;
    noiseGain.connect(voiceGain);

    // waveGain: sits between either the thresholder or the oscillator
    // (depending on whether we're playing a rectangle wave vs. sawtooth or
    // triangle), and determines whether or not sound from that source will
    // go out on the voice (all or nothing).
    waveGain.gain.value = 0;
    waveGain.connect(voiceGain);


    voices[voice] = {
      oscillator,
      voiceGain,
      noiseGain,
      waveGain,
      whiteNoise,
      dcSource,
      thresholder
    };
  }
)

function setMasterVolume(byte) {
  // byte is the raw write byte; needs disentangling
  masterGain.gain.value = ((byte & 0xf) / 15) * MASTER_MULTIPLIER;
}

function setVoiceFrequency(voice) {

  const lo = state.regs[(voice * 7) + 0];
  const hi = state.regs[(voice * 7) + 1];

  const word = (hi << 8) | lo;
  const freq = word / MASTER_TUNING;

  // voices[voice].oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
  voices[voice].oscillator.frequency.value = freq;
  voices[voice].whiteNoise.playbackRate.value = freq / 2000;
}

function setVoicePulseWidth(voice) {

  // Pulse width is a 12-bit number, split between a lowbyte and highbyte.
  const lo = (state.regs[(voice * 7) + 2]) & 0xff;
  const hi = (state.regs[(voice * 7) + 3]) & 0x0f;

  const width = (hi << 8) | lo;

  // Map (000, fff) width value to a (-1, 1) DC offset
  const dcOffset = ((width / 0xfff) * 2) - 1; 

  voices[voice].dcSource.offset.value = dcOffset;
}

function setControlRegister(voice, byte) {

  // TODO: this relies on reset configuring it to the lastControlRegister value
  // but I haven't made it do that yet.
  if ((byte & 0xf0) !== voices[voice].lastControlRegister) {

    // Theoretically, no two waveforms should be on at the same time. But
    // Wizball does that in voices 1 and 2 (triangle and rectangle) late into
    // song 3, and it's clear from real hardware (at least on a 6581) that
    // rectangle wins out.
    if (byte & 0x80) {
      // Noise
      voices[voice]. waveGain.gain.value = 0;
      voices[voice].noiseGain.gain.value = 1;
    }

    else if (byte & 0x40) {
      // Rectangle (pulse)
      // (Yes implemented as a triangle wave. It gets added to an offset, then
      // thresholded, to end up as the pulse wave requested.)
      voices[voice].oscillator.type = "triangle";
      voices[voice]. waveGain.gain.value = 1;
      voices[voice].noiseGain.gain.value = 0;
      voices[voice].oscillator.disconnect();
      voices[voice].oscillator.connect(voices[voice].thresholder);
    }

    else if (byte & 0x20) {
      // Sawtooth
      voices[voice].oscillator.type = "sawtooth";
      voices[voice]. waveGain.gain.value = 1;
      voices[voice].noiseGain.gain.value = 0;
      voices[voice].oscillator.disconnect();
      voices[voice].oscillator.connect(voices[voice].waveGain);
    }

    else if (byte & 0x10) {
      // Triangle
      voices[voice].oscillator.type = "triangle";
      voices[voice]. waveGain.gain.value = 1;
      voices[voice].noiseGain.gain.value = 0;
      voices[voice].oscillator.disconnect();
      voices[voice].oscillator.connect(voices[voice].waveGain);
    }
  }

  // TODO: add this to docs
  voices[voice].lastControlRegister = byte;
}

function setVoiceVolume(voice, volume) {
  voices[voice].voiceGain.gain.value = volume;
}

function onRegWrite(reg, byte) {

  state.regs[reg] = byte;

  switch (reg) {

    case 0x00:    // $d400: voice 1 frequency (low-byte)
    case 0x01:    // $d401: voice 1 frequency (high-byte)
      return setVoiceFrequency(0);

    case 0x02:    // $d402: voice 1 pulse width (low-byte)
    case 0x03:    // $d403: voice 1 pulse width (high-byte)
      return setVoicePulseWidth(0);

    case 0x04:    // $d404: voice 1 control register
      return setControlRegister(0, byte);


    case 0x07:    // $d407: voice 2 frequency (low-byte)
    case 0x08:    // $d408: voice 2 frequency (high-byte)
      return setVoiceFrequency(1);

    case 0x09:    // $d409: voice 2 pulse width (low-byte)
    case 0x0a:    // $d40a: voice 2 pulse width (high-byte)
      return setVoicePulseWidth(1);

    case 0x0b:    // $d40b: voice 2 control register
      return setControlRegister(1, byte);


    case 0x0e:    // $d40e: voice 3 frequency (low-byte)
    case 0x0f:    // $d40f: voice 3 frequency (high-byte)
      return setVoiceFrequency(2);

    case 0x10:    // $d410: voice 3 pulse width (low-byte)
    case 0x11:    // $d411: voice 3 pulse width (high-byte)
      return setVoicePulseWidth(2);

    case 0x12:    // $d412: voice 3 control register
      return setControlRegister(2, byte);


    case 0x18:    // $d418: master volume and filter modes
      return setMasterVolume(byte);
  }
}

function reset() {
  // TODO!
}

function attach(nascentC64) {
  nascentC64.audio = {
    // Control
    reset,
    // Interface-specific handlers
    setVoiceVolume,
    onRegWrite,
    userDidInteract,
    setUiGain,
  };

  // https://stackoverflow.com/questions/7944460/detect-safari-browser
  const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

  if (isSafari) {
    // Effects reported below relate to macOS Safari v13.0.3, current at time
    // of writing. Also, it'll run really slowly if the JavaScript console's
    // open.
    const useStub = confirm(
      "It looks like you're running Safari. Safari's sound implementation " +
      "introduces weird slides, and isn't comptible with our pulse width " +
      "modulator. Disable audio?"
    );

    if (useStub) {
      nascentC64.audio.setVoiceVolume  = () => {};
      nascentC64.audio.onRegWrite      = () => {};
      nascentC64.audio.userDidInteract = () => {};
    }
  }
}

function userDidInteract() {
  // If the audioContext was created in a suspended state (see
  // https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#webaudio
  // ), let's try to resume it now that we've observed a user interaction.
  if (state.suspended) audioCtx.resume();

  // If successful, audioCtx.state may not change immediately. (My observation:
  // Firefox 75 does; Chrome 81 does not.)
  // Thus, just to track whether the audio's actually on at any given time (not
  // that the frontend currently reports it), we have an interval poller that 
  // checks and updates the `suspended` variable.

  // Also, note that this resumption may not be successful. A keydown event of
  // a modifier or escape key, for example, would trigger this function, but is
  // insufficient for the browser's anti-nuisance policy to allow the audio
  // resumption.
}

function setUiGain(value) {
  uiGain.gain.value = value; 
}


/***/ }),

/***/ "./src/host/buttonNameToMatrixPos.js":
/*!*******************************************!*\
  !*** ./src/host/buttonNameToMatrixPos.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buttonNameToMatrixPos: () => (/* binding */ buttonNameToMatrixPos)
/* harmony export */ });
/*
   Column-row combinations for the C64's physical keys
  
   Example: Commodore key is [7, 5], meaning that if, when writing to CIA1
   port A ($dc00), I set the keyboard scan to column 7 (by writing bit 7, so
   0b10000000), I'd expect to see the status of the Commodore key in bit 5 when
   reading CIA1 port B.
  
   Note that the Restore key doesn't have a position in this table: it's wired
   directly to the NMI line and has no position in the matrix. There's no
   separate entry for Shift Lock either.
 */

const buttonNameToMatrixPos = {
  RunStop:      [ 7, 7 ],
  Q:            [ 7, 6 ],
  Commodore:    [ 7, 5 ],   // unmapped in natural
  Space:        [ 7, 4 ],
  Num2:         [ 7, 3 ],
  Ctrl:         [ 7, 2 ],
  LeftArrow:    [ 7, 1 ],   // the key that draws a '←', not cursor-left
  Num1:         [ 7, 0 ],

  Slash:        [ 6, 7 ],
  UpArrow:      [ 6, 6 ],   // the key that draws a '↑', not cursor-up
  Equal:        [ 6, 5 ],
  RightShift:   [ 6, 4 ],   // unmapped in natural
  ClrHome:      [ 6, 3 ],
  Semicolon:    [ 6, 2 ],
  Asterisk:     [ 6, 1 ],
  Pound:        [ 6, 0 ],

  Comma:        [ 5, 7 ],
  At:           [ 5, 6 ],
  Colon:        [ 5, 5 ],
  Period:       [ 5, 4 ],
  Minus:        [ 5, 3 ],
  L:            [ 5, 2 ],
  P:            [ 5, 1 ],
  Plus:         [ 5, 0 ],

  N:            [ 4, 7 ],
  O:            [ 4, 6 ],
  K:            [ 4, 5 ],
  M:            [ 4, 4 ],
  Num0:         [ 4, 3 ],
  J:            [ 4, 2 ],
  I:            [ 4, 1 ],
  Num9:         [ 4, 0 ],

  V:            [ 3, 7 ],
  U:            [ 3, 6 ],
  H:            [ 3, 5 ],
  B:            [ 3, 4 ],
  Num8:         [ 3, 3 ],
  G:            [ 3, 2 ],
  Y:            [ 3, 1 ],
  Num7:         [ 3, 0 ],

  X:            [ 2, 7 ],
  T:            [ 2, 6 ],
  F:            [ 2, 5 ],
  C:            [ 2, 4 ],
  Num6:         [ 2, 3 ],
  D:            [ 2, 2 ],
  R:            [ 2, 1 ],
  Num5:         [ 2, 0 ],

  LeftShift:    [ 1, 7 ],
  E:            [ 1, 6 ],
  S:            [ 1, 5 ],
  Z:            [ 1, 4 ],
  Num4:         [ 1, 3 ],
  A:            [ 1, 2 ],
  W:            [ 1, 1 ],
  Num3:         [ 1, 0 ],

  CursorDown:   [ 0, 7 ],
  F5:           [ 0, 6 ],
  F3:           [ 0, 5 ],
  F1:           [ 0, 4 ],
  F7:           [ 0, 3 ],
  CursorRight:  [ 0, 2 ],
  Return:       [ 0, 1 ],
  InstDel:      [ 0, 0 ],
};


/***/ }),

/***/ "./src/host/dragAndDrop.js":
/*!*********************************!*\
  !*** ./src/host/dragAndDrop.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   attach: () => (/* binding */ attach)
/* harmony export */ });
/* harmony import */ var _ingest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ingest.js */ "./src/host/ingest.js");


// bound by attach
let c64;

function attach(nascentC64) {
  c64 = nascentC64;

  window.addEventListener(
    "load",
    () => {
      document.addEventListener(
        "dragover",
        (event) => {
          // This looks like it isn't doing anything, but without it, drag-and-drop
          // doesn't work.
          event.preventDefault();
        }
      );

      document.addEventListener(
        "drop",
        (event) => {
          event.preventDefault();
          onDrop(event);

          // For the web audio API, the drop event is one of the interactions
          // whose occurrence permits the AudioContext to be resumed. Moreover,
          // it's likely to be the only such interaction before the user would
          // expect to hear sound.
          if (c64.audio.userDidInteract) c64.audio.userDidInteract();
        }
      );
    }
  );
}

function onDrop(event) {
  const [file, extraFile] = event.dataTransfer.files;

  if (extraFile) {
    err("Drop only one file at once");
    return;
  }

  if (!file) {
    tryLoadFromInternallyDraggedSnapshot(event);
    return;
  }

  const reader = new FileReader();
  reader.onload = (event) => {
    (0,_ingest_js__WEBPACK_IMPORTED_MODULE_0__.ingest)(c64, file.name, new Uint8Array(reader.result));
  };

  reader.readAsArrayBuffer(file);
}

function err(str) {
  if (c64.hooks.reportError) c64.hooks.reportError(str);
  else alert(str);
}

function tryLoadFromInternallyDraggedSnapshot(event) {
  // The event.file was falsy, meaning quite possibly that the user dragged a
  // snapshot link from the <a> to the main window. The code below is a super
  // awkward attempt at loading in that circumstance. At time of writing, it
  // works in Chrome, Firefox, and Safari, but I don't trust it very far.
  //
  // I believe there's a drag-and-drop interface which would allow for DOM
  // nodes to be dragged to your desktop in a way that creates files there. If
  // so, it'd be good to support that; and the below would likely adopt
  // accordingly.

  for (let item of event.dataTransfer.items) {
    if (item.type !== "text/plain") continue;

    item.getAsString(
      async (url) => {

        // expect a URL like `blob:http://localhost:8080/(some guid)`
        if (!/^blob\:/.test(url)) return;

        const json = await (await fetch(url)).json();

        (0,_ingest_js__WEBPACK_IMPORTED_MODULE_0__.ingest)(
          c64,
          "snapshot.json",
          // 🤮
          new Uint8Array(
            Array
              .from(JSON.stringify(json))
              .map(str => str.charCodeAt(0))
          )
        );
      }
    );

    break;
  }
}


/***/ }),

/***/ "./src/host/ingest-d64.js":
/*!********************************!*\
  !*** ./src/host/ingest-d64.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ingest_d64: () => (/* binding */ ingest_d64)
/* harmony export */ });
/* harmony import */ var _tools_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/parser */ "./src/tools/parser.js");
/* harmony import */ var _tools_loadPrg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tools/loadPrg */ "./src/tools/loadPrg.js");
/* harmony import */ var _tools_romLocations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tools/romLocations */ "./src/tools/romLocations.js");


 


// Format reference:
// †1 http://unusedino.de/ec64/technical/formats/d64.html

const parseDirSector = (0,_tools_parser__WEBPACK_IMPORTED_MODULE_0__.makeParser)((_) => {

  const entry = (_) => ({
    nextTrack:     _.byte(),
    nextSector:    _.byte(),
    type:          _.byte(),
    track:         _.byte(),
    sector:        _.byte(),
    name:          _.string(16),
    sideSecTrack:  _.byte(),
    sideSecSector: _.byte(),
    relLength:     _.byte(),
    _:             _.skip(6),
    blocks:        _.word_le(),
  });

  return new Array(8)
    .fill()
    .map(() => entry(_))
  ;
});

const parseFileSector = (0,_tools_parser__WEBPACK_IMPORTED_MODULE_0__.makeParser)((_) => ({
  nextTrack:  _.byte(),
  nextSector: _.byte(),
  bytes:      _.remainder(),
}));


async function ingest_d64(c64, bytes) {

  if (!c64.hooks.onD64Ingest) {
    throw new Error("Can’t show .d64 directories with this frontend");
  }

  const dir = loadDir(bytes);

  // d64 ingestor hook: give it a directory; it'll present a dialog for picking
  // which PRG to load, and return a promise which resolves to an entry from
  // the directory. That entry contains a track/sector, which defined the start
  // of the PRG.
  //
  // (TODO: right now, if you close the dialog, the promise just sits
  // unresolved forever. Better if it resolved to, or threw, null)
  const { track, sector } = await c64.hooks.onD64Ingest(dir);

  // Follow the track/sector links to pull in all the bytes
  const prg = loadFile(bytes, track, sector);

  // ...then boot it in the usual way.
  c64.runloop.reset();
  await c64.runloop.untilPc(_tools_romLocations__WEBPACK_IMPORTED_MODULE_2__.AWAIT_KEYBOARD_PC);
  (0,_tools_loadPrg__WEBPACK_IMPORTED_MODULE_1__.loadPrg)(c64, prg);
  c64.runloop.type("RUN\r");
  c64.runloop.run();
}

function calcAbsSector(track, sector) {
  // Note: by convention, `track` is one-indexed; `sector` is zero-indexed.
  // We could do a sanity check that sector isn't too big a number for that
  // track.
  if ((track < 1) || (track > 40)) {
    throw new Error("Track out of range: " + track);
  }

  // Convert `sector` from being track-relative to absolute
  while (--track) {
    if      (track >= 31) sector += 17;
    else if (track >= 25) sector += 18;
    else if (track >= 18) sector += 19;
    else                  sector += 21;
  }

  return sector;
}

function loadAbsSector(d64, absSector) {
  const d64Offset = absSector * 256;
  return d64.slice(d64Offset, d64Offset + 256);
}

function getLoadTrackSectorWithRecurCheck(d64) {
  // Returns a function that will return a sector's bytes, given a track/sector
  // location, and will throw if the same absolute sector is requested twice.
  const seenAbsSectors = new Set();  

  return (track, sector) => {
    const absSector = calcAbsSector(track, sector);

    if (seenAbsSectors.has(absSector)) {
      throw new Error("Chain of disk sector links contains a loop");
    }

    seenAbsSectors.add(absSector);
    return loadAbsSector(d64, absSector);
  }
}

function loadDir(d64) {

  // Directory listing starts at 18/1 (even if 18/0 points elsewhere)
  let track = 18;
  let sector = 1;

  let entries = [];
  const loadTrackSector = getLoadTrackSectorWithRecurCheck(d64);

  while (track) {

    const newEntries = parseDirSector(
      loadTrackSector(track, sector)
    );

    entries = [
      ...entries,
      ...newEntries,
    ];

    track  = newEntries[0].nextTrack;
    sector = newEntries[0].nextSector;
  }

  return entries
    .map(
      (entry) => {
        const { type, ...ret } = entry;

        ret.type = [
          "DEL",
          "SEQ",
          "PRG",
          "USR",
          "REL",
        ][entry.type & 0b111];

        ret.locked = Boolean(entry.type & (1 << 6));
        ret.closed = Boolean(entry.type & (1 << 7));

        return ret;
      }
    )
    .filter(
      // I think this is right? DEL's don't show up in the "$"?
      ({ type }) => (type !== "DEL")
    )
  ;
}

function loadFile(d64, track, sector) {
  let ret = [];
  const loadTrackSector = getLoadTrackSectorWithRecurCheck(d64);

  while (track) {

    const sec = parseFileSector(
      loadTrackSector(track, sector)
    );

    if (!sec.nextTrack) {
      // If the nextTrack value is zero, then nextSector reveals how much of
      // this sector contains file data. †1 implies that if nextSector has a
      // value of 4, then, bearing in mind that the next link's track/sector
      // values are in bytes 0 and 1 respectively, the file data would be in
      // bytes 2, 3, and 4.
      // Thus a '4' would mean a slice parameter of '5' wrt. the raw sector's
      // data, hence a slice parameter of '3' wrt. the parsed `bytes` array
      // from that sector. Hence, in general, slice until `sector` minus one.

      ret = [...ret, ...sec.bytes.slice(0, sec.nextSector - 1)];
    }
    else {
      ret = [...ret, ...sec.bytes];
    }

    track  = sec.nextTrack;
    sector = sec.nextSector;
  }

  return ret;
}


/***/ }),

/***/ "./src/host/ingest-json.js":
/*!*********************************!*\
  !*** ./src/host/ingest-json.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ingest_json: () => (/* binding */ ingest_json)
/* harmony export */ });
// The only file type that can be brought in from JSON is a snapshot.

async function ingest_json(c64, bytes) {
  // Convert the incoming byte array to a string
  let json = "";

  for (let i of bytes) {
    json += String.fromCharCode(i);
  }

  // Once the original snapshot was serialized, it was saved out in a JSON
  // format, meaning yet another layer of the onion. Unpeel that last one
  // to get the original serialiazation (which is in JSON, and encodes yet
  // more JSON in its subsections)
  const snapshot = JSON.parse(json);

  c64.runloop.stop();                // just out of caution
  c64.runloop.reset();               // just out of caution
  c64.runloop.deserialize(snapshot);
  c64.runloop.run();
}


/***/ }),

/***/ "./src/host/ingest-prg.js":
/*!********************************!*\
  !*** ./src/host/ingest-prg.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ingest_prg: () => (/* binding */ ingest_prg)
/* harmony export */ });
/* harmony import */ var _tools_loadPrg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/loadPrg */ "./src/tools/loadPrg.js");
/* harmony import */ var _tools_romLocations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tools/romLocations */ "./src/tools/romLocations.js");

 


async function ingest_prg(c64, bytes) {
  c64.runloop.reset();
  await c64.runloop.untilPc(_tools_romLocations__WEBPACK_IMPORTED_MODULE_1__.AWAIT_KEYBOARD_PC);

  (0,_tools_loadPrg__WEBPACK_IMPORTED_MODULE_0__.loadPrg)(c64, bytes);

  c64.runloop.type("RUN\r");
  c64.runloop.run();
}


/***/ }),

/***/ "./src/host/ingest-sid.js":
/*!********************************!*\
  !*** ./src/host/ingest-sid.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ingest_sid: () => (/* binding */ ingest_sid)
/* harmony export */ });
/* harmony import */ var _tools_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/parser */ "./src/tools/parser.js");
/* harmony import */ var _tools_assembler_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tools/assembler.js */ "./src/tools/assembler.js");
/* harmony import */ var _tools_c64FontCodePoints__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tools/c64FontCodePoints */ "./src/tools/c64FontCodePoints.js");
/* harmony import */ var _tools_romLocations__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tools/romLocations */ "./src/tools/romLocations.js");
/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../debug */ "./src/debug.js");



 



// Format references:
// - https://gist.github.com/cbmeeks/2b107f0a8d36fc461ebb056e94b2f4d6
// - http://unusedino.de/ec64/technical/formats/sidplay.html
//
// (Beware: neither signal very well whether the numbers they quote are
// decimal or hex.)

const parseHeader = (0,_tools_parser__WEBPACK_IMPORTED_MODULE_0__.makeParser)((_) => ({
  magicID:     _.string(4),
  version:     _.word_be(),
  dataOffset:  _.word_be(),
  loadAddress: _.word_be(),
  initAddress: _.word_be(),
  playAddress: _.word_be(),
  songs:       _.word_be(),
  startSong:   _.word_be(),
  speed:       _.long_be(),
  name:        _.string(32),
  author:      _.string(32),
  released:    _.string(32),
}));

async function ingest_sid(c64, bytes) {
  let header;
  
  try {
    header = parseHeader(bytes);
  }
  catch (e) {
    console.error("Unexpected early end of file");
  }

  validate(header);

  let { loadAddress, dataOffset } = header;

  if (loadAddress === 0) {
    // means the load address is at the start of the data secion, like a
    // .prg file
    loadAddress = (
      bytes[dataOffset++] | 
      bytes[dataOffset++] << 8
    );
  }

  const fileData = bytes.slice(dataOffset);

  // It's only 130 bytes or so. Seems a safe place to stash it, no?
  // Just need to careful that it doesn't run into the PAL/NTSC flag at $02a6
  // as SIDs can rely on that.
  const playerOrg = 0x0200;
  // (Postscript: most of Richard Joesph's songs won't play at all with the
  // player org'ed there. Org it somewhere else and they'll play a litte better
  // but still not right. Haven't looked into why.)

  // PSID file is 1-indexed, code expects 0-indexed
  let startSong = (header.startSong - 1) & 0xff;

  playSong(
    c64,
    fileData,
    playerOrg,
    loadAddress,
    header
  );
}

function validate(header) {
  if (header.magicID !== "PSID") {
    throw new Error("Only PSID .sid files can be played.");
  }
}

function showHeader(c64, header, loadAddress, playerAddress, playerLength, loadLength) {

  const stringToScreen = (row, col, string) => {
    string = string.toLowerCase();
    for (let i = 0; i < string.length; i++) {
      c64.wires.cpuWrite(
        0x400 + col + (40 * row) + i, 
        (0,_tools_c64FontCodePoints__WEBPACK_IMPORTED_MODULE_2__.charToC64FontCodePoint)(string[i], true)
      );
      c64.wires.cpuWrite(
        0xd800 + col + (40 * row) + i, 
        15
      );
    }
  };

  stringToScreen( 6, 4, header.name);
  stringToScreen( 7, 4, header.author);
  stringToScreen( 8, 4, header.released);
  stringToScreen(10, 4, `load: ${(0,_debug__WEBPACK_IMPORTED_MODULE_4__.$xxxx)(loadAddress)}-${(0,_debug__WEBPACK_IMPORTED_MODULE_4__.$xxxx)(loadAddress + loadLength)}`);
  stringToScreen(11, 4, `init: ${(0,_debug__WEBPACK_IMPORTED_MODULE_4__.$xxxx)(header.initAddress)}`);
  stringToScreen(12, 4, `play: ${(0,_debug__WEBPACK_IMPORTED_MODULE_4__.$xxxx)(header.playAddress)}`);
  stringToScreen(14, 4, `# songs: ${header.songs} (start ${header.startSong})`);
  stringToScreen(16, 4, `player at ${(0,_debug__WEBPACK_IMPORTED_MODULE_4__.$xxxx)(playerAddress)}-${(0,_debug__WEBPACK_IMPORTED_MODULE_4__.$xxxx)(playerAddress + playerLength)}`);
  stringToScreen(20, 2, `joystick #2 left/right for prev/next`);
}

async function playSong(
  c64,
  fileData,
  playerOrg,
  fileOrg,
  header
) {

  c64.runloop.reset();
  await c64.runloop.untilPc(_tools_romLocations__WEBPACK_IMPORTED_MODULE_3__.READY_PC);

  const { initAddress, playAddress, songs, startSong } = header;

  // Right now the player just uses raster time to cue the PSID's tick routine
  // so we're stuck with 50Hz playback, which a lot of PSID's aren't using.
  // We should use a CIA to fix that.

  const playerData = (0,_tools_assembler_js__WEBPACK_IMPORTED_MODULE_1__.assemble)(
    playerOrg,
    ({
      NOP, LDA, LDX, LDY, STA, STX, STY, CLC, CLD, CLI, CLV, SEC, SED, SEI, 
      TAX, TAY, TSX, TXA, TXS, TYA, CMP, CPX, CPY, BCS, BCC, BEQ, BNE, BMI,
      BPL, BVS, BVC, BIT, JSR, RTS, RTI, BRK, JMP, INC, DEC, DEX, DEY, INX,
      INY, ADC, SBC, AND, EOR, ORA, ASL, ROL, LSR, ROR, PHA, PHP, PLA, PLP,
      _
    }) => {

        // We've come in from Basic, so stop everything
        LDA.imm (0); 
        STA.abs (0xdc0e);           // stop CIA1 timer A
        STA.abs (0xdc0f);           // stop CIA1 timer B
        STA.abs (0xdd0e);           // stop CIA2 timer A
        STA.abs (0xdd0f);           // stop CIA2 timer B

        LDA.zpg (1);                // read processor port
        AND.imm (0xf8);             // clear bottom 3 bits
        ORA.imm (0x05);             // 0b101 = I/O mapped, otherwise max RAM
        STA.zpg (1);                // store processor port

        LDA.imm (startSong - 1);    // header's startSong is 1-indexed
        JMP.abs ("startSong");      // play it and enter loop

      _`main`;
        LDA.abs (0xd012);           // read raster line (bits 0-7)
        CMP.imm (0x40);             // there's no line 0x140, so if bits 0-7
        BNE.rel ("main");           // say 0x40, we're at 0x040. Loop until then.

        LDA.imm (15);
        STA.abs (0xd020);           // light border for the duration of the play routing
        JSR.abs (playAddress);      // call player's tick routine
        LDA.imm (14);
        STA.abs (0xd020);           // bring the border back

        LDX.abs (0xdc00);           // read joystick port 2
        TXA.imp ();
        AND.imm (0b1000);           // right?
        BEQ.rel ("nextSong");
        TXA.imp ();
        AND.imm (0b100);            // left?
        BEQ.rel ("prevSong");

      _`tail`;
        LDA.abs (0xd012);           // no changes to the song. just be sure we're
        CMP.imm (0x40);             // not still on that same 0x040 scanline...
        BEQ.rel ("tail");
        BNE.rel ("main");           // we're not. So now loop until we are.

      _`prevSong`;
        DEC.abs ("song");
        DEC.abs ("song");           // because it falls through...

      _`nextSong`;
        INC.abs ("song");

      _`untilReleased`;
        LDA.abs (0xdc00);           // wait until the joystick's let go of
        CMP.imm (0x7f);             // to prevent a double-advance
        BNE.rel ("untilReleased");

        LDA.abs ("song");           // now let's clamp the song number
        BPL.rel ("clamp");          // if positive, go check it's not too high
        LDA.imm (0);                // was negative so clamp to zero
        BEQ.rel ("startSong");      // play

      _`clamp`;
        CMP.imm (songs);            // already at the last song?
        BNE.rel ("startSong");      // no? kick it
        CLC.imp ();                 // (seriously, why is there no DEC.acc?)
        ADC.imm (0xff);             // decrement back to the last

      _`startSong`;
        STA.abs ("song");           // store post-inc/dec song num

        LDX.imm (0b1000);         
        STX.abs (0xd404);           // stop voice 1
        STX.abs (0xd40b);           // stop voice 2
        STX.abs (0xd412);           // stop voice 3

        LDX.imm (0);
        STX.abs (0xd417);           // reset filters
        STX.abs (0xd418);           // volume 0, reset more filters

        JSR.abs (initAddress);      // call player's init routine for song in acc
        JMP.abs ("main");           // re-run main loop

      _`song`;
        _.bytes(0);                 // current song (init'ed by startSong)
    }
  );

  showHeader(c64, header, fileOrg, playerOrg, playerData.length, fileData.length);

  const { cpuWrite } = c64.wires;

  fileData.forEach(
    (byte, index) => cpuWrite(fileOrg + index, byte)
  );

  playerData.forEach(
    (byte, index) => cpuWrite(playerOrg + index, byte)
  );

  c64.cpu.getState().pc = playerOrg;
  c64.runloop.run();
}


/***/ }),

/***/ "./src/host/ingest-t64.js":
/*!********************************!*\
  !*** ./src/host/ingest-t64.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ingest_t64: () => (/* binding */ ingest_t64)
/* harmony export */ });
/* harmony import */ var _tools_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/parser */ "./src/tools/parser.js");
/* harmony import */ var _tools_loadPrg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tools/loadPrg */ "./src/tools/loadPrg.js");
/* harmony import */ var _tools_romLocations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tools/romLocations */ "./src/tools/romLocations.js");


 


// Format references:
//    http://unusedino.de/ec64/technical/formats/t64.html
//    https://vice-emu.sourceforge.io/vice_16.html

const parseHeader = (0,_tools_parser__WEBPACK_IMPORTED_MODULE_0__.makeParser)((_) => ({
  desc:        _.string(32),
  version:     _.word_le(),
  entries:     _.word_le(),
  usedEntries: _.word_le(),
  _:           _.skip(2),
  userDesc:    _.string(24),

  // The below should have its own separate structure, as theoretically
  // there's a sequence of multiple instances of it
  entryType:   _.byte(),
  fileType:    _.byte(),
  startAddr:   _.word_le(),
  endAddr:     _.word_le(),
  _:           _.skip(2),
  start:       _.long_le(),
  _:           _.skip(4),
  filename:    _.string(16),
}));

async function ingest_t64(c64, bytes) {
  let header;
  
  try {
    header = parseHeader(bytes);
  }
  catch (e) {
    console.error("Unexpect early end to file");
  }

  validate(header);

  const prg = [
    header.startAddr & 0xff,
    header.startAddr >> 8,
    ...bytes.slice(header.start)
  ];

  c64.runloop.reset();
  await c64.runloop.untilPc(_tools_romLocations__WEBPACK_IMPORTED_MODULE_2__.AWAIT_KEYBOARD_PC);

  (0,_tools_loadPrg__WEBPACK_IMPORTED_MODULE_1__.loadPrg)(c64, prg);

  c64.runloop.type("RUN\r");
  c64.runloop.run();
}

function validate(header) {
  // General policy is that we'll waive as much as we possibly can with
  // warnings, and only error if we absolutely can't load the file

  const warn = console.warn;

  if (header.usedEntries !== 1) {
    // I've seen an otherwise working .t64 report zero used entries, so waive
    // what you'd think would be a breaking case.
    warn(`.t64 file has ${header.usedEntries} used entries. One was expected.`);
  }

  if (header.startAddr !== 0x0801) {
    warn(".t64 file start address isn't $0801");
  }

  // We ignore the end addr

  if (header.entryType !== 1) {
    warn(`.t64 error: only entry type 1 supported (got ${header.entryType})`);
  }

  // Should try warn if the file size doesn't match what we'd expect from the
  // header, though this happens commonly for files that otherwise work.
}


/***/ }),

/***/ "./src/host/ingest-tap.js":
/*!********************************!*\
  !*** ./src/host/ingest-tap.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ingest_tap: () => (/* binding */ ingest_tap)
/* harmony export */ });
/* harmony import */ var _tools_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/parser */ "./src/tools/parser.js");
/* harmony import */ var _tools_romLocations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tools/romLocations */ "./src/tools/romLocations.js");

 


// Format references:
//    http://wav-prg.sourceforge.net/tape.html
//    http://unusedino.de/ec64/technical/formats/tap.html

const parseTap = (0,_tools_parser__WEBPACK_IMPORTED_MODULE_0__.makeParser)((_) => ({
  header:   _.string(20),
  contents: _.remainder(),
}));

async function ingest_tap(c64, bytes) {

  const struct = parseTap(bytes);

  validate(struct);

  c64.runloop.reset();
  await c64.runloop.untilPc(_tools_romLocations__WEBPACK_IMPORTED_MODULE_1__.AWAIT_KEYBOARD_PC);

  c64.tape.setImage(bytes.slice(20));

  c64.runloop.type("LOAD\r");
  c64.runloop.run();
  c64.tape.pressPlay();
}

function validate(struct) {
  // In my experience, headers are always
  //    "C64-TAPE-RAW"
  // or "C64-TAPE-RAW\u0001"

  if (struct.header.indexOf("C64-TAPE-RAW") !== 0) {
    console.warn(
      "Expected to find 'C64-TAPE-RAW' in header, but got:",
      struct.header
    );
  }
}


/***/ }),

/***/ "./src/host/ingest.js":
/*!****************************!*\
  !*** ./src/host/ingest.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ingest: () => (/* binding */ ingest)
/* harmony export */ });
/* harmony import */ var _ingest_prg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ingest-prg */ "./src/host/ingest-prg.js");
/* harmony import */ var _ingest_t64__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ingest-t64 */ "./src/host/ingest-t64.js");
/* harmony import */ var _ingest_d64__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ingest-d64 */ "./src/host/ingest-d64.js");
/* harmony import */ var _ingest_sid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ingest-sid */ "./src/host/ingest-sid.js");
/* harmony import */ var _ingest_tap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ingest-tap */ "./src/host/ingest-tap.js");
/* harmony import */ var _ingest_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ingest-json */ "./src/host/ingest-json.js");







const ingestors = [
  [/\.prg$/i , _ingest_prg__WEBPACK_IMPORTED_MODULE_0__.ingest_prg  ],
  [/\.t64$/i , _ingest_t64__WEBPACK_IMPORTED_MODULE_1__.ingest_t64  ],
  [/\.d64$/i , _ingest_d64__WEBPACK_IMPORTED_MODULE_2__.ingest_d64  ],
  [/\.sid$/i , _ingest_sid__WEBPACK_IMPORTED_MODULE_3__.ingest_sid  ],
  [/\.tap$/i , _ingest_tap__WEBPACK_IMPORTED_MODULE_4__.ingest_tap  ],
  [/\.json$/i, _ingest_json__WEBPACK_IMPORTED_MODULE_5__.ingest_json ],
];

async function ingest(c64, filename, bytes) {
  try {

    for (let [regex, fn] of ingestors) {
      if (regex.test(filename)) {
        await fn(c64, bytes);

        if (c64.hooks.setTitle) {
          c64.hooks.setTitle(filename);
        }

        return;
      }
    }

    throw new Error("Can’t guess file format from name, or format is unsupported.");
  }
  catch (e) {
    const { message } = e;
    console.error(e);
    if (c64.hooks.reportError) c64.hooks.reportError(message);
    else alert(message);
  }
}


/***/ }),

/***/ "./src/host/joystick-KeyboardEvent.js":
/*!********************************************!*\
  !*** ./src/host/joystick-KeyboardEvent.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   attach: () => (/* binding */ attach)
/* harmony export */ });
// bound by attach
let c64;

// Populated by cias
let setJoystick1 = () => {};
let setJoystick2 = () => {};

// Called during initialization to tell the keyboard event handler how to send
// key matrices to CIA1.
function setSetJoystick1(fn) { setJoystick1 = fn; }
function setSetJoystick2(fn) { setJoystick2 = fn; }


const JOSTICK_UP    = 0x01;
const JOSTICK_DOWN  = 0x02;
const JOSTICK_LEFT  = 0x04;
const JOSTICK_RIGHT = 0x08;
const JOSTICK_FIRE  = 0x10;

let buttonsDown = new Set();

function eventToJoystickButton(event) {
  switch (event.key) {
    case "Shift":      return JOSTICK_FIRE;
    case "ArrowUp":    return JOSTICK_UP;
    case "ArrowDown":  return JOSTICK_DOWN;
    case "ArrowLeft":  return JOSTICK_LEFT;
    case "ArrowRight": return JOSTICK_RIGHT;
  }
}

function tellCia() {
  let byte = 0;

  for (let val of buttonsDown.values()) {
    byte |= val;
  }

  // values float high; the buttons pull them low
  if (c64.joystick.toControlPort1) setJoystick1((~byte) & 0xff);
  if (c64.joystick.toControlPort2) setJoystick2((~byte) & 0xff);
}

globalThis.addEventListener(
  "keydown",
  event => {
    const setKey = eventToJoystickButton(event);
    if (!setKey) return;

    buttonsDown.add(setKey);
    tellCia();
  }
);

globalThis.addEventListener(
  "keyup",
  event => {
    const setKey = eventToJoystickButton(event);
    if (!setKey) return;

    buttonsDown.delete(setKey);
    tellCia();
  }
);

globalThis.addEventListener(
  "blur",
  event => {
    buttonsDown.clear();
    tellCia();
  }
);

function attach(nascentC64) {

  c64 = nascentC64;
  // TODO: this should be where we set up the event listeners

  nascentC64.joystick = {
    setSetJoystick1,
    setSetJoystick2,
    toControlPort1: false,
    toControlPort2: true,
  };
}


/***/ }),

/***/ "./src/host/keyboard-KeyboardEvent.js":
/*!********************************************!*\
  !*** ./src/host/keyboard-KeyboardEvent.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   attach: () => (/* binding */ attach),
/* harmony export */   setSetKeyMatrix: () => (/* binding */ setSetKeyMatrix)
/* harmony export */ });
/* harmony import */ var _keyboard_natural__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keyboard-natural */ "./src/host/keyboard-natural.js");
/* harmony import */ var _keyboard_direct__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keyboard-direct */ "./src/host/keyboard-direct.js");
/* harmony import */ var _buttonNameToMatrixPos__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./buttonNameToMatrixPos */ "./src/host/buttonNameToMatrixPos.js");






// Bound by attach
let c64;

// Populated by setSetKeyMatrix;
let setKeyMatrix = () => {};

/*
   keyStack: an event stack that chronicles which C64 keyboard buttons (let's
   call them 'buttons' and those of host machine's, 'keys') got held down when.

   Example: if you were to hold down your Shift key, then your 8 key, keyStack
   would be:

      [
        { code: "Digit8", buttonCodes: [...] },
        { code: "ShiftLeft", buttonCodes: [...] }
      ]

   ...where buttonCodes is an array of names of C64 buttons (see
   buttonNameToMatrixPos) that corresponded to the keyboard event, and varies
   depending on the keyboard mapper used.

   The 'natural' keyboard mapping, for example, would have identified that the
   event that had the `code` of Digit8 was an asterisk press (in the case of a
   US keyboard); thus would record ["Asterisk"] in buttonCodes, whereas the
   'direct' keyboard mapping would record it as ["Num8"].

   When new keys are pressed, they're pushed/moved to the front of the stack.
   Released keys are removed from the stack.

   It's important to note that the `code` of the stack entries is the `code`
   field of a DOM keyboard event, and, in spite of the names of its values,
   represents the position of a key, not the symbol it represents. We use this
   position information for identifying, in the keyup, which stack entry was
   generated by the original keydown. Had we used `event.key` instead, keys
   would jam in cases like:

          (hold-shift, hold-R, release-shift, release-R)

   ...where the events we'll receive would have a keydown for "R", but a keyup
   for "r", and we'd be stuck with the "R" on the keyStack.
*/

let keyStack = [
  // {
  //   code
  //   buttonNames
  // }
];

function getEventToButtonNames() {
  return (
    c64.keyboard.naturalMapping
    ? _keyboard_natural__WEBPACK_IMPORTED_MODULE_0__.eventToButtonNames
    : _keyboard_direct__WEBPACK_IMPORTED_MODULE_1__.eventToButtonNames
  );
}

function getKeyStackToButtonNames() {
  return (
    c64.keyboard.naturalMapping
    ? _keyboard_natural__WEBPACK_IMPORTED_MODULE_0__.keyStackToButtonNames
    : _keyboard_direct__WEBPACK_IMPORTED_MODULE_1__.keyStackToButtonNames
  );
}


function attach(nascentC64) {
  c64 = nascentC64;

  c64.keyboard = {
    setSetKeyMatrix,
    cursorsToKeys: true,
    naturalMapping: true,
  };

  globalThis.addEventListener("keydown", onKeyDown);
  globalThis.addEventListener("keyup",   onKeyUp);
  globalThis.addEventListener("blur",    onBlur);
}

// Called during initialization to tell the keyboard event handler how to send
// key matrices to CIA1.
function setSetKeyMatrix(_setKeyMatrix) {
  setKeyMatrix = _setKeyMatrix;
}

function buttonNamesToKeyMatrix(buttonNames) {
  const keyMatrix = [0, 0, 0, 0, 0, 0, 0, 0];

  for (let buttonName of buttonNames) {
    const [column, row] = _buttonNameToMatrixPos__WEBPACK_IMPORTED_MODULE_2__.buttonNameToMatrixPos[buttonName];
    keyMatrix[column] |= (1 << row);
  }

  setKeyMatrix(keyMatrix);
}


function onKeyDown(event) {
  // Any keypress with the Meta key (cmd/ctrl/...) down isn't for us.
  if (event.metaKey) return;

  // Shift/Cursors may be disabled for keyboards so that they can go to the
  // joysticks only (otherwise games like Buggy Boy get stuck)
  if (!c64.keyboard.cursorsToKeys) {
    if (event.key === "Shift")      return;
    if (event.key === "ArrowUp")    return;
    if (event.key === "ArrowDown")  return;
    if (event.key === "ArrowLeft")  return;
    if (event.key === "ArrowRight") return;
  }

  // Map the event to a list of C64 buttons that the keypress corresponds to
  // (if any)
  const buttonNames = getEventToButtonNames()(event);
  if (!buttonNames) return;

  // For debug
  if (globalThis.inhibitKeyboard) return;

  // Associate the position-centric event.code with the names of the buttons it
  // translates to
  keyStack = [
    {
      code: event.code,
      buttonNames
    },
    ...keyStack.filter(
      ({ code }) => (code !== event.code)
    )
  ];

  // Make available to CIA1
  buttonNamesToKeyMatrix(
    getKeyStackToButtonNames()(keyStack)
  );

  event.preventDefault();
}

function onKeyUp(event) {
  const buttonNames = getEventToButtonNames()(event);
  if (!buttonNames) return;

  keyStack = keyStack.filter(
    ({ code }) => (code !== event.code)
  );

  buttonNamesToKeyMatrix(
    getKeyStackToButtonNames()(keyStack)
  );

  event.preventDefault();
}

function onBlur(event) {
  // All bets are off when we lose focus. So assume all keys got released.
  keyStack = [];
  buttonNamesToKeyMatrix([]);
}


/***/ }),

/***/ "./src/host/keyboard-direct.js":
/*!*************************************!*\
  !*** ./src/host/keyboard-direct.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   eventToButtonNames: () => (/* binding */ eventToButtonNames),
/* harmony export */   keyStackToButtonNames: () => (/* binding */ keyStackToButtonNames)
/* harmony export */ });
/*
   "Direct" keyboard mapping: translates what key you press on your keyboard to
   the C64 key in a roughly-corresponding position (see images at
   https://www.c64-wiki.com/wiki/Keyboard). Notable exceptions are:
  
     * RUN STOP is moved to Escape.
     * ← and ↑ are moved to cursor-left and cursor-up. Those two were unused
       as the C64 requires you to use shift+cursor-right and shift+cursor-up
       for them anyways.
       (Like, seriously, £, @, ← and ↑ got their own buttons, but cursor-up and
       cursor-left had to share?!)
     * = is moved to the backslash above Enter (on a US keyboard)
     * £ is moved to the backtick to the left of 1 (on a US keyboard)
     * CLR HOME is moved to F8, and, if your keyboard features it, Home. If
       you have a numeric keypad with a Clear key (like the Mac extended
       keyboard), it will effect a left-shift and CLR HOME.
     * RESTORE is presently unmapped, mostly because it's connected to the NMI
       line rather than the keyboard matrix. Still, it would be nice to get it
       in someday, not that we have an obvious physical space for it.

   Reference: see
     https://hacks.mozilla.org/2017/03/internationalize-your-keyboard-controls/
  
   Note that, unlike event.key, and unlike what the names of its values would
   suggest, event.code tells you the physical location of the key that was
   pressed. So an event.code of "KeyQ" means you'd hit the "Q" of a QWERTY
   keyboard *or* the "A" of a French AZERTY keyboard. A "KeyY" means you'd hit
   the Y of a QWERTY keyboard, or the Z of a German QWERTZ keyboard.
*/

const eventCodeToButtonNames = {

  // Top row, left-to-right
  "ArrowLeft":      ["LeftArrow"],    // Not where you might expect
  "Digit1":         ["Num1"],
  "Digit2":         ["Num2"],
  "Digit3":         ["Num3"],
  "Digit4":         ["Num4"],
  "Digit5":         ["Num5"],
  "Digit6":         ["Num6"],
  "Digit7":         ["Num7"],
  "Digit8":         ["Num8"],
  "Digit9":         ["Num9"],
  "Digit0":         ["Num0"],
  "Minus":          ["Plus"],
  "Equal":          ["Minus"],
  "Backquote":      ["Pound"],        // Not where you might expect
  "F8":             ["ClrHome"],      // Not where you might expect
  "Backspace":      ["InstDel"],

  // Second row, left-to-right
  "Tab":            ["Ctrl"],
  "KeyQ":           ["Q"],
  "KeyW":           ["W"],
  "KeyE":           ["E"],
  "KeyR":           ["R"],
  "KeyT":           ["T"],
  "KeyY":           ["Y"],
  "KeyU":           ["U"],
  "KeyI":           ["I"],
  "KeyO":           ["O"],
  "KeyP":           ["P"],
  "BracketLeft":    ["At"],
  "BracketRight":   ["Asterisk"],
  "ArrowUp":        ["UpArrow"],      // Not where you might expect

  // Third row, left-to-right
  "Escape":         ["RunStop"],
  "KeyA":           ["A"],
  "KeyS":           ["S"],
  "KeyD":           ["D"],
  "KeyF":           ["F"],
  "KeyG":           ["G"],
  "KeyH":           ["H"],
  "KeyJ":           ["J"],
  "KeyK":           ["K"],
  "KeyL":           ["L"],
  "Semicolon":      ["Colon"],
  "Quote":          ["Semicolon"],
  "Backslash":      ["Equal"],        // Not where you might expect
  "Enter":          ["Return"],

  // Fourth row, left-to-right
  "AltLeft":        ["Commodore"],
  "ShiftLeft":      ["LeftShift"],
  "KeyZ":           ["Z"],
  "KeyX":           ["X"],
  "KeyC":           ["C"],
  "KeyV":           ["V"],
  "KeyB":           ["B"],
  "KeyN":           ["N"],
  "KeyM":           ["M"],
  "Comma":          ["Comma"],
  "Period":         ["Period"],
  "Slash":          ["Slash"],
  "ShiftRight":     ["RightShift"],
  "ArrowDown":      ["CursorDown"],
  "ArrowRight":     ["CursorRight"],

  // Fifth row, left-to-right
  "Space":          ["Space"],

  // Function keys
  "F1":             ["F1"],
  "F3":             ["F3"],
  "F5":             ["F5"],
  "F7":             ["F7"],

  // Above that's a 1:1 mapping of everything. Now let's map some extra keys,
  // if your keyboard has them, to something vaguely intuitive:
  "Home":           ["ClrHome"],
  "Clear":          ["Home", "LeftShift"],
  "Delete":         ["InstDel"],
  "Numpad0":        ["Num0"],
  "Numpad1":        ["Num1"],
  "Numpad2":        ["Num2"],
  "Numpad3":        ["Num3"],
  "Numpad4":        ["Num4"],
  "Numpad5":        ["Num5"],
  "Numpad6":        ["Num6"],
  "Numpad7":        ["Num7"],
  "Numpad8":        ["Num8"],
  "Numpad9":        ["Num9"],
  "NumpadEqual":    ["Equal"],
  "NumpadDivide":   ["Slash"],
  "NumpadMultiply": ["Asterisk"],
  "NumpadSubtract": ["Minus"],
  "NumpadAdd":      ["Plus"],
  "NumpadEnter":    ["Return"],
  "F2":             ["F1", "LeftShift"],
  "F4":             ["F3", "LeftShift"],
  "F6":             ["F5", "LeftShift"],
  "F8":             ["F7", "LeftShift"],
}

function eventToButtonNames(event) {
  return eventCodeToButtonNames[event.code];
}

function keyStackToButtonNames(keyStack) {
  // For the direct keyboard handler, we're stacking all the pressed keys on
  // top of each other.
  const buttons = new Set();

  keyStack.forEach(
    ({ buttonNames }) => (
      buttonNames.forEach(
        buttonName => buttons.add(buttonName)
      )
    )
  );

  return Array.from(buttons);
}


/***/ }),

/***/ "./src/host/keyboard-natural.js":
/*!**************************************!*\
  !*** ./src/host/keyboard-natural.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   eventToButtonNames: () => (/* binding */ eventToButtonNames),
/* harmony export */   keyStackToButtonNames: () => (/* binding */ keyStackToButtonNames)
/* harmony export */ });
/*
   "Natural" keyboard mapping: tries to map what was written on your key to a
   combination of C64 physical keys. Convenient for typing, but makes many C64
   keys, or key combinations, inaccessible.

   There is a problem with this approach: pressing repeated asterisks (if
   that's Shift-8 on your keyboard) alternates between telling the virtual
   machine that only SHIFT is pressed, and only the * key is pressed. If that
   transition happens in the middle of the keyboard matrix scan, it can look
   like both are pressed, resulting in a shifted-* key getting typed (a PETSCII
   horizontal line character). It's not as difficult to achieve as you might
   think.

   Arguably we shouldn't be sending shift-on-its-own to the virtual machine.
*/

const eventKeyToButtonNames = {
  "a":          ["A"],
  "b":          ["B"],
  "c":          ["C"],
  "d":          ["D"],
  "e":          ["E"],
  "f":          ["F"],
  "g":          ["G"],
  "h":          ["H"],
  "i":          ["I"],
  "j":          ["J"],
  "k":          ["K"],
  "l":          ["L"],
  "m":          ["M"],
  "n":          ["N"],
  "o":          ["O"],
  "p":          ["P"],
  "q":          ["Q"],
  "r":          ["R"],
  "s":          ["S"],
  "t":          ["T"],
  "u":          ["U"],
  "v":          ["V"],
  "w":          ["W"],
  "x":          ["X"],
  "y":          ["Y"],
  "z":          ["Z"],

  "A":          ["A", "LeftShift"],
  "B":          ["B", "LeftShift"],
  "C":          ["C", "LeftShift"],
  "D":          ["D", "LeftShift"],
  "E":          ["E", "LeftShift"],
  "F":          ["F", "LeftShift"],
  "G":          ["G", "LeftShift"],
  "H":          ["H", "LeftShift"],
  "I":          ["I", "LeftShift"],
  "J":          ["J", "LeftShift"],
  "K":          ["K", "LeftShift"],
  "L":          ["L", "LeftShift"],
  "M":          ["M", "LeftShift"],
  "N":          ["N", "LeftShift"],
  "O":          ["O", "LeftShift"],
  "P":          ["P", "LeftShift"],
  "Q":          ["Q", "LeftShift"],
  "R":          ["R", "LeftShift"],
  "S":          ["S", "LeftShift"],
  "T":          ["T", "LeftShift"],
  "U":          ["U", "LeftShift"],
  "V":          ["V", "LeftShift"],
  "W":          ["W", "LeftShift"],
  "X":          ["X", "LeftShift"],
  "Y":          ["Y", "LeftShift"],
  "Z":          ["Z", "LeftShift"],

  "0":          ["Num0"],
  "1":          ["Num1"],
  "2":          ["Num2"],
  "3":          ["Num3"],
  "4":          ["Num4"],
  "5":          ["Num5"],
  "6":          ["Num6"],
  "7":          ["Num7"],
  "8":          ["Num8"],
  "9":          ["Num9"],

  "!":          ["Num1", "LeftShift"],
  '"':          ["Num2", "LeftShift"],
  "#":          ["Num3", "LeftShift"],
  "$":          ["Num4", "LeftShift"],
  "%":          ["Num5", "LeftShift"],
  "&":          ["Num6", "LeftShift"],
  "'":          ["Num7", "LeftShift"],
  "(":          ["Num8", "LeftShift"],
  ")":          ["Num9", "LeftShift"],

  " ":          ["Space"],
  "Backspace":  ["InstDel"],
  "Enter":      ["Return"],
  "Escape":     ["RunStop"],

  "+":          ["Plus"],
  "-":          ["Minus"],
  "=":          ["Equal"],
  "@":          ["At"],
  "£":          ["Pound"],
  "*":          ["Asterisk"],
  ",":          ["Comma"],
  ".":          ["Period"],
  "/":          ["Slash"],
  "?":          ["Slash", "LeftShift"],
  ":":          ["Colon"],
  ";":          ["Semicolon"],
  "[":          ["Colon", "LeftShift"],
  "]":          ["Semicolon", "LeftShift"],

  "Shift":      ["LeftShift"],
  "Home":       ["ClrHome"],
  "ArrowLeft":  ["CursorRight", "LeftShift"],
  "ArrowRight": ["CursorRight"],
  "ArrowUp":    ["CursorDown", "LeftShift"],
  "ArrowDown":  ["CursorDown"],

  "F1":         ["F1"],
  "F2":         ["F1", "LeftShift"],
  "F3":         ["F3"],
  "F4":         ["F3", "LeftShift"],
  "F5":         ["F5"],
  "F6":         ["F5", "LeftShift"],
  "F7":         ["F7"],
  "F8":         ["F7", "LeftShift"],

  // We're not going to translate all of our Unicode translations (see
  // videoAsAnsi.js) back to PETSCII, but we'll make an exception for π, since
  // Basic understands it as a token.
  "π":          ["UpArrow", "LeftShift"],

  // Not literal; provided for convenience
  "`":          ["LeftArrow"],
  "~":          ["UpArrow"],
  "\\":         ["ClrHome"],
  "|":          ["ClrHome", "LeftShift"],
  "^":          ["Commodore", "LeftShift"],
  "_":          ["RunStop", "LeftShift"],
  "{":          ["Ctrl", "Num9"],
  "}":          ["Ctrl", "Num0"],
};

function eventToButtonNames(event) {
  return eventKeyToButtonNames[event.key];
}

function keyStackToButtonNames(keyStack) {
  // For the natural keyboard handler, only the buttons for the most recent key
  // event are held. Thus, if you type an asterisk by Shift-8 (eg. on a US
  // keyboard), the result will be just the single key, ["Asterisk"], not
  // the combination ["Asterisk, LeftShift"], which corresponds to a PETSCII
  // horizontal line character.
  if (!keyStack.length) return [];
  return keyStack[0].buttonNames;
}


/***/ }),

/***/ "./src/host/video-canvas.js":
/*!**********************************!*\
  !*** ./src/host/video-canvas.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   attach: () => (/* binding */ attach),
/* harmony export */   setHasScope: () => (/* binding */ setHasScope),
/* harmony export */   setHasSnapshots: () => (/* binding */ setHasSnapshots),
/* harmony export */   setHasTrays: () => (/* binding */ setHasTrays)
/* harmony export */ });
// References:
// †1 http://www.zimmers.net/cbmpics/cbm/c64/vic-ii.txt

// A PAL frame (†1) is 312 lines of 504 pixels each. (8 pixels/cycle, 63 cycles
// per line). The emulated Vic will call our setPixel for each of those 157,248
// virtual pixels, many of which are in the hblank or vblank, and it's up to
// this interface to discard those.
//
// According to that same source, there are 284 visible lines of 403 visible
// pixels each. I'm coercing those numbers a little to get the dimentions
// below, and they'll likely change when the Vic emulation gets more cycle-
// accurate.


// Constants that may be variable in future
// x and y position (as arguments to setPixel) for first visible pixels
let first_x = 95;
let first_y = 10;

let canvas_w = 402;
let canvas_h = 282;

const SCOPE_WIDTH = 274;
const TRAY_HEIGHT = 70;     // TODO: unless the window is narrow
const SNAPSHOTS_WIDTH = 150;

let canvas;
let context;
let imageData;
let bitmap;
let showingTrays     = false;
let showingScope     = false;
let showingSnapshots = false;

function attach(nascentC64) {
  nascentC64.video = {
    // Control
    reset,
    // Interface-specific handlers
    setPixel,
    blit,
  };

  createCanvas();
}

function reset() {
  clearCanvas();
}

function createCanvas() {
  canvas = document.getElementById("canvas");
  canvas.setAttribute("width",  canvas_w);
  canvas.setAttribute("height", canvas_h);

  context = canvas.getContext("2d");
  imageData = context.getImageData(0, 0, canvas_w, canvas_h);
  bitmap = imageData.data;  
  clearCanvas();

  positionCanvas();
  window.addEventListener("resize", onResize);
}

function setHasScope(hasScope) {
  showingScope = hasScope;
  positionCanvas();
}

function setHasTrays(hasTrays) {
  showingTrays = hasTrays;
  positionCanvas();
}

function setHasSnapshots(hasSnapshots) {
  showingSnapshots = hasSnapshots;
  positionCanvas();
}

function onResize() {
  // Don't allow the canvas size transition to happen when the window resizes,
  // or it'll be a slow gloopy mess.
  requestAnimationFrame(
    () => {
      canvas.classList.add("no-transition");
      requestAnimationFrame(
        () => {
          positionCanvas();
          requestAnimationFrame(
            () => {
              canvas.classList.remove("no-transition");
            }
          );            
        }
      );
    }
  );
}

function positionCanvas() {
  const { innerWidth, innerHeight } = window;

  // First assess the extents of the potential area into which the canvas could
  // be positioned.

  // availWidth/Height, min/maxUsableX/Y: areas of the window not occupied by
  // the trays/rails.
  let availWidth  = innerWidth;
  let availHeight = innerHeight;
  let minUsableX  = 0;
  let maxUsableX  = innerWidth;
  let minUsableY  = 0;
  let maxUsableY  = innerHeight;

  if (showingScope) {
    availWidth -= SCOPE_WIDTH;
    maxUsableX -= SCOPE_WIDTH;
  }
  
  if (showingTrays) {
    availHeight -= 2 * TRAY_HEIGHT;
    minUsableY += TRAY_HEIGHT;
    maxUsableY -= TRAY_HEIGHT;
  }

  if (showingSnapshots) {
    availWidth -= SNAPSHOTS_WIDTH;
    minUsableX += SNAPSHOTS_WIDTH;
  }

  // Now consider its width and height: fill the available width or height
  // depending on which constrains us first.

  const srcRatio = canvas_w / canvas_h;
  let w, h;

  if ((availWidth / availHeight) > srcRatio) {
    // canvas has a wider ratio so bound it by height
    h = availHeight;
    w = availHeight * srcRatio;
  }
  else {
    // canvas has a taller ratio so bound it by width
    h = availWidth / srcRatio;
    w = availWidth;
  }

  // Finally consider centering. We'll first try centering within the original
  // window rather than within the whittled down-space. If we'd hit a rail in
  // doing so, nudge it until it's only just touching that rail.

  let idealX = (innerWidth - w) / 2;
  let x;

  if (idealX < minUsableX) x = minUsableX;
  else if ((idealX + w) >= maxUsableX) x = maxUsableX - w;
  else x = idealX;

  // Vertical centering's easy: either both trays are showing, or neither are.
  // And they'd both the same height, so the calculation can ignore them.

  let y = minUsableY;
  y += (availHeight - h) / 2;

  canvas.setAttribute(
    "style",
    `width: ${Math.round(w)}px;` +
    `height: ${Math.round(h)}px;` +
    `left: ${Math.round(x)}px;` +
    `top: ${Math.round(y)}px;`
  );
}

function clearCanvas() {
  let index = 0;

  for (let y = 0; y < canvas_h; y++) {
    for (let x = 0; x < canvas_w; x++) {
      bitmap[index++] = 0;
      bitmap[index++] = 0;
      bitmap[index++] = 0; 
      bitmap[index++] = 255;
    }
  }

  blit();
}

function setPixel(x, y, r, g, b) {
  x -= first_x;
  y -= first_y;

  if ((x < 0) || (x >= canvas_w)) return;
  if ((y < 0) || (y >= canvas_h)) return;

  let index = (((y * canvas_w) + x) * 4);

  // Relies on the alpha values having already been set by clearCanvas
  bitmap[index++] = r;
  bitmap[index++] = g;
  bitmap[index  ] = b;
}

function blit() {
  context.putImageData(imageData, 0, 0); 
}


/***/ }),

/***/ "./src/host/webFrontEnd/collisionScope.js":
/*!************************************************!*\
  !*** ./src/host/webFrontEnd/collisionScope.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   collision: () => (/* binding */ collision)
/* harmony export */ });
// bound by attach
let c64;

const allOffState = {
  ignoreSprSpr: false,
  ignoreSprBg:  false,
  dontVis:      false,
};

const desiredState = { ...allOffState };

const checkboxes = [
  { domId: "noSprSprColButton", desiredStateKey: "ignoreSprSpr" },
  { domId: "noSprBgColButton",  desiredStateKey: "ignoreSprBg"  },
  { domId: "noVisColButton",    desiredStateKey: "dontVis"      },
];

function attach(nascentC64) {
  c64 = nascentC64;

  for (let { domId, desiredStateKey } of checkboxes) {
    attachEventHandler(domId, desiredStateKey);
  }
}

function applyState(state) {
  c64.vic.setScope(state.dontVis ? null : "scopeCollision");
  c64.vic.setIgnoreSprBgCol (state.ignoreSprBg);
  c64.vic.setIgnoreSprSprCol(state.ignoreSprSpr);
}

function setCheckboxesFromState(state) {
  for (let { domId, desiredStateKey } of checkboxes) {
    const { classList } = document.getElementById(domId);
    classList.remove("selected");
    if (state[desiredStateKey]) classList.add("selected");
  }
}

function attachEventHandler(domId, desiredStateKey) {
  document
    .getElementById(domId)
    .addEventListener(
      "click",
      (event) => {
        desiredState[desiredStateKey] = !desiredState[desiredStateKey];
        setCheckboxesFromState(desiredState);
        applyState(desiredState);
      }
    )
  ;
}

const collision = {
  domId:   "collisionScope",
  onEnter: () => applyState(desiredState),
  onExit:  () => applyState({ ...allOffState, dontVis: true }),
  attach,
};


/***/ }),

/***/ "./src/host/webFrontEnd/demos/first_prg.js":
/*!*************************************************!*\
  !*** ./src/host/webFrontEnd/demos/first_prg.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tools_base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/base64 */ "./src/tools/base64.js");


// Thank you Jason
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_tools_base64__WEBPACK_IMPORTED_MODULE_0__.base64Decode)("AQgLCIQhnjIwNjEAAACpAEy3CAAJLAAAI3vdAgAAAAAAEAgEAACn9ugAABkEAwAAxvnG+7H4kfrI0PnG/NDxpv+9AAGF+r0FAYX7oAC9DwHwEYX8sf2R+sjQ+eb+5vvG/NDxvQoB8BWF/LH9kfrIxPzQ95gYZf2F/ZAC5v7KEMGl9/Aohfup2IX+oACE/YT6ogPGAbH9kfrI0Pnm/ub7yhDyisb7oPiR+sjQ+6kcjfgHqTeFAUwACHii/5rYSK2mAikBSKWiSKk3hQEghP+iLr1GCZ3/z8rQ96kHjQDdqQCdANidANmdANqdANvo0PGiHakPnS3YyhD6og69dQmdXNjKEPegyKInqQHgB/AFsAWpDSypB4iZoNiZQNnKEOuY0OSpDJkw2sjAoND4qTSFAakDjSgDqQiNKQOgpbkRCJn2AIjQ90wUAQCSAAAAAAAAAAAAAAAAAAAAazcAAAEIABYPAAAAAAAAAAABAgMEAAYCAwQFBgcJCwgMCg8HAQ0HAwwOBAYgICAgcEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQG4gICAgICAgIF1QU0lENjQgFjEuMSACGSBSDwwBDgQgSAUSDQEOEyFdICAgICAgICBtQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTgENBSAgIDogRklSU1QgICAgICAgICAgICAgICAgICAgICAgICAgIEEVFAgPEiA6IEoBEw8OIFABBwUgICAgICAgICAgICAgICAgICAgICBSBQwFARMFOiAyMDE1LTA5LTI2ICAgICAgICAgICAgICAgICAgICAgTA8BBCAgIDogJDEwMDAtJDI5QTcgICAgICAgICAgICAgICAgICAgIEkOCRQgICA6ICQxMDAwICAgICAgICAgICAgICAgICAgICAgICAgICBQDAEZICAgOiAkMTAwMyAgICAgICAgICAgICAgICAgICAgICAgICAgUw8OBxMgIDogMSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEYMAQcTICA6IFBBTCwgODU4MCAgICAgICAgICAgICAgICAgICAgICBDDA8DCyAgOiAgIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgGzEdIFMFDAUDFCATDw4HIBsrHSBOBRgUIBMPDgcgICAgICAgIBstHSBQEgUWCQ8VEyATDw4HIBtERUwdIEIMAQ4LIBMDEgUFDiAgGx8dIEYBExQgBg8SFwESBCAbTE9DSx0gUwgPFyASARMUBRIgFAkNBSAgG1JVTi9TVE9QHSBTFA8QIBtDVFJMK0NCTStERUwdIFIFEwUUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVwUCEwkUBTogCBQUEDovLxATCQQ2NC4TDxUSAwUGDxIHBS4OBRQgTIkITLIJTAAQTAMQAQEAAAAFNzcAAAAbAAAAAAAAAAgAAQMEgAjCCYgIrSDQSK0A3Eip/Y0A3K0B3DAFqQaNINClAUitEwiFAakAIAkIaIUBqf+NANytANwpEPAMqX+NANytAdwpAtAJ7iDQIIALTEEIaI0A3GiNINCtGdCNGdCtDdxoqGiqaEBojRYIaI0VCGiNFAh42KL/mqUBKQPQAqkBCTSFASAMCqkA8D+uFAjoiqAAojDJZJAP6WToyWSw+Y4AAMiiMNAHyQqQDukK6MkKsPlIipkAAMhoCTCZAACpKZkBAKkgyMADkPaiBKkwvB8ImekFytD3jhkIjhoIjhsIjh4IIAEMrhEIMAm9JAidFAPKEPetFwiiAI0R0I4S0K0VCPAGqSWiQNAEqZWiQo0E3I4F3KwUCMwMCJACoACYSKkA8Bu5AACiACDvC7kAAOgg7wu5AACNHAi5AACNHQitEgjwHsAgkAKgH6kAqjgqkAIq6IgQ+D0NCNAHqYGNGtDQBamBjQ3cqQGNDtytEwjwBakqjRQDqS+FAK0SCNADqTdYhQForhYIoADK0PsgBgitEgjwD60TCPAJqTeFAdADov+aWCBdCgh4IH8KIEELqX+NANytAdwpJNAYov6OANytAdxKsA0gDAqpN4UBjQSAbPz/KK0XCCkQ8AkgQQwgmQwgcgwggAtMxgmiAI4a0K0Z0I0Z0Kl/jQ3cjQ3drQ3crQ3dqQiNDtyNDt2ND9yND92NBNSNC9SNEtSNBNSNC9SNEtSKohedANSdANTKEPeOGQipD40Y1I0Y1GDuFgitEtAQ+K4fCDjpw8kgkAKiCI4W0K0S0DDsqQiNFtBgrvAKMA698QqNANytAdw9GQvwIa0MCBhpA8kokAKpJ6q98QqNANytAdw9GQvwB8oQ747wCmCO8AqK0ANMDArK0AytFwhJEI0XCI0R0GDK0A2uFAjo7AwIkBSiAPAQytAMrhQI0AOuDAjKTOwKyopMkgj/f/7f339//f37+/f37+/99/v7/fv39+/v79/v7+/ff/v9+/f3/fv3/YABAQgBCAEIAQgBCAEIBBAQBEAgBCACBCAEEIBAAkACIEBAgAKAAhCp/40A3K0A3KpNGAgtGAiOGAhKkA2uFAjo7AwIkBCiAPAMSpANrhQI0AOuDAjKikySCEqQA0wMCkqQA0yVCGCuGQgwYeiKrBUI2esLkBqiBLwfCLnpBWkA3eYLkAOpMCyiAZnpBcrQ6I4ZCKwVCL7tC6wcCJgNHQjwK+4aCNAD7hsIzBoI0BitHQjtGwjQEI0aCI0bCK0eCMmYsAPuHgjK0NggAQxgOjo2OjwyBQZISkpKSiD6C2gpDwkwnQMG6GCtHgiqKfgYaZCNANCpACqNENCKKQeouTkMoBiZ/QaIiIjQ+IpKSkqqqQbKEAKpDpnv2cjAE9DzYACAwODw+Pz+rATYogC9BdidBNjo4B+Q9a1L2I0j2K1z2I1L2KIevVTYnVXYyhD3rSzYjVTYjCzYYO6IDK2IDEopD6i5iQyiJZ3B28oQ+mAACQIECgcNAQ0HCgQCCQAAAKAA8E+iJr1I251J28oQ984fCM4fCBA8qQaNHwju7Qyt7QwpB6q97gyNSNuiAL1JB51IB+jgJ5D1rtUM4P/QCeiO0gyM0wzw8I5vB+7SDNAD7tMMYAAFBQUDDQENA0wmGKIAIPgXogcg+BeiDiD4F6kAjRXUqQCNFtSpAPAwrVYQ0Cat2RjwBzAFjVYQ0Bqt4BjwBzAFjVYQ0A6t5xjwBzAFjVYQ0AKpAK0dEAkAjRfUqQ8JAI0Y1K5gGOjgBbADTHQSrmEYEANM1xLo4EDwBo5hGEzjEKIAjmEYrmIY6OAzkBOp/o2LGI2SGI2ZGKmAjWEYTNcSjmIYvZ8mhfC90iaF8b03KI3GGL0FJ4XyvTgnhfO9aiiNzRi9ayeF9L2eJ4X1vZ0ojdQYvdEnhfa9BCiF96kAjesQjW4RjfERjYUSzmQY0H6iAKAAsfAwHvA+yUCQAyk/yspKjWQYkAjIsfCNrxipgI2gGExOEQqNihgKjYkYSkopH42IGKq9aBvQC411GI12GKn+jZ8YogGpAY1kGMix8I2gGBAOKX+NhhjIsfCNrxhMThGNhhiOixjIEA+YKX+opfAYaYCF8JAC5vGM6xDOZRjQfqIAoACx8jAe8D7JQJADKT/KykqNZRiQCMix8o22GKmAjacYTNERCo2RGAqNkBhKSikfjY8Yqr1oG9ALjXwYjX0Yqf6NphiiAakBjWUYyLHyjacYEA4pf42NGMix8o22GEzREY2NGI6SGMgQD5gpf6il8hhpgIXykALm84xuEc5mGNB+ogCgALH0MB7wPslAkAMpP8rKSo1mGJAIyLH0jb0YqYCNrhhMVBIKjZgYCo2XGEpKKR+NlhiqvWgb0AuNgxiNhBip/o2tGKIBqQGNZhjIsfSNrhgQDil/jZQYyLH0jb0YTFQSjZQYjpkYyBAPmCl/qKX0GGmAhfSQAub1jPERqQCNYBhM1xKOYBjgAvBs4AHQWM5jGNBToACx9hAFyCl/EC/JILAJyEqNbRiwIrH2yUCwC8hKKQ+NVBCwE7H2KT+NXxCqyuACkAKiAo54EsipAY1jGIyFEpgQECl/jYUSpfYYaYCF9pAC5veiACDcFaIHINwVog4g3BVgogAgfxOiByB/E6IOIH8TTPkSrIcYucIZMASouWUajdkYrI4YucIZMASouWUajeAYrJUYucIZMASouWUajecYqQCiAOzZGPACCQHs4BjwAgkC7OcY8AIJBI0dEGCpAKyHGL7CGTADvmUajtkY8AIJAayOGL7CGTADvmUajuAY8AIJAqyVGL7CGTADvmUajucY8AIJBI0dEGC9oBgQI72vGAqdshipAJACqf+dsxi9ixgQJD2fGJ2fGKkAnaAYTNwVvYsYEAk9nxidnxhM3BWoqQCdshjwA6ipAJ2wGJ2xGMAB8DG8hxi5VRvwD72GGBh9xhhpRJ2FGEzcFb2GGBh9xhidhRioudAonckYuTApncoYTNwVnccYncgYvYYYGH3GGJ2FGL2IGJ2HGKn/nZ8YvIcYue4YnXUYuQEZnXYYvXQYKf6dBNS5FBmddBi5VRudnhjwI6i9hRgYaUSdhRi5lRoQBBh9hRiouc8onckYuS8pncoYTG0UvIUYudAonckYuTApncoYvYkYEE68hxi5JxmonZoYECi5OBmdmxi5LhmdnBgQBKn/0AKpAJ2dGLkaGfAmuSQZnXIYnXMYTMAUuToZnXIYnXMYqQCdmxi5WhmdnBi5ahmdnRi9ihgwA0xKFbyHGOxtGNB9ucIZjWcYqBA5uQ8ajWsYudMZjU8QufcZSo1WEJALuf0ZjRgQqQCNExCpAI1oGLkJGo1qGLkDGkqNaRiQPe5oGNA4udUZjRgQqQCNExCNaBi5UxqNTxC5ZRqNVhC5+RmNahi55xlKjWkYkAPuaBi5CxqNaxi5HRqNbBi8hxi5exudtBgQA0yrF6kAnbUYuY4bGGkBSp3EGJAHuaEbSp3HGLmhG53FGEyrF96bGDAI0EbIuTgZ0Aip/52bGEwnFhANnZoYqLk4GZ2bGEykFZ2bGJidmhi5LhmdnBgQBKn/0AKpAJ2dGLkaGfBtuSQZnXIYnXMYTCcWvXIYGH2cGJ1yGL1zGH2dGJ1zGEwnFryaGDCY3pwY0BvenRgQFrl6GZ2cGLmKGZ2dGL2bGEkBnZsYECa9mxjQEhi9chh5ShmdchiQFf5zGEwnFji9chj5ShmdchiwA95zGL2yGPAQGH2wGJ2wGL2zGH2xGJ2xGL20GPAHMF3etBgQWLyHGL21GNAevccYGH3FGJ3HGJAD/sgY3sQY0Dy5jhudxBipARAcvccYOP3FGJ3HGLAD3sgY3sQY0B65jhudxBipAJ21GLm0G/AOGH3FGJ3FGJAFqf+dxRjsbRjwA0xZF6xnGBBYzmsYMAjQcci5DxrQCKn/jWsYTFkXEA2NZxiouQ8ajWsYTNgWjWsYmI1nGLn3GUqNVhCQC7n9GY0YEKkAjRMQqQCNaBi5CRqNahi5AxpKjWkYkFnuaBjQVM5rGNAbzmwYEBa5LxqNaxi5QRqNbBitaBhJAY1oGBA0rWgY0BqtExAJ+BhtaRgpB40TEK0YEG1qGI0YEExZF60TEDjtaRgpB40TEK0YEO1qGI0YELyeGPAvuZYa0Aq59hqdnhioTHEX/p4YyLn1Gp10GLmVGhBoGH2FGKi5zyidyRi5Lymdyhi9tBjwJr3JGBh9sBidcBi9yhh9sRjdsxjwS51xGGC9yRidcBi9yhidcRhgvckYGH2wGI1uGL3KGH2xGN2zGPAljW8YrW4YGH3HGJ1wGK1vGH3IGJ1xGGCouc8onXAYuS8pnXEYYKkAnbIYYL10GD2fGJ0E1L11GJ0F1L12GJ0G1L1yGJ0C1L1zGJ0D1L1wGJ0A1L1xGJ0B1GCp3qJdjQTcjgXcqQCiFJ1wGMoQ+o2FEqkBjWMYjWQYjWUYjWYYqf+NYhipP41hGKn+jWAYqQWNXxBg/gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGcgYAAwAPCQcZCAcACiAIBTGwABjomBmYqICACZr4mJpqYakggYGFgUEBQUFBQRVBgUFBQUNBFAABAgMEgAUGB4QICQoLDA0Ohw/UxwjHCAgIGCBQxwiIEHgILAAAABcAAAkAPwAATgEgAD4BAQFZAQFYAT4BAQwTLQEAAAAAAAAAAAAAAAAAAgAAWgEBAbEBAVgBPwEBFhNwAQAAAAAAAAAAAAAAAAACAAABAQEAAQEAAQEAgH8eAAQIAJelAA0ADwAAAAAAAAABAhuAAgKEAgKHgAABAgMEBQYHCAkKCwwNDg8QERQoWRQUFCgUFCgUWRR4FBT//wkJAAkJCQkJCQkJAAkBCQgAAAAAAAAAAAAAAAAAAAAGAAAAABVLARUVFUsVFUsVARUUFW8BAQAAAAAAAAAAAAAAAAAAAAAAABWRARUVFZEVFZEVARUUFZcBAQAAAAAAAAAAAAAAAAAAAAAAAPDwAPDw8PDw8PDwAPDw8PDw8AAAAAAAAAAAAAAAAABgABAAAMEhISEgAPmkUgoKAAAABwAAAAAACQAAAAEBAwYGhABPvQBBLEIeHkUzEiciLgC8vbEASSQdFhMSEQ8AvcDEAFROTgC9wcQAreXGwb+8Mi4sKikoJyYlAL1Lvb0ASS4tHlEbVAC9wsUAvb29vQC9vcDAxADJycnJvb29vQC9AACBQQKBQYBAQICAEIAQgAeFFRURgUERERERERAbQUFBHQGBASNBQUElQYFAQEBBQEBAQEBAQEBANxUVFRQ8gUFAQIBAgENBQUFGQUFVQU1BQUFBQU9DQUFBQUFBQVUUXgEEEBQdISUpAAA5AD5GSk9VAF4AAAAAAAAAAAAAAAAAAAABAAABgIALgICAgIAGD4AXgICAgIAJgAAABgAAAAAABQcABQAAAAAABAAAAE0AAAAAACUQAFcAAAAAAFwAAAAAAAAAAAAABAAAAAAAAAAAAOAYBOAY4SJC4jzgJOAY4B/gIuAY4SRC4jxC4BYE4BbhJELiPOAd4BYC4CLgFuEwQuAXQuAYBOAY4SRC4jzgJOAY4B/gIuAY4SRC4jxC4BYE4BbhJELiPELgFgTgFuEkQuAW4STjJELkMOQwQuU75DDkMOMkQuQw5DDiMELkMOQw4yRC5i7mLkLlPOYu5i7jJELmLuYu5i5C5i5C4yRC5DDkMELlPOQw5DDjJELkMOQw5DBC5TzkMOMkQuYu5i5C5TXmLkLjJELmLkLmLkLmLuYufn5E5yRC6DBC6DLoM0LotiUANwboPAbovTgAPgToPwToPgTpPwLpPgA6ADMAMuo3Qug1BOg3AkLoOgTpPATptiUAN+k1FucrQucr5yvotiUAN+g36DME6DAE6DDoM+gw6DfoM+gw6zPoNQQAOgQAPgboPwLpPuk/6UHpOuekMkLouzIAPALouzIAPALoNwLoOug1BOg3Auk6Buk1Bus3Bus4BuAUBOAg7BhC4jxC4CAE4BvhJELiPELgHQTgHeEkQuI84B3gHQLgGOAY4TBC4BtC4B8E4B/hJELiPOAb4B8C4BjgGOEkQuI8QuAWBOAW4SRC4jxC4BYE4CLhJELgFuEk4yRC5izmLELlO+Ys5izjJELkMOQw4jBC5DDkMOMkQuQp5ClC5TzkKeQp4yRC5CnkKeQ1QuQ1QuMkQuQw5DBC5TzkMOQw4yRC5DDkMOQwQuU85DDjJELmLuYuQuU15i5C4yRC5i5C5i5C5i7mLuu3JwA4GOokQus3Qus4Qus36zNC6zACQuszQus4Qus6Quu6YQA8EkLqJELnJELrPkLrP0LrPus6Qus1BOk/Auk+AuckQuAUBOAg7BhC4jxC4CAE4BvhJELiPELgHQTgHeEkQuI84B3gHQLgGOAY4TBC4BtC4BgE4BjhJELiPOAb4BhC4BjgGOEkQuI84BbgFgTgGOEkQuI8QuAW4CLgFuAW4SRC4BbhJOu3JwA4GOokQus3Qus4Qus36zNC6zACQuszQus4Qus3QuuuJQAwEA346y4W5yRC5yRC4BQE4CDsGELiPELgIATgG+EkQuI8QuAdBOAd4SRC4jzgHeAdAuAY4BjhMELgG0LgGATgGOEkQuI84BvgGELgGOAY4SRC4jzgFuAYBOAY4SRC4jxC4BjgH+Ak4BjhJELgG+Ek4yRC5izmLELlO+Ys5izjJELkMOQw4jBC5DDkMOMkQuQp5ClC5TzkKeQp4yRC5CnkKeQ1QuQ1QuMkQuQw5DBC5TzkMOQw4yRC5DDkMOQwQuU85DDjJELkMOQwQuU15DBC4yRC5yRC5yRC5yTnJOu3JwA4GOokQus3Qus4Qus36zNC6zAC6zDrM+sw6zjrMOs36zPrriUAMBJC6iRC5yRG4kbiSOJD4kbiQeJD4j/iPOI/4jziOuI85yRC4BgC6CTgGOEi6CfiPOAk4BjgH+Ai4BjhJELiPELgGALoJOAY4SToJ+I84B3gFgLgIuAW4TBC4BfoJOAYBOAY4SRC4jzgJOAY4B/gIuAY4SRC4jxC4BgC6CTgGOEkQuI8QuAgAugk4CDhJELgG+Ek4yRC5DDkMELlO+Qw5DDjJELkMOQw4jBC5DDkMOMkQuQw5DBC5TzkMOQw4yRC5i7mLuYuQuYuQuMkQuQw5DBC5TzkMOQw4yRC5DDkMOQwQuU85DDjJELkMOQwQuU15DBC4yRC7TBC7TBC7TDtMOckQu4kQu4mACcC7isOQuckQu4kQu4mACcC7iwI5j8CQuQ8UO8wJuckQuck5yTnJELuJELuJu4nQu4rDkLnJELuJELuJu4nQu4sCOY/AkLkPFDvMB7rumEAPAQAOgbgFATgIOwYQuI8QuAgBOAb4SRC4jxC4B0E4B3hJELiPOAd4B0C4BjgGOEwQuAbQuAYBOAY4SRC4jzgG+AYQuAY4BjhJELiPOAW4BgE4BjhJELiPELgGOAf4CTgGPAbBvAgHvAdHvAYFvAbBvAWHkLrtycAOBhE6zdC6zhC6zfrM0LrMAJC6zNC6zhC6zpC67phADwc6z5C6z9C6z7rOkLrNQ7rtycAOBhE6zdC6zhC6zfrM0LrMAJC6zNC6zhC6zpC67phADwc6z5C6z9C6z7rOkLrNQTpPwLpPgLnJELwIB7wHR7wGB7wGx5C67cnADgc6zdC6zhC6zfrM0LrMAJC6zNC6zhC6zdC664lADAQDfjrLhzrtycAOBjqJELrN0LrOELrN+szQuswAkLrM0LrOELrN0LrriUAMBAN+OsuFuckQuckQvAgHvAdHvAYNkTnJAJC67cnADgc6zdC6zhC6zfrM0LrMAJC6zNC6zhC6zdC664lADAa4SRG4SRG4SRC4SThJOEkAuEk4STrtycAOBjqJELrN0LrOELrN+szQuswAkLrM0LrOELrN0LrriUAMBxY671nAD/rPQLrtycAOBjqJELrN0LrOELrN+szQuswAkLrM+sw6zjrMOs66zDrumEAPBJC6iRC5yRC6z5C6z9C6z7rOkLrNQTpPwLrNwIAOgLxvXMAPwLxvXMAPwLxvXMAPwTxOvE9AD/xQvFB8T3xxH8ARgLxSQTxyX8ASwTxTvFL8VAAS/FOAEvx0H8AUgLxUQQAUATxTgQASwLxSULxxH8ARvFJ8UUEAEQE8UIEAEQC8UUC8UbxSfFL8UnxS/FG8UXxRELxwn8ARELxRvFJ8UvxSQBOAvFNQvFGAEnxRABC8URC8ULxRALxRPFC8UTxRgIAPwLxPfE/ADoAOQA4AvE28TjxOgA2ADgC8ToANgA4AvE68T0AOALxOvE98TjxPfE/8ULxRPFF8cR/AEYM6jxC6jdC6jjqNUTnJELxRQIARABCAkLxRQIARABCQvFEAEbxSfHEfwBGDOo3QuowQuo86jdE5yRC8UlC8UvxRvFF8UQAQkLxRAA/6jAG8cJ/AEQM6jxC6jdC6jjqNUTnJELxRAIAQgA/AkLxOgIAPQA4QvE6ADYAOPGxOQAzDOo3QuowQuo86jdE8S7xMfEz8THxM/E28TPxNvE48TbxOPE58TrxOPE68T3oIALyRkbyRkLoIALyRvJGRPJGQugpAvJGRvJGQugp8kbyRkLyRkLyRvJG6CQC8kZG8kZC6CTyRvJGQuokQuckQugnAvJGRvJGQugmAvJGQvJG8kbnJELoIALyRkbyRkLoIALyRvJGRPJGQugpAvJGRvJGQugp8kbyRkLyRkLyRvJG6CQC8kZG8kZC6CTyRvJGQuokQuckQugnAvJGRvJGQugpAvJGQvJG8kbnJELoIALyRkbyRkLoIALyRvJGRPJGQugpAvJGRvJGQugp8kbyRkLyRkLyRvJG6CQC8kZG8kZC6CTyRvJGQuokQuckQugkAvJGRvJGQugkAvJGQvJG8kbnJELgGwTgG+wYQuI84B7gGwTgG+Ek4B7gIOAe4BsE4BvhJELiPOAd4B4C4BvgG+EwQuAZQuAbBOAb4SRC4jzgG+AbAuAb4BvhJOAe4CDgGeAbBOAb4SRC4jzgIuAbBOAb4SRC4BbhJPAbPj4C6CcC8kZG8kZC6CcC8kbyRkTyRkLoJwLyRkbyRkLoJ/JG8kZC8kZC8kbyRugnAvJGRvJGQugn8kbyRkLqJELnJELoJwLyRkbyRkLoJwLyRkLyRvJGRH5+RMA/gzeDMYMtgymDJ4MlhiOIIZfHx8fHO0w74cfHO0w74f7+/v47TDs4lxaXfjtMOzjHx8fHx8fHxztMOzg7TDs4ysqYmJgbGxsbHR4dHhsbHR4dHh8fHx8dHh0hISIhIh0eHSEbGxsbGxsbGx0eHSEdHh0hJSUcHBwrKysrmpqaRCsrmpqaRG1tbW2amppEpiKmi5qamkQrKysrRERERJqamkSamppELy8vL5gcHBwcHR0dHxwcHR0dHyAgICAdHR0fISIhIh0dHR8cHBwcHx8fHx0dHR8dHR0fJiYmJhyYmJvlB68HsZvlB68Hsdra2ggHrwex2kzaxAev9LGb5TygFWkVaQev9LHFHMVzNDQ0NIkcHBwcHh4eHxwcHh4eHyAgICEeHh4fISIhIh4eIh8cHCMjJCQkJB4eIh8kJSQlJiYmJiaMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI0mJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMDAwMDAwAAAAAAAAMDAwMDAwMDAAAAAAAWJzhLXnOJobrU8A0tTnGWvecTQnSo4BtanOIse88nhehRwTe0OMRZ955PCtCjgm5ocYmz7jyeFKFGBNzQ4hNm3Xg8KUOMCLihxCfNuvF4U4cZEHFCiU+bdOLwpg4zIP8BAQEBAQEBAQEBAQICAgICAgIDAwMDAwQEBAQFBQUGBgYHBwgICQkKCgsMDQ0ODxAREhMUFRcYGhsdHyAiJCcpKy4xNDc6PkFFSU5SV1xiaG51fIOLk5ylr7nE0N3q+P94IAAQqXHNEtDQ+84g0CADEO4g0EyUKQ=="));


/***/ }),

/***/ "./src/host/webFrontEnd/demos/hoverbovver_prg.js":
/*!*******************************************************!*\
  !*** ./src/host/webFrontEnd/demos/hoverbovver_prg.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tools_base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/base64 */ "./src/tools/base64.js");


/*
http://www.llamasoftarchive.org/oldsite/llamasoft/readme.txt
(as at 2020-05-15, 20:40 PDT)

LLAMASOFT GAMES FOR EMULATOR USE
======================================

These game images may be distributed free of charge to anyone
who wants to use them on emulators.  Please feel free
to carry them on emulator sites or whatever.  Llamasoft
feels that software old enough to be running on emulators
is not going to be exactly generating a huge amount of
revenue, and as such the images are considered by Llamasoft
to be in the public domain, and there will be *no* legal
hassles if your site carries the images.

Enjoy!

\
(:-) - Y a K  1/12/96
/ 
*/

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_tools_base64__WEBPACK_IMPORTED_MODULE_0__.base64Decode)("AQgTCJoCnjIwODAgU0NJIDY2NgAAAOrq6urq6urq6urq6urq6urq6urq6urq6urq6urq6urq6urq6urq6urq6urq6uqpAI0g0KkLjRHQeKk0hQGi0r2FCJ35AOBzsAa9VwmdMwPK0O3KmqAAxv3OdAix/Jn//4jQ+Kb94AjQ7YYuyIQtTAAB8ATlM+TVogMgNAPwM8kH0BaiASA0A9AKogQgNAMYaQcQBaIKIDQDhfel9oX4pf6F/KX/hf0gawOl/YX/pfyF/qICIDQDSrA30B6iCCA0A6AChPeF9TilLeX1hfylLuX2hf0gaQNMAAHoIDQD8AmiCCA0A6AD0NqiDiA0A0xtAdApoASE+eggNAPQCaIQIDQDpPnQveggNAPQCKIMIDQDTIoBogggNANMigHoIDQD0AroIDQDGGkFqNDJ6CA0A9AL6KICIDQDGGkH0OyiCCA0A9DlqQCF9qT78AwG+iom9sb7ytDyqGBIsf6F+qkIhfto5v7Q5ub/0OLmAakbjRHQqTeFAVhMEAiG+KAAxPjQCKT30ATmLub9xviIsfyRLZjQ+KX4MAjQ7KT30OjmLhilLWX3kAPmLhiFLaX8ZfeF/JAC5v1gCoEOCJoCniAoMjA2NCkAAAB4qTSFAaIFvUIInS0AyhD3mqAAxjLOLAixMZneUMjQ+KUyyQjQ7blICDyBAej3TAbjAQgkyBVBsS8qKgC4gCkHqr0aAY0YAf8GASkfqiAiAUz/AaRDq3lYOz8p5i/QAuYwYKFF5ZEt5i0O5y7K0PXwxakA8O+p/9DrBoAuNyUcY6BovvCoIHEBIZlwg8Y5EPEwj4Y5CKpMGRSEeJ5yKSHps5Qs2gGpN9DhWCBZpkyup+AaeFzuqQMsqQiF/82YyMT/PMcYpS1l/4UtpS5pAIUuYA7I5SRoL5MvpTCiRjCiM7kA77De/84AztwBzt8BrQ/BoMnf0OpgYCohCAoAnjIxNDA6jyBIT1ZFUiBCGDg/GE9LVCc4MwAsCBRB4MAzMjc2OKMkOTE1MqTrFC9QUk9HUkFNTUVPAUhVTFCQEfAKjyLkFCEy513jSakJjXMIqWCNdgigQKIAvQAJnQBg6MHuBUjuJ8yI0O5gAvwCyYXQIakTFDASqaChuRKgEEETCguglABUgu5hyjmA4wJgIe8Q7wSnwfch34IABSD/QECA98gAAsq0kO9C7QBCGKIvuhI9BZkiVk9PUlNUVUsio2FEMEcYRkIiADkTywCDIh3cRjgyMDM4QTJBOTAwOAMbAygDKQMrAzAGKQIIgCuDrEH1JgYfhgzFiAYVzPADHQwkBjAEMAIvBi0BEATAAIKaSgQoAiYIKRMGJAShRAQKIChBDgqHlWVAZHsqDCuDCiSGLQLDKl0QJgNMnCMCEgMhBB8CAKIhKtDynVCCIQC6Hi2UA3hRoXkBnAIAU3A4BjUGOQQ3AiU1BDQCMqCAEjQ3YNEyojQDMAwwQtQB4oiQL0iALkQDAjAtEYG6ESjrHF5glCWOgwQY4YUMVvHhcK2ACHOMDwyF1AcARAboH80C4SACYICEkAlYgCbAryAMMfCrgdYHHboB8MhXTS6/DmwcwIAsQAwMJ2OP1FGAXPAG8PDSYVoEGmBFEBTgdxcjChX2OCMDIQNgoUNw5QYfAfBBHANXQBgB/wQYAhoEHAIYBh0GHiwDRhAkAhYYIgqBIIDDGh4sQhxjBOSZIAUNJgQgIfAIh4ZhggMAA4IaHBAQqIgdgEgUsHjukcIKHQIcChoCGwYAiDkCBCKBCDAgAh/KPgMdAx9QFIUm4CkCKAomAieAkKgrEAoaBC6A/BgsCHkqYV0QGVMvAaUQJqADDuFXDC8jiGfGaUICFDeeHk2TIPBCHG+it2BUtQBgezBu2wwZDBsMpiAqphgCriArYBgAICvFIOATDBgB8AQYf3GZYDXLF5kKno4VBFFFB3/OwmB0LDMsAJA2LAVAOSwkRjbDMc4fygAFZMQ7IC5CWVRFIONMMCwxBTQ0GAChyoAQAL5gNywyMDxm27Gx22Y8GCeYfszMzgD8ZmZ8xsz4AA/hYMDAxnwA+GwEQ4gQ/kCCeAf+MIbjwCnkBG4Y43gA42YhfuPMJAAQYBjjMCMh2x7jDC3Y2HAA5mx4cNjMxgDg42A1TgBRgXd/a8bGx4h2fn7OBIDABygozEAZuAFAgjoACBQ85gYgKcB2BTwGYAC6KsWh5GYkzHbQCrErxmysATw5Y2Nr39fjAMbckG4gBsLAkDi6jWYMGDDm0FdXX18EoORfKldVVz1/X/X11dXk/SLV9eP9KgvwYAAQMH9/MBCpJwwcHDgwAGCiJv8cNmPB/wgg/kNiwP4CGfwcNP5A/IL4JwAi0PiiK/AQiPAAMHgIUKUm4AAgN4jgoiHAoiNAwMAIoYCjIoCAYCABtABEpSRIgJbQoyF+qCOdomBWAwYMUU0Api92hi0wA9Uw/BAAwLVBwg0c6AQrYGxsp+DCdGB8BkADAgLQKYB9IPCAEBARgUQDhCA+DCAMIFwAGaSgyCoYIDQOjwYwGA6jI34WozFwGAy6GnBWKDgcesL//OPMKs/MwM/d/PzszPymKuC03MwGF9wMlD9gz9xdgcdgP5DwGIzcC4DsjBjwYfwbOKrsfHxvMzAfpiEEJtj4+C2L4Jgxx+/wSO7XYMyc3Dyi+OYW/c/A2/6viqnAJPgMDPyoIe7E3Srg6ePDw8nM/wWQwHC+ATMjV7GkI5iau8N54MSqw+P9IVXj3ytVUVVFVVRVVRSqquS847AFOACk5AvAPuMOIgICKALY44AiNqjngEkCcJQCMwL0iZWV5eX5+f7+VlZbW29vv78EqkoCd3HCrMsnAD8zM/MA/6gk/9sdG+MYJR4hwgsP5Aws/HycagAwmQ88YNDw5DAoPz45Nz5h8HKEuNgUcAAxeH/3/X/dpt+EEP8UAHbCIf3COYR0j6q+/9fX/76qq7qqruquqrrcAGpqWlrkVi4oAkPFwKWlqakjiOhVKa+vv6+rr47h+uP+JPrq/vosuAAir+/EIvu6nv4pRUQgU1lNQk9M5SowRFVQTElDQVRFsTcvSU0IKDBQhKAC2kNPREXmJMJOVkFgG3ACQUREUkVTU1hgTS5BIE0dAbROT1QgBxhMT1erQyoqUkFOXEZGIEVORAQAHArmUorRTEFCRUx4gVSkVC4hRTlTDBYtWuKwVE9PIDtkTkfnQU4ByC2QhFBIJFVNPYJIERQxRk9SVzUCUBzIRiQFNkNF5DwSkCwOpFh7QlVTaUIfiFjOCnZZKkMbISdU2BSgUwDpUHo0SU8kAKgHIC8XtQJESXRDVElWRY0lQhgSSEhsnlVUhAGgfBRUmEkKRUeeC+oBIBsCXQJZUMA6G5uOMsA3Gk+jx0EsWCxZLFMsUCBZQFpFVtLjSjMlUENkVBDsSS0txkBjwDAqTUFDUk8lg6CUTO1GVUyFsGYmICFABzlLiYvIPC8TBdpNUB6ByHcyFBsJEAFJU/SDVOPCLgsBmhNXSVRIBiCGCAkBLgHFrASpTR5BpAiS50ScNM6FjAKAYVsHw0VFUDeDhRNNX4hZICg+OSkgUEHj8VJNUyr5Iw4kIyQ4JE0kojBiJHckjCShJLYkyyTgJPUkpGAfCiUfJTQlSSVeJXMliCWdJbIlxyXcJfElBiYBCmToEKNhowMnhASGBa1/CCkQ8ANMESeFAXWA0Ecs/KBwM6IC7DkI8AsgzP9RjgK6QSDG/yDP/6aQ8BWoiilA0AmACHW5/idMrSepAI1LCJikBKYFYKIDmdhzMCd1UIUmIDQn0AYgQC1MYybJP9Dd/no46TAgziygALEQjY0JyAzAjgkNltAkpQVhegmlEY17XJBLoAuAhRCteykRCkitPWiREMitjjCzhAknACgExR8AkKPm7p2gA+4oOoLQn3vD70gFbk6th0ZciIy5hxmIzIxZ+P6JCb0B8AHJOtAIqTCdOsrQ7q14CcWgrXkYOkK5iSB4DfEpyMAEkPVxQrnNYKkNhgWEBEgscwgQHK3FyQSwiJYEER4jyf9oSCDS/65yz4YDIBbnaEynJo5AqQEgwxS4BCkFoKitdIEBXJEpqQZxIwdBRSTmTHEoIOH/8AFgIG0LeKICAoYFDmGFxlgg5P8JAPD5yULwAcBfC2BXQDvGAgCoACICqqIhXAGQVAxQMlABkPwPjKuiJ//1AKr0AP8MAPQo88AAAPiEA8PAAgPA8CoPUAHfPAqAKtEmz6Ap8wADBgPgIIp+gw8p5DwAIoDoeT59A8GiLf/QAZC/DI686CAPFGI8oiMo8pz4hyoMAv/wPwAYzO0BJvDnqMpz4VARMj/4ADBZEPAMgP5kOD2gING7IaDwoGQoA0IKojGAzDSAKXzgGgJAABonUABWVAFVVb7go+KSgc0EoACEAAuAMSgAAVoFlADYlQAVBgIyQE6QCmRQMioLkAfwAwg7QCIlQEAa0AsgDHcwBgEBYAGIcAZBAmc8LvBiBAUBQAPAX8QFBFPDJdZ6eD7PQCozNyAIuQwDBAnZUQ3wUAYHQFkrPAvoExegKofnpzbEc9NQQxWgAxPBoQIPPgAkoICgPyMqAA/ODziJ7qKDDOvdAyHwNUDgKkmAAMAeB1Hju6Cgw3BjAkTdMwA/rw/cQAc0AcAEkED1gKIhYGKBodiiYABmwIGKBgLQD3GAIX8C/8DfPv+AH2gOfwMDfQwBgBsDAPm4BsAZhsAxjMA8zuDRpc+IWAZzcAkm4HTgcAECDk3/RhTouSTZAg2tHi8HgDYD4Q2AZhmA973Ap0QwLhQMgCxmOJ6HOkQl4KgORXZZHym7DrOyAwkADQAbB8ANIBwY73UbnA8Y3U0HOgVgK8FZ1IZgMMwweO4c0akmAcOAA+fADkH/4CYDpABgCyEBgSJimDB+LIAB8vEYsyTUqqqgAoIIICOEMCGqBSSAqswCYKoGVKAFWtPGojD/AM5QD//wP//8DqqwDrYCEVDVI4IDAgCXhrACDqmwIQ4EjKAiqjRSTwZAIdGAQP+vIgFUBAAFVaEDBvkAJQZZAAJYBUIIfCGgAD1QoASzI0TQAwA8gqEFYwBLqLPBryUBFcIqpQVAh/UmQAQQQDiCtoQmBgI6aqgJXV/CJQgOKAxwIBEuBBLLDAAwYAGorAMcmSihAAMURBtLArfGMlMpQgbih7nGMjMlQgAOQAL2ACEINpG1NAoEA7gCyOMfPC9oQ5zlCAIA4gKqs7goER49kpG2SVGiJwHj+T8oszQCgAJ+rQJ6oAAKBkC6Nb6tBABOuMEwKGAEg4wPGMYQAvoGd/4YVLIkY1F6Aq+ACiqirgWari55ucXAGjMXHi+LgNSAemHFy6okGIJ8igfAH6IwVxACVgHxlqowDqrwPqrAM6tME8AmvTXACJGtGCEQoihUACIhABAJSD5GxCIQqxWpInOFIyE1WdAA4NQAMlYGqaoA8KiEAEGgMAAPJhAhEBzAgl2nsEEKNxAPLQAwr3k5AhT4nTAhAwLQEAMhwCzWI/KqN8AlqAASjDtJJQhFmSSiAKBvtsGmjckAMBCAA1yoMPYAPBXyACUQHwBjn0wOoKBQIQceIXDA5uiwAL4ZtBT4NrfgAr/gALBCIZIXKDStCFFQocOMUQQksMiwAgRAtCIgAkB4OMWMwBJEOVE9gwYOMqIsDwqaKpgWQLg4ytEmwOQANR+u4blQgfSBRYi/aCJyAmv4AAfsPC8pEBRgLI634ZIJmGgRcWig4oaOsZEGhQ+iH3xdEOiEJUsgARkCFcgAsDrKDP0QAAUFsIS8wXwlBATUUGGYSbiCDozFSD4GdvgVAGqRYKZ4gKQh0aZgQDky/hCQfIRBFA36GBmNmiAGPEswATk5Cc067hmYELwk83uYEAgM0wYAAYgd2QyiQ3MBmeG6rGN5YOJDwvUTsEwGZ4OswFihS0ZhJDtjI/wY8OzBwSPRAdnOQPPAICEQAHvBnMM4gAAMiyeZAAx4bsXOsyGEojCIQAH+YAf/+BkDECAwDiqALAleeAjGCA8wQDFiAAZwgwCEgCkANxAQhggIcLNAGTM7AY2ahvHQgCoAMyEBAhECBn/MH//wAzHAAiDfgBGALQAvEIAXIACJxgXL+YuHGOCAKAA6BCAAEggC3iigBojgDEHYnIQAIIIAQCYoVQArKT8BR7NMtLxhXEJlvnAAhQ2FDKkFhQ6pBoUDpivCYAqFAr3EnYUFpg2pB4UPvQFMhQSGCSBJgKYJ6OYCxg/Q7aUCGGkFlQSpAYupA8VyKIYNpQMSEQI/iuYMxg7wA0wOfJawHKkItVAgiLA44CBYhojQ+nNT0PbGDdDyPpfnYKUtyQHwDOYcpRzJA9AEMKIgHoqpEyKpDd2zgKIAvdWepBzP4NADvd+eKT/rdQOnVejgCtDiYE1FR0EgIE1PV0VSB+JBTklBQ1Oi+JoDC4efgBAI4EMXeAfLGn3C8+AviiRzQBIdad2gJtDXTGZ9VVNFIEYxLDMsNSBUTyBvGFQgVkFMVUVTLi4uczcT7lRBUlRFTlRSWSBMQVdOOiAx4yAqUALJWQJzUw1BYH4bSUNLcN4CpcXJQNAOojVfWYKnytD3WHhAyQTQEu4VBq02yTnQUKAxjSUCTGzGBYsQIliCIsczMWMimLEGosQuFjwu4sUuxYQErNP5+jjpMIUhGIzCCC1GMwjjHkx8gsW9waJgY4Cc0ABknQAgGIBlxCEGIGYxIgGIZwxAI2JoAxAkGIBpxCUGIGoxJgGIaw3HJ+jQzaAAqWyFCAIdQgepYQqhHNQJsQeRCeYH0ALmCOYJGd0KpQovBynqqYCNkQJggZzqJgDq6iAAfuXqYbhM/4GpBIVJqUgfOMClSJ1AA6VJnWADphhpKAmAMQNpALyA6OAb0ORgpgOkAr34BUi9PgFOamAgNICxSGClAskoEPkY6aUEkXANSNQ2waUFkZEBvyQg8QQAyAUGQAY4B8rQ7wpwWC94qcCNFAOOJxUDTIaAqb+NGA1VGQP/gC9YqYGNGtAKwI0S0K0R0DTUKX+NAgUaMBorrgAQhRGgAakPw5TUIJWJYECtGdApAdBEXDHq5gMy0VCAMioqTOIkDhpj+MYQ0PmlET/jpS/wDsYv0AqiKLLkR44QLRoX0DilE8X07xOlFDcgFKAAjATUsROFF8gLwMnw8BuqvYQnwADUvcIZVgHUcA6opV8OcSGhJMZmbqOlFXjpFaUW4RYPIbEVjAv4gBnIgU8rhsn/0AfdPEzmgNHOB2jnCJ0IBUKM+QQYOFp9o8z2I1OGu/QwcLT7R5jtR6cMd+lh4Wj3jzDaj04Y79LDw9HvH2C1Hpwx36WHhqLfPsFrPDljvksPDOcC5QPkBOMFIgYG4wdhRwgICQkKCwsMDQ4ODxAREhMVFhcZGhwdHyEjJScqLC8yNTg7P0MgDYAgzJ0gdoCpCY0F1I0Mazc5jRPbIBdpBgDIDQaYFNTzQeGuT40RT4UdFF9MoJ+iZBfaGwwoomQT9cepYIUUqWK4BoHGIC0q/GCCsPupMmxmMkIuEOOjcxG56AnMYAbgAYBUAvB1ZiBnhgaN2eClIY0CEcMST0xyhiBigGN5QCDQjSHQqRiNGNCiAPGSKBYDQV4YvQ2DIP2CqQUg+QaiU1gg/4IxcjXi671dMGOFmRkWghMXrQoMhBxZKNC+IDaCTNWDIkEHZDhgB+YDECR6ICBMTEFNQVNPRlQgUFJFU4OqU+MIYcBKRUZGIE1JB3gwRVInU+QgYCVNVVNJQ0FMIEFSUkFOR0VN5TAgQlkgKgH4DcCNxUlTTkVZ5iA+R0PFSmBPR1JIAo1EIx4ZphHoKOYjRIRERfVHTkeAWIYuS/ApkESd9S5DLpOhJ0BqDzE5ODNnMr6EOCpXQSmAz8hhDqkDjRXQqQeNJwKwCo0lFlEOjSbQRRzQA13A+AepxY35KQSCBjZShQgUAMJcMhNjWZKbYCCShKIE7qCArXPJxdAFM05w5gegASBchKUHSDjpDIU00ADUaIXoxAsMHEwBwwvQ9srQx+YCA/LrLdC3TBGFikiYqugKqKUImQHQDrAKmQDQsBLggjgqbgD8Sf8tENCNDfFMj4SJHA3EFGiqEMUMhQykBJfAKYDwBaUMQWAuwUAM4QbEhQK944Qd8AMgyYR6wW0FIRvgG2ByIDah8A3GBwQw4xBbTElC2UQAyEgGQEw5UKUhVLh46xK7qmQNqcgo+40E0IKWGMwJCBxEBRBAoMscCkkoYUlgKdDuua0A58nQ0AUZGD+Hf+DISFjmB6VBWFDQ1qnHWkjAojiFIIbMYcTGwnILgd5wIOaBzM1gMz5gGYsrqbgiYFosUtCN+gcCymkCwO8eGQ8IztCEUGPDuWGw1I8O5sZyxGhjGQ5Y8Oh2h4fnw8Nh6T4FFw9JBvDNQFTnstC3kexyQIpIph29ANxJ/4UbbzggIEqGpRspEKs8sFmCTN58qQCiIJ3/TlTDYAe4EIAgS4gTM2qFBGJ2EIQTAwGlDPZBhrCzAhSn0OoaBvAbUKlrTCD74YesA2ACFdnx7akgjZ9vEcbGUCZBD/Di4g5CmAyH8vi8pRzJAfAHvRaHLj2C6BgIQvHegfggIFkOs0OHTMKK8YhDI09OReMKdlRXTxgwsQHIb1Y76DkZ9eYDpQPJFtDpYKAewZ7YCJhISLWoyMAF0PTl4aYgyiAAm6kfD4QaZFDb8AYYaQgBAeaFDKYMvRCJjSvQvRGJY5lsAo0p2WcqIl8eGR1BF4E5ka2KAQkQjRal0YkdgNKN/LLTjfsHBIZY+e/I+grYDI0ip5Yj0Ed6SluACSCFBRB31h4gOsoL0AqpZsJiAfFDmAzQ2xQpSVoEh4plpA7ZBHjxLFzREnOtAm08LEQimKADmMhciIqtK4IIJ4u2gwyJd70NiZDLIMYD8B7EBREORiiAo+UOx9UPiasgYJjwzIwCA5yNCxKJwdmQoAS6HEDRCwDHuBh0hnaGZQOMWAhxrQjgAPAXwxA+ZYYJkfQMj9sGpgnK0O3mRGQZGZNg6OjgCvALdEDYRUlgTLCIOBzEEWCCxkOeH8HHTCOJERYMFg8HDUgaDgwODwkDchUPDOMPYJEFdowQOGGxiAyMmGR44yGEFkDAC5BHhkeEWCvXx4bGggbQylRYAofHEdKOI3Yd6CO41CS40MZgCuuEpomdAECdgEC78Gl40PJgRE9HIExPWUFMVFk65CDvIiEg5zAxIMWkVE9MRRmyUUNFOiCFOCBEWE0nUw7YTU9XswhWCgOODEFEOvIgYI3EwDXgvKIIvQBPpBzAAtADvRBPlR/K0O+pQIUKCxTACcpALMAEqYCkoADONhi8wxqSsQljOkKEB4CBB8KkB8jAUYPspiDDItUwAy1UqqBZILaKlgOZuQfoxAOy5KIPvZeKnafbnX/bMsASgs/bXwbt7mAGBgICBAQFBQMDBwfjAeUF5QflAmR4SklNoDbkRkpDTQzjoKUi0AalI9AC8ANM0JipDX0AIGLiLAlcRHOFED+LI6lIhSLEcyPFI5UAtxDpIKiLTDCPxiKahMn/vgjGI2ClByl/IEsMCQiBfxAI0wimCqQLpQlymEiKSKAKPmCAydgQi2iqaKhFYojQ55Asjdw3AaggBuZgLxxJQDZlxwSiAkwF/HDmCcZEkeI5WMijx4hlZwgyvtKpboUNqYyFDqYhyoopD6rooACxDaJB8AjmDWiYDtDyEAtABBPKHGYzyXzwVsl+8GzJG9AAc3ABYIUHIGN6XAgUuAkpCnBSC+CmDIKzIBuLmj/JCdDEkArQ5gzkqPC4JbTGC/CwoISshAWIpK9ME4zEtJVSi0IfTNGLiONB1lV9ixobzYeY42D/9gEBBhME9iHMGIAHyAYHBi4ODLMbAQYOGYB8DwETfBdM9hIBBAQDAxoQDAOeBwUFCgwJ9hkGgHwTAAgiDgd04gkcMPYLAxoAAvYTBcBUQBwGMQUGDhJjBRDGAFIzGDQNYwB+AAkSfhaDOHAUgBjQDmFjRmDChgFq0AEIBXwEQwdBDQoENA0Q0CVDIkENHwQ0HBEMGQgkEClCEwk5D6DgO0EIB3gYixeDcO9+ARAOfhcED9IL0wlXADZoEWEHLwViG/2LnwENAwEPNAwEE8oHdg0EWgDCEQMASBWgRRQYAmKGAqgb4AYuFTAF5QkCQZUYCgwCegQDPIOxABwKByQwYgpuoQoDiGYNwAINJAYHfgQpqn4eCG8PuxQFBQIZCQX/VAqzA2JDgwLyCwUECQnCgwgKigEEgKiAEBQMC3wgBCL/IwIkAqlGEYMKaugYBQfZBQEVDAUfFBCJDICkASAXwSRcERmQEgMIwBIuDgwLNAULSKAaAhgKCAwCLTQQEQAWDYoaDZqXBLsAMQ0BhAXI5gQMMwyBBgIiAqoAEKDAdncAAg5gAmLIoAkG5JcdQsiBGQUQAaMwYg0SkRDQ0Bdgb6oHBAhADkUbBEEFCFQRBREGDQYgVgw6xR/BhVhQKAESRgcUA2QgCAkRQB4JjyEHDRoI9YMHBwZ8HwdKAA0HfiECC68CFAwBAWQLBRMKCCCPCHwhBCZ+0AEIFwj6wmCWnbRB3wZPFhngTA8d3HcjpwSiEKkAnf/PDvTxqSOHNTeFOIU5qRSFNKkShTMQ8HoyhTGpCIUwqVGFNanNhTapwIU6II6PTGaQpjC9wY8Lx6C9yo8YZTn4DKU1hQR5NoUIMMK906LIB4UeNNwg0QhUAEwK+EIA1NUA16Mm1gDY2wDhoyHepCEMoyT0ABLupiRkHkYA5C5gdQCkYgoDBgQDogS95I+dAB+96MQQBiDsNxAwH6kBnSAfnVAGQEAyYAozYZCdPBck19IPck0bcXhmhVeFXEju6PDwCXZgqQRMXZAEXCC9lB3SAgY45Qd8EKUhKQ8YaoWFoOH8EFCFWGAABwth8HH4X4U9hT6FXqkehSqFK6kQhSwg9o+iAyAAmyCUkCD1kSA0kiAnkyAalUyCkKCAiND9BtfjYCDAlaU+yQHQARX5ADfwPqUwKQHwB8Y2J0zYkENIAhr45jbmw24E8AXGNeF9FQjwAuY1xjfmOaU5yQPQBPJBOUyOj4aMBxhrigNMxZkgTpGlAgKaYAOUpHd6kAqSkUhYAzMFfC40IKhWkTCCnNgjyX3wHyntG8l/8BcMRBWShhHJKPAN4AoD0skVgzGReiAa5TGHGD8IcPMzBb9gNIUDuLaC3IhBGAHEHKzQ5nMEQ4gCDwAI0PvmflBMQ4AgSoalGyUw8B3wCJDmMqUyGxBm0CU+BIU3eOZMq5ARh/VVqQF9AdORoPUHQOMLB5jrCweY4wsPDkdg2CUx0A/yw448FSv/kJ1MZkTJxjrw8Di44wo3DUlGgNR4MzpMnZDJe/AcyXfwGMl20AkCIIOSaHpMDJYGehQvsiAXk6l7YCAqKSgmJSQjIsY/0PIFUu8/qRhRLIOhgzeOySDwE6IJ3SqS8A+i4Pi9KSpgE4HQzMYsAskPgIATLOWPGdC9vBSNEtSFPqmBHDGaBjESXkTASEilSQyAA2YCDqGOmEitMR/JcxCZaArThT2Dv/+FPAzbnyLwFoXtxiu3AExAZBvskua4sR/QFeRuflwRFI4BYC4QJqVoqAehAgloEgAGQEk0SGA3QP6PB70PgMk60AipMJ0JAnHuCMQfALxgRwOiB6QhIP2Sm1hgxkDQ+xWsQCALnc58QJI7R5iWpT7QGKU98OLGPPAGpTyND9RgUFeM3kQH9AYk7uEgrRoKCqNBhjhnIBxyFKZX3iCcWQYgj5NMi5O9MKeKGgfb6GC98Y8DhkDeYPsXqQOBw9D+UB+9UISUBABCEDnOESBZliA0lCDH745WChhlVhhp5IUMkAgXOQI5gCJoDHcEEB+FCL0AHwt9j1UpAailCCUgApNM8ZMCnDjpAgvKZsKU8AlMICqmWpKaAkpCB1IBGTBMFpQoBKKFByU5BaMAREEJwHaHnRDLJZWKqMgEfCVgmK5CAgSge5WSiFGtC1SFUk1f8BtJDa0BH0TQER8nXExnlK0CNNAS16VRSAQmAGqlUnCACAq4HCCRUyMwg1QBIOBVpVTFUjAEMgUKpFPFUTAG4gkCAwVaFWBQ1EkDBofUIUkKVmgQiGiawGAYaiEBqwT/Ccks8EbJzvBCXcLJCPA8yaTwOGOXCFkvAuxoKFCCShYDI6dz8CIC6TAeLpoahQ5oqh5aDuAD8AoNTwHwBMl2UAmwqf9gFBIaYMZY0PulCYPBTHSTpVrQHJ+oGYGCizj9TnYYaQiFDSmA0DelDckQEEAuDFqp6hh9UB+GPDI7IMYMCBXBkpEFpQzEAxgAOeCCCAAugQyd+QdguExrld5AH3DlpVtMj5WtEtCFWyk/gr0QKahx8bhgqRYXhSrJD/AYyL0Hh8a8IG4kAaNQKmBEYQQAcFDQIGYeGDEfpV7QC6UrG5EFJMUPFBeLMh+NMx8gZZZgNLfaogQDCECpAuCC943HOUfGXNAepWCFXEyalanVV4oC9wxleaqtFdAJEJftCndgQp2S+RlkqRcog8Sj6Hndxiu7HNXdlaIIQRkaEyAklsjPhAhVwDjtAk2cEIUOBNmGHKUOshAWrRGLGhIscxgWNAZZGjAwozmQOj088CKPDNAhVOY8CEwpB4U8jTBfkQEx4ikfhV1gxl3Q+wwAMAL5UTj9AFLOB2lmSaW+DRBDoawZipo0K7YQMANMH5ccvgIkyQDwGckCOGx9iqABB9itogXYzsxAhDYuTK6XpTXrBwU0MxtQ7QoQFaU2WA7aOu4JDnApkIJBEBjI1V7D8gFLLl6wPC5LUMkzy/ATqSKRSOYsyExqlwI1dS+iCsAwq6qpEEkBNICpIO4vyMAf0PmpD4UrDpMIZywgM8UGzgZDRCBoghACchBC4yPh0hccBZC4dSDQKszqCdhsd8A2DCJAORsgG9aN+b9Ci5ipFRqgAIO68ISI0PrGDND2/uAqAf8swNCZICiYTLCYqVCFEgwG4ue4HMkCOrFUcQECIAT4gm6C9AfC8cGRB6VJdwHUhUmlCEgCES6BsUgyaAOi5gcZXuYIAsgIl4jibyfQ9dY4y4DwPC8YW6BgwpjmGZLJKICpyEqY5gM7oRahd0SYYKUtJX3HipnmIKUgUIKjUCKZTDedGBUIHoqDj4cgIIceAEBUh7Mc9aN70DSTsQTzBM6KGKAFaKIrSYA6AFMxAqUCyTrQ2gDdzojQzkwwj2INHcMNogi1H50ATwL1eUw/mYaXEA1OqRDYBISpIiwGOxFTQHYzBQcABIUJDqog0iXf1UOQiAgoOximHOCnxgaZAEBMhJmZgEB8drJ40OpgoviapR7JAfAMxh2lHcn/0IUTHZhdoZ9JCSID/QvYqOYcWQPMgN8cXUxyhiDGmgGmVakCjIwKfDSiAL2Mmik/hYQTKopIwqJoqh7Z6OAl0OdTDWK4TA6lDqIKnZHZGfqmDooDUx3G1cGgQIjQ/cYOA9N5DdDZIaC2b5rmIWFhFpLWTMKKqQmTDQFhEBQRW06xbaPC9psV0OuiBpOeCthyPCxRkeIMnJNWyRTwC6ICUV9RTGpwnZqVmEBau4AmmldFTEwgRE9ORSHjIGDTUFJFUEFOACBGT1IgTU8kUF4QV0lORyFDQU4cUXRJRBfQSVRZIELFEVVT6I0TZ24GhQzkO/Ob7iPQu4ZDVwigAF1cTN2aC3iY6EAvGfqIPZ1HhQupm4LQGC8ixphI4ADwGoET8EALyf/wCeYLheYMTBOb4STKTA40DtaZSAd9gBeW28jAKNDvqTCFL2ioCxEISU0gV7QnVFQCfgBEIElGYJsFuVItZSBISVO9BvVS4y7B5TaZH0kn0AMAWoCsGUxQIEEuHOU8UFRPTSdTIeQgwRAIIUdPTwywT0xEhYhMRiGERRoAUSA9GENFTnE4Q0hBUMoQIkNqREUWQUNLEgGIkEWMSVRIbtlZIExBV066liEU5Cz/MBBWMo8uLiBLSaQhUALxICtNLHkgWWZTSUVaRSHMaADcYP8gIONBYCRSR0hgqKRZJ0FGRkNZT1ULEUVBZoZMWXAGAswDoCqH6yAyR7AfgXAI8EoONtLrSxHkwAbJSSHOg8UnRkwaOVOigUgHgCxWSUP0jSpAIiZIkBWEBGCINoC+EB/CRxCD3UBLU0VJTjSBRUSVYC1ahuVEUjlGUyEQcqG7aSAdwFQfXAIgGzlFyeflID5EQU1jBvEhoihJJx8QGANUzr/g1SHmIGE5/62NAikC0AFgpcXJJNANpV9J/4VfDOFA0PpgySnQ+9wsODHwBEMiUILHdLECogClAykHqLnEnYUFvbudeaiGDheapg5i80cJ0MKTnckNnhXQ0GaEDTQdSAk7wB3Q98gO5ET0+EzanYqkOCpAhdiqFcY8mBA7lg+gwMcTwA/Q+UyhnUdpnEX6eaEGAgQFAwcBAKIyvUKeBjsATMrQ9WCJAnjBoAGiAYQNvY8H2X8F8jAK8AIQLOjI4AjQ7qQNmBhpCqjAM9DfU+BYnByRMMEGSxtM3p0jPUymn6UNPvjE8FCgMqIKufZLmSKILTD2hA5YB300CcUO8DekDkwnnucwI0pDTRnQTk9UZ1RFR0GYWkFQDUZgjVBPV5BAiv4p6sjorzf0hAypCiEJEGgxkhVY1Z6kHMAmK73fnshQCw0KAQ1hQHkK0OIikQULBSg+6SGP8EAZ0OtMAp9Qo8QH2EEIRxhTVFdPgYcAJDEtEFK3h05JVElBTFM6IsIi00DPmeQKpR7AZADmEHJOgCPaIEqGpRspBPAP3iMGvQ1Byf/LUBqdEiipCAVO/uKlG50IbirgENARvKcNZpUQUV32TBSfpAxJQ/ODiHU9KII/AJgyPw4kcRAj0weQ4irw7mzr5qkB4DJdA/ADQHBMBJ4XyiCfgiCsBiagn2tDAn9JCPo4lU14ynx8TAYUAgPYAHzLu2AnTE1PADKUt//8/wD/fwJwQSNJHgCPIEUczEUOZMBWQwhCDCg7owAM"));


/***/ }),

/***/ "./src/host/webFrontEnd/dialogs.js":
/*!*****************************************!*\
  !*** ./src/host/webFrontEnd/dialogs.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Dialog: () => (/* binding */ Dialog),
/* harmony export */   closeAllDialogs: () => (/* binding */ closeAllDialogs),
/* harmony export */   initDialogs: () => (/* binding */ initDialogs),
/* harmony export */   showErrorDialog: () => (/* binding */ showErrorDialog)
/* harmony export */ });
/* harmony import */ var _dialogs_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dialogs.css */ "./src/host/webFrontEnd/dialogs.css");


let openDialogs;
let menuEl;
let errorDialog;

class Dialog {

  constructor(id) {
    // this.state can be: "closed", "opening", "open", "closing"
    this.state = "closed";
    this.el = document.getElementById(id);
    this.el.addEventListener("transitionend", this.transitionDidEnd.bind(this));

    for (let closeButton of this.el.getElementsByClassName("close")) {
      closeButton.addEventListener(
        "click",
        this.close.bind(this)        
      );
    }
  }

  open() {

    openDialogs.add(this);
    reconsiderBlanket();

    // Maybe it matters what state we were in before?
    this.state = "opening";

    // On the first frame, make it display...
    requestAnimationFrame(
      () => {
        this.el.className = "dialog transparent";
        // ...only then, once it's up, can we start the transition
        requestAnimationFrame(
          () => {
            this.el.className = "dialog open";
          }
        );
      }
    );

    // Band-aid: without this, clicking on buttons to open the dialogs too
    // quickly can result in them opening with everything highighted.
    globalThis.getSelection().empty();
  }

  close() {
    // (Assuming it wasn't already closed)
    this.state = "closing";
    this.el.className = "dialog transparent";
  }

  transitionDidEnd() {
    switch (this.state) {
      case "closing":
        this.state = "closed";
        this.el.className = "dialog undisplayed";
        openDialogs.delete(this);
        reconsiderBlanket();
        break;
      case "opening":
        this.state = "open";
        break;
    }
  }
}

function reconsiderBlanket() {
  // TODO: ugh
  if (openDialogs.size) {
    menuEl.setAttribute(
      "style",
      `display: block;`
    );
  }
  else {
    menuEl.setAttribute(
      "style",
      `display: none;`
    );
  }
}

function showErrorDialog(text) {
  // This exposes the weakness of not having a dynamic dialog manager, which
  // creates and destroys the DOM elements on-demand. It's luck that multiple
  // dialogs don't occur at the same time, and we don't handle the case well
  // when they do. Hence the errorDialog is at the end of the pre-baked HTML.
  document
    .getElementById("errorDialog-text")
    .innerText = text;

  errorDialog.open();
}

function initDialogs() {

  openDialogs = new Set();
  menuEl = document.getElementById("menu");

  document
    .getElementById("blanket")
    .addEventListener(
      "click",
      () => {
        Array.from(openDialogs).forEach(
          dialog => dialog.close()
        );
      }
    )
  ;

  errorDialog = new Dialog("errorDialog");
}

function closeAllDialogs() {
  for (let dialog of openDialogs) {
    // Doesn't mutate the list we're iterating over
    dialog.close();
  }
}


/***/ }),

/***/ "./src/host/webFrontEnd/diskDialog.js":
/*!********************************************!*\
  !*** ./src/host/webFrontEnd/diskDialog.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initDiskDialog: () => (/* binding */ initDiskDialog)
/* harmony export */ });
/* harmony import */ var _dialogs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dialogs */ "./src/host/webFrontEnd/dialogs.js");
/* harmony import */ var _target_rom_character__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../target/rom/character */ "./src/target/rom/character.js");
/* harmony import */ var _tools_c64FontCodePoints__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/c64FontCodePoints */ "./src/tools/c64FontCodePoints.js");
/* harmony import */ var _diskDialog_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./diskDialog.css */ "./src/host/webFrontEnd/diskDialog.css");





let c64;
let dialog;

function initDiskDialog(nascentC64) {
  c64 = nascentC64;

  c64.hooks.onD64Ingest = showDiskDialog;
  dialog = new _dialogs__WEBPACK_IMPORTED_MODULE_0__.Dialog("diskDialog");
}

function petsciiStringToCanvas(petsciiSeq) {

  const canvas = document.createElement("canvas");
  canvas.width  = 8 * petsciiSeq.length;
  canvas.height = 8;

  const context = canvas.getContext("2d");

  canvas.style.width  = `${Math.round(canvas.width  * 1.0)}px`;
  canvas.style.height = `${Math.round(canvas.height * 1.0)}px`;
  canvas.style.imageRendering = "pixelated";
  
  const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
  const bitmap = imageData.data;  

  Array.from(petsciiSeq).forEach(
    (char, index) => {

      let codepoint = (0,_tools_c64FontCodePoints__WEBPACK_IMPORTED_MODULE_2__.petsciiToFontCodePoint)(char.charCodeAt(0));

      for (let y = 0; y < 8; y++) {

        const fontOffset = (codepoint * 8) + y;
        let seq = _target_rom_character__WEBPACK_IMPORTED_MODULE_1__["default"][fontOffset];

        for (let x = 0; x < 8; x++) {
          let canvasOffset = ((y * canvas.width) + (index * 8) + x) * 4;

          if (seq & 0b10000000) {
            bitmap[canvasOffset + 0] = 0xff;
            bitmap[canvasOffset + 1] = 0xff;
            bitmap[canvasOffset + 2] = 0xff;
            bitmap[canvasOffset + 3] = 255;
          }

          seq <<= 1;
        }
      }
    }
  );

  context.putImageData(imageData, 0, 0);
  return canvas;
}

function showDiskDialog(dir) {

  let resolveWithDirEntry;

  const promise = new Promise(
    (resolve) => {
      resolveWithDirEntry = resolve;
    }
  );

  const container = document.getElementById("diskDialog-dirEntries");

  // Empty whatever might have been there before
  while (container.firstChild) {
    container.removeChild(container.lastChild);
  }

  for (let entry of dir) {
    const { name, blocks, type } = entry;
    
    const canvas = petsciiStringToCanvas(
      `${String(blocks).padEnd(5)}${`"${name}"`.padEnd(20)}${type}`
    );

    const button = document.createElement("button");
    button.appendChild(canvas);

    if (type === "PRG") {
      button.addEventListener(
        "click",
        () => {
          (0,_dialogs__WEBPACK_IMPORTED_MODULE_0__.closeAllDialogs)();
          resolveWithDirEntry(entry);
        }
      );
    }
    else {
      button.setAttribute("disabled", "disabled");
    }

    container.appendChild(button);
  }

  dialog.open();
  return promise;
}


/***/ }),

/***/ "./src/host/webFrontEnd/index.js":
/*!***************************************!*\
  !*** ./src/host/webFrontEnd/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   attach: () => (/* binding */ attach)
/* harmony export */ });
/* harmony import */ var _dialogs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dialogs */ "./src/host/webFrontEnd/dialogs.js");
/* harmony import */ var _trays__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./trays */ "./src/host/webFrontEnd/trays.js");
/* harmony import */ var _scopes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scopes */ "./src/host/webFrontEnd/scopes.js");
/* harmony import */ var _joystickDialog__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./joystickDialog */ "./src/host/webFrontEnd/joystickDialog.js");
/* harmony import */ var _keyMapDialog__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./keyMapDialog */ "./src/host/webFrontEnd/keyMapDialog.js");
/* harmony import */ var _loaderDialog__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./loaderDialog */ "./src/host/webFrontEnd/loaderDialog.js");
/* harmony import */ var _diskDialog__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./diskDialog */ "./src/host/webFrontEnd/diskDialog.js");
/*
   This web front end maintains a whole UI through direct DOM manipulation.
   That's a bad idea. One initial goal of the emulator was to have no external
   dependencies, but then the front end grew, and now it's long past the point
   that it should just be rewritten in React or other framework. So... expect
   this folder to look very different in future.
*/










// A development aid. Don't commit with this turned on.
const pauseOnMenus = false;

function attach(nascentC64) {
  const c64 = nascentC64;

  // Attach click handlers for backgroup elements to open the upper tray
  for (let el of document.getElementsByClassName("_isBackground")) {
    el.addEventListener(
      "click",
      (event) => {
        if (event.target !== el) {
          // This paradigm feels wrong
          return;
        }

        const showing = (0,_trays__WEBPACK_IMPORTED_MODULE_1__.toggleTrays)();

        if (pauseOnMenus) {
          // This is a hack, and will conflict with settings you
          // make to the runloop and mute within the menu.
          if (showing) {
            c64.runloop.stop();
            c64.audio.setUiGain(0);
          }
          else {
            c64.runloop.run();
            c64.audio.setUiGain(1);
          }
        }
      }
    );
  }

  // Wire-up all the other UI elements (existing HTML) to code
  (0,_dialogs__WEBPACK_IMPORTED_MODULE_0__.initDialogs)();
  (0,_trays__WEBPACK_IMPORTED_MODULE_1__.initTrays)(c64);
  (0,_joystickDialog__WEBPACK_IMPORTED_MODULE_3__.initJoystickDialog)(c64);
  (0,_keyMapDialog__WEBPACK_IMPORTED_MODULE_4__.initKeyMapDialog)(c64);
  (0,_loaderDialog__WEBPACK_IMPORTED_MODULE_5__.initLoaderDialog)(c64);
  (0,_diskDialog__WEBPACK_IMPORTED_MODULE_6__.initDiskDialog)(c64);
  (0,_scopes__WEBPACK_IMPORTED_MODULE_2__.initScopes)(c64);

  c64.hooks.reportError = _dialogs__WEBPACK_IMPORTED_MODULE_0__.showErrorDialog;
  c64.hooks.setTitle = setTitle;
}

const initialTitle = document.title;

function setTitle(str) {
  // TODO: we should do this for ANSI mode too,
  // And get it into the snapshot name; at least so that clicking on the
  // snapshot will restore the window title.
  document.title = str.length ? `${str} (${initialTitle})` : initialTitle;
}


/***/ }),

/***/ "./src/host/webFrontEnd/joystickDialog.js":
/*!************************************************!*\
  !*** ./src/host/webFrontEnd/joystickDialog.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initJoystickDialog: () => (/* binding */ initJoystickDialog)
/* harmony export */ });
/* harmony import */ var _joystickDialog_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./joystickDialog.css */ "./src/host/webFrontEnd/joystickDialog.css");


let c64;
let state;

const crsrsBindings = [
  ["crsrs_key", "cursorsToKeys"],
  ["crsrs_cp1", "cursorsToCp1"],
  ["crsrs_cp2", "cursorsToCp2"],
];

function initJoystickDialog(nascentC64) {
  c64 = nascentC64;

  state = {
    // These maybe belong in some settings struct on c64
    cursorsToKeys: true,
    cursorsToCp1: false,
    cursorsToCp2: true,
  };

  for (let [id, stateKey] of crsrsBindings) {
    const el = document.getElementById(id);
    el.addEventListener(
      "click",
      () => {
        state[stateKey] = !state[stateKey];
        updateCursorElements();

        c64.keyboard.cursorsToKeys  = state.cursorsToKeys;
        c64.joystick.toControlPort1 = state.cursorsToCp1;
        c64.joystick.toControlPort2 = state.cursorsToCp2;

        event.stopImmediatePropagation();
      }
    );
  }

  updateCursorElements();
}

function updateCursorElements() {
  for (let [id, stateKey] of crsrsBindings) {
    const { classList } = document.getElementById(id);

    if (state[stateKey]) classList.add   ("selected");
    else                 classList.remove("selected");
  }
}


/***/ }),

/***/ "./src/host/webFrontEnd/keyMapDialog.js":
/*!**********************************************!*\
  !*** ./src/host/webFrontEnd/keyMapDialog.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initKeyMapDialog: () => (/* binding */ initKeyMapDialog)
/* harmony export */ });
/* harmony import */ var _keyMapDialog_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keyMapDialog.css */ "./src/host/webFrontEnd/keyMapDialog.css");


let c64;

// Should get/set this from/to a cookie in future
let naturalMapping = true;

function initKeyMapDialog(nascentC64) {
  c64 = nascentC64;

  document.getElementById("map_natural").addEventListener(
    "click",
    () => {
      naturalMapping = true;
      c64.keyboard.naturalMapping = true;
      updateMappingElements();
    }
  );

  document.getElementById("map_direct").addEventListener(
    "click",
    () => {
      naturalMapping = false;
      c64.keyboard.naturalMapping = false;
      updateMappingElements();
    }
  );

  updateMappingElements();
}

function updateMappingElements() {
  setSelectedness("map_natural", naturalMapping);
  setSelectedness("map_direct", !naturalMapping);
}

function setSelectedness(id, selected) {
  const { classList } = document.getElementById(id);
  if (selected) classList.add   ("selected");
  else          classList.remove("selected");
}


/***/ }),

/***/ "./src/host/webFrontEnd/loaderDialog.js":
/*!**********************************************!*\
  !*** ./src/host/webFrontEnd/loaderDialog.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initLoaderDialog: () => (/* binding */ initLoaderDialog)
/* harmony export */ });
/* harmony import */ var _demos_hoverbovver_prg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./demos/hoverbovver_prg */ "./src/host/webFrontEnd/demos/hoverbovver_prg.js");
/* harmony import */ var _demos_first_prg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./demos/first_prg */ "./src/host/webFrontEnd/demos/first_prg.js");
/* harmony import */ var _dialogs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dialogs */ "./src/host/webFrontEnd/dialogs.js");
/* harmony import */ var _ingest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ingest */ "./src/host/ingest.js");
/* harmony import */ var _loaderDialog_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./loaderDialog.css */ "./src/host/webFrontEnd/loaderDialog.css");







let c64;

function initLoaderDialog(nascentC64) {
  c64 = nascentC64;

  document
    .getElementById("hoverBovverButton")
    .addEventListener(
      "click",
      // TODO: reassign joystick to port 1 automatically
      () => launch("Hover Bovver.prg", _demos_hoverbovver_prg__WEBPACK_IMPORTED_MODULE_0__["default"])
    )
  ;

  document
    .getElementById("firstButton")
    .addEventListener(
      "click",
      () => launch("First.prg", _demos_first_prg__WEBPACK_IMPORTED_MODULE_1__["default"])
    )
  ;
}

function launch(filename, bytes) {
  (0,_ingest__WEBPACK_IMPORTED_MODULE_3__.ingest)(c64, filename, bytes);
  (0,_dialogs__WEBPACK_IMPORTED_MODULE_2__.closeAllDialogs)();
}


/***/ }),

/***/ "./src/host/webFrontEnd/lowerTray.js":
/*!*******************************************!*\
  !*** ./src/host/webFrontEnd/lowerTray.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initLowerTray: () => (/* binding */ initLowerTray),
/* harmony export */   updateFpsMessage: () => (/* binding */ updateFpsMessage)
/* harmony export */ });
/* harmony import */ var _dialogs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dialogs */ "./src/host/webFrontEnd/dialogs.js");
/* harmony import */ var _scopes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scopes */ "./src/host/webFrontEnd/scopes.js");
/* harmony import */ var _snapshot__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./snapshot */ "./src/host/webFrontEnd/snapshot.js");




let c64;

function initLowerTray(nascentC64) {
  c64 = nascentC64;

  for (let [buttonId, dialogId] of [
    ["joystickButton", "cursorKeysDialog"],
    ["keymapButton",   "keymapDialog"],
    ["loadButton",     "loadDialog"],
    ["aboutButton",    "aboutDialog"],
  ]) {
    const dialog = new _dialogs__WEBPACK_IMPORTED_MODULE_0__.Dialog(dialogId);

    handlerForEventForId(
      buttonId, 
      "click",
      () => dialog.open()
    );
  }

  handlerForEventForId(
    "pauseButton", 
    "click",
    () => c64.runloop.stop()
  );

  handlerForEventForId(
    "playButton", 
    "click",
    () => c64.runloop.run()
  );

  handlerForEventForId(
    "recordButton", 
    "click",
    () => (0,_snapshot__WEBPACK_IMPORTED_MODULE_2__.takeSnapshot)(c64)
  );

  handlerForEventForId(
    "muteButton", 
    "click",
    () => mute()
  );

  handlerForEventForId(
    "unmuteButton", 
    "click",
    () => unmute()
  );

  handlerForEventForId(
    "scopeButton", 
    "click",
    () => (0,_scopes__WEBPACK_IMPORTED_MODULE_1__.toggleScopes)()
  );

  // TODO: we're choosing an initial state here, but what we should do is start
  // with it muted, and change it to unmuted when the audio API resumes itself
  // after the first interaction.
  document.getElementById("unmuteButton").classList.add("hidden");

  // TODO: This is a bad pattern, the tray taking the hook for itself. Other
  // components are quite likely to want access to the start/stop one. Ideally
  // have an EventTarget object in the frontend root, to which these
  // components should call an addEventListener.

  c64.hooks.didStart = () => {
    document.getElementById("pauseButton").classList.remove("hidden");
    document.getElementById("playButton") .classList.add   ("hidden");
    updateFpsMessage("...Hz");
  };

  c64.hooks.didStop = () => {
    document.getElementById("pauseButton").classList.add   ("hidden");
    document.getElementById("playButton") .classList.remove("hidden");
    updateFpsMessage("");
  };

  nascentC64.hooks.updateFps = (fps) => {
    updateFpsMessage(`${fps}Hz`);
  };
}

function updateFpsMessage(message) {
  document.getElementById("fps").innerText = message;
}

function handlerForEventForId(id, eventName, fn) {
  document
    .getElementById(id)
    .addEventListener(eventName, fn)
  ;
}

function mute() {
  document.getElementById("muteButton")  .classList.add   ("hidden");
  document.getElementById("unmuteButton").classList.remove("hidden");
  c64.audio.setUiGain(0);
}

function unmute() {
  document.getElementById("muteButton")  .classList.remove("hidden");
  document.getElementById("unmuteButton").classList.add   ("hidden");
  c64.audio.setUiGain(1);
}


/***/ }),

/***/ "./src/host/webFrontEnd/ramAccessScope.js":
/*!************************************************!*\
  !*** ./src/host/webFrontEnd/ramAccessScope.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ramAccess: () => (/* binding */ ramAccess)
/* harmony export */ });
// bound by attach
let c64;

let canvas;
let context;
let imageData;
let bitmap;

function attach(nascentC64) {
  c64 = nascentC64;

  canvas    = document.getElementById("ramAccessCanvas");
  context   = canvas.getContext("2d");
  imageData = context.getImageData(0, 0, 256, 256);
  bitmap    = imageData.data;  
}

function onEnter() {
  clearCanvas();
  blitCanvas();

  c64.hooks.onRamRead = (addr) => {
    // +1 = green
    bitmap[(addr * 4) + 1] = 255;
  };

  c64.hooks.onRamWrite = (addr) => {
    // +0 = red
    bitmap[(addr * 4) + 0] = 255;
  };

  c64.hooks.onVicRead = (addr) => {
    // +2 = blue
    bitmap[(addr * 4) + 2] = 255;
  };

  c64.hooks.onFrameEnd = () => {
    blitCanvas();
    clearCanvas();
  };
}

function onExit() {
  c64.hooks.onRamRead  = undefined;
  c64.hooks.onRamWrite = undefined;
  c64.hooks.onVicRead  = undefined;
  c64.hooks.onFrameEnd = undefined;
}

function blitCanvas() {
  context.putImageData(imageData, 0, 0);
}

function clearCanvas() {
  let index = 0;

  for (let y = 0; y < 256; y++) {
    for (let x = 0; x < 256; x++) {
      bitmap[index++] = 0;
      bitmap[index++] = 0;
      bitmap[index++] = 0; 
      bitmap[index++] = 255;
    }
  }
}

const ramAccess = {
  domId: "ramAccessScope",
  onEnter,
  onExit,
  attach,
};


/***/ }),

/***/ "./src/host/webFrontEnd/scopes.js":
/*!****************************************!*\
  !*** ./src/host/webFrontEnd/scopes.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initScopes: () => (/* binding */ initScopes),
/* harmony export */   toggleScopes: () => (/* binding */ toggleScopes)
/* harmony export */ });
/* harmony import */ var _video_canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../video-canvas */ "./src/host/video-canvas.js");
/* harmony import */ var _collisionScope__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./collisionScope */ "./src/host/webFrontEnd/collisionScope.js");
/* harmony import */ var _ramAccessScope__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ramAccessScope */ "./src/host/webFrontEnd/ramAccessScope.js");
/* harmony import */ var _scopes_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scopes.css */ "./src/host/webFrontEnd/scopes.css");





let c64;
let isShowing = false;
// `selectedScope`: selected, but not necessarily active
let selectedScope = "sprites";

const scopes = {
  // Keys should match the <option> tag's `value`.
  sprites: {
    domId:       "spriteScope",
    onEnter:     () => c64.vic.setScope("scopeSprites"),
    onExit:      () => c64.vic.setScope(null),
  },
  background: {
    domId:       "backgroundScope",
    onEnter:     () => c64.vic.setScope("scopeBackground"),
    onExit:      () => c64.vic.setScope(null),
  },
  collision: _collisionScope__WEBPACK_IMPORTED_MODULE_1__.collision,
  colorRam: {
    onEnter:     () => c64.vic.setScope("scopeColorRam"),
    onExit:      () => c64.vic.setScope(null),
  },
  ramAccess: _ramAccessScope__WEBPACK_IMPORTED_MODULE_2__.ramAccess,
};

function initScopes(nascentC64) {
  c64 = nascentC64;

  const selectEl = document.getElementById("scopeSelect");

  selectEl
    .addEventListener(
      "change",
      (event) => {
        stopScope();
        hideScope();
        selectedScope = selectEl.value;
        showScope();
        startScope();
      }
    )
  ;

  for (const [,{ attach, domId }] of Object.entries(scopes)) {
    if (domId) {
      document
        .getElementById(domId)
        .classList
        .add("hidden")
      ;
    }
    if (attach) attach(nascentC64);
  }
}

function toggleScopes() {
  isShowing = !isShowing;

  // Tell the layout manager the side panel's moving
  (0,_video_canvas__WEBPACK_IMPORTED_MODULE_0__.setHasScope)(isShowing);

  // Open or close the side panel, and start/stop the selected scope
  const scopeRail        = document.getElementById("scopeRail");
  const scopeRailBlanket = document.getElementById("scopeRail-blanket");

  if (isShowing) {
    scopeRail.classList.remove("hidden");
    scopeRailBlanket.classList.add("hidden");
    startScope();
  }
  else {
    scopeRail.classList.add("hidden");
    scopeRailBlanket.classList.remove("hidden");
    stopScope();
  }
}

function startScope() {
  const { domId, onEnter } = scopes[selectedScope];
  if (domId) {
    document
      .getElementById(domId)
      .classList
      .remove("hidden")
    ;
  }
  onEnter();
}

function stopScope() {
  const { onExit } = scopes[selectedScope];
  onExit();
}

function hideScope() {
  const { domId } = scopes[selectedScope];
  if (domId) {
    document
      .getElementById(domId)
      .classList
      .add("hidden")
    ;
  }
}

function showScope() {
  const { domId } = scopes[selectedScope];
  if (domId) {
    document
      .getElementById(domId)
      .classList
      .remove("hidden")
    ;
  }
}


/***/ }),

/***/ "./src/host/webFrontEnd/snapshot.js":
/*!******************************************!*\
  !*** ./src/host/webFrontEnd/snapshot.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   takeSnapshot: () => (/* binding */ takeSnapshot)
/* harmony export */ });
/* harmony import */ var _video_canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../video-canvas */ "./src/host/video-canvas.js");
/* harmony import */ var _snapshots_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./snapshots.css */ "./src/host/webFrontEnd/snapshots.css");



let numSnapshotsShowing = 0;
let lastSnapshotNum = 0;

let maskCanvas;

function createSnapshotCanvas() {

  // Would prob. be better to ask video-canvas for its element instead
  const mainCanvas = document.getElementById("canvas");

  // Create the 1701-monitor-bezel mask canvas if we haven't already
  if (!maskCanvas) {
    maskCanvas = document.createElement("canvas");

    maskCanvas.width  = mainCanvas.width;
    maskCanvas.height = mainCanvas.height;

    const context = maskCanvas.getContext("2d");

    // Fill color is irrelevant; we're just relying on alpha channel
    context.fill(
      new Path2D(
        "M386.79,141s.1,29.89-1,59.26c-1,26.65-3.3,52.86-4.21,56.07-2.22,7.8-3.75,17.87-18.83,20.46-8.38,1.44-34.53,2.84-62.95,3.65C253.8,281.75,201,282,201,282s-52.8-.25-98.76-1.56c-28.42-.81-54.57-2.21-62.95-3.65-15.08-2.59-16.61-12.66-18.83-20.46-.91-3.21-3.17-29.42-4.21-56.07-1.14-29.37-1-59.26-1-59.26s-.1-29.89,1-59.26c1-26.65,3.3-52.86,4.21-56.07,2.22-7.8,3.75-17.87,18.83-20.46,8.38-1.44,34.53-2.84,63-3.65C148.2.25,201,0,201,0s52.8.25,98.76,1.56c28.42.81,54.57,2.21,62.95,3.65,15.08,2.59,16.61,12.66,18.83,20.46.91,3.21,3.17,29.42,4.21,56.07C386.89,111.11,386.79,141,386.79,141Z"
      )
    );
  }

  const canvas = document.createElement("canvas");

  canvas.width  = mainCanvas.width;
  canvas.height = mainCanvas.height;

  const context = canvas.getContext("2d");

  context.drawImage(maskCanvas, 0, 0);
  context.globalCompositeOperation = "source-in";
  context.drawImage(mainCanvas, 0, 0);

  return canvas;
}


function takeSnapshot(c64) {

  let alive = true;

  // TODO: inappropriate name now
  const bubble = document.createElement("div");

  const innerFrame = document.createElement("div");
  bubble.append(innerFrame);
  innerFrame.classList.add("innerFrame");

  const { classList } = bubble;

  classList.add("snapshot");
  classList.add("collapsed");

  requestAnimationFrame(
    () => {
      requestAnimationFrame(
        () => {
          classList.remove("collapsed");
        }
      );
    }
  );


  const close = document.createElement("button");
  close.setAttribute("class", "close");

  close.addEventListener(
    "click",
    (event) => {
      event.stopImmediatePropagation();
      if (alive) {
        onClose(classList);
        alive = false;
      }
    }
  );

  innerFrame.append(close);

  const button =  document.createElement("button");

  const canvas = createSnapshotCanvas();

  document
    .getElementById("snapshotsRail")
    .prepend(bubble)
  ;

  const serial = c64.runloop.serialize();
  const blob = new Blob(
    Array.from(
      // `serial` is serialized, but we'll JSON encode it for testing in source
      // for now. We won't need that later.
      JSON.stringify(serial)
    ),
    { type: "application/json" }
  );

  const link = document.createElement("a");
  link.innerText = `${++lastSnapshotNum}.json`;
  link.href = URL.createObjectURL(blob);

  link.addEventListener(
    "click",
    (event) => {
      event.preventDefault();
      event.stopImmediatePropagation();
      onClickSnapshot(c64, serial)
    }
  );

  canvas.addEventListener(
    "click",
    () => onClickSnapshot(c64, serial)
  );

  bubble.addEventListener(
    "transitionend",
    (event) => {
      onTransitionEnd(event, bubble, alive);
    }
  );

  button.append(canvas);

  innerFrame.append(button);
  innerFrame.append(link);

  numSnapshotsShowing++;
  reconsiderSnapshotRail();
}

function onClickSnapshot(c64, serial) {
  c64.runloop.stop();
  c64.runloop.reset();
  c64.runloop.deserialize(serial);
  c64.runloop.run(); 
}

function reconsiderSnapshotRail() {
  // Unlike the scopeRail, the snapshots rail doesn't need a blanket. The only
  // we for it to be hidden is if all the snapshots have been deleted; hence we
  // don't need to worry about clicking on one that wasn't there.

  const shouldShow = numSnapshotsShowing > 0;
  (0,_video_canvas__WEBPACK_IMPORTED_MODULE_0__.setHasSnapshots)(shouldShow);

  const { classList } = document.getElementById("snapshotsRail");

  if (shouldShow) classList.remove("hidden");
  else            classList.add   ("hidden");
}

function onTransitionEnd(event, bubble, alive) {
  if (event.target !== bubble) return;

  if (!alive) {
    console.log("onTransitionEnd");
    bubble.remove();
  }
}

function onClose(classList) {
  requestAnimationFrame(
    () => {
      requestAnimationFrame(
        () => {
          classList.add("collapsed");
        }
      );
    }
  );

  // transitionend handler will remove the bubble from the DOM, but for the
  // purposes of showing/hiding the rail, we'll consider it to have gone
  // already.
  numSnapshotsShowing--;
  reconsiderSnapshotRail();
}


/***/ }),

/***/ "./src/host/webFrontEnd/trays.js":
/*!***************************************!*\
  !*** ./src/host/webFrontEnd/trays.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initTrays: () => (/* binding */ initTrays),
/* harmony export */   toggleTrays: () => (/* binding */ toggleTrays)
/* harmony export */ });
/* harmony import */ var _upperTray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./upperTray */ "./src/host/webFrontEnd/upperTray.js");
/* harmony import */ var _lowerTray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lowerTray */ "./src/host/webFrontEnd/lowerTray.js");
/* harmony import */ var _video_canvas__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../video-canvas */ "./src/host/video-canvas.js");
/* harmony import */ var _trays_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./trays.css */ "./src/host/webFrontEnd/trays.css");





let isShowing = false;

function toggleTrays() {
  isShowing = !isShowing;

  const upperTray = document.getElementById("upperTray");
  const upperTrayBlanket = upperTray.getElementsByClassName("tray-blanket")[0];

  const trayClassList    = upperTray       .classList;
  const blanketClassList = upperTrayBlanket.classList;

  if (isShowing) {
    trayClassList.remove("hidden");
    blanketClassList.add("hidden");
  }
  else {
    trayClassList.add("hidden");
    blanketClassList.remove("hidden");
  }

  // As above, so below
  const lowerTray = document.getElementById("lowerTray");
  const lowerTrayBlanket = lowerTray.getElementsByClassName("tray-blanket")[0];

  lowerTray.classList = trayClassList;
  lowerTrayBlanket.classList = blanketClassList;

  (0,_video_canvas__WEBPACK_IMPORTED_MODULE_2__.setHasTrays)(isShowing);
  return isShowing;
}

function initTrays(nascentC64) {
  (0,_upperTray__WEBPACK_IMPORTED_MODULE_0__.initUpperTray)(nascentC64);
  (0,_lowerTray__WEBPACK_IMPORTED_MODULE_1__.initLowerTray)(nascentC64);
}


/***/ }),

/***/ "./src/host/webFrontEnd/upperTray.js":
/*!*******************************************!*\
  !*** ./src/host/webFrontEnd/upperTray.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initUpperTray: () => (/* binding */ initUpperTray)
/* harmony export */ });
let c64;
let serial = null;
let countdownInterval = null;

function initUpperTray(nascentC64) {
  c64 = nascentC64;

  handlerForEventForId(
    "resetButton", 
    "click",
    () => undoableReset()
  );

  handlerForEventForId(
    "undoResetButton", 
    "click",
    () => {
      if (serial) {
        c64.runloop.deserialize(serial);
        c64.runloop.run();
        removeUndoResetButton();
      }
    }
  );
}

function handlerForEventForId(id, eventName, fn) {
  document
    .getElementById(id)
    .addEventListener(eventName, fn)
  ;
}

function undoableReset() {
  serial = c64.runloop.serialize();
  c64.runloop.reset();
  c64.runloop.run();

  removeUndoResetButton();
  addUndoResetButton();
}

function removeUndoResetButton() {

  const [ resetButton, undoResetButton, label ] = [
    "resetButton",
    "undoResetButton",
    "undoResetButton-label"
  ].map((id) => document.getElementById(id));

  resetButton.classList.remove("hidden");
  undoResetButton.classList.add("hidden");
  label.innerText = "";

  if (countdownInterval) {
    clearInterval(countdownInterval);
    countdownInterval = null;
  }
}

function addUndoResetButton() {

  const [
    resetButton,
    undoResetButton,
    label
  ] = [
    "resetButton",
    "undoResetButton",
    "undoResetButton-label"
  ].map((id) => document.getElementById(id));

  resetButton.classList.add("hidden");
  undoResetButton.classList.remove("hidden");

  const updateLabelCountdown = () => {
    label.innerText = `Undo (${countdown})`;
  };
  
  let countdown = 6;
  updateLabelCountdown();

  if (countdownInterval) clearInterval(countdownInterval);

  countdownInterval = setInterval(
    () => {
      if (--countdown === 0) {
        removeUndoResetButton();
        serial = null;
      }
      else updateLabelCountdown();
    },
    1000
  );
}


/***/ }),

/***/ "./src/monitor.js":
/*!************************!*\
  !*** ./src/monitor.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   attach: () => (/* binding */ attach)
/* harmony export */ });
/* harmony import */ var _tools_disasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools/disasm */ "./src/tools/disasm.js");
/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./debug */ "./src/debug.js");



// Bound by attach
let c64;
let runloop;
let cli;        // TODO: ugly

function attach(nascentC64) {
  c64 = nascentC64;
  runloop = c64.runloop;
  installCli();
}

function help() {
  console.log("Monitor commands:");
  console.log("-----------------");
  cli.forEach(i => i.help.forEach(j => console.log(j)));
  console.log("---");
}

function installCli() {
  cli = [
    {
      name: "h",
      help: [
        "h()       - help",
      ],
      fn: help
    },
    {
      name: "b",
      help: [
        "b()       - stop"
      ],
      fn: runloop.stop,
    },
    {
      name: "c",
      help: [
        "c()       - continue execution           c(0xfce2)         - execute from $fce2",
      ],
      fn: (from) => {
        if (from !== undefined) c64.cpu.getState().pc = from;
        runloop.run();
      }
    },
    {
      name: "s",
      help: [
        "s()       - single-step instruction      s(5)              - step 5 instructions",

      ],
      fn: (...args) => void singleStep(...args) // don't return the promise
    },
      {
      name: "u",
      help: [
        "u(0xe3a0) - run until PC = $e3a0         u(0xe3a0, true)   - same, as fast as possible",
      ],
      fn: untilPc
    },
    {
      name: "w",
      help: [
        "w(0x400, 0xff) - write $ff to $0400",
      ],
      fn: (addr, byte) => c64.wires.cpuWrite(addr, byte)
    },
    {
      name: "x",
      help: [
        "x(0x0400) - show hex from $400           x(0x0400, 0x1000) - show from $0400 to $1000",
      ],
      fn: (from, to) => {
        busDump(from, Math.min(to === undefined ? from + 0x7f : to), 0xffff);
      }
    },
      {
      name: "d",
      help: [
        "d(0x6000) - disassemble from $6000       d(r().pc)         - disassemble from PC",
      ],
      fn: (from, to=0x20 + from) => console.log((0,_tools_disasm__WEBPACK_IMPORTED_MODULE_0__.disasm)(c64.wires.cpuRead, from, to))
    },
    {
      name: "r",
      help: [
        "r()       - show registers               r().a=0xab        - set the acc to $ab",
      ],
      fn: () => {
        try {
          c64.cpu.showState();
        }
        catch (r) {}
        return c64.cpu.getState();
      }
    },
    {
      name: "y",
      help: [
        "y(370000) - run until cycle 370000",
      ],
      fn: untilCycle
    },
    {
      name: "f",
      help: [
        "f(5)      - run at 5 frames/second",
      ],
      fn: fps => runloop.run({ fps })
    },
    {
      name: "z",
      help: [
        "z()       - reset",
      ],
      fn: () => {
        runloop.reset();
        runloop.run();
      }
    },
  ];

  cli.forEach(
    i => {
      globalThis[i.name] = i.fn;
    }
  );

  help();

  // Strictly for the user to use, through the JavaScript console
  globalThis.c64 = c64;
}


async function singleStep(steps = 1) {
  while (steps--) {
    const initialPc = c64.cpu.getState().pc;
    await runloop.run({
      tick: () => c64.cpu.getState().pc !== initialPc
    });
    c64.cpu.showState();
  }
}

async function untilPc(pc, fast) {
  if (pc === undefined) {
    console.error("Missing argument: PC address");
    return;
  }

  await runloop.untilPc(pc, fast);
  c64.cpu.showState();
}

function untilCycle(cycle) {
  const runloopState = runloop.getState();
  runloop.run({
    tick: () => runloopState.cycle >= cycle,
    fps: Infinity,
  });
}

function busDump(from, to) {
  const { cpuRead } = c64.wires;
  const displayFrom = Math.floor(from / 16) * 16;
  const displayTo   = Math.floor(  to / 16) * 16;

  for (let addr = displayFrom; addr <= displayTo; addr += 16) {

    let line = "";
    let raw = "";

    for (let i = 0; i < 16; i++) {

      const a = addr + i;
      let hex = "  ";
      let char = " ";

      if ((a >= from) && (a <= to)) {
        const byte = cpuRead(a);
        hex = (0,_debug__WEBPACK_IMPORTED_MODULE_1__.xx)(byte);
        char = _debug__WEBPACK_IMPORTED_MODULE_1__.petsciiToChar[byte];
      }

      line += ` ${hex}`;
      if (i === 7) line += " ";

      raw += char;
    }

    console.log(`${(0,_debug__WEBPACK_IMPORTED_MODULE_1__.$xxxx)(addr)}: ${line}   ${raw}`);
  }
}


/***/ }),

/***/ "./src/target/bringup.js":
/*!*******************************!*\
  !*** ./src/target/bringup.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bringup: () => (/* binding */ bringup)
/* harmony export */ });
/* harmony import */ var _runloop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./runloop */ "./src/target/runloop.js");
/*
   bringup: a bootstrapping sequencer for initializing the virtual machine.
  
   The C64 is a system of mutually dependent components. We have to be careful,
   in structuring the emulator sources, that we don't introduce cyclic
   dependencies between modules, and when initializing a component, we have to
   guarantee that it doesn't try interacting with another component that hasn't
   itself yet initialized.
  
   This module orchestrates this bringup. Supply it with a structure of
   components representing the whole machine, and it'll get it started.
*/



function bringup({
  host:   { audio, video, keyboard, joystick },
  target: { wires, ram, vic, sid, cpu, cias, tape, basic, kernal, character },
  attachments
}) {

  const c64 = {
    // 'hooks' is a way for the target machine to trigger a host-side action,
    // for example, updating the FPS count on the UI, if there is one.
    // Target shouldn't assume any particular hook is present, but the presence
    // of the `hooks` object is at least guaranteed.
    hooks: {},
  };

  // First the ROMs, which, being just data, are truly at the end of the chain.
  c64.rom = {
    basic,
    kernal,
    character,
  };

  // ...followed by the RAM, which likewise won't be calling anyone else
  ram(c64);

  // wires has to go next. The one guarantee that other modules have while
  // initializing is that its functions and state structure are present.
  // (But must not be called until after initialization.)
  wires(c64);

  // Host interfaces have to attach next (in any order).
  // The target devices can assume, when they attach, that the functions and
  // objects for the interfaces are final.
  audio(c64);
  video(c64);
  joystick(c64);
  keyboard(c64);

  // Now all the devices (in any order).
  // Each should add a structure to the c64 for their
  // state and accessors, and the device should be in a valid reset state, but
  // must not call other devices in resetting, since there's no guarantee that
  // other devices are yet attached.
  //
  // For example, CIA2, when assigning a default value for its Vic bank, must
  // not then call wires to announce the change in memory mapping. Rather, we
  // have to co-ordinate our reset states such that the devices' default values
  // happen to be consistent with each other.
  vic(c64);
  sid(c64);
  cias(c64);
  cpu(c64);
  tape(c64);

  // By this point we're done, and no longer have to be careful about order of
  // execution.
  (0,_runloop__WEBPACK_IMPORTED_MODULE_0__.attach)(c64);

  // Add any additional attachments for this configuration
  for (let attachment of attachments) attachment(c64);

  return c64;
}


/***/ }),

/***/ "./src/target/cias.js":
/*!****************************!*\
  !*** ./src/target/cias.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   attach: () => (/* binding */ attach)
/* harmony export */ });
/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../debug */ "./src/debug.js");
/* harmony import */ var _tools_serializerSupport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tools/serializerSupport */ "./src/tools/serializerSupport.js");
/*
   cias: emulates both of the 6526 complex interface adaptors

   As well as emulating the CIAs themselves, this module provides interfacing
   for the devices that would be attached to them. For example, when it sees
   that a new value will be emitted on CIA2 port A, it will instruct the Vic
   bank-mapper (in wires) that the Vic bank just changed. 

   The code below represents a failed attempt at making the CIA emulation
   cycle-accurate. Its nextTickFn attempts to model what the Lorenz tests
   expect to see happen at various cycles after events, but its model
   misunderstands what's really going on, and can't be adjusted to pass the
   tests.

   For an accurate model, see Lorenz's own, at:
      https://ist.uwaterloo.ca/~schepers/MJK/cia6526.html

   Some additional caveats:

   - https://en.wikipedia.org/wiki/MOS_Technology_CIA

      "Due to a bug in many 6526s (see also errata below), the alarm IRQ would
      not always occur when the seconds component of the alarm time is exactly
      zero. The workaround is to set the alarm's tenths value to 0.1 seconds.

      In addition to the aforementioned alarm clock interrupt bug, many CIAs
      exhibited a defect in which the part would fail to generate a timer B 
      hardware interrupt if the interrupt control register (ICR) was read one
      or two clock cycles before the time when the interrupt should have
      actually occurred. This defect, as well as logic errors in the Commodore
      provided (8 bit) operating system, caused frequent pseudo-RS-232 errors
      in the Commodore 64 and Commodore 128 computers when running at higher 
      baud rates."

   - https://codebase64.org/doku.php?id=base:detecting_6526_vs_6526a_cia_chips

      "This sets off a single-shot NMI to interrupt immediately before an INC
      statement. The older 6526 triggers one cycle later, so it will run the
      INC while the newer one won't.
*/

// TODO: I really need to rename irq_status and irq_control to be something
// like 'int_status', etc. as it might be NMI that they relate to.




// Bound by attach
let c64;
let setCia1Irq;
let setCia2Nmi;
let setVicBank;

const CLOCK_SPEED = 985248;                 // cycles/second (PAL 50Hz)
const todOffset   = 10 * 60 * CLOCK_SPEED;  // 10 minutes in cycles

let state = {};

const defaultTimerRegs = {
  value_lo:       0,
  value_hi:       0,
  startValue_lo:  0,
  startValue_hi:  0,
  control:        0,
  status:         0,
  nextTickFn:     tick_timer_stopped,
};

const defaultPortRegs = {
  value:          0,
  direction:      0,
};

const makeDefaultCiaRegs = (is1) => ({
  is1,
  port_a:         { ...defaultPortRegs },
  port_b:         { ...defaultPortRegs },
  shift:          0,
  irq_status:     0,
  irq_control:    0,
  tod_10ths:      0,
  tod_seconds:    0,
  tod_minutes:    0,
  tod_hours:      0,
  timer_a:        { isA: true,  ...defaultTimerRegs },
  timer_b:        { isA: false, ...defaultTimerRegs },
});


function attach(nascentC64) {
  c64 = nascentC64;

  setCia1Irq = c64.wires.setCia1Irq;
  setCia2Nmi = c64.wires.setCia2Nmi;
  setVicBank = c64.wires.setVicBank;

  c64.keyboard.setSetKeyMatrix(
    (keyMatrix) => {
      state.keyMatrix = keyMatrix;
    }
  );

  c64.joystick.setSetJoystick1((value) => { state.joystick1 = value; });
  c64.joystick.setSetJoystick2((value) => { state.joystick2 = value; });

  c64.cias = {
    // Control
    tick,
    reset,
    serialize,
    deserialize,
    // MMIO
    read_dc00_dcff,
    read_dd00_ddff,
    write_dc00_dcff,
    write_dd00_ddff,
    // Other wires
    raiseTapeInterrupt,
  };

  reset();
}

function reset() {
  state = {
    cia1: makeDefaultCiaRegs(true),
    cia2: makeDefaultCiaRegs(false),

    // joystick1/joystick2 represent what the respective port values would be
    // in isolation (if joystick port 1 wasn't shared with the keyboard). Lines
    // float high.
    joystick1: 0xff,
    joystick2: 0xff,

    // keyMatrix: what values should appear on CIA1 port B for each of the
    // eight bits that might be selected on its port A write, *except that*
    // - they appear inverted here (they'll be flipped back on read), and 
    // - the joystick port 1 contribution is stripped out.
    keyMatrix: [0, 0, 0, 0, 0, 0, 0, 0],
  };
}

function numberToBcd(num) {
  // Converts 59 -> 0x59, rounding down if num is floating-point.
  return parseInt(Math.floor(num), 16);
}

function underflow(timer, cia) {
  // Timer reloads from the latch, regardless of whether this was one-shot or
  // continuous.
  timer.value_lo = timer.startValue_lo;
  timer.value_hi = timer.startValue_hi;

  // Delay the actioning of this until the next cycle.
  timer.nextTickFn = tick_timer_postUnderflow_0;
}

/*
  #1 #2  DD06 sequence 1/2/3 (4)
  ---------------------------------
  00 01  keep   keep   count  count     tick_timer_startup_0     -> tick_timer_running
  00 10  keep   load   keep   keep      tick_timer_stoppedLoad_0 -> tick_timer_stopped
  00 11  keep   load   keep   count     tick_timer_startup_0     -> tick_timer_running
  01 11  count  load   keep   count     tick_timer_runningLoad_0 -> tick_timer_running
  01 10  count  load   keep   keep      tick_timer_shutdown_0    -> tick_timer_stopped
  01 00  count  count  keep   keep      tick_timer_shutdown_0    -> tick_timer_stopped
*/

function tick_timer_startup_0(timer, cia) {
  // First cycle is always a continuation
  timer.nextTickFn = tick_timer_startup_1;
}

function tick_timer_startup_1(timer, cia) {
  if (timer.control & 0x10) {
    load(timer);
    timer.nextTickFn = tick_timer_startup_2;
  }
  else timer.nextTickFn = tick_timer_running;
}

function tick_timer_startup_2(timer, cia) {
  // We did a load, and that stalls the count for a cycle
  timer.nextTickFn = tick_timer_running;
}

function tick_timer_shutdown_0(timer, cia) {
  // First cycle is always a continuation
  // decrement(timer, cia);
  // timer.nextTickFn = tick_timer_shutdown_1;

  // short-circuit what I thought it was doing; it doesn't look like it needs two cycles to stop
  tick_timer_shutdown_1(timer, cia);  
}

function tick_timer_shutdown_1(timer, cia) {
  if (timer.control & 0x10) {
    load(timer);
  }
  else decrement(timer, cia);
  timer.nextTickFn = tick_timer_stopped;
}

function tick_timer_stoppedLoad_0(timer, cia) {
  // First cycle is always a continuation
  timer.nextTickFn = tick_timer_stoppedLoad_1;
}

function tick_timer_stoppedLoad_1(timer, cia) {
  load(timer);
  timer.nextTickFn = tick_timer_stopped;
}

function tick_timer_runningLoad_0(timer, cia) {
  // First cycle is always a continuation
  decrement(timer, cia);
  timer.nextTickFn = tick_timer_runningLoad_1;
}

function tick_timer_runningLoad_1(timer, cia) {
  load(timer);
  timer.nextTickFn = tick_timer_runningLoad_2;
}

function tick_timer_runningLoad_2(timer, cia) {
  // We did a load, and that stalls the count for a cycle
  timer.nextTickFn = tick_timer_running;
}

function tick_timer_runningNonLoad_0(timer, cia) {
  // Starting while already started seems to cause a one-cycle pause
  timer.nextTickFn = tick_timer_running;
}


function tick_timer_running(timer, cia) {
  decrement(timer, cia);
}

function tick_timer_stopped(timer, cia) {
}

function tick_timer_postUnderflow_0(timer, cia) {

  if (timer.isA) {
    // Mark Timer A interrupt as having happened
    cia.irq_status |= 0b01;

    // Is Timer B configured to count when we underflow? (and not in
    // conjunction with the CNT pin)
    if ((cia.timer_b.control & 0b01100000) === 0b01000000) {
      decrement(cia.timer_b, cia);
    }
  }
  else {
    // Mark Timer B interrupt as having happened
    cia.irq_status |= 0b10;
  }

  reconsiderInterrupt(cia);

  // bit 3: 1 = timer stops on underflow
  if (timer.control & 0b1000) {
    timer.nextTickFn = tick_timer_postUnderflow_1;
  }
  else {
    // Timer restarts on underflow (but we still fire the interrupt)
    // In this case, we have a one-cycle delay before restarting the count,
    // presumably to compensate for the timer reloading instead of showing
    // a zero count.
    timer.nextTickFn = tick_timer_running;
  }

  // CIA1TAB test shows there's a one-cycle delay here
  // timer.nextTickFn = tick_timer_running;
}

function tick_timer_postUnderflow_1(timer, cia) {
  // We're on the one-shot flow here. Finally mark the timer as having stopped.
  timer.control &= 0xfe;
  timer.nextTickFn = tick_timer_stopped;
}



function load(timer) {
  timer.value_lo = timer.startValue_lo;
  timer.value_hi = timer.startValue_hi;
}


function decrement(timer, cia) {
  timer.value_lo--;

  // The 'underflow' interrupt, timer stop and reload happen if the timer
  // reaches zero, not if it actually underflows.
  if (!timer.value_lo && !timer.value_hi) {
    underflow(timer, cia);
    return;
  }

  if (timer.value_lo < 0) {
    timer.value_lo = 0xff;
    timer.value_hi = --timer.value_hi & 0xff;
  }
}

function reconsiderInterrupt(cia) {
  if (cia.irq_status & cia.irq_control) {
    if (cia.is1) setCia1Irq(true);
    else         setCia2Nmi(true);
  }

  // Otherwise... don't setCiaXXxx(false): nothing can un-set the interrupt
  // state except for reading the interrupt control/status register, handled by
  // the read logic

  // "Once the interrupt flip-flop has been set, changing the condition in the
  // IMR has no effect. Only reading the ICR will clear it."
  // - Lorenz (https://ist.uwaterloo.ca/~schepers/MJK/cia6526.html)
}

function tick_cia(cia) {

  // Set bit 7 of the irq_status
  const int_state = Boolean(cia.irq_status & cia.irq_control);
  cia.irq_status = (cia.irq_status & 0x7f) | (int_state ? 0x80 : 0);
  // maybe this is where we actually pull the interrupt line low

  cia.timer_a.nextTickFn(cia.timer_a, cia);
  cia.timer_b.nextTickFn(cia.timer_b, cia);
}

function tick() {
  tick_cia(state.cia1, setCia1Irq);
  tick_cia(state.cia2, setCia2Nmi);
}

function read(cia, reg) {

  switch (reg) {

    // cases 0x0 and 0x1: picked up by the read handlers specific to that CIA,
    // but this defines default behavior if they do nothing.

    case 0x0:     // $dc02 / $dd02: port A value
      // TODO: honor port direction
      return cia.port_a.value;

    case 0x1:     // $dc02 / $dd02: port A value
      // TODO: honor port direction
      return cia.port_b.value;

    case 0x2:     // $dc02 / $dd02: port A data direction
      // TODO: honor port direction
      return cia.port_a.direction;

    case 0x3:     // $dc03 / $dd03: port B data direction
      // TODO: honor port direction
      return cia.port_b.direction;

    case 0x4:     // $dc04 / $dd04: timer A value, low byte
      return cia.timer_a.value_lo;

    case 0x5:     // $dc05 / $dd05: timer A value, high byte
      return cia.timer_a.value_hi;

    case 0x6:     // $dc06 / $dd06: timer B value, low byte
      return cia.timer_b.value_lo;

    case 0x7:     // $dc07 / $dd07: timer B value, high byte
      return cia.timer_b.value_hi;

    case 0x8:     // $dc08 / $dd08: time of day, tenths
      {
        let t = (c64.runloop.getState().cycle + todOffset) / CLOCK_SPEED;
        t *= 10;  // tenths
        t %= 10;  // ...and just the tenths
        return numberToBcd(t);
      }

    case 0x9:     // $dc09 / $dd09: time of day, seconds
      {
        let t = (c64.runloop.getState().cycle + todOffset) / CLOCK_SPEED;
        t %= 60;  // ...and just the seconds
        return numberToBcd(t);
      }

    case 0xa:     // $dc0a / $dd0a: time of day, minutes
      {
        let t = (c64.runloop.getState().cycle + todOffset) / CLOCK_SPEED;
        t /= 60;  // minutes
        t %= 60;  // ...and just the minutes
        return numberToBcd(t);
      }

    case 0xb:     // $dc0b / $dd0b: time of day, hours
      {
        let t = (c64.runloop.getState().cycle + todOffset) / CLOCK_SPEED;
        t /= 60;  // minutes
        t /= 60;  // hours
        t %= 24;  // ...and just the hours

        // Result must be 12 hour, with MSB being the meridiem
        let ret = numberToBcd(t % 12);
        ret |= (t > 12) ? 0x80 : 0;
        return ret;
      }

    case 0xc:     // $dc0c / $dd0c: serial shift
      // TODO: Serial shifter not implemented
      (0,_debug__WEBPACK_IMPORTED_MODULE_0__.unimplementedWarning)("serial shifter read");
      return 0;

    case 0xd:     // $dc0d / $dd0d: interrupt status/control
      {
        // Reading the interrupt status clears it
        const ret = cia.irq_status;
        cia.irq_status = 0;

        if (cia.is1) setCia1Irq(false);
        else         setCia2Nmi(false);

        return ret;
      }

    // This is kludgey. The load doesn't get stored permanently; I am
    // storing it (the cycle sequence needs it remembered), so I'm just zeroing
    // it out on read. Do not like.

    case 0xe:     // $dc0e / $dd0e: timer A control
      return cia.timer_a.control & 0b11101111;

    case 0xf:     // $dc0f / $dd0f: timer B control
      return cia.timer_b.control & 0b11101111;
  }
}

function write_timerControl(timer, byte) {

  /*
    #1 #2  DD06 sequence 1/2/3 (4)
    ---------------------------------
    00 01  keep   keep   count  count     tick_timer_startup_0     -> tick_timer_running
    00 10  keep   load   keep   keep      tick_timer_stoppedLoad_0 -> tick_timer_stopped
    00 11  keep   load   keep   count     tick_timer_startup_0     -> tick_timer_running
    01 11  count  load   keep   count     tick_timer_runningLoad_0 -> tick_timer_running
    01 10  count  load   keep   keep      tick_timer_shutdown_0    -> tick_timer_stopped
    01 00  count  count  keep   keep      tick_timer_shutdown_0    -> tick_timer_stopped
  */

  // If we're not counting cycles CPU cycles...
  if (byte & 0b01100000) {
    // Maybe, like the cycle counter, it has a cycle for this to get noticed.
    // I haven't looked.
    timer.nextTickFn = tick_timer_stopped;

    // (There's an edge case here about if it was running but not counting cycles)
  }
  // We are counting cycles CPU cycles...
  else {

    // If timer was running...
    if (timer.control & 1) {
      // ...and we're keeping it running...
      if (byte & 1) {
        // ...but we're doing a load
        if (byte & 0x10) {
          timer.nextTickFn = tick_timer_runningLoad_0;
        }
        // ...or not doing a load
        else {
          timer.nextTickFn = tick_timer_runningNonLoad_0;
        }
      }
      // ...and we're stopping it...
      else {
        timer.nextTickFn = tick_timer_shutdown_0;
      }
    }
    // If timer was stopped...
    else {
      // ...but we're starting it...
      if (byte & 1) {
        timer.nextTickFn = tick_timer_startup_0;
      }
      // ...and we're keeping it stopped...
      else {
        // ...but we're doing a load
        if (byte & 0x10) {
          timer.nextTickFn = tick_timer_stoppedLoad_0;
        }
      }
    }
  }

  // TODO: we're not doing anything about bits 1 or 2, on setting bits of the
  // port when an underflow/overflow occurs. (How does an overflow even happen?
  // When used for the serial shift register?)
  // And as for the other bits... non-CPU-clock source, shift register
  // direction, 50/60Hz clock select... we don't do any of that.

  if (byte & 1) (0,_debug__WEBPACK_IMPORTED_MODULE_0__.unimplementedWarning)("indicate timer underflow on port B");

  timer.control = byte;
}

function write_timerLow(timer, byte) {
  timer.startValue_lo = byte;

}

function write_timerHigh(timer, byte) {
  timer.startValue_hi = byte;

  // Load the timer value immediately if the timer's not running
  if (!(timer.control & 1)) {
    load(timer);
  }
}

function raiseTapeInterrupt() {
  state.cia1.irq_status |= 0x10;
  reconsiderInterrupt(state.cia1);
}

function write(cia, reg, byte) {
  switch (reg) {

    case 0x0:
      // TODO: honor port direction
      cia.port_a.value = byte;
      break;

    case 0x1:
      // TODO: honor port direction
      cia.port_b.value = byte;
      break;

    case 0x2:     // $dc02 / $dd02: port A data direction
      cia.port_a.direction = byte;
      break;

    case 0x3:     // $dc03 / $dd03: port B data direction
      cia.port_b.direction = byte;
      break;

    case 0x4:     // $dc04 / $dd04: timer A value, low byte
      write_timerLow(cia.timer_a, byte);
      break;

    case 0x5:     // $dc05 / $dd05: timer A value, high byte
      write_timerHigh(cia.timer_a, byte);
      break;

    case 0x6:     // $dc06 / $dd06: timer B value, low byte
      write_timerLow(cia.timer_b, byte);
      break;

    case 0x7:     // $dc07 / $dd07: timer B value, high byte
      write_timerHigh(cia.timer_b, byte);
      break;

    case 0x8:     // $dc08 / $dd08: time of day
      (0,_debug__WEBPACK_IMPORTED_MODULE_0__.unimplementedWarning)("time of day clock write");
      break;

    case 0x9:     // $dc09 / $dd09: time of day
      (0,_debug__WEBPACK_IMPORTED_MODULE_0__.unimplementedWarning)("time of day clock write");
      break;

    case 0xa:     // $dc0a / $dd0a: time of day
      (0,_debug__WEBPACK_IMPORTED_MODULE_0__.unimplementedWarning)("time of day clock write");
      break;

    case 0xb:     // $dc0b / $dd0b: time of day
      (0,_debug__WEBPACK_IMPORTED_MODULE_0__.unimplementedWarning)("time of day clock write");
      break;

    case 0xc:     // $dc0c / $dd0c: serial shift
      (0,_debug__WEBPACK_IMPORTED_MODULE_0__.unimplementedWarning)("serial shifter write");
      break;

    case 0xd:     // $dc0d / $dd0d: interrupt control

      if (byte & 0x80) {
        // byte is specifying which bits of the control register to set
        cia.irq_control |= (byte & 0x7f);
      }
      else {
        // byte is specifying which bits of the control register to clear
        cia.irq_control &= ~byte;
      }

      reconsiderInterrupt(cia);
      break;

    case 0xe:     // $dc0e / $dd0e: timer A control
      write_timerControl(cia.timer_a, byte);
      break;

    case 0xf:     // $dc0f / $dd0f: timer B control
      write_timerControl(cia.timer_b, byte);
      break;
  }
}

function read_dc00_dcff(addr) {
  
  // CIA1 regs are from $dc00-$dc0f, with degenerate copies through $dcff
  const reg = addr & 0xf;

  switch (reg) {
    case 0x0:     // $dc00: joystick 2

      // The docs I read say that bits 0-4 are the joystick switches but don't
      // mention the others. In practice, bit 7 is tied low, and 6 and 5 are
      // high. Some games (Commando, Bomb Jack...) depend on this by testing
      // for the value $6f to wait for the fire button.

      return state.joystick2 & 0b01111111;

    case 0x1:     // $dc01: keyboard and joystick 1
      {
        // everything's inverted, unhelpfully

        const column = (~state.cia1.port_a.value) & 0xff;
        // const column = (~state.regs_1[0]) & 0xff;

        let ret = 0;

        for (let c = 0; c < 8; c++) {
          if (column & (1 << c)) ret |= state.keyMatrix[c];
        }

        // return (~ret) & 0xff;
        return (~(ret | ~state.joystick1)) & 0xff;
      }
  }

  return read(state.cia1, reg);
}

function read_dd00_ddff(addr) {

  // CIA2 regs are from $dd00-$dd0f, with degenerate copies through $ddff
  const reg = addr & 0xf;

  switch (reg) {
    case 0x0:     // $dd00: serial bus
      // TODO
      // Deliberately fall through
      break;

    case 0x1:     // $dd01: RS232
      // TODO
      // Deliberately fall through
      break;      
  }

  return read(state.cia2, reg);
}

function write_dc00_dcff(addr, byte) {

  // CIA1 regs are from $dc00-$dc0f, with degenerate copies through $dcff
  const reg = addr & 0xf;

  // CIA1-specific configuration
  switch (reg) {
    case 0x0:     // $dc00: keyboard column
    case 0x1:     // $cd01: RS232
      // deliberately fall through
      break;
  }

  // CIA-general functionality
  return write(state.cia1, reg, byte, setCia1Irq);
}

function write_dd00_ddff(addr, byte) {

  // CIA2 regs are from $dd00-$dd0f, with degenerate copies through $ddff
  const reg = addr & 0xf;

  // CIA2-specific configuration
  switch (reg) {
    case 0x0:     // $dd00: VIC bank select, serial bus

      // The 'bank number' that we're setting is the bitwise inverse of the
      // that's being written here; presumably because lines are tied high,
      // so setting the bit means pulling it low. It's just a matter of
      // convention, but to stay consistent with the documentation's
      // concept of the VIC bank number, we'll translate here.
      setVicBank(3 - (byte & 0b11));

      // TODO: and there's other bits here for the serial bus
      state.cia2.port_a.value = byte;
      // deliberately fall through
      break;

    case 0x1:     // $dd01: user port
      // TODO
      // deliberately fall through
      break;

    // direction
    case 0x2:
      // debugger;
      break;
    case 0x3:
      // debugger;
      break;
  }

  // CIA-general functionality
  return write(state.cia2, reg, byte, setCia2Nmi);
}

function serialize() {
  const obj = {
    ...state,
    cia1: {
      ...state.cia1,
      timer_a: {
        ...state.cia1.timer_a,
        nextTickFn: (0,_tools_serializerSupport__WEBPACK_IMPORTED_MODULE_1__.functionToReference)(state.cia1.timer_a.nextTickFn),
      },
      timer_b: {
      ...state.cia1.timer_b,
        nextTickFn: (0,_tools_serializerSupport__WEBPACK_IMPORTED_MODULE_1__.functionToReference)(state.cia1.timer_b.nextTickFn),
      },
    },
    cia2: {
      ...state.cia2,
      timer_a: {
        ...state.cia2.timer_a,
        nextTickFn: (0,_tools_serializerSupport__WEBPACK_IMPORTED_MODULE_1__.functionToReference)(state.cia2.timer_a.nextTickFn),
      },
      timer_b: {
      ...state.cia2.timer_b,
        nextTickFn: (0,_tools_serializerSupport__WEBPACK_IMPORTED_MODULE_1__.functionToReference)(state.cia2.timer_b.nextTickFn),
      },
    }
  };

  return JSON.stringify(obj);
}

function deserialize(json) {
  state = JSON.parse(json);

  state.cia1.timer_a.nextTickFn = (0,_tools_serializerSupport__WEBPACK_IMPORTED_MODULE_1__.referenceToFunction)(state.cia1.timer_a.nextTickFn);
  state.cia1.timer_b.nextTickFn = (0,_tools_serializerSupport__WEBPACK_IMPORTED_MODULE_1__.referenceToFunction)(state.cia1.timer_b.nextTickFn);
  state.cia2.timer_a.nextTickFn = (0,_tools_serializerSupport__WEBPACK_IMPORTED_MODULE_1__.referenceToFunction)(state.cia2.timer_a.nextTickFn);
  state.cia2.timer_b.nextTickFn = (0,_tools_serializerSupport__WEBPACK_IMPORTED_MODULE_1__.referenceToFunction)(state.cia2.timer_b.nextTickFn);
}

(0,_tools_serializerSupport__WEBPACK_IMPORTED_MODULE_1__.addToSerializerRegistry)({
  tick_timer_startup_0,
  tick_timer_startup_1,
  tick_timer_startup_2,
  tick_timer_shutdown_0,
  tick_timer_shutdown_1,
  tick_timer_stoppedLoad_0,
  tick_timer_stoppedLoad_1,
  tick_timer_runningLoad_0,
  tick_timer_runningLoad_1,
  tick_timer_runningLoad_2,
  tick_timer_runningNonLoad_0,
  tick_timer_running,
  tick_timer_stopped,
  tick_timer_postUnderflow_0,
  tick_timer_postUnderflow_1,
});


/***/ }),

/***/ "./src/target/cpu.js":
/*!***************************!*\
  !*** ./src/target/cpu.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   attach: () => (/* binding */ attach)
/* harmony export */ });
/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../debug */ "./src/debug.js");
/* harmony import */ var _tools_disasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tools/disasm */ "./src/tools/disasm.js");
/* harmony import */ var _tools_serializerSupport__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tools/serializerSupport */ "./src/tools/serializerSupport.js");
/*
   cpu: emulates the 6510 microprocessor, including quasi-ops

   References:

   †1: http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/64doc
   †2: Long discussion on interrupts and branches:
       http://forum.6502.org/viewtopic.php?f=4&t=1634
   †3: http://archive.6502.org/books/mcs6500_family_hardware_manual.pdf
   †4: http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/6502-NMOS.extra.opcodes

   TODOs:

     - allow bus takeover by VIC (RDY pin)
     - at least make a note of PC when an opcode starts (SYNC pin), for
       debugging
*/





let state;

// Bound by attach
let c64;
let cpuRead;
let cpuWrite;
let getIrq;
let getNmi;

function attach(nascentC64) {
  c64 = nascentC64;

  cpuRead  = c64.wires.cpuRead;
  cpuWrite = c64.wires.cpuWrite;
  getIrq   = c64.wires.getIrq;
  getNmi   = c64.wires.getNmi;

  reset();

  c64.cpu = {
    // Control
    tick,
    reset,
    serialize,
    deserialize,
    // Debug
    getState,
    showState,
  };
}

function reset() {
  state = {
    a:  0,  // accumulator
    x:  0,  // X register
    y:  0,  // Y register
    s:  0,  // stack pointer
    pc: 0,  // program counter
    n:  0,  // status register (P) negative flag (bit 7)
    v:  0,  // status register (P) overflow flag (bit 6)
    d:  0,  // status register (P) decimal mode (bit 3)
    i:  1,  // status register (P) interrupt disable (bit 2)
    z:  0,  // status register (P) zero flag (bit 1)
    c:  0,  // status register (P) carry flag (bit 0)

    ir: 0,       // instruction register
    opFn: null,  // operation handler, called from the addressing mode

    lastNmi: false, // was NMI low last time we looked?

    adl: 0,      // temporary low address byte from fetch
    adh: 0,      // temporary high address byte from fetch
    tmp: 0,      // a working variable for read-mod-write insns

    pendingInt: 3,  // (0 = nothing , 1 = IRQ, 2 = NMI, 3 = RESET)

    // Two parallel state machines to achieve the pipelining
    fdTick: null,              // fetch/decode
    amTick: am_interrupt_T2,   // addressing mode
  };
}

function getState() {
  return state;
}

// (TODO: maybe use a Map for these. Would it actually be faster?)
const  opFn_forOpcode = {}; // eg. 0x49 -> logic_eor
const am_T1_forOpcode = {}; // eg. 0x49 -> am_ieomd_imm_T1

[
  // Single-byte operations (implicit)
  [ 0xea, op_NOP_void_void, am_singleByte_imp_T1 ],
  [ 0x18, op_CLC_void_void, am_singleByte_imp_T1 ],
  [ 0xd8, op_CLD_void_void, am_singleByte_imp_T1 ],
  [ 0x58, op_CLI_void_void, am_singleByte_imp_T1 ],
  [ 0xb8, op_CLV_void_void, am_singleByte_imp_T1 ],
  [ 0x38, op_SEC_void_void, am_singleByte_imp_T1 ],
  [ 0xf8, op_SED_void_void, am_singleByte_imp_T1 ],
  [ 0x78, op_SEI_void_void, am_singleByte_imp_T1 ],
  [ 0xaa, op_TAX_void_void, am_singleByte_imp_T1 ],
  [ 0xa8, op_TAY_void_void, am_singleByte_imp_T1 ],
  [ 0x8a, op_TXA_void_void, am_singleByte_imp_T1 ],
  [ 0x98, op_TYA_void_void, am_singleByte_imp_T1 ],
  [ 0xba, op_TSX_void_void, am_singleByte_imp_T1 ],
  [ 0x9a, op_TXS_void_void, am_singleByte_imp_T1 ],
  [ 0xca, op_DEX_void_void, am_singleByte_imp_T1 ],
  [ 0x88, op_DEY_void_void, am_singleByte_imp_T1 ],
  [ 0xe8, op_INX_void_void, am_singleByte_imp_T1 ],
  [ 0xc8, op_INY_void_void, am_singleByte_imp_T1 ],
  [ 0x1a, op_NOP_void_void, am_singleByte_imp_T1 ],   // Quasi-op
  [ 0x3a, op_NOP_void_void, am_singleByte_imp_T1 ],   // Quasi-op
  [ 0x5a, op_NOP_void_void, am_singleByte_imp_T1 ],   // Quasi-op
  [ 0x7a, op_NOP_void_void, am_singleByte_imp_T1 ],   // Quasi-op
  [ 0xda, op_NOP_void_void, am_singleByte_imp_T1 ],   // Quasi-op
  [ 0xfa, op_NOP_void_void, am_singleByte_imp_T1 ],   // Quasi-op

  // Single-byte operations (accumulator)
  [ 0x0a, op_ASL_arg_ret,   am_singleByte_acc_T1 ],
  [ 0x4a, op_LSR_arg_ret,   am_singleByte_acc_T1 ],
  [ 0x2a, op_ROL_arg_ret,   am_singleByte_acc_T1 ],
  [ 0x6a, op_ROR_arg_ret,   am_singleByte_acc_T1 ],

  // Internal execution on memory data (immediate)
  [ 0x29, op_AND_tmp_void,  am_ieomd_imm_T1 ],
  [ 0x49, op_EOR_tmp_void,  am_ieomd_imm_T1 ],
  [ 0x09, op_ORA_tmp_void,  am_ieomd_imm_T1 ],
  [ 0xc9, op_CMP_tmp_void,  am_ieomd_imm_T1 ],
  [ 0xe0, op_CPX_tmp_void,  am_ieomd_imm_T1 ],
  [ 0xc0, op_CPY_tmp_void,  am_ieomd_imm_T1 ],
  [ 0xa9, op_LDA_tmp_void,  am_ieomd_imm_T1 ],
  [ 0xa2, op_LDX_tmp_void,  am_ieomd_imm_T1 ],
  [ 0xa0, op_LDY_tmp_void,  am_ieomd_imm_T1 ],
  [ 0x69, op_ADC_tmp_void,  am_ieomd_imm_T1 ],
  [ 0xe9, op_SBC_tmp_void,  am_ieomd_imm_T1 ],
  [ 0x80, op_NOP_void_void, am_ieomd_imm_T1 ],        // Quasi-op
  [ 0x82, op_NOP_void_void, am_ieomd_imm_T1 ],        // Quasi-op
  [ 0x89, op_NOP_void_void, am_ieomd_imm_T1 ],        // Quasi-op
  [ 0xc2, op_NOP_void_void, am_ieomd_imm_T1 ],        // Quasi-op
  [ 0xe2, op_NOP_void_void, am_ieomd_imm_T1 ],        // Quasi-op
  [ 0xeb, op_SBC_tmp_void,  am_ieomd_imm_T1 ],        // Quasi-op
  [ 0x0b, op_ANC_tmp_void,  am_ieomd_imm_T1 ],        // Quasi-op
  [ 0x2b, op_ANC_tmp_void,  am_ieomd_imm_T1 ],        // Quasi-op
  [ 0x4b, op_ALR_tmp_void,  am_ieomd_imm_T1 ],        // Quasi-op
  [ 0x6b, op_ARR_tmp_void,  am_ieomd_imm_T1 ],        // Quasi-op
  [ 0x8b, op_ANE_tmp_void,  am_ieomd_imm_T1 ],        // Quasi-op
  [ 0xab, op_LXA_tmp_void,  am_ieomd_imm_T1 ],        // Quasi-op
  [ 0xcb, op_SBX_tmp_void,  am_ieomd_imm_T1 ],        // Quasi-op

  // Internal execution on memory data (zero page)
  [ 0x25, op_AND_tmp_void,  am_ieomd_zp_T1 ],
  [ 0x24, op_BIT_tmp_void,  am_ieomd_zp_T1 ],
  [ 0x45, op_EOR_tmp_void,  am_ieomd_zp_T1 ],
  [ 0x05, op_ORA_tmp_void,  am_ieomd_zp_T1 ],
  [ 0xc5, op_CMP_tmp_void,  am_ieomd_zp_T1 ],
  [ 0xe4, op_CPX_tmp_void,  am_ieomd_zp_T1 ],
  [ 0xc4, op_CPY_tmp_void,  am_ieomd_zp_T1 ],
  [ 0xa5, op_LDA_tmp_void,  am_ieomd_zp_T1 ],
  [ 0xa6, op_LDX_tmp_void,  am_ieomd_zp_T1 ],
  [ 0xa4, op_LDY_tmp_void,  am_ieomd_zp_T1 ],
  [ 0x65, op_ADC_tmp_void,  am_ieomd_zp_T1 ],
  [ 0xe5, op_SBC_tmp_void,  am_ieomd_zp_T1 ],
  [ 0x04, op_NOP_void_void, am_ieomd_zp_T1 ],         // Quasi-op
  [ 0x44, op_NOP_void_void, am_ieomd_zp_T1 ],         // Quasi-op
  [ 0x64, op_NOP_void_void, am_ieomd_zp_T1 ],         // Quasi-op
  [ 0xa7, op_LAX_tmp_void,  am_ieomd_zp_T1 ],         // Quasi-op

  // Internal execution on memory data (absolute)
  [ 0x2d, op_AND_tmp_void,  am_ieomd_abs_T1 ],
  [ 0x2c, op_BIT_tmp_void,  am_ieomd_abs_T1 ],
  [ 0x4d, op_EOR_tmp_void,  am_ieomd_abs_T1 ],
  [ 0x0d, op_ORA_tmp_void,  am_ieomd_abs_T1 ],
  [ 0xcd, op_CMP_tmp_void,  am_ieomd_abs_T1 ],
  [ 0xec, op_CPX_tmp_void,  am_ieomd_abs_T1 ],
  [ 0xcc, op_CPY_tmp_void,  am_ieomd_abs_T1 ],
  [ 0xad, op_LDA_tmp_void,  am_ieomd_abs_T1 ],
  [ 0xae, op_LDX_tmp_void,  am_ieomd_abs_T1 ],
  [ 0xac, op_LDY_tmp_void,  am_ieomd_abs_T1 ],
  [ 0x6d, op_ADC_tmp_void,  am_ieomd_abs_T1 ],
  [ 0xed, op_SBC_tmp_void,  am_ieomd_abs_T1 ],
  [ 0xaf, op_LAX_tmp_void,  am_ieomd_abs_T1 ],        // Quasi-op

  // Internal execution on memory data (indirect,X)
  [ 0x21, op_AND_tmp_void,  am_ieomd_inx_T1 ],
  [ 0x41, op_EOR_tmp_void,  am_ieomd_inx_T1 ],
  [ 0x01, op_ORA_tmp_void,  am_ieomd_inx_T1 ],
  [ 0xc1, op_CMP_tmp_void,  am_ieomd_inx_T1 ],
  [ 0xa1, op_LDA_tmp_void,  am_ieomd_inx_T1 ],
  [ 0x61, op_ADC_tmp_void,  am_ieomd_inx_T1 ],
  [ 0xe1, op_SBC_tmp_void,  am_ieomd_inx_T1 ],
  [ 0xa3, op_LAX_tmp_void,  am_ieomd_inx_T1 ],        // Quasi-op

  // Internal execution on memory data (absolute,X)
  [ 0x3d, op_AND_tmp_void,  am_ieomd_abx_T1 ],
  [ 0x5d, op_EOR_tmp_void,  am_ieomd_abx_T1 ],
  [ 0x1d, op_ORA_tmp_void,  am_ieomd_abx_T1 ],
  [ 0xdd, op_CMP_tmp_void,  am_ieomd_abx_T1 ],
  [ 0xbd, op_LDA_tmp_void,  am_ieomd_abx_T1 ],
  [ 0xbc, op_LDY_tmp_void,  am_ieomd_abx_T1 ],
  [ 0x7d, op_ADC_tmp_void,  am_ieomd_abx_T1 ],
  [ 0xfd, op_SBC_tmp_void,  am_ieomd_abx_T1 ],
  [ 0x0c, op_NOP_void_void, am_ieomd_abx_T1 ],        // Quasi-op
  [ 0x1c, op_NOP_void_void, am_ieomd_abx_T1 ],        // Quasi-op
  [ 0x3c, op_NOP_void_void, am_ieomd_abx_T1 ],        // Quasi-op
  [ 0x5c, op_NOP_void_void, am_ieomd_abx_T1 ],        // Quasi-op
  [ 0x7c, op_NOP_void_void, am_ieomd_abx_T1 ],        // Quasi-op
  [ 0xdc, op_NOP_void_void, am_ieomd_abx_T1 ],        // Quasi-op
  [ 0xfc, op_NOP_void_void, am_ieomd_abx_T1 ],        // Quasi-op

  // Internal execution on memory data (absolute,Y)
  [ 0x39, op_AND_tmp_void,  am_ieomd_aby_T1 ],
  [ 0x59, op_EOR_tmp_void,  am_ieomd_aby_T1 ],
  [ 0x19, op_ORA_tmp_void,  am_ieomd_aby_T1 ],
  [ 0xd9, op_CMP_tmp_void,  am_ieomd_aby_T1 ],
  [ 0xb9, op_LDA_tmp_void,  am_ieomd_aby_T1 ],
  [ 0xbe, op_LDX_tmp_void,  am_ieomd_aby_T1 ],
  [ 0x79, op_ADC_tmp_void,  am_ieomd_aby_T1 ],
  [ 0xf9, op_SBC_tmp_void,  am_ieomd_aby_T1 ],
  [ 0xbf, op_LAX_tmp_void,  am_ieomd_aby_T1 ],        // Quasi-op
  [ 0xbb, op_LAS_tmp_void,  am_ieomd_aby_T1 ],        // Quasi-op

  // Internal execution on memory data (zero page,X)
  [ 0x35, op_AND_tmp_void,  am_ieomd_zpx_T1 ],
  [ 0x55, op_EOR_tmp_void,  am_ieomd_zpx_T1 ],
  [ 0x15, op_ORA_tmp_void,  am_ieomd_zpx_T1 ],
  [ 0xd5, op_CMP_tmp_void,  am_ieomd_zpx_T1 ],
  [ 0xb5, op_LDA_tmp_void,  am_ieomd_zpx_T1 ],
  [ 0xb4, op_LDY_tmp_void,  am_ieomd_zpx_T1 ],
  [ 0x75, op_ADC_tmp_void,  am_ieomd_zpx_T1 ],
  [ 0xf5, op_SBC_tmp_void,  am_ieomd_zpx_T1 ],

  // Internal execution on memory data (zero page,Y)
  [ 0xb6, op_LDX_tmp_void,  am_ieomd_zpy_T1 ],
  [ 0xb7, op_LAX_tmp_void,  am_ieomd_zpy_T1 ],        // Quasi-op

  // Internal execution on memory data (indirect,Y)
  [ 0x31, op_AND_tmp_void,  am_ieomd_iny_T1 ],
  [ 0x51, op_EOR_tmp_void,  am_ieomd_iny_T1 ],
  [ 0x11, op_ORA_tmp_void,  am_ieomd_iny_T1 ],
  [ 0xd1, op_CMP_tmp_void,  am_ieomd_iny_T1 ],
  [ 0xb1, op_LDA_tmp_void,  am_ieomd_iny_T1 ],
  [ 0x71, op_ADC_tmp_void,  am_ieomd_iny_T1 ],
  [ 0xf1, op_SBC_tmp_void,  am_ieomd_iny_T1 ],
  [ 0xb3, op_LAX_tmp_void,  am_ieomd_iny_T1 ],        // Quasi-op

  // Store operations (zero page)
  [ 0x85, op_STA_void_ret,  am_store_zp_T1 ],
  [ 0x86, op_STX_void_ret,  am_store_zp_T1 ],
  [ 0x84, op_STY_void_ret,  am_store_zp_T1 ],
  [ 0x87, op_AXS_void_ret,  am_store_zp_T1 ],         // Quasi-op

  // Store operations (absolute)
  [ 0x8d, op_STA_void_ret,  am_store_abs_T1 ],
  [ 0x8e, op_STX_void_ret,  am_store_abs_T1 ],
  [ 0x8c, op_STY_void_ret,  am_store_abs_T1 ],
  [ 0x8f, op_AXS_void_ret,  am_store_abs_T1 ],        // Quasi-op

  // Store operations (indirect,X)
  [ 0x81, op_STA_void_ret,  am_store_inx_T1 ],
  [ 0x83, op_AXS_void_ret,  am_store_inx_T1 ],        // Quasi-op

  // Store operations (absolute,X)
  [ 0x9d, op_STA_void_ret,  am_store_abx_T1 ],
  [ 0x9c, op_SHY_void_ret,  am_store_abx_T1 ],        // Quasi-op

  // Store operations (absolute,Y)
  [ 0x99, op_STA_void_ret,  am_store_aby_T1 ],
  [ 0x9f, op_SHA_void_ret,  am_store_aby_T1 ],        // Quasi-op
  [ 0x9b, op_SHS_void_ret,  am_store_aby_T1 ],        // Quasi-op
  [ 0x9e, op_SHX_void_ret,  am_store_aby_T1 ],        // Quasi-op

  // Store operations (zero page,X)
  [ 0x95, op_STA_void_ret,  am_store_zpx_T1 ],
  [ 0x94, op_STY_void_ret,  am_store_zpx_T1 ],

  // Store operations (zero page,Y)
  [ 0x96, op_STX_void_ret,  am_store_zpy_T1 ],
  [ 0x97, op_AXS_void_ret,  am_store_zpy_T1 ],        // Quasi-op

  // Store operations (indirect,Y)
  [ 0x91, op_STA_void_ret,  am_store_iny_T1 ],
  [ 0x93, op_SHA_void_ret,  am_store_iny_T1 ],        // Quasi-op

  // Read-modify-write operations (zero page)
  [ 0x06, op_ASL_arg_ret,   am_rmw_zp_T1 ],
  [ 0x46, op_LSR_arg_ret,   am_rmw_zp_T1 ],
  [ 0x26, op_ROL_arg_ret,   am_rmw_zp_T1 ],
  [ 0x66, op_ROR_arg_ret,   am_rmw_zp_T1 ],
  [ 0xe6, op_INC_arg_ret,   am_rmw_zp_T1 ],
  [ 0xc6, op_DEC_arg_ret,   am_rmw_zp_T1 ],
  [ 0x47, op_LSE_arg_ret,   am_rmw_zp_T1 ],           // Quasi-op
  [ 0xc7, op_DCM_arg_ret,   am_rmw_zp_T1 ],           // Quasi-op
  [ 0x07, op_ASO_arg_ret,   am_rmw_zp_T1 ],           // Quasi-op
  [ 0x27, op_RLA_arg_ret,   am_rmw_zp_T1 ],           // Quasi-op
  [ 0x67, op_RRA_arg_ret,   am_rmw_zp_T1 ],           // Quasi-op
  [ 0xe7, op_INS_arg_ret,   am_rmw_zp_T1 ],           // Quasi-op

  // Read-modify-write operations (absolute)
  [ 0x0e, op_ASL_arg_ret,   am_rmw_abs_T1 ],
  [ 0x2e, op_ROL_arg_ret,   am_rmw_abs_T1 ],
  [ 0x6e, op_ROR_arg_ret,   am_rmw_abs_T1 ],
  [ 0x4e, op_LSR_arg_ret,   am_rmw_abs_T1 ],
  [ 0xee, op_INC_arg_ret,   am_rmw_abs_T1 ],
  [ 0xce, op_DEC_arg_ret,   am_rmw_abs_T1 ],
  [ 0x4f, op_LSE_arg_ret,   am_rmw_abs_T1 ],          // Quasi-op
  [ 0xcf, op_DCM_arg_ret,   am_rmw_abs_T1 ],          // Quasi-op
  [ 0x0f, op_ASO_arg_ret,   am_rmw_abs_T1 ],          // Quasi-op
  [ 0x2f, op_RLA_arg_ret,   am_rmw_abs_T1 ],          // Quasi-op
  [ 0x6f, op_RRA_arg_ret,   am_rmw_abs_T1 ],          // Quasi-op
  [ 0xef, op_INS_arg_ret,   am_rmw_abs_T1 ],          // Quasi-op

  // Read-modify-write operations (zero page,X)
  [ 0x16, op_ASL_arg_ret,   am_rmw_zpx_T1 ],
  [ 0x36, op_ROL_arg_ret,   am_rmw_zpx_T1 ],
  [ 0x76, op_ROR_arg_ret,   am_rmw_zpx_T1 ],
  [ 0x56, op_LSR_arg_ret,   am_rmw_zpx_T1 ],
  [ 0xf6, op_INC_arg_ret,   am_rmw_zpx_T1 ],
  [ 0xd6, op_DEC_arg_ret,   am_rmw_zpx_T1 ],
  [ 0x14, op_NOP_arg_ret,   am_rmw_zpx_T1 ],          // Quasi-op
  [ 0x34, op_NOP_arg_ret,   am_rmw_zpx_T1 ],          // Quasi-op
  [ 0x54, op_NOP_arg_ret,   am_rmw_zpx_T1 ],          // Quasi-op
  [ 0x74, op_NOP_arg_ret,   am_rmw_zpx_T1 ],          // Quasi-op
  [ 0xd4, op_NOP_arg_ret,   am_rmw_zpx_T1 ],          // Quasi-op
  [ 0xf4, op_NOP_arg_ret,   am_rmw_zpx_T1 ],          // Quasi-op
  [ 0x57, op_LSE_arg_ret,   am_rmw_zpx_T1 ],          // Quasi-op
  [ 0xd7, op_DCM_arg_ret,   am_rmw_zpx_T1 ],          // Quasi-op
  [ 0x17, op_ASO_arg_ret,   am_rmw_zpx_T1 ],          // Quasi-op
  [ 0x37, op_RLA_arg_ret,   am_rmw_zpx_T1 ],          // Quasi-op
  [ 0x77, op_RRA_arg_ret,   am_rmw_zpx_T1 ],          // Quasi-op
  [ 0xf7, op_INS_arg_ret,   am_rmw_zpx_T1 ],          // Quasi-op

  // Read-modify-write operations (absolute,X)
  [ 0x1e, op_ASL_arg_ret,   am_rmw_abx_T1 ],
  [ 0x3e, op_ROL_arg_ret,   am_rmw_abx_T1 ],
  [ 0x7e, op_ROR_arg_ret,   am_rmw_abx_T1 ],
  [ 0x5e, op_LSR_arg_ret,   am_rmw_abx_T1 ],
  [ 0xfe, op_INC_arg_ret,   am_rmw_abx_T1 ],
  [ 0xde, op_DEC_arg_ret,   am_rmw_abx_T1 ],
  [ 0x5f, op_LSE_arg_ret,   am_rmw_abx_T1 ],          // Quasi-op
  [ 0xdf, op_DCM_arg_ret,   am_rmw_abx_T1 ],          // Quasi-op
  [ 0x1f, op_ASO_arg_ret,   am_rmw_abx_T1 ],          // Quasi-op
  [ 0x3f, op_RLA_arg_ret,   am_rmw_abx_T1 ],          // Quasi-op
  [ 0x3f, op_RLA_arg_ret,   am_rmw_abx_T1 ],          // Quasi-op
  [ 0x7f, op_RRA_arg_ret,   am_rmw_abx_T1 ],          // Quasi-op
  [ 0xff, op_INS_arg_ret,   am_rmw_abx_T1 ],          // Quasi-op

  // Read-modify-write operations (absolute,Y)
  [ 0x5b, op_LSE_arg_ret,   am_rmw_aby_T1 ],          // Quasi-op
  [ 0xdb, op_DCM_arg_ret,   am_rmw_aby_T1 ],          // Quasi-op
  [ 0x1b, op_ASO_arg_ret,   am_rmw_aby_T1 ],          // Quasi-op
  [ 0x3b, op_RLA_arg_ret,   am_rmw_aby_T1 ],          // Quasi-op
  [ 0x7b, op_RRA_arg_ret,   am_rmw_aby_T1 ],          // Quasi-op
  [ 0xfb, op_INS_arg_ret,   am_rmw_aby_T1 ],          // Quasi-op

  // Read-modify-write operations (indirect,X)
  [ 0x43, op_LSE_arg_ret,   am_rmw_inx_T1 ],          // Quasi-op
  [ 0xc3, op_DCM_arg_ret,   am_rmw_inx_T1 ],          // Quasi-op
  [ 0x03, op_ASO_arg_ret,   am_rmw_inx_T1 ],          // Quasi-op
  [ 0x23, op_RLA_arg_ret,   am_rmw_inx_T1 ],          // Quasi-op
  [ 0x63, op_RRA_arg_ret,   am_rmw_inx_T1 ],          // Quasi-op
  [ 0xe3, op_INS_arg_ret,   am_rmw_inx_T1 ],          // Quasi-op

  // Read-modify-write operations (indirect,Y)
  [ 0x53, op_LSE_arg_ret,   am_rmw_iny_T1 ],          // Quasi-op
  [ 0xd3, op_DCM_arg_ret,   am_rmw_iny_T1 ],          // Quasi-op
  [ 0x13, op_ASO_arg_ret,   am_rmw_iny_T1 ],          // Quasi-op
  [ 0x33, op_RLA_arg_ret,   am_rmw_iny_T1 ],          // Quasi-op
  [ 0x73, op_RRA_arg_ret,   am_rmw_iny_T1 ],          // Quasi-op
  [ 0xf3, op_INS_arg_ret,   am_rmw_iny_T1 ],          // Quasi-op

  // Miscellaneous operations (push)
  [ 0x48, op_PHA_void_ret,  am_push_T1 ],
  [ 0x08, op_PHP_void_ret,  am_push_T1 ],

  // Miscellaneous operations (pull)
  [ 0x68, op_PLA_arg_void,  am_pull_T1 ],
  [ 0x28, op_PLP_arg_void,  am_pull_T1 ],

  // Miscellaneous operations (jump to subroutine)
  [ 0x20, op_JSR_void_void, am_jsr_T1 ],

  // Miscellaneous operations (break)
  [ 0x00, op_BRK_void_void, am_interrupt_T1 ],

  // Miscellaneous operations (return from interrupt)
  [ 0x40, op_RTI_void_void, am_rti_T1 ],

  // Jump operation (absolute)
  [ 0x4c, op_JMP_void_void, am_jmp_abs_T1 ],

  // Jump operation (indirect)
  [ 0x6c, op_JMP_void_void, am_jmp_ind_T1 ],

  // Miscellaneous operations (return from subroutine)
  [ 0x60, op_RTS_void_void, am_rts_T1 ],

  // Miscellaneous operations (branch)
  [ 0x90, op_BCC_void_ret,  am_rel_T1 ],
  [ 0xb0, op_BCS_void_ret,  am_rel_T1 ],
  [ 0xf0, op_BEQ_void_ret,  am_rel_T1 ],
  [ 0x30, op_BMI_void_ret,  am_rel_T1 ],
  [ 0xd0, op_BNE_void_ret,  am_rel_T1 ],
  [ 0x10, op_BPL_void_ret,  am_rel_T1 ],
  [ 0x50, op_BVC_void_ret,  am_rel_T1 ],
  [ 0x70, op_BVS_void_ret,  am_rel_T1 ],

  // Irrecoverable failure
  [ 0x02, op_HLT_void_void, am_halt_T1 ],
  [ 0x12, op_HLT_void_void, am_halt_T1 ],
  [ 0x22, op_HLT_void_void, am_halt_T1 ],
  [ 0x32, op_HLT_void_void, am_halt_T1 ],
  [ 0x42, op_HLT_void_void, am_halt_T1 ],
  [ 0x52, op_HLT_void_void, am_halt_T1 ],
  [ 0x62, op_HLT_void_void, am_halt_T1 ],
  [ 0x72, op_HLT_void_void, am_halt_T1 ],
  [ 0x92, op_HLT_void_void, am_halt_T1 ],
  [ 0xb2, op_HLT_void_void, am_halt_T1 ],
  [ 0xd2, op_HLT_void_void, am_halt_T1 ],
  [ 0xf2, op_HLT_void_void, am_halt_T1 ],

].forEach(
  ([ opcode, opFn, t1 ]) => {
    am_T1_forOpcode[opcode] = t1;
     opFn_forOpcode[opcode] = opFn;
  }
);

function fd_fetch_T0() {

  // Bearing in mind that this cycle usually runs concurrently with an am_ 
  // cycle, we have to be very careful which registers we use here.

  state.ir = cpuRead(state.pc);

  // TODO: I gather this doesn't happen here, but on the last Tn of any mode
  pollForInterrupts();

  // Latch the instruction register from zero (BRK) if there are interrupts
  if (state.pendingInt) {
    state.ir = 0;
  }
  else {
    state.pc = ++state.pc & 0xffff;
  }

  state.fdTick = fd_decode_T1;
}

const visitedPcs = new Set();

function fd_decode_T1() {

  // {
  //   state.pc--;
  //   if (!visitedPcs.has(state.pc)) {
  //     visitedPcs.add(state.pc);
  //     showState();
  //   }
  //   state.pc++;
  // }

  const  opFn =  opFn_forOpcode[state.ir];
  const am_T1 = am_T1_forOpcode[state.ir];

  state.tmp = cpuRead(state.pc);

  // Now run the T1 stage for the addressing mode sequence. Usually the
  // CPU tick function would call this at the start of the cycle, but having
  // decoded the opcode, there's still a small bit of time left in this cycle,
  // and the CPU seems to use it to increment the PC if the sequence calls for
  // it. The T1 handler can assign the next amTick tick handler function, as it
  // would for any other stage, but it *must* reassign fdTick, otherwise the
  // CPU will be decoding instructions every cycle.

  state.opFn = opFn;
  am_T1();
}


// ----------------------------------------------------------------------------
// Single byte instructions (implicit)
// (†3: A. 1)

function am_singleByte_imp_T1() {
  state.fdTick = fd_fetch_T0;
  state.amTick = am_singleByte_imp_T2;
}

function am_singleByte_imp_T2() {
  state.opFn();
  state.amTick = null;
}


// ----------------------------------------------------------------------------
// Single byte instructions (accumulator)
// (†3: A. 1)

function am_singleByte_acc_T1() {
  state.fdTick = fd_fetch_T0;
  state.amTick = am_singleByte_acc_T2;
}

function am_singleByte_acc_T2() {
  // The read-modify-write opFn's take a parameter and return a value
  state.a = state.opFn(state.a);
  state.amTick = null;
}


// ----------------------------------------------------------------------------
// Internal execution on memory data: immediate addressing
// (†3: A. 2.1)

function am_ieomd_imm_T1() {
  state.pc     = ++state.pc & 0xffff;
  state.fdTick = fd_fetch_T0;
  state.amTick = am_ieomd_imm_T2;
}

function am_ieomd_imm_T2() {
  state.opFn();
  state.amTick = null;
}


// ----------------------------------------------------------------------------
// Internal execution on memory data: zero page addressing
// (†3: A. 2.2)

function am_ieomd_zp_T1() {
  state.pc     = ++state.pc & 0xffff;
  state.amTick = am_ieomd_zp_T2;
  state.fdTick = null;
}

function am_ieomd_zp_T2() {
  // Decode phase left the operand (zero page address) in state.tmp.
  // opFn expects its operand to be in state.tmp.
  state.tmp    = cpuRead(state.tmp);
  state.amTick = am_ieomd_zp_T3;
  state.fdTick = fd_fetch_T0;
}

function am_ieomd_zp_T3() {
  state.opFn();
  state.amTick = null;
}


// ----------------------------------------------------------------------------
// Internal execution on memory data: absolute addressing
// (†3: A. 2.3)

function am_ieomd_abs_T1() {
  state.pc     = ++state.pc & 0xffff;
  state.amTick = am_ieomd_abs_T2;
  state.fdTick = null;
}

function am_ieomd_abs_T2() {
  // Decode phase left the operand (ADL) in state.tmp.
  // opFn expects its operand to be in state.tmp.
  state.adl    = state.tmp;
  state.adh    = cpuRead(state.pc);
  state.pc     = ++state.pc & 0xffff;
  state.amTick = am_ieomd_abs_T3;
}

function am_ieomd_abs_T3() {
  state.tmp    = cpuRead((state.adh << 8) | state.adl);
  state.amTick = am_ieomd_abs_T4;
}

function am_ieomd_abs_T4() {
  state.opFn();
  state.amTick = null;
  state.fdTick = fd_fetch_T0;
}


// ----------------------------------------------------------------------------
// Internal execution on memory data: indirect,X addressing
// (†3: A. 2.4)

function am_ieomd_inx_T1() {
  state.pc     = ++state.pc & 0xffff;
  state.amTick = am_ieomd_inx_T2;
  state.fdTick = null;
}

function am_ieomd_inx_T2() {
  // Decode phase left the operand (zero page address) in state.tmp.
  // opFn expects its operand to be in state.tmp.
  cpuRead(state.tmp);
  state.tmp    = (state.tmp + state.x) & 0xff;
  state.amTick = am_ieomd_inx_T3;
}

function am_ieomd_inx_T3() {
  state.adl    = cpuRead(state.tmp);
  state.tmp    = ++state.tmp & 0xff;
  state.amTick = am_ieomd_inx_T4;
}

function am_ieomd_inx_T4() {
  state.adh    = cpuRead(state.tmp);
  state.amTick = am_ieomd_inx_T5;
}

function am_ieomd_inx_T5() {
  state.tmp    = cpuRead((state.adh << 8) | state.adl);
  state.amTick = am_ieomd_inx_T6;
  state.fdTick = fd_fetch_T0;
}

function am_ieomd_inx_T6() {
  state.opFn();
  state.amTick = null;
}


// ----------------------------------------------------------------------------
// Internal execution on memory data: absolute,X / absolute,Y addressing
// (†3: A. 2.5)

// --------------------------------------------------------
// Absolute,X only

function am_ieomd_abx_T1() {
  state.pc     = ++state.pc & 0xffff;
  state.amTick = am_ieomd_abx_T2;
  state.fdTick = null;
}

function am_ieomd_abx_T2() {
  // Decode phase left the base address low byte in state.tmp.
  // opFn expects its operand to be in state.tmp.
  state.adh    = cpuRead(state.pc);
  state.pc     = ++state.pc & 0xffff;
  state.adl    = (state.tmp + state.x);  // 9 bits hereafter
  state.amTick = am_ieomd_abxy_T3;       // flow into common code
}

// --------------------------------------------------------
// Absolute,Y only

function am_ieomd_aby_T1() {
  state.pc     = ++state.pc & 0xffff;
  state.amTick = am_ieomd_aby_T2;
  state.fdTick = null;
}

function am_ieomd_aby_T2() {
  // Decode phase left the base address low byte in state.tmp.
  // opFn expects its operand to be in state.tmp.
  state.adh    = cpuRead(state.pc);
  state.pc     = ++state.pc & 0xffff;
  state.adl    = (state.tmp + state.y);  // the one difference from am_ieomd_abx_T2
  state.amTick = am_ieomd_abxy_T3;       // flow into common code
}

// --------------------------------------------------------
// Common cycles for both absolute,X and absolute,Y

function am_ieomd_abxy_T3() {
  // Read from the potentially broken address
  state.tmp = cpuRead((state.adh << 8) | (state.adl & 0xff));

  if (state.adl < 0x100) {
    // No address fixup needed; advance to op and next instruction
    state.fdTick = fd_fetch_T0;
    state.amTick = am_ieomd_abxy_T5;
  }

  else {
    // Fix address and, next cycle, refetch
    state.adh    = ++state.adh & 0xff;
    state.adl   &= 0xff;
    state.amTick = am_ieomd_abxy_T4;
  }
}

function am_ieomd_abxy_T4() {
  state.tmp    = cpuRead((state.adh << 8) | state.adl);
  state.fdTick = fd_fetch_T0;
  state.amTick = am_ieomd_abxy_T5;
}

function am_ieomd_abxy_T5() {
  state.opFn();
  state.amTick = null;
}


// ----------------------------------------------------------------------------
// Internal execution on memory data: zero page,X / zero page,Y addressing
// (†3: A. 2.6)

// --------------------------------------------------------
// Zero page,X only

function am_ieomd_zpx_T1() {
  state.pc     = ++state.pc & 0xffff;
  state.amTick = am_ieomd_zpx_T2;
  state.fdTick = null;
}

function am_ieomd_zpx_T2() {
  // Decode phase left the operand (zero page address) in state.tmp.
  // opFn expects its operand to be in state.tmp.
  cpuRead(state.tmp);
  state.adl    = (state.tmp + state.x) & 0xff;
  state.amTick = am_ieomd_zpxy_T3;
}

// --------------------------------------------------------
// Zero page,Y only

function am_ieomd_zpy_T1() {
  state.pc     = ++state.pc & 0xffff;
  state.amTick = am_ieomd_zpy_T2;
  state.fdTick = null;
}

function am_ieomd_zpy_T2() {
  // Decode phase left the operand (zero page address) in state.tmp.
  // opFn expects its operand to be in state.tmp.
  cpuRead(state.tmp);
  state.adl    = (state.tmp + state.y) & 0xff;
  state.amTick = am_ieomd_zpxy_T3;
}

// --------------------------------------------------------
// Common cycles for both zero page,X and zero page,Y

function am_ieomd_zpxy_T3() {
  state.tmp    = cpuRead(state.adl);
  state.fdTick = fd_fetch_T0;
  state.amTick = am_ieomd_zpxy_T4;
}

function am_ieomd_zpxy_T4() {
  state.opFn();
  state.amTick = null;
}


// ----------------------------------------------------------------------------
// Internal execution on memory data: indirect,Y addressing
// (†3: A. 2.7)

function am_ieomd_iny_T1() {
  state.pc     = ++state.pc & 0xffff;
  state.amTick = am_ieomd_iny_T2;
  state.fdTick = null;
}

function am_ieomd_iny_T2() {
  // Decode phase left the operand (zero page address) in state.tmp.
  // opFn expects its operand to be in state.tmp.
  state.adl    = cpuRead(state.tmp);
  state.tmp    = ++state.tmp & 0xff;
  state.amTick = am_ieomd_iny_T3;
}

function am_ieomd_iny_T3() {
  state.adh    = cpuRead(state.tmp);
  state.adl    = state.adl + state.y;  // 9 bits hereafter
  state.amTick = am_ieomd_iny_T4;
}

function am_ieomd_iny_T4() {
  state.tmp = cpuRead((state.adh << 8) | (state.adl & 0xff));

  if (state.adl > 0xff) {
    // Address needs fixing
    state.adh    = ++state.adh & 0xff;
    state.adl    = state.adl & 0xff;   // 8 bits hereafter
    state.amTick = am_ieomd_iny_T5;
  }
  else {
    // Address didn't need fixing. Skip to last stage and fetch next instruction.
    state.amTick = am_ieomd_iny_T6;
    state.fdTick = fd_fetch_T0;
  }
}

function am_ieomd_iny_T5() {
  state.tmp    = cpuRead((state.adh << 8) | state.adl);
  state.amTick = am_ieomd_iny_T6;
  state.fdTick = fd_fetch_T0;
}

function am_ieomd_iny_T6() {
  state.opFn();
  state.amTick = null;
}


// ----------------------------------------------------------------------------
// Store operations: zero page addressing
// (†3: A. 3.1)

function am_store_zp_T1() {
  state.pc     = ++state.pc & 0xffff;
  state.amTick = am_store_zp_T2;
  state.fdTick = null;
}

function am_store_zp_T2() {
  // Decode phase left the operand (zero page address) in state.tmp.
  const adl = state.tmp;

  cpuWrite(adl, state.opFn());

  state.amTick = null;
  state.fdTick = fd_fetch_T0;
}


// ----------------------------------------------------------------------------
// Store operations: absolute addressing
// (†3: A. 3.2)

function am_store_abs_T1() {
  state.pc     = ++state.pc & 0xffff;
  state.amTick = am_store_abs_T2;
  state.fdTick = null;
}

function am_store_abs_T2() {
  // Decode phase left the address low-byte in state.tmp.
  state.adl = state.tmp;
  state.adh = cpuRead(state.pc);
  state.pc  = ++state.pc & 0xffff;

  state.amTick = am_store_abs_T3;
}

function am_store_abs_T3() {
  cpuWrite((state.adh << 8) | state.adl, state.opFn());

  state.amTick = null;
  state.fdTick = fd_fetch_T0;
}


// ----------------------------------------------------------------------------
// Store operations: indirect,X addressing
// (†3: A. 3.3)

function am_store_inx_T1() {
  state.pc     = ++state.pc & 0xffff;
  state.amTick = am_store_inx_T2;
  state.fdTick = null;
}

function am_store_inx_T2() {
  // Decode phase left the zero page address in state.tmp.
  cpuRead(state.tmp);
  
  state.tmp    = (state.tmp + state.x) & 0xff;
  state.amTick = am_store_inx_T3;
}

function am_store_inx_T3() {
  state.adl    = cpuRead(state.tmp);
  state.tmp    = ++state.tmp & 0xff;
  state.amTick = am_store_inx_T4;
}

function am_store_inx_T4() {
  state.adh    = cpuRead(state.tmp);
  state.amTick = am_store_inx_T5;
}

function am_store_inx_T5() {
  cpuWrite((state.adh << 8) | state.adl, state.opFn());

  state.amTick = null;
  state.fdTick = fd_fetch_T0;
}


// ----------------------------------------------------------------------------
// Store operations: absolute,X / absolute,Y addressing
// (†3: A. 3.4)

// --------------------------------------------------------
// Absolute,X only

function am_store_abx_T1() {
  state.pc     = ++state.pc & 0xffff;
  state.amTick = am_store_abx_T2;
  state.fdTick = null;
}

function am_store_abx_T2() {
  // Decode phase left the base address low byte in state.tmp.
  state.adh    = cpuRead(state.pc);
  state.pc     = ++state.pc & 0xffff;
  state.adl    = (state.tmp + state.x);  // 9 bits hereafter
  state.amTick = am_store_abxy_T3;     // flow into common code
}

// --------------------------------------------------------
// Absolute,Y only

function am_store_aby_T1() {
  state.pc     = ++state.pc & 0xffff;
  state.amTick = am_store_aby_T2;
  state.fdTick = null;
}

function am_store_aby_T2() {
  // Decode phase left the base address low byte in state.tmp.
  // opFn expects its operand to be in state.tmp.
  state.adh    = cpuRead(state.pc);
  state.pc     = ++state.pc & 0xffff;
  state.adl    = (state.tmp + state.y);  // the one difference from am_store_abx_T2
  state.amTick = am_store_abxy_T3;       // flow into common code
}

// --------------------------------------------------------
// Common cycles for both absolute,X and absolute,Y

function am_store_abxy_T3() {
  // Dummy read from the potentially broken address
  state.tmp = cpuRead((state.adh << 8) | (state.adl & 0xff));

  if (state.adl > 0xff) {
    // Fix up address
    state.adh    = ++state.adh & 0xff;
    state.adl   &= 0xff;
  }

  // state.adl is 8 bits hereafter
  state.amTick = am_store_abxy_T4;
}

function am_store_abxy_T4() {
  cpuWrite((state.adh << 8) | state.adl, state.opFn());
  state.fdTick = fd_fetch_T0;
  state.amTick = null;
}


// ----------------------------------------------------------------------------
// Store operations: zero page,X / zero page,Y addressing
// (†3: A. 3.5)

// --------------------------------------------------------
// Zero page,X only

function am_store_zpx_T1() {
  state.pc     = ++state.pc & 0xffff;
  state.amTick = am_store_zpx_T2;
  state.fdTick = null;
}

function am_store_zpx_T2() {
  // Decode phase left the operand (zero page address) in state.tmp.
  cpuRead(state.tmp);
  state.adl    = (state.tmp + state.x) & 0xff;
  state.amTick = am_store_zpxy_T3;
}

// --------------------------------------------------------
// Zero page,Y only

function am_store_zpy_T1() {
  state.pc     = ++state.pc & 0xffff;
  state.amTick = am_store_zpy_T2;
  state.fdTick = null;
}

function am_store_zpy_T2() {
  // Decode phase left the operand (zero page address) in state.tmp.
  cpuRead(state.tmp);
  state.adl    = (state.tmp + state.y) & 0xff;
  state.amTick = am_store_zpxy_T3;
}

// --------------------------------------------------------
// Common cycles for both zero page,X and zero page,Y

function am_store_zpxy_T3() {
  cpuWrite(state.adl, state.opFn());

  state.fdTick = fd_fetch_T0;
  state.amTick = null;
}


// ----------------------------------------------------------------------------
// Store operations: indirect,Y addressing
// (†3: A. 3.6)

function am_store_iny_T1() {
  state.pc     = ++state.pc & 0xffff;
  state.amTick = am_store_iny_T2;
  state.fdTick = null;
}

function am_store_iny_T2() {
  // Decode phase left the operand (zero page address) in state.tmp.
  state.adl    = cpuRead(state.tmp);
  state.tmp    = ++state.tmp & 0xff;
  state.amTick = am_store_iny_T3;
}

function am_store_iny_T3() {
  state.adh    = cpuRead(state.tmp);
  state.adl    = state.adl + state.y;  // 9 bits hereafter
  state.amTick = am_store_iny_T4;
}

function am_store_iny_T4() {
  state.tmp    = cpuRead((state.adh << 8) | (state.adl & 0xff));

  if (state.adl > 0xff) {
    // Address needs fixing
    state.adh    = ++state.adh & 0xff;
    state.adl    = state.adl & 0xff;
  }

  // state.adl is 8 bits hereafter
  state.amTick = am_store_iny_T5;
}

function am_store_iny_T5() {
  cpuWrite((state.adh << 8) | state.adl, state.opFn());
  state.amTick = null;
  state.fdTick = fd_fetch_T0;
}


// ----------------------------------------------------------------------------
// Read-modify-write operations: zero page addressing
// (†3: A. 4.1)

function am_rmw_zp_T1() {
  state.pc     = ++state.pc & 0xffff;
  state.amTick = am_rmw_zp_T2;
  state.fdTick = null;
}

function am_rmw_zp_T2() {
  // Decode phase left the operand (zero page address) in state.tmp.
  // opFn takes an argument and returns a value.
  state.adl    = state.tmp;
  state.tmp    = cpuRead(state.adl);
  state.amTick = am_rmw_zp_T3;
}

function am_rmw_zp_T3() {
  // Dummy write of the fetched data back to itself
  cpuWrite(state.adl, state.tmp);

  state.tmp = state.opFn(state.tmp);
  state.amTick = am_rmw_zp_T4;
}

function am_rmw_zp_T4() {
  // Actual write of the processed data
  cpuWrite(state.adl, state.tmp);

  state.amTick = null;
  state.fdTick = fd_fetch_T0;
}


// ----------------------------------------------------------------------------
// Read-modify-write operations: absolute addressing
// (†3: A. 4.2)

function am_rmw_abs_T1() {
  state.pc     = ++state.pc & 0xffff;
  state.amTick = am_rmw_abs_T2;
  state.fdTick = null;
}

function am_rmw_abs_T2() {
  // Decode phase left the operand (ADL) in state.tmp.
  // opFn takes an argument and returns a value.
  state.adl    = state.tmp;
  state.adh    = cpuRead(state.pc);
  state.pc     = ++state.pc & 0xffff;
  state.amTick = am_rmw_abs_T3;
}

function am_rmw_abs_T3() {
  state.tmp    = cpuRead((state.adh << 8) | state.adl);
  state.amTick = am_rmw_abs_T4;
}

function am_rmw_abs_T4() {
  // Dummy write of the fetched data back to itself
  cpuWrite((state.adh << 8) | state.adl, state.tmp);

  state.tmp    = state.opFn(state.tmp);
  state.amTick = am_rmw_abs_T5;
}

function am_rmw_abs_T5() {
  // Actual write of the processed data
  cpuWrite((state.adh << 8) | state.adl, state.tmp);

  state.amTick = null;
  state.fdTick = fd_fetch_T0;
}


// ----------------------------------------------------------------------------
// Read-modify-write operations: zero page,X addressing
// (†3: A. 4.3)

function am_rmw_zpx_T1() {
  state.pc     = ++state.pc & 0xffff;
  state.amTick = am_rmw_zpx_T2;
  state.fdTick = null;
}

function am_rmw_zpx_T2() {
  // Decode phase left the operand (zero page address) in state.tmp.
  // opFn takes an argument and returns a value.
  cpuRead(state.tmp);
  state.adl    = (state.tmp + state.x) & 0xff;
  state.amTick = am_rmw_zpx_T3;
}

function am_rmw_zpx_T3() {
  state.tmp    = cpuRead(state.adl);
  state.amTick = am_rmw_zpx_T4;
}

function am_rmw_zpx_T4() {
  // Dummy write of the fetched data back to itself
  cpuWrite(state.adl, state.tmp);
  state.tmp    = state.opFn(state.tmp);
  state.amTick = am_rmw_zpx_T5;
}

function am_rmw_zpx_T5() {
  // Actual write of the processed data
  cpuWrite(state.adl, state.tmp);
  state.amTick = null;
  state.fdTick = fd_fetch_T0;
}


// ----------------------------------------------------------------------------
// Read-modify-write operations: absolute,X / absolute,Y addressing
// (†3: A. 4.4)

// --------------------------------------------------------
// Absolute,X only

function am_rmw_abx_T1() {
  state.pc     = ++state.pc & 0xffff;
  state.amTick = am_rmw_abx_T2;
  state.fdTick = null;
}

function am_rmw_abx_T2() {
  // Decode phase left the base address low byte in state.tmp.
  // opFn takes an argument and returns a value.
  state.adh    = cpuRead(state.pc);
  state.pc     = ++state.pc & 0xffff;
  state.adl    = (state.tmp + state.x);  // 9 bits hereafter
  state.amTick = am_rmw_abxy_T3;
}

// --------------------------------------------------------
// Absolute,Y only (used only by quasi-ops)

function am_rmw_aby_T1() {
  state.pc     = ++state.pc & 0xffff;
  state.amTick = am_rmw_aby_T2;
  state.fdTick = null;
}

function am_rmw_aby_T2() {
  // Decode phase left the base address low byte in state.tmp.
  // opFn takes an argument and returns a value.
  state.adh    = cpuRead(state.pc);
  state.pc     = ++state.pc & 0xffff;
  state.adl    = (state.tmp + state.y);  // 9 bits hereafter
  state.amTick = am_rmw_abxy_T3;
}

// --------------------------------------------------------
// Common cycles for both absolute,X and absolute,Y

function am_rmw_abxy_T3() {
  // Dummy read from the potentially broken address
  state.tmp = cpuRead((state.adh << 8) | (state.adl & 0xff));

  if (state.adl > 0xff) {
    // Fix address
    state.adh  = ++state.adh & 0xff;
    state.adl &= 0xff;
  }

  // state.adl is 8 bits hereafter
  state.amTick = am_rmw_abxy_T4;
}

function am_rmw_abxy_T4() {
  state.tmp    = cpuRead((state.adh << 8) | state.adl);
  state.amTick = am_rmw_abxy_T5;
}

function am_rmw_abxy_T5() {
  // Dummy write of the fetched data back to itself
  cpuWrite((state.adh << 8) | state.adl, state.tmp);

  state.tmp    = state.opFn(state.tmp);
  state.amTick = am_rmw_abxy_T6;
}

function am_rmw_abxy_T6() {
  // Actual write of the processed data
  cpuWrite((state.adh << 8) | state.adl, state.tmp);

  state.amTick = null;
  state.fdTick = fd_fetch_T0;
}


// ----------------------------------------------------------------------------
// Read-modify-write operations: indirect,X addressing
// (Not referenced in †3, as only used by quasi-ops. Cycle sequence is thus
// guesswork, informed only by the IEOMD indirect,X sequence (†3: A. 2.4) and
// knowing that the instructions take 8 cycles (†4).)

function am_rmw_inx_T1() {
  state.pc     = ++state.pc & 0xffff;
  state.amTick = am_rmw_inx_T2;
  state.fdTick = null;
}

function am_rmw_inx_T2() {
  // Decode phase left the operand (zero page address) in state.tmp.
  // opFn expects its operand to be in state.tmp.
  cpuRead(state.tmp);
  state.tmp    = (state.tmp + state.x) & 0xff;
  state.amTick = am_rmw_inx_T3;
}

function am_rmw_inx_T3() {
  state.adl    = cpuRead(state.tmp);
  state.tmp    = ++state.tmp & 0xff;
  state.amTick = am_rmw_inx_T4;
}

function am_rmw_inx_T4() {
  state.adh    = cpuRead(state.tmp);
  state.amTick = am_rmw_inx_T5;
}

function am_rmw_inx_T5() {
  state.tmp    = cpuRead((state.adh << 8) | state.adl);
  state.amTick = am_rmw_inx_T6;
}

function am_rmw_inx_T6() {
  // All the other read-modify-write's do a dummy write after reading, while
  // the ALU's calculating, so this seems a safe bet.
  cpuWrite((state.adh << 8) | state.adl, state.tmp);
  state.tmp    = state.opFn(state.tmp);
  state.amTick = am_rmw_inx_T7;
}

function am_rmw_inx_T7() {
  cpuWrite((state.adh << 8) | state.adl, state.tmp);
  state.amTick = null;
  state.fdTick = fd_fetch_T0;
}


// ----------------------------------------------------------------------------
// Read-modify-write operations: indirect,Y addressing
// (Not referenced in †3, as only used by quasi-ops. Cycle sequence is thus
// guesswork, informed only by the IEOMD indirect,Y sequence (†3: A. 2.7) and
// knowing that the instructions take 8 cycles (†4).)

function am_rmw_iny_T1() {
  state.pc     = ++state.pc & 0xffff;
  state.amTick = am_rmw_iny_T2;
  state.fdTick = null;
}

function am_rmw_iny_T2() {
  // Decode phase left the operand (zero page address) in state.tmp.
  // opFn expects its operand to be in state.tmp.
  state.adl    = cpuRead(state.tmp);
  state.tmp    = ++state.tmp & 0xff;
  state.amTick = am_rmw_iny_T3;
}

function am_rmw_iny_T3() {
  state.adh    = cpuRead(state.tmp);
  state.adl    = state.adl + state.y;  // 9 bits hereafter
  state.amTick = am_rmw_iny_T4;
}

function am_rmw_iny_T4() {
  state.tmp    = cpuRead((state.adh << 8) | (state.adl & 0xff));

  if (state.adl > 0xff) {
    // Address needs fixing
    state.adh    = ++state.adh & 0xff;
    state.adl    = state.adl & 0xff;   // 8 bits hereafter
  }

  // state.adl is 8 bits hereafter
  state.amTick = am_rmw_iny_T5;
}

function am_rmw_iny_T5() {
  state.tmp    = cpuRead((state.adh << 8) | state.adl);
  state.amTick = am_rmw_iny_T6;
}

function am_rmw_iny_T6() {
  // All the other read-modify-write's do a dummy write after reading, while
  // the ALU's calculating, so this seems a safe bet.
  cpuWrite((state.adh << 8) | state.adl, state.tmp);
  state.tmp    = state.opFn(state.tmp);
  state.amTick = am_rmw_iny_T7;
}

function am_rmw_iny_T7() {
  cpuWrite((state.adh << 8) | state.adl, state.tmp);
  state.amTick = null;
  state.fdTick = fd_fetch_T0;
}


// ----------------------------------------------------------------------------
// Miscellaneous operations: push operations
// (†3: A. 5.1)

function am_push_T1() {
  state.amTick = am_push_T2;
  state.fdTick = null;
}

function am_push_T2() {
  // opFn returns the thing to be pushed.
  cpuWrite(0x100 + state.s, state.opFn());
  state.s      = --state.s & 0xff;
  state.amTick = null;
  state.fdTick = fd_fetch_T0;
}


// ----------------------------------------------------------------------------
// Miscellaneous operations: pull operations
// (†3: A. 5.2)

function am_pull_T1() {
  state.amTick = am_pull_T2;
  state.fdTick = null;
}

function am_pull_T2() {
  // opFn assigns its argument to the necessary register
  cpuRead(0x100 + state.s);
  state.s      = ++state.s & 0xff;
  state.amTick = am_pull_T3;
}

function am_pull_T3() {
  state.tmp    = cpuRead(0x100 + state.s);
  state.amTick = am_pull_T4;
  state.fdTick = fd_fetch_T0;
}

function am_pull_T4() {
  state.opFn(state.tmp);
  state.amTick = null;
}


// ----------------------------------------------------------------------------
// Miscellaneous operations: jump to subroutine
// (†3: A. 5.3)

function am_jsr_T1() {
  state.pc     = ++state.pc & 0xffff;
  state.amTick = am_jsr_T2;
  state.fdTick = null;
}

function am_jsr_T2() {
  // Decode phase left the subroutine address's low byte in state.tmp.
  // It's not clear to me why this cycle exists. It does nothing useful.
  cpuRead(0x100 + state.s);
  state.amTick = am_jsr_T3;
}

function am_jsr_T3() {
  cpuWrite(0x100 + state.s, state.pc >> 8);
  state.s      = --state.s & 0xff;
  state.amTick = am_jsr_T4;
}

function am_jsr_T4() {
  cpuWrite(0x100 + state.s, state.pc & 0xff);
  state.s      = --state.s & 0xff;
  state.amTick = am_jsr_T5;
}

function am_jsr_T5() {
  state.adh    = cpuRead(state.pc);
  state.amTick = am_jsr_T6;
}

function am_jsr_T6() {
  state.pc     = (state.adh << 8) | state.tmp;
  state.amTick = null;
  state.fdTick = fd_fetch_T0;
}


// ----------------------------------------------------------------------------
// Miscellaneous operations: break operation (hardware interrupt/BRK)
// (†3: A. 5.4)

function am_interrupt_T1() {

  // Only increment the PC if this is a BRK
  // (Though even still, that's not very useful)
  if (state.pendingInt === 0) {
    state.pc = ++state.pc & 0xffff;
  }

  state.fdTick = null;
  state.amTick = am_interrupt_T2;
}

function am_interrupt_T2() {

  // Push PCH onto stack
  cpuWrite(0x100 + state.s, state.pc >> 8);
  state.s = --state.s & 0xff;

  state.amTick = am_interrupt_T3;
}

function am_interrupt_T3() {

  // Push PCL onto stack
  cpuWrite(0x100 + state.s, state.pc & 0xff);
  state.s = --state.s & 0xff;

  state.amTick = am_interrupt_T4;
}

function am_interrupt_T4() {

  // Push P onto stack
  cpuWrite(0x100 + state.s, statusToP((state.pendingInt === 0) ? 1 : 0));
  state.s = --state.s & 0xff;

  // Now that the status register has been pushed, we can change it
  state.i = 1;

  state.amTick = am_interrupt_T5;
}

function am_interrupt_T5() {

  // Get interrupt vector lowbyte
  let lowbyte;

  if      (state.pendingInt === 0) lowbyte = 0xfffe;  // BRK
  else if (state.pendingInt === 1) lowbyte = 0xfffe;  // IRQ (same vector)
  else if (state.pendingInt === 2) lowbyte = 0xfffa;  // NMI
  else if (state.pendingInt === 3) lowbyte = 0xfffc;  // RESET

  state.pc = cpuRead(lowbyte);

  state.amTick = am_interrupt_T6;
}

function am_interrupt_T6() {

  // Get interrupt vector highbyte
  let highbyte;

  if      (state.pendingInt === 0) highbyte = 0xffff;  // BRK
  else if (state.pendingInt === 1) highbyte = 0xffff;  // IRQ (same vector)
  else if (state.pendingInt === 2) highbyte = 0xfffb;  // NMI
  else if (state.pendingInt === 3) highbyte = 0xfffd;  // RESET

  state.pc |= cpuRead(highbyte) << 8;

  // Clear pendingInt, so the next time we come to this sequence we'll assume
  // it's a BRK unless the interrupt poller wants to tell us otherwise.
  state.pendingInt = 0;

  state.amTick = null;
  state.fdTick = fd_fetch_T0;
}


// ----------------------------------------------------------------------------
// Miscellaneous operations: return from interrupt (RTI)
// (†3: A. 5.5)

function am_rti_T1() {
  state.amTick = am_rti_T2;
  state.fdTick = null;
}

function am_rti_T2() {
  cpuRead(0x100 + state.s);
  state.s      = ++state.s & 0xff;
  state.amTick = am_rti_T3;
}

function am_rti_T3() {
  pToStatus(cpuRead(0x100 + state.s));
  state.s      = ++state.s & 0xff;
  state.amTick = am_rti_T4;
}

function am_rti_T4() {
  state.pc     = cpuRead(0x100 + state.s);
  state.s      = ++state.s & 0xff;
  state.amTick = am_rti_T5;
}

function am_rti_T5() {
  state.pc    |= cpuRead(0x100 + state.s) << 8;
  state.amTick = null;
  state.fdTick = fd_fetch_T0;
}


// ----------------------------------------------------------------------------
// Jump operation: absolute addressing
// (†3: A. 5.6.1)

function am_jmp_abs_T1() {
  state.pc     = ++state.pc & 0xffff;
  state.amTick = am_jmp_abs_T2;
  state.fdTick = null;
}

function am_jmp_abs_T2() {
  // Decode phase left the target address's low byte in state.tmp.
  state.pc     = (cpuRead(state.pc) << 8) | state.tmp;
  state.amTick = null;
  state.fdTick = fd_fetch_T0;
}


// ----------------------------------------------------------------------------
// Jump operation: indirect addressing
// (†3: A. 5.6.2)

function am_jmp_ind_T1() {
  state.pc     = ++state.pc & 0xffff;
  state.amTick = am_jmp_ind_T2;
  state.fdTick = null;
}

function am_jmp_ind_T2() {
  // Decode phase left the pointer address's low byte in state.tmp.
  state.adh    = cpuRead(state.pc);
  state.amTick = am_jmp_ind_T3;
}

function am_jmp_ind_T3() {
  state.pc     = cpuRead((state.adh << 8) | state.tmp);
  state.tmp    = ++state.tmp & 0xff;
  state.amTick = am_jmp_ind_T4;
}

function am_jmp_ind_T4() {
  state.pc    |= cpuRead((state.adh << 8) | state.tmp) << 8;
  state.amTick = null;
  state.fdTick = fd_fetch_T0;
}


// ----------------------------------------------------------------------------
// Miscellaneous operations: return from subroutine (RTS)
// (†3: A. 5.7)

function am_rts_T1() {
  state.amTick = am_rts_T2;
  state.fdTick = null;
}

function am_rts_T2() {
  cpuRead(0x100 + state.s);
  state.s      = ++state.s & 0xff;
  state.amTick = am_rts_T3;
}

function am_rts_T3() {
  state.pc     = cpuRead(0x100 + state.s);
  state.s      = ++state.s & 0xff;
  state.amTick = am_rts_T4;
}

function am_rts_T4() {
  state.pc    |= cpuRead(0x100 + state.s) << 8;
  state.amTick = am_rts_T5;
}

function am_rts_T5() {
  cpuRead(state.pc);
  state.pc     = ++state.pc & 0xffff;
  state.amTick = null;
  state.fdTick = fd_fetch_T0;
}


// ----------------------------------------------------------------------------
// Miscellaneous operations: branch operaion
// (†3: A. 5.8 has to be wrong; see presumed fix in †2)

function am_rel_T1() {
  state.pc     = ++state.pc & 0xffff;
  state.fdTick = null;
  state.amTick = am_rel_T2;
}

function am_rel_T2() {
  // Instruction decode will have left the instruction operand (the branch offset)
  // in state.tmp for us

  // Read next opcode, if that's what it turns out to be
  state.ir = cpuRead(state.pc);

  // This stage would be T2 of a branch instruction, which seems to be (†2)
  // where the relative mode interrupt poll seems to be.
  pollForInterrupts();

  // Evaluate the branch criterion
  if (state.opFn()) {

    // Taking branch
    const offset = state.tmp; // operand, from previous cycle

    // 9-bit ADL, effectively
    state.adl = (state.pc & 0xff) + (offset < 0x80 ? offset : -(256 - offset));

    // Cobble together an un-fixed PC by adding the low bytes without carry
    state.pc = (state.pc & 0xff00) | (state.adl & 0xff);

    state.amTick = am_rel_T3;
    return;
  }
  
  // Branch not taken. Skip straight to the decode stage as we've already
  // performed the instruction fetch.

  // Latch the instruction register from zero (BRK) if there are interrupts
  if (state.pendingInt) {
    state.ir = 0;
  }
  else {
    state.pc = ++state.pc & 0xffff;
  }

  state.amTick = null;
  state.fdTick = fd_decode_T1;
}

function am_rel_T3() {

  // Read next opcode from un-fixed PC, then figure out if it needed fixing
  state.ir = cpuRead(state.pc);

  if (state.adl & 0x100) {  // (state.adl < 0) || (state.adl > 0xff)

    state.pc = (state.adl < 0)
      ? ((state.pc - 0x100) & 0xffff)
      : ((state.pc + 0x100) & 0xffff)
    ;
    
    // End the addressing mode processing and use the regular fetch/decode
    // fetch stage to execute from the next instruction. This would be why,
    // I'm thinking, real hardware honors interrupts an instruction sooner when
    // the PC needed fixup than when it doesn't. (See †2)

    state.amTick = null;
    state.fdTick = fd_fetch_T0;
  }

  else {
    // It didn't need fixing. Since we already have the fetched instruction,
    // advance straight to fd_decode_T1

    // Latch the instruction register from zero (BRK) if there are interrupts
    if (state.pendingInt) {
      state.ir = 0;
    }
    else {
      state.pc = ++state.pc & 0xffff;
    }

    state.amTick = null;
    state.fdTick = fd_decode_T1;
  }
}


// ----------------------------------------------------------------------------
// HLT opcode
// Not documented, since it's a quasi-op mode, and it causes an irrecoverable
// failure, so capturing the nuances of what specifically happens each cycle
// is irrelevant.

function am_halt_T1() {
  // 'unimplemented' doesn't accurately describe this. We need an alternative
  // error reporting hook.
  (0,_debug__WEBPACK_IMPORTED_MODULE_0__.unimplementedWarning)(`HLT opcode at PC=${(0,_debug__WEBPACK_IMPORTED_MODULE_0__.$xxxx)(state.pc)}`);
  state.amTick = null;
  state.fdTick = null;
}


// Opcode operations
//
// These functions are supplied to the addressing mode handler and perform the
// key functionality of the opcode. Different addressing mode handlers have
// different expectations of how they expect their op functions to take inputs
// and give outputs. Hence, to clarify usage, their names take the format:
//
//      op_XXX_in_out
//
// ...where in = void     takes no explicit input (maybe from regs)
//          in = tmp      takes input from state.tmp
//          in = arg      takes input from sole function argument
//
//         out = void     returns nothing (or is implicit, or to regs)
//         out = ret      returns value from function return value


// Flow control operations
// ...don't need to exist: they're never called. They only exist to help
// explain the opcodes of the table where they're used.

function op_BRK_void_void() { }
function op_JSR_void_void() { }
function op_RTI_void_void() { }
function op_JMP_void_void() { }
function op_RTS_void_void() { }
function op_HLT_void_void() { }  // Quasi-op

// Single-byte operations
// ...operate entirely on registers

function op_NOP_void_void() { }
function op_CLC_void_void() { state.c = 0; }
function op_CLD_void_void() { state.d = 0; }
function op_CLI_void_void() { state.i = 0; }
function op_CLV_void_void() { state.v = 0; }

function op_SEC_void_void() { state.c = 1; }
function op_SED_void_void() { state.d = 1; }
function op_SEI_void_void() { state.i = 1; }

function op_TAX_void_void() { state.x = state.a; state.z = state.x ? 0 : 1; state.n = (state.x & 0x80) ? 1 : 0; }
function op_TAY_void_void() { state.y = state.a; state.z = state.y ? 0 : 1; state.n = (state.y & 0x80) ? 1 : 0; }
function op_TXA_void_void() { state.a = state.x; state.z = state.a ? 0 : 1; state.n = (state.a & 0x80) ? 1 : 0; }
function op_TYA_void_void() { state.a = state.y; state.z = state.a ? 0 : 1; state.n = (state.a & 0x80) ? 1 : 0; }
function op_TSX_void_void() { state.x = state.s; state.z = state.x ? 0 : 1; state.n = (state.x & 0x80) ? 1 : 0; }
function op_TXS_void_void() { state.s = state.x;                                                            }

function op_DEX_void_void() { state.x = --state.x & 0xff; state.z = state.x ? 0 : 1; state.n = (state.x & 0x80) ? 1 : 0; }
function op_DEY_void_void() { state.y = --state.y & 0xff; state.z = state.y ? 0 : 1; state.n = (state.y & 0x80) ? 1 : 0; }
function op_INX_void_void() { state.x = ++state.x & 0xff; state.z = state.x ? 0 : 1; state.n = (state.x & 0x80) ? 1 : 0; }
function op_INY_void_void() { state.y = ++state.y & 0xff; state.z = state.y ? 0 : 1; state.n = (state.y & 0x80) ? 1 : 0; }

// Read-modify-write operations
// ...take a parameter and return a new value for it.

function op_ASL_arg_ret(arg) {
  arg <<= 1;
  state.c = (arg & 0x100) ? 1 : 0;
  arg &= 0xff;
  state.z = arg ? 0 : 1;
  state.n = (arg & 0x80) ? 1 : 0;
  return arg;
}

function op_LSR_arg_ret(arg) {
  state.c = arg & 1;
  arg >>= 1;
  state.z = arg ? 0 : 1;
  state.n = 0;
  return arg;
}

function op_ROL_arg_ret(arg) {
  arg <<= 1;
  arg |= state.c;
  state.c = (arg & 0x100) ? 1 : 0;
  arg &= 0xff;
  state.z = arg ? 0 : 1;
  state.n = (arg & 0x80) ? 1 : 0;
  return arg;
}

function op_ROR_arg_ret(arg) {
  const tmp = state.c;
  state.c = arg & 1;
  arg >>= 1;
  arg |= (tmp << 7);
  state.z = arg ? 0 : 1;
  state.n = (arg & 0x80) ? 1 : 0;
  return arg;
}

function op_LSE_arg_ret(arg) {
  // Quasi-op: "LSE" (†4), "SRE" (†1)
  state.tmp = op_LSR_arg_ret(arg);
  op_EOR_tmp_void();
  return state.tmp;
}

function op_DCM_arg_ret(arg) {
  // Quasi-op: "DCM" (†4), "DCP" (†1)
  state.tmp = op_DEC_arg_ret(arg);
  op_CMP_tmp_void();
  return state.tmp;
}

function op_ASO_arg_ret(arg) {
  // Quasi-op: "ASO" (†4), "SLO" (†1)
  state.tmp = op_ASL_arg_ret(arg);
  op_ORA_tmp_void();
  return state.tmp;
}

function op_RLA_arg_ret(arg) {
  // Quasi-op: "RLA" (†4 and †1)
  state.tmp = op_ROL_arg_ret(arg);
  op_AND_tmp_void();
  return state.tmp;
}

function op_RRA_arg_ret(arg) {
  // Quasi-op: "RRA" (†4 and †1)
  state.tmp = op_ROR_arg_ret(arg);
  op_ADC_tmp_void();
  return state.tmp;
}

function op_INS_arg_ret(arg) {
  // Quasi-op: "INS" (†4), "ISB" (†1), and also "ISB" (†4)
  state.tmp = op_INC_arg_ret(arg);
  op_SBC_tmp_void();
  return state.tmp;
}

function op_INC_arg_ret(arg) { arg = ++arg & 0xff; state.z = arg ? 0 : 1; state.n = (arg & 0x80) ? 1 : 0; return arg; }
function op_DEC_arg_ret(arg) { arg = --arg & 0xff; state.z = arg ? 0 : 1; state.n = (arg & 0x80) ? 1 : 0; return arg; }
function op_NOP_arg_ret(arg) { /* Quasi-op */                                                             return arg; }

// Boolean functions
// ...take a parameter and mutate the accumulator with it.

function op_EOR_tmp_void() { state.a ^= state.tmp; state.z = state.a ? 0 : 1;           state.n = (state.a & 0x80) ? 1 : 0; }
function op_ORA_tmp_void() { state.a |= state.tmp; state.z = state.a ? 0 : 1;           state.n = (state.a & 0x80) ? 1 : 0; }
function op_AND_tmp_void() { state.a &= state.tmp; state.z = state.a ? 0 : 1;           state.n = (state.a & 0x80) ? 1 : 0; }
function op_ANC_tmp_void() { state.a &= state.tmp; state.z = state.a ? 0 : 1; state.c = state.n = (state.a & 0x80) ? 1 : 0; }  // Quasi-op

function op_BIT_tmp_void() {
  state.z = (state.a & state.tmp) ? 0 : 1;
  state.n = (state.tmp & 0x80) ? 1 : 0;
  state.v = (state.tmp & 0x40) ? 1 : 0;
}

function op_ANE_tmp_void() {
  // Quasi-op: "XAA" (†4, which is inaccurate), "ANE" (†1)

  // †1 describes how this 0x11 constant can alternatively be 0x10, 0x01,
  // or 0x00 depending on residual charge on the open bus. The 0x11 used here
  // is the value expected by the Lorenz aneb test.
  state.a = ((state.a & 0x11 & state.x) | ( 0xee & state.x)) & state.tmp;
  state.z = state.a ? 0 : 1;
  state.n = (state.a & 0x80) ? 1 : 0;
}

function op_LXA_tmp_void() {
  // Quasi-op: "OAL" (†4), "LXA" (†1)

  // The 0xee here makes me think of the 0xee in ANE and how its 0x11 can be
  // unstable. This quasi-op sounds similarly unstable, so likewise, the
  // behavior here is whatever the Lorenz lxab test expects it to be.
  state.a = state.x = (state.a | 0xee) & state.tmp;
  state.z = state.a ? 0 : 1;
  state.n = (state.a & 0x80) ? 1 : 0;
}

function op_SBX_tmp_void() {
  // Quasi-op: "SAX" (†4), "SBX" (†1)
  const tmp = (state.a & state.x) - state.tmp;

  state.x = tmp & 0xff;
  state.c = (tmp >= 0) ? 1 : 0;
  state.z = state.x ? 0 : 1;
  state.n = (state.x & 0x80) ? 1 : 0;
}

function op_ALR_tmp_void() {
// Quasi-op: "ALR" (†4), "ASR" (†1)
  state.a = op_LSR_arg_ret(state.a & state.tmp);
}

function op_ARR_tmp_void() {
  // Quasi-op: "ARR" (†4 (which is inaccurate) and †1)

  if (state.d) {
    // Translated from †1. I've skipped the annotations because this is really
    // just an arbitrary muddle of accidental logic, of no use to anyone.
    let t = state.a & state.tmp;

    let ah = t >> 4;
    let al = t & 15;

    state.n = state.c;
    state.a = (t >> 1) | (state.c << 7);

    state.z = state.a ? 0 : 1;
    state.v = ((t ^ state.a) & 64) ? 1 : 0;

    if (al + (al & 1) > 5) {
      state.a = (state.a & 0xf0) | ((state.a + 6) & 0xf);
    }

    state.c = ((ah + (ah & 1)) > 5) ? 1 : 0;

    if (state.c) {
      state.a = (state.a + 0x60) & 0xff;
    }
  }
  else {
    state.a = op_ROR_arg_ret(state.a & state.tmp);

    state.c = ((state.a >> 6)                 ) & 1;
    state.v = ((state.a >> 6) ^ (state.a >> 5)) & 1;
  }
}

// Loads
// ...commit a parameter to a register.

function op_LDA_tmp_void() {           state.a = state.tmp; state.z = state.a ? 0 : 1; state.n = (state.a & 0x80) ? 1 : 0; }
function op_LDX_tmp_void() {           state.x = state.tmp; state.z = state.x ? 0 : 1; state.n = (state.x & 0x80) ? 1 : 0; }
function op_LDY_tmp_void() {           state.y = state.tmp; state.z = state.y ? 0 : 1; state.n = (state.y & 0x80) ? 1 : 0; }
function op_LAX_tmp_void() { state.x = state.a = state.tmp; state.z = state.a ? 0 : 1; state.n = (state.a & 0x80) ? 1 : 0; }  // Quasi-op

function op_LAS_tmp_void() {
  // Quasi-op: "LAS" (†4 and †1)
  state.a = state.x = state.s = state.tmp & state.s;
  state.z = state.a ? 0 : 1;
  state.n = (state.a & 0x80) ? 1 : 0;
}

// Stores
// ...supply a value for the addressing mode to commit to memory.

function op_STA_void_ret() { return state.a;                                      }
function op_STX_void_ret() { return state.x;                                      }
function op_STY_void_ret() { return state.y;                                      }
function op_AXS_void_ret() { return state.a & state.x;                            }  // Quasi-op: "AXS" (†4), "SAX" (†1)
function op_SHA_void_ret() { return state.a & state.x & ((state.adh + 1) & 0xff); }  // Quasi-op: "AXA" (†4), "SHA" (†1)
function op_SHX_void_ret() { return           state.x & ((state.adh + 1) & 0xff); }  // Quasi-op: "XAS" (†4), "SHX" (†1)
function op_SHY_void_ret() { return           state.y & ((state.adh + 1) & 0xff); }  // Quasi-op: "SAY" (†4), "SHY" (†1)

function op_SHS_void_ret() {
  // Quasi-op: "TAS" (†4), "SHS" (†1)
  state.s = state.a & state.x;
  return state.s & ((state.adh + 1) & 0xff);
}

// Compares
// ...compare a register to a parameter value.

function op_CMP_tmp_void() { const tmp = state.a - state.tmp; state.c = (tmp >= 0) ? 1 : 0; state.z = tmp ? 0 : 1; state.n = (tmp & 0x80) ? 1 : 0; }
function op_CPX_tmp_void() { const tmp = state.x - state.tmp; state.c = (tmp >= 0) ? 1 : 0; state.z = tmp ? 0 : 1; state.n = (tmp & 0x80) ? 1 : 0; }
function op_CPY_tmp_void() { const tmp = state.y - state.tmp; state.c = (tmp >= 0) ? 1 : 0; state.z = tmp ? 0 : 1; state.n = (tmp & 0x80) ? 1 : 0; }

// Add-subtract
// ...take a parameter and operate on the accumulator.

function op_ADC_tmp_void() { ADC_helper(state.tmp); }
function op_SBC_tmp_void() { SBC_helper(state.tmp); }

// Branches
// ...supply a boolean to inform the addressing mode whether to branch.

function op_BCC_void_ret() { return state.c === 0; }
function op_BCS_void_ret() { return state.c === 1; }
function op_BEQ_void_ret() { return state.z === 1; }
function op_BMI_void_ret() { return state.n === 1; }
function op_BNE_void_ret() { return state.z === 0; }
function op_BPL_void_ret() { return state.n === 0; }
function op_BVC_void_ret() { return state.v === 0; }
function op_BVS_void_ret() { return state.v === 1; }

// Pushes
// ...supply a value for the addressing mode to push on the stack.

function op_PHA_void_ret() { return state.a;      }
function op_PHP_void_ret() { return statusToP(1); }

// Pulls
// ...commit a value that the addressing mode has popped from the stack.

function op_PLA_arg_void(arg) { state.a = arg; state.z = arg ? 0 : 1; state.n = (arg & 0x80) ? 1 : 0; }
function op_PLP_arg_void(arg) { pToStatus(arg);                                                       }





function ADC_helper(src) {
  // TODO: This really wants cleaning up

  if (state.d) {
    
    state.z = ((state.a + src + state.c) & 0xff) ? 0 : 1;
    let al = (state.a & 0xf) + (src & 0xf) + state.c;
    state.c = 0;
    if (al > 9) al = ((al - 10) & 0xf) + 0x10;

    let seahn = (state.a & 0xf0);
    let sebhn = (    src & 0xf0);

    seahn = (seahn >= 0x80) ? (-1 & ~0xff) | (seahn & 0xff) : seahn;
    sebhn = (sebhn >= 0x80) ? (-1 & ~0xff) | (sebhn & 0xff) : sebhn;

    let temp = seahn + sebhn + al;

    state.n = (temp & 128) ? 1 : 0;
    state.v = ((temp < -128) || (temp > 127)) ? 1 : 0;
    state.a = (state.a & 0xf0) + (src & 0xf0) + al;

    if (state.a >= 0xa0) {
      state.a -= 0xa0;
      state.c = 1;
    }

    state.a &= 0xff;
  }
  else {
    const initialAcc = state.a;
    state.a += src;
    state.a += state.c;
    
    state.c = (state.a & 0x100) ? 1 : 0;
    state.a &= 0xff;
    state.z = state.a ? 0 : 1;
    state.n = (state.a & 0x80) ? 1 : 0;
    
    state.v = ~(initialAcc ^ src) & (initialAcc ^ state.a) & 0x80;
    state.v = state.v ? 1 : 0;
  }
}

function SBC_helper(src) {
  if (state.d) {

    // TODO: This also really wants cleaning up

    const ain = state.a;
    const cin = state.c;
    const sin = src;

    // CNVZ flags come from the binary implementation, so...
    // --------------------------------
    src = (~src) & 0xff;
    state.d = 0;
    ADC_helper(src);
    state.d = 1;
    // --------------------------------
    let al = (ain & 0xf) - (sin & 0xf) + cin - 1;
    if (al < 0) al = ((al - 6) & 0xf) - 0x10;
    state.a = (ain & 0xf0) - (sin & 0xf0) + al;
    if (state.a < 0) state.a -= 0x60;
    state.a &= 0xff;
  }
  else {
    src = (~src) & 0xff;
    ADC_helper(src);
  }
}


function statusToP(b) {
  return (
    (state.n ? (1 << 7) : 0)
  | (state.v ? (1 << 6) : 0)
  | (          (1 << 5)    )
  | (      b ? (1 << 4) : 0)
  | (state.d ? (1 << 3) : 0)
  | (state.i ? (1 << 2) : 0)
  | (state.z ? (1 << 1) : 0)
  | (state.c ? (1 << 0) : 0)
  );
}

function pToStatus(byte) {
  state.n = (byte >> 7) & 1;
  state.v = (byte >> 6) & 1;

  state.d = (byte >> 3) & 1;
  state.i = (byte >> 2) & 1;
  state.z = (byte >> 1) & 1;
  state.c = (byte >> 0) & 1;
}

function showState() {
  try {
    console.log(
      `PC=${(0,_debug__WEBPACK_IMPORTED_MODULE_0__.$xxxx)(state.pc)}` +
      ` A=${(0,_debug__WEBPACK_IMPORTED_MODULE_0__.$xx)(state.a)}` +
      ` X=${(0,_debug__WEBPACK_IMPORTED_MODULE_0__.$xx)(state.x)}` +
      ` Y=${(0,_debug__WEBPACK_IMPORTED_MODULE_0__.$xx)(state.y)}` +
      ` SR=${(0,_debug__WEBPACK_IMPORTED_MODULE_0__.$xx)(statusToP(0))}` +
      ` (` +
        ((state.n) ? "N" : "_") +
        ((state.v) ? "V" : "_") +
        (            "-"      ) +
        (            "-"      ) +
        ((state.d) ? "D" : "_") +
        ((state.i) ? "I" : "_") +
        ((state.z) ? "Z" : "_") +
        ((state.c) ? "C" : "_") +
      `)` +
      ` SP=${(0,_debug__WEBPACK_IMPORTED_MODULE_0__.$xxxx)(state.s)}` +
      ` | ` +
      c64.runloop.getState().cycle +
      ` | ` +
      (0,_tools_disasm__WEBPACK_IMPORTED_MODULE_1__.disasm)(cpuRead, state.pc, state.pc + 1)
    );
  }
  catch (e) {
    console.log("Regs are:", state);
    console.log("Error:", e);
    throw new Error("Regs are corrupted");
  }
}

function assertRegs() {
  if (typeof state.a !== "number")      throw new Error("Bad state.a: " + state.a);
  if ((state.a < 0) || (state.a > 255)) throw new Error("Bad state.a: " + state.a);

  if (typeof state.s !== "number")      throw new Error("Bad state.s: " + state.s);
  if ((state.s < 0) || (state.s > 255)) throw new Error("Bad state.s: " + state.s);

  if (typeof state.x !== "number")      throw new Error("Bad state.x: " + state.x);
  if ((state.x < 0) || (state.x > 255)) throw new Error("Bad state.x: " + state.x);

  if (typeof state.y !== "number")      throw new Error("Bad state.y: " + state.y);
  if ((state.y < 0) || (state.y > 255)) throw new Error("Bad state.y: " + state.y);

  if ((state.c !== 0) && (state.c !== 1)) throw new Error("Bad state.c: " + state.c);
  if ((state.v !== 0) && (state.v !== 1)) throw new Error("Bad state.v: " + state.v);
  if ((state.n !== 0) && (state.n !== 1)) throw new Error("Bad state.n: " + state.n);
  if ((state.z !== 0) && (state.z !== 1)) throw new Error("Bad state.z: " + state.z);
  if ((state.d !== 0) && (state.d !== 1)) throw new Error("Bad state.d: " + state.d);
  if ((state.i !== 0) && (state.i !== 1)) throw new Error("Bad state.i: " + state.i);
}

function pollForInterrupts() {

  // Look to see if any interrupts should divert execution. If they should, we
  // record that in the state in a variable which must be looked at whenever
  // an opcode is loaded into the instruction register (because we'd be putting
  // zero there instead)

  const nmi = getNmi();

  // NMI takes precedence over an IRQ, and ignores the I flag. Or so †3 would
  // have you believe. Test Suite 2.15.txt suggests the 6510 _does_ turn on
  // I-disable for the NMI. Try it and see...

  // NMI is edge-triggered, whereas IRQ is level-triggered
  // TODO: forums suggest that NMI edge detection is per-cycle, but this
  // is doing it per poll
  if (nmi !== state.lastNmi) {
    state.lastNmi = nmi;
    if (nmi) {
      // I'm hearing disagreement on whether state.i inhibits NMIs on a 6510.
      // Need to just try it out on real hardware.
      // Frantic Freddie gets stuck unless it's inhibited. But then if
      // allowed through it just gets stuck in gameplay.
      // if (!state.i) {
        state.pendingInt = 2;
        return;
      // }
    }
  }

  const irq = getIrq();

  if (irq) {
    if (!state.i) {
      state.pendingInt = 1;
      return;
    }
  }
}


function tick() {
  // We should probably only do this in dev builds
  assertRegs();

  // Make a copy of the state machine functions so that if one changes another,
  // it won't take effect until the next cycle.
  const { fdTick, amTick } = state;

  if (fdTick) fdTick();
  if (amTick) amTick();
}

function serialize() {
  return JSON.stringify({
    ...state,
    amTick: (0,_tools_serializerSupport__WEBPACK_IMPORTED_MODULE_2__.functionToReference)(state.amTick),
    fdTick: (0,_tools_serializerSupport__WEBPACK_IMPORTED_MODULE_2__.functionToReference)(state.fdTick),
    opFn:   (0,_tools_serializerSupport__WEBPACK_IMPORTED_MODULE_2__.functionToReference)(state.opFn),
  });
}

function deserialize(json) {
  state = JSON.parse(json);

  state.amTick = (0,_tools_serializerSupport__WEBPACK_IMPORTED_MODULE_2__.referenceToFunction)(state.amTick);
  state.fdTick = (0,_tools_serializerSupport__WEBPACK_IMPORTED_MODULE_2__.referenceToFunction)(state.fdTick);
  state.opFn   = (0,_tools_serializerSupport__WEBPACK_IMPORTED_MODULE_2__.referenceToFunction)(state.opFn);
}

(0,_tools_serializerSupport__WEBPACK_IMPORTED_MODULE_2__.addToSerializerRegistry)({
  fd_fetch_T0,
  fd_decode_T1,
  am_singleByte_imp_T1,
  am_singleByte_imp_T2,
  am_singleByte_acc_T1,
  am_singleByte_acc_T2,
  am_ieomd_imm_T1,
  am_ieomd_imm_T2,
  am_ieomd_zp_T1,
  am_ieomd_zp_T2,
  am_ieomd_zp_T3,
  am_ieomd_abs_T1,
  am_ieomd_abs_T2,
  am_ieomd_abs_T3,
  am_ieomd_abs_T4,
  am_ieomd_inx_T1,
  am_ieomd_inx_T2,
  am_ieomd_inx_T3,
  am_ieomd_inx_T4,
  am_ieomd_inx_T5,
  am_ieomd_inx_T6,
  am_ieomd_abx_T1,
  am_ieomd_abx_T2,
  am_ieomd_aby_T1,
  am_ieomd_aby_T2,
  am_ieomd_abxy_T3,
  am_ieomd_abxy_T4,
  am_ieomd_abxy_T5,
  am_ieomd_zpx_T1,
  am_ieomd_zpx_T2,
  am_ieomd_zpy_T1,
  am_ieomd_zpy_T2,
  am_ieomd_zpxy_T3,
  am_ieomd_zpxy_T4,
  am_ieomd_iny_T1,
  am_ieomd_iny_T2,
  am_ieomd_iny_T3,
  am_ieomd_iny_T4,
  am_ieomd_iny_T5,
  am_ieomd_iny_T6,
  am_store_zp_T1,
  am_store_zp_T2,
  am_store_abs_T1,
  am_store_abs_T2,
  am_store_abs_T3,
  am_store_inx_T1,
  am_store_inx_T2,
  am_store_inx_T3,
  am_store_inx_T4,
  am_store_inx_T5,
  am_store_abx_T1,
  am_store_abx_T2,
  am_store_aby_T1,
  am_store_aby_T2,
  am_store_abxy_T3,
  am_store_abxy_T4,
  am_store_zpx_T1,
  am_store_zpx_T2,
  am_store_zpy_T1,
  am_store_zpy_T2,
  am_store_zpxy_T3,
  am_store_iny_T1,
  am_store_iny_T2,
  am_store_iny_T3,
  am_store_iny_T4,
  am_store_iny_T5,
  am_rmw_zp_T1,
  am_rmw_zp_T2,
  am_rmw_zp_T3,
  am_rmw_zp_T4,
  am_rmw_abs_T1,
  am_rmw_abs_T2,
  am_rmw_abs_T3,
  am_rmw_abs_T4,
  am_rmw_abs_T5,
  am_rmw_zpx_T1,
  am_rmw_zpx_T2,
  am_rmw_zpx_T3,
  am_rmw_zpx_T4,
  am_rmw_zpx_T5,
  am_rmw_abx_T1,
  am_rmw_abx_T2,
  am_rmw_aby_T1,
  am_rmw_aby_T2,
  am_rmw_abxy_T3,
  am_rmw_abxy_T4,
  am_rmw_abxy_T5,
  am_rmw_abxy_T6,
  am_rmw_inx_T1,
  am_rmw_inx_T2,
  am_rmw_inx_T3,
  am_rmw_inx_T4,
  am_rmw_inx_T5,
  am_rmw_inx_T6,
  am_rmw_inx_T7,
  am_rmw_iny_T1,
  am_rmw_iny_T2,
  am_rmw_iny_T3,
  am_rmw_iny_T4,
  am_rmw_iny_T5,
  am_rmw_iny_T6,
  am_rmw_iny_T7,
  am_push_T1,
  am_push_T2,
  am_pull_T1,
  am_pull_T2,
  am_pull_T3,
  am_pull_T4,
  am_jsr_T1,
  am_jsr_T2,
  am_jsr_T3,
  am_jsr_T4,
  am_jsr_T5,
  am_jsr_T6,
  am_interrupt_T1,
  am_interrupt_T2,
  am_interrupt_T3,
  am_interrupt_T4,
  am_interrupt_T5,
  am_interrupt_T6,
  am_rti_T1,
  am_rti_T2,
  am_rti_T3,
  am_rti_T4,
  am_rti_T5,
  am_jmp_abs_T1,
  am_jmp_abs_T2,
  am_jmp_ind_T1,
  am_jmp_ind_T2,
  am_jmp_ind_T3,
  am_jmp_ind_T4,
  am_rts_T1,
  am_rts_T2,
  am_rts_T3,
  am_rts_T4,
  am_rts_T5,
  am_rel_T1,
  am_rel_T2,
  am_rel_T3,
  am_halt_T1,
  op_BRK_void_void,
  op_JSR_void_void,
  op_RTI_void_void,
  op_JMP_void_void,
  op_RTS_void_void,
  op_HLT_void_void,
  op_NOP_void_void,
  op_CLC_void_void,
  op_CLD_void_void,
  op_CLI_void_void,
  op_CLV_void_void,
  op_SEC_void_void,
  op_SED_void_void,
  op_SEI_void_void,
  op_TAX_void_void,
  op_TAY_void_void,
  op_TXA_void_void,
  op_TYA_void_void,
  op_TSX_void_void,
  op_TXS_void_void,
  op_DEX_void_void,
  op_DEY_void_void,
  op_INX_void_void,
  op_INY_void_void,
  op_ASL_arg_ret,
  op_LSR_arg_ret,
  op_ROL_arg_ret,
  op_ROR_arg_ret,
  op_LSE_arg_ret,
  op_DCM_arg_ret,
  op_ASO_arg_ret,
  op_RLA_arg_ret,
  op_RRA_arg_ret,
  op_INS_arg_ret,
  op_INC_arg_ret,
  op_DEC_arg_ret,
  op_NOP_arg_ret,
  op_EOR_tmp_void,
  op_ORA_tmp_void,
  op_AND_tmp_void,
  op_ANC_tmp_void,
  op_BIT_tmp_void,
  op_ANE_tmp_void,
  op_LXA_tmp_void,
  op_SBX_tmp_void,
  op_ALR_tmp_void,
  op_ARR_tmp_void,
  op_LDA_tmp_void,
  op_LDX_tmp_void,
  op_LDY_tmp_void,
  op_LAX_tmp_void,
  op_LAS_tmp_void,
  op_STA_void_ret,
  op_STX_void_ret,
  op_STY_void_ret,
  op_AXS_void_ret,
  op_SHA_void_ret,
  op_SHX_void_ret,
  op_SHY_void_ret,
  op_SHS_void_ret,
  op_CMP_tmp_void,
  op_CPX_tmp_void,
  op_CPY_tmp_void,
  op_ADC_tmp_void,
  op_SBC_tmp_void,
  op_BCC_void_ret,
  op_BCS_void_ret,
  op_BEQ_void_ret,
  op_BMI_void_ret,
  op_BNE_void_ret,
  op_BPL_void_ret,
  op_BVC_void_ret,
  op_BVS_void_ret,
  op_PHA_void_ret,
  op_PHP_void_ret,
  op_PLA_arg_void,
  op_PLP_arg_void,
});


/***/ }),

/***/ "./src/target/ram.js":
/*!***************************!*\
  !*** ./src/target/ram.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   attach: () => (/* binding */ attach)
/* harmony export */ });
/* harmony import */ var _tools_base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/base64 */ "./src/tools/base64.js");
/*
   ram: emulates 64KiB of byte-addressed RAM
*/



// bound by attach
let c64;

const state = new Uint8Array(65536);

function attach(nascentC64) {
  c64 = nascentC64;

  nascentC64.ram = {
    // Control
    reset,
    serialize,
    deserialize,
    // Accessors
    readRam,
    writeRam,
    vicReadRam,
  };

  reset();
}

function reset() {
  // Initialize RAM with 0xdeadbeef. Not to help our own debugging, but to
  // simulate static noise. Some games, like Dominator's tape loader, look for
  // a constant value in memory as a sign that you're trying to hack them, and
  // will crash if they detect one.
  for (let i = 0; i < 65536; i += 4) {
    state[i + 0] = 0xde;
    state[i + 1] = 0xad;
    state[i + 2] = 0xbe;
    state[i + 3] = 0xef;
  }
}

function serialize() {
  return (0,_tools_base64__WEBPACK_IMPORTED_MODULE_0__.base64Encode)(state);
}

function deserialize(base64) {
  const bytes = (0,_tools_base64__WEBPACK_IMPORTED_MODULE_0__.base64Decode)(base64);
  for (let i in bytes) {
    state[i] = bytes[i];
  }
}

function readRam(addr) {
  if (c64.hooks.onRamRead) c64.hooks.onRamRead(addr);
  return state[addr];
}

function vicReadRam(addr) {
  if (c64.hooks.onVicRead) c64.hooks.onVicRead(addr);
  return state[addr];
}

function writeRam(addr, byte) {
  if (c64.hooks.onRamWrite) c64.hooks.onRamWrite(addr, byte);
  state[addr] = byte;
}


/***/ }),

/***/ "./src/target/rom/basic.js":
/*!*********************************!*\
  !*** ./src/target/rom/basic.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tools_assembler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/assembler */ "./src/tools/assembler.js");
/*
   Basic ($a000 – $bfff)

   The source below assembles into a bytestream fully compatible with the C64's
   Basic ROM. It's adapted from Michael Steil's adaptation(†1) of Lee Davison's
   investigation into the original firmware. All comments below are Lee's.

   The labels are informed by Project64's collection of memory maps(†2) and
   those used in Mapping The Commodore 64(†3). Where sources disagree on names/
   locations, I've based my choices on which had the most consensus and which
   best corresponds to the instructions or data to which they relate.

   †1 https://github.com/mist64/c64disasm
   †2 https://github.com/Project-64/reloaded/blob/master/c64/64MAP11.TXT
   †3 https://github.com/Project-64/reloaded/blob/master/c64/mapc64/MAPC6412.TXT

   If you want to substitute your own ROM, just export a byte array instead:
       export default [ 0x.., ... ];

   Unlike the rest of the Viciious project, which was authored from scratch and
   entered into the public domain, the source below is derived from works by
   multiple other authors and I make no representations as to its ownership or
   terms of use.

   Note that the Basic interpreter spills over into the Kernal ROM.
*/



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_tools_assembler__WEBPACK_IMPORTED_MODULE_0__.assemble)(
  0xa000,
  ({
    NOP, LDA, LDX, LDY, STA, STX, STY, CLC, CLD, CLI, CLV, SEC, SED, SEI,
    TAX, TAY, TSX, TXA, TXS, TYA, CMP, CPX, CPY, BCS, BCC, BEQ, BNE, BMI,
    BPL, BVS, BVC, BIT, JSR, RTS, RTI, BRK, JMP, INC, DEC, DEX, DEY, INX,
    INY, ADC, SBC, AND, EOR, ORA, ASL, ROL, LSR, ROR, PHA, PHP, PLA, PLP,
    _
  }) => {
            // External labels (RAM)
            _.label(0x0002, "_0002");
            _.label(0x0003, "adray1+0_0003");
            _.label(0x0004, "adray1+1_0004");
            _.label(0x0007, "charac_0007");
            _.label(0x0008, "endchr_0008");
            _.label(0x0009, "trmpos_0009");
            _.label(0x000b, "count_000b");
            _.label(0x000c, "dimflg_000c");
            _.label(0x000d, "valtyp_000d");
            _.label(0x000e, "intflg_000e");
            _.label(0x000f, "garbfl_000f");
            _.label(0x0010, "subflg_0010");
            _.label(0x0011, "inpflg_0011");
            _.label(0x0012, "tansgn_0012");
            _.label(0x0013, "channl_0013");
            _.label(0x0014, "linnum+0_0014");
            _.label(0x0015, "linnum+1_0015");
            _.label(0x0016, "temppt_0016");
            _.label(0x0017, "lastpt+0_0017");
            _.label(0x0018, "lastpt+1_0018");
            _.label(0x0022, "index+0_0022");
            _.label(0x0023, "index+1_0023");
            _.label(0x0024, "index+2_0024");
            _.label(0x0025, "index+3_0025");
            _.label(0x0026, "resho+0_0026");
            _.label(0x0027, "resho+1_0027");
            _.label(0x0028, "resho+2_0028");
            _.label(0x0029, "resho+3_0029");
            _.label(0x002b, "txttab+0_002b");
            _.label(0x002c, "txttab+1_002c");
            _.label(0x002d, "vartab+0_002d");
            _.label(0x002e, "vartab+1_002e");
            _.label(0x002f, "arytab+0_002f");
            _.label(0x0030, "arytab+1_0030");
            _.label(0x0031, "strend+0_0031");
            _.label(0x0032, "strend+1_0032");
            _.label(0x0033, "fretop+0_0033");
            _.label(0x0034, "fretop+1_0034");
            _.label(0x0035, "frespc+0_0035");
            _.label(0x0036, "frespc+1_0036");
            _.label(0x0037, "memsiz+0_0037");
            _.label(0x0038, "memsiz+1_0038");
            _.label(0x0039, "curlin+0_0039");
            _.label(0x003a, "curlin+1_003a");
            _.label(0x003b, "oldlin+0_003b");
            _.label(0x003c, "oldlin+1_003c");
            _.label(0x003d, "oldtxt+0_003d");
            _.label(0x003e, "oldtxt+1_003e");
            _.label(0x003f, "datlin+0_003f");
            _.label(0x0040, "datlin+1_0040");
            _.label(0x0041, "datptr+0_0041");
            _.label(0x0042, "datptr+1_0042");
            _.label(0x0043, "inpptr+0_0043");
            _.label(0x0044, "inpptr+1_0044");
            _.label(0x0045, "varnam+0_0045");
            _.label(0x0046, "varnam+1_0046");
            _.label(0x0047, "varpnt+0_0047");
            _.label(0x0048, "varpnt+1_0048");
            _.label(0x0049, "forpnt+0_0049");
            _.label(0x004a, "forpnt+1_004a");
            _.label(0x004b, "opptr+0_004b");
            _.label(0x004c, "opptr+1_004c");
            _.label(0x004d, "opmask_004d");
            _.label(0x004e, "defpnt+0_004e");
            _.label(0x004f, "defpnt+1_004f");
            _.label(0x0050, "dscpnt+0_0050");
            _.label(0x0051, "dscpnt+1_0051");
            _.label(0x0053, "four6_0053");
            _.label(0x0054, "jmper+0_0054");
            _.label(0x0055, "jmper+1_0055");
            _.label(0x0056, "jmper+2_0056");
            _.label(0x0058, "tempf1+1_0058");
            _.label(0x0059, "tempf1+2_0059");
            _.label(0x005a, "tempf1+3_005a");
            _.label(0x005b, "tempf1+4_005b");
            _.label(0x005d, "tempf2+1_005d");
            _.label(0x005e, "tempf2+2_005e");
            _.label(0x005f, "tempf2+3_005f");
            _.label(0x0060, "tempf2+4_0060");
            _.label(0x0061, "facexp_0061");
            _.label(0x0062, "facho+0_0062");
            _.label(0x0063, "facho+1_0063");
            _.label(0x0064, "facho+2_0064");
            _.label(0x0065, "facho+3_0065");
            _.label(0x0066, "facsgn_0066");
            _.label(0x0067, "sgnflg_0067");
            _.label(0x0068, "bits_0068");
            _.label(0x0069, "argexp_0069");
            _.label(0x006a, "argho+0_006a");
            _.label(0x006b, "argho+1_006b");
            _.label(0x006c, "argho+2_006c");
            _.label(0x006d, "argho+3_006d");
            _.label(0x006e, "argsgn_006e");
            _.label(0x006f, "arisgn_006f");
            _.label(0x0070, "facov_0070");
            _.label(0x0071, "fbufpt+0_0071");
            _.label(0x0072, "fbufpt+1_0072");
            _.label(0x0073, "chrget+0_0073");
            _.label(0x0079, "chrgot_0079");
            _.label(0x007a, "txtptr+0_007a");
            _.label(0x007b, "txtptr+1_007b");
            _.label(0x0080, "chrget+13_0080");
            _.label(0x00ff, "baszpt_00ff");
            _.label(0x0100, "bad+0_0100");
            _.label(0x0101, "bad+1_0101");
            _.label(0x0102, "bad+2_0102");
            _.label(0x0103, "bad+3_0103");
            _.label(0x0104, "bad+4_0104");
            _.label(0x0109, "bad+9_0109");
            _.label(0x010f, "bad+15_010f");
            _.label(0x0110, "bad+16_0110");
            _.label(0x0111, "bad+17_0111");
            _.label(0x0112, "bad+18_0112");
            _.label(0x01fb, "bstack+188_01fb");
            _.label(0x01fc, "bstack+189_01fc");
            _.label(0x01fd, "bstack+190_01fd");
            _.label(0x01fe, "bstack+191_01fe");
            _.label(0x01ff, "bstack+192_01ff");
            _.label(0x0200, "buf+0_0200");
            _.label(0x0201, "buf+1_0201");
            _.label(0x0300, "ierror+0_0300");
            _.label(0x0302, "imain+0_0302");
            _.label(0x0304, "icrnch+0_0304");
            _.label(0x0306, "iqplop+0_0306");
            _.label(0x0308, "igone+0_0308");
            _.label(0x030a, "ieval+0_030a");
            _.label(0x9fea, "_9fea");
            _.label(0x9feb, "_9feb");

            // External labels (Memory-mapped IO)
            _.label(0x0001, "r6510_0001");

            // External labels (Kernal ROM)
            _.label(0xe000, "(exp_e000");
            _.label(0xe043, "polyx_e043");
            _.label(0xe10c, "bchout_e10c");
            _.label(0xe112, "bchin_e112");
            _.label(0xe118, "bckout_e118");
            _.label(0xe11e, "bckin_e11e");
            _.label(0xe124, "bgetin_e124");
            _.label(0xe386, "_e386");
            _.label(0xff90, "setmsg_ff90");
            _.label(0xffb7, "readst_ffb7");
            _.label(0xffcc, "clrchn_ffcc");
            _.label(0xffdb, "settim_ffdb");
            _.label(0xffde, "rdtim_ffde");
            _.label(0xffe1, "stop_ffe1");
            _.label(0xffe7, "clall_ffe7");
            _.label(0xfff0, "plot_fff0");

// ---------------------------------------------------------- start of the BASIC ROM
/* a000 */ _`restart_a000`;  _.bytes(0x94, 0xe3);          // BASIC cold start entry point
/* a002 */                   _.bytes(0x7b, 0xe3);          // BASIC warm start entry point

                                                           // 'cbmbasic', ROM name, unreferenced
/* a004 */                   _.bytes(0x43, 0x42, 0x4d, 0x42, 0x41, 0x53, 0x49, 0x43);

// ------------------------------------------------------- // action addresses for primary commands
                                                           // these are called by pushing the address onto the stack and doing an RTS so the
                                                           // actual address -1 needs to be pushed
/* a00c */  _`stmdsp_a00c`;  _.bytes(0x30, 0xa8);          // perform END     $80
/* a00e */                   _.bytes(0x41, 0xa7);          // perform FOR     $81
/* a010 */                   _.bytes(0x1d, 0xad);          // perform NEXT    $82
/* a012 */                   _.bytes(0xf7, 0xa8);          // perform DATA    $83
/* a014 */                   _.bytes(0xa4, 0xab);          // perform INPUT#  $84
/* a016 */                   _.bytes(0xbe, 0xab);          // perform INPUT   $85
/* a018 */                   _.bytes(0x80, 0xb0);          // perform DIM     $86
/* a01a */                   _.bytes(0x05, 0xac);          // perform READ    $87
/* a01c */                   _.bytes(0xa4, 0xa9);          // perform LET     $88
/* a01e */                   _.bytes(0x9f, 0xa8);          // perform GOTO    $89
/* a020 */                   _.bytes(0x70, 0xa8);          // perform RUN     $8A
/* a022 */                   _.bytes(0x27, 0xa9);          // perform IF      $8B
/* a024 */                   _.bytes(0x1c, 0xa8);          // perform RESTORE $8C
/* a026 */                   _.bytes(0x82, 0xa8);          // perform GOSUB   $8D
/* a028 */                   _.bytes(0xd1, 0xa8);          // perform RETURN  $8E
/* a02a */                   _.bytes(0x3a, 0xa9);          // perform REM     $8F
/* a02c */                   _.bytes(0x2e, 0xa8);          // perform STOP    $90
/* a02e */                   _.bytes(0x4a, 0xa9);          // perform ON      $91
/* a030 */                   _.bytes(0x2c, 0xb8);          // perform WAIT    $92
/* a032 */                   _.bytes(0x67, 0xe1);          // perform LOAD    $93
/* a034 */                   _.bytes(0x55, 0xe1);          // perform SAVE    $94
/* a036 */                   _.bytes(0x64, 0xe1);          // perform VERIFY  $95
/* a038 */                   _.bytes(0xb2, 0xb3);          // perform DEF     $96
/* a03a */                   _.bytes(0x23, 0xb8);          // perform POKE    $97
/* a03c */                   _.bytes(0x7f, 0xaa);          // perform PRINT#  $98
/* a03e */                   _.bytes(0x9f, 0xaa);          // perform PRINT   $99
/* a040 */                   _.bytes(0x56, 0xa8);          // perform CONT    $9A
/* a042 */                   _.bytes(0x9b, 0xa6);          // perform LIST    $9B
/* a044 */                   _.bytes(0x5d, 0xa6);          // perform CLR     $9C
/* a046 */                   _.bytes(0x85, 0xaa);          // perform CMD     $9D
/* a048 */                   _.bytes(0x29, 0xe1);          // perform SYS     $9E
/* a04a */                   _.bytes(0xbd, 0xe1);          // perform OPEN    $9F
/* a04c */                   _.bytes(0xc6, 0xe1);          // perform CLOSE   $A0
/* a04e */                   _.bytes(0x7a, 0xab);          // perform GET     $A1
/* a050 */                   _.bytes(0x41, 0xa6);          // perform NEW     $A2

// ------------------------------------------------------- // action addresses for functions
/* a052 */  _`fundsp_a052`;  _.bytes(0x39, 0xbc);          // perform SGN     $B4
/* a054 */                   _.bytes(0xcc, 0xbc);          // perform INT     $B5
/* a056 */                   _.bytes(0x58, 0xbc);          // perform ABS     $B6
/* a058 */                   _.bytes(0x10, 0x03);          // perform USR     $B7
/* a05a */                   _.bytes(0x7d, 0xb3);          // perform FRE     $B8
/* a05c */                   _.bytes(0x9e, 0xb3);          // perform POS     $B9
/* a05e */                   _.bytes(0x71, 0xbf);          // perform SQR     $BA
/* a060 */                   _.bytes(0x97, 0xe0);          // perform RND     $BB
/* a062 */                   _.bytes(0xea, 0xb9);          // perform LOG     $BC
/* a064 */                   _.bytes(0xed, 0xbf);          // perform EXP     $BD
/* a066 */                   _.bytes(0x64, 0xe2);          // perform COS     $BE
/* a068 */                   _.bytes(0x6b, 0xe2);          // perform SIN     $BF
/* a06a */                   _.bytes(0xb4, 0xe2);          // perform TAN     $C0
/* a06c */                   _.bytes(0x0e, 0xe3);          // perform ATN     $C1
/* a06e */                   _.bytes(0x0d, 0xb8);          // perform PEEK    $C2
/* a070 */                   _.bytes(0x7c, 0xb7);          // perform LEN     $C3
/* a072 */                   _.bytes(0x65, 0xb4);          // perform STR$    $C4
/* a074 */                   _.bytes(0xad, 0xb7);          // perform VAL     $C5
/* a076 */                   _.bytes(0x8b, 0xb7);          // perform ASC     $C6
/* a078 */                   _.bytes(0xec, 0xb6);          // perform CHR$    $C7
/* a07a */                   _.bytes(0x00, 0xb7);          // perform LEFT$   $C8
/* a07c */                   _.bytes(0x2c, 0xb7);          // perform RIGHT$  $C9
/* a07e */                   _.bytes(0x37, 0xb7);          // perform MID$    $CA

// ------------------------------------------------------- // precedence byte and action addresses for operators
                                                           // like the primary commands these are called by pushing the address onto the stack
                                                           // and doing an RTS, so again the actual address -1 needs to be pushed
/* a080 */   _`optab_a080`;  _.bytes(0x79, 0x69, 0xb8);    // +
/* a083 */                   _.bytes(0x79, 0x52, 0xb8);    // -
/* a086 */                   _.bytes(0x7b, 0x2a, 0xba);    // *
/* a089 */                   _.bytes(0x7b, 0x11, 0xbb);    // /
/* a08c */                   _.bytes(0x7f, 0x7a, 0xbf);    // ^
/* a08f */                   _.bytes(0x50, 0xe8, 0xaf);    // AND
/* a092 */                   _.bytes(0x46, 0xe5, 0xaf);    // OR
/* a095 */                   _.bytes(0x7d, 0xb3, 0xbf);    // >
/* a098 */                   _.bytes(0x5a, 0xd3, 0xae);    // =
/* a09b */                   _.bytes(0x64, 0x15, 0xb0);    // <

// ------------------------------------------------------- // BASIC keywords
                                                           // each word has b7 set in it's last character as an end marker, even
                                                           // the one character keywords such as "<" or "="
                                                           // first are the primary command keywords, only these can start a statement
/* a09e */  _`reslst_a09e`;  _.bytes(0x45, 0x4e);          // end
                                                           // for next
/* a0a0 */                   _.bytes(0xc4, 0x46, 0x4f, 0xd2, 0x4e, 0x45, 0x58, 0xd4);
                                                           // data input#
/* a0a8 */                   _.bytes(0x44, 0x41, 0x54, 0xc1, 0x49, 0x4e, 0x50, 0x55);
                                                           // input dim
/* a0b0 */                   _.bytes(0x54, 0xa3, 0x49, 0x4e, 0x50, 0x55, 0xd4, 0x44);
                                                           // read let
/* a0b8 */                   _.bytes(0x49, 0xcd, 0x52, 0x45, 0x41, 0xc4, 0x4c, 0x45);
                                                           // goto run
/* a0c0 */                   _.bytes(0xd4, 0x47, 0x4f, 0x54, 0xcf, 0x52, 0x55, 0xce);
                                                           // if restore
/* a0c8 */                   _.bytes(0x49, 0xc6, 0x52, 0x45, 0x53, 0x54, 0x4f, 0x52);
                                                           // gosub return
/* a0d0 */                   _.bytes(0xc5, 0x47, 0x4f, 0x53, 0x55, 0xc2, 0x52, 0x45);
                                                           // rem stop
/* a0d8 */                   _.bytes(0x54, 0x55, 0x52, 0xce, 0x52, 0x45, 0xcd, 0x53);
                                                           // on wait
/* a0e0 */                   _.bytes(0x54, 0x4f, 0xd0, 0x4f, 0xce, 0x57, 0x41, 0x49);
                                                           // load save
/* a0e8 */                   _.bytes(0xd4, 0x4c, 0x4f, 0x41, 0xc4, 0x53, 0x41, 0x56);
                                                           // verify def
/* a0f0 */                   _.bytes(0xc5, 0x56, 0x45, 0x52, 0x49, 0x46, 0xd9, 0x44);
                                                           // poke print#
/* a0f8 */                   _.bytes(0x45, 0xc6, 0x50, 0x4f, 0x4b, 0xc5, 0x50, 0x52);
                                                           // print
/* a100 */                   _.bytes(0x49, 0x4e, 0x54, 0xa3, 0x50, 0x52, 0x49, 0x4e);
                                                           // cont list
/* a108 */                   _.bytes(0xd4, 0x43, 0x4f, 0x4e, 0xd4, 0x4c, 0x49, 0x53);
                                                           // clr cmd sys
/* a110 */                   _.bytes(0xd4, 0x43, 0x4c, 0xd2, 0x43, 0x4d, 0xc4, 0x53);
                                                           // open close
/* a118 */                   _.bytes(0x59, 0xd3, 0x4f, 0x50, 0x45, 0xce, 0x43, 0x4c);
                                                           // get new
/* a120 */                   _.bytes(0x4f, 0x53, 0xc5, 0x47, 0x45, 0xd4, 0x4e, 0x45);

                                                           // next are the secondary command keywords, these can not start a statement
                                                           // tab( to
/* a128 */                   _.bytes(0xd7, 0x54, 0x41, 0x42, 0xa8, 0x54, 0xcf, 0x46);
                                                           // spc( then
/* a130 */                   _.bytes(0xce, 0x53, 0x50, 0x43, 0xa8, 0x54, 0x48, 0x45);
                                                           // not step
/* a138 */                   _.bytes(0xce, 0x4e, 0x4f, 0xd4, 0x53, 0x54, 0x45, 0xd0);
                                                           // next are the operators
                                                           // + - * / ' and
/* a140 */  _`oplist_a140`;  _.bytes(0xab, 0xad, 0xaa, 0xaf, 0xde, 0x41, 0x4e, 0xc4);
                                                           // or <=>
/* a148 */                   _.bytes(0x4f, 0xd2, 0xbe, 0xbd, 0xbc);
/* a14d */  _`funlst_a14d`;  _.bytes(0x53, 0x47, 0xce);    // sgn

                                                           // and finally the functions
                                                           // int abs usr
/* a150 */                   _.bytes(0x49, 0x4e, 0xd4, 0x41, 0x42, 0xd3, 0x55, 0x53);
                                                           // fre pos sqr
/* a158 */                   _.bytes(0xd2, 0x46, 0x52, 0xc5, 0x50, 0x4f, 0xd3, 0x53);
                                                           // rnd log
/* a160 */                   _.bytes(0x51, 0xd2, 0x52, 0x4e, 0xc4, 0x4c, 0x4f, 0xc7);
                                                           // exp cos sin
/* a168 */                   _.bytes(0x45, 0x58, 0xd0, 0x43, 0x4f, 0xd3, 0x53, 0x49);
                                                           // tan atn peek
/* a170 */                   _.bytes(0xce, 0x54, 0x41, 0xce, 0x41, 0x54, 0xce, 0x50);
                                                           // len str$
/* a178 */                   _.bytes(0x45, 0x45, 0xcb, 0x4c, 0x45, 0xce, 0x53, 0x54);
                                                           // val asc
/* a180 */                   _.bytes(0x52, 0xa4, 0x56, 0x41, 0xcc, 0x41, 0x53, 0xc3);
                                                           // chr$ left$
/* a188 */                   _.bytes(0x43, 0x48, 0x52, 0xa4, 0x4c, 0x45, 0x46, 0x54);
                                                           // right$ mid$
/* a190 */                   _.bytes(0xa4, 0x52, 0x49, 0x47, 0x48, 0x54, 0xa4, 0x4d);

                                                           // lastly is GO, this is an add on so that GO TO, as well as GOTO, will work
                                                           // go
/* a198 */                   _.bytes(0x49, 0x44, 0xa4, 0x47, 0xcf);
/* a19d */                   _.bytes(0x00);                // end marker

// ------------------------------------------------------- // BASIC error messages
/* a19e */  _`errtab_a19e`;  _.bytes(0x54, 0x4f);          // 1 too many files
/* a1a0 */                   _.bytes(0x4f, 0x20, 0x4d, 0x41, 0x4e, 0x59, 0x20, 0x46);
                                                           // 2 file open
/* a1a8 */                   _.bytes(0x49, 0x4c, 0x45, 0xd3, 0x46, 0x49, 0x4c, 0x45);
                                                           // 3 file not open
/* a1b0 */                   _.bytes(0x20, 0x4f, 0x50, 0x45, 0xce, 0x46, 0x49, 0x4c);
/* a1b8 */                   _.bytes(0x45, 0x20, 0x4e, 0x4f, 0x54, 0x20, 0x4f, 0x50);
                                                           // 4 file not found
/* a1c0 */                   _.bytes(0x45, 0xce, 0x46, 0x49, 0x4c, 0x45, 0x20, 0x4e);
                                                           // 5 device not present
/* a1c8 */                   _.bytes(0x4f, 0x54, 0x20, 0x46, 0x4f, 0x55, 0x4e, 0xc4);
/* a1d0 */                   _.bytes(0x44, 0x45, 0x56, 0x49, 0x43, 0x45, 0x20, 0x4e);
/* a1d8 */                   _.bytes(0x4f, 0x54, 0x20, 0x50, 0x52, 0x45, 0x53, 0x45);
                                                           // 6 not input file
/* a1e0 */                   _.bytes(0x4e, 0xd4, 0x4e, 0x4f, 0x54, 0x20, 0x49, 0x4e);
/* a1e8 */                   _.bytes(0x50, 0x55, 0x54, 0x20, 0x46, 0x49, 0x4c, 0xc5);
                                                           // 7 not output file
/* a1f0 */                   _.bytes(0x4e, 0x4f, 0x54, 0x20, 0x4f, 0x55, 0x54, 0x50);
/* a1f8 */                   _.bytes(0x55, 0x54, 0x20, 0x46, 0x49, 0x4c, 0xc5, 0x4d);
                                                           // 8 missing filename
/* a200 */                   _.bytes(0x49, 0x53, 0x53, 0x49, 0x4e, 0x47, 0x20, 0x46);
/* a208 */                   _.bytes(0x49, 0x4c, 0x45, 0x20, 0x4e, 0x41, 0x4d, 0xc5);
                                                           // 9 illegal device number
/* a210 */                   _.bytes(0x49, 0x4c, 0x4c, 0x45, 0x47, 0x41, 0x4c, 0x20);
/* a218 */                   _.bytes(0x44, 0x45, 0x56, 0x49, 0x43, 0x45, 0x20, 0x4e);
                                                           // 10 next without for
/* a220 */                   _.bytes(0x55, 0x4d, 0x42, 0x45, 0xd2, 0x4e, 0x45, 0x58);
/* a228 */                   _.bytes(0x54, 0x20, 0x57, 0x49, 0x54, 0x48, 0x4f, 0x55);
                                                           // 11 syntax
/* a230 */                   _.bytes(0x54, 0x20, 0x46, 0x4f, 0xd2, 0x53, 0x59, 0x4e);
                                                           // 12 return without gosub
/* a238 */                   _.bytes(0x54, 0x41, 0xd8, 0x52, 0x45, 0x54, 0x55, 0x52);
/* a240 */                   _.bytes(0x4e, 0x20, 0x57, 0x49, 0x54, 0x48, 0x4f, 0x55);
                                                           // 13 out of data
/* a248 */                   _.bytes(0x54, 0x20, 0x47, 0x4f, 0x53, 0x55, 0xc2, 0x4f);
/* a250 */                   _.bytes(0x55, 0x54, 0x20, 0x4f, 0x46, 0x20, 0x44, 0x41);
                                                           // 14 illegal quantity
/* a258 */                   _.bytes(0x54, 0xc1, 0x49, 0x4c, 0x4c, 0x45, 0x47, 0x41);
/* a260 */                   _.bytes(0x4c, 0x20, 0x51, 0x55, 0x41, 0x4e, 0x54, 0x49);
                                                           // 15 overflow
/* a268 */                   _.bytes(0x54, 0xd9, 0x4f, 0x56, 0x45, 0x52, 0x46, 0x4c);
                                                           // 16 out of memory
/* a270 */                   _.bytes(0x4f, 0xd7, 0x4f, 0x55, 0x54, 0x20, 0x4f, 0x46);
                                                           // 17 undef'd statement
/* a278 */                   _.bytes(0x20, 0x4d, 0x45, 0x4d, 0x4f, 0x52, 0xd9, 0x55);
/* a280 */                   _.bytes(0x4e, 0x44, 0x45, 0x46, 0x27, 0x44, 0x20, 0x53);
/* a288 */                   _.bytes(0x54, 0x41, 0x54, 0x45, 0x4d, 0x45, 0x4e, 0xd4);
                                                           // 18 bad subscript
/* a290 */                   _.bytes(0x42, 0x41, 0x44, 0x20, 0x53, 0x55, 0x42, 0x53);
                                                           // 19 redim'd array
/* a298 */                   _.bytes(0x43, 0x52, 0x49, 0x50, 0xd4, 0x52, 0x45, 0x44);
/* a2a0 */                   _.bytes(0x49, 0x4d, 0x27, 0x44, 0x20, 0x41, 0x52, 0x52);
                                                           // 20 division by zero
/* a2a8 */                   _.bytes(0x41, 0xd9, 0x44, 0x49, 0x56, 0x49, 0x53, 0x49);
/* a2b0 */                   _.bytes(0x4f, 0x4e, 0x20, 0x42, 0x59, 0x20, 0x5a, 0x45);
                                                           // 21 illegal direct
/* a2b8 */                   _.bytes(0x52, 0xcf, 0x49, 0x4c, 0x4c, 0x45, 0x47, 0x41);
/* a2c0 */                   _.bytes(0x4c, 0x20, 0x44, 0x49, 0x52, 0x45, 0x43, 0xd4);
                                                           // 22 type mismatch
/* a2c8 */                   _.bytes(0x54, 0x59, 0x50, 0x45, 0x20, 0x4d, 0x49, 0x53);
                                                           // 23 string too long
/* a2d0 */                   _.bytes(0x4d, 0x41, 0x54, 0x43, 0xc8, 0x53, 0x54, 0x52);
/* a2d8 */                   _.bytes(0x49, 0x4e, 0x47, 0x20, 0x54, 0x4f, 0x4f, 0x20);
                                                           // 24 file data
/* a2e0 */                   _.bytes(0x4c, 0x4f, 0x4e, 0xc7, 0x46, 0x49, 0x4c, 0x45);
                                                           // 25 formula too complex
/* a2e8 */                   _.bytes(0x20, 0x44, 0x41, 0x54, 0xc1, 0x46, 0x4f, 0x52);
/* a2f0 */                   _.bytes(0x4d, 0x55, 0x4c, 0x41, 0x20, 0x54, 0x4f, 0x4f);
/* a2f8 */                   _.bytes(0x20, 0x43, 0x4f, 0x4d, 0x50, 0x4c, 0x45, 0xd8);
                                                           // 26 can't continue
/* a300 */                   _.bytes(0x43, 0x41, 0x4e, 0x27, 0x54, 0x20, 0x43, 0x4f);
                                                           // 27 undef'd function
/* a308 */                   _.bytes(0x4e, 0x54, 0x49, 0x4e, 0x55, 0xc5, 0x55, 0x4e);
/* a310 */                   _.bytes(0x44, 0x45, 0x46, 0x27, 0x44, 0x20, 0x46, 0x55);
                                                           // 28 verify
/* a318 */                   _.bytes(0x4e, 0x43, 0x54, 0x49, 0x4f, 0xce, 0x56, 0x45);
                                                           // 29 load
/* a320 */                   _.bytes(0x52, 0x49, 0x46, 0xd9, 0x4c, 0x4f, 0x41, 0xc4);

// ------------------------------------------------------- // error message pointer table
/* a328 */  _`errptr_a328`;  _.bytes(0x9e, 0xa1, 0xac, 0xa1, 0xb5, 0xa1, 0xc2, 0xa1);
/* a330 */                   _.bytes(0xd0, 0xa1, 0xe2, 0xa1, 0xf0, 0xa1, 0xff, 0xa1);
/* a338 */                   _.bytes(0x10, 0xa2, 0x25, 0xa2, 0x35, 0xa2, 0x3b, 0xa2);
/* a340 */                   _.bytes(0x4f, 0xa2, 0x5a, 0xa2, 0x6a, 0xa2, 0x72, 0xa2);
/* a348 */                   _.bytes(0x7f, 0xa2, 0x90, 0xa2, 0x9d, 0xa2, 0xaa, 0xa2);
/* a350 */                   _.bytes(0xba, 0xa2, 0xc8, 0xa2, 0xd5, 0xa2, 0xe4, 0xa2);
/* a358 */                   _.bytes(0xed, 0xa2, 0x00, 0xa3, 0x0e, 0xa3, 0x1e, 0xa3);
/* a360 */                   _.bytes(0x24, 0xa3, 0x83, 0xa3);

// ------------------------------------------------------- // BASIC messages
                                                           // OK
/* a364 */     _`okk_a364`;  _.bytes(0x0d, 0x4f, 0x4b, 0x0d);
                                                           // ERROR
/* a368 */                   _.bytes(0x00, 0x20, 0x20, 0x45, 0x52, 0x52, 0x4f, 0x52);
                                                           // IN
/* a370 */                   _.bytes(0x00, 0x20, 0x49, 0x4e, 0x20, 0x00, 0x0d, 0x0a);
                                                           // READY.
/* a378 */                   _.bytes(0x52, 0x45, 0x41, 0x44, 0x59, 0x2e, 0x0d, 0x0a);
                                                           // BREAK
/* a380 */                   _.bytes(0x00, 0x0d, 0x0a, 0x42, 0x52, 0x45, 0x41, 0x4b);
/* a388 */                   _.bytes(0x00);

// ------------------------------------------------------- // spare byte, not referenced
/* a389 */                   _.bytes(0xa0);                // unused

// ------------------------------------------------------- // search the stack for FOR or GOSUB activity
                                                           // return Zb=1 if FOR variable found
/* a38a */  _`fndfor_a38a`;  TSX.imp ();                   // copy stack pointer
/* a38b */                   INX.imp ();                   // +1 pass return address
/* a38c */                   INX.imp ();                   // +2 pass return address
/* a38d */                   INX.imp ();                   // +3 pass calling routine return address
/* a38e */                   INX.imp ();                   // +4 pass calling routine return address
/* a38f */        _`_a38f`;  LDA.abx ("bad+1_0101");       // get the token byte from the stack
/* a392 */                   CMP.imm (0x81);               // is it the FOR token
/* a394 */                   BNE.rel ("_a3b7");            // if not FOR token just exit
                                                           // it was the FOR token
/* a396 */                   LDA.zpg ("forpnt+1_004a");    // get FOR/NEXT variable pointer high byte
/* a398 */                   BNE.rel ("_a3a4");            // branch if not null
/* a39a */                   LDA.abx ("bad+2_0102");       // get FOR variable pointer low byte
/* a39d */                   STA.zpg ("forpnt+0_0049");    // save FOR/NEXT variable pointer low byte
/* a39f */                   LDA.abx ("bad+3_0103");       // get FOR variable pointer high byte
/* a3a2 */                   STA.zpg ("forpnt+1_004a");    // save FOR/NEXT variable pointer high byte
/* a3a4 */        _`_a3a4`;  CMP.abx ("bad+3_0103");       // compare variable pointer with stacked variable pointer
                                                           // high byte
/* a3a7 */                   BNE.rel ("_a3b0");            // branch if no match
/* a3a9 */                   LDA.zpg ("forpnt+0_0049");    // get FOR/NEXT variable pointer low byte
/* a3ab */                   CMP.abx ("bad+2_0102");       // compare variable pointer with stacked variable pointer
                                                           // low byte
/* a3ae */                   BEQ.rel ("_a3b7");            // exit if match found
/* a3b0 */        _`_a3b0`;  TXA.imp ();                   // copy index
/* a3b1 */                   CLC.imp ();                   // clear carry for add
/* a3b2 */                   ADC.imm (0x12);               // add FOR stack use size
/* a3b4 */                   TAX.imp ();                   // copy back to index
/* a3b5 */                   BNE.rel ("_a38f");            // loop if not at start of stack
/* a3b7 */        _`_a3b7`;  RTS.imp ();

// ------------------------------------------------------- // open up a space in the memory, set the end of arrays
/* a3b8 */    _`bltu_a3b8`;  JSR.abs ("reason_a408");      // check available memory, do out of memory error if no room
/* a3bb */                   STA.zpg ("strend+0_0031");    // set end of arrays low byte
/* a3bd */                   STY.zpg ("strend+1_0032");    // set end of arrays high byte
                                                           // open up a space in the memory, don't set the array end
/* a3bf */        _`_a3bf`;  SEC.imp ();                   // set carry for subtract
/* a3c0 */                   LDA.zpg ("tempf1+3_005a");    // get block end low byte
/* a3c2 */                   SBC.zpg ("tempf2+3_005f");    // subtract block start low byte
/* a3c4 */                   STA.zpg ("index+0_0022");     // save MOD(block length/$100) byte
/* a3c6 */                   TAY.imp ();                   // copy MOD(block length/$100) byte to Y
/* a3c7 */                   LDA.zpg ("tempf1+4_005b");    // get block end high byte
/* a3c9 */                   SBC.zpg ("tempf2+4_0060");    // subtract block start high byte
/* a3cb */                   TAX.imp ();                   // copy block length high byte to X
/* a3cc */                   INX.imp ();                   // +1 to allow for count=0 exit
/* a3cd */                   TYA.imp ();                   // copy block length low byte to A
/* a3ce */                   BEQ.rel ("_a3f3");            // branch if length low byte=0
                                                           // block is (X-1)*256+Y bytes, do the Y bytes first
/* a3d0 */                   LDA.zpg ("tempf1+3_005a");    // get block end low byte
/* a3d2 */                   SEC.imp ();                   // set carry for subtract
/* a3d3 */                   SBC.zpg ("index+0_0022");     // subtract MOD(block length/$100) byte
/* a3d5 */                   STA.zpg ("tempf1+3_005a");    // save corrected old block end low byte
/* a3d7 */                   BCS.rel ("_a3dc");            // branch if no underflow
/* a3d9 */                   DEC.zpg ("tempf1+4_005b");    // else decrement block end high byte
/* a3db */                   SEC.imp ();                   // set carry for subtract
/* a3dc */        _`_a3dc`;  LDA.zpg ("tempf1+1_0058");    // get destination end low byte
/* a3de */                   SBC.zpg ("index+0_0022");     // subtract MOD(block length/$100) byte
/* a3e0 */                   STA.zpg ("tempf1+1_0058");    // save modified new block end low byte
/* a3e2 */                   BCS.rel ("_a3ec");            // branch if no underflow
/* a3e4 */                   DEC.zpg ("tempf1+2_0059");    // else decrement block end high byte
/* a3e6 */                   BCC.rel ("_a3ec");            // branch always
/* a3e8 */        _`_a3e8`;  LDA.iny ("tempf1+3_005a");    // get byte from source
/* a3ea */                   STA.iny ("tempf1+1_0058");    // copy byte to destination
/* a3ec */        _`_a3ec`;  DEY.imp ();                   // decrement index
/* a3ed */                   BNE.rel ("_a3e8");            // loop until Y=0
                                                           // now do Y=0 indexed byte
/* a3ef */                   LDA.iny ("tempf1+3_005a");    // get byte from source
/* a3f1 */                   STA.iny ("tempf1+1_0058");    // save byte to destination
/* a3f3 */        _`_a3f3`;  DEC.zpg ("tempf1+4_005b");    // decrement source pointer high byte
/* a3f5 */                   DEC.zpg ("tempf1+2_0059");    // decrement destination pointer high byte
/* a3f7 */                   DEX.imp ();                   // decrement block count
/* a3f8 */                   BNE.rel ("_a3ec");            // loop until count = $0
/* a3fa */                   RTS.imp ();

// ------------------------------------------------------- // check room on stack for A bytes
                                                           // if stack too deep do out of memory error
/* a3fb */  _`getstk_a3fb`;  ASL.acc ();                   // *2
/* a3fc */                   ADC.imm (0x3e);               // need at least $3E bytes free
/* a3fe */                   BCS.rel ("omerr_a435");       // if overflow go do out of memory error then warm start
/* a400 */                   STA.zpg ("index+0_0022");     // save result in temp byte
/* a402 */                   TSX.imp ();                   // copy stack
/* a403 */                   CPX.zpg ("index+0_0022");     // compare new limit with stack
/* a405 */                   BCC.rel ("omerr_a435");       // if stack < limit do out of memory error then warm start
/* a407 */                   RTS.imp ();

// ------------------------------------------------------- // check available memory, do out of memory error if no room
/* a408 */  _`reason_a408`;  CPY.zpg ("fretop+1_0034");    // compare with bottom of string space high byte
/* a40a */                   BCC.rel ("_a434");            // if less then exit (is ok)
/* a40c */                   BNE.rel ("_a412");            // skip next test if greater (tested <)
                                                           // high byte was =, now do low byte
/* a40e */                   CMP.zpg ("fretop+0_0033");    // compare with bottom of string space low byte
/* a410 */                   BCC.rel ("_a434");            // if less then exit (is ok)
                                                           // address is > string storage ptr (oops!)
/* a412 */        _`_a412`;  PHA.imp ();                   // push address low byte
/* a413 */                   LDX.imm (0x09);               // set index to save $57 to $60 inclusive
/* a415 */                   TYA.imp ();                   // copy address high byte (to push on stack)
                                                           // save misc numeric work area
/* a416 */        _`_a416`;  PHA.imp ();                   // push byte
/* a417 */                   LDA.zpx (0x57);               // get byte from $57 to $60
/* a419 */                   DEX.imp ();                   // decrement index
/* a41a */                   BPL.rel ("_a416");            // loop until all done
/* a41c */                   JSR.abs ("garbag_b526");      // do garbage collection routine
                                                           // restore misc numeric work area
/* a41f */                   LDX.imm (0xf7);               // set index to restore bytes
/* a421 */        _`_a421`;  PLA.imp ();                   // pop byte
/* a422 */                   STA.zpx (0x61);               // save byte to $57 to $60
/* a424 */                   INX.imp ();                   // increment index
/* a425 */                   BMI.rel ("_a421");            // loop while -ve
/* a427 */                   PLA.imp ();                   // pop address high byte
/* a428 */                   TAY.imp ();                   // copy back to Y
/* a429 */                   PLA.imp ();                   // pop address low byte
/* a42a */                   CPY.zpg ("fretop+1_0034");    // compare with bottom of string space high byte
/* a42c */                   BCC.rel ("_a434");            // if less then exit (is ok)
/* a42e */                   BNE.rel ("omerr_a435");       // if greater do out of memory error then warm start
                                                           // high byte was =, now do low byte
/* a430 */                   CMP.zpg ("fretop+0_0033");    // compare with bottom of string space low byte
/* a432 */                   BCS.rel ("omerr_a435");       // if >= do out of memory error then warm start
                                                           // ok exit, carry clear
/* a434 */        _`_a434`;  RTS.imp ();

// ------------------------------------------------------- // do out of memory error then warm start
/* a435 */   _`omerr_a435`;  LDX.imm (0x10);               // error code $10, out of memory error
                                                           // do error #X then warm start
/* a437 */   _`error_a437`;  JMP.ind ("ierror+0_0300");    // do error message

// ------------------------------------------------------- // do error #X then warm start, the error message vector is initialised to point here
/* a43a */                   TXA.imp ();                   // copy error number
/* a43b */                   ASL.acc ();                   // *2
/* a43c */                   TAX.imp ();                   // copy to index
/* a43d */                   LDA.abx (0xa326);             // get error message pointer low byte
/* a440 */                   STA.zpg ("index+0_0022");     // save it
/* a442 */                   LDA.abx (0xa327);             // get error message pointer high byte
/* a445 */                   STA.zpg ("index+1_0023");     // save it
/* a447 */                   JSR.abs ("clrchn_ffcc");      // close input and output channels
/* a44a */                   LDA.imm (0x00);               // clear A
/* a44c */                   STA.zpg ("channl_0013");      // clear current I/O channel, flag default
/* a44e */                   JSR.abs ("crdo_aad7");        // print CR/LF
/* a451 */                   JSR.abs ("_ab45");            // print "?"
/* a454 */                   LDY.imm (0x00);               // clear index
/* a456 */        _`_a456`;  LDA.iny ("index+0_0022");     // get byte from message
/* a458 */                   PHA.imp ();                   // save status
/* a459 */                   AND.imm (0x7f);               // mask 0xxx xxxx, clear b7
/* a45b */                   JSR.abs ("_ab47");            // output character
/* a45e */                   INY.imp ();                   // increment index
/* a45f */                   PLA.imp ();                   // restore status
/* a460 */                   BPL.rel ("_a456");            // loop if character was not end marker
/* a462 */                   JSR.abs ("_a67a");            // flush BASIC stack and clear continue pointer
/* a465 */                   LDA.imm (0x69);               // set " ERROR" pointer low byte
/* a467 */                   LDY.imm (0xa3);               // set " ERROR" pointer high byte

// ------------------------------------------------------- // print string and do warm start, break entry
/* a469 */  _`errfin_a469`;  JSR.abs ("strout_ab1e");      // print null terminated string
/* a46c */                   LDY.zpg ("curlin+1_003a");    // get current line number high byte
/* a46e */                   INY.imp ();                   // increment it
/* a46f */                   BEQ.rel ("ready_a474");       // branch if was in immediate mode
/* a471 */                   JSR.abs ("inprt_bdc2");       // do " IN " line number message

// ------------------------------------------------------- // do warm start
/* a474 */   _`ready_a474`;  LDA.imm (0x76);               // set "READY." pointer low byte
/* a476 */                   LDY.imm (0xa3);               // set "READY." pointer high byte
/* a478 */                   JSR.abs ("strout_ab1e");      // print null terminated string
/* a47b */                   LDA.imm (0x80);               // set for control messages only
/* a47d */                   JSR.abs ("setmsg_ff90");      // control kernal messages
/* a480 */    _`main_a480`;  JMP.ind ("imain+0_0302");     // do BASIC warm start

// ------------------------------------------------------- // BASIC warm start, the warm start vector is initialised to point here
/* a483 */                   JSR.abs ("inlin_a560");       // call for BASIC input
/* a486 */                   STX.zpg ("txtptr+0_007a");    // save BASIC execute pointer low byte
/* a488 */                   STY.zpg ("txtptr+1_007b");    // save BASIC execute pointer high byte
/* a48a */                   JSR.abs ("chrget+0_0073");    // increment and scan memory
/* a48d */                   TAX.imp ();                   // copy byte to set flags
/* a48e */                   BEQ.rel ("main_a480");        // loop if no input
                                                           // got to interpret the input line now ....
/* a490 */                   LDX.imm (0xff);               // current line high byte to -1, indicates immediate mode
/* a492 */                   STX.zpg ("curlin+1_003a");    // set current line number high byte
/* a494 */                   BCC.rel ("main1_a49c");       // if numeric character go handle new BASIC line
                                                           // no line number .. immediate mode
/* a496 */                   JSR.abs ("crunch_a579");      // crunch keywords into BASIC tokens
/* a499 */                   JMP.abs ("_a7e1");            // go scan and interpret code

// ------------------------------------------------------- // handle new BASIC line
/* a49c */   _`main1_a49c`;  JSR.abs ("linget_a96b");      // get fixed-point number into temporary integer
/* a49f */                   JSR.abs ("crunch_a579");      // crunch keywords into BASIC tokens
/* a4a2 */  _`inslin_a4a2`;  STY.zpg ("count_000b");       // save index pointer to end of crunched line
/* a4a4 */                   JSR.abs ("fndlin_a613");      // search BASIC for temporary integer line number
/* a4a7 */                   BCC.rel ("_a4ed");            // if not found skip the line delete
                                                           // line # already exists so delete it
/* a4a9 */                   LDY.imm (0x01);               // set index to next line pointer high byte
/* a4ab */                   LDA.iny ("tempf2+3_005f");    // get next line pointer high byte
/* a4ad */                   STA.zpg ("index+1_0023");     // save it
/* a4af */                   LDA.zpg ("vartab+0_002d");    // get start of variables low byte
/* a4b1 */                   STA.zpg ("index+0_0022");     // save it
/* a4b3 */                   LDA.zpg ("tempf2+4_0060");    // get found line pointer high byte
/* a4b5 */                   STA.zpg ("index+3_0025");     // save it
/* a4b7 */                   LDA.zpg ("tempf2+3_005f");    // get found line pointer low byte
/* a4b9 */                   DEY.imp ();                   // decrement index
/* a4ba */                   SBC.iny ("tempf2+3_005f");    // subtract next line pointer low byte
/* a4bc */                   CLC.imp ();                   // clear carry for add
/* a4bd */                   ADC.zpg ("vartab+0_002d");    // add start of variables low byte
/* a4bf */                   STA.zpg ("vartab+0_002d");    // set start of variables low byte
/* a4c1 */                   STA.zpg ("index+2_0024");     // save destination pointer low byte
/* a4c3 */                   LDA.zpg ("vartab+1_002e");    // get start of variables high byte
/* a4c5 */                   ADC.imm (0xff);               // -1 + carry
/* a4c7 */                   STA.zpg ("vartab+1_002e");    // set start of variables high byte
/* a4c9 */                   SBC.zpg ("tempf2+4_0060");    // subtract found line pointer high byte
/* a4cb */                   TAX.imp ();                   // copy to block count
/* a4cc */                   SEC.imp ();                   // set carry for subtract
/* a4cd */                   LDA.zpg ("tempf2+3_005f");    // get found line pointer low byte
/* a4cf */                   SBC.zpg ("vartab+0_002d");    // subtract start of variables low byte
/* a4d1 */                   TAY.imp ();                   // copy to bytes in first block count
/* a4d2 */                   BCS.rel ("_a4d7");            // branch if no underflow
/* a4d4 */                   INX.imp ();                   // increment block count, correct for = 0 loop exit
/* a4d5 */                   DEC.zpg ("index+3_0025");     // decrement destination high byte
/* a4d7 */        _`_a4d7`;  CLC.imp ();                   // clear carry for add
/* a4d8 */                   ADC.zpg ("index+0_0022");     // add source pointer low byte
/* a4da */                   BCC.rel ("_a4df");            // branch if no overflow
/* a4dc */                   DEC.zpg ("index+1_0023");     // else decrement source pointer high byte
/* a4de */                   CLC.imp ();                   // clear carry
                                                           // close up memory to delete old line
/* a4df */        _`_a4df`;  LDA.iny ("index+0_0022");     // get byte from source
/* a4e1 */                   STA.iny ("index+2_0024");     // copy to destination
/* a4e3 */                   INY.imp ();                   // increment index
/* a4e4 */                   BNE.rel ("_a4df");            // while <> 0 do this block
/* a4e6 */                   INC.zpg ("index+1_0023");     // increment source pointer high byte
/* a4e8 */                   INC.zpg ("index+3_0025");     // increment destination pointer high byte
/* a4ea */                   DEX.imp ();                   // decrement block count
/* a4eb */                   BNE.rel ("_a4df");            // loop until all done
                                                           // got new line in buffer and no existing same #
/* a4ed */        _`_a4ed`;  JSR.abs ("_a659");            // reset execution to start, clear variables, flush stack
                                                           // and return
/* a4f0 */                   JSR.abs ("linkprg_a533");     // rebuild BASIC line chaining
/* a4f3 */                   LDA.abs ("buf+0_0200");       // get first byte from buffer
/* a4f6 */                   BEQ.rel ("main_a480");        // if no line go do BASIC warm start
                                                           // else insert line into memory
/* a4f8 */                   CLC.imp ();                   // clear carry for add
/* a4f9 */                   LDA.zpg ("vartab+0_002d");    // get start of variables low byte
/* a4fb */                   STA.zpg ("tempf1+3_005a");    // save as source end pointer low byte
/* a4fd */                   ADC.zpg ("count_000b");       // add index pointer to end of crunched line
/* a4ff */                   STA.zpg ("tempf1+1_0058");    // save as destination end pointer low byte
/* a501 */                   LDY.zpg ("vartab+1_002e");    // get start of variables high byte
/* a503 */                   STY.zpg ("tempf1+4_005b");    // save as source end pointer high byte
/* a505 */                   BCC.rel ("_a508");            // branch if no carry to high byte
/* a507 */                   INY.imp ();                   // else increment high byte
/* a508 */        _`_a508`;  STY.zpg ("tempf1+2_0059");    // save as destination end pointer high byte
/* a50a */                   JSR.abs ("bltu_a3b8");        // open up space in memory
                                                           // most of what remains to do is copy the crunched line into the space opened up in memory,
                                                           // however, before the crunched line comes the next line pointer and the line number. the
                                                           // line number is retrieved from the temporary integer and stored in memory, this
                                                           // overwrites the bottom two bytes on the stack. next the line is copied and the next line
                                                           // pointer is filled with whatever was in two bytes above the line number in the stack.
                                                           // this is ok because the line pointer gets fixed in the line chain re-build.
/* a50d */                   LDA.zpg ("linnum+0_0014");    // get line number low byte
/* a50f */                   LDY.zpg ("linnum+1_0015");    // get line number high byte
/* a511 */                   STA.abs ("bstack+191_01fe");  // save line number low byte before crunched line
/* a514 */                   STY.abs ("bstack+192_01ff");  // save line number high byte before crunched line
/* a517 */                   LDA.zpg ("strend+0_0031");    // get end of arrays low byte
/* a519 */                   LDY.zpg ("strend+1_0032");    // get end of arrays high byte
/* a51b */                   STA.zpg ("vartab+0_002d");    // set start of variables low byte
/* a51d */                   STY.zpg ("vartab+1_002e");    // set start of variables high byte
/* a51f */                   LDY.zpg ("count_000b");       // get index to end of crunched line
/* a521 */                   DEY.imp ();                   // -1
/* a522 */        _`_a522`;  LDA.aby ("bstack+189_01fc");  // get byte from crunched line
/* a525 */                   STA.iny ("tempf2+3_005f");    // save byte to memory
/* a527 */                   DEY.imp ();                   // decrement index
/* a528 */                   BPL.rel ("_a522");            // loop while more to do
                                                           // reset execution, clear variables, flush stack, rebuild BASIC chain and do warm start
/* a52a */                   JSR.abs ("_a659");            // reset execution to start, clear variables and flush stack
/* a52d */                   JSR.abs ("linkprg_a533");     // rebuild BASIC line chaining
/* a530 */                   JMP.abs ("main_a480");        // go do BASIC warm start

// ------------------------------------------------------- // rebuild BASIC line chaining
/* a533 */ _`linkprg_a533`;  LDA.zpg ("txttab+0_002b");    // get start of memory low byte
/* a535 */                   LDY.zpg ("txttab+1_002c");    // get start of memory high byte
/* a537 */                   STA.zpg ("index+0_0022");     // set line start pointer low byte
/* a539 */                   STY.zpg ("index+1_0023");     // set line start pointer high byte
/* a53b */                   CLC.imp ();                   // clear carry for add
/* a53c */        _`_a53c`;  LDY.imm (0x01);               // set index to pointer to next line high byte
/* a53e */                   LDA.iny ("index+0_0022");     // get pointer to next line high byte
/* a540 */                   BEQ.rel ("_a55f");            // exit if null, [EOT]
/* a542 */                   LDY.imm (0x04);               // point to first code byte of line
                                                           // there is always 1 byte + [EOL] as null entries are deleted
/* a544 */        _`_a544`;  INY.imp ();                   // next code byte
/* a545 */                   LDA.iny ("index+0_0022");     // get byte
/* a547 */                   BNE.rel ("_a544");            // loop if not [EOL]
/* a549 */                   INY.imp ();                   // point to byte past [EOL], start of next line
/* a54a */                   TYA.imp ();                   // copy it
/* a54b */                   ADC.zpg ("index+0_0022");     // add line start pointer low byte
/* a54d */                   TAX.imp ();                   // copy to X
/* a54e */                   LDY.imm (0x00);               // clear index, point to this line's next line pointer
/* a550 */                   STA.iny ("index+0_0022");     // set next line pointer low byte
/* a552 */                   LDA.zpg ("index+1_0023");     // get line start pointer high byte
/* a554 */                   ADC.imm (0x00);               // add any overflow
/* a556 */                   INY.imp ();                   // increment index to high byte
/* a557 */                   STA.iny ("index+0_0022");     // set next line pointer high byte
/* a559 */                   STX.zpg ("index+0_0022");     // set line start pointer low byte
/* a55b */                   STA.zpg ("index+1_0023");     // set line start pointer high byte
/* a55d */                   BCC.rel ("_a53c");            // go do next line, branch always
/* a55f */        _`_a55f`;  RTS.imp ();
                                                           // call for BASIC input
/* a560 */   _`inlin_a560`;  LDX.imm (0x00);               // set channel $00, keyboard
/* a562 */        _`_a562`;  JSR.abs ("bchin_e112");       // input character from channel with error check
/* a565 */                   CMP.imm (0x0d);               // compare with [CR]
/* a567 */                   BEQ.rel ("_a576");            // if [CR] set XY to $200 - 1, print [CR] and exit
                                                           // character was not [CR]
/* a569 */                   STA.abx ("buf+0_0200");       // save character to buffer
/* a56c */                   INX.imp ();                   // increment buffer index
/* a56d */                   CPX.imm (0x59);               // compare with max+1
/* a56f */                   BCC.rel ("_a562");            // branch if < max+1
/* a571 */                   LDX.imm (0x17);               // error $17, string too long error
/* a573 */                   JMP.abs ("error_a437");       // do error #X then warm start
/* a576 */        _`_a576`;  JMP.abs ("_aaca");            // set XY to $200 - 1 and print [CR]

// ------------------------------------------------------- // crunch BASIC tokens vector
/* a579 */  _`crunch_a579`;  JMP.ind ("icrnch+0_0304");    // do crunch BASIC tokens

// ------------------------------------------------------- // crunch BASIC tokens, the crunch BASIC tokens vector is initialised to point here
/* a57c */                   LDX.zpg ("txtptr+0_007a");    // get BASIC execute pointer low byte
/* a57e */                   LDY.imm (0x04);               // set save index
/* a580 */                   STY.zpg ("garbfl_000f");      // clear open quote/DATA flag
/* a582 */        _`_a582`;  LDA.abx ("buf+0_0200");       // get a byte from the input buffer
/* a585 */                   BPL.rel ("_a58e");            // if b7 clear go do crunching
/* a587 */                   CMP.imm (0xff);               // compare with the token for PI, this toke is input
                                                           // directly from the keyboard as the PI character
/* a589 */                   BEQ.rel ("_a5c9");            // if PI save byte then continue crunching
                                                           // this is the bit of code that stops you being able to enter
                                                           // some keywords as just single shifted characters. If this
                                                           // dropped through you would be able to enter GOTO as just
                                                           // [SHIFT]G
/* a58b */                   INX.imp ();                   // increment read index
/* a58c */                   BNE.rel ("_a582");            // loop if more to do, branch always
/* a58e */        _`_a58e`;  CMP.imm (0x20);               // compare with [SPACE]
/* a590 */                   BEQ.rel ("_a5c9");            // if [SPACE] save byte then continue crunching
/* a592 */                   STA.zpg ("endchr_0008");      // save buffer byte as search character
/* a594 */                   CMP.imm (0x22);               // compare with quote character
/* a596 */                   BEQ.rel ("_a5ee");            // if quote go copy quoted string
/* a598 */                   BIT.zpg ("garbfl_000f");      // get open quote/DATA token flag
/* a59a */                   BVS.rel ("_a5c9");            // branch if b6 of Oquote set, was DATA
                                                           // go save byte then continue crunching
/* a59c */                   CMP.imm (0x3f);               // compare with "?" character
/* a59e */                   BNE.rel ("_a5a4");            // if not "?" continue crunching
/* a5a0 */                   LDA.imm (0x99);               // else the keyword token is $99, PRINT
/* a5a2 */                   BNE.rel ("_a5c9");            // go save byte then continue crunching, branch always
/* a5a4 */        _`_a5a4`;  CMP.imm (0x30);               // compare with "0"
/* a5a6 */                   BCC.rel ("_a5ac");            // branch if <, continue crunching
/* a5a8 */                   CMP.imm (0x3c);               // compare with "<"
/* a5aa */                   BCC.rel ("_a5c9");            // if <, 0123456789:; go save byte then continue crunching
                                                           // gets here with next character not numeric, ";" or ":"
/* a5ac */        _`_a5ac`;  STY.zpg ("fbufpt+0_0071");    // copy save index
/* a5ae */                   LDY.imm (0x00);               // clear table pointer
/* a5b0 */                   STY.zpg ("count_000b");       // clear word index
/* a5b2 */                   DEY.imp ();                   // adjust for pre increment loop
/* a5b3 */                   STX.zpg ("txtptr+0_007a");    // save BASIC execute pointer low byte, buffer index
/* a5b5 */                   DEX.imp ();                   // adjust for pre increment loop
/* a5b6 */        _`_a5b6`;  INY.imp ();                   // next table byte
/* a5b7 */                   INX.imp ();                   // next buffer byte
/* a5b8 */        _`_a5b8`;  LDA.abx ("buf+0_0200");       // get byte from input buffer
/* a5bb */                   SEC.imp ();                   // set carry for subtract
/* a5bc */                   SBC.aby ("reslst_a09e");      // subtract table byte
/* a5bf */                   BEQ.rel ("_a5b6");            // go compare next if match
/* a5c1 */                   CMP.imm (0x80);               // was it end marker match ?
/* a5c3 */                   BNE.rel ("_a5f5");            // branch if not, not found keyword
                                                           // actually this works even if the input buffer byte is the
                                                           // end marker, i.e. a shifted character. As you can't enter
                                                           // any keywords as a single shifted character, see above,
                                                           // you can enter keywords in shorthand by shifting any
                                                           // character after the first. so RETURN can be entered as
                                                           // R[SHIFT]E, RE[SHIFT]T, RET[SHIFT]U or RETU[SHIFT]R.
                                                           // RETUR[SHIFT]N however will not work because the [SHIFT]N
                                                           // will match the RETURN end marker so the routine will try
                                                           // to match the next character.
                                                           // else found keyword
/* a5c5 */                   ORA.zpg ("count_000b");       // OR with word index, +$80 in A makes token
/* a5c7 */        _`_a5c7`;  LDY.zpg ("fbufpt+0_0071");    // restore save index
                                                           // save byte then continue crunching
/* a5c9 */        _`_a5c9`;  INX.imp ();                   // increment buffer read index
/* a5ca */                   INY.imp ();                   // increment save index
/* a5cb */                   STA.aby ("bstack+188_01fb");  // save byte to output
/* a5ce */                   LDA.aby ("bstack+188_01fb");  // get byte from output, set flags
/* a5d1 */                   BEQ.rel ("_a609");            // branch if was null [EOL]
                                                           // A holds the token here
/* a5d3 */                   SEC.imp ();                   // set carry for subtract
/* a5d4 */                   SBC.imm (0x3a);               // subtract ":"
/* a5d6 */                   BEQ.rel ("_a5dc");            // branch if it was (is now $00)
                                                           // A now holds token-':'
/* a5d8 */                   CMP.imm (0x49);               // compare with the token for DATA-':'
/* a5da */                   BNE.rel ("_a5de");            // if not DATA go try REM
                                                           // token was : or DATA
/* a5dc */        _`_a5dc`;  STA.zpg ("garbfl_000f");      // save the token-$3A
/* a5de */        _`_a5de`;  SEC.imp ();                   // set carry for subtract
/* a5df */                   SBC.imm (0x55);               // subtract the token for REM-':'
/* a5e1 */                   BNE.rel ("_a582");            // if wasn't REM crunch next bit of line
/* a5e3 */                   STA.zpg ("endchr_0008");      // else was REM so set search for [EOL]
                                                           // loop for "..." etc.
/* a5e5 */        _`_a5e5`;  LDA.abx ("buf+0_0200");       // get byte from input buffer
/* a5e8 */                   BEQ.rel ("_a5c9");            // if null [EOL] save byte then continue crunching
/* a5ea */                   CMP.zpg ("endchr_0008");      // compare with stored character
/* a5ec */                   BEQ.rel ("_a5c9");            // if match save byte then continue crunching
/* a5ee */        _`_a5ee`;  INY.imp ();                   // increment save index
/* a5ef */                   STA.aby ("bstack+188_01fb");  // save byte to output
/* a5f2 */                   INX.imp ();                   // increment buffer index
/* a5f3 */                   BNE.rel ("_a5e5");            // loop while <> 0, should never reach 0
                                                           // not found keyword this go
/* a5f5 */        _`_a5f5`;  LDX.zpg ("txtptr+0_007a");    // restore BASIC execute pointer low byte
/* a5f7 */                   INC.zpg ("count_000b");       // increment word index (next word)
                                                           // now find end of this word in the table
/* a5f9 */        _`_a5f9`;  INY.imp ();                   // increment table index
/* a5fa */                   LDA.aby (0xa09d);             // get table byte
/* a5fd */                   BPL.rel ("_a5f9");            // loop if not end of word yet
/* a5ff */                   LDA.aby ("reslst_a09e");      // get byte from keyword table
/* a602 */                   BNE.rel ("_a5b8");            // go test next word if not zero byte, end of table
                                                           // reached end of table with no match
/* a604 */                   LDA.abx ("buf+0_0200");       // restore byte from input buffer
/* a607 */                   BPL.rel ("_a5c7");            // branch always, all unmatched bytes in the buffer are
                                                           // $00 to $7F, go save byte in output and continue crunching
                                                           // reached [EOL]
/* a609 */        _`_a609`;  STA.aby ("bstack+190_01fd");  // save [EOL]
/* a60c */                   DEC.zpg ("txtptr+1_007b");    // decrement BASIC execute pointer high byte
/* a60e */                   LDA.imm (0xff);               // point to start of buffer-1
/* a610 */                   STA.zpg ("txtptr+0_007a");    // set BASIC execute pointer low byte
/* a612 */                   RTS.imp ();

// ------------------------------------------------------- // search BASIC for temporary integer line number
/* a613 */  _`fndlin_a613`;  LDA.zpg ("txttab+0_002b");    // get start of memory low byte
/* a615 */                   LDX.zpg ("txttab+1_002c");    // get start of memory high byte

// ------------------------------------------------------- // search Basic for temp integer line number from AX
                                                           // returns carry set if found
/* a617 */        _`_a617`;  LDY.imm (0x01);               // set index to next line pointer high byte
/* a619 */                   STA.zpg ("tempf2+3_005f");    // save low byte as current
/* a61b */                   STX.zpg ("tempf2+4_0060");    // save high byte as current
/* a61d */                   LDA.iny ("tempf2+3_005f");    // get next line pointer high byte from address
/* a61f */                   BEQ.rel ("_a640");            // pointer was zero so done, exit
/* a621 */                   INY.imp ();                   // increment index ...
/* a622 */                   INY.imp ();                   // ... to line # high byte
/* a623 */                   LDA.zpg ("linnum+1_0015");    // get temporary integer high byte
/* a625 */                   CMP.iny ("tempf2+3_005f");    // compare with line # high byte
/* a627 */                   BCC.rel ("_a641");            // exit if temp < this line, target line passed
/* a629 */                   BEQ.rel ("_a62e");            // go check low byte if =
/* a62b */                   DEY.imp ();                   // else decrement index
/* a62c */                   BNE.rel ("_a637");            // branch always
/* a62e */        _`_a62e`;  LDA.zpg ("linnum+0_0014");    // get temporary integer low byte
/* a630 */                   DEY.imp ();                   // decrement index to line # low byte
/* a631 */                   CMP.iny ("tempf2+3_005f");    // compare with line # low byte
/* a633 */                   BCC.rel ("_a641");            // exit if temp < this line, target line passed
/* a635 */                   BEQ.rel ("_a641");            // exit if temp = (found line#)
                                                           // not quite there yet
/* a637 */        _`_a637`;  DEY.imp ();                   // decrement index to next line pointer high byte
/* a638 */                   LDA.iny ("tempf2+3_005f");    // get next line pointer high byte
/* a63a */                   TAX.imp ();                   // copy to X
/* a63b */                   DEY.imp ();                   // decrement index to next line pointer low byte
/* a63c */                   LDA.iny ("tempf2+3_005f");    // get next line pointer low byte
/* a63e */                   BCS.rel ("_a617");            // go search for line # in temporary integer
                                                           // from AX, carry always set
/* a640 */        _`_a640`;  CLC.imp ();                   // clear found flag
/* a641 */        _`_a641`;  RTS.imp ();

// ------------------------------------------------------- // perform NEW
/* a642 */  _`scrtch_a642`;  BNE.rel ("_a641");            // exit if following byte to allow syntax error
/* a644 */                   LDA.imm (0x00);               // clear A
/* a646 */                   TAY.imp ();                   // clear index
/* a647 */                   STA.iny ("txttab+0_002b");    // clear pointer to next line low byte
/* a649 */                   INY.imp ();                   // increment index
/* a64a */                   STA.iny ("txttab+0_002b");    // clear pointer to next line high byte, erase program
/* a64c */                   LDA.zpg ("txttab+0_002b");    // get start of memory low byte
/* a64e */                   CLC.imp ();                   // clear carry for add
/* a64f */                   ADC.imm (0x02);               // add null program length
/* a651 */                   STA.zpg ("vartab+0_002d");    // set start of variables low byte
/* a653 */                   LDA.zpg ("txttab+1_002c");    // get start of memory high byte
/* a655 */                   ADC.imm (0x00);               // add carry
/* a657 */                   STA.zpg ("vartab+1_002e");    // set start of variables high byte

// ------------------------------------------------------- // reset execute pointer and do CLR
/* a659 */        _`_a659`;  JSR.abs ("stxpt_a68e");       // set BASIC execute pointer to start of memory - 1
/* a65c */                   LDA.imm (0x00);               // set Zb for CLR entry

// ------------------------------------------------------- // perform CLR
/* a65e */   _`clear_a65e`;  BNE.rel ("_a68d");            // exit if following byte to allow syntax error
/* a660 */        _`_a660`;  JSR.abs ("clall_ffe7");       // close all channels and files
/* a663 */                   LDA.zpg ("memsiz+0_0037");    // get end of memory low byte
/* a665 */                   LDY.zpg ("memsiz+1_0038");    // get end of memory high byte
/* a667 */                   STA.zpg ("fretop+0_0033");    // set bottom of string space low byte, clear strings
/* a669 */                   STY.zpg ("fretop+1_0034");    // set bottom of string space high byte
/* a66b */                   LDA.zpg ("vartab+0_002d");    // get start of variables low byte
/* a66d */                   LDY.zpg ("vartab+1_002e");    // get start of variables high byte
/* a66f */                   STA.zpg ("arytab+0_002f");    // set end of variables low byte, clear variables
/* a671 */                   STY.zpg ("arytab+1_0030");    // set end of variables high byte
/* a673 */                   STA.zpg ("strend+0_0031");    // set end of arrays low byte, clear arrays
/* a675 */                   STY.zpg ("strend+1_0032");    // set end of arrays high byte

// ------------------------------------------------------- // do RESTORE and clear stack
/* a677 */                   JSR.abs ("restor_a81d");      // perform RESTORE

// ------------------------------------------------------- // flush BASIC stack and clear the continue pointer
/* a67a */        _`_a67a`;  LDX.imm (0x19);               // get the descriptor stack start
/* a67c */                   STX.zpg ("temppt_0016");      // set the descriptor stack pointer
/* a67e */                   PLA.imp ();                   // pull the return address low byte
/* a67f */                   TAY.imp ();                   // copy it
/* a680 */                   PLA.imp ();                   // pull the return address high byte
/* a681 */                   LDX.imm (0xfa);               // set the cleared stack pointer
/* a683 */                   TXS.imp ();                   // set the stack
/* a684 */                   PHA.imp ();                   // push the return address high byte
/* a685 */                   TYA.imp ();                   // restore the return address low byte
/* a686 */                   PHA.imp ();                   // push the return address low byte
/* a687 */                   LDA.imm (0x00);               // clear A
/* a689 */                   STA.zpg ("oldtxt+1_003e");    // clear the continue pointer high byte
/* a68b */                   STA.zpg ("subflg_0010");      // clear the subscript/FNX flag
/* a68d */        _`_a68d`;  RTS.imp ();

// ------------------------------------------------------- // set BASIC execute pointer to start of memory - 1
/* a68e */   _`stxpt_a68e`;  CLC.imp ();                   // clear carry for add
/* a68f */                   LDA.zpg ("txttab+0_002b");    // get start of memory low byte
/* a691 */                   ADC.imm (0xff);               // add -1 low byte
/* a693 */                   STA.zpg ("txtptr+0_007a");    // set BASIC execute pointer low byte
/* a695 */                   LDA.zpg ("txttab+1_002c");    // get start of memory high byte
/* a697 */                   ADC.imm (0xff);               // add -1 high byte
/* a699 */                   STA.zpg ("txtptr+1_007b");    // save BASIC execute pointer high byte
/* a69b */                   RTS.imp ();

// ------------------------------------------------------- // perform LIST
/* a69c */    _`list_a69c`;  BCC.rel ("_a6a4");            // branch if next character not token (LIST n...)
/* a69e */                   BEQ.rel ("_a6a4");            // branch if next character [NULL] (LIST)
/* a6a0 */                   CMP.imm (0xab);               // compare with token for -
/* a6a2 */                   BNE.rel ("_a68d");            // exit if not - (LIST -m)
                                                           // LIST [[n][-m]]
                                                           // this bit sets the n , if present, as the start and end
/* a6a4 */        _`_a6a4`;  JSR.abs ("linget_a96b");      // get fixed-point number into temporary integer
/* a6a7 */                   JSR.abs ("fndlin_a613");      // search BASIC for temporary integer line number
/* a6aa */                   JSR.abs ("chrgot_0079");      // scan memory
/* a6ad */                   BEQ.rel ("_a6bb");            // branch if no more chrs
                                                           // this bit checks the - is present
/* a6af */                   CMP.imm (0xab);               // compare with token for -
/* a6b1 */                   BNE.rel ("_a641");            // return if not "-" (will be SN error)
                                                           // LIST [n]-m
                                                           // the - was there so set m as the end value
/* a6b3 */                   JSR.abs ("chrget+0_0073");    // increment and scan memory
/* a6b6 */                   JSR.abs ("linget_a96b");      // get fixed-point number into temporary integer
/* a6b9 */                   BNE.rel ("_a641");            // exit if not ok
/* a6bb */        _`_a6bb`;  PLA.imp ();                   // dump return address low byte, exit via warm start
/* a6bc */                   PLA.imp ();                   // dump return address high byte
/* a6bd */                   LDA.zpg ("linnum+0_0014");    // get temporary integer low byte
/* a6bf */                   ORA.zpg ("linnum+1_0015");    // OR temporary integer high byte
/* a6c1 */                   BNE.rel ("_a6c9");            // branch if start set
/* a6c3 */                   LDA.imm (0xff);               // set for -1
/* a6c5 */                   STA.zpg ("linnum+0_0014");    // set temporary integer low byte
/* a6c7 */                   STA.zpg ("linnum+1_0015");    // set temporary integer high byte
/* a6c9 */        _`_a6c9`;  LDY.imm (0x01);               // set index for line
/* a6cb */                   STY.zpg ("garbfl_000f");      // clear open quote flag
/* a6cd */                   LDA.iny ("tempf2+3_005f");    // get next line pointer high byte
/* a6cf */                   BEQ.rel ("_a714");            // if null all done so exit
/* a6d1 */                   JSR.abs ("stop_a82c");        // do CRTL-C check vector
/* a6d4 */                   JSR.abs ("crdo_aad7");        // print CR/LF
/* a6d7 */                   INY.imp ();                   // increment index for line
/* a6d8 */                   LDA.iny ("tempf2+3_005f");    // get line number low byte
/* a6da */                   TAX.imp ();                   // copy to X
/* a6db */                   INY.imp ();                   // increment index
/* a6dc */                   LDA.iny ("tempf2+3_005f");    // get line number high byte
/* a6de */                   CMP.zpg ("linnum+1_0015");    // compare with temporary integer high byte
/* a6e0 */                   BNE.rel ("_a6e6");            // branch if no high byte match
/* a6e2 */                   CPX.zpg ("linnum+0_0014");    // compare with temporary integer low byte
/* a6e4 */                   BEQ.rel ("_a6e8");            // branch if = last line to do, < will pass next branch
                                                           // else
/* a6e6 */        _`_a6e6`;  BCS.rel ("_a714");            // if greater all done so exit
/* a6e8 */        _`_a6e8`;  STY.zpg ("forpnt+0_0049");    // save index for line
/* a6ea */                   JSR.abs ("linprt_bdcd");      // print XA as unsigned integer
/* a6ed */                   LDA.imm (0x20);               // space is the next character
/* a6ef */        _`_a6ef`;  LDY.zpg ("forpnt+0_0049");    // get index for line
/* a6f1 */                   AND.imm (0x7f);               // mask top out bit of character
/* a6f3 */        _`_a6f3`;  JSR.abs ("_ab47");            // go print the character
/* a6f6 */                   CMP.imm (0x22);               // was it " character
/* a6f8 */                   BNE.rel ("_a700");            // if not skip the quote handle
                                                           // we are either entering or leaving a pair of quotes
/* a6fa */                   LDA.zpg ("garbfl_000f");      // get open quote flag
/* a6fc */                   EOR.imm (0xff);               // toggle it
/* a6fe */                   STA.zpg ("garbfl_000f");      // save it back
/* a700 */        _`_a700`;  INY.imp ();                   // increment index
/* a701 */                   BEQ.rel ("_a714");            // line too long so just bail out and do a warm start
/* a703 */                   LDA.iny ("tempf2+3_005f");    // get next byte
/* a705 */                   BNE.rel ("qplop_a717");       // if not [EOL] (go print character)
                                                           // was [EOL]
/* a707 */                   TAY.imp ();                   // else clear index
/* a708 */                   LDA.iny ("tempf2+3_005f");    // get next line pointer low byte
/* a70a */                   TAX.imp ();                   // copy to X
/* a70b */                   INY.imp ();                   // increment index
/* a70c */                   LDA.iny ("tempf2+3_005f");    // get next line pointer high byte
/* a70e */                   STX.zpg ("tempf2+3_005f");    // set pointer to line low byte
/* a710 */                   STA.zpg ("tempf2+4_0060");    // set pointer to line high byte
/* a712 */                   BNE.rel ("_a6c9");            // go do next line if not [EOT]
                                                           // else ...
/* a714 */        _`_a714`;  JMP.abs ("_e386");            // do warm start
/* a717 */   _`qplop_a717`;  JMP.ind ("iqplop+0_0306");    // do uncrunch BASIC tokens

// ------------------------------------------------------- // uncrunch BASIC tokens, the uncrunch BASIC tokens vector is initialised to point here
/* a71a */                   BPL.rel ("_a6f3");            // just go print it if not token byte
                                                           // else was token byte so uncrunch it
/* a71c */                   CMP.imm (0xff);               // compare with the token for PI. in this case the token
                                                           // is the same as the PI character so it just needs printing
/* a71e */                   BEQ.rel ("_a6f3");            // just print it if so
/* a720 */                   BIT.zpg ("garbfl_000f");      // test the open quote flag
/* a722 */                   BMI.rel ("_a6f3");            // just go print character if open quote set
/* a724 */                   SEC.imp ();                   // else set carry for subtract
/* a725 */                   SBC.imm (0x7f);               // reduce token range to 1 to whatever
/* a727 */                   TAX.imp ();                   // copy token # to X
/* a728 */                   STY.zpg ("forpnt+0_0049");    // save index for line
/* a72a */                   LDY.imm (0xff);               // start from -1, adjust for pre increment
/* a72c */        _`_a72c`;  DEX.imp ();                   // decrement token #
/* a72d */                   BEQ.rel ("_a737");            // if now found go do printing
/* a72f */        _`_a72f`;  INY.imp ();                   // else increment index
/* a730 */                   LDA.aby ("reslst_a09e");      // get byte from keyword table
/* a733 */                   BPL.rel ("_a72f");            // loop until keyword end marker
/* a735 */                   BMI.rel ("_a72c");            // go test if this is required keyword, branch always
                                                           // found keyword, it's the next one
/* a737 */        _`_a737`;  INY.imp ();                   // increment keyword table index
/* a738 */                   LDA.aby ("reslst_a09e");      // get byte from table
/* a73b */                   BMI.rel ("_a6ef");            // go restore index, mask byte and print if
                                                           // byte was end marker
/* a73d */                   JSR.abs ("_ab47");            // else go print the character
/* a740 */                   BNE.rel ("_a737");            // go get next character, branch always

// ------------------------------------------------------- // perform FOR
/* a742 */     _`for_a742`;  LDA.imm (0x80);               // set FNX
/* a744 */                   STA.zpg ("subflg_0010");      // set subscript/FNX flag
/* a746 */                   JSR.abs ("let_a9a5");         // perform LET
/* a749 */                   JSR.abs ("fndfor_a38a");      // search the stack for FOR or GOSUB activity
/* a74c */                   BNE.rel ("_a753");            // branch if FOR, this variable, not found
                                                           // FOR, this variable, was found so first we dump the old one
/* a74e */                   TXA.imp ();                   // copy index
/* a74f */                   ADC.imm (0x0f);               // add FOR structure size-2
/* a751 */                   TAX.imp ();                   // copy to index
/* a752 */                   TXS.imp ();                   // set stack (dump FOR structure (-2 bytes))
/* a753 */        _`_a753`;  PLA.imp ();                   // pull return address
/* a754 */                   PLA.imp ();                   // pull return address
/* a755 */                   LDA.imm (0x09);               // we need 18d bytes !
/* a757 */                   JSR.abs ("getstk_a3fb");      // check room on stack for 2*A bytes
/* a75a */                   JSR.abs ("datan_a906");       // scan for next BASIC statement ([:] or [EOL])
/* a75d */                   CLC.imp ();                   // clear carry for add
/* a75e */                   TYA.imp ();                   // copy index to A
/* a75f */                   ADC.zpg ("txtptr+0_007a");    // add BASIC execute pointer low byte
/* a761 */                   PHA.imp ();                   // push onto stack
/* a762 */                   LDA.zpg ("txtptr+1_007b");    // get BASIC execute pointer high byte
/* a764 */                   ADC.imm (0x00);               // add carry
/* a766 */                   PHA.imp ();                   // push onto stack
/* a767 */                   LDA.zpg ("curlin+1_003a");    // get current line number high byte
/* a769 */                   PHA.imp ();                   // push onto stack
/* a76a */                   LDA.zpg ("curlin+0_0039");    // get current line number low byte
/* a76c */                   PHA.imp ();                   // push onto stack
/* a76d */                   LDA.imm (0xa4);               // set "TO" token
/* a76f */                   JSR.abs ("chkcom_aeff");      // scan for CHR$(A), else do syntax error then warm start
/* a772 */                   JSR.abs ("_ad8d");            // check if source is numeric, else do type mismatch
/* a775 */                   JSR.abs ("frmnum_ad8a");      // evaluate expression and check is numeric, else do
                                                           // type mismatch
/* a778 */                   LDA.zpg ("facsgn_0066");      // get FAC1 sign (b7)
/* a77a */                   ORA.imm (0x7f);               // set all non sign bits
/* a77c */                   AND.zpg ("facho+0_0062");     // and FAC1 mantissa 1
/* a77e */                   STA.zpg ("facho+0_0062");     // save FAC1 mantissa 1
/* a780 */                   LDA.imm (0x8b);               // set return address low byte
/* a782 */                   LDY.imm (0xa7);               // set return address high byte
/* a784 */                   STA.zpg ("index+0_0022");     // save return address low byte
/* a786 */                   STY.zpg ("index+1_0023");     // save return address high byte
/* a788 */                   JMP.abs ("_ae43");            // round FAC1 and put on stack, returns to next instruction
/* a78b */                   LDA.imm (0xbc);               // set 1 pointer low address, default step size
/* a78d */                   LDY.imm (0xb9);               // set 1 pointer high address
/* a78f */                   JSR.abs ("movfm_bba2");       // unpack memory (AY) into FAC1
/* a792 */                   JSR.abs ("chrgot_0079");      // scan memory
/* a795 */                   CMP.imm (0xa9);               // compare with STEP token
/* a797 */                   BNE.rel ("_a79f");            // if not "STEP" continue
                                                           // was step so ....
/* a799 */                   JSR.abs ("chrget+0_0073");    // increment and scan memory
/* a79c */                   JSR.abs ("frmnum_ad8a");      // evaluate expression and check is numeric, else do
                                                           // type mismatch
/* a79f */        _`_a79f`;  JSR.abs ("sign_bc2b");        // get FAC1 sign, return A = $FF -ve, A = $01 +ve
/* a7a2 */                   JSR.abs ("_ae38");            // push sign, round FAC1 and put on stack
/* a7a5 */                   LDA.zpg ("forpnt+1_004a");    // get FOR/NEXT variable pointer high byte
/* a7a7 */                   PHA.imp ();                   // push on stack
/* a7a8 */                   LDA.zpg ("forpnt+0_0049");    // get FOR/NEXT variable pointer low byte
/* a7aa */                   PHA.imp ();                   // push on stack
/* a7ab */                   LDA.imm (0x81);               // get FOR token
/* a7ad */                   PHA.imp ();                   // push on stack

// ------------------------------------------------------- // interpreter inner loop
/* a7ae */  _`newstt_a7ae`;  JSR.abs ("stop_a82c");        // do CRTL-C check vector
/* a7b1 */                   LDA.zpg ("txtptr+0_007a");    // get the BASIC execute pointer low byte
/* a7b3 */                   LDY.zpg ("txtptr+1_007b");    // get the BASIC execute pointer high byte
/* a7b5 */                   CPY.imm (0x02);               // compare the high byte with $02xx
/* a7b7 */                   NOP.imp ();                   // unused byte
/* a7b8 */                   BEQ.rel ("_a7be");            // if immediate mode skip the continue pointer save
/* a7ba */                   STA.zpg ("oldtxt+0_003d");    // save the continue pointer low byte
/* a7bc */                   STY.zpg ("oldtxt+1_003e");    // save the continue pointer high byte
/* a7be */        _`_a7be`;  LDY.imm (0x00);               // clear the index
/* a7c0 */                   LDA.iny ("txtptr+0_007a");    // get a BASIC byte
/* a7c2 */                   BNE.rel ("_a807");            // if not [EOL] go test for ":"
/* a7c4 */   _`ckeol_a7c4`;  LDY.imm (0x02);               // else set the index
/* a7c6 */                   LDA.iny ("txtptr+0_007a");    // get next line pointer high byte
/* a7c8 */                   CLC.imp ();                   // clear carry for no "BREAK" message
/* a7c9 */                   BNE.rel ("_a7ce");            // branch if not end of program
/* a7cb */                   JMP.abs ("_a84b");            // else go to immediate mode,was immediate or [EOT] marker
/* a7ce */        _`_a7ce`;  INY.imp ();                   // increment index
/* a7cf */                   LDA.iny ("txtptr+0_007a");    // get line number low byte
/* a7d1 */                   STA.zpg ("curlin+0_0039");    // save current line number low byte
/* a7d3 */                   INY.imp ();                   // increment index
/* a7d4 */                   LDA.iny ("txtptr+0_007a");    // get line # high byte
/* a7d6 */                   STA.zpg ("curlin+1_003a");    // save current line number high byte
/* a7d8 */                   TYA.imp ();                   // A now = 4
/* a7d9 */                   ADC.zpg ("txtptr+0_007a");    // add BASIC execute pointer low byte, now points to code
/* a7db */                   STA.zpg ("txtptr+0_007a");    // save BASIC execute pointer low byte
/* a7dd */                   BCC.rel ("_a7e1");            // branch if no overflow
/* a7df */                   INC.zpg ("txtptr+1_007b");    // else increment BASIC execute pointer high byte
/* a7e1 */        _`_a7e1`;  JMP.ind ("igone+0_0308");     // do start new BASIC code

// ------------------------------------------------------- // start new BASIC code, the start new BASIC code vector is initialised to point here
/* a7e4 */    _`gone_a7e4`;  JSR.abs ("chrget+0_0073");    // increment and scan memory
/* a7e7 */                   JSR.abs ("gone3_a7ed");       // go interpret BASIC code from BASIC execute pointer
/* a7ea */                   JMP.abs ("newstt_a7ae");      // loop

// ------------------------------------------------------- // go interpret BASIC code from BASIC execute pointer
/* a7ed */   _`gone3_a7ed`;  BEQ.rel ("_a82b");            // if the first byte is null just exit
/* a7ef */        _`_a7ef`;  SBC.imm (0x80);               // normalise the token
/* a7f1 */                   BCC.rel ("_a804");            // if wasn't token go do LET
/* a7f3 */                   CMP.imm (0x23);               // compare with token for TAB(-$80
/* a7f5 */                   BCS.rel ("_a80e");            // branch if >= TAB(
/* a7f7 */                   ASL.acc ();                   // *2 bytes per vector
/* a7f8 */                   TAY.imp ();                   // copy to index
/* a7f9 */                   LDA.aby (0xa00d);             // get vector high byte
/* a7fc */                   PHA.imp ();                   // push on stack
/* a7fd */                   LDA.aby ("stmdsp_a00c");      // get vector low byte
/* a800 */                   PHA.imp ();                   // push on stack
/* a801 */                   JMP.abs ("chrget+0_0073");    // increment and scan memory and return. the return in
                                                           // this case calls the command code, the return from
                                                           // that will eventually return to the interpreter inner
                                                           // loop above
/* a804 */        _`_a804`;  JMP.abs ("let_a9a5");         // perform LET
                                                           // was not [EOL]
/* a807 */        _`_a807`;  CMP.imm (0x3a);               // comapre with ":"
/* a809 */                   BEQ.rel ("_a7e1");            // if ":" go execute new code
                                                           // else ...
/* a80b */        _`_a80b`;  JMP.abs ("synerr_af08");      // do syntax error then warm start
                                                           // token was >= TAB(
/* a80e */        _`_a80e`;  CMP.imm (0x4b);               // compare with the token for GO
/* a810 */                   BNE.rel ("_a80b");            // if not "GO" do syntax error then warm start
                                                           // else was "GO"
/* a812 */                   JSR.abs ("chrget+0_0073");    // increment and scan memory
/* a815 */                   LDA.imm (0xa4);               // set "TO" token
/* a817 */                   JSR.abs ("chkcom_aeff");      // scan for CHR$(A), else do syntax error then warm start
/* a81a */                   JMP.abs ("goto_a8a0");        // perform GOTO

// ------------------------------------------------------- // perform RESTORE
/* a81d */  _`restor_a81d`;  SEC.imp ();                   // set carry for subtract
/* a81e */                   LDA.zpg ("txttab+0_002b");    // get start of memory low byte
/* a820 */                   SBC.imm (0x01);               // -1
/* a822 */                   LDY.zpg ("txttab+1_002c");    // get start of memory high byte
/* a824 */                   BCS.rel ("_a827");            // branch if no rollunder
/* a826 */                   DEY.imp ();                   // else decrement high byte
/* a827 */        _`_a827`;  STA.zpg ("datptr+0_0041");    // set DATA pointer low byte
/* a829 */                   STY.zpg ("datptr+1_0042");    // set DATA pointer high byte
/* a82b */        _`_a82b`;  RTS.imp ();

// ------------------------------------------------------- // do CRTL-C check vector
/* a82c */    _`stop_a82c`;  JSR.abs ("stop_ffe1");        // scan stop key

// ------------------------------------------------------- // perform STOP
/* a82f */                   BCS.rel ("_a832");            // if carry set do BREAK instead of just END

// ------------------------------------------------------- // perform END
/* a831 */     _`end_a831`;  CLC.imp ();                   // clear carry
/* a832 */        _`_a832`;  BNE.rel ("_a870");            // return if wasn't CTRL-C
/* a834 */                   LDA.zpg ("txtptr+0_007a");    // get BASIC execute pointer low byte
/* a836 */                   LDY.zpg ("txtptr+1_007b");    // get BASIC execute pointer high byte
/* a838 */                   LDX.zpg ("curlin+1_003a");    // get current line number high byte
/* a83a */                   INX.imp ();                   // increment it
/* a83b */                   BEQ.rel ("_a849");            // branch if was immediate mode
/* a83d */                   STA.zpg ("oldtxt+0_003d");    // save continue pointer low byte
/* a83f */                   STY.zpg ("oldtxt+1_003e");    // save continue pointer high byte
/* a841 */                   LDA.zpg ("curlin+0_0039");    // get current line number low byte
/* a843 */                   LDY.zpg ("curlin+1_003a");    // get current line number high byte
/* a845 */                   STA.zpg ("oldlin+0_003b");    // save break line number low byte
/* a847 */                   STY.zpg ("oldlin+1_003c");    // save break line number high byte
/* a849 */        _`_a849`;  PLA.imp ();                   // dump return address low byte
/* a84a */                   PLA.imp ();                   // dump return address high byte
/* a84b */        _`_a84b`;  LDA.imm (0x81);               // set [CR][LF]"BREAK" pointer low byte
/* a84d */                   LDY.imm (0xa3);               // set [CR][LF]"BREAK" pointer high byte
/* a84f */                   BCC.rel ("_a854");            // if was program end skip the print string
/* a851 */                   JMP.abs ("errfin_a469");      // print string and do warm start
/* a854 */        _`_a854`;  JMP.abs ("_e386");            // do warm start

// ------------------------------------------------------- // perform CONT
/* a857 */    _`cont_a857`;  BNE.rel ("_a870");            // exit if following byte to allow syntax error
/* a859 */                   LDX.imm (0x1a);               // error code $1A, can't continue error
/* a85b */                   LDY.zpg ("oldtxt+1_003e");    // get continue pointer high byte
/* a85d */                   BNE.rel ("_a862");            // go do continue if we can
/* a85f */                   JMP.abs ("error_a437");       // else do error #X then warm start
                                                           // we can continue so ...
/* a862 */        _`_a862`;  LDA.zpg ("oldtxt+0_003d");    // get continue pointer low byte
/* a864 */                   STA.zpg ("txtptr+0_007a");    // save BASIC execute pointer low byte
/* a866 */                   STY.zpg ("txtptr+1_007b");    // save BASIC execute pointer high byte
/* a868 */                   LDA.zpg ("oldlin+0_003b");    // get break line low byte
/* a86a */                   LDY.zpg ("oldlin+1_003c");    // get break line high byte
/* a86c */                   STA.zpg ("curlin+0_0039");    // set current line number low byte
/* a86e */                   STY.zpg ("curlin+1_003a");    // set current line number high byte
/* a870 */        _`_a870`;  RTS.imp ();

// ------------------------------------------------------- // perform RUN
/* a871 */     _`run_a871`;  PHP.imp ();                   // save status
/* a872 */                   LDA.imm (0x00);               // no control or kernal messages
/* a874 */                   JSR.abs ("setmsg_ff90");      // control kernal messages
/* a877 */                   PLP.imp ();                   // restore status
/* a878 */                   BNE.rel ("_a87d");            // branch if RUN n
/* a87a */                   JMP.abs ("_a659");            // reset execution to start, clear variables, flush stack
                                                           // and return
/* a87d */        _`_a87d`;  JSR.abs ("_a660");            // go do "CLEAR"
/* a880 */                   JMP.abs ("_a897");            // get n and do GOTO n

// ------------------------------------------------------- // perform GOSUB
/* a883 */   _`gosub_a883`;  LDA.imm (0x03);               // need 6 bytes for GOSUB
/* a885 */                   JSR.abs ("getstk_a3fb");      // check room on stack for 2*A bytes
/* a888 */                   LDA.zpg ("txtptr+1_007b");    // get BASIC execute pointer high byte
/* a88a */                   PHA.imp ();                   // save it
/* a88b */                   LDA.zpg ("txtptr+0_007a");    // get BASIC execute pointer low byte
/* a88d */                   PHA.imp ();                   // save it
/* a88e */                   LDA.zpg ("curlin+1_003a");    // get current line number high byte
/* a890 */                   PHA.imp ();                   // save it
/* a891 */                   LDA.zpg ("curlin+0_0039");    // get current line number low byte
/* a893 */                   PHA.imp ();                   // save it
/* a894 */                   LDA.imm (0x8d);               // token for GOSUB
/* a896 */                   PHA.imp ();                   // save it
/* a897 */        _`_a897`;  JSR.abs ("chrgot_0079");      // scan memory
/* a89a */                   JSR.abs ("goto_a8a0");        // perform GOTO
/* a89d */                   JMP.abs ("newstt_a7ae");      // go do interpreter inner loop

// ------------------------------------------------------- // perform GOTO
/* a8a0 */    _`goto_a8a0`;  JSR.abs ("linget_a96b");      // get fixed-point number into temporary integer
/* a8a3 */                   JSR.abs ("_a909");            // scan for next BASIC line
/* a8a6 */                   SEC.imp ();                   // set carry for subtract
/* a8a7 */                   LDA.zpg ("curlin+0_0039");    // get current line number low byte
/* a8a9 */                   SBC.zpg ("linnum+0_0014");    // subtract temporary integer low byte
/* a8ab */                   LDA.zpg ("curlin+1_003a");    // get current line number high byte
/* a8ad */                   SBC.zpg ("linnum+1_0015");    // subtract temporary integer high byte
/* a8af */                   BCS.rel ("_a8bc");            // if current line number >= temporary integer, go search
                                                           // from the start of memory
/* a8b1 */                   TYA.imp ();                   // else copy line index to A
/* a8b2 */                   SEC.imp ();                   // set carry (+1)
/* a8b3 */                   ADC.zpg ("txtptr+0_007a");    // add BASIC execute pointer low byte
/* a8b5 */                   LDX.zpg ("txtptr+1_007b");    // get BASIC execute pointer high byte
/* a8b7 */                   BCC.rel ("_a8c0");            // branch if no overflow to high byte
/* a8b9 */                   INX.imp ();                   // increment high byte
/* a8ba */                   BCS.rel ("_a8c0");            // branch always (can never be carry)

// ------------------------------------------------------- // search for line number in temporary integer from start of memory pointer
/* a8bc */        _`_a8bc`;  LDA.zpg ("txttab+0_002b");    // get start of memory low byte
/* a8be */                   LDX.zpg ("txttab+1_002c");    // get start of memory high byte

// ------------------------------------------------------- // search for line # in temporary integer from (AX)
/* a8c0 */        _`_a8c0`;  JSR.abs ("_a617");            // search Basic for temp integer line number from AX
/* a8c3 */                   BCC.rel ("_a8e3");            // if carry clear go do unsdefined statement error
                                                           // carry all ready set for subtract
/* a8c5 */                   LDA.zpg ("tempf2+3_005f");    // get pointer low byte
/* a8c7 */                   SBC.imm (0x01);               // -1
/* a8c9 */                   STA.zpg ("txtptr+0_007a");    // save BASIC execute pointer low byte
/* a8cb */                   LDA.zpg ("tempf2+4_0060");    // get pointer high byte
/* a8cd */                   SBC.imm (0x00);               // subtract carry
/* a8cf */                   STA.zpg ("txtptr+1_007b");    // save BASIC execute pointer high byte
/* a8d1 */        _`_a8d1`;  RTS.imp ();

// ------------------------------------------------------- // perform RETURN
/* a8d2 */  _`return_a8d2`;  BNE.rel ("_a8d1");            // exit if following token to allow syntax error
/* a8d4 */                   LDA.imm (0xff);               // set byte so no match possible
/* a8d6 */                   STA.zpg ("forpnt+1_004a");    // save FOR/NEXT variable pointer high byte
/* a8d8 */                   JSR.abs ("fndfor_a38a");      // search the stack for FOR or GOSUB activity,
                                                           // get token off stack
/* a8db */                   TXS.imp ();                   // correct the stack
/* a8dc */                   CMP.imm (0x8d);               // compare with GOSUB token
/* a8de */                   BEQ.rel ("_a8eb");            // if matching GOSUB go continue RETURN
/* a8e0 */                   LDX.imm (0x0c);               // else error code $04, return without gosub error
/* a8e2 */                   _.bytes(0x2c);                // makes next line BIT $11A2
/* a8e3 */        _`_a8e3`;  LDX.imm (0x11);               // error code $11, undefined statement error
/* a8e5 */                   JMP.abs ("error_a437");       // do error #X then warm start
/* a8e8 */        _`_a8e8`;  JMP.abs ("synerr_af08");      // do syntax error then warm start
                                                           // was matching GOSUB token
/* a8eb */        _`_a8eb`;  PLA.imp ();                   // dump token byte
/* a8ec */                   PLA.imp ();                   // pull return line low byte
/* a8ed */                   STA.zpg ("curlin+0_0039");    // save current line number low byte
/* a8ef */                   PLA.imp ();                   // pull return line high byte
/* a8f0 */                   STA.zpg ("curlin+1_003a");    // save current line number high byte
/* a8f2 */                   PLA.imp ();                   // pull return address low byte
/* a8f3 */                   STA.zpg ("txtptr+0_007a");    // save BASIC execute pointer low byte
/* a8f5 */                   PLA.imp ();                   // pull return address high byte
/* a8f6 */                   STA.zpg ("txtptr+1_007b");    // save BASIC execute pointer high byte

// ------------------------------------------------------- // perform DATA
/* a8f8 */    _`data_a8f8`;  JSR.abs ("datan_a906");       // scan for next BASIC statement ([:] or [EOL])

// ------------------------------------------------------- // add Y to the BASIC execute pointer
/* a8fb */        _`_a8fb`;  TYA.imp ();                   // copy index to A
/* a8fc */                   CLC.imp ();                   // clear carry for add
/* a8fd */                   ADC.zpg ("txtptr+0_007a");    // add BASIC execute pointer low byte
/* a8ff */                   STA.zpg ("txtptr+0_007a");    // save BASIC execute pointer low byte
/* a901 */                   BCC.rel ("_a905");            // skip increment if no carry
/* a903 */                   INC.zpg ("txtptr+1_007b");    // else increment BASIC execute pointer high byte
/* a905 */        _`_a905`;  RTS.imp ();

// ------------------------------------------------------- // scan for next BASIC statement ([:] or [EOL])
                                                           // returns Y as index to [:] or [EOL]
/* a906 */   _`datan_a906`;  LDX.imm (0x3a);               // set look for character = ":"
/* a908 */                   _.bytes(0x2c);                // makes next line BIT $00A2

// ------------------------------------------------------- // scan for next BASIC line
                                                           // returns Y as index to [EOL]
/* a909 */        _`_a909`;  LDX.imm (0x00);               // set alternate search character = [EOL]
/* a90b */                   STX.zpg ("charac_0007");      // store alternate search character
/* a90d */                   LDY.imm (0x00);               // set search character = [EOL]
/* a90f */                   STY.zpg ("endchr_0008");      // save the search character
/* a911 */        _`_a911`;  LDA.zpg ("endchr_0008");      // get search character
/* a913 */                   LDX.zpg ("charac_0007");      // get alternate search character
/* a915 */                   STA.zpg ("charac_0007");      // make search character = alternate search character
/* a917 */                   STX.zpg ("endchr_0008");      // make alternate search character = search character
/* a919 */        _`_a919`;  LDA.iny ("txtptr+0_007a");    // get BASIC byte
/* a91b */                   BEQ.rel ("_a905");            // exit if null [EOL]
/* a91d */                   CMP.zpg ("endchr_0008");      // compare with search character
/* a91f */                   BEQ.rel ("_a905");            // exit if found
/* a921 */                   INY.imp ();                   // else increment index
/* a922 */                   CMP.imm (0x22);               // compare current character with open quote
/* a924 */                   BNE.rel ("_a919");            // if found go swap search character for alternate search
                                                           // character
/* a926 */                   BEQ.rel ("_a911");            // loop for next character, branch always

// ------------------------------------------------------- // perform IF
/* a928 */      _`if_a928`;  JSR.abs ("frmevl_ad9e");      // evaluate expression
/* a92b */                   JSR.abs ("chrgot_0079");      // scan memory
/* a92e */                   CMP.imm (0x89);               // compare with "GOTO" token
/* a930 */                   BEQ.rel ("_a937");            // if it was  the token for GOTO go do IF ... GOTO
                                                           // wasn't IF ... GOTO so must be IF ... THEN
/* a932 */                   LDA.imm (0xa7);               // set "THEN" token
/* a934 */                   JSR.abs ("chkcom_aeff");      // scan for CHR$(A), else do syntax error then warm start
/* a937 */        _`_a937`;  LDA.zpg ("facexp_0061");      // get FAC1 exponent
/* a939 */                   BNE.rel ("_a940");            // if result was non zero continue execution
                                                           // else REM rest of line

// ------------------------------------------------------- // perform REM
/* a93b */     _`rem_a93b`;  JSR.abs ("_a909");            // scan for next BASIC line
/* a93e */                   BEQ.rel ("_a8fb");            // add Y to the BASIC execute pointer and return, branch
                                                           // always
                                                           // result was non zero so do rest of line
/* a940 */        _`_a940`;  JSR.abs ("chrgot_0079");      // scan memory
/* a943 */                   BCS.rel ("_a948");            // branch if not numeric character, is variable or keyword
/* a945 */                   JMP.abs ("goto_a8a0");        // else perform GOTO n
                                                           // is variable or keyword
/* a948 */        _`_a948`;  JMP.abs ("gone3_a7ed");       // interpret BASIC code from BASIC execute pointer

// ------------------------------------------------------- // perform ON
/* a94b */  _`ongoto_a94b`;  JSR.abs ("_b79e");            // get byte parameter
/* a94e */                   PHA.imp ();                   // push next character
/* a94f */                   CMP.imm (0x8d);               // compare with GOSUB token
/* a951 */                   BEQ.rel ("_a957");            // if GOSUB go see if it should be executed
/* a953 */        _`_a953`;  CMP.imm (0x89);               // compare with GOTO token
/* a955 */                   BNE.rel ("_a8e8");            // if not GOTO do syntax error then warm start
                                                           // next character was GOTO or GOSUB, see if it should be executed
/* a957 */        _`_a957`;  DEC.zpg ("facho+3_0065");     // decrement the byte value
/* a959 */                   BNE.rel ("_a95f");            // if not zero go see if another line number exists
/* a95b */                   PLA.imp ();                   // pull keyword token
/* a95c */                   JMP.abs ("_a7ef");            // go execute it
/* a95f */        _`_a95f`;  JSR.abs ("chrget+0_0073");    // increment and scan memory
/* a962 */                   JSR.abs ("linget_a96b");      // get fixed-point number into temporary integer
                                                           // skip this n
/* a965 */                   CMP.imm (0x2c);               // compare next character with ","
/* a967 */                   BEQ.rel ("_a957");            // loop if ","
/* a969 */                   PLA.imp ();                   // else pull keyword token, ran out of options
/* a96a */        _`_a96a`;  RTS.imp ();

// ------------------------------------------------------- // get fixed-point number into temporary integer
/* a96b */  _`linget_a96b`;  LDX.imm (0x00);               // clear X
/* a96d */                   STX.zpg ("linnum+0_0014");    // clear temporary integer low byte
/* a96f */                   STX.zpg ("linnum+1_0015");    // clear temporary integer high byte
/* a971 */        _`_a971`;  BCS.rel ("_a96a");            // return if carry set, end of scan, character was not 0-9
/* a973 */                   SBC.imm (0x2f);               // subtract $30, $2F+carry, from byte
/* a975 */                   STA.zpg ("charac_0007");      // store #
/* a977 */                   LDA.zpg ("linnum+1_0015");    // get temporary integer high byte
/* a979 */                   STA.zpg ("index+0_0022");     // save it for now
/* a97b */                   CMP.imm (0x19);               // compare with $19
/* a97d */                   BCS.rel ("_a953");            // branch if >= this makes the maximum line number 63999
                                                           // because the next bit does $1900 * $0A = $FA00 = 64000
                                                           // decimal. the branch target is really the SYNTAX error
                                                           // at $A8E8 but that is too far so an intermediate
                                                           // compare and branch to that location is used. the problem
                                                           // with this is that line number that gives a partial result
                                                           // from $8900 to $89FF, 35072x to 35327x, will pass the new
                                                           // target compare and will try to execute the remainder of
                                                           // the ON n GOTO/GOSUB. a solution to this is to copy the
                                                           // byte in A before the branch to X and then branch to
                                                           // $A955 skipping the second compare
/* a97f */                   LDA.zpg ("linnum+0_0014");    // get temporary integer low byte
/* a981 */                   ASL.acc ();                   // *2 low byte
/* a982 */                   ROL.zpg ("index+0_0022");     // *2 high byte
/* a984 */                   ASL.acc ();                   // *2 low byte
/* a985 */                   ROL.zpg ("index+0_0022");     // *2 high byte (*4)
/* a987 */                   ADC.zpg ("linnum+0_0014");    // + low byte (*5)
/* a989 */                   STA.zpg ("linnum+0_0014");    // save it
/* a98b */                   LDA.zpg ("index+0_0022");     // get high byte temp
/* a98d */                   ADC.zpg ("linnum+1_0015");    // + high byte (*5)
/* a98f */                   STA.zpg ("linnum+1_0015");    // save it
/* a991 */                   ASL.zpg ("linnum+0_0014");    // *2 low byte (*10d)
/* a993 */                   ROL.zpg ("linnum+1_0015");    // *2 high byte (*10d)
/* a995 */                   LDA.zpg ("linnum+0_0014");    // get low byte
/* a997 */                   ADC.zpg ("charac_0007");      // add #
/* a999 */                   STA.zpg ("linnum+0_0014");    // save low byte
/* a99b */                   BCC.rel ("_a99f");            // branch if no overflow to high byte
/* a99d */                   INC.zpg ("linnum+1_0015");    // else increment high byte
/* a99f */        _`_a99f`;  JSR.abs ("chrget+0_0073");    // increment and scan memory
/* a9a2 */                   JMP.abs ("_a971");            // loop for next character

// ------------------------------------------------------- // perform LET
/* a9a5 */     _`let_a9a5`;  JSR.abs ("ptrget_b08b");      // get variable address
/* a9a8 */                   STA.zpg ("forpnt+0_0049");    // save variable address low byte
/* a9aa */                   STY.zpg ("forpnt+1_004a");    // save variable address high byte
/* a9ac */                   LDA.imm (0xb2);               // $B2 is "=" token
/* a9ae */                   JSR.abs ("chkcom_aeff");      // scan for CHR$(A), else do syntax error then warm start
/* a9b1 */                   LDA.zpg ("intflg_000e");      // get data type flag, $80 = integer, $00 = float
/* a9b3 */                   PHA.imp ();                   // push data type flag
/* a9b4 */                   LDA.zpg ("valtyp_000d");      // get data type flag, $FF = string, $00 = numeric
/* a9b6 */                   PHA.imp ();                   // push data type flag
/* a9b7 */                   JSR.abs ("frmevl_ad9e");      // evaluate expression
/* a9ba */                   PLA.imp ();                   // pop data type flag
/* a9bb */                   ROL.acc ();                   // string bit into carry
/* a9bc */                   JSR.abs ("_ad90");            // do type match check
/* a9bf */                   BNE.rel ("putstr_a9d9");      // branch if string
/* a9c1 */                   PLA.imp ();                   // pop integer/float data type flag
                                                           // assign value to numeric variable
/* a9c2 */        _`_a9c2`;  BPL.rel ("ptflpt_a9d6");      // branch if float
                                                           // expression is numeric integer
/* a9c4 */  _`putint_a9c4`;  JSR.abs ("round_bc1b");       // round FAC1
/* a9c7 */                   JSR.abs ("ayint_b1bf");       // evaluate integer expression, no sign check
/* a9ca */                   LDY.imm (0x00);               // clear index
/* a9cc */                   LDA.zpg ("facho+2_0064");     // get FAC1 mantissa 3
/* a9ce */                   STA.iny ("forpnt+0_0049");    // save as integer variable low byte
/* a9d0 */                   INY.imp ();                   // increment index
/* a9d1 */                   LDA.zpg ("facho+3_0065");     // get FAC1 mantissa 4
/* a9d3 */                   STA.iny ("forpnt+0_0049");    // save as integer variable high byte
/* a9d5 */                   RTS.imp ();
/* a9d6 */  _`ptflpt_a9d6`;  JMP.abs ("_bbd0");            // pack FAC1 into variable pointer and return
                                                           // assign value to numeric variable
/* a9d9 */  _`putstr_a9d9`;  PLA.imp ();                   // dump integer/float data type flag
/* a9da */        _`_a9da`;  LDY.zpg ("forpnt+1_004a");    // get variable pointer high byte
/* a9dc */                   CPY.imm (0xbf);               // was it TI$ pointer
/* a9de */                   BNE.rel ("getspt_aa2c");      // branch if not
                                                           // else it's TI$ = <expr$>
/* a9e0 */                   JSR.abs ("_b6a6");            // pop string off descriptor stack, or from top of string
                                                           // space returns with A = length, X = pointer low byte,
                                                           // Y = pointer high byte
/* a9e3 */  _`puttim_a9e3`;  CMP.imm (0x06);               // compare length with 6
/* a9e5 */                   BNE.rel ("_aa24");            // if length not 6 do illegal quantity error then warm start
/* a9e7 */                   LDY.imm (0x00);               // clear index
/* a9e9 */                   STY.zpg ("facexp_0061");      // clear FAC1 exponent
/* a9eb */                   STY.zpg ("facsgn_0066");      // clear FAC1 sign (b7)
/* a9ed */        _`_a9ed`;  STY.zpg ("fbufpt+0_0071");    // save index
/* a9ef */                   JSR.abs ("_aa1d");            // check and evaluate numeric digit
/* a9f2 */                   JSR.abs ("mul10_bae2");       // multiply FAC1 by 10
/* a9f5 */                   INC.zpg ("fbufpt+0_0071");    // increment index
/* a9f7 */                   LDY.zpg ("fbufpt+0_0071");    // restore index
/* a9f9 */                   JSR.abs ("_aa1d");            // check and evaluate numeric digit
/* a9fc */                   JSR.abs ("movaf_bc0c");       // round and copy FAC1 to FAC2
/* a9ff */                   TAX.imp ();                   // copy FAC1 exponent
/* aa00 */                   BEQ.rel ("_aa07");            // branch if FAC1 zero
/* aa02 */                   INX.imp ();                   // increment index, * 2
/* aa03 */                   TXA.imp ();                   // copy back to A
/* aa04 */                   JSR.abs ("_baed");            // FAC1 = (FAC1 + (FAC2 * 2)) * 2 = FAC1 * 6
/* aa07 */        _`_aa07`;  LDY.zpg ("fbufpt+0_0071");    // get index
/* aa09 */                   INY.imp ();                   // increment index
/* aa0a */                   CPY.imm (0x06);               // compare index with 6
/* aa0c */                   BNE.rel ("_a9ed");            // loop if not 6
/* aa0e */                   JSR.abs ("mul10_bae2");       // multiply FAC1 by 10
/* aa11 */                   JSR.abs ("qint_bc9b");        // convert FAC1 floating to fixed
/* aa14 */                   LDX.zpg ("facho+2_0064");     // get FAC1 mantissa 3
/* aa16 */                   LDY.zpg ("facho+1_0063");     // get FAC1 mantissa 2
/* aa18 */                   LDA.zpg ("facho+3_0065");     // get FAC1 mantissa 4
/* aa1a */                   JMP.abs ("settim_ffdb");      // set real time clock and return

// ------------------------------------------------------- // check and evaluate numeric digit
/* aa1d */        _`_aa1d`;  LDA.iny ("index+0_0022");     // get byte from string
/* aa1f */                   JSR.abs ("chrget+13_0080");   // clear Cb if numeric. this call should be to $84
                                                           // as the code from $80 first comapres the byte with
                                                           // [SPACE] and does a BASIC increment and get if it is
/* aa22 */                   BCC.rel ("_aa27");            // branch if numeric
/* aa24 */        _`_aa24`;  JMP.abs ("fcerr_b248");       // do illegal quantity error then warm start
/* aa27 */        _`_aa27`;  SBC.imm (0x2f);               // subtract $2F + carry to convert ASCII to binary
/* aa29 */                   JMP.abs ("finlog_bd7e");      // evaluate new ASCII digit and return

// ------------------------------------------------------- // assign value to numeric variable, but not TI$
/* aa2c */  _`getspt_aa2c`;  LDY.imm (0x02);               // index to string pointer high byte
/* aa2e */                   LDA.iny ("facho+2_0064");     // get string pointer high byte
/* aa30 */                   CMP.zpg ("fretop+1_0034");    // compare with bottom of string space high byte
/* aa32 */                   BCC.rel ("_aa4b");            // branch if string pointer high byte is less than bottom
                                                           // of string space high byte
/* aa34 */                   BNE.rel ("_aa3d");            // branch if string pointer high byte is greater than
                                                           // bottom of string space high byte
                                                           // else high bytes were equal
/* aa36 */                   DEY.imp ();                   // decrement index to string pointer low byte
/* aa37 */                   LDA.iny ("facho+2_0064");     // get string pointer low byte
/* aa39 */                   CMP.zpg ("fretop+0_0033");    // compare with bottom of string space low byte
/* aa3b */                   BCC.rel ("_aa4b");            // branch if string pointer low byte is less than bottom
                                                           // of string space low byte
/* aa3d */        _`_aa3d`;  LDY.zpg ("facho+3_0065");     // get descriptor pointer high byte
/* aa3f */                   CPY.zpg ("vartab+1_002e");    // compare with start of variables high byte
/* aa41 */                   BCC.rel ("_aa4b");            // branch if less, is on string stack
/* aa43 */                   BNE.rel ("_aa52");            // if greater make space and copy string
                                                           // else high bytes were equal
/* aa45 */                   LDA.zpg ("facho+2_0064");     // get descriptor pointer low byte
/* aa47 */                   CMP.zpg ("vartab+0_002d");    // compare with start of variables low byte
/* aa49 */                   BCS.rel ("_aa52");            // if greater or equal make space and copy string
/* aa4b */        _`_aa4b`;  LDA.zpg ("facho+2_0064");     // get descriptor pointer low byte
/* aa4d */                   LDY.zpg ("facho+3_0065");     // get descriptor pointer high byte
/* aa4f */                   JMP.abs ("_aa68");            // go copy descriptor to variable
/* aa52 */        _`_aa52`;  LDY.imm (0x00);               // clear index
/* aa54 */                   LDA.iny ("facho+2_0064");     // get string length
/* aa56 */                   JSR.abs ("_b475");            // copy descriptor pointer and make string space A bytes long
/* aa59 */                   LDA.zpg ("dscpnt+0_0050");    // copy old descriptor pointer low byte
/* aa5b */                   LDY.zpg ("dscpnt+1_0051");    // copy old descriptor pointer high byte
/* aa5d */                   STA.zpg ("arisgn_006f");      // save old descriptor pointer low byte
/* aa5f */                   STY.zpg ("facov_0070");       // save old descriptor pointer high byte
/* aa61 */                   JSR.abs ("movins_b67a");      // copy string from descriptor to utility pointer
/* aa64 */                   LDA.imm (0x61);               // get descriptor pointer low byte
/* aa66 */                   LDY.imm (0x00);               // get descriptor pointer high byte
/* aa68 */        _`_aa68`;  STA.zpg ("dscpnt+0_0050");    // save descriptor pointer low byte
/* aa6a */                   STY.zpg ("dscpnt+1_0051");    // save descriptor pointer high byte
/* aa6c */                   JSR.abs ("frefac_b6db");      // clean descriptor stack, YA = pointer
/* aa6f */                   LDY.imm (0x00);               // clear index
/* aa71 */                   LDA.iny ("dscpnt+0_0050");    // get string length from new descriptor
/* aa73 */                   STA.iny ("forpnt+0_0049");    // copy string length to variable
/* aa75 */                   INY.imp ();                   // increment index
/* aa76 */                   LDA.iny ("dscpnt+0_0050");    // get string pointer low byte from new descriptor
/* aa78 */                   STA.iny ("forpnt+0_0049");    // copy string pointer low byte to variable
/* aa7a */                   INY.imp ();                   // increment index
/* aa7b */                   LDA.iny ("dscpnt+0_0050");    // get string pointer high byte from new descriptor
/* aa7d */                   STA.iny ("forpnt+0_0049");    // copy string pointer high byte to variable
/* aa7f */                   RTS.imp ();

// ------------------------------------------------------- // perform PRINT#
/* aa80 */  _`printn_aa80`;  JSR.abs ("cmd_aa86");         // perform CMD
/* aa83 */                   JMP.abs ("_abb5");            // close input and output channels and return

// ------------------------------------------------------- // perform CMD
/* aa86 */     _`cmd_aa86`;  JSR.abs ("_b79e");            // get byte parameter
/* aa89 */                   BEQ.rel ("_aa90");            // branch if following byte is ":" or [EOT]
/* aa8b */                   LDA.imm (0x2c);               // set ","
/* aa8d */                   JSR.abs ("chkcom_aeff");      // scan for CHR$(A), else do syntax error then warm start
/* aa90 */        _`_aa90`;  PHP.imp ();                   // save status
/* aa91 */                   STX.zpg ("channl_0013");      // set current I/O channel
/* aa93 */                   JSR.abs ("bckout_e118");      // open channel for output with error check
/* aa96 */                   PLP.imp ();                   // restore status
/* aa97 */                   JMP.abs ("print_aaa0");       // perform PRINT
/* aa9a */  _`strdon_aa9a`;  JSR.abs ("_ab21");            // print string from utility pointer
/* aa9d */        _`_aa9d`;  JSR.abs ("chrgot_0079");      // scan memory

// ------------------------------------------------------- // perform PRINT
/* aaa0 */   _`print_aaa0`;  BEQ.rel ("crdo_aad7");        // if nothing following just print CR/LF
/* aaa2 */        _`_aaa2`;  BEQ.rel ("_aae7");            // exit if nothing following, end of PRINT branch
/* aaa4 */                   CMP.imm (0xa3);               // compare with token for TAB(
/* aaa6 */                   BEQ.rel ("_aaf8");            // if TAB( go handle it
/* aaa8 */                   CMP.imm (0xa6);               // compare with token for SPC(
/* aaaa */                   CLC.imp ();                   // flag SPC(
/* aaab */                   BEQ.rel ("_aaf8");            // if SPC( go handle it
/* aaad */                   CMP.imm (0x2c);               // compare with ","
/* aaaf */                   BEQ.rel ("comprt_aae8");      // if "," go skip to the next TAB position
/* aab1 */                   CMP.imm (0x3b);               // compare with ";"
/* aab3 */                   BEQ.rel ("_ab13");            // if ";" go continue the print loop
/* aab5 */                   JSR.abs ("frmevl_ad9e");      // evaluate expression
/* aab8 */   _`varop_aab8`;  BIT.zpg ("valtyp_000d");      // test data type flag, $FF = string, $00 = numeric
/* aaba */                   BMI.rel ("strdon_aa9a");      // if string go print string, scan memory and continue PRINT
/* aabc */                   JSR.abs ("fout_bddd");        // convert FAC1 to ASCII string result in (AY)
/* aabf */                   JSR.abs ("strlit_b487");      // print " terminated string to utility pointer
/* aac2 */                   JSR.abs ("_ab21");            // print string from utility pointer
/* aac5 */                   JSR.abs ("outspc_ab3b");      // print [SPACE] or [CURSOR RIGHT]
/* aac8 */                   BNE.rel ("_aa9d");            // go scan memory and continue PRINT, branch always

// ------------------------------------------------------- // set XY to $0200 - 1 and print [CR]
/* aaca */        _`_aaca`;  LDA.imm (0x00);               // clear A
/* aacc */                   STA.abx ("buf+0_0200");       // clear first byte of input buffer
/* aacf */                   LDX.imm (0xff);               // $0200 - 1 low byte
/* aad1 */                   LDY.imm (0x01);               // $0200 - 1 high byte
/* aad3 */                   LDA.zpg ("channl_0013");      // get current I/O channel
/* aad5 */                   BNE.rel ("_aae7");            // exit if not default channel

// ------------------------------------------------------- // print CR/LF
/* aad7 */    _`crdo_aad7`;  LDA.imm (0x0d);               // set [CR]
/* aad9 */                   JSR.abs ("_ab47");            // print the character
/* aadc */                   BIT.zpg ("channl_0013");      // test current I/O channel
/* aade */                   BPL.rel ("_aae5");            // if ?? toggle A, EOR #$FF and return
/* aae0 */                   LDA.imm (0x0a);               // set [LF]
/* aae2 */                   JSR.abs ("_ab47");            // print the character
                                                           // toggle A
/* aae5 */        _`_aae5`;  EOR.imm (0xff);               // invert A
/* aae7 */        _`_aae7`;  RTS.imp ();
                                                           // was ","
/* aae8 */  _`comprt_aae8`;  SEC.imp ();                   // set Cb for read cursor position
/* aae9 */                   JSR.abs ("plot_fff0");        // read/set X,Y cursor position
/* aaec */                   TYA.imp ();                   // copy cursor Y
/* aaed */                   SEC.imp ();                   // set carry for subtract
/* aaee */        _`_aaee`;  SBC.imm (0x0a);               // subtract one TAB length
/* aaf0 */                   BCS.rel ("_aaee");            // loop if result was +ve
/* aaf2 */                   EOR.imm (0xff);               // complement it
/* aaf4 */                   ADC.imm (0x01);               // +1, twos complement
/* aaf6 */                   BNE.rel ("_ab0e");            // always print A spaces, result is never $00
/* aaf8 */        _`_aaf8`;  PHP.imp ();                   // save TAB( or SPC( status
/* aaf9 */                   SEC.imp ();                   // set Cb for read cursor position
/* aafa */                   JSR.abs ("plot_fff0");        // read/set X,Y cursor position
/* aafd */                   STY.zpg ("trmpos_0009");      // save current cursor position
/* aaff */                   JSR.abs ("gtbytc_b79b");      // scan and get byte parameter
/* ab02 */                   CMP.imm (0x29);               // compare with ")"
/* ab04 */                   BNE.rel ("_ab5f");            // if not ")" do syntax error
/* ab06 */                   PLP.imp ();                   // restore TAB( or SPC( status
/* ab07 */                   BCC.rel ("_ab0f");            // branch if was SPC(
                                                           // else was TAB(
/* ab09 */                   TXA.imp ();                   // copy TAB() byte to A
/* ab0a */                   SBC.zpg ("trmpos_0009");      // subtract current cursor position
/* ab0c */                   BCC.rel ("_ab13");            // go loop for next if already past requited position
/* ab0e */        _`_ab0e`;  TAX.imp ();                   // copy [SPACE] count to X
/* ab0f */        _`_ab0f`;  INX.imp ();                   // increment count
/* ab10 */        _`_ab10`;  DEX.imp ();                   // decrement count
/* ab11 */                   BNE.rel ("_ab19");            // branch if count was not zero
                                                           // was ";" or [SPACES] printed
/* ab13 */        _`_ab13`;  JSR.abs ("chrget+0_0073");    // increment and scan memory
/* ab16 */                   JMP.abs ("_aaa2");            // continue print loop
/* ab19 */        _`_ab19`;  JSR.abs ("outspc_ab3b");      // print [SPACE] or [CURSOR RIGHT]
/* ab1c */                   BNE.rel ("_ab10");            // loop, branch always

// ------------------------------------------------------- // print null terminated string
/* ab1e */  _`strout_ab1e`;  JSR.abs ("strlit_b487");      // print " terminated string to utility pointer

// ------------------------------------------------------- // print string from utility pointer
/* ab21 */        _`_ab21`;  JSR.abs ("_b6a6");            // pop string off descriptor stack, or from top of string
                                                           // space returns with A = length, X = pointer low byte,
                                                           // Y = pointer high byte
/* ab24 */                   TAX.imp ();                   // copy length
/* ab25 */                   LDY.imm (0x00);               // clear index
/* ab27 */                   INX.imp ();                   // increment length, for pre decrement loop
/* ab28 */        _`_ab28`;  DEX.imp ();                   // decrement length
/* ab29 */                   BEQ.rel ("_aae7");            // exit if done
/* ab2b */                   LDA.iny ("index+0_0022");     // get byte from string
/* ab2d */                   JSR.abs ("_ab47");            // print the character
/* ab30 */                   INY.imp ();                   // increment index
/* ab31 */                   CMP.imm (0x0d);               // compare byte with [CR]
/* ab33 */                   BNE.rel ("_ab28");            // loop if not [CR]
/* ab35 */                   JSR.abs ("_aae5");            // toggle A, EOR #$FF. what is the point of this ??
/* ab38 */                   JMP.abs ("_ab28");            // loop

// ------------------------------------------------------- // print [SPACE] or [CURSOR RIGHT]
/* ab3b */  _`outspc_ab3b`;  LDA.zpg ("channl_0013");      // get current I/O channel
/* ab3d */                   BEQ.rel ("_ab42");            // if default channel go output [CURSOR RIGHT]
/* ab3f */                   LDA.imm (0x20);               // else output [SPACE]
/* ab41 */                   _.bytes(0x2c);                // makes next line BIT $1DA9
/* ab42 */        _`_ab42`;  LDA.imm (0x1d);               // set [CURSOR RIGHT]
/* ab44 */                   _.bytes(0x2c);                // makes next line BIT $3FA9

// ------------------------------------------------------- // print "?"
/* ab45 */        _`_ab45`;  LDA.imm (0x3f);               // set "?"

// ------------------------------------------------------- // print character
/* ab47 */        _`_ab47`;  JSR.abs ("bchout_e10c");      // output character to channel with error check
/* ab4a */                   AND.imm (0xff);               // set the flags on A
/* ab4c */                   RTS.imp ();

// ------------------------------------------------------- // bad input routine
/* ab4d */  _`doagin_ab4d`;  LDA.zpg ("inpflg_0011");      // get INPUT mode flag, $00 = INPUT, $40 = GET, $98 = READ
/* ab4f */                   BEQ.rel ("_ab62");            // branch if INPUT
/* ab51 */                   BMI.rel ("_ab57");            // branch if READ
                                                           // else was GET
/* ab53 */                   LDY.imm (0xff);               // set current line high byte to -1, indicate immediate mode
/* ab55 */                   BNE.rel ("_ab5b");            // branch always
/* ab57 */        _`_ab57`;  LDA.zpg ("datlin+0_003f");    // get current DATA line number low byte
/* ab59 */                   LDY.zpg ("datlin+1_0040");    // get current DATA line number high byte
/* ab5b */        _`_ab5b`;  STA.zpg ("curlin+0_0039");    // set current line number low byte
/* ab5d */                   STY.zpg ("curlin+1_003a");    // set current line number high byte
/* ab5f */        _`_ab5f`;  JMP.abs ("synerr_af08");      // do syntax error then warm start
                                                           // was INPUT
/* ab62 */        _`_ab62`;  LDA.zpg ("channl_0013");      // get current I/O channel
/* ab64 */                   BEQ.rel ("_ab6b");            // branch if default channel
/* ab66 */                   LDX.imm (0x18);               // else error $18, file data error
/* ab68 */                   JMP.abs ("error_a437");       // do error #X then warm start
/* ab6b */        _`_ab6b`;  LDA.imm (0x0c);               // set "?REDO FROM START" pointer low byte
/* ab6d */                   LDY.imm (0xad);               // set "?REDO FROM START" pointer high byte
/* ab6f */                   JSR.abs ("strout_ab1e");      // print null terminated string
/* ab72 */                   LDA.zpg ("oldtxt+0_003d");    // get continue pointer low byte
/* ab74 */                   LDY.zpg ("oldtxt+1_003e");    // get continue pointer high byte
/* ab76 */                   STA.zpg ("txtptr+0_007a");    // save BASIC execute pointer low byte
/* ab78 */                   STY.zpg ("txtptr+1_007b");    // save BASIC execute pointer high byte
/* ab7a */                   RTS.imp ();

// ------------------------------------------------------- // perform GET
/* ab7b */     _`get_ab7b`;  JSR.abs ("errdir_b3a6");      // check not Direct, back here if ok
/* ab7e */                   CMP.imm (0x23);               // compare with "#"
/* ab80 */                   BNE.rel ("_ab92");            // branch if not GET#
/* ab82 */                   JSR.abs ("chrget+0_0073");    // increment and scan memory
/* ab85 */                   JSR.abs ("_b79e");            // get byte parameter
/* ab88 */                   LDA.imm (0x2c);               // set ","
/* ab8a */                   JSR.abs ("chkcom_aeff");      // scan for CHR$(A), else do syntax error then warm start
/* ab8d */                   STX.zpg ("channl_0013");      // set current I/O channel
/* ab8f */                   JSR.abs ("bckin_e11e");       // open channel for input with error check
/* ab92 */        _`_ab92`;  LDX.imm (0x01);               // set pointer low byte
/* ab94 */                   LDY.imm (0x02);               // set pointer high byte
/* ab96 */                   LDA.imm (0x00);               // clear A
/* ab98 */                   STA.abs ("buf+1_0201");       // ensure null terminator
/* ab9b */                   LDA.imm (0x40);               // input mode = GET
/* ab9d */                   JSR.abs ("_ac0f");            // perform the GET part of READ
/* aba0 */                   LDX.zpg ("channl_0013");      // get current I/O channel
/* aba2 */                   BNE.rel ("_abb7");            // if not default channel go do channel close and return
/* aba4 */                   RTS.imp ();

// ------------------------------------------------------- // perform INPUT#
/* aba5 */  _`inputn_aba5`;  JSR.abs ("_b79e");            // get byte parameter
/* aba8 */                   LDA.imm (0x2c);               // set ","
/* abaa */                   JSR.abs ("chkcom_aeff");      // scan for CHR$(A), else do syntax error then warm start
/* abad */                   STX.zpg ("channl_0013");      // set current I/O channel
/* abaf */                   JSR.abs ("bckin_e11e");       // open channel for input with error check
/* abb2 */                   JSR.abs ("_abce");            // perform INPUT with no prompt string

// ------------------------------------------------------- // close input and output channels
/* abb5 */        _`_abb5`;  LDA.zpg ("channl_0013");      // get current I/O channel
/* abb7 */        _`_abb7`;  JSR.abs ("clrchn_ffcc");      // close input and output channels
/* abba */                   LDX.imm (0x00);               // clear X
/* abbc */                   STX.zpg ("channl_0013");      // clear current I/O channel, flag default
/* abbe */                   RTS.imp ();

// ------------------------------------------------------- // perform INPUT
/* abbf */   _`input_abbf`;  CMP.imm (0x22);               // compare next byte with open quote
/* abc1 */                   BNE.rel ("_abce");            // if no prompt string just do INPUT
/* abc3 */                   JSR.abs ("_aebd");            // print "..." string
/* abc6 */                   LDA.imm (0x3b);               // load A with ";"
/* abc8 */                   JSR.abs ("chkcom_aeff");      // scan for CHR$(A), else do syntax error then warm start
/* abcb */                   JSR.abs ("_ab21");            // print string from utility pointer
                                                           // done with prompt, now get data
/* abce */        _`_abce`;  JSR.abs ("errdir_b3a6");      // check not Direct, back here if ok
/* abd1 */                   LDA.imm (0x2c);               // set ","
/* abd3 */                   STA.abs ("bstack+192_01ff");  // save to start of buffer - 1
/* abd6 */        _`_abd6`;  JSR.abs ("qinlin_abf9");      // print "? " and get BASIC input
/* abd9 */                   LDA.zpg ("channl_0013");      // get current I/O channel
/* abdb */                   BEQ.rel ("bufful_abea");      // branch if default I/O channel
/* abdd */                   JSR.abs ("readst_ffb7");      // read I/O status word
/* abe0 */                   AND.imm (0x02);               // mask no DSR/timeout
/* abe2 */                   BEQ.rel ("bufful_abea");      // branch if not error
/* abe4 */                   JSR.abs ("_abb5");            // close input and output channels
/* abe7 */                   JMP.abs ("data_a8f8");        // perform DATA
/* abea */  _`bufful_abea`;  LDA.abs ("buf+0_0200");       // get first byte in input buffer
/* abed */                   BNE.rel ("_ac0d");            // branch if not null
                                                           // else ..
/* abef */                   LDA.zpg ("channl_0013");      // get current I/O channel
/* abf1 */                   BNE.rel ("_abd6");            // if not default channel go get BASIC input
/* abf3 */                   JSR.abs ("datan_a906");       // scan for next BASIC statement ([:] or [EOL])
/* abf6 */                   JMP.abs ("_a8fb");            // add Y to the BASIC execute pointer and return

// ------------------------------------------------------- // print "? " and get BASIC input
/* abf9 */  _`qinlin_abf9`;  LDA.zpg ("channl_0013");      // get current I/O channel
/* abfb */                   BNE.rel ("_ac03");            // skip "?" prompt if not default channel
/* abfd */                   JSR.abs ("_ab45");            // print "?"
/* ac00 */                   JSR.abs ("outspc_ab3b");      // print [SPACE] or [CURSOR RIGHT]
/* ac03 */        _`_ac03`;  JMP.abs ("inlin_a560");       // call for BASIC input and return

// ------------------------------------------------------- // perform READ
/* ac06 */    _`read_ac06`;  LDX.zpg ("datptr+0_0041");    // get DATA pointer low byte
/* ac08 */                   LDY.zpg ("datptr+1_0042");    // get DATA pointer high byte
/* ac0a */                   LDA.imm (0x98);               // set input mode = READ
/* ac0c */                   _.bytes(0x2c);                // makes next line BIT $00A9
/* ac0d */        _`_ac0d`;  LDA.imm (0x00);               // set input mode = INPUT

// ------------------------------------------------------- // perform GET
/* ac0f */        _`_ac0f`;  STA.zpg ("inpflg_0011");      // set input mode flag, $00 = INPUT, $40 = GET, $98 = READ
/* ac11 */                   STX.zpg ("inpptr+0_0043");    // save READ pointer low byte
/* ac13 */                   STY.zpg ("inpptr+1_0044");    // save READ pointer high byte
                                                           // READ, GET or INPUT next variable from list
/* ac15 */        _`_ac15`;  JSR.abs ("ptrget_b08b");      // get variable address
/* ac18 */                   STA.zpg ("forpnt+0_0049");    // save address low byte
/* ac1a */                   STY.zpg ("forpnt+1_004a");    // save address high byte
/* ac1c */                   LDA.zpg ("txtptr+0_007a");    // get BASIC execute pointer low byte
/* ac1e */                   LDY.zpg ("txtptr+1_007b");    // get BASIC execute pointer high byte
/* ac20 */                   STA.zpg ("opptr+0_004b");     // save BASIC execute pointer low byte
/* ac22 */                   STY.zpg ("opptr+1_004c");     // save BASIC execute pointer high byte
/* ac24 */                   LDX.zpg ("inpptr+0_0043");    // get READ pointer low byte
/* ac26 */                   LDY.zpg ("inpptr+1_0044");    // get READ pointer high byte
/* ac28 */                   STX.zpg ("txtptr+0_007a");    // save as BASIC execute pointer low byte
/* ac2a */                   STY.zpg ("txtptr+1_007b");    // save as BASIC execute pointer high byte
/* ac2c */                   JSR.abs ("chrgot_0079");      // scan memory
/* ac2f */                   BNE.rel ("_ac51");            // branch if not null
                                                           // pointer was to null entry
/* ac31 */                   BIT.zpg ("inpflg_0011");      // test input mode flag, $00 = INPUT, $40 = GET, $98 = READ
/* ac33 */                   BVC.rel ("_ac41");            // branch if not GET
                                                           // else was GET
/* ac35 */   _`rdget_ac35`;  JSR.abs ("bgetin_e124");      // get character from input device with error check
/* ac38 */                   STA.abs ("buf+0_0200");       // save to buffer
/* ac3b */                   LDX.imm (0xff);               // set pointer low byte
/* ac3d */                   LDY.imm (0x01);               // set pointer high byte
/* ac3f */                   BNE.rel ("_ac4d");            // go interpret single character
/* ac41 */        _`_ac41`;  BMI.rel ("_acb8");            // branch if READ
                                                           // else was INPUT
/* ac43 */                   LDA.zpg ("channl_0013");      // get current I/O channel
/* ac45 */                   BNE.rel ("_ac4a");            // skip "?" prompt if not default channel
/* ac47 */                   JSR.abs ("_ab45");            // print "?"
/* ac4a */        _`_ac4a`;  JSR.abs ("qinlin_abf9");      // print "? " and get BASIC input
/* ac4d */        _`_ac4d`;  STX.zpg ("txtptr+0_007a");    // save BASIC execute pointer low byte
/* ac4f */                   STY.zpg ("txtptr+1_007b");    // save BASIC execute pointer high byte
/* ac51 */        _`_ac51`;  JSR.abs ("chrget+0_0073");    // increment and scan memory, execute pointer now points to
                                                           // start of next data or null terminator
/* ac54 */                   BIT.zpg ("valtyp_000d");      // test data type flag, $FF = string, $00 = numeric
/* ac56 */                   BPL.rel ("_ac89");            // branch if numeric
                                                           // type is string
/* ac58 */                   BIT.zpg ("inpflg_0011");      // test INPUT mode flag, $00 = INPUT, $40 = GET, $98 = READ
/* ac5a */                   BVC.rel ("_ac65");            // branch if not GET
                                                           // else do string GET
/* ac5c */                   INX.imp ();                   // clear X ??
/* ac5d */                   STX.zpg ("txtptr+0_007a");    // save BASIC execute pointer low byte
/* ac5f */                   LDA.imm (0x00);               // clear A
/* ac61 */                   STA.zpg ("charac_0007");      // clear search character
/* ac63 */                   BEQ.rel ("_ac71");            // branch always
                                                           // is string INPUT or string READ
/* ac65 */        _`_ac65`;  STA.zpg ("charac_0007");      // save search character
/* ac67 */                   CMP.imm (0x22);               // compare with "
/* ac69 */                   BEQ.rel ("_ac72");            // branch if quote
                                                           // string is not in quotes so ":", "," or $00 are the
                                                           // termination characters
/* ac6b */                   LDA.imm (0x3a);               // set ":"
/* ac6d */                   STA.zpg ("charac_0007");      // set search character
/* ac6f */                   LDA.imm (0x2c);               // set ","
/* ac71 */        _`_ac71`;  CLC.imp ();                   // clear carry for add
/* ac72 */        _`_ac72`;  STA.zpg ("endchr_0008");      // set scan quotes flag
/* ac74 */                   LDA.zpg ("txtptr+0_007a");    // get BASIC execute pointer low byte
/* ac76 */                   LDY.zpg ("txtptr+1_007b");    // get BASIC execute pointer high byte
/* ac78 */                   ADC.imm (0x00);               // add to pointer low byte. this add increments the pointer
                                                           // if the mode is INPUT or READ and the data is a "..."
                                                           // string
/* ac7a */                   BCC.rel ("_ac7d");            // branch if no rollover
/* ac7c */                   INY.imp ();                   // else increment pointer high byte
/* ac7d */        _`_ac7d`;  JSR.abs ("_b48d");            // print string to utility pointer
/* ac80 */                   JSR.abs ("_b7e2");            // restore BASIC execute pointer from temp
/* ac83 */                   JSR.abs ("_a9da");            // perform string LET
/* ac86 */                   JMP.abs ("_ac91");            // continue processing command
                                                           // GET, INPUT or READ is numeric
/* ac89 */        _`_ac89`;  JSR.abs ("fin_bcf3");         // get FAC1 from string
/* ac8c */                   LDA.zpg ("intflg_000e");      // get data type flag, $80 = integer, $00 = float
/* ac8e */                   JSR.abs ("_a9c2");            // assign value to numeric variable
/* ac91 */        _`_ac91`;  JSR.abs ("chrgot_0079");      // scan memory
/* ac94 */                   BEQ.rel ("_ac9d");            // branch if ":" or [EOL]
/* ac96 */                   CMP.imm (0x2c);               // comparte with ","
/* ac98 */                   BEQ.rel ("_ac9d");            // branch if ","
/* ac9a */                   JMP.abs ("doagin_ab4d");      // else go do bad input routine
                                                           // string terminated with ":", "," or $00
/* ac9d */        _`_ac9d`;  LDA.zpg ("txtptr+0_007a");    // get BASIC execute pointer low byte
/* ac9f */                   LDY.zpg ("txtptr+1_007b");    // get BASIC execute pointer high byte
/* aca1 */                   STA.zpg ("inpptr+0_0043");    // save READ pointer low byte
/* aca3 */                   STY.zpg ("inpptr+1_0044");    // save READ pointer high byte
/* aca5 */                   LDA.zpg ("opptr+0_004b");     // get saved BASIC execute pointer low byte
/* aca7 */                   LDY.zpg ("opptr+1_004c");     // get saved BASIC execute pointer high byte
/* aca9 */                   STA.zpg ("txtptr+0_007a");    // restore BASIC execute pointer low byte
/* acab */                   STY.zpg ("txtptr+1_007b");    // restore BASIC execute pointer high byte
/* acad */                   JSR.abs ("chrgot_0079");      // scan memory
/* acb0 */                   BEQ.rel ("_acdf");            // branch if ":" or [EOL]
/* acb2 */                   JSR.abs ("_aefd");            // scan for ",", else do syntax error then warm start
/* acb5 */                   JMP.abs ("_ac15");            // go READ or INPUT next variable from list
                                                           // was READ
/* acb8 */        _`_acb8`;  JSR.abs ("datan_a906");       // scan for next BASIC statement ([:] or [EOL])
/* acbb */                   INY.imp ();                   // increment index to next byte
/* acbc */                   TAX.imp ();                   // copy byte to X
/* acbd */                   BNE.rel ("_acd1");            // branch if ":"
/* acbf */                   LDX.imm (0x0d);               // else set error $0D, out of data error
/* acc1 */                   INY.imp ();                   // increment index to next line pointer high byte
/* acc2 */                   LDA.iny ("txtptr+0_007a");    // get next line pointer high byte
/* acc4 */                   BEQ.rel ("_ad32");            // branch if program end, eventually does error X
/* acc6 */                   INY.imp ();                   // increment index
/* acc7 */                   LDA.iny ("txtptr+0_007a");    // get next line # low byte
/* acc9 */                   STA.zpg ("datlin+0_003f");    // save current DATA line low byte
/* accb */                   INY.imp ();                   // increment index
/* accc */                   LDA.iny ("txtptr+0_007a");    // get next line # high byte
/* acce */                   INY.imp ();                   // increment index
/* accf */                   STA.zpg ("datlin+1_0040");    // save current DATA line high byte
/* acd1 */        _`_acd1`;  JSR.abs ("_a8fb");            // add Y to the BASIC execute pointer
/* acd4 */                   JSR.abs ("chrgot_0079");      // scan memory
/* acd7 */                   TAX.imp ();                   // copy the byte
/* acd8 */                   CPX.imm (0x83);               // compare it with token for DATA
/* acda */                   BNE.rel ("_acb8");            // loop if not DATA
/* acdc */                   JMP.abs ("_ac51");            // continue evaluating READ
/* acdf */        _`_acdf`;  LDA.zpg ("inpptr+0_0043");    // get READ pointer low byte
/* ace1 */                   LDY.zpg ("inpptr+1_0044");    // get READ pointer high byte
/* ace3 */                   LDX.zpg ("inpflg_0011");      // get INPUT mode flag, $00 = INPUT, $40 = GET, $98 = READ
/* ace5 */                   BPL.rel ("_acea");            // branch if INPUT or GET
/* ace7 */                   JMP.abs ("_a827");            // else set data pointer and exit
/* acea */        _`_acea`;  LDY.imm (0x00);               // clear index
/* acec */                   LDA.iny ("inpptr+0_0043");    // get READ byte
/* acee */                   BEQ.rel ("_acfb");            // exit if [EOL]
/* acf0 */                   LDA.zpg ("channl_0013");      // get current I/O channel
/* acf2 */                   BNE.rel ("_acfb");            // exit if not default channel
/* acf4 */                   LDA.imm (0xfc);               // set "?EXTRA IGNORED" pointer low byte
/* acf6 */                   LDY.imm (0xac);               // set "?EXTRA IGNORED" pointer high byte
/* acf8 */                   JMP.abs ("strout_ab1e");      // print null terminated string
/* acfb */        _`_acfb`;  RTS.imp ();

// ------------------------------------------------------- // input error messages
                                                           // '?extra ignored'
/* acfc */   _`exint_acfc`;  _.bytes(0x3f, 0x45, 0x58, 0x54, 0x52, 0x41, 0x20, 0x49);
/* ad04 */                   _.bytes(0x47, 0x4e, 0x4f, 0x52, 0x45, 0x44, 0x0d, 0x00);
                                                           // '?redo from start'
/* ad0c */                   _.bytes(0x3f, 0x52, 0x45, 0x44, 0x4f, 0x20, 0x46, 0x52);
/* ad14 */                   _.bytes(0x4f, 0x4d, 0x20, 0x53, 0x54, 0x41, 0x52, 0x54);
/* ad1c */                   _.bytes(0x0d, 0x00);

// ------------------------------------------------------- // perform NEXT
/* ad1e */    _`next_ad1e`;  BNE.rel ("_ad24");            // branch if NEXT variable
/* ad20 */                   LDY.imm (0x00);               // else clear Y
/* ad22 */                   BEQ.rel ("_ad27");            // branch always
                                                           // NEXT variable
/* ad24 */        _`_ad24`;  JSR.abs ("ptrget_b08b");      // get variable address
/* ad27 */        _`_ad27`;  STA.zpg ("forpnt+0_0049");    // save FOR/NEXT variable pointer low byte
/* ad29 */                   STY.zpg ("forpnt+1_004a");    // save FOR/NEXT variable pointer high byte
                                                           // (high byte cleared if no variable defined)
/* ad2b */                   JSR.abs ("fndfor_a38a");      // search the stack for FOR or GOSUB activity
/* ad2e */                   BEQ.rel ("_ad35");            // branch if FOR, this variable, found
/* ad30 */                   LDX.imm (0x0a);               // else set error $0A, next without for error
/* ad32 */        _`_ad32`;  JMP.abs ("error_a437");       // do error #X then warm start
                                                           // found this FOR variable
/* ad35 */        _`_ad35`;  TXS.imp ();                   // update stack pointer
/* ad36 */                   TXA.imp ();                   // copy stack pointer
/* ad37 */                   CLC.imp ();                   // clear carry for add
/* ad38 */                   ADC.imm (0x04);               // point to STEP value
/* ad3a */                   PHA.imp ();                   // save it
/* ad3b */                   ADC.imm (0x06);               // point to TO value
/* ad3d */                   STA.zpg ("index+2_0024");     // save pointer to TO variable for compare
/* ad3f */                   PLA.imp ();                   // restore pointer to STEP value
/* ad40 */                   LDY.imm (0x01);               // point to stack page
/* ad42 */                   JSR.abs ("movfm_bba2");       // unpack memory (AY) into FAC1
/* ad45 */                   TSX.imp ();                   // get stack pointer back
/* ad46 */                   LDA.abx ("bad+9_0109");       // get step sign
/* ad49 */                   STA.zpg ("facsgn_0066");      // save FAC1 sign (b7)
/* ad4b */                   LDA.zpg ("forpnt+0_0049");    // get FOR/NEXT variable pointer low byte
/* ad4d */                   LDY.zpg ("forpnt+1_004a");    // get FOR/NEXT variable pointer high byte
/* ad4f */                   JSR.abs ("fadd_b867");        // add FOR variable to FAC1
/* ad52 */                   JSR.abs ("_bbd0");            // pack FAC1 into FOR variable
/* ad55 */                   LDY.imm (0x01);               // point to stack page
/* ad57 */                   JSR.abs ("_bc5d");            // compare FAC1 with TO value
/* ad5a */                   TSX.imp ();                   // get stack pointer back
/* ad5b */                   SEC.imp ();                   // set carry for subtract
/* ad5c */                   SBC.abx ("bad+9_0109");       // subtract step sign
/* ad5f */                   BEQ.rel ("_ad78");            // branch if =, loop complete
                                                           // loop back and do it all again
/* ad61 */  _`donext_ad61`;  LDA.abx ("bad+15_010f");      // get FOR line low byte
/* ad64 */                   STA.zpg ("curlin+0_0039");    // save current line number low byte
/* ad66 */                   LDA.abx ("bad+16_0110");      // get FOR line high byte
/* ad69 */                   STA.zpg ("curlin+1_003a");    // save current line number high byte
/* ad6b */                   LDA.abx ("bad+18_0112");      // get BASIC execute pointer low byte
/* ad6e */                   STA.zpg ("txtptr+0_007a");    // save BASIC execute pointer low byte
/* ad70 */                   LDA.abx ("bad+17_0111");      // get BASIC execute pointer high byte
/* ad73 */                   STA.zpg ("txtptr+1_007b");    // save BASIC execute pointer high byte
/* ad75 */        _`_ad75`;  JMP.abs ("newstt_a7ae");      // go do interpreter inner loop
                                                           // NEXT loop comlete
/* ad78 */        _`_ad78`;  TXA.imp ();                   // stack copy to A
/* ad79 */                   ADC.imm (0x11);               // add $12, $11 + carry, to dump FOR structure
/* ad7b */                   TAX.imp ();                   // copy back to index
/* ad7c */                   TXS.imp ();                   // copy to stack pointer
/* ad7d */                   JSR.abs ("chrgot_0079");      // scan memory
/* ad80 */                   CMP.imm (0x2c);               // compare with ","
/* ad82 */                   BNE.rel ("_ad75");            // if not "," go do interpreter inner loop
                                                           // was "," so another NEXT variable to do
/* ad84 */                   JSR.abs ("chrget+0_0073");    // increment and scan memory
/* ad87 */                   JSR.abs ("_ad24");            // do NEXT variable

// ------------------------------------------------------- // evaluate expression and check type mismatch
/* ad8a */  _`frmnum_ad8a`;  JSR.abs ("frmevl_ad9e");      // evaluate expression
                                                           // check if source and destination are numeric
/* ad8d */        _`_ad8d`;  CLC.imp ();
/* ad8e */                   _.bytes(0x24);                // makes next line BIT $38
                                                           // check if source and destination are string
/* ad8f */        _`_ad8f`;  SEC.imp ();                   // destination is string
                                                           // type match check, set C for string, clear C for numeric
/* ad90 */        _`_ad90`;  BIT.zpg ("valtyp_000d");      // test data type flag, $FF = string, $00 = numeric
/* ad92 */                   BMI.rel ("_ad97");            // branch if string
/* ad94 */                   BCS.rel ("_ad99");            // if destiantion is numeric do type missmatch error
/* ad96 */        _`_ad96`;  RTS.imp ();
/* ad97 */        _`_ad97`;  BCS.rel ("_ad96");            // exit if destination is string
                                                           // do type missmatch error
/* ad99 */        _`_ad99`;  LDX.imm (0x16);               // error code $16, type missmatch error
/* ad9b */                   JMP.abs ("error_a437");       // do error #X then warm start

// ------------------------------------------------------- // evaluate expression
/* ad9e */  _`frmevl_ad9e`;  LDX.zpg ("txtptr+0_007a");    // get BASIC execute pointer low byte
/* ada0 */                   BNE.rel ("_ada4");            // skip next if not zero
/* ada2 */                   DEC.zpg ("txtptr+1_007b");    // else decrement BASIC execute pointer high byte
/* ada4 */        _`_ada4`;  DEC.zpg ("txtptr+0_007a");    // decrement BASIC execute pointer low byte
/* ada6 */                   LDX.imm (0x00);               // set null precedence, flag done
/* ada8 */                   _.bytes(0x24);                // makes next line BIT $48
/* ada9 */        _`_ada9`;  PHA.imp ();                   // push compare evaluation byte if branch to here
/* adaa */                   TXA.imp ();                   // copy precedence byte
/* adab */                   PHA.imp ();                   // push precedence byte
/* adac */                   LDA.imm (0x01);               // 2 bytes
/* adae */                   JSR.abs ("getstk_a3fb");      // check room on stack for A*2 bytes
/* adb1 */                   JSR.abs ("eval_ae83");        // get value from line
/* adb4 */                   LDA.imm (0x00);               // clear A
/* adb6 */                   STA.zpg ("opmask_004d");      // clear comparrison evaluation flag
/* adb8 */        _`_adb8`;  JSR.abs ("chrgot_0079");      // scan memory
/* adbb */        _`_adbb`;  SEC.imp ();                   // set carry for subtract
/* adbc */                   SBC.imm (0xb1);               // subtract the token for ">"
/* adbe */                   BCC.rel ("_add7");            // branch if < ">"
/* adc0 */                   CMP.imm (0x03);               // compare with ">" to +3
/* adc2 */                   BCS.rel ("_add7");            // branch if >= 3
                                                           // was token for ">" "=" or "<"
/* adc4 */                   CMP.imm (0x01);               // compare with token for =
/* adc6 */                   ROL.acc ();                   // *2, b0 = carry (=1 if token was = or <)
/* adc7 */                   EOR.imm (0x01);               // toggle b0
/* adc9 */                   EOR.zpg ("opmask_004d");      // EOR with comparrison evaluation flag
/* adcb */                   CMP.zpg ("opmask_004d");      // compare with comparrison evaluation flag
/* adcd */                   BCC.rel ("_ae30");            // if < saved flag do syntax error then warm start
/* adcf */                   STA.zpg ("opmask_004d");      // save new comparrison evaluation flag
/* add1 */                   JSR.abs ("chrget+0_0073");    // increment and scan memory
/* add4 */                   JMP.abs ("_adbb");            // go do next character
/* add7 */        _`_add7`;  LDX.zpg ("opmask_004d");      // get comparrison evaluation flag
/* add9 */                   BNE.rel ("_ae07");            // branch if compare function
/* addb */                   BCS.rel ("_ae58");            // go do functions
                                                           // else was < TK_GT so is operator or lower
/* addd */                   ADC.imm (0x07);               // add # of operators (+, -, *, /, ^, AND or OR)
/* addf */                   BCC.rel ("_ae58");            // branch if < + operator
                                                           // carry was set so token was +, -, *, /, ^, AND or OR
/* ade1 */                   ADC.zpg ("valtyp_000d");      // add data type flag, $FF = string, $00 = numeric
/* ade3 */                   BNE.rel ("_ade8");            // branch if not string or not + token
                                                           // will only be $00 if type is string and token was +
/* ade5 */                   JMP.abs ("cat_b63d");         // add strings, string 1 is in the descriptor, string 2
                                                           // is in line, and return
/* ade8 */        _`_ade8`;  ADC.imm (0xff);               // -1 (corrects for carry add)
/* adea */                   STA.zpg ("index+0_0022");     // save it
/* adec */                   ASL.acc ();                   // *2
/* aded */                   ADC.zpg ("index+0_0022");     // *3
/* adef */                   TAY.imp ();                   // copy to index
/* adf0 */        _`_adf0`;  PLA.imp ();                   // pull previous precedence
/* adf1 */                   CMP.aby ("optab_a080");       // compare with precedence byte
/* adf4 */                   BCS.rel ("_ae5d");            // branch if A >=
/* adf6 */                   JSR.abs ("_ad8d");            // check if source is numeric, else do type mismatch
/* adf9 */        _`_adf9`;  PHA.imp ();                   // save precedence
/* adfa */        _`_adfa`;  JSR.abs ("_ae20");            // get vector, execute function then continue evaluation
/* adfd */                   PLA.imp ();                   // restore precedence
/* adfe */                   LDY.zpg ("opptr+0_004b");     // get precedence stacked flag
/* ae00 */                   BPL.rel ("_ae19");            // branch if stacked values
/* ae02 */                   TAX.imp ();                   // copy precedence, set flags
/* ae03 */                   BEQ.rel ("_ae5b");            // exit if done
/* ae05 */                   BNE.rel ("_ae66");            // else pop FAC2 and return, branch always
/* ae07 */        _`_ae07`;  LSR.zpg ("valtyp_000d");      // clear data type flag, $FF = string, $00 = numeric
/* ae09 */                   TXA.imp ();                   // copy compare function flag
/* ae0a */                   ROL.acc ();                   // <<1, shift data type flag into b0, 1 = string, 0 = num
/* ae0b */                   LDX.zpg ("txtptr+0_007a");    // get BASIC execute pointer low byte
/* ae0d */                   BNE.rel ("_ae11");            // branch if no underflow
/* ae0f */                   DEC.zpg ("txtptr+1_007b");    // else decrement BASIC execute pointer high byte
/* ae11 */        _`_ae11`;  DEC.zpg ("txtptr+0_007a");    // decrement BASIC execute pointer low byte
/* ae13 */                   LDY.imm (0x1b);
                                                           // set offset to = operator precedence entry
/* ae15 */                   STA.zpg ("opmask_004d");      // save new comparrison evaluation flag
/* ae17 */                   BNE.rel ("_adf0");            // branch always
/* ae19 */        _`_ae19`;  CMP.aby ("optab_a080");       // compare with stacked function precedence
/* ae1c */                   BCS.rel ("_ae66");            // if A >=, pop FAC2 and return
/* ae1e */                   BCC.rel ("_adf9");            // else go stack this one and continue, branch always

// ------------------------------------------------------- // get vector, execute function then continue evaluation
/* ae20 */        _`_ae20`;  LDA.aby (0xa082);             // get function vector high byte
/* ae23 */                   PHA.imp ();                   // onto stack
/* ae24 */                   LDA.aby (0xa081);             // get function vector low byte
/* ae27 */                   PHA.imp ();                   // onto stack
                                                           // now push sign, round FAC1 and put on stack
/* ae28 */                   JSR.abs ("_ae33");            // function will return here, then the next RTS will call
                                                           // the function
/* ae2b */                   LDA.zpg ("opmask_004d");      // get comparrison evaluation flag
/* ae2d */                   JMP.abs ("_ada9");            // continue evaluating expression
/* ae30 */        _`_ae30`;  JMP.abs ("synerr_af08");      // do syntax error then warm start
/* ae33 */        _`_ae33`;  LDA.zpg ("facsgn_0066");      // get FAC1 sign (b7)
/* ae35 */                   LDX.aby ("optab_a080");       // get precedence byte

// ------------------------------------------------------- // push sign, round FAC1 and put on stack
/* ae38 */        _`_ae38`;  TAY.imp ();                   // copy sign
/* ae39 */                   PLA.imp ();                   // get return address low byte
/* ae3a */                   STA.zpg ("index+0_0022");     // save it
/* ae3c */                   INC.zpg ("index+0_0022");     // increment it as return-1 is pushed
                                                           // note, no check is made on the high byte so if the calling
                                                           // routine ever assembles to a page edge then this all goes
                                                           // horribly wrong!
/* ae3e */                   PLA.imp ();                   // get return address high byte
/* ae3f */                   STA.zpg ("index+1_0023");     // save it
/* ae41 */                   TYA.imp ();                   // restore sign
/* ae42 */                   PHA.imp ();                   // push sign

// ------------------------------------------------------- // round FAC1 and put on stack
/* ae43 */        _`_ae43`;  JSR.abs ("round_bc1b");       // round FAC1
/* ae46 */                   LDA.zpg ("facho+3_0065");     // get FAC1 mantissa 4
/* ae48 */                   PHA.imp ();                   // save it
/* ae49 */                   LDA.zpg ("facho+2_0064");     // get FAC1 mantissa 3
/* ae4b */                   PHA.imp ();                   // save it
/* ae4c */                   LDA.zpg ("facho+1_0063");     // get FAC1 mantissa 2
/* ae4e */                   PHA.imp ();                   // save it
/* ae4f */                   LDA.zpg ("facho+0_0062");     // get FAC1 mantissa 1
/* ae51 */                   PHA.imp ();                   // save it
/* ae52 */                   LDA.zpg ("facexp_0061");      // get FAC1 exponent
/* ae54 */                   PHA.imp ();                   // save it
/* ae55 */                   JMP.ind ("index+0_0022");     // return, sort of

// ------------------------------------------------------- // do functions
/* ae58 */        _`_ae58`;  LDY.imm (0xff);               // flag function
/* ae5a */                   PLA.imp ();                   // pull precedence byte
/* ae5b */        _`_ae5b`;  BEQ.rel ("_ae80");            // exit if done
/* ae5d */        _`_ae5d`;  CMP.imm (0x64);               // compare previous precedence with $64
/* ae5f */                   BEQ.rel ("_ae64");            // branch if was $64 (< function)
/* ae61 */                   JSR.abs ("_ad8d");            // check if source is numeric, else do type mismatch
/* ae64 */        _`_ae64`;  STY.zpg ("opptr+0_004b");     // save precedence stacked flag
                                                           // pop FAC2 and return
/* ae66 */        _`_ae66`;  PLA.imp ();                   // pop byte
/* ae67 */                   LSR.acc ();                   // shift out comparison evaluation lowest bit
/* ae68 */                   STA.zpg ("tansgn_0012");      // save the comparison evaluation flag
/* ae6a */                   PLA.imp ();                   // pop exponent
/* ae6b */                   STA.zpg ("argexp_0069");      // save FAC2 exponent
/* ae6d */                   PLA.imp ();                   // pop mantissa 1
/* ae6e */                   STA.zpg ("argho+0_006a");     // save FAC2 mantissa 1
/* ae70 */                   PLA.imp ();                   // pop mantissa 2
/* ae71 */                   STA.zpg ("argho+1_006b");     // save FAC2 mantissa 2
/* ae73 */                   PLA.imp ();                   // pop mantissa 3
/* ae74 */                   STA.zpg ("argho+2_006c");     // save FAC2 mantissa 3
/* ae76 */                   PLA.imp ();                   // pop mantissa 4
/* ae77 */                   STA.zpg ("argho+3_006d");     // save FAC2 mantissa 4
/* ae79 */                   PLA.imp ();                   // pop sign
/* ae7a */                   STA.zpg ("argsgn_006e");      // save FAC2 sign (b7)
/* ae7c */                   EOR.zpg ("facsgn_0066");      // EOR FAC1 sign (b7)
/* ae7e */                   STA.zpg ("arisgn_006f");      // save sign compare (FAC1 EOR FAC2)
/* ae80 */        _`_ae80`;  LDA.zpg ("facexp_0061");      // get FAC1 exponent
/* ae82 */                   RTS.imp ();

// ------------------------------------------------------- // get value from line
/* ae83 */    _`eval_ae83`;  JMP.ind ("ieval+0_030a");     // get arithmetic element

// ------------------------------------------------------- // get arithmetic element, the get arithmetic element vector is initialised to point here
/* ae86 */                   LDA.imm (0x00);               // clear byte
/* ae88 */                   STA.zpg ("valtyp_000d");      // clear data type flag, $FF = string, $00 = numeric
/* ae8a */        _`_ae8a`;  JSR.abs ("chrget+0_0073");    // increment and scan memory
/* ae8d */                   BCS.rel ("_ae92");            // branch if not numeric character
                                                           // else numeric string found (e.g. 123)
/* ae8f */        _`_ae8f`;  JMP.abs ("fin_bcf3");         // get FAC1 from string and return
                                                           // get value from line .. continued
                                                           // wasn't a number so ...
/* ae92 */        _`_ae92`;  JSR.abs ("isletc_b113");      // check byte, return Cb = 0 if<"A" or >"Z"
/* ae95 */                   BCC.rel ("_ae9a");            // branch if not variable name
/* ae97 */                   JMP.abs ("isvar_af28");       // variable name set-up and return
/* ae9a */        _`_ae9a`;  CMP.imm (0xff);               // compare with token for PI
/* ae9c */                   BNE.rel ("qdot_aead");        // branch if not PI
/* ae9e */                   LDA.imm (0xa8);               // get PI pointer low byte
/* aea0 */                   LDY.imm (0xae);               // get PI pointer high byte
/* aea2 */                   JSR.abs ("movfm_bba2");       // unpack memory (AY) into FAC1
/* aea5 */                   JMP.abs ("chrget+0_0073");    // increment and scan memory and return

// ------------------------------------------------------- // PI as floating number
                                                           // 3.141592653
/* aea8 */   _`pival_aea8`;  _.bytes(0x82, 0x49, 0x0f, 0xda, 0xa1);

// ------------------------------------------------------- // get value from line .. continued
                                                           // wasn't variable name so ...
/* aead */    _`qdot_aead`;  CMP.imm (0x2e);               // compare with "."
/* aeaf */                   BEQ.rel ("_ae8f");            // if so get FAC1 from string and return, e.g. was .123
                                                           // wasn't .123 so ...
/* aeb1 */                   CMP.imm (0xab);               // compare with token for -
/* aeb3 */                   BEQ.rel ("domin_af0d");       // branch if - token, do set-up for functions
                                                           // wasn't -123 so ...
/* aeb5 */                   CMP.imm (0xaa);               // compare with token for +
/* aeb7 */                   BEQ.rel ("_ae8a");            // branch if + token, +1 = 1 so ignore leading +
                                                           // it wasn't any sort of number so ...
/* aeb9 */                   CMP.imm (0x22);               // compare with "
/* aebb */                   BNE.rel ("_aecc");            // branch if not open quote
                                                           // was open quote so get the enclosed string

// ------------------------------------------------------- // print "..." string to string utility area
/* aebd */        _`_aebd`;  LDA.zpg ("txtptr+0_007a");    // get BASIC execute pointer low byte
/* aebf */                   LDY.zpg ("txtptr+1_007b");    // get BASIC execute pointer high byte
/* aec1 */                   ADC.imm (0x00);               // add carry to low byte
/* aec3 */                   BCC.rel ("_aec6");            // branch if no overflow
/* aec5 */                   INY.imp ();                   // increment high byte
/* aec6 */        _`_aec6`;  JSR.abs ("strlit_b487");      // print " terminated string to utility pointer
/* aec9 */                   JMP.abs ("_b7e2");            // restore BASIC execute pointer from temp and return
                                                           // get value from line .. continued
                                                           // wasn't a string so ...
/* aecc */        _`_aecc`;  CMP.imm (0xa8);               // compare with token for NOT
/* aece */                   BNE.rel ("_aee3");            // branch if not token for NOT
                                                           // was NOT token
/* aed0 */                   LDY.imm (0x18);               // offset to NOT function
/* aed2 */                   BNE.rel ("_af0f");            // do set-up for function then execute, branch always
                                                           // do = compare
/* aed4 */                   JSR.abs ("ayint_b1bf");       // evaluate integer expression, no sign check
/* aed7 */                   LDA.zpg ("facho+3_0065");     // get FAC1 mantissa 4
/* aed9 */                   EOR.imm (0xff);               // invert it
/* aedb */                   TAY.imp ();                   // copy it
/* aedc */                   LDA.zpg ("facho+2_0064");     // get FAC1 mantissa 3
/* aede */                   EOR.imm (0xff);               // invert it
/* aee0 */                   JMP.abs ("givayf_b391");      // convert fixed integer AY to float FAC1 and return
                                                           // get value from line .. continued
                                                           // wasn't a string or NOT so ...
/* aee3 */        _`_aee3`;  CMP.imm (0xa5);               // compare with token for FN
/* aee5 */                   BNE.rel ("_aeea");            // branch if not token for FN
/* aee7 */                   JMP.abs ("fndoer_b3f4");      // else go evaluate FNx
                                                           // get value from line .. continued
                                                           // wasn't a string, NOT or FN so ...
/* aeea */        _`_aeea`;  CMP.imm (0xb4);               // compare with token for SGN
/* aeec */                   BCC.rel ("parchk_aef1");      // if less than SGN token evaluate expression in parentheses
                                                           // else was a function token
/* aeee */                   JMP.abs ("isfun_afa7");       // go set up function references, branch always
                                                           // get value from line .. continued
                                                           // if here it can only be something in brackets so ....
                                                           // evaluate expression within parentheses
/* aef1 */  _`parchk_aef1`;  JSR.abs ("chkopn_aefa");      // scan for "(", else do syntax error then warm start
/* aef4 */                   JSR.abs ("frmevl_ad9e");      // evaluate expression
                                                           // all the 'scan for' routines return the character after the sought character
                                                           // scan for ")", else do syntax error then warm start
/* aef7 */  _`chkcls_aef7`;  LDA.imm (0x29);               // load A with ")"
/* aef9 */                   _.bytes(0x2c);                // makes next line BIT $28A9
                                                           // scan for "(", else do syntax error then warm start
/* aefa */  _`chkopn_aefa`;  LDA.imm (0x28);               // load A with "("
/* aefc */                   _.bytes(0x2c);                // makes next line BIT $2CA9
                                                           // scan for ",", else do syntax error then warm start
/* aefd */        _`_aefd`;  LDA.imm (0x2c);               // load A with ","
                                                           // scan for CHR$(A), else do syntax error then warm start
/* aeff */  _`chkcom_aeff`;  LDY.imm (0x00);               // clear index
/* af01 */                   CMP.iny ("txtptr+0_007a");    // compare with BASIC byte
/* af03 */                   BNE.rel ("synerr_af08");      // if not expected byte do syntax error then warm start
/* af05 */                   JMP.abs ("chrget+0_0073");    // else increment and scan memory and return
                                                           // syntax error then warm start
/* af08 */  _`synerr_af08`;  LDX.imm (0x0b);               // error code $0B, syntax error
/* af0a */                   JMP.abs ("error_a437");       // do error #X then warm start
/* af0d */   _`domin_af0d`;  LDY.imm (0x15);               // set offset from base to > operator
/* af0f */        _`_af0f`;  PLA.imp ();                   // dump return address low byte
/* af10 */                   PLA.imp ();                   // dump return address high byte
/* af11 */                   JMP.abs ("_adfa");            // execute function then continue evaluation

// ------------------------------------------------------- // check address range, return Cb = 1 if address in BASIC ROM
/* af14 */  _`rsvvar_af14`;  SEC.imp ();                   // set carry for subtract
/* af15 */                   LDA.zpg ("facho+2_0064");     // get variable address low byte
/* af17 */                   SBC.imm (0x00);               // subtract $A000 low byte
/* af19 */                   LDA.zpg ("facho+3_0065");     // get variable address high byte
/* af1b */                   SBC.imm (0xa0);               // subtract $A000 high byte
/* af1d */                   BCC.rel ("_af27");            // exit if address < $A000
/* af1f */                   LDA.imm (0xa2);               // get end of BASIC marker low byte
/* af21 */                   SBC.zpg ("facho+2_0064");     // subtract variable address low byte
/* af23 */                   LDA.imm (0xe3);               // get end of BASIC marker high byte
/* af25 */                   SBC.zpg ("facho+3_0065");     // subtract variable address high byte
/* af27 */        _`_af27`;  RTS.imp ();

// ------------------------------------------------------- // variable name set-up
/* af28 */   _`isvar_af28`;  JSR.abs ("ptrget_b08b");      // get variable address
/* af2b */  _`isvret_af2b`;  STA.zpg ("facho+2_0064");     // save variable pointer low byte
/* af2d */                   STY.zpg ("facho+3_0065");     // save variable pointer high byte
/* af2f */                   LDX.zpg ("varnam+0_0045");    // get current variable name first character
/* af31 */                   LDY.zpg ("varnam+1_0046");    // get current variable name second character
/* af33 */                   LDA.zpg ("valtyp_000d");      // get data type flag, $FF = string, $00 = numeric
/* af35 */                   BEQ.rel ("_af5d");            // branch if numeric
                                                           // variable is string
/* af37 */                   LDA.imm (0x00);               // else clear A
/* af39 */                   STA.zpg ("facov_0070");       // clear FAC1 rounding byte
/* af3b */                   JSR.abs ("rsvvar_af14");      // check address range
/* af3e */                   BCC.rel ("_af5c");            // exit if not in BASIC ROM
/* af40 */                   CPX.imm (0x54);               // compare variable name first character with "T"
/* af42 */                   BNE.rel ("_af5c");            // exit if not "T"
/* af44 */                   CPY.imm (0xc9);               // compare variable name second character with "I$"
/* af46 */                   BNE.rel ("_af5c");            // exit if not "I$"
                                                           // variable name was "TI$"
/* af48 */  _`tisasc_af48`;  JSR.abs ("_af84");            // read real time clock into FAC1 mantissa, 0HML
/* af4b */                   STY.zpg ("tempf2+2_005e");    // clear exponent count adjust
/* af4d */                   DEY.imp ();                   // Y = $FF
/* af4e */                   STY.zpg ("fbufpt+0_0071");    // set output string index, -1 to allow for pre increment
/* af50 */                   LDY.imm (0x06);               // HH:MM:SS is six digits
/* af52 */                   STY.zpg ("tempf2+1_005d");    // set number of characters before the decimal point
/* af54 */                   LDY.imm (0x24);
                                                           // index to jiffy conversion table
/* af56 */                   JSR.abs ("foutim_be68");      // convert jiffy count to string
/* af59 */                   JMP.abs ("_b46f");            // exit via STR$() code tail
/* af5c */        _`_af5c`;  RTS.imp ();
                                                           // variable name set-up, variable is numeric
/* af5d */        _`_af5d`;  BIT.zpg ("intflg_000e");      // test data type flag, $80 = integer, $00 = float
/* af5f */                   BPL.rel ("_af6e");            // branch if float
/* af61 */                   LDY.imm (0x00);               // clear index
/* af63 */                   LDA.iny ("facho+2_0064");     // get integer variable low byte
/* af65 */                   TAX.imp ();                   // copy to X
/* af66 */                   INY.imp ();                   // increment index
/* af67 */                   LDA.iny ("facho+2_0064");     // get integer variable high byte
/* af69 */                   TAY.imp ();                   // copy to Y
/* af6a */                   TXA.imp ();                   // copy loa byte to A
/* af6b */                   JMP.abs ("givayf_b391");      // convert fixed integer AY to float FAC1 and return
                                                           // variable name set-up, variable is float
/* af6e */        _`_af6e`;  JSR.abs ("rsvvar_af14");      // check address range
/* af71 */                   BCC.rel ("_afa0");            // if not in BASIC ROM get pointer and unpack into FAC1
/* af73 */                   CPX.imm (0x54);               // compare variable name first character with "T"
/* af75 */                   BNE.rel ("_af92");            // branch if not "T"
/* af77 */                   CPY.imm (0x49);               // compare variable name second character with "I"
/* af79 */                   BNE.rel ("_afa0");            // branch if not "I"
                                                           // variable name was "TI"
/* af7b */                   JSR.abs ("_af84");            // read real time clock into FAC1 mantissa, 0HML
/* af7e */                   TYA.imp ();                   // clear A
/* af7f */                   LDX.imm (0xa0);               // set exponent to 32 bit value
/* af81 */                   JMP.abs ("_bc4f");            // set exponent = X and normalise FAC1

// ------------------------------------------------------- // read real time clock into FAC1 mantissa, 0HML
/* af84 */        _`_af84`;  JSR.abs ("rdtim_ffde");       // read real time clock
/* af87 */                   STX.zpg ("facho+2_0064");     // save jiffy clock mid byte as  FAC1 mantissa 3
/* af89 */                   STY.zpg ("facho+1_0063");     // save jiffy clock high byte as  FAC1 mantissa 2
/* af8b */                   STA.zpg ("facho+3_0065");     // save jiffy clock low byte as  FAC1 mantissa 4
/* af8d */                   LDY.imm (0x00);               // clear Y
/* af8f */                   STY.zpg ("facho+0_0062");     // clear FAC1 mantissa 1
/* af91 */                   RTS.imp ();
                                                           // variable name set-up, variable is float and not "Tx"
/* af92 */        _`_af92`;  CPX.imm (0x53);               // compare variable name first character with "S"
/* af94 */                   BNE.rel ("_afa0");            // if not "S" go do normal floating variable
/* af96 */                   CPY.imm (0x54);               // compare variable name second character with "
/* af98 */                   BNE.rel ("_afa0");            // if not "T" go do normal floating variable
                                                           // variable name was "ST"
/* af9a */                   JSR.abs ("readst_ffb7");      // read I/O status word
/* af9d */                   JMP.abs ("_bc3c");            // save A as integer byte and return
                                                           // variable is float
/* afa0 */        _`_afa0`;  LDA.zpg ("facho+2_0064");     // get variable pointer low byte
/* afa2 */                   LDY.zpg ("facho+3_0065");     // get variable pointer high byte
/* afa4 */                   JMP.abs ("movfm_bba2");       // unpack memory (AY) into FAC1

// ------------------------------------------------------- // get value from line continued
                                                           // only functions left so ..
                                                           // set up function references
/* afa7 */   _`isfun_afa7`;  ASL.acc ();                   // *2 (2 bytes per function address)
/* afa8 */                   PHA.imp ();                   // save function offset
/* afa9 */                   TAX.imp ();                   // copy function offset
/* afaa */                   JSR.abs ("chrget+0_0073");    // increment and scan memory
/* afad */                   CPX.imm (0x8f);               // compare function offset to CHR$ token offset+1
/* afaf */                   BCC.rel ("numfun_afd1");      // branch if < LEFT$ (can not be =)
                                                           // get value from line .. continued
                                                           // was LEFT$, RIGHT$ or MID$ so..
/* afb1 */  _`strfun_afb1`;  JSR.abs ("chkopn_aefa");      // scan for "(", else do syntax error then warm start
/* afb4 */                   JSR.abs ("frmevl_ad9e");      // evaluate, should be string, expression
/* afb7 */                   JSR.abs ("_aefd");            // scan for ",", else do syntax error then warm start
/* afba */                   JSR.abs ("_ad8f");            // check if source is string, else do type mismatch
/* afbd */                   PLA.imp ();                   // restore function offset
/* afbe */                   TAX.imp ();                   // copy it
/* afbf */                   LDA.zpg ("facho+3_0065");     // get descriptor pointer high byte
/* afc1 */                   PHA.imp ();                   // push string pointer high byte
/* afc2 */                   LDA.zpg ("facho+2_0064");     // get descriptor pointer low byte
/* afc4 */                   PHA.imp ();                   // push string pointer low byte
/* afc5 */                   TXA.imp ();                   // restore function offset
/* afc6 */                   PHA.imp ();                   // save function offset
/* afc7 */                   JSR.abs ("_b79e");            // get byte parameter
/* afca */                   PLA.imp ();                   // restore function offset
/* afcb */                   TAY.imp ();                   // copy function offset
/* afcc */                   TXA.imp ();                   // copy byte parameter to A
/* afcd */                   PHA.imp ();                   // push byte parameter
/* afce */                   JMP.abs ("_afd6");            // go call function
                                                           // get value from line .. continued
                                                           // was SGN() to CHR$() so..
/* afd1 */  _`numfun_afd1`;  JSR.abs ("parchk_aef1");      // evaluate expression within parentheses
/* afd4 */                   PLA.imp ();                   // restore function offset
/* afd5 */                   TAY.imp ();                   // copy to index
/* afd6 */        _`_afd6`;  LDA.aby ("_9fea");            // get function jump vector low byte
/* afd9 */                   STA.zpg ("jmper+1_0055");     // save functions jump vector low byte
/* afdb */                   LDA.aby ("_9feb");            // get function jump vector high byte
/* afde */                   STA.zpg ("jmper+2_0056");     // save functions jump vector high byte
/* afe0 */                   JSR.abs ("jmper+0_0054");     // do function call
/* afe3 */                   JMP.abs ("_ad8d");            // check if source is numeric and RTS, else do type mismatch
                                                           // string functions avoid this by dumping the return address

// ------------------------------------------------------- // perform OR
                                                           // this works because NOT(NOT(x) AND NOT(y)) = x OR y
/* afe6 */    _`orop_afe6`;  LDY.imm (0xff);               // set Y for OR
/* afe8 */                   _.bytes(0x2c);                // makes next line BIT $00A0

// ------------------------------------------------------- // perform AND
/* afe9 */   _`andop_afe9`;  LDY.imm (0x00);               // clear Y for AND
/* afeb */                   STY.zpg ("count_000b");       // set AND/OR invert value
/* afed */                   JSR.abs ("ayint_b1bf");       // evaluate integer expression, no sign check
/* aff0 */                   LDA.zpg ("facho+2_0064");     // get FAC1 mantissa 3
/* aff2 */                   EOR.zpg ("count_000b");       // EOR low byte
/* aff4 */                   STA.zpg ("charac_0007");      // save it
/* aff6 */                   LDA.zpg ("facho+3_0065");     // get FAC1 mantissa 4
/* aff8 */                   EOR.zpg ("count_000b");       // EOR high byte
/* affa */                   STA.zpg ("endchr_0008");      // save it
/* affc */                   JSR.abs ("movfa_bbfc");       // copy FAC2 to FAC1, get 2nd value in expression
/* afff */                   JSR.abs ("ayint_b1bf");       // evaluate integer expression, no sign check
/* b002 */                   LDA.zpg ("facho+3_0065");     // get FAC1 mantissa 4
/* b004 */                   EOR.zpg ("count_000b");       // EOR high byte
/* b006 */                   AND.zpg ("endchr_0008");      // AND with expression 1 high byte
/* b008 */                   EOR.zpg ("count_000b");       // EOR result high byte
/* b00a */                   TAY.imp ();                   // save in Y
/* b00b */                   LDA.zpg ("facho+2_0064");     // get FAC1 mantissa 3
/* b00d */                   EOR.zpg ("count_000b");       // EOR low byte
/* b00f */                   AND.zpg ("charac_0007");      // AND with expression 1 low byte
/* b011 */                   EOR.zpg ("count_000b");       // EOR result low byte
/* b013 */                   JMP.abs ("givayf_b391");      // convert fixed integer AY to float FAC1 and return

// ------------------------------------------------------- // perform comparisons
                                                           // do < compare
/* b016 */   _`dorel_b016`;  JSR.abs ("_ad90");            // type match check, set C for string
/* b019 */                   BCS.rel ("strrel_b02e");      // branch if string
                                                           // do numeric < compare
/* b01b */  _`numrel_b01b`;  LDA.zpg ("argsgn_006e");      // get FAC2 sign (b7)
/* b01d */                   ORA.imm (0x7f);               // set all non sign bits
/* b01f */                   AND.zpg ("argho+0_006a");     // and FAC2 mantissa 1 (AND in sign bit)
/* b021 */                   STA.zpg ("argho+0_006a");     // save FAC2 mantissa 1
/* b023 */                   LDA.imm (0x69);               // set pointer low byte to FAC2
/* b025 */                   LDY.imm (0x00);               // set pointer high byte to FAC2
/* b027 */                   JSR.abs ("fcomp_bc5b");       // compare FAC1 with (AY)
/* b02a */                   TAX.imp ();                   // copy the result
/* b02b */                   JMP.abs ("_b061");            // go evaluate result
                                                           // do string < compare
/* b02e */  _`strrel_b02e`;  LDA.imm (0x00);               // clear byte
/* b030 */                   STA.zpg ("valtyp_000d");      // clear data type flag, $FF = string, $00 = numeric
/* b032 */                   DEC.zpg ("opmask_004d");      // clear < bit in comparrison evaluation flag
/* b034 */                   JSR.abs ("_b6a6");            // pop string off descriptor stack, or from top of string
                                                           // space returns with A = length, X = pointer low byte,
                                                           // Y = pointer high byte
/* b037 */                   STA.zpg ("facexp_0061");      // save length
/* b039 */                   STX.zpg ("facho+0_0062");     // save string pointer low byte
/* b03b */                   STY.zpg ("facho+1_0063");     // save string pointer high byte
/* b03d */                   LDA.zpg ("argho+2_006c");     // get descriptor pointer low byte
/* b03f */                   LDY.zpg ("argho+3_006d");     // get descriptor pointer high byte
/* b041 */                   JSR.abs ("_b6aa");            // pop (YA) descriptor off stack or from top of string space
                                                           // returns with A = length, X = pointer low byte,
                                                           // Y = pointer high byte
/* b044 */                   STX.zpg ("argho+2_006c");     // save string pointer low byte
/* b046 */                   STY.zpg ("argho+3_006d");     // save string pointer high byte
/* b048 */                   TAX.imp ();                   // copy length
/* b049 */                   SEC.imp ();                   // set carry for subtract
/* b04a */                   SBC.zpg ("facexp_0061");      // subtract string 1 length
/* b04c */                   BEQ.rel ("_b056");            // branch if str 1 length = string 2 length
/* b04e */                   LDA.imm (0x01);               // set str 1 length > string 2 length
/* b050 */                   BCC.rel ("_b056");            // branch if so
/* b052 */                   LDX.zpg ("facexp_0061");      // get string 1 length
/* b054 */                   LDA.imm (0xff);               // set str 1 length < string 2 length
/* b056 */        _`_b056`;  STA.zpg ("facsgn_0066");      // save length compare
/* b058 */                   LDY.imm (0xff);               // set index
/* b05a */                   INX.imp ();                   // adjust for loop
/* b05b */        _`_b05b`;  INY.imp ();                   // increment index
/* b05c */                   DEX.imp ();                   // decrement count
/* b05d */                   BNE.rel ("_b066");            // branch if still bytes to do
/* b05f */                   LDX.zpg ("facsgn_0066");      // get length compare back
/* b061 */        _`_b061`;  BMI.rel ("_b072");            // branch if str 1 < str 2
/* b063 */                   CLC.imp ();                   // flag str 1 <= str 2
/* b064 */                   BCC.rel ("_b072");            // go evaluate result
/* b066 */        _`_b066`;  LDA.iny ("argho+2_006c");     // get string 2 byte
/* b068 */                   CMP.iny ("facho+0_0062");     // compare with string 1 byte
/* b06a */                   BEQ.rel ("_b05b");            // loop if bytes =
/* b06c */                   LDX.imm (0xff);               // set str 1 < string 2
/* b06e */                   BCS.rel ("_b072");            // branch if so
/* b070 */                   LDX.imm (0x01);               // set str 1 > string 2
/* b072 */        _`_b072`;  INX.imp ();                   // x = 0, 1 or 2
/* b073 */                   TXA.imp ();                   // copy to A
/* b074 */                   ROL.acc ();                   // * 2 (1, 2 or 4)
/* b075 */                   AND.zpg ("tansgn_0012");      // AND with the comparison evaluation flag
/* b077 */                   BEQ.rel ("_b07b");            // branch if 0 (compare is false)
/* b079 */                   LDA.imm (0xff);               // else set result true
/* b07b */        _`_b07b`;  JMP.abs ("_bc3c");            // save A as integer byte and return
/* b07e */        _`_b07e`;  JSR.abs ("_aefd");            // scan for ",", else do syntax error then warm start

// ------------------------------------------------------- // perform DIM
/* b081 */     _`dim_b081`;  TAX.imp ();                   // copy "DIM" flag to X
/* b082 */                   JSR.abs ("_b090");            // search for variable
/* b085 */                   JSR.abs ("chrgot_0079");      // scan memory
/* b088 */                   BNE.rel ("_b07e");            // scan for "," and loop if not null
/* b08a */                   RTS.imp ();

// ------------------------------------------------------- // search for variable
/* b08b */  _`ptrget_b08b`;  LDX.imm (0x00);               // set DIM flag = $00
/* b08d */                   JSR.abs ("chrgot_0079");      // scan memory, 1st character
/* b090 */        _`_b090`;  STX.zpg ("dimflg_000c");      // save DIM flag
/* b092 */        _`_b092`;  STA.zpg ("varnam+0_0045");    // save 1st character
/* b094 */                   JSR.abs ("chrgot_0079");      // scan memory
/* b097 */                   JSR.abs ("isletc_b113");      // check byte, return Cb = 0 if<"A" or >"Z"
/* b09a */                   BCS.rel ("_b09f");            // branch if ok
/* b09c */        _`_b09c`;  JMP.abs ("synerr_af08");      // else syntax error then warm start
                                                           // was variable name so ...
/* b09f */        _`_b09f`;  LDX.imm (0x00);               // clear 2nd character temp
/* b0a1 */                   STX.zpg ("valtyp_000d");      // clear data type flag, $FF = string, $00 = numeric
/* b0a3 */                   STX.zpg ("intflg_000e");      // clear data type flag, $80 = integer, $00 = float
/* b0a5 */                   JSR.abs ("chrget+0_0073");    // increment and scan memory, 2nd character
/* b0a8 */                   BCC.rel ("_b0af");            // if character = "0"-"9" (ok) go save 2nd character
                                                           // 2nd character wasn't "0" to "9" so ...
/* b0aa */                   JSR.abs ("isletc_b113");      // check byte, return Cb = 0 if<"A" or >"Z"
/* b0ad */                   BCC.rel ("_b0ba");            // branch if <"A" or >"Z" (go check if string)
/* b0af */        _`_b0af`;  TAX.imp ();                   // copy 2nd character
                                                           // ignore further (valid) characters in the variable name
/* b0b0 */        _`_b0b0`;  JSR.abs ("chrget+0_0073");    // increment and scan memory, 3rd character
/* b0b3 */                   BCC.rel ("_b0b0");            // loop if character = "0"-"9" (ignore)
/* b0b5 */                   JSR.abs ("isletc_b113");      // check byte, return Cb = 0 if<"A" or >"Z"
/* b0b8 */                   BCS.rel ("_b0b0");            // loop if character = "A"-"Z" (ignore)
                                                           // check if string variable
/* b0ba */        _`_b0ba`;  CMP.imm (0x24);               // compare with "$"
/* b0bc */                   BNE.rel ("_b0c4");            // branch if not string
                                                           // type is string
/* b0be */                   LDA.imm (0xff);               // set data type = string
/* b0c0 */                   STA.zpg ("valtyp_000d");      // set data type flag, $FF = string, $00 = numeric
/* b0c2 */                   BNE.rel ("_b0d4");            // branch always
/* b0c4 */        _`_b0c4`;  CMP.imm (0x25);               // compare with "%"
/* b0c6 */                   BNE.rel ("_b0db");            // branch if not integer
/* b0c8 */                   LDA.zpg ("subflg_0010");      // get subscript/FNX flag
/* b0ca */                   BNE.rel ("_b09c");            // if ?? do syntax error then warm start
/* b0cc */                   LDA.imm (0x80);               // set integer type
/* b0ce */                   STA.zpg ("intflg_000e");      // set data type = integer
/* b0d0 */                   ORA.zpg ("varnam+0_0045");    // OR current variable name first byte
/* b0d2 */                   STA.zpg ("varnam+0_0045");    // save current variable name first byte
/* b0d4 */        _`_b0d4`;  TXA.imp ();                   // get 2nd character back
/* b0d5 */                   ORA.imm (0x80);               // set top bit, indicate string or integer variable
/* b0d7 */                   TAX.imp ();                   // copy back to 2nd character temp
/* b0d8 */                   JSR.abs ("chrget+0_0073");    // increment and scan memory
/* b0db */        _`_b0db`;  STX.zpg ("varnam+1_0046");    // save 2nd character
/* b0dd */                   SEC.imp ();                   // set carry for subtract
/* b0de */                   ORA.zpg ("subflg_0010");      // or with subscript/FNX flag - or FN name
/* b0e0 */                   SBC.imm (0x28);               // subtract "("
/* b0e2 */                   BNE.rel ("ordvar_b0e7");      // branch if not "("
/* b0e4 */                   JMP.abs ("isary_b1d1");       // go find, or make, array
                                                           // either find or create variable
                                                           // variable name wasn't xx(.... so look for plain variable
/* b0e7 */  _`ordvar_b0e7`;  LDY.imm (0x00);               // clear A
/* b0e9 */                   STY.zpg ("subflg_0010");      // clear subscript/FNX flag
/* b0eb */                   LDA.zpg ("vartab+0_002d");    // get start of variables low byte
/* b0ed */                   LDX.zpg ("vartab+1_002e");    // get start of variables high byte
/* b0ef */        _`_b0ef`;  STX.zpg ("tempf2+4_0060");    // save search address high byte
/* b0f1 */        _`_b0f1`;  STA.zpg ("tempf2+3_005f");    // save search address low byte
/* b0f3 */                   CPX.zpg ("arytab+1_0030");    // compare with end of variables high byte
/* b0f5 */                   BNE.rel ("_b0fb");            // skip next compare if <>
                                                           // high addresses were = so compare low addresses
/* b0f7 */                   CMP.zpg ("arytab+0_002f");    // compare low address with end of variables low byte
/* b0f9 */                   BEQ.rel ("notfns_b11d");      // if not found go make new variable
/* b0fb */        _`_b0fb`;  LDA.zpg ("varnam+0_0045");    // get 1st character of variable to find
/* b0fd */                   CMP.iny ("tempf2+3_005f");    // compare with variable name 1st character
/* b0ff */                   BNE.rel ("_b109");            // branch if no match
                                                           // 1st characters match so compare 2nd character
/* b101 */                   LDA.zpg ("varnam+1_0046");    // get 2nd character of variable to find
/* b103 */                   INY.imp ();                   // index to point to variable name 2nd character
/* b104 */                   CMP.iny ("tempf2+3_005f");    // compare with variable name 2nd character
/* b106 */                   BEQ.rel ("finptr_b185");      // branch if match (found variable)
/* b108 */                   DEY.imp ();                   // else decrement index (now = $00)
/* b109 */        _`_b109`;  CLC.imp ();                   // clear carry for add
/* b10a */                   LDA.zpg ("tempf2+3_005f");    // get search address low byte
/* b10c */                   ADC.imm (0x07);               // +7, offset to next variable name
/* b10e */                   BCC.rel ("_b0f1");            // loop if no overflow to high byte
/* b110 */                   INX.imp ();                   // else increment high byte
/* b111 */                   BNE.rel ("_b0ef");            // loop always, RAM doesn't extend to $FFFF
                                                           // check byte, return Cb = 0 if<"A" or >"Z"
/* b113 */  _`isletc_b113`;  CMP.imm (0x41);               // compare with "A"
/* b115 */                   BCC.rel ("_b11c");            // exit if less
                                                           // carry is set
/* b117 */                   SBC.imm (0x5b);               // subtract "Z"+1
/* b119 */                   SEC.imp ();                   // set carry
/* b11a */                   SBC.imm (0xa5);               // subtract $A5 (restore byte)
                                                           // carry clear if byte > $5A
/* b11c */        _`_b11c`;  RTS.imp ();
                                                           // reached end of variable memory without match
                                                           // ... so create new variable
/* b11d */  _`notfns_b11d`;  PLA.imp ();                   // pop return address low byte
/* b11e */                   PHA.imp ();                   // push return address low byte
/* b11f */                   CMP.imm (0x2a);               // compare with expected calling routine return low byte
/* b121 */                   BNE.rel ("notevl_b128");      // if not get variable go create new variable
                                                           // this will only drop through if the call was from $AF28 and is only called
                                                           // from there if it is searching for a variable from the right hand side of a LET a=b
                                                           // statement, it prevents the creation of variables not assigned a value.
                                                           // value returned by this is either numeric zero, exponent byte is $00, or null string,
                                                           // descriptor length byte is $00. in fact a pointer to any $00 byte would have done.
                                                           // else return dummy null value
/* b123 */        _`_b123`;  LDA.imm (0x13);               // set result pointer low byte
/* b125 */                   LDY.imm (0xbf);               // set result pointer high byte
/* b127 */                   RTS.imp ();
                                                           // create new numeric variable
/* b128 */  _`notevl_b128`;  LDA.zpg ("varnam+0_0045");    // get variable name first character
/* b12a */                   LDY.zpg ("varnam+1_0046");    // get variable name second character
/* b12c */                   CMP.imm (0x54);               // compare first character with "T"
/* b12e */                   BNE.rel ("_b13b");            // branch if not "T"
/* b130 */                   CPY.imm (0xc9);               // compare second character with "I$"
/* b132 */                   BEQ.rel ("_b123");            // if "I$" return null value
/* b134 */                   CPY.imm (0x49);               // compare second character with "I"
/* b136 */                   BNE.rel ("_b13b");            // branch if not "I"
                                                           // if name is "TI" do syntax error
/* b138 */        _`_b138`;  JMP.abs ("synerr_af08");      // do syntax error then warm start
/* b13b */        _`_b13b`;  CMP.imm (0x53);               // compare first character with "S"
/* b13d */                   BNE.rel ("_b143");            // branch if not "S"
/* b13f */                   CPY.imm (0x54);               // compare second character with "T"
/* b141 */                   BEQ.rel ("_b138");            // if name is "ST" do syntax error
/* b143 */        _`_b143`;  LDA.zpg ("arytab+0_002f");    // get end of variables low byte
/* b145 */                   LDY.zpg ("arytab+1_0030");    // get end of variables high byte
/* b147 */                   STA.zpg ("tempf2+3_005f");    // save old block start low byte
/* b149 */                   STY.zpg ("tempf2+4_0060");    // save old block start high byte
/* b14b */                   LDA.zpg ("strend+0_0031");    // get end of arrays low byte
/* b14d */                   LDY.zpg ("strend+1_0032");    // get end of arrays high byte
/* b14f */                   STA.zpg ("tempf1+3_005a");    // save old block end low byte
/* b151 */                   STY.zpg ("tempf1+4_005b");    // save old block end high byte
/* b153 */                   CLC.imp ();                   // clear carry for add
/* b154 */                   ADC.imm (0x07);               // +7, space for one variable
/* b156 */                   BCC.rel ("_b159");            // branch if no overflow to high byte
/* b158 */                   INY.imp ();                   // else increment high byte
/* b159 */        _`_b159`;  STA.zpg ("tempf1+1_0058");    // set new block end low byte
/* b15b */                   STY.zpg ("tempf1+2_0059");    // set new block end high byte
/* b15d */                   JSR.abs ("bltu_a3b8");        // open up space in memory
/* b160 */                   LDA.zpg ("tempf1+1_0058");    // get new start low byte
/* b162 */                   LDY.zpg ("tempf1+2_0059");    // get new start high byte (-$100)
/* b164 */                   INY.imp ();                   // correct high byte
/* b165 */                   STA.zpg ("arytab+0_002f");    // set end of variables low byte
/* b167 */                   STY.zpg ("arytab+1_0030");    // set end of variables high byte
/* b169 */                   LDY.imm (0x00);               // clear index
/* b16b */                   LDA.zpg ("varnam+0_0045");    // get variable name 1st character
/* b16d */                   STA.iny ("tempf2+3_005f");    // save variable name 1st character
/* b16f */                   INY.imp ();                   // increment index
/* b170 */                   LDA.zpg ("varnam+1_0046");    // get variable name 2nd character
/* b172 */                   STA.iny ("tempf2+3_005f");    // save variable name 2nd character
/* b174 */                   LDA.imm (0x00);               // clear A
/* b176 */                   INY.imp ();                   // increment index
/* b177 */                   STA.iny ("tempf2+3_005f");    // initialise variable byte
/* b179 */                   INY.imp ();                   // increment index
/* b17a */                   STA.iny ("tempf2+3_005f");    // initialise variable byte
/* b17c */                   INY.imp ();                   // increment index
/* b17d */                   STA.iny ("tempf2+3_005f");    // initialise variable byte
/* b17f */                   INY.imp ();                   // increment index
/* b180 */                   STA.iny ("tempf2+3_005f");    // initialise variable byte
/* b182 */                   INY.imp ();                   // increment index
/* b183 */                   STA.iny ("tempf2+3_005f");    // initialise variable byte
                                                           // found a match for variable
/* b185 */  _`finptr_b185`;  LDA.zpg ("tempf2+3_005f");    // get variable address low byte
/* b187 */                   CLC.imp ();                   // clear carry for add
/* b188 */                   ADC.imm (0x02);               // +2, offset past variable name bytes
/* b18a */                   LDY.zpg ("tempf2+4_0060");    // get variable address high byte
/* b18c */                   BCC.rel ("_b18f");            // branch if no overflow from add
/* b18e */                   INY.imp ();                   // else increment high byte
/* b18f */        _`_b18f`;  STA.zpg ("varpnt+0_0047");    // save current variable pointer low byte
/* b191 */                   STY.zpg ("varpnt+1_0048");    // save current variable pointer high byte
/* b193 */                   RTS.imp ();
                                                           // set-up array pointer to first element in array
/* b194 */  _`aryget_b194`;  LDA.zpg ("count_000b");       // get # of dimensions (1, 2 or 3)
/* b196 */                   ASL.acc ();                   // *2 (also clears the carry !)
/* b197 */                   ADC.imm (0x05);               // +5 (result is 7, 9 or 11 here)
/* b199 */                   ADC.zpg ("tempf2+3_005f");    // add array start pointer low byte
/* b19b */                   LDY.zpg ("tempf2+4_0060");    // get array pointer high byte
/* b19d */                   BCC.rel ("_b1a0");            // branch if no overflow
/* b19f */                   INY.imp ();                   // else increment high byte
/* b1a0 */        _`_b1a0`;  STA.zpg ("tempf1+1_0058");    // save array data pointer low byte
/* b1a2 */                   STY.zpg ("tempf1+2_0059");    // save array data pointer high byte
/* b1a4 */                   RTS.imp ();

// ------------------------------------------------------- // -32768 as floating value
                                                           // -32768
/* b1a5 */  _`n32768_b1a5`;  _.bytes(0x90, 0x80, 0x00, 0x00, 0x00);

// ------------------------------------------------------- // convert float to fixed
/* b1aa */  _`facinx_b1aa`;  JSR.abs ("ayint_b1bf");       // evaluate integer expression, no sign check
/* b1ad */                   LDA.zpg ("facho+2_0064");     // get result low byte
/* b1af */                   LDY.zpg ("facho+3_0065");     // get result high byte
/* b1b1 */                   RTS.imp ();

// ------------------------------------------------------- // evaluate integer expression
/* b1b2 */  _`intidx_b1b2`;  JSR.abs ("chrget+0_0073");    // increment and scan memory
/* b1b5 */                   JSR.abs ("frmevl_ad9e");      // evaluate expression
                                                           // evaluate integer expression, sign check
/* b1b8 */        _`_b1b8`;  JSR.abs ("_ad8d");            // check if source is numeric, else do type mismatch
/* b1bb */                   LDA.zpg ("facsgn_0066");      // get FAC1 sign (b7)
/* b1bd */                   BMI.rel ("_b1cc");            // do illegal quantity error if -ve
                                                           // evaluate integer expression, no sign check
/* b1bf */   _`ayint_b1bf`;  LDA.zpg ("facexp_0061");      // get FAC1 exponent
/* b1c1 */                   CMP.imm (0x90);               // compare with exponent = 2^16 (n>2^15)
/* b1c3 */                   BCC.rel ("_b1ce");            // if n<2^16 go convert FAC1 floating to fixed and return
/* b1c5 */                   LDA.imm (0xa5);               // set pointer low byte to -32768
/* b1c7 */                   LDY.imm (0xb1);               // set pointer high byte to -32768
/* b1c9 */                   JSR.abs ("fcomp_bc5b");       // compare FAC1 with (AY)
/* b1cc */        _`_b1cc`;  BNE.rel ("fcerr_b248");       // if <> do illegal quantity error then warm start
/* b1ce */        _`_b1ce`;  JMP.abs ("qint_bc9b");        // convert FAC1 floating to fixed and return

// ------------------------------------------------------- // find or make array
                                                           // an array is stored as follows

                                                           // array name             two bytes with the following patterns for different types
                                                           //                        1st char    2nd char
                                                           //                           b7          b7       type             element size
                                                           //                        --------    --------    -----            ------------
                                                           //                           0           0        floating point   5
                                                           //                           0           1        string           3
                                                           //                           1           1        integer          2
                                                           // offset to next array   word
                                                           // dimension count        byte
                                                           // 1st dimension size     word, this is the number of elements including 0
                                                           // 2nd dimension size     word, only here if the array has a second dimension
                                                           // 2nd dimension size     word, only here if the array has a third dimension
                                                           //                        note: the dimension size word is in high byte low byte
                                                           //                        format, not like most 6502 words
                                                           // then for each element the required number of bytes given as the element size above
/* b1d1 */   _`isary_b1d1`;  LDA.zpg ("dimflg_000c");      // get DIM flag
/* b1d3 */                   ORA.zpg ("intflg_000e");      // OR with data type flag
/* b1d5 */                   PHA.imp ();                   // push it
/* b1d6 */                   LDA.zpg ("valtyp_000d");      // get data type flag, $FF = string, $00 = numeric
/* b1d8 */                   PHA.imp ();                   // push it
/* b1d9 */                   LDY.imm (0x00);               // clear dimensions count
                                                           // now get the array dimension(s) and stack it (them) before the data type and DIM flag
/* b1db */        _`_b1db`;  TYA.imp ();                   // copy dimensions count
/* b1dc */                   PHA.imp ();                   // save it
/* b1dd */                   LDA.zpg ("varnam+1_0046");    // get array name 2nd byte
/* b1df */                   PHA.imp ();                   // save it
/* b1e0 */                   LDA.zpg ("varnam+0_0045");    // get array name 1st byte
/* b1e2 */                   PHA.imp ();                   // save it
/* b1e3 */                   JSR.abs ("intidx_b1b2");      // evaluate integer expression
/* b1e6 */                   PLA.imp ();                   // pull array name 1st byte
/* b1e7 */                   STA.zpg ("varnam+0_0045");    // restore array name 1st byte
/* b1e9 */                   PLA.imp ();                   // pull array name 2nd byte
/* b1ea */                   STA.zpg ("varnam+1_0046");    // restore array name 2nd byte
/* b1ec */                   PLA.imp ();                   // pull dimensions count
/* b1ed */                   TAY.imp ();                   // restore it
/* b1ee */                   TSX.imp ();                   // copy stack pointer
/* b1ef */                   LDA.abx ("bad+2_0102");       // get DIM flag
/* b1f2 */                   PHA.imp ();                   // push it
/* b1f3 */                   LDA.abx ("bad+1_0101");       // get data type flag
/* b1f6 */                   PHA.imp ();                   // push it
/* b1f7 */                   LDA.zpg ("facho+2_0064");     // get this dimension size high byte
/* b1f9 */                   STA.abx ("bad+2_0102");       // stack before flag bytes
/* b1fc */                   LDA.zpg ("facho+3_0065");     // get this dimension size low byte
/* b1fe */                   STA.abx ("bad+1_0101");       // stack before flag bytes
/* b201 */                   INY.imp ();                   // increment dimensions count
/* b202 */                   JSR.abs ("chrgot_0079");      // scan memory
/* b205 */                   CMP.imm (0x2c);               // compare with ","
/* b207 */                   BEQ.rel ("_b1db");            // if found go do next dimension
/* b209 */                   STY.zpg ("count_000b");       // store dimensions count
/* b20b */                   JSR.abs ("chkcls_aef7");      // scan for ")", else do syntax error then warm start
/* b20e */                   PLA.imp ();                   // pull data type flag
/* b20f */                   STA.zpg ("valtyp_000d");      // restore data type flag, $FF = string, $00 = numeric
/* b211 */                   PLA.imp ();                   // pull data type flag
/* b212 */                   STA.zpg ("intflg_000e");      // restore data type flag, $80 = integer, $00 = float
/* b214 */                   AND.imm (0x7f);               // mask dim flag
/* b216 */                   STA.zpg ("dimflg_000c");      // restore DIM flag
/* b218 */  _`fndary_b218`;  LDX.zpg ("arytab+0_002f");    // set end of variables low byte
                                                           // (array memory start low byte)
/* b21a */                   LDA.zpg ("arytab+1_0030");    // set end of variables high byte
                                                           // (array memory start high byte)
                                                           // now check to see if we are at the end of array memory, we would be if there were
                                                           // no arrays.
/* b21c */        _`_b21c`;  STX.zpg ("tempf2+3_005f");    // save as array start pointer low byte
/* b21e */                   STA.zpg ("tempf2+4_0060");    // save as array start pointer high byte
/* b220 */                   CMP.zpg ("strend+1_0032");    // compare with end of arrays high byte
/* b222 */                   BNE.rel ("_b228");            // branch if not reached array memory end
/* b224 */                   CPX.zpg ("strend+0_0031");    // else compare with end of arrays low byte
/* b226 */                   BEQ.rel ("notfdd_b261");      // go build array if not found
                                                           // search for array
/* b228 */        _`_b228`;  LDY.imm (0x00);               // clear index
/* b22a */                   LDA.iny ("tempf2+3_005f");    // get array name first byte
/* b22c */                   INY.imp ();                   // increment index to second name byte
/* b22d */                   CMP.zpg ("varnam+0_0045");    // compare with this array name first byte
/* b22f */                   BNE.rel ("_b237");            // branch if no match
/* b231 */                   LDA.zpg ("varnam+1_0046");    // else get this array name second byte
/* b233 */                   CMP.iny ("tempf2+3_005f");    // compare with array name second byte
/* b235 */                   BEQ.rel ("_b24d");            // array found so branch
                                                           // no match
/* b237 */        _`_b237`;  INY.imp ();                   // increment index
/* b238 */                   LDA.iny ("tempf2+3_005f");    // get array size low byte
/* b23a */                   CLC.imp ();                   // clear carry for add
/* b23b */                   ADC.zpg ("tempf2+3_005f");    // add array start pointer low byte
/* b23d */                   TAX.imp ();                   // copy low byte to X
/* b23e */                   INY.imp ();                   // increment index
/* b23f */                   LDA.iny ("tempf2+3_005f");    // get array size high byte
/* b241 */                   ADC.zpg ("tempf2+4_0060");    // add array memory pointer high byte
/* b243 */                   BCC.rel ("_b21c");            // if no overflow go check next array

// ------------------------------------------------------- // do bad subscript error
/* b245 */   _`bserr_b245`;  LDX.imm (0x12);               // error $12, bad subscript error
/* b247 */                   _.bytes(0x2c);                // makes next line BIT $0EA2

// ------------------------------------------------------- // do illegal quantity error
/* b248 */   _`fcerr_b248`;  LDX.imm (0x0e);               // error $0E, illegal quantity error
/* b24a */        _`_b24a`;  JMP.abs ("error_a437");       // do error #X then warm start

// ------------------------------------------------------- // found the array
/* b24d */        _`_b24d`;  LDX.imm (0x13);               // set error $13, double dimension error
/* b24f */                   LDA.zpg ("dimflg_000c");      // get DIM flag
/* b251 */                   BNE.rel ("_b24a");            // if we are trying to dimension it do error #X then warm
                                                           // start
                                                           // found the array and we're not dimensioning it so we must find an element in it
/* b253 */                   JSR.abs ("aryget_b194");      // set-up array pointer to first element in array
/* b256 */                   LDA.zpg ("count_000b");       // get dimensions count
/* b258 */                   LDY.imm (0x04);               // set index to array's # of dimensions
/* b25a */                   CMP.iny ("tempf2+3_005f");    // compare with no of dimensions
/* b25c */                   BNE.rel ("bserr_b245");       // if wrong do bad subscript error
/* b25e */                   JMP.abs ("_b2ea");            // found array so go get element
                                                           // array not found, so build it
/* b261 */  _`notfdd_b261`;  JSR.abs ("aryget_b194");      // set-up array pointer to first element in array
/* b264 */                   JSR.abs ("reason_a408");      // check available memory, do out of memory error if no room
/* b267 */                   LDY.imm (0x00);               // clear Y
/* b269 */                   STY.zpg ("fbufpt+1_0072");    // clear array data size high byte
/* b26b */                   LDX.imm (0x05);               // set default element size
/* b26d */                   LDA.zpg ("varnam+0_0045");    // get variable name 1st byte
/* b26f */                   STA.iny ("tempf2+3_005f");    // save array name 1st byte
/* b271 */                   BPL.rel ("_b274");            // branch if not string or floating point array
/* b273 */                   DEX.imp ();                   // decrement element size, $04
/* b274 */        _`_b274`;  INY.imp ();                   // increment index
/* b275 */                   LDA.zpg ("varnam+1_0046");    // get variable name 2nd byte
/* b277 */                   STA.iny ("tempf2+3_005f");    // save array name 2nd byte
/* b279 */                   BPL.rel ("_b27d");            // branch if not integer or string
/* b27b */                   DEX.imp ();                   // decrement element size, $03
/* b27c */                   DEX.imp ();                   // decrement element size, $02
/* b27d */        _`_b27d`;  STX.zpg ("fbufpt+0_0071");    // save element size
/* b27f */                   LDA.zpg ("count_000b");       // get dimensions count
/* b281 */                   INY.imp ();                   // increment index ..
/* b282 */                   INY.imp ();                   // .. to array  ..
/* b283 */                   INY.imp ();                   // .. dimension count
/* b284 */                   STA.iny ("tempf2+3_005f");    // save array dimension count
/* b286 */        _`_b286`;  LDX.imm (0x0b);               // set default dimension size low byte
/* b288 */                   LDA.imm (0x00);               // set default dimension size high byte
/* b28a */                   BIT.zpg ("dimflg_000c");      // test DIM flag
/* b28c */                   BVC.rel ("_b296");            // branch if default to be used
/* b28e */                   PLA.imp ();                   // pull dimension size low byte
/* b28f */                   CLC.imp ();                   // clear carry for add
/* b290 */                   ADC.imm (0x01);               // add 1, allow for zeroeth element
/* b292 */                   TAX.imp ();                   // copy low byte to X
/* b293 */                   PLA.imp ();                   // pull dimension size high byte
/* b294 */                   ADC.imm (0x00);               // add carry to high byte
/* b296 */        _`_b296`;  INY.imp ();                   // incement index to dimension size high byte
/* b297 */                   STA.iny ("tempf2+3_005f");    // save dimension size high byte
/* b299 */                   INY.imp ();                   // incement index to dimension size low byte
/* b29a */                   TXA.imp ();                   // copy dimension size low byte
/* b29b */                   STA.iny ("tempf2+3_005f");    // save dimension size low byte
/* b29d */                   JSR.abs ("umult_b34c");       // compute array size
/* b2a0 */                   STX.zpg ("fbufpt+0_0071");    // save result low byte
/* b2a2 */                   STA.zpg ("fbufpt+1_0072");    // save result high byte
/* b2a4 */                   LDY.zpg ("index+0_0022");     // restore index
/* b2a6 */                   DEC.zpg ("count_000b");       // decrement dimensions count
/* b2a8 */                   BNE.rel ("_b286");            // loop if not all done
/* b2aa */                   ADC.zpg ("tempf1+2_0059");    // add array data pointer high byte
/* b2ac */                   BCS.rel ("_b30b");            // if overflow do out of memory error then warm start
/* b2ae */                   STA.zpg ("tempf1+2_0059");    // save array data pointer high byte
/* b2b0 */                   TAY.imp ();                   // copy array data pointer high byte
/* b2b1 */                   TXA.imp ();                   // copy array size low byte
/* b2b2 */                   ADC.zpg ("tempf1+1_0058");    // add array data pointer low byte
/* b2b4 */                   BCC.rel ("_b2b9");            // branch if no rollover
/* b2b6 */                   INY.imp ();                   // else increment next array pointer high byte
/* b2b7 */                   BEQ.rel ("_b30b");            // if rolled over do out of memory error then warm start
/* b2b9 */        _`_b2b9`;  JSR.abs ("reason_a408");      // check available memory, do out of memory error if no room
/* b2bc */                   STA.zpg ("strend+0_0031");    // set end of arrays low byte
/* b2be */                   STY.zpg ("strend+1_0032");    // set end of arrays high byte
                                                           // now the aray is created we need to zero all the elements in it
/* b2c0 */                   LDA.imm (0x00);               // clear A for array clear
/* b2c2 */                   INC.zpg ("fbufpt+1_0072");    // increment array size high byte, now block count
/* b2c4 */                   LDY.zpg ("fbufpt+0_0071");    // get array size low byte, now index to block
/* b2c6 */                   BEQ.rel ("_b2cd");            // branch if $00
/* b2c8 */        _`_b2c8`;  DEY.imp ();                   // decrement index, do 0 to n-1
/* b2c9 */                   STA.iny ("tempf1+1_0058");    // clear array element byte
/* b2cb */                   BNE.rel ("_b2c8");            // loop until this block done
/* b2cd */        _`_b2cd`;  DEC.zpg ("tempf1+2_0059");    // decrement array pointer high byte
/* b2cf */                   DEC.zpg ("fbufpt+1_0072");    // decrement block count high byte
/* b2d1 */                   BNE.rel ("_b2c8");            // loop until all blocks done
/* b2d3 */                   INC.zpg ("tempf1+2_0059");    // correct for last loop
/* b2d5 */                   SEC.imp ();                   // set carry for subtract
/* b2d6 */                   LDA.zpg ("strend+0_0031");    // get end of arrays low byte
/* b2d8 */                   SBC.zpg ("tempf2+3_005f");    // subtract array start low byte
/* b2da */                   LDY.imm (0x02);               // index to array size low byte
/* b2dc */                   STA.iny ("tempf2+3_005f");    // save array size low byte
/* b2de */                   LDA.zpg ("strend+1_0032");    // get end of arrays high byte
/* b2e0 */                   INY.imp ();                   // index to array size high byte
/* b2e1 */                   SBC.zpg ("tempf2+4_0060");    // subtract array start high byte
/* b2e3 */                   STA.iny ("tempf2+3_005f");    // save array size high byte
/* b2e5 */                   LDA.zpg ("dimflg_000c");      // get default DIM flag
/* b2e7 */                   BNE.rel ("_b34b");            // exit if this was a DIM command
                                                           // else, find element
/* b2e9 */                   INY.imp ();                   // set index to # of dimensions, the dimension indeces
                                                           // are on the stack and will be removed as the position
                                                           // of the array element is calculated
/* b2ea */        _`_b2ea`;  LDA.iny ("tempf2+3_005f");    // get array's dimension count
/* b2ec */                   STA.zpg ("count_000b");       // save it
/* b2ee */                   LDA.imm (0x00);               // clear byte
/* b2f0 */                   STA.zpg ("fbufpt+0_0071");    // clear array data pointer low byte
/* b2f2 */        _`_b2f2`;  STA.zpg ("fbufpt+1_0072");    // save array data pointer high byte
/* b2f4 */                   INY.imp ();                   // increment index, point to array bound high byte
/* b2f5 */                   PLA.imp ();                   // pull array index low byte
/* b2f6 */                   TAX.imp ();                   // copy to X
/* b2f7 */                   STA.zpg ("facho+2_0064");     // save index low byte to FAC1 mantissa 3
/* b2f9 */                   PLA.imp ();                   // pull array index high byte
/* b2fa */                   STA.zpg ("facho+3_0065");     // save index high byte to FAC1 mantissa 4
/* b2fc */                   CMP.iny ("tempf2+3_005f");    // compare with array bound high byte
/* b2fe */                   BCC.rel ("inlpn2_b30e");      // branch if within bounds
/* b300 */                   BNE.rel ("_b308");            // if outside bounds do bad subscript error
                                                           // else high byte was = so test low bytes
/* b302 */                   INY.imp ();                   // index to array bound low byte
/* b303 */                   TXA.imp ();                   // get array index low byte
/* b304 */                   CMP.iny ("tempf2+3_005f");    // compare with array bound low byte
/* b306 */                   BCC.rel ("_b30f");            // branch if within bounds
/* b308 */        _`_b308`;  JMP.abs ("bserr_b245");       // do bad subscript error
/* b30b */        _`_b30b`;  JMP.abs ("omerr_a435");       // do out of memory error then warm start
/* b30e */  _`inlpn2_b30e`;  INY.imp ();                   // index to array bound low byte
/* b30f */        _`_b30f`;  LDA.zpg ("fbufpt+1_0072");    // get array data pointer high byte
/* b311 */                   ORA.zpg ("fbufpt+0_0071");    // OR with array data pointer low byte
/* b313 */                   CLC.imp ();                   // clear carry for either add, carry always clear here ??
/* b314 */                   BEQ.rel ("_b320");            // branch if array data pointer = null, skip multiply
/* b316 */                   JSR.abs ("umult_b34c");       // compute array size
/* b319 */                   TXA.imp ();                   // get result low byte
/* b31a */                   ADC.zpg ("facho+2_0064");     // add index low byte from FAC1 mantissa 3
/* b31c */                   TAX.imp ();                   // save result low byte
/* b31d */                   TYA.imp ();                   // get result high byte
/* b31e */                   LDY.zpg ("index+0_0022");     // restore index
/* b320 */        _`_b320`;  ADC.zpg ("facho+3_0065");     // add index high byte from FAC1 mantissa 4
/* b322 */                   STX.zpg ("fbufpt+0_0071");    // save array data pointer low byte
/* b324 */                   DEC.zpg ("count_000b");       // decrement dimensions count
/* b326 */                   BNE.rel ("_b2f2");            // loop if dimensions still to do
/* b328 */                   STA.zpg ("fbufpt+1_0072");    // save array data pointer high byte
/* b32a */                   LDX.imm (0x05);               // set default element size
/* b32c */                   LDA.zpg ("varnam+0_0045");    // get variable name 1st byte
/* b32e */                   BPL.rel ("_b331");            // branch if not string or floating point array
/* b330 */                   DEX.imp ();                   // decrement element size, $04
/* b331 */        _`_b331`;  LDA.zpg ("varnam+1_0046");    // get variable name 2nd byte
/* b333 */                   BPL.rel ("_b337");            // branch if not integer or string
/* b335 */                   DEX.imp ();                   // decrement element size, $03
/* b336 */                   DEX.imp ();                   // decrement element size, $02
/* b337 */        _`_b337`;  STX.zpg ("resho+2_0028");     // save dimension size low byte
/* b339 */                   LDA.imm (0x00);               // clear dimension size high byte
/* b33b */                   JSR.abs ("_b355");            // compute array size
/* b33e */                   TXA.imp ();                   // copy array size low byte
/* b33f */                   ADC.zpg ("tempf1+1_0058");    // add array data start pointer low byte
/* b341 */                   STA.zpg ("varpnt+0_0047");    // save as current variable pointer low byte
/* b343 */                   TYA.imp ();                   // copy array size high byte
/* b344 */                   ADC.zpg ("tempf1+2_0059");    // add array data start pointer high byte
/* b346 */                   STA.zpg ("varpnt+1_0048");    // save as current variable pointer high byte
/* b348 */                   TAY.imp ();                   // copy high byte to Y
/* b349 */                   LDA.zpg ("varpnt+0_0047");    // get current variable pointer low byte
                                                           // pointer to element is now in AY
/* b34b */        _`_b34b`;  RTS.imp ();
                                                           // compute array size, result in XY
/* b34c */   _`umult_b34c`;  STY.zpg ("index+0_0022");     // save index
/* b34e */                   LDA.iny ("tempf2+3_005f");    // get dimension size low byte
/* b350 */                   STA.zpg ("resho+2_0028");     // save dimension size low byte
/* b352 */                   DEY.imp ();                   // decrement index
/* b353 */                   LDA.iny ("tempf2+3_005f");    // get dimension size high byte
/* b355 */        _`_b355`;  STA.zpg ("resho+3_0029");     // save dimension size high byte
/* b357 */                   LDA.imm (0x10);               // count = $10 (16 bit multiply)
/* b359 */                   STA.zpg ("tempf2+1_005d");    // save bit count
/* b35b */                   LDX.imm (0x00);               // clear result low byte
/* b35d */                   LDY.imm (0x00);               // clear result high byte
/* b35f */        _`_b35f`;  TXA.imp ();                   // get result low byte
/* b360 */                   ASL.acc ();                   // *2
/* b361 */                   TAX.imp ();                   // save result low byte
/* b362 */                   TYA.imp ();                   // get result high byte
/* b363 */                   ROL.acc ();                   // *2
/* b364 */                   TAY.imp ();                   // save result high byte
/* b365 */                   BCS.rel ("_b30b");            // if overflow go do "Out of memory" error
/* b367 */                   ASL.zpg ("fbufpt+0_0071");    // shift element size low byte
/* b369 */                   ROL.zpg ("fbufpt+1_0072");    // shift element size high byte
/* b36b */                   BCC.rel ("_b378");            // skip add if no carry
/* b36d */                   CLC.imp ();                   // else clear carry for add
/* b36e */                   TXA.imp ();                   // get result low byte
/* b36f */                   ADC.zpg ("resho+2_0028");     // add dimension size low byte
/* b371 */                   TAX.imp ();                   // save result low byte
/* b372 */                   TYA.imp ();                   // get result high byte
/* b373 */                   ADC.zpg ("resho+3_0029");     // add dimension size high byte
/* b375 */                   TAY.imp ();                   // save result high byte
/* b376 */                   BCS.rel ("_b30b");            // if overflow go do "Out of memory" error
/* b378 */        _`_b378`;  DEC.zpg ("tempf2+1_005d");    // decrement bit count
/* b37a */                   BNE.rel ("_b35f");            // loop until all done
/* b37c */                   RTS.imp ();
                                                           // perform FRE()
/* b37d */     _`fre_b37d`;  LDA.zpg ("valtyp_000d");      // get data type flag, $FF = string, $00 = numeric
/* b37f */                   BEQ.rel ("_b384");            // branch if numeric
/* b381 */                   JSR.abs ("_b6a6");            // pop string off descriptor stack, or from top of string
                                                           // space returns with A = length, X=$71=pointer low byte,
                                                           // Y=$72=pointer high byte
                                                           // FRE(n) was numeric so do this
/* b384 */        _`_b384`;  JSR.abs ("garbag_b526");      // go do garbage collection
/* b387 */                   SEC.imp ();                   // set carry for subtract
/* b388 */                   LDA.zpg ("fretop+0_0033");    // get bottom of string space low byte
/* b38a */                   SBC.zpg ("strend+0_0031");    // subtract end of arrays low byte
/* b38c */                   TAY.imp ();                   // copy result to Y
/* b38d */                   LDA.zpg ("fretop+1_0034");    // get bottom of string space high byte
/* b38f */                   SBC.zpg ("strend+1_0032");    // subtract end of arrays high byte

// ------------------------------------------------------- // convert fixed integer AY to float FAC1
/* b391 */  _`givayf_b391`;  LDX.imm (0x00);               // set type = numeric
/* b393 */                   STX.zpg ("valtyp_000d");      // clear data type flag, $FF = string, $00 = numeric
/* b395 */                   STA.zpg ("facho+0_0062");     // save FAC1 mantissa 1
/* b397 */                   STY.zpg ("facho+1_0063");     // save FAC1 mantissa 2
/* b399 */                   LDX.imm (0x90);               // set exponent=2^16 (integer)
/* b39b */                   JMP.abs ("_bc44");            // set exp = X, clear FAC1 3 and 4, normalise and return

// ------------------------------------------------------- // perform POS()
/* b39e */     _`pos_b39e`;  SEC.imp ();                   // set Cb for read cursor position
/* b39f */                   JSR.abs ("plot_fff0");        // read/set X,Y cursor position
/* b3a2 */        _`_b3a2`;  LDA.imm (0x00);               // clear high byte
/* b3a4 */                   BEQ.rel ("givayf_b391");      // convert fixed integer AY to float FAC1, branch always
                                                           // check not Direct, used by DEF and INPUT
/* b3a6 */  _`errdir_b3a6`;  LDX.zpg ("curlin+1_003a");    // get current line number high byte
/* b3a8 */                   INX.imp ();                   // increment it
/* b3a9 */                   BNE.rel ("_b34b");            // return if not direct mode
                                                           // else do illegal direct error
/* b3ab */                   LDX.imm (0x15);               // error $15, illegal direct error
/* b3ad */                   _.bytes(0x2c);                // makes next line BIT $1BA2
/* b3ae */        _`_b3ae`;  LDX.imm (0x1b);               // error $1B, undefined function error
/* b3b0 */                   JMP.abs ("error_a437");       // do error #X then warm start

// ------------------------------------------------------- // perform DEF
/* b3b3 */     _`def_b3b3`;  JSR.abs ("getfnm_b3e1");      // check FNx syntax
/* b3b6 */                   JSR.abs ("errdir_b3a6");      // check not direct, back here if ok
/* b3b9 */                   JSR.abs ("chkopn_aefa");      // scan for "(", else do syntax error then warm start
/* b3bc */                   LDA.imm (0x80);               // set flag for FNx
/* b3be */                   STA.zpg ("subflg_0010");      // save subscript/FNx flag
/* b3c0 */                   JSR.abs ("ptrget_b08b");      // get variable address
/* b3c3 */                   JSR.abs ("_ad8d");            // check if source is numeric, else do type mismatch
/* b3c6 */                   JSR.abs ("chkcls_aef7");      // scan for ")", else do syntax error then warm start
/* b3c9 */                   LDA.imm (0xb2);               // get = token
/* b3cb */                   JSR.abs ("chkcom_aeff");      // scan for CHR$(A), else do syntax error then warm start
/* b3ce */                   PHA.imp ();                   // push next character
/* b3cf */                   LDA.zpg ("varpnt+1_0048");    // get current variable pointer high byte
/* b3d1 */                   PHA.imp ();                   // push it
/* b3d2 */                   LDA.zpg ("varpnt+0_0047");    // get current variable pointer low byte
/* b3d4 */                   PHA.imp ();                   // push it
/* b3d5 */                   LDA.zpg ("txtptr+1_007b");    // get BASIC execute pointer high byte
/* b3d7 */                   PHA.imp ();                   // push it
/* b3d8 */                   LDA.zpg ("txtptr+0_007a");    // get BASIC execute pointer low byte
/* b3da */                   PHA.imp ();                   // push it
/* b3db */                   JSR.abs ("data_a8f8");        // perform DATA
/* b3de */                   JMP.abs ("_b44f");            // put execute pointer and variable pointer into function
                                                           // and return

// ------------------------------------------------------- // check FNx syntax
/* b3e1 */  _`getfnm_b3e1`;  LDA.imm (0xa5);               // set FN token
/* b3e3 */                   JSR.abs ("chkcom_aeff");      // scan for CHR$(A), else do syntax error then warm start
/* b3e6 */                   ORA.imm (0x80);               // set FN flag bit
/* b3e8 */                   STA.zpg ("subflg_0010");      // save FN name
/* b3ea */                   JSR.abs ("_b092");            // search for FN variable
/* b3ed */                   STA.zpg ("defpnt+0_004e");    // save function pointer low byte
/* b3ef */                   STY.zpg ("defpnt+1_004f");    // save function pointer high byte
/* b3f1 */                   JMP.abs ("_ad8d");            // check if source is numeric and return, else do type
                                                           // mismatch

// ------------------------------------------------------- // Evaluate FNx
/* b3f4 */  _`fndoer_b3f4`;  JSR.abs ("getfnm_b3e1");      // check FNx syntax
/* b3f7 */                   LDA.zpg ("defpnt+1_004f");    // get function pointer high byte
/* b3f9 */                   PHA.imp ();                   // push it
/* b3fa */                   LDA.zpg ("defpnt+0_004e");    // get function pointer low byte
/* b3fc */                   PHA.imp ();                   // push it
/* b3fd */                   JSR.abs ("parchk_aef1");      // evaluate expression within parentheses
/* b400 */                   JSR.abs ("_ad8d");            // check if source is numeric, else do type mismatch
/* b403 */                   PLA.imp ();                   // pop function pointer low byte
/* b404 */                   STA.zpg ("defpnt+0_004e");    // restore it
/* b406 */                   PLA.imp ();                   // pop function pointer high byte
/* b407 */                   STA.zpg ("defpnt+1_004f");    // restore it
/* b409 */                   LDY.imm (0x02);               // index to variable pointer high byte
/* b40b */                   LDA.iny ("defpnt+0_004e");    // get variable address low byte
/* b40d */                   STA.zpg ("varpnt+0_0047");    // save current variable pointer low byte
/* b40f */                   TAX.imp ();                   // copy address low byte
/* b410 */                   INY.imp ();                   // index to variable address high byte
/* b411 */                   LDA.iny ("defpnt+0_004e");    // get variable pointer high byte
/* b413 */                   BEQ.rel ("_b3ae");            // branch if high byte zero
/* b415 */                   STA.zpg ("varpnt+1_0048");    // save current variable pointer high byte
/* b417 */                   INY.imp ();                   // index to mantissa 3
                                                           // now stack the function variable value before use
/* b418 */        _`_b418`;  LDA.iny ("varpnt+0_0047");    // get byte from variable
/* b41a */                   PHA.imp ();                   // stack it
/* b41b */                   DEY.imp ();                   // decrement index
/* b41c */                   BPL.rel ("_b418");            // loop until variable stacked
/* b41e */                   LDY.zpg ("varpnt+1_0048");    // get current variable pointer high byte
/* b420 */                   JSR.abs ("_bbd4");            // pack FAC1 into (XY)
/* b423 */                   LDA.zpg ("txtptr+1_007b");    // get BASIC execute pointer high byte
/* b425 */                   PHA.imp ();                   // push it
/* b426 */                   LDA.zpg ("txtptr+0_007a");    // get BASIC execute pointer low byte
/* b428 */                   PHA.imp ();                   // push it
/* b429 */                   LDA.iny ("defpnt+0_004e");    // get function execute pointer low byte
/* b42b */                   STA.zpg ("txtptr+0_007a");    // save BASIC execute pointer low byte
/* b42d */                   INY.imp ();                   // index to high byte
/* b42e */                   LDA.iny ("defpnt+0_004e");    // get function execute pointer high byte
/* b430 */                   STA.zpg ("txtptr+1_007b");    // save BASIC execute pointer high byte
/* b432 */                   LDA.zpg ("varpnt+1_0048");    // get current variable pointer high byte
/* b434 */                   PHA.imp ();                   // push it
/* b435 */                   LDA.zpg ("varpnt+0_0047");    // get current variable pointer low byte
/* b437 */                   PHA.imp ();                   // push it
/* b438 */                   JSR.abs ("frmnum_ad8a");      // evaluate expression and check is numeric, else do
                                                           // type mismatch
/* b43b */                   PLA.imp ();                   // pull variable address low byte
/* b43c */                   STA.zpg ("defpnt+0_004e");    // save variable address low byte
/* b43e */                   PLA.imp ();                   // pull variable address high byte
/* b43f */                   STA.zpg ("defpnt+1_004f");    // save variable address high byte
/* b441 */                   JSR.abs ("chrgot_0079");      // scan memory
/* b444 */                   BEQ.rel ("_b449");            // branch if null (should be [EOL] marker)
/* b446 */                   JMP.abs ("synerr_af08");      // else syntax error then warm start

// ------------------------------------------------------- // restore BASIC execute pointer and function variable from stack
/* b449 */        _`_b449`;  PLA.imp ();                   // pull BASIC execute pointer low byte
/* b44a */                   STA.zpg ("txtptr+0_007a");    // save BASIC execute pointer low byte
/* b44c */                   PLA.imp ();                   // pull BASIC execute pointer high byte
/* b44d */                   STA.zpg ("txtptr+1_007b");    // save BASIC execute pointer high byte
                                                           // put execute pointer and variable pointer into function
/* b44f */        _`_b44f`;  LDY.imm (0x00);               // clear index
/* b451 */                   PLA.imp ();                   // pull BASIC execute pointer low byte
/* b452 */                   STA.iny ("defpnt+0_004e");    // save to function
/* b454 */                   PLA.imp ();                   // pull BASIC execute pointer high byte
/* b455 */                   INY.imp ();                   // increment index
/* b456 */                   STA.iny ("defpnt+0_004e");    // save to function
/* b458 */                   PLA.imp ();                   // pull current variable address low byte
/* b459 */                   INY.imp ();                   // increment index
/* b45a */                   STA.iny ("defpnt+0_004e");    // save to function
/* b45c */                   PLA.imp ();                   // pull current variable address high byte
/* b45d */                   INY.imp ();                   // increment index
/* b45e */                   STA.iny ("defpnt+0_004e");    // save to function
/* b460 */                   PLA.imp ();                   // pull ??
/* b461 */                   INY.imp ();                   // increment index
/* b462 */                   STA.iny ("defpnt+0_004e");    // save to function
/* b464 */                   RTS.imp ();

// ------------------------------------------------------- // perform STR$()
/* b465 */    _`strd_b465`;  JSR.abs ("_ad8d");            // check if source is numeric, else do type mismatch
/* b468 */                   LDY.imm (0x00);               // set string index
/* b46a */                   JSR.abs ("_bddf");            // convert FAC1 to string
/* b46d */                   PLA.imp ();                   // dump return address (skip type check)
/* b46e */                   PLA.imp ();                   // dump return address (skip type check)
/* b46f */        _`_b46f`;  LDA.imm (0xff);               // set result string low pointer
/* b471 */                   LDY.imm (0x00);               // set result string high pointer
/* b473 */                   BEQ.rel ("strlit_b487");      // print null terminated string to utility pointer

// ------------------------------------------------------- // do string vector
                                                           // copy descriptor pointer and make string space A bytes long
/* b475 */        _`_b475`;  LDX.zpg ("facho+2_0064");     // get descriptor pointer low byte
/* b477 */                   LDY.zpg ("facho+3_0065");     // get descriptor pointer high byte
/* b479 */                   STX.zpg ("dscpnt+0_0050");    // save descriptor pointer low byte
/* b47b */                   STY.zpg ("dscpnt+1_0051");    // save descriptor pointer high byte

// ------------------------------------------------------- // make string space A bytes long
/* b47d */        _`_b47d`;  JSR.abs ("getspa_b4f4");      // make space in string memory for string A long
/* b480 */                   STX.zpg ("facho+0_0062");     // save string pointer low byte
/* b482 */                   STY.zpg ("facho+1_0063");     // save string pointer high byte
/* b484 */                   STA.zpg ("facexp_0061");      // save length
/* b486 */                   RTS.imp ();

// ------------------------------------------------------- // scan, set up string
                                                           // print " terminated string to utility pointer
/* b487 */  _`strlit_b487`;  LDX.imm (0x22);               // set terminator to "
/* b489 */                   STX.zpg ("charac_0007");      // set search character, terminator 1
/* b48b */                   STX.zpg ("endchr_0008");      // set terminator 2
                                                           // print search or alternate terminated string to utility pointer
                                                           // source is AY
/* b48d */        _`_b48d`;  STA.zpg ("arisgn_006f");      // store string start low byte
/* b48f */                   STY.zpg ("facov_0070");       // store string start high byte
/* b491 */                   STA.zpg ("facho+0_0062");     // save string pointer low byte
/* b493 */                   STY.zpg ("facho+1_0063");     // save string pointer high byte
/* b495 */                   LDY.imm (0xff);               // set length to -1
/* b497 */        _`_b497`;  INY.imp ();                   // increment length
/* b498 */                   LDA.iny ("arisgn_006f");      // get byte from string
/* b49a */                   BEQ.rel ("_b4a8");            // exit loop if null byte [EOS]
/* b49c */                   CMP.zpg ("charac_0007");      // compare with search character, terminator 1
/* b49e */                   BEQ.rel ("_b4a4");            // branch if terminator
/* b4a0 */                   CMP.zpg ("endchr_0008");      // compare with terminator 2
/* b4a2 */                   BNE.rel ("_b497");            // loop if not terminator 2
/* b4a4 */        _`_b4a4`;  CMP.imm (0x22);               // compare with "
/* b4a6 */                   BEQ.rel ("_b4a9");            // branch if " (carry set if = !)
/* b4a8 */        _`_b4a8`;  CLC.imp ();                   // clear carry for add (only if [EOL] terminated string)
/* b4a9 */        _`_b4a9`;  STY.zpg ("facexp_0061");      // save length in FAC1 exponent
/* b4ab */                   TYA.imp ();                   // copy length to A
/* b4ac */                   ADC.zpg ("arisgn_006f");      // add string start low byte
/* b4ae */                   STA.zpg ("fbufpt+0_0071");    // save string end low byte
/* b4b0 */                   LDX.zpg ("facov_0070");       // get string start high byte
/* b4b2 */                   BCC.rel ("_b4b5");            // branch if no low byte overflow
/* b4b4 */                   INX.imp ();                   // else increment high byte
/* b4b5 */        _`_b4b5`;  STX.zpg ("fbufpt+1_0072");    // save string end high byte
/* b4b7 */                   LDA.zpg ("facov_0070");       // get string start high byte
/* b4b9 */                   BEQ.rel ("_b4bf");            // branch if in utility area
/* b4bb */                   CMP.imm (0x02);               // compare with input buffer memory high byte
/* b4bd */                   BNE.rel ("_b4ca");            // branch if not in input buffer memory
                                                           // string in input buffer or utility area, move to string
                                                           // memory
/* b4bf */        _`_b4bf`;  TYA.imp ();                   // copy length to A
/* b4c0 */                   JSR.abs ("_b475");            // copy descriptor pointer and make string space A bytes long
/* b4c3 */                   LDX.zpg ("arisgn_006f");      // get string start low byte
/* b4c5 */                   LDY.zpg ("facov_0070");       // get string start high byte
/* b4c7 */                   JSR.abs ("_b688");            // store string A bytes long from XY to utility pointer
                                                           // check for space on descriptor stack then ...
                                                           // put string address and length on descriptor stack and update stack pointers
/* b4ca */        _`_b4ca`;  LDX.zpg ("temppt_0016");      // get the descriptor stack pointer
/* b4cc */                   CPX.imm (0x22);               // compare it with the maximum + 1
/* b4ce */                   BNE.rel ("putnw1_b4d5");      // if there is space on the string stack continue
                                                           // else do string too complex error
/* b4d0 */                   LDX.imm (0x19);               // error $19, string too complex error
/* b4d2 */        _`_b4d2`;  JMP.abs ("error_a437");       // do error #X then warm start
                                                           // put string address and length on descriptor stack and update stack pointers
/* b4d5 */  _`putnw1_b4d5`;  LDA.zpg ("facexp_0061");      // get the string length
/* b4d7 */                   STA.zpx (0x00);               // put it on the string stack
/* b4d9 */                   LDA.zpg ("facho+0_0062");     // get the string pointer low byte
/* b4db */                   STA.zpx (0x01);               // put it on the string stack
/* b4dd */                   LDA.zpg ("facho+1_0063");     // get the string pointer high byte
/* b4df */                   STA.zpx (0x02);               // put it on the string stack
/* b4e1 */                   LDY.imm (0x00);               // clear Y
/* b4e3 */                   STX.zpg ("facho+2_0064");     // save the string descriptor pointer low byte
/* b4e5 */                   STY.zpg ("facho+3_0065");     // save the string descriptor pointer high byte, always $00
/* b4e7 */                   STY.zpg ("facov_0070");       // clear FAC1 rounding byte
/* b4e9 */                   DEY.imp ();                   // Y = $FF
/* b4ea */                   STY.zpg ("valtyp_000d");      // save the data type flag, $FF = string
/* b4ec */                   STX.zpg ("lastpt+0_0017");    // save the current descriptor stack item pointer low byte
/* b4ee */                   INX.imp ();                   // update the stack pointer
/* b4ef */                   INX.imp ();                   // update the stack pointer
/* b4f0 */                   INX.imp ();                   // update the stack pointer
/* b4f1 */                   STX.zpg ("temppt_0016");      // save the new descriptor stack pointer
/* b4f3 */                   RTS.imp ();

// ------------------------------------------------------- // make space in string memory for string A long
                                                           // return X = pointer low byte, Y = pointer high byte
/* b4f4 */  _`getspa_b4f4`;  LSR.zpg ("garbfl_000f");      // clear garbage collected flag (b7)
                                                           // make space for string A long
/* b4f6 */        _`_b4f6`;  PHA.imp ();                   // save string length
/* b4f7 */                   EOR.imm (0xff);               // complement it
/* b4f9 */                   SEC.imp ();                   // set carry for subtract, two's complement add
/* b4fa */                   ADC.zpg ("fretop+0_0033");    // add bottom of string space low byte, subtract length
/* b4fc */                   LDY.zpg ("fretop+1_0034");    // get bottom of string space high byte
/* b4fe */                   BCS.rel ("_b501");            // skip decrement if no underflow
/* b500 */                   DEY.imp ();                   // decrement bottom of string space high byte
/* b501 */        _`_b501`;  CPY.zpg ("strend+1_0032");    // compare with end of arrays high byte
/* b503 */                   BCC.rel ("_b516");            // do out of memory error if less
/* b505 */                   BNE.rel ("_b50b");            // if not = skip next test
/* b507 */                   CMP.zpg ("strend+0_0031");    // compare with end of arrays low byte
/* b509 */                   BCC.rel ("_b516");            // do out of memory error if less
/* b50b */        _`_b50b`;  STA.zpg ("fretop+0_0033");    // save bottom of string space low byte
/* b50d */                   STY.zpg ("fretop+1_0034");    // save bottom of string space high byte
/* b50f */                   STA.zpg ("frespc+0_0035");    // save string utility ptr low byte
/* b511 */                   STY.zpg ("frespc+1_0036");    // save string utility ptr high byte
/* b513 */                   TAX.imp ();                   // copy low byte to X
/* b514 */                   PLA.imp ();                   // get string length back
/* b515 */                   RTS.imp ();
/* b516 */        _`_b516`;  LDX.imm (0x10);               // error code $10, out of memory error
/* b518 */                   LDA.zpg ("garbfl_000f");      // get garbage collected flag
/* b51a */                   BMI.rel ("_b4d2");            // if set then do error code X
/* b51c */                   JSR.abs ("garbag_b526");      // else go do garbage collection
/* b51f */                   LDA.imm (0x80);               // flag for garbage collected
/* b521 */                   STA.zpg ("garbfl_000f");      // set garbage collected flag
/* b523 */                   PLA.imp ();                   // pull length
/* b524 */                   BNE.rel ("_b4f6");            // go try again (loop always, length should never be = $00)

// ------------------------------------------------------- // garbage collection routine
/* b526 */  _`garbag_b526`;  LDX.zpg ("memsiz+0_0037");    // get end of memory low byte
/* b528 */                   LDA.zpg ("memsiz+1_0038");    // get end of memory high byte
                                                           // re-run routine from last ending
/* b52a */        _`_b52a`;  STX.zpg ("fretop+0_0033");    // set bottom of string space low byte
/* b52c */                   STA.zpg ("fretop+1_0034");    // set bottom of string space high byte
/* b52e */                   LDY.imm (0x00);               // clear index
/* b530 */                   STY.zpg ("defpnt+1_004f");    // clear working pointer high byte
/* b532 */                   STY.zpg ("defpnt+0_004e");    // clear working pointer low byte
/* b534 */                   LDA.zpg ("strend+0_0031");    // get end of arrays low byte
/* b536 */                   LDX.zpg ("strend+1_0032");    // get end of arrays high byte
/* b538 */                   STA.zpg ("tempf2+3_005f");    // save as highest uncollected string pointer low byte
/* b53a */                   STX.zpg ("tempf2+4_0060");    // save as highest uncollected string pointer high byte
/* b53c */                   LDA.imm (0x19);               // set descriptor stack pointer
/* b53e */                   LDX.imm (0x00);               // clear X
/* b540 */                   STA.zpg ("index+0_0022");     // save descriptor stack pointer low byte
/* b542 */                   STX.zpg ("index+1_0023");     // save descriptor stack pointer high byte ($00)
/* b544 */        _`_b544`;  CMP.zpg ("temppt_0016");      // compare with descriptor stack pointer
/* b546 */                   BEQ.rel ("_b54d");            // branch if =
/* b548 */                   JSR.abs ("_b5c7");            // check string salvageability
/* b54b */                   BEQ.rel ("_b544");            // loop always
                                                           // done stacked strings, now do string variables
/* b54d */        _`_b54d`;  LDA.imm (0x07);               // set step size = $07, collecting variables
/* b54f */                   STA.zpg ("four6_0053");       // save garbage collection step size
/* b551 */                   LDA.zpg ("vartab+0_002d");    // get start of variables low byte
/* b553 */                   LDX.zpg ("vartab+1_002e");    // get start of variables high byte
/* b555 */                   STA.zpg ("index+0_0022");     // save as pointer low byte
/* b557 */                   STX.zpg ("index+1_0023");     // save as pointer high byte
/* b559 */        _`_b559`;  CPX.zpg ("arytab+1_0030");    // compare end of variables high byte,
                                                           // start of arrays high byte
/* b55b */                   BNE.rel ("_b561");            // branch if no high byte match
/* b55d */                   CMP.zpg ("arytab+0_002f");    // else compare end of variables low byte,
                                                           // start of arrays low byte
/* b55f */                   BEQ.rel ("_b566");            // branch if = variable memory end
/* b561 */        _`_b561`;  JSR.abs ("dvars_b5bd");       // check variable salvageability
/* b564 */                   BEQ.rel ("_b559");            // loop always
                                                           // done string variables, now do string arrays
/* b566 */        _`_b566`;  STA.zpg ("tempf1+1_0058");    // save start of arrays low byte as working pointer
/* b568 */                   STX.zpg ("tempf1+2_0059");    // save start of arrays high byte as working pointer
/* b56a */                   LDA.imm (0x03);               // set step size, collecting descriptors
/* b56c */                   STA.zpg ("four6_0053");       // save step size
/* b56e */        _`_b56e`;  LDA.zpg ("tempf1+1_0058");    // get pointer low byte
/* b570 */                   LDX.zpg ("tempf1+2_0059");    // get pointer high byte
/* b572 */        _`_b572`;  CPX.zpg ("strend+1_0032");    // compare with end of arrays high byte
/* b574 */                   BNE.rel ("_b57d");            // branch if not at end
/* b576 */                   CMP.zpg ("strend+0_0031");    // else compare with end of arrays low byte
/* b578 */                   BNE.rel ("_b57d");            // branch if not at end
/* b57a */                   JMP.abs ("grbpas_b606");      // collect string, tidy up and exit if at end ??
/* b57d */        _`_b57d`;  STA.zpg ("index+0_0022");     // save pointer low byte
/* b57f */                   STX.zpg ("index+1_0023");     // save pointer high byte
/* b581 */                   LDY.imm (0x00);               // set index
/* b583 */                   LDA.iny ("index+0_0022");     // get array name first byte
/* b585 */                   TAX.imp ();                   // copy it
/* b586 */                   INY.imp ();                   // increment index
/* b587 */                   LDA.iny ("index+0_0022");     // get array name second byte
/* b589 */                   PHP.imp ();                   // push the flags
/* b58a */                   INY.imp ();                   // increment index
/* b58b */                   LDA.iny ("index+0_0022");     // get array size low byte
/* b58d */                   ADC.zpg ("tempf1+1_0058");    // add start of this array low byte
/* b58f */                   STA.zpg ("tempf1+1_0058");    // save start of next array low byte
/* b591 */                   INY.imp ();                   // increment index
/* b592 */                   LDA.iny ("index+0_0022");     // get array size high byte
/* b594 */                   ADC.zpg ("tempf1+2_0059");    // add start of this array high byte
/* b596 */                   STA.zpg ("tempf1+2_0059");    // save start of next array high byte
/* b598 */                   PLP.imp ();                   // restore the flags
/* b599 */                   BPL.rel ("_b56e");            // skip if not string array
                                                           // was possibly string array so ...
/* b59b */                   TXA.imp ();                   // get name first byte back
/* b59c */                   BMI.rel ("_b56e");            // skip if not string array
/* b59e */                   INY.imp ();                   // increment index
/* b59f */                   LDA.iny ("index+0_0022");     // get # of dimensions
/* b5a1 */                   LDY.imm (0x00);               // clear index
/* b5a3 */                   ASL.acc ();                   // *2
/* b5a4 */                   ADC.imm (0x05);               // +5 (array header size)
/* b5a6 */                   ADC.zpg ("index+0_0022");     // add pointer low byte
/* b5a8 */                   STA.zpg ("index+0_0022");     // save pointer low byte
/* b5aa */                   BCC.rel ("_b5ae");            // branch if no rollover
/* b5ac */                   INC.zpg ("index+1_0023");     // else increment pointer hgih byte
/* b5ae */        _`_b5ae`;  LDX.zpg ("index+1_0023");     // get pointer high byte
/* b5b0 */        _`_b5b0`;  CPX.zpg ("tempf1+2_0059");    // compare pointer high byte with end of this array high byte
/* b5b2 */                   BNE.rel ("_b5b8");            // branch if not there yet
/* b5b4 */                   CMP.zpg ("tempf1+1_0058");    // compare pointer low byte with end of this array low byte
/* b5b6 */                   BEQ.rel ("_b572");            // if at end of this array go check next array
/* b5b8 */        _`_b5b8`;  JSR.abs ("_b5c7");            // check string salvageability
/* b5bb */                   BEQ.rel ("_b5b0");            // loop
                                                           // check variable salvageability
/* b5bd */   _`dvars_b5bd`;  LDA.iny ("index+0_0022");     // get variable name first byte
/* b5bf */                   BMI.rel ("_b5f6");            // add step and exit if not string
/* b5c1 */                   INY.imp ();                   // increment index
/* b5c2 */                   LDA.iny ("index+0_0022");     // get variable name second byte
/* b5c4 */                   BPL.rel ("_b5f6");            // add step and exit if not string
/* b5c6 */                   INY.imp ();                   // increment index
                                                           // check string salvageability
/* b5c7 */        _`_b5c7`;  LDA.iny ("index+0_0022");     // get string length
/* b5c9 */                   BEQ.rel ("_b5f6");            // add step and exit if null string
/* b5cb */                   INY.imp ();                   // increment index
/* b5cc */                   LDA.iny ("index+0_0022");     // get string pointer low byte
/* b5ce */                   TAX.imp ();                   // copy to X
/* b5cf */                   INY.imp ();                   // increment index
/* b5d0 */                   LDA.iny ("index+0_0022");     // get string pointer high byte
/* b5d2 */                   CMP.zpg ("fretop+1_0034");    // compare string pointer high byte with bottom of string
                                                           // space high byte
/* b5d4 */                   BCC.rel ("_b5dc");            // if bottom of string space greater go test against highest
                                                           // uncollected string
/* b5d6 */                   BNE.rel ("_b5f6");            // if bottom of string space less string has been collected
                                                           // so go update pointers, step to next and return
                                                           // high bytes were equal so test low bytes
/* b5d8 */                   CPX.zpg ("fretop+0_0033");    // compare string pointer low byte with bottom of string
                                                           // space low byte
/* b5da */                   BCS.rel ("_b5f6");            // if bottom of string space less string has been collected
                                                           // so go update pointers, step to next and return
                                                           // else test string against highest uncollected string so far
/* b5dc */        _`_b5dc`;  CMP.zpg ("tempf2+4_0060");    // compare string pointer high byte with highest uncollected
                                                           // string high byte
/* b5de */                   BCC.rel ("_b5f6");            // if highest uncollected string is greater then go update
                                                           // pointers, step to next and return
/* b5e0 */                   BNE.rel ("_b5e6");            // if highest uncollected string is less then go set this
                                                           // string as highest uncollected so far
                                                           // high bytes were equal so test low bytes
/* b5e2 */                   CPX.zpg ("tempf2+3_005f");    // compare string pointer low byte with highest uncollected
                                                           // string low byte
/* b5e4 */                   BCC.rel ("_b5f6");            // if highest uncollected string is greater then go update
                                                           // pointers, step to next and return
                                                           // else set current string as highest uncollected string
/* b5e6 */        _`_b5e6`;  STX.zpg ("tempf2+3_005f");    // save string pointer low byte as highest uncollected string
                                                           // low byte
/* b5e8 */                   STA.zpg ("tempf2+4_0060");    // save string pointer high byte as highest uncollected
                                                           // string high byte
/* b5ea */                   LDA.zpg ("index+0_0022");     // get descriptor pointer low byte
/* b5ec */                   LDX.zpg ("index+1_0023");     // get descriptor pointer high byte
/* b5ee */                   STA.zpg ("defpnt+0_004e");    // save working pointer high byte
/* b5f0 */                   STX.zpg ("defpnt+1_004f");    // save working pointer low byte
/* b5f2 */                   LDA.zpg ("four6_0053");       // get step size
/* b5f4 */                   STA.zpg ("jmper+1_0055");     // copy step size
/* b5f6 */        _`_b5f6`;  LDA.zpg ("four6_0053");       // get step size
/* b5f8 */                   CLC.imp ();                   // clear carry for add
/* b5f9 */                   ADC.zpg ("index+0_0022");     // add pointer low byte
/* b5fb */                   STA.zpg ("index+0_0022");     // save pointer low byte
/* b5fd */                   BCC.rel ("_b601");            // branch if no rollover
/* b5ff */                   INC.zpg ("index+1_0023");     // else increment pointer high byte
/* b601 */        _`_b601`;  LDX.zpg ("index+1_0023");     // get pointer high byte
/* b603 */                   LDY.imm (0x00);               // flag not moved
/* b605 */                   RTS.imp ();
                                                           // collect string
/* b606 */  _`grbpas_b606`;  LDA.zpg ("defpnt+1_004f");    // get working pointer low byte
/* b608 */                   ORA.zpg ("defpnt+0_004e");    // OR working pointer high byte
/* b60a */                   BEQ.rel ("_b601");            // exit if nothing to collect
/* b60c */                   LDA.zpg ("jmper+1_0055");     // get copied step size
/* b60e */                   AND.imm (0x04);               // mask step size, $04 for variables, $00 for array or stack
/* b610 */                   LSR.acc ();                   // >> 1
/* b611 */                   TAY.imp ();                   // copy to index
/* b612 */                   STA.zpg ("jmper+1_0055");     // save offset to descriptor start
/* b614 */                   LDA.iny ("defpnt+0_004e");    // get string length low byte
/* b616 */                   ADC.zpg ("tempf2+3_005f");    // add string start low byte
/* b618 */                   STA.zpg ("tempf1+3_005a");    // set block end low byte
/* b61a */                   LDA.zpg ("tempf2+4_0060");    // get string start high byte
/* b61c */                   ADC.imm (0x00);               // add carry
/* b61e */                   STA.zpg ("tempf1+4_005b");    // set block end high byte
/* b620 */                   LDA.zpg ("fretop+0_0033");    // get bottom of string space low byte
/* b622 */                   LDX.zpg ("fretop+1_0034");    // get bottom of string space high byte
/* b624 */                   STA.zpg ("tempf1+1_0058");    // save destination end low byte
/* b626 */                   STX.zpg ("tempf1+2_0059");    // save destination end high byte
/* b628 */                   JSR.abs ("_a3bf");            // open up space in memory, don't set array end. this
                                                           // copies the string from where it is to the end of the
                                                           // uncollected string memory
/* b62b */                   LDY.zpg ("jmper+1_0055");     // restore offset to descriptor start
/* b62d */                   INY.imp ();                   // increment index to string pointer low byte
/* b62e */                   LDA.zpg ("tempf1+1_0058");    // get new string pointer low byte
/* b630 */                   STA.iny ("defpnt+0_004e");    // save new string pointer low byte
/* b632 */                   TAX.imp ();                   // copy string pointer low byte
/* b633 */                   INC.zpg ("tempf1+2_0059");    // increment new string pointer high byte
/* b635 */                   LDA.zpg ("tempf1+2_0059");    // get new string pointer high byte
/* b637 */                   INY.imp ();                   // increment index to string pointer high byte
/* b638 */                   STA.iny ("defpnt+0_004e");    // save new string pointer high byte
/* b63a */                   JMP.abs ("_b52a");            // re-run routine from last ending, XA holds new bottom
                                                           // of string memory pointer

// ------------------------------------------------------- // concatenate
                                                           // add strings, the first string is in the descriptor, the second string is in line
/* b63d */     _`cat_b63d`;  LDA.zpg ("facho+3_0065");     // get descriptor pointer high byte
/* b63f */                   PHA.imp ();                   // put on stack
/* b640 */                   LDA.zpg ("facho+2_0064");     // get descriptor pointer low byte
/* b642 */                   PHA.imp ();                   // put on stack
/* b643 */                   JSR.abs ("eval_ae83");        // get value from line
/* b646 */                   JSR.abs ("_ad8f");            // check if source is string, else do type mismatch
/* b649 */                   PLA.imp ();                   // get descriptor pointer low byte back
/* b64a */                   STA.zpg ("arisgn_006f");      // set pointer low byte
/* b64c */                   PLA.imp ();                   // get descriptor pointer high byte back
/* b64d */                   STA.zpg ("facov_0070");       // set pointer high byte
/* b64f */                   LDY.imm (0x00);               // clear index
/* b651 */                   LDA.iny ("arisgn_006f");      // get length of first string from descriptor
/* b653 */                   CLC.imp ();                   // clear carry for add
/* b654 */                   ADC.iny ("facho+2_0064");     // add length of second string
/* b656 */                   BCC.rel ("_b65d");            // branch if no overflow
/* b658 */                   LDX.imm (0x17);               // else error $17, string too long error
/* b65a */                   JMP.abs ("error_a437");       // do error #X then warm start
/* b65d */        _`_b65d`;  JSR.abs ("_b475");            // copy descriptor pointer and make string space A bytes long
/* b660 */                   JSR.abs ("movins_b67a");      // copy string from descriptor to utility pointer
/* b663 */                   LDA.zpg ("dscpnt+0_0050");    // get descriptor pointer low byte
/* b665 */                   LDY.zpg ("dscpnt+1_0051");    // get descriptor pointer high byte
/* b667 */                   JSR.abs ("_b6aa");            // pop (YA) descriptor off stack or from top of string space
                                                           // returns with A = length, X = pointer low byte,
                                                           // Y = pointer high byte
/* b66a */                   JSR.abs ("_b68c");            // store string from pointer to utility pointer
/* b66d */                   LDA.zpg ("arisgn_006f");      // get descriptor pointer low byte
/* b66f */                   LDY.zpg ("facov_0070");       // get descriptor pointer high byte
/* b671 */                   JSR.abs ("_b6aa");            // pop (YA) descriptor off stack or from top of string space
                                                           // returns with A = length, X = pointer low byte,
                                                           // Y = pointer high byte
/* b674 */                   JSR.abs ("_b4ca");            // check space on descriptor stack then put string address
                                                           // and length on descriptor stack and update stack pointers
/* b677 */                   JMP.abs ("_adb8");            // continue evaluation

// ------------------------------------------------------- // copy string from descriptor to utility pointer
/* b67a */  _`movins_b67a`;  LDY.imm (0x00);               // clear index
/* b67c */                   LDA.iny ("arisgn_006f");      // get string length
/* b67e */                   PHA.imp ();                   // save it
/* b67f */                   INY.imp ();                   // increment index
/* b680 */                   LDA.iny ("arisgn_006f");      // get string pointer low byte
/* b682 */                   TAX.imp ();                   // copy to X
/* b683 */                   INY.imp ();                   // increment index
/* b684 */                   LDA.iny ("arisgn_006f");      // get string pointer high byte
/* b686 */                   TAY.imp ();                   // copy to Y
/* b687 */                   PLA.imp ();                   // get length back
/* b688 */        _`_b688`;  STX.zpg ("index+0_0022");     // save string pointer low byte
/* b68a */                   STY.zpg ("index+1_0023");     // save string pointer high byte
                                                           // store string from pointer to utility pointer
/* b68c */        _`_b68c`;  TAY.imp ();                   // copy length as index
/* b68d */                   BEQ.rel ("_b699");            // branch if null string
/* b68f */                   PHA.imp ();                   // save length
/* b690 */        _`_b690`;  DEY.imp ();                   // decrement length/index
/* b691 */                   LDA.iny ("index+0_0022");     // get byte from string
/* b693 */                   STA.iny ("frespc+0_0035");    // save byte to destination
/* b695 */                   TYA.imp ();                   // copy length/index
/* b696 */                   BNE.rel ("_b690");            // loop if not all done yet
/* b698 */                   PLA.imp ();                   // restore length
/* b699 */        _`_b699`;  CLC.imp ();                   // clear carry for add
/* b69a */                   ADC.zpg ("frespc+0_0035");    // add string utility ptr low byte
/* b69c */                   STA.zpg ("frespc+0_0035");    // save string utility ptr low byte
/* b69e */                   BCC.rel ("_b6a2");            // branch if no rollover
/* b6a0 */                   INC.zpg ("frespc+1_0036");    // increment string utility ptr high byte
/* b6a2 */        _`_b6a2`;  RTS.imp ();

// ------------------------------------------------------- // evaluate string
/* b6a3 */  _`frestr_b6a3`;  JSR.abs ("_ad8f");            // check if source is string, else do type mismatch
                                                           // pop string off descriptor stack, or from top of string space
                                                           // returns with A = length, X = pointer low byte, Y = pointer high byte
/* b6a6 */        _`_b6a6`;  LDA.zpg ("facho+2_0064");     // get descriptor pointer low byte
/* b6a8 */                   LDY.zpg ("facho+3_0065");     // get descriptor pointer high byte
                                                           // pop (YA) descriptor off stack or from top of string space
                                                           // returns with A = length, X = pointer low byte, Y = pointer high byte
/* b6aa */        _`_b6aa`;  STA.zpg ("index+0_0022");     // save string pointer low byte
/* b6ac */                   STY.zpg ("index+1_0023");     // save string pointer high byte
/* b6ae */                   JSR.abs ("frefac_b6db");      // clean descriptor stack, YA = pointer
/* b6b1 */                   PHP.imp ();                   // save status flags
/* b6b2 */                   LDY.imm (0x00);               // clear index
/* b6b4 */                   LDA.iny ("index+0_0022");     // get length from string descriptor
/* b6b6 */                   PHA.imp ();                   // put on stack
/* b6b7 */                   INY.imp ();                   // increment index
/* b6b8 */                   LDA.iny ("index+0_0022");     // get string pointer low byte from descriptor
/* b6ba */                   TAX.imp ();                   // copy to X
/* b6bb */                   INY.imp ();                   // increment index
/* b6bc */                   LDA.iny ("index+0_0022");     // get string pointer high byte from descriptor
/* b6be */                   TAY.imp ();                   // copy to Y
/* b6bf */                   PLA.imp ();                   // get string length back
/* b6c0 */                   PLP.imp ();                   // restore status
/* b6c1 */                   BNE.rel ("_b6d6");            // branch if pointer <> last_sl,last_sh
/* b6c3 */                   CPY.zpg ("fretop+1_0034");    // compare with bottom of string space high byte
/* b6c5 */                   BNE.rel ("_b6d6");            // branch if <>
/* b6c7 */                   CPX.zpg ("fretop+0_0033");    // else compare with bottom of string space low byte
/* b6c9 */                   BNE.rel ("_b6d6");            // branch if <>
/* b6cb */                   PHA.imp ();                   // save string length
/* b6cc */                   CLC.imp ();                   // clear carry for add
/* b6cd */                   ADC.zpg ("fretop+0_0033");    // add bottom of string space low byte
/* b6cf */                   STA.zpg ("fretop+0_0033");    // set bottom of string space low byte
/* b6d1 */                   BCC.rel ("_b6d5");            // skip increment if no overflow
/* b6d3 */                   INC.zpg ("fretop+1_0034");    // increment bottom of string space high byte
/* b6d5 */        _`_b6d5`;  PLA.imp ();                   // restore string length
/* b6d6 */        _`_b6d6`;  STX.zpg ("index+0_0022");     // save string pointer low byte
/* b6d8 */                   STY.zpg ("index+1_0023");     // save string pointer high byte
/* b6da */                   RTS.imp ();
                                                           // clean descriptor stack, YA = pointer
                                                           // checks if AY is on the descriptor stack, if so does a stack discard
/* b6db */  _`frefac_b6db`;  CPY.zpg ("lastpt+1_0018");    // compare high byte with current descriptor stack item
                                                           // pointer high byte
/* b6dd */                   BNE.rel ("_b6eb");            // exit if <>
/* b6df */                   CMP.zpg ("lastpt+0_0017");    // compare low byte with current descriptor stack item
                                                           // pointer low byte
/* b6e1 */                   BNE.rel ("_b6eb");            // exit if <>
/* b6e3 */                   STA.zpg ("temppt_0016");      // set descriptor stack pointer
/* b6e5 */                   SBC.imm (0x03);               // update last string pointer low byte
/* b6e7 */                   STA.zpg ("lastpt+0_0017");    // save current descriptor stack item pointer low byte
/* b6e9 */                   LDY.imm (0x00);               // clear high byte
/* b6eb */        _`_b6eb`;  RTS.imp ();

// ------------------------------------------------------- // perform CHR$()
/* b6ec */    _`chrd_b6ec`;  JSR.abs ("_b7a1");            // evaluate byte expression, result in X
/* b6ef */                   TXA.imp ();                   // copy to A
/* b6f0 */                   PHA.imp ();                   // save character
/* b6f1 */                   LDA.imm (0x01);               // string is single byte
/* b6f3 */                   JSR.abs ("_b47d");            // make string space A bytes long
/* b6f6 */                   PLA.imp ();                   // get character back
/* b6f7 */                   LDY.imm (0x00);               // clear index
/* b6f9 */                   STA.iny ("facho+0_0062");     // save byte in string - byte IS string!
/* b6fb */                   PLA.imp ();                   // dump return address (skip type check)
/* b6fc */                   PLA.imp ();                   // dump return address (skip type check)
/* b6fd */                   JMP.abs ("_b4ca");            // check space on descriptor stack then put string address
                                                           // and length on descriptor stack and update stack pointers

// ------------------------------------------------------- // perform LEFT$()
/* b700 */   _`leftd_b700`;  JSR.abs ("pream_b761");       // pull string data and byte parameter from stack
                                                           // return pointer in descriptor, byte in A (and X), Y=0
/* b703 */                   CMP.iny ("dscpnt+0_0050");    // compare byte parameter with string length
/* b705 */                   TYA.imp ();                   // clear A
/* b706 */        _`_b706`;  BCC.rel ("_b70c");            // branch if string length > byte parameter
/* b708 */                   LDA.iny ("dscpnt+0_0050");    // else make parameter = length
/* b70a */                   TAX.imp ();                   // copy to byte parameter copy
/* b70b */                   TYA.imp ();                   // clear string start offset
/* b70c */        _`_b70c`;  PHA.imp ();                   // save string start offset
/* b70d */        _`_b70d`;  TXA.imp ();                   // copy byte parameter (or string length if <)
/* b70e */        _`_b70e`;  PHA.imp ();                   // save string length
/* b70f */                   JSR.abs ("_b47d");            // make string space A bytes long
/* b712 */                   LDA.zpg ("dscpnt+0_0050");    // get descriptor pointer low byte
/* b714 */                   LDY.zpg ("dscpnt+1_0051");    // get descriptor pointer high byte
/* b716 */                   JSR.abs ("_b6aa");            // pop (YA) descriptor off stack or from top of string space
                                                           // returns with A = length, X = pointer low byte,
                                                           // Y = pointer high byte
/* b719 */                   PLA.imp ();                   // get string length back
/* b71a */                   TAY.imp ();                   // copy length to Y
/* b71b */                   PLA.imp ();                   // get string start offset back
/* b71c */                   CLC.imp ();                   // clear carry for add
/* b71d */                   ADC.zpg ("index+0_0022");     // add start offset to string start pointer low byte
/* b71f */                   STA.zpg ("index+0_0022");     // save string start pointer low byte
/* b721 */                   BCC.rel ("_b725");            // branch if no overflow
/* b723 */                   INC.zpg ("index+1_0023");     // else increment string start pointer high byte
/* b725 */        _`_b725`;  TYA.imp ();                   // copy length to A
/* b726 */                   JSR.abs ("_b68c");            // store string from pointer to utility pointer
/* b729 */                   JMP.abs ("_b4ca");            // check space on descriptor stack then put string address
                                                           // and length on descriptor stack and update stack pointers

// ------------------------------------------------------- // perform RIGHT$()
/* b72c */  _`rightd_b72c`;  JSR.abs ("pream_b761");       // pull string data and byte parameter from stack
                                                           // return pointer in descriptor, byte in A (and X), Y=0
/* b72f */                   CLC.imp ();                   // clear carry for add-1
/* b730 */                   SBC.iny ("dscpnt+0_0050");    // subtract string length
/* b732 */                   EOR.imm (0xff);               // invert it (A=LEN(expression$)-l)
/* b734 */                   JMP.abs ("_b706");            // go do rest of LEFT$()

// ------------------------------------------------------- // perform MID$()
/* b737 */    _`midd_b737`;  LDA.imm (0xff);               // set default length = 255
/* b739 */                   STA.zpg ("facho+3_0065");     // save default length
/* b73b */                   JSR.abs ("chrgot_0079");      // scan memory
/* b73e */                   CMP.imm (0x29);               // compare with ")"
/* b740 */                   BEQ.rel ("_b748");            // branch if = ")" (skip second byte get)
/* b742 */                   JSR.abs ("_aefd");            // scan for ",", else do syntax error then warm start
/* b745 */                   JSR.abs ("_b79e");            // get byte parameter
/* b748 */        _`_b748`;  JSR.abs ("pream_b761");       // pull string data and byte parameter from stack
                                                           // return pointer in descriptor, byte in A (and X), Y=0
/* b74b */                   BEQ.rel ("_b798");            // if null do illegal quantity error then warm start
/* b74d */                   DEX.imp ();                   // decrement start index
/* b74e */                   TXA.imp ();                   // copy to A
/* b74f */                   PHA.imp ();                   // save string start offset
/* b750 */                   CLC.imp ();                   // clear carry for sub-1
/* b751 */                   LDX.imm (0x00);               // clear output string length
/* b753 */                   SBC.iny ("dscpnt+0_0050");    // subtract string length
/* b755 */                   BCS.rel ("_b70d");            // if start>string length go do null string
/* b757 */                   EOR.imm (0xff);               // complement -length
/* b759 */                   CMP.zpg ("facho+3_0065");     // compare byte parameter
/* b75b */                   BCC.rel ("_b70e");            // if length>remaining string go do RIGHT$
/* b75d */                   LDA.zpg ("facho+3_0065");     // get length byte
/* b75f */                   BCS.rel ("_b70e");            // go do string copy, branch always

// ------------------------------------------------------- // pull string data and byte parameter from stack
                                                           // return pointer in descriptor, byte in A (and X), Y=0
/* b761 */   _`pream_b761`;  JSR.abs ("chkcls_aef7");      // scan for ")", else do syntax error then warm start
/* b764 */                   PLA.imp ();                   // pull return address low byte
/* b765 */                   TAY.imp ();                   // save return address low byte
/* b766 */                   PLA.imp ();                   // pull return address high byte
/* b767 */                   STA.zpg ("jmper+1_0055");     // save return address high byte
/* b769 */                   PLA.imp ();                   // dump call to function vector low byte
/* b76a */                   PLA.imp ();                   // dump call to function vector high byte
/* b76b */                   PLA.imp ();                   // pull byte parameter
/* b76c */                   TAX.imp ();                   // copy byte parameter to X
/* b76d */                   PLA.imp ();                   // pull string pointer low byte
/* b76e */                   STA.zpg ("dscpnt+0_0050");    // save it
/* b770 */                   PLA.imp ();                   // pull string pointer high byte
/* b771 */                   STA.zpg ("dscpnt+1_0051");    // save it
/* b773 */                   LDA.zpg ("jmper+1_0055");     // get return address high byte
/* b775 */                   PHA.imp ();                   // back on stack
/* b776 */                   TYA.imp ();                   // get return address low byte
/* b777 */                   PHA.imp ();                   // back on stack
/* b778 */                   LDY.imm (0x00);               // clear index
/* b77a */                   TXA.imp ();                   // copy byte parameter
/* b77b */                   RTS.imp ();

// ------------------------------------------------------- // perform LEN()
/* b77c */     _`len_b77c`;  JSR.abs ("len1_b782");        // evaluate string, get length in A (and Y)
/* b77f */                   JMP.abs ("_b3a2");            // convert Y to byte in FAC1 and return

// ------------------------------------------------------- // evaluate string, get length in Y
/* b782 */    _`len1_b782`;  JSR.abs ("frestr_b6a3");      // evaluate string
/* b785 */                   LDX.imm (0x00);               // set data type = numeric
/* b787 */                   STX.zpg ("valtyp_000d");      // clear data type flag, $FF = string, $00 = numeric
/* b789 */                   TAY.imp ();                   // copy length to Y
/* b78a */                   RTS.imp ();

// ------------------------------------------------------- // perform ASC()
/* b78b */     _`asc_b78b`;  JSR.abs ("len1_b782");        // evaluate string, get length in A (and Y)
/* b78e */                   BEQ.rel ("_b798");            // if null do illegal quantity error then warm start
/* b790 */                   LDY.imm (0x00);               // set index to first character
/* b792 */                   LDA.iny ("index+0_0022");     // get byte
/* b794 */                   TAY.imp ();                   // copy to Y
/* b795 */                   JMP.abs ("_b3a2");            // convert Y to byte in FAC1 and return

// ------------------------------------------------------- // do illegal quantity error then warm start
/* b798 */        _`_b798`;  JMP.abs ("fcerr_b248");       // do illegal quantity error then warm start

// ------------------------------------------------------- // scan and get byte parameter
/* b79b */  _`gtbytc_b79b`;  JSR.abs ("chrget+0_0073");    // increment and scan memory

// ------------------------------------------------------- // get byte parameter
/* b79e */        _`_b79e`;  JSR.abs ("frmnum_ad8a");      // evaluate expression and check is numeric, else do
                                                           // type mismatch

// ------------------------------------------------------- // evaluate byte expression, result in X
/* b7a1 */        _`_b7a1`;  JSR.abs ("_b1b8");            // evaluate integer expression, sign check
/* b7a4 */                   LDX.zpg ("facho+2_0064");     // get FAC1 mantissa 3
/* b7a6 */                   BNE.rel ("_b798");            // if not null do illegal quantity error then warm start
/* b7a8 */                   LDX.zpg ("facho+3_0065");     // get FAC1 mantissa 4
/* b7aa */                   JMP.abs ("chrgot_0079");      // scan memory and return

// ------------------------------------------------------- // perform VAL()
/* b7ad */     _`val_b7ad`;  JSR.abs ("len1_b782");        // evaluate string, get length in A (and Y)
/* b7b0 */                   BNE.rel ("strval_b7b5");      // branch if not null string
                                                           // string was null so set result = $00
/* b7b2 */                   JMP.abs ("_b8f7");            // clear FAC1 exponent and sign and return
/* b7b5 */  _`strval_b7b5`;  LDX.zpg ("txtptr+0_007a");    // get BASIC execute pointer low byte
/* b7b7 */                   LDY.zpg ("txtptr+1_007b");    // get BASIC execute pointer high byte
/* b7b9 */                   STX.zpg ("fbufpt+0_0071");    // save BASIC execute pointer low byte
/* b7bb */                   STY.zpg ("fbufpt+1_0072");    // save BASIC execute pointer high byte
/* b7bd */                   LDX.zpg ("index+0_0022");     // get string pointer low byte
/* b7bf */                   STX.zpg ("txtptr+0_007a");    // save BASIC execute pointer low byte
/* b7c1 */                   CLC.imp ();                   // clear carry for add
/* b7c2 */                   ADC.zpg ("index+0_0022");     // add string length
/* b7c4 */                   STA.zpg ("index+2_0024");     // save string end low byte
/* b7c6 */                   LDX.zpg ("index+1_0023");     // get string pointer high byte
/* b7c8 */                   STX.zpg ("txtptr+1_007b");    // save BASIC execute pointer high byte
/* b7ca */                   BCC.rel ("_b7cd");            // branch if no high byte increment
/* b7cc */                   INX.imp ();                   // increment string end high byte
/* b7cd */        _`_b7cd`;  STX.zpg ("index+3_0025");     // save string end high byte
/* b7cf */                   LDY.imm (0x00);               // set index to $00
/* b7d1 */                   LDA.iny ("index+2_0024");     // get string end byte
/* b7d3 */                   PHA.imp ();                   // push it
/* b7d4 */                   TYA.imp ();                   // clear A
/* b7d5 */                   STA.iny ("index+2_0024");     // terminate string with $00
/* b7d7 */                   JSR.abs ("chrgot_0079");      // scan memory
/* b7da */                   JSR.abs ("fin_bcf3");         // get FAC1 from string
/* b7dd */                   PLA.imp ();                   // restore string end byte
/* b7de */                   LDY.imm (0x00);               // clear index
/* b7e0 */                   STA.iny ("index+2_0024");     // put string end byte back

// ------------------------------------------------------- // restore BASIC execute pointer from temp
/* b7e2 */        _`_b7e2`;  LDX.zpg ("fbufpt+0_0071");    // get BASIC execute pointer low byte back
/* b7e4 */                   LDY.zpg ("fbufpt+1_0072");    // get BASIC execute pointer high byte back
/* b7e6 */                   STX.zpg ("txtptr+0_007a");    // save BASIC execute pointer low byte
/* b7e8 */                   STY.zpg ("txtptr+1_007b");    // save BASIC execute pointer high byte
/* b7ea */                   RTS.imp ();

// ------------------------------------------------------- // get parameters for POKE/WAIT
/* b7eb */  _`getnum_b7eb`;  JSR.abs ("frmnum_ad8a");      // evaluate expression and check is numeric, else do
                                                           // type mismatch
/* b7ee */                   JSR.abs ("getadr_b7f7");      // convert FAC_1 to integer in temporary integer
/* b7f1 */        _`_b7f1`;  JSR.abs ("_aefd");            // scan for ",", else do syntax error then warm start
/* b7f4 */                   JMP.abs ("_b79e");            // get byte parameter and return

// ------------------------------------------------------- // convert FAC_1 to integer in temporary integer
/* b7f7 */  _`getadr_b7f7`;  LDA.zpg ("facsgn_0066");      // get FAC1 sign
/* b7f9 */                   BMI.rel ("_b798");            // if -ve do illegal quantity error then warm start
/* b7fb */                   LDA.zpg ("facexp_0061");      // get FAC1 exponent
/* b7fd */                   CMP.imm (0x91);               // compare with exponent = 2^16
/* b7ff */                   BCS.rel ("_b798");            // if >= do illegal quantity error then warm start
/* b801 */                   JSR.abs ("qint_bc9b");        // convert FAC1 floating to fixed
/* b804 */                   LDA.zpg ("facho+2_0064");     // get FAC1 mantissa 3
/* b806 */                   LDY.zpg ("facho+3_0065");     // get FAC1 mantissa 4
/* b808 */                   STY.zpg ("linnum+0_0014");    // save temporary integer low byte
/* b80a */                   STA.zpg ("linnum+1_0015");    // save temporary integer high byte
/* b80c */                   RTS.imp ();

// ------------------------------------------------------- // perform PEEK()
/* b80d */    _`peek_b80d`;  LDA.zpg ("linnum+1_0015");    // get line number high byte
/* b80f */                   PHA.imp ();                   // save line number high byte
/* b810 */                   LDA.zpg ("linnum+0_0014");    // get line number low byte
/* b812 */                   PHA.imp ();                   // save line number low byte
/* b813 */                   JSR.abs ("getadr_b7f7");      // convert FAC_1 to integer in temporary integer
/* b816 */                   LDY.imm (0x00);               // clear index
/* b818 */                   LDA.iny ("linnum+0_0014");    // read byte
/* b81a */                   TAY.imp ();                   // copy byte to A
/* b81b */                   PLA.imp ();                   // pull byte
/* b81c */                   STA.zpg ("linnum+0_0014");    // restore line number low byte
/* b81e */                   PLA.imp ();                   // pull byte
/* b81f */                   STA.zpg ("linnum+1_0015");    // restore line number high byte
/* b821 */                   JMP.abs ("_b3a2");            // convert Y to byte in FAC_1 and return

// ------------------------------------------------------- // perform POKE
/* b824 */    _`poke_b824`;  JSR.abs ("getnum_b7eb");      // get parameters for POKE/WAIT
/* b827 */                   TXA.imp ();                   // copy byte to A
/* b828 */                   LDY.imm (0x00);               // clear index
/* b82a */                   STA.iny ("linnum+0_0014");    // write byte
/* b82c */                   RTS.imp ();

// ------------------------------------------------------- // perform WAIT
/* b82d */    _`wait_b82d`;  JSR.abs ("getnum_b7eb");      // get parameters for POKE/WAIT
/* b830 */                   STX.zpg ("forpnt+0_0049");    // save byte
/* b832 */                   LDX.imm (0x00);               // clear mask
/* b834 */                   JSR.abs ("chrgot_0079");      // scan memory
/* b837 */                   BEQ.rel ("_b83c");            // skip if no third argument
/* b839 */                   JSR.abs ("_b7f1");            // scan for "," and get byte, else syntax error then
                                                           // warm start
/* b83c */        _`_b83c`;  STX.zpg ("forpnt+1_004a");    // save EOR argument
/* b83e */                   LDY.imm (0x00);               // clear index
/* b840 */        _`_b840`;  LDA.iny ("linnum+0_0014");    // get byte via temporary integer (address)
/* b842 */                   EOR.zpg ("forpnt+1_004a");    // EOR with second argument       (mask)
/* b844 */                   AND.zpg ("forpnt+0_0049");    // AND with first argument        (byte)
/* b846 */                   BEQ.rel ("_b840");            // loop if result is zero
/* b848 */        _`_b848`;  RTS.imp ();

// ------------------------------------------------------- // add 0.5 to FAC1 (round FAC1)
/* b849 */   _`faddh_b849`;  LDA.imm (0x11);               // set 0.5 pointer low byte
/* b84b */                   LDY.imm (0xbf);               // set 0.5 pointer high byte
/* b84d */                   JMP.abs ("fadd_b867");        // add (AY) to FAC1

// ------------------------------------------------------- // perform subtraction, FAC1 from (AY)
/* b850 */    _`fsub_b850`;  JSR.abs ("conupk_ba8c");      // unpack memory (AY) into FAC2

// ------------------------------------------------------- // perform subtraction, FAC1 from FAC2
/* b853 */   _`fsubt_b853`;  LDA.zpg ("facsgn_0066");      // get FAC1 sign (b7)
/* b855 */                   EOR.imm (0xff);               // complement it
/* b857 */                   STA.zpg ("facsgn_0066");      // save FAC1 sign (b7)
/* b859 */                   EOR.zpg ("argsgn_006e");      // EOR with FAC2 sign (b7)
/* b85b */                   STA.zpg ("arisgn_006f");      // save sign compare (FAC1 EOR FAC2)
/* b85d */                   LDA.zpg ("facexp_0061");      // get FAC1 exponent
/* b85f */                   JMP.abs ("faddt_b86a");       // add FAC2 to FAC1 and return
/* b862 */   _`fadd5_b862`;  JSR.abs ("_b999");            // shift FACX A times right (>8 shifts)
/* b865 */                   BCC.rel ("_b8a3");            // go subtract mantissas

// ------------------------------------------------------- // add (AY) to FAC1
/* b867 */    _`fadd_b867`;  JSR.abs ("conupk_ba8c");      // unpack memory (AY) into FAC2

// ------------------------------------------------------- // add FAC2 to FAC1
/* b86a */   _`faddt_b86a`;  BNE.rel ("_b86f");            // branch if FAC1 is not zero
/* b86c */                   JMP.abs ("movfa_bbfc");       // FAC1 was zero so copy FAC2 to FAC1 and return
                                                           // FAC1 is non zero
/* b86f */        _`_b86f`;  LDX.zpg ("facov_0070");       // get FAC1 rounding byte
/* b871 */                   STX.zpg ("jmper+2_0056");     // save as FAC2 rounding byte
/* b873 */                   LDX.imm (0x69);               // set index to FAC2 exponent address
/* b875 */                   LDA.zpg ("argexp_0069");      // get FAC2 exponent
/* b877 */        _`_b877`;  TAY.imp ();                   // copy exponent
/* b878 */                   BEQ.rel ("_b848");            // exit if zero
/* b87a */                   SEC.imp ();                   // set carry for subtract
/* b87b */                   SBC.zpg ("facexp_0061");      // subtract FAC1 exponent
/* b87d */                   BEQ.rel ("_b8a3");            // if equal go add mantissas
/* b87f */                   BCC.rel ("_b893");            // if FAC2 < FAC1 then go shift FAC2 right
                                                           // else FAC2 > FAC1
/* b881 */                   STY.zpg ("facexp_0061");      // save FAC1 exponent
/* b883 */                   LDY.zpg ("argsgn_006e");      // get FAC2 sign (b7)
/* b885 */                   STY.zpg ("facsgn_0066");      // save FAC1 sign (b7)
/* b887 */                   EOR.imm (0xff);               // complement A
/* b889 */                   ADC.imm (0x00);               // +1, twos complement, carry is set
/* b88b */                   LDY.imm (0x00);               // clear Y
/* b88d */                   STY.zpg ("jmper+2_0056");     // clear FAC2 rounding byte
/* b88f */                   LDX.imm (0x61);               // set index to FAC1 exponent address
/* b891 */                   BNE.rel ("_b897");            // branch always
                                                           // FAC2 < FAC1
/* b893 */        _`_b893`;  LDY.imm (0x00);               // clear Y
/* b895 */                   STY.zpg ("facov_0070");       // clear FAC1 rounding byte
/* b897 */        _`_b897`;  CMP.imm (0xf9);               // compare exponent diff with $F9
/* b899 */                   BMI.rel ("fadd5_b862");       // branch if range $79-$F8
/* b89b */                   TAY.imp ();                   // copy exponent difference to Y
/* b89c */                   LDA.zpg ("facov_0070");       // get FAC1 rounding byte
/* b89e */                   LSR.zpx (0x01);               // shift FAC? mantissa 1
/* b8a0 */                   JSR.abs ("_b9b0");            // shift FACX Y times right
                                                           // exponents are equal now do mantissa subtract
/* b8a3 */        _`_b8a3`;  BIT.zpg ("arisgn_006f");      // test sign compare (FAC1 EOR FAC2)
/* b8a5 */                   BPL.rel ("normal_b8fe");      // if = add FAC2 mantissa to FAC1 mantissa and return
/* b8a7 */   _`fadd4_b8a7`;  LDY.imm (0x61);               // set the Y index to FAC1 exponent address
/* b8a9 */                   CPX.imm (0x69);               // compare X to FAC2 exponent address
/* b8ab */                   BEQ.rel ("_b8af");            // if = continue, Y = FAC1, X = FAC2
/* b8ad */                   LDY.imm (0x69);               // else set the Y index to FAC2 exponent address
                                                           // subtract the smaller from the bigger (take the sign of
                                                           // the bigger)
/* b8af */        _`_b8af`;  SEC.imp ();                   // set carry for subtract
/* b8b0 */                   EOR.imm (0xff);               // ones complement A
/* b8b2 */                   ADC.zpg ("jmper+2_0056");     // add FAC2 rounding byte
/* b8b4 */                   STA.zpg ("facov_0070");       // save FAC1 rounding byte
/* b8b6 */                   LDA.aby ("adray1+1_0004");    // get FACY mantissa 4
/* b8b9 */                   SBC.zpx (0x04);               // subtract FACX mantissa 4
/* b8bb */                   STA.zpg ("facho+3_0065");     // save FAC1 mantissa 4
/* b8bd */                   LDA.aby ("adray1+0_0003");    // get FACY mantissa 3
/* b8c0 */                   SBC.zpx (0x03);               // subtract FACX mantissa 3
/* b8c2 */                   STA.zpg ("facho+2_0064");     // save FAC1 mantissa 3
/* b8c4 */                   LDA.aby ("_0002");            // get FACY mantissa 2
/* b8c7 */                   SBC.zpx (0x02);               // subtract FACX mantissa 2
/* b8c9 */                   STA.zpg ("facho+1_0063");     // save FAC1 mantissa 2
/* b8cb */                   LDA.aby ("r6510_0001");       // get FACY mantissa 1
/* b8ce */                   SBC.zpx (0x01);               // subtract FACX mantissa 1
/* b8d0 */                   STA.zpg ("facho+0_0062");     // save FAC1 mantissa 1

// ------------------------------------------------------- // do ABS and normalise FAC1
/* b8d2 */        _`_b8d2`;  BCS.rel ("_b8d7");            // branch if number is +ve
/* b8d4 */                   JSR.abs ("negfac_b947");      // negate FAC1

// ------------------------------------------------------- // normalise FAC1
/* b8d7 */        _`_b8d7`;  LDY.imm (0x00);               // clear Y
/* b8d9 */                   TYA.imp ();                   // clear A
/* b8da */                   CLC.imp ();                   // clear carry for add
/* b8db */        _`_b8db`;  LDX.zpg ("facho+0_0062");     // get FAC1 mantissa 1
/* b8dd */                   BNE.rel ("_b929");            // if not zero normalise FAC1
/* b8df */                   LDX.zpg ("facho+1_0063");     // get FAC1 mantissa 2
/* b8e1 */                   STX.zpg ("facho+0_0062");     // save FAC1 mantissa 1
/* b8e3 */                   LDX.zpg ("facho+2_0064");     // get FAC1 mantissa 3
/* b8e5 */                   STX.zpg ("facho+1_0063");     // save FAC1 mantissa 2
/* b8e7 */                   LDX.zpg ("facho+3_0065");     // get FAC1 mantissa 4
/* b8e9 */                   STX.zpg ("facho+2_0064");     // save FAC1 mantissa 3
/* b8eb */                   LDX.zpg ("facov_0070");       // get FAC1 rounding byte
/* b8ed */                   STX.zpg ("facho+3_0065");     // save FAC1 mantissa 4
/* b8ef */                   STY.zpg ("facov_0070");       // clear FAC1 rounding byte
/* b8f1 */                   ADC.imm (0x08);               // add x to exponent offset
/* b8f3 */                   CMP.imm (0x20);               // compare with $20, max offset, all bits would be = 0
/* b8f5 */                   BNE.rel ("_b8db");            // loop if not max

// ------------------------------------------------------- // clear FAC1 exponent and sign
/* b8f7 */        _`_b8f7`;  LDA.imm (0x00);               // clear A
/* b8f9 */        _`_b8f9`;  STA.zpg ("facexp_0061");      // set FAC1 exponent

// ------------------------------------------------------- // save FAC1 sign
/* b8fb */        _`_b8fb`;  STA.zpg ("facsgn_0066");      // save FAC1 sign (b7)
/* b8fd */                   RTS.imp ();

// ------------------------------------------------------- // add FAC2 mantissa to FAC1 mantissa
/* b8fe */  _`normal_b8fe`;  ADC.zpg ("jmper+2_0056");     // add FAC2 rounding byte
/* b900 */                   STA.zpg ("facov_0070");       // save FAC1 rounding byte
/* b902 */                   LDA.zpg ("facho+3_0065");     // get FAC1 mantissa 4
/* b904 */                   ADC.zpg ("argho+3_006d");     // add FAC2 mantissa 4
/* b906 */                   STA.zpg ("facho+3_0065");     // save FAC1 mantissa 4
/* b908 */                   LDA.zpg ("facho+2_0064");     // get FAC1 mantissa 3
/* b90a */                   ADC.zpg ("argho+2_006c");     // add FAC2 mantissa 3
/* b90c */                   STA.zpg ("facho+2_0064");     // save FAC1 mantissa 3
/* b90e */                   LDA.zpg ("facho+1_0063");     // get FAC1 mantissa 2
/* b910 */                   ADC.zpg ("argho+1_006b");     // add FAC2 mantissa 2
/* b912 */                   STA.zpg ("facho+1_0063");     // save FAC1 mantissa 2
/* b914 */                   LDA.zpg ("facho+0_0062");     // get FAC1 mantissa 1
/* b916 */                   ADC.zpg ("argho+0_006a");     // add FAC2 mantissa 1
/* b918 */                   STA.zpg ("facho+0_0062");     // save FAC1 mantissa 1
/* b91a */                   JMP.abs ("_b936");            // test and normalise FAC1 for C=0/1
/* b91d */        _`_b91d`;  ADC.imm (0x01);               // add 1 to exponent offset
/* b91f */                   ASL.zpg ("facov_0070");       // shift FAC1 rounding byte
/* b921 */                   ROL.zpg ("facho+3_0065");     // shift FAC1 mantissa 4
/* b923 */                   ROL.zpg ("facho+2_0064");     // shift FAC1 mantissa 3
/* b925 */                   ROL.zpg ("facho+1_0063");     // shift FAC1 mantissa 2
/* b927 */                   ROL.zpg ("facho+0_0062");     // shift FAC1 mantissa 1
                                                           // normalise FAC1
/* b929 */        _`_b929`;  BPL.rel ("_b91d");            // loop if not normalised
/* b92b */                   SEC.imp ();                   // set carry for subtract
/* b92c */                   SBC.zpg ("facexp_0061");      // subtract FAC1 exponent
/* b92e */                   BCS.rel ("_b8f7");            // branch if underflow (set result = $0)
/* b930 */                   EOR.imm (0xff);               // complement exponent
/* b932 */                   ADC.imm (0x01);               // +1 (twos complement)
/* b934 */                   STA.zpg ("facexp_0061");      // save FAC1 exponent
                                                           // test and normalise FAC1 for C=0/1
/* b936 */        _`_b936`;  BCC.rel ("_b946");            // exit if no overflow
                                                           // normalise FAC1 for C=1
/* b938 */        _`_b938`;  INC.zpg ("facexp_0061");      // increment FAC1 exponent
/* b93a */                   BEQ.rel ("overr_b97e");       // if zero do overflow error then warm start
/* b93c */                   ROR.zpg ("facho+0_0062");     // shift FAC1 mantissa 1
/* b93e */                   ROR.zpg ("facho+1_0063");     // shift FAC1 mantissa 2
/* b940 */                   ROR.zpg ("facho+2_0064");     // shift FAC1 mantissa 3
/* b942 */                   ROR.zpg ("facho+3_0065");     // shift FAC1 mantissa 4
/* b944 */                   ROR.zpg ("facov_0070");       // shift FAC1 rounding byte
/* b946 */        _`_b946`;  RTS.imp ();

// ------------------------------------------------------- // negate FAC1
/* b947 */  _`negfac_b947`;  LDA.zpg ("facsgn_0066");      // get FAC1 sign (b7)
/* b949 */                   EOR.imm (0xff);               // complement it
/* b94b */                   STA.zpg ("facsgn_0066");      // save FAC1 sign (b7)
                                                           // twos complement FAC1 mantissa
/* b94d */        _`_b94d`;  LDA.zpg ("facho+0_0062");     // get FAC1 mantissa 1
/* b94f */                   EOR.imm (0xff);               // complement it
/* b951 */                   STA.zpg ("facho+0_0062");     // save FAC1 mantissa 1
/* b953 */                   LDA.zpg ("facho+1_0063");     // get FAC1 mantissa 2
/* b955 */                   EOR.imm (0xff);               // complement it
/* b957 */                   STA.zpg ("facho+1_0063");     // save FAC1 mantissa 2
/* b959 */                   LDA.zpg ("facho+2_0064");     // get FAC1 mantissa 3
/* b95b */                   EOR.imm (0xff);               // complement it
/* b95d */                   STA.zpg ("facho+2_0064");     // save FAC1 mantissa 3
/* b95f */                   LDA.zpg ("facho+3_0065");     // get FAC1 mantissa 4
/* b961 */                   EOR.imm (0xff);               // complement it
/* b963 */                   STA.zpg ("facho+3_0065");     // save FAC1 mantissa 4
/* b965 */                   LDA.zpg ("facov_0070");       // get FAC1 rounding byte
/* b967 */                   EOR.imm (0xff);               // complement it
/* b969 */                   STA.zpg ("facov_0070");       // save FAC1 rounding byte
/* b96b */                   INC.zpg ("facov_0070");       // increment FAC1 rounding byte
/* b96d */                   BNE.rel ("_b97d");            // exit if no overflow
                                                           // increment FAC1 mantissa
/* b96f */        _`_b96f`;  INC.zpg ("facho+3_0065");     // increment FAC1 mantissa 4
/* b971 */                   BNE.rel ("_b97d");            // finished if no rollover
/* b973 */                   INC.zpg ("facho+2_0064");     // increment FAC1 mantissa 3
/* b975 */                   BNE.rel ("_b97d");            // finished if no rollover
/* b977 */                   INC.zpg ("facho+1_0063");     // increment FAC1 mantissa 2
/* b979 */                   BNE.rel ("_b97d");            // finished if no rollover
/* b97b */                   INC.zpg ("facho+0_0062");     // increment FAC1 mantissa 1
/* b97d */        _`_b97d`;  RTS.imp ();

// ------------------------------------------------------- // do overflow error then warm start
/* b97e */   _`overr_b97e`;  LDX.imm (0x0f);               // error $0F, overflow error
/* b980 */                   JMP.abs ("error_a437");       // do error #X then warm start

// ------------------------------------------------------- // shift FCAtemp << A+8 times
/* b983 */  _`mulshf_b983`;  LDX.imm (0x25);               // set the offset to FACtemp
/* b985 */        _`_b985`;  LDY.zpx (0x04);               // get FACX mantissa 4
/* b987 */                   STY.zpg ("facov_0070");       // save as FAC1 rounding byte
/* b989 */                   LDY.zpx (0x03);               // get FACX mantissa 3
/* b98b */                   STY.zpx (0x04);               // save FACX mantissa 4
/* b98d */                   LDY.zpx (0x02);               // get FACX mantissa 2
/* b98f */                   STY.zpx (0x03);               // save FACX mantissa 3
/* b991 */                   LDY.zpx (0x01);               // get FACX mantissa 1
/* b993 */                   STY.zpx (0x02);               // save FACX mantissa 2
/* b995 */                   LDY.zpg ("bits_0068");        // get FAC1 overflow byte
/* b997 */                   STY.zpx (0x01);               // save FACX mantissa 1
                                                           // shift FACX -A times right (> 8 shifts)
/* b999 */        _`_b999`;  ADC.imm (0x08);               // add 8 to shift count
/* b99b */                   BMI.rel ("_b985");            // go do 8 shift if still -ve
/* b99d */                   BEQ.rel ("_b985");            // go do 8 shift if zero
/* b99f */                   SBC.imm (0x08);               // else subtract 8 again
/* b9a1 */                   TAY.imp ();                   // save count to Y
/* b9a2 */                   LDA.zpg ("facov_0070");       // get FAC1 rounding byte
/* b9a4 */                   BCS.rel ("_b9ba");
/* b9a6 */        _`_b9a6`;  ASL.zpx (0x01);               // shift FACX mantissa 1
/* b9a8 */                   BCC.rel ("_b9ac");            // branch if +ve
/* b9aa */                   INC.zpx (0x01);               // this sets b7 eventually
/* b9ac */        _`_b9ac`;  ROR.zpx (0x01);               // shift FACX mantissa 1 (correct for ASL)
/* b9ae */                   ROR.zpx (0x01);               // shift FACX mantissa 1 (put carry in b7)
                                                           // shift FACX Y times right
/* b9b0 */        _`_b9b0`;  ROR.zpx (0x02);               // shift FACX mantissa 2
/* b9b2 */                   ROR.zpx (0x03);               // shift FACX mantissa 3
/* b9b4 */                   ROR.zpx (0x04);               // shift FACX mantissa 4
/* b9b6 */                   ROR.acc ();                   // shift FACX rounding byte
/* b9b7 */                   INY.imp ();                   // increment exponent diff
/* b9b8 */                   BNE.rel ("_b9a6");            // branch if range adjust not complete
/* b9ba */        _`_b9ba`;  CLC.imp ();                   // just clear it
/* b9bb */                   RTS.imp ();

// ------------------------------------------------------- // constants and series for LOG(n)
                                                           // 1
/* b9bc */    _`fone_b9bc`;  _.bytes(0x81, 0x00, 0x00, 0x00, 0x00);
/* b9c1 */  _`logcn2_b9c1`;  _.bytes(0x03);                // series counter
                                                           //  .434255942
/* b9c2 */                   _.bytes(0x7f, 0x5e, 0x56, 0xcb, 0x79);
                                                           //  .576584541
/* b9c7 */                   _.bytes(0x80, 0x13, 0x9b, 0x0b, 0x64);
                                                           //  .961800759
/* b9cc */                   _.bytes(0x80, 0x76, 0x38, 0x93, 0x16);
                                                           // 2.88539007
/* b9d1 */                   _.bytes(0x82, 0x38, 0xaa, 0x3b, 0x20);
                                                           //  .707106781 = 1/SQR(2)
/* b9d6 */                   _.bytes(0x80, 0x35, 0x04, 0xf3, 0x34);
                                                           // 1.41421356 = SQR(2)
/* b9db */                   _.bytes(0x81, 0x35, 0x04, 0xf3, 0x34);
                                                           // -.5
/* b9e0 */                   _.bytes(0x80, 0x80, 0x00, 0x00, 0x00);
                                                           //  .693147181  =  LOG(2)
/* b9e5 */                   _.bytes(0x80, 0x31, 0x72, 0x17, 0xf8);

// ------------------------------------------------------- // perform LOG()
/* b9ea */     _`log_b9ea`;  JSR.abs ("sign_bc2b");        // test sign and zero
/* b9ed */                   BEQ.rel ("_b9f1");            // if zero do illegal quantity error then warm start
/* b9ef */                   BPL.rel ("_b9f4");            // skip error if +ve
/* b9f1 */        _`_b9f1`;  JMP.abs ("fcerr_b248");       // do illegal quantity error then warm start
/* b9f4 */        _`_b9f4`;  LDA.zpg ("facexp_0061");      // get FAC1 exponent
/* b9f6 */                   SBC.imm (0x7f);               // normalise it
/* b9f8 */                   PHA.imp ();                   // save it
/* b9f9 */                   LDA.imm (0x80);               // set exponent to zero
/* b9fb */                   STA.zpg ("facexp_0061");      // save FAC1 exponent
/* b9fd */                   LDA.imm (0xd6);               // pointer to 1/root 2 low byte
/* b9ff */                   LDY.imm (0xb9);               // pointer to 1/root 2 high byte
/* ba01 */                   JSR.abs ("fadd_b867");        // add (AY) to FAC1 (1/root2)
/* ba04 */                   LDA.imm (0xdb);               // pointer to root 2 low byte
/* ba06 */                   LDY.imm (0xb9);               // pointer to root 2 high byte
/* ba08 */                   JSR.abs ("fdiv_bb0f");        // convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
/* ba0b */                   LDA.imm (0xbc);               // pointer to 1 low byte
/* ba0d */                   LDY.imm (0xb9);               // pointer to 1 high byte
/* ba0f */                   JSR.abs ("fsub_b850");        // subtract FAC1 ((root2/(x+(1/root2)))-1) from (AY)
/* ba12 */                   LDA.imm (0xc1);               // pointer to series for LOG(n) low byte
/* ba14 */                   LDY.imm (0xb9);               // pointer to series for LOG(n) high byte
/* ba16 */                   JSR.abs ("polyx_e043");       // ^2 then series evaluation
/* ba19 */                   LDA.imm (0xe0);               // pointer to -0.5 low byte
/* ba1b */                   LDY.imm (0xb9);               // pointer to -0.5 high byte
/* ba1d */                   JSR.abs ("fadd_b867");        // add (AY) to FAC1
/* ba20 */                   PLA.imp ();                   // restore FAC1 exponent
/* ba21 */                   JSR.abs ("finlog_bd7e");      // evaluate new ASCII digit
/* ba24 */                   LDA.imm (0xe5);               // pointer to LOG(2) low byte
/* ba26 */                   LDY.imm (0xb9);               // pointer to LOG(2) high byte

// ------------------------------------------------------- // do convert AY, FCA1*(AY)
/* ba28 */   _`fmult_ba28`;  JSR.abs ("conupk_ba8c");      // unpack memory (AY) into FAC2
/* ba2b */                   BNE.rel ("_ba30");            // multiply FAC1 by FAC2 ??
/* ba2d */                   JMP.abs ("_ba8b");            // exit if zero
/* ba30 */        _`_ba30`;  JSR.abs ("muldiv_bab7");      // test and adjust accumulators
/* ba33 */                   LDA.imm (0x00);               // clear A
/* ba35 */                   STA.zpg ("resho+0_0026");     // clear temp mantissa 1
/* ba37 */                   STA.zpg ("resho+1_0027");     // clear temp mantissa 2
/* ba39 */                   STA.zpg ("resho+2_0028");     // clear temp mantissa 3
/* ba3b */                   STA.zpg ("resho+3_0029");     // clear temp mantissa 4
/* ba3d */                   LDA.zpg ("facov_0070");       // get FAC1 rounding byte
/* ba3f */                   JSR.abs ("mulply_ba59");      // go do shift/add FAC2
/* ba42 */                   LDA.zpg ("facho+3_0065");     // get FAC1 mantissa 4
/* ba44 */                   JSR.abs ("mulply_ba59");      // go do shift/add FAC2
/* ba47 */                   LDA.zpg ("facho+2_0064");     // get FAC1 mantissa 3
/* ba49 */                   JSR.abs ("mulply_ba59");      // go do shift/add FAC2
/* ba4c */                   LDA.zpg ("facho+1_0063");     // get FAC1 mantissa 2
/* ba4e */                   JSR.abs ("mulply_ba59");      // go do shift/add FAC2
/* ba51 */                   LDA.zpg ("facho+0_0062");     // get FAC1 mantissa 1
/* ba53 */                   JSR.abs ("_ba5e");            // go do shift/add FAC2
/* ba56 */                   JMP.abs ("_bb8f");            // copy temp to FAC1, normalise and return
/* ba59 */  _`mulply_ba59`;  BNE.rel ("_ba5e");            // branch if byte <> zero
/* ba5b */                   JMP.abs ("mulshf_b983");      // shift FCAtemp << A+8 times
                                                           // else do shift and add
/* ba5e */        _`_ba5e`;  LSR.acc ();                   // shift byte
/* ba5f */                   ORA.imm (0x80);               // set top bit (mark for 8 times)
/* ba61 */        _`_ba61`;  TAY.imp ();                   // copy result
/* ba62 */                   BCC.rel ("_ba7d");            // skip next if bit was zero
/* ba64 */                   CLC.imp ();                   // clear carry for add
/* ba65 */                   LDA.zpg ("resho+3_0029");     // get temp mantissa 4
/* ba67 */                   ADC.zpg ("argho+3_006d");     // add FAC2 mantissa 4
/* ba69 */                   STA.zpg ("resho+3_0029");     // save temp mantissa 4
/* ba6b */                   LDA.zpg ("resho+2_0028");     // get temp mantissa 3
/* ba6d */                   ADC.zpg ("argho+2_006c");     // add FAC2 mantissa 3
/* ba6f */                   STA.zpg ("resho+2_0028");     // save temp mantissa 3
/* ba71 */                   LDA.zpg ("resho+1_0027");     // get temp mantissa 2
/* ba73 */                   ADC.zpg ("argho+1_006b");     // add FAC2 mantissa 2
/* ba75 */                   STA.zpg ("resho+1_0027");     // save temp mantissa 2
/* ba77 */                   LDA.zpg ("resho+0_0026");     // get temp mantissa 1
/* ba79 */                   ADC.zpg ("argho+0_006a");     // add FAC2 mantissa 1
/* ba7b */                   STA.zpg ("resho+0_0026");     // save temp mantissa 1
/* ba7d */        _`_ba7d`;  ROR.zpg ("resho+0_0026");     // shift temp mantissa 1
/* ba7f */                   ROR.zpg ("resho+1_0027");     // shift temp mantissa 2
/* ba81 */                   ROR.zpg ("resho+2_0028");     // shift temp mantissa 3
/* ba83 */                   ROR.zpg ("resho+3_0029");     // shift temp mantissa 4
/* ba85 */                   ROR.zpg ("facov_0070");       // shift temp rounding byte
/* ba87 */                   TYA.imp ();                   // get byte back
/* ba88 */                   LSR.acc ();                   // shift byte
/* ba89 */                   BNE.rel ("_ba61");            // loop if all bits not done
/* ba8b */        _`_ba8b`;  RTS.imp ();

// ------------------------------------------------------- // unpack memory (AY) into FAC2
/* ba8c */  _`conupk_ba8c`;  STA.zpg ("index+0_0022");     // save pointer low byte
/* ba8e */                   STY.zpg ("index+1_0023");     // save pointer high byte
/* ba90 */                   LDY.imm (0x04);               // 5 bytes to get (0-4)
/* ba92 */                   LDA.iny ("index+0_0022");     // get mantissa 4
/* ba94 */                   STA.zpg ("argho+3_006d");     // save FAC2 mantissa 4
/* ba96 */                   DEY.imp ();                   // decrement index
/* ba97 */                   LDA.iny ("index+0_0022");     // get mantissa 3
/* ba99 */                   STA.zpg ("argho+2_006c");     // save FAC2 mantissa 3
/* ba9b */                   DEY.imp ();                   // decrement index
/* ba9c */                   LDA.iny ("index+0_0022");     // get mantissa 2
/* ba9e */                   STA.zpg ("argho+1_006b");     // save FAC2 mantissa 2
/* baa0 */                   DEY.imp ();                   // decrement index
/* baa1 */                   LDA.iny ("index+0_0022");     // get mantissa 1 + sign
/* baa3 */                   STA.zpg ("argsgn_006e");      // save FAC2 sign (b7)
/* baa5 */                   EOR.zpg ("facsgn_0066");      // EOR with FAC1 sign (b7)
/* baa7 */                   STA.zpg ("arisgn_006f");      // save sign compare (FAC1 EOR FAC2)
/* baa9 */                   LDA.zpg ("argsgn_006e");      // recover FAC2 sign (b7)
/* baab */                   ORA.imm (0x80);               // set 1xxx xxx (set normal bit)
/* baad */                   STA.zpg ("argho+0_006a");     // save FAC2 mantissa 1
/* baaf */                   DEY.imp ();                   // decrement index
/* bab0 */                   LDA.iny ("index+0_0022");     // get exponent byte
/* bab2 */                   STA.zpg ("argexp_0069");      // save FAC2 exponent
/* bab4 */                   LDA.zpg ("facexp_0061");      // get FAC1 exponent
/* bab6 */                   RTS.imp ();

// ------------------------------------------------------- // test and adjust accumulators
/* bab7 */  _`muldiv_bab7`;  LDA.zpg ("argexp_0069");      // get FAC2 exponent
/* bab9 */                   BEQ.rel ("_bada");            // branch if FAC2 = $00 (handle underflow)
/* babb */                   CLC.imp ();                   // clear carry for add
/* babc */                   ADC.zpg ("facexp_0061");      // add FAC1 exponent
/* babe */                   BCC.rel ("_bac4");            // branch if sum of exponents < $0100
/* bac0 */                   BMI.rel ("_badf");            // do overflow error
/* bac2 */                   CLC.imp ();                   // clear carry for the add
/* bac3 */                   _.bytes(0x2c);                // makes next line BIT $1410
/* bac4 */        _`_bac4`;  BPL.rel ("_bada");            // if +ve go handle underflow
/* bac6 */                   ADC.imm (0x80);               // adjust exponent
/* bac8 */                   STA.zpg ("facexp_0061");      // save FAC1 exponent
/* baca */                   BNE.rel ("_bacf");            // branch if not zero
/* bacc */                   JMP.abs ("_b8fb");            // save FAC1 sign and return
/* bacf */        _`_bacf`;  LDA.zpg ("arisgn_006f");      // get sign compare (FAC1 EOR FAC2)
/* bad1 */                   STA.zpg ("facsgn_0066");      // save FAC1 sign (b7)
/* bad3 */                   RTS.imp ();
                                                           // handle overflow and underflow
/* bad4 */  _`mldvex_bad4`;  LDA.zpg ("facsgn_0066");      // get FAC1 sign (b7)
/* bad6 */                   EOR.imm (0xff);               // complement it
/* bad8 */                   BMI.rel ("_badf");            // do overflow error
                                                           // handle underflow
/* bada */        _`_bada`;  PLA.imp ();                   // pop return address low byte
/* badb */                   PLA.imp ();                   // pop return address high byte
/* badc */                   JMP.abs ("_b8f7");            // clear FAC1 exponent and sign and return
/* badf */        _`_badf`;  JMP.abs ("overr_b97e");       // do overflow error then warm start

// ------------------------------------------------------- // multiply FAC1 by 10
/* bae2 */   _`mul10_bae2`;  JSR.abs ("movaf_bc0c");       // round and copy FAC1 to FAC2
/* bae5 */                   TAX.imp ();                   // copy exponent (set the flags)
/* bae6 */                   BEQ.rel ("_baf8");            // exit if zero
/* bae8 */                   CLC.imp ();                   // clear carry for add
/* bae9 */                   ADC.imm (0x02);               // add two to exponent (*4)
/* baeb */                   BCS.rel ("_badf");            // do overflow error if > $FF
                                                           // FAC1 = (FAC1 + FAC2) * 2
/* baed */        _`_baed`;  LDX.imm (0x00);               // clear byte
/* baef */                   STX.zpg ("arisgn_006f");      // clear sign compare (FAC1 EOR FAC2)
/* baf1 */                   JSR.abs ("_b877");            // add FAC2 to FAC1 (*5)
/* baf4 */                   INC.zpg ("facexp_0061");      // increment FAC1 exponent (*10)
/* baf6 */                   BEQ.rel ("_badf");            // if exponent now zero go do overflow error
/* baf8 */        _`_baf8`;  RTS.imp ();

// ------------------------------------------------------- // 10 as a floating value
                                                           // 10
/* baf9 */    _`tenc_baf9`;  _.bytes(0x84, 0x20, 0x00, 0x00, 0x00);

// ------------------------------------------------------- // divide FAC1 by 10
/* bafe */   _`div10_bafe`;  JSR.abs ("movaf_bc0c");       // round and copy FAC1 to FAC2
/* bb01 */                   LDA.imm (0xf9);               // set 10 pointer low byte
/* bb03 */                   LDY.imm (0xba);               // set 10 pointer high byte
/* bb05 */                   LDX.imm (0x00);               // clear sign

// ------------------------------------------------------- // divide by (AY) (X=sign)
/* bb07 */   _`fdivf_bb07`;  STX.zpg ("arisgn_006f");      // save sign compare (FAC1 EOR FAC2)
/* bb09 */                   JSR.abs ("movfm_bba2");       // unpack memory (AY) into FAC1
/* bb0c */                   JMP.abs ("fdivt_bb12");       // do FAC2/FAC1
                                                           // Perform divide-by

// ------------------------------------------------------- // convert AY and do (AY)/FAC1
/* bb0f */    _`fdiv_bb0f`;  JSR.abs ("conupk_ba8c");      // unpack memory (AY) into FAC2
/* bb12 */   _`fdivt_bb12`;  BEQ.rel ("_bb8a");            // if zero go do /0 error
/* bb14 */                   JSR.abs ("round_bc1b");       // round FAC1
/* bb17 */                   LDA.imm (0x00);               // clear A
/* bb19 */                   SEC.imp ();                   // set carry for subtract
/* bb1a */                   SBC.zpg ("facexp_0061");      // subtract FAC1 exponent (2s complement)
/* bb1c */                   STA.zpg ("facexp_0061");      // save FAC1 exponent
/* bb1e */                   JSR.abs ("muldiv_bab7");      // test and adjust accumulators
/* bb21 */                   INC.zpg ("facexp_0061");      // increment FAC1 exponent
/* bb23 */                   BEQ.rel ("_badf");            // if zero do overflow error
/* bb25 */                   LDX.imm (0xfc);               // set index to FAC temp
/* bb27 */                   LDA.imm (0x01);               // set byte
/* bb29 */        _`_bb29`;  LDY.zpg ("argho+0_006a");     // get FAC2 mantissa 1
/* bb2b */                   CPY.zpg ("facho+0_0062");     // compare FAC1 mantissa 1
/* bb2d */                   BNE.rel ("_bb3f");            // branch if <>
/* bb2f */                   LDY.zpg ("argho+1_006b");     // get FAC2 mantissa 2
/* bb31 */                   CPY.zpg ("facho+1_0063");     // compare FAC1 mantissa 2
/* bb33 */                   BNE.rel ("_bb3f");            // branch if <>
/* bb35 */                   LDY.zpg ("argho+2_006c");     // get FAC2 mantissa 3
/* bb37 */                   CPY.zpg ("facho+2_0064");     // compare FAC1 mantissa 3
/* bb39 */                   BNE.rel ("_bb3f");            // branch if <>
/* bb3b */                   LDY.zpg ("argho+3_006d");     // get FAC2 mantissa 4
/* bb3d */                   CPY.zpg ("facho+3_0065");     // compare FAC1 mantissa 4
/* bb3f */        _`_bb3f`;  PHP.imp ();                   // save FAC2-FAC1 compare status
/* bb40 */                   ROL.acc ();                   // shift byte
/* bb41 */                   BCC.rel ("_bb4c");            // skip next if no carry
/* bb43 */                   INX.imp ();                   // increment index to FAC temp
/* bb44 */                   STA.zpx (0x29);
/* bb46 */                   BEQ.rel ("_bb7a");
/* bb48 */                   BPL.rel ("_bb7e");
/* bb4a */                   LDA.imm (0x01);
/* bb4c */        _`_bb4c`;  PLP.imp ();                   // restore FAC2-FAC1 compare status
/* bb4d */                   BCS.rel ("_bb5d");            // if FAC2 >= FAC1 then do subtract
                                                           // FAC2 = FAC2*2
/* bb4f */        _`_bb4f`;  ASL.zpg ("argho+3_006d");     // shift FAC2 mantissa 4
/* bb51 */                   ROL.zpg ("argho+2_006c");     // shift FAC2 mantissa 3
/* bb53 */                   ROL.zpg ("argho+1_006b");     // shift FAC2 mantissa 2
/* bb55 */                   ROL.zpg ("argho+0_006a");     // shift FAC2 mantissa 1
/* bb57 */                   BCS.rel ("_bb3f");            // loop with no compare
/* bb59 */                   BMI.rel ("_bb29");            // loop with compare
/* bb5b */                   BPL.rel ("_bb3f");            // loop with no compare, branch always
/* bb5d */        _`_bb5d`;  TAY.imp ();                   // save FAC2-FAC1 compare status
/* bb5e */                   LDA.zpg ("argho+3_006d");     // get FAC2 mantissa 4
/* bb60 */                   SBC.zpg ("facho+3_0065");     // subtract FAC1 mantissa 4
/* bb62 */                   STA.zpg ("argho+3_006d");     // save FAC2 mantissa 4
/* bb64 */                   LDA.zpg ("argho+2_006c");     // get FAC2 mantissa 3
/* bb66 */                   SBC.zpg ("facho+2_0064");     // subtract FAC1 mantissa 3
/* bb68 */                   STA.zpg ("argho+2_006c");     // save FAC2 mantissa 3
/* bb6a */                   LDA.zpg ("argho+1_006b");     // get FAC2 mantissa 2
/* bb6c */                   SBC.zpg ("facho+1_0063");     // subtract FAC1 mantissa 2
/* bb6e */                   STA.zpg ("argho+1_006b");     // save FAC2 mantissa 2
/* bb70 */                   LDA.zpg ("argho+0_006a");     // get FAC2 mantissa 1
/* bb72 */                   SBC.zpg ("facho+0_0062");     // subtract FAC1 mantissa 1
/* bb74 */                   STA.zpg ("argho+0_006a");     // save FAC2 mantissa 1
/* bb76 */                   TYA.imp ();                   // restore FAC2-FAC1 compare status
/* bb77 */                   JMP.abs ("_bb4f");
/* bb7a */        _`_bb7a`;  LDA.imm (0x40);
/* bb7c */                   BNE.rel ("_bb4c");            // branch always
                                                           // do A<<6, save as FAC1 rounding byte, normalise and return
/* bb7e */        _`_bb7e`;  ASL.acc ();
/* bb7f */                   ASL.acc ();
/* bb80 */                   ASL.acc ();
/* bb81 */                   ASL.acc ();
/* bb82 */                   ASL.acc ();
/* bb83 */                   ASL.acc ();
/* bb84 */                   STA.zpg ("facov_0070");       // save FAC1 rounding byte
/* bb86 */                   PLP.imp ();                   // dump FAC2-FAC1 compare status
/* bb87 */                   JMP.abs ("_bb8f");            // copy temp to FAC1, normalise and return
                                                           // do "Divide by zero" error
/* bb8a */        _`_bb8a`;  LDX.imm (0x14);               // error $14, divide by zero error
/* bb8c */                   JMP.abs ("error_a437");       // do error #X then warm start
/* bb8f */        _`_bb8f`;  LDA.zpg ("resho+0_0026");     // get temp mantissa 1
/* bb91 */                   STA.zpg ("facho+0_0062");     // save FAC1 mantissa 1
/* bb93 */                   LDA.zpg ("resho+1_0027");     // get temp mantissa 2
/* bb95 */                   STA.zpg ("facho+1_0063");     // save FAC1 mantissa 2
/* bb97 */                   LDA.zpg ("resho+2_0028");     // get temp mantissa 3
/* bb99 */                   STA.zpg ("facho+2_0064");     // save FAC1 mantissa 3
/* bb9b */                   LDA.zpg ("resho+3_0029");     // get temp mantissa 4
/* bb9d */                   STA.zpg ("facho+3_0065");     // save FAC1 mantissa 4
/* bb9f */                   JMP.abs ("_b8d7");            // normalise FAC1 and return

// ------------------------------------------------------- // unpack memory (AY) into FAC1
/* bba2 */   _`movfm_bba2`;  STA.zpg ("index+0_0022");     // save pointer low byte
/* bba4 */                   STY.zpg ("index+1_0023");     // save pointer high byte
/* bba6 */                   LDY.imm (0x04);               // 5 bytes to do
/* bba8 */                   LDA.iny ("index+0_0022");     // get fifth byte
/* bbaa */                   STA.zpg ("facho+3_0065");     // save FAC1 mantissa 4
/* bbac */                   DEY.imp ();                   // decrement index
/* bbad */                   LDA.iny ("index+0_0022");     // get fourth byte
/* bbaf */                   STA.zpg ("facho+2_0064");     // save FAC1 mantissa 3
/* bbb1 */                   DEY.imp ();                   // decrement index
/* bbb2 */                   LDA.iny ("index+0_0022");     // get third byte
/* bbb4 */                   STA.zpg ("facho+1_0063");     // save FAC1 mantissa 2
/* bbb6 */                   DEY.imp ();                   // decrement index
/* bbb7 */                   LDA.iny ("index+0_0022");     // get second byte
/* bbb9 */                   STA.zpg ("facsgn_0066");      // save FAC1 sign (b7)
/* bbbb */                   ORA.imm (0x80);               // set 1xxx xxxx (add normal bit)
/* bbbd */                   STA.zpg ("facho+0_0062");     // save FAC1 mantissa 1
/* bbbf */                   DEY.imp ();                   // decrement index
/* bbc0 */                   LDA.iny ("index+0_0022");     // get first byte (exponent)
/* bbc2 */                   STA.zpg ("facexp_0061");      // save FAC1 exponent
/* bbc4 */                   STY.zpg ("facov_0070");       // clear FAC1 rounding byte
/* bbc6 */                   RTS.imp ();

// ------------------------------------------------------- // pack FAC1 into $5C
/* bbc7 */   _`mov2f_bbc7`;  LDX.imm (0x5c);               // set pointer low byte
/* bbc9 */                   _.bytes(0x2c);                // makes next line BIT $57A2

// ------------------------------------------------------- // pack FAC1 into $57
/* bbca */                   LDX.imm (0x57);               // set pointer low byte
/* bbcc */                   LDY.imm (0x00);               // set pointer high byte
/* bbce */                   BEQ.rel ("_bbd4");            // pack FAC1 into (XY) and return, branch always

// ------------------------------------------------------- // pack FAC1 into variable pointer
/* bbd0 */        _`_bbd0`;  LDX.zpg ("forpnt+0_0049");    // get destination pointer low byte
/* bbd2 */                   LDY.zpg ("forpnt+1_004a");    // get destination pointer high byte

// ------------------------------------------------------- // pack FAC1 into (XY)
/* bbd4 */        _`_bbd4`;  JSR.abs ("round_bc1b");       // round FAC1
/* bbd7 */                   STX.zpg ("index+0_0022");     // save pointer low byte
/* bbd9 */                   STY.zpg ("index+1_0023");     // save pointer high byte
/* bbdb */                   LDY.imm (0x04);               // set index
/* bbdd */                   LDA.zpg ("facho+3_0065");     // get FAC1 mantissa 4
/* bbdf */                   STA.iny ("index+0_0022");     // store in destination
/* bbe1 */                   DEY.imp ();                   // decrement index
/* bbe2 */                   LDA.zpg ("facho+2_0064");     // get FAC1 mantissa 3
/* bbe4 */                   STA.iny ("index+0_0022");     // store in destination
/* bbe6 */                   DEY.imp ();                   // decrement index
/* bbe7 */                   LDA.zpg ("facho+1_0063");     // get FAC1 mantissa 2
/* bbe9 */                   STA.iny ("index+0_0022");     // store in destination
/* bbeb */                   DEY.imp ();                   // decrement index
/* bbec */                   LDA.zpg ("facsgn_0066");      // get FAC1 sign (b7)
/* bbee */                   ORA.imm (0x7f);               // set bits x111 1111
/* bbf0 */                   AND.zpg ("facho+0_0062");     // AND in FAC1 mantissa 1
/* bbf2 */                   STA.iny ("index+0_0022");     // store in destination
/* bbf4 */                   DEY.imp ();                   // decrement index
/* bbf5 */                   LDA.zpg ("facexp_0061");      // get FAC1 exponent
/* bbf7 */                   STA.iny ("index+0_0022");     // store in destination
/* bbf9 */                   STY.zpg ("facov_0070");       // clear FAC1 rounding byte
/* bbfb */                   RTS.imp ();

// ------------------------------------------------------- // copy FAC2 to FAC1
/* bbfc */   _`movfa_bbfc`;  LDA.zpg ("argsgn_006e");      // get FAC2 sign (b7)
                                                           // save FAC1 sign and copy ABS(FAC2) to FAC1
/* bbfe */        _`_bbfe`;  STA.zpg ("facsgn_0066");      // save FAC1 sign (b7)
/* bc00 */                   LDX.imm (0x05);               // 5 bytes to copy
/* bc02 */        _`_bc02`;  LDA.zpx (0x68);               // get byte from FAC2,X
/* bc04 */                   STA.zpx (0x60);               // save byte at FAC1,X
/* bc06 */                   DEX.imp ();                   // decrement count
/* bc07 */                   BNE.rel ("_bc02");            // loop if not all done
/* bc09 */                   STX.zpg ("facov_0070");       // clear FAC1 rounding byte
/* bc0b */                   RTS.imp ();

// ------------------------------------------------------- // round and copy FAC1 to FAC2
/* bc0c */   _`movaf_bc0c`;  JSR.abs ("round_bc1b");       // round FAC1
                                                           // copy FAC1 to FAC2
/* bc0f */   _`movef_bc0f`;  LDX.imm (0x06);               // 6 bytes to copy
/* bc11 */        _`_bc11`;  LDA.zpx (0x60);               // get byte from FAC1,X
/* bc13 */                   STA.zpx (0x68);               // save byte at FAC2,X
/* bc15 */                   DEX.imp ();                   // decrement count
/* bc16 */                   BNE.rel ("_bc11");            // loop if not all done
/* bc18 */                   STX.zpg ("facov_0070");       // clear FAC1 rounding byte
/* bc1a */        _`_bc1a`;  RTS.imp ();

// ------------------------------------------------------- // round FAC1
/* bc1b */   _`round_bc1b`;  LDA.zpg ("facexp_0061");      // get FAC1 exponent
/* bc1d */                   BEQ.rel ("_bc1a");            // exit if zero
/* bc1f */                   ASL.zpg ("facov_0070");       // shift FAC1 rounding byte
/* bc21 */                   BCC.rel ("_bc1a");            // exit if no overflow
                                                           // round FAC1 (no check)
/* bc23 */        _`_bc23`;  JSR.abs ("_b96f");            // increment FAC1 mantissa
/* bc26 */                   BNE.rel ("_bc1a");            // branch if no overflow
/* bc28 */                   JMP.abs ("_b938");            // nornalise FAC1 for C=1 and return

// ------------------------------------------------------- // get FAC1 sign
                                                           // return A = $FF, Cb = 1/-ve A = $01, Cb = 0/+ve, A = $00, Cb = ?/0
/* bc2b */    _`sign_bc2b`;  LDA.zpg ("facexp_0061");      // get FAC1 exponent
/* bc2d */                   BEQ.rel ("_bc38");            // exit if zero (allready correct SGN(0)=0)

// ------------------------------------------------------- // return A = $FF, Cb = 1/-ve A = $01, Cb = 0/+ve
                                                           // no = 0 check
/* bc2f */        _`_bc2f`;  LDA.zpg ("facsgn_0066");      // else get FAC1 sign (b7)

// ------------------------------------------------------- // return A = $FF, Cb = 1/-ve A = $01, Cb = 0/+ve
                                                           // no = 0 check, sign in A
/* bc31 */        _`_bc31`;  ROL.acc ();                   // move sign bit to carry
/* bc32 */                   LDA.imm (0xff);               // set byte for -ve result
/* bc34 */                   BCS.rel ("_bc38");            // return if sign was set (-ve)
/* bc36 */                   LDA.imm (0x01);               // else set byte for +ve result
/* bc38 */        _`_bc38`;  RTS.imp ();

// ------------------------------------------------------- // perform SGN()
/* bc39 */     _`sgn_bc39`;  JSR.abs ("sign_bc2b");        // get FAC1 sign, return A = $FF -ve, A = $01 +ve

// ------------------------------------------------------- // save A as integer byte
/* bc3c */        _`_bc3c`;  STA.zpg ("facho+0_0062");     // save FAC1 mantissa 1
/* bc3e */                   LDA.imm (0x00);               // clear A
/* bc40 */                   STA.zpg ("facho+1_0063");     // clear FAC1 mantissa 2
/* bc42 */                   LDX.imm (0x88);               // set exponent
                                                           // set exponent = X, clear FAC1 3 and 4 and normalise
/* bc44 */        _`_bc44`;  LDA.zpg ("facho+0_0062");     // get FAC1 mantissa 1
/* bc46 */                   EOR.imm (0xff);               // complement it
/* bc48 */                   ROL.acc ();                   // sign bit into carry
                                                           // set exponent = X, clear mantissa 4 and 3 and normalise FAC1
/* bc49 */        _`_bc49`;  LDA.imm (0x00);               // clear A
/* bc4b */                   STA.zpg ("facho+3_0065");     // clear FAC1 mantissa 4
/* bc4d */                   STA.zpg ("facho+2_0064");     // clear FAC1 mantissa 3
                                                           // set exponent = X and normalise FAC1
/* bc4f */        _`_bc4f`;  STX.zpg ("facexp_0061");      // set FAC1 exponent
/* bc51 */                   STA.zpg ("facov_0070");       // clear FAC1 rounding byte
/* bc53 */                   STA.zpg ("facsgn_0066");      // clear FAC1 sign (b7)
/* bc55 */                   JMP.abs ("_b8d2");            // do ABS and normalise FAC1

// ------------------------------------------------------- // perform ABS()
/* bc58 */     _`abs_bc58`;  LSR.zpg ("facsgn_0066");      // clear FAC1 sign, put zero in b7
/* bc5a */                   RTS.imp ();

// ------------------------------------------------------- // compare FAC1 with (AY)
                                                           // returns A=$00 if FAC1 = (AY)
                                                           // returns A=$01 if FAC1 > (AY)
                                                           // returns A=$FF if FAC1 < (AY)
/* bc5b */   _`fcomp_bc5b`;  STA.zpg ("index+2_0024");     // save pointer low byte
/* bc5d */        _`_bc5d`;  STY.zpg ("index+3_0025");     // save pointer high byte
/* bc5f */                   LDY.imm (0x00);               // clear index
/* bc61 */                   LDA.iny ("index+2_0024");     // get exponent
/* bc63 */                   INY.imp ();                   // increment index
/* bc64 */                   TAX.imp ();                   // copy (AY) exponent to X
/* bc65 */                   BEQ.rel ("sign_bc2b");        // branch if (AY) exponent=0 and get FAC1 sign
                                                           // A = $FF, Cb = 1/-ve A = $01, Cb = 0/+ve
/* bc67 */                   LDA.iny ("index+2_0024");     // get (AY) mantissa 1, with sign
/* bc69 */                   EOR.zpg ("facsgn_0066");      // EOR FAC1 sign (b7)
/* bc6b */                   BMI.rel ("_bc2f");            // if signs <> do return A = $FF, Cb = 1/-ve
                                                           // A = $01, Cb = 0/+ve and return
/* bc6d */                   CPX.zpg ("facexp_0061");      // compare (AY) exponent with FAC1 exponent
/* bc6f */                   BNE.rel ("_bc92");            // branch if different
/* bc71 */                   LDA.iny ("index+2_0024");     // get (AY) mantissa 1, with sign
/* bc73 */                   ORA.imm (0x80);               // normalise top bit
/* bc75 */                   CMP.zpg ("facho+0_0062");     // compare with FAC1 mantissa 1
/* bc77 */                   BNE.rel ("_bc92");            // branch if different
/* bc79 */                   INY.imp ();                   // increment index
/* bc7a */                   LDA.iny ("index+2_0024");     // get mantissa 2
/* bc7c */                   CMP.zpg ("facho+1_0063");     // compare with FAC1 mantissa 2
/* bc7e */                   BNE.rel ("_bc92");            // branch if different
/* bc80 */                   INY.imp ();                   // increment index
/* bc81 */                   LDA.iny ("index+2_0024");     // get mantissa 3
/* bc83 */                   CMP.zpg ("facho+2_0064");     // compare with FAC1 mantissa 3
/* bc85 */                   BNE.rel ("_bc92");            // branch if different
/* bc87 */                   INY.imp ();                   // increment index
/* bc88 */                   LDA.imm (0x7f);               // set for 1/2 value rounding byte
/* bc8a */                   CMP.zpg ("facov_0070");       // compare with FAC1 rounding byte (set carry)
/* bc8c */                   LDA.iny ("index+2_0024");     // get mantissa 4
/* bc8e */                   SBC.zpg ("facho+3_0065");     // subtract FAC1 mantissa 4
/* bc90 */                   BEQ.rel ("_bcba");            // exit if mantissa 4 equal
                                                           // gets here if number <> FAC1
/* bc92 */        _`_bc92`;  LDA.zpg ("facsgn_0066");      // get FAC1 sign (b7)
/* bc94 */                   BCC.rel ("_bc98");            // branch if FAC1 > (AY)
/* bc96 */                   EOR.imm (0xff);               // else toggle FAC1 sign
/* bc98 */        _`_bc98`;  JMP.abs ("_bc31");            // return A = $FF, Cb = 1/-ve A = $01, Cb = 0/+ve

// ------------------------------------------------------- // convert FAC1 floating to fixed
/* bc9b */    _`qint_bc9b`;  LDA.zpg ("facexp_0061");      // get FAC1 exponent
/* bc9d */                   BEQ.rel ("_bce9");            // if zero go clear FAC1 and return
/* bc9f */                   SEC.imp ();                   // set carry for subtract
/* bca0 */                   SBC.imm (0xa0);               // subtract maximum integer range exponent
/* bca2 */                   BIT.zpg ("facsgn_0066");      // test FAC1 sign (b7)
/* bca4 */                   BPL.rel ("_bcaf");            // branch if FAC1 +ve
                                                           // FAC1 was -ve
/* bca6 */                   TAX.imp ();                   // copy subtracted exponent
/* bca7 */                   LDA.imm (0xff);               // overflow for -ve number
/* bca9 */                   STA.zpg ("bits_0068");        // set FAC1 overflow byte
/* bcab */                   JSR.abs ("_b94d");            // twos complement FAC1 mantissa
/* bcae */                   TXA.imp ();                   // restore subtracted exponent
/* bcaf */        _`_bcaf`;  LDX.imm (0x61);               // set index to FAC1
/* bcb1 */                   CMP.imm (0xf9);               // compare exponent result
/* bcb3 */                   BPL.rel ("_bcbb");            // if < 8 shifts shift FAC1 A times right and return
/* bcb5 */                   JSR.abs ("_b999");            // shift FAC1 A times right (> 8 shifts)
/* bcb8 */                   STY.zpg ("bits_0068");        // clear FAC1 overflow byte
/* bcba */        _`_bcba`;  RTS.imp ();

// ------------------------------------------------------- // shift FAC1 A times right
/* bcbb */        _`_bcbb`;  TAY.imp ();                   // copy shift count
/* bcbc */                   LDA.zpg ("facsgn_0066");      // get FAC1 sign (b7)
/* bcbe */                   AND.imm (0x80);               // mask sign bit only (x000 0000)
/* bcc0 */                   LSR.zpg ("facho+0_0062");     // shift FAC1 mantissa 1
/* bcc2 */                   ORA.zpg ("facho+0_0062");     // OR sign in b7 FAC1 mantissa 1
/* bcc4 */                   STA.zpg ("facho+0_0062");     // save FAC1 mantissa 1
/* bcc6 */                   JSR.abs ("_b9b0");            // shift FAC1 Y times right
/* bcc9 */                   STY.zpg ("bits_0068");        // clear FAC1 overflow byte
/* bccb */                   RTS.imp ();

// ------------------------------------------------------- // perform INT()
/* bccc */     _`int_bccc`;  LDA.zpg ("facexp_0061");      // get FAC1 exponent
/* bcce */                   CMP.imm (0xa0);               // compare with max int
/* bcd0 */                   BCS.rel ("_bcf2");            // exit if >= (allready int, too big for fractional part!)
/* bcd2 */                   JSR.abs ("qint_bc9b");        // convert FAC1 floating to fixed
/* bcd5 */                   STY.zpg ("facov_0070");       // save FAC1 rounding byte
/* bcd7 */                   LDA.zpg ("facsgn_0066");      // get FAC1 sign (b7)
/* bcd9 */                   STY.zpg ("facsgn_0066");      // save FAC1 sign (b7)
/* bcdb */                   EOR.imm (0x80);               // toggle FAC1 sign
/* bcdd */                   ROL.acc ();                   // shift into carry
/* bcde */                   LDA.imm (0xa0);               // set new exponent
/* bce0 */                   STA.zpg ("facexp_0061");      // save FAC1 exponent
/* bce2 */                   LDA.zpg ("facho+3_0065");     // get FAC1 mantissa 4
/* bce4 */                   STA.zpg ("charac_0007");      // save FAC1 mantissa 4 for power function
/* bce6 */                   JMP.abs ("_b8d2");            // do ABS and normalise FAC1

// ------------------------------------------------------- // clear FAC1 and return
/* bce9 */        _`_bce9`;  STA.zpg ("facho+0_0062");     // clear FAC1 mantissa 1
/* bceb */                   STA.zpg ("facho+1_0063");     // clear FAC1 mantissa 2
/* bced */                   STA.zpg ("facho+2_0064");     // clear FAC1 mantissa 3
/* bcef */                   STA.zpg ("facho+3_0065");     // clear FAC1 mantissa 4
/* bcf1 */                   TAY.imp ();                   // clear Y
/* bcf2 */        _`_bcf2`;  RTS.imp ();

// ------------------------------------------------------- // get FAC1 from string
/* bcf3 */     _`fin_bcf3`;  LDY.imm (0x00);               // clear Y
/* bcf5 */                   LDX.imm (0x0a);               // set index
/* bcf7 */        _`_bcf7`;  STY.zpx (0x5d);               // clear byte
/* bcf9 */                   DEX.imp ();                   // decrement index
/* bcfa */                   BPL.rel ("_bcf7");            // loop until numexp to negnum (and FAC1) = $00
/* bcfc */                   BCC.rel ("_bd0d");            // branch if first character is numeric
/* bcfe */                   CMP.imm (0x2d);               // else compare with "-"
/* bd00 */                   BNE.rel ("_bd06");            // branch if not "-"
/* bd02 */                   STX.zpg ("sgnflg_0067");      // set flag for -ve n (negnum = $FF)
/* bd04 */                   BEQ.rel ("_bd0a");            // branch always
/* bd06 */        _`_bd06`;  CMP.imm (0x2b);               // else compare with "+"
/* bd08 */                   BNE.rel ("_bd0f");            // branch if not "+"
/* bd0a */        _`_bd0a`;  JSR.abs ("chrget+0_0073");    // increment and scan memory
/* bd0d */        _`_bd0d`;  BCC.rel ("_bd6a");            // branch if numeric character
/* bd0f */        _`_bd0f`;  CMP.imm (0x2e);               // else compare with "."
/* bd11 */                   BEQ.rel ("_bd41");            // branch if "."
/* bd13 */                   CMP.imm (0x45);               // else compare with "E"
/* bd15 */                   BNE.rel ("_bd47");            // branch if not "E"
                                                           // was "E" so evaluate exponential part
/* bd17 */                   JSR.abs ("chrget+0_0073");    // increment and scan memory
/* bd1a */                   BCC.rel ("_bd33");            // branch if numeric character
/* bd1c */                   CMP.imm (0xab);               // else compare with token for -
/* bd1e */                   BEQ.rel ("_bd2e");            // branch if token for -
/* bd20 */                   CMP.imm (0x2d);               // else compare with "-"
/* bd22 */                   BEQ.rel ("_bd2e");            // branch if "-"
/* bd24 */                   CMP.imm (0xaa);               // else compare with token for +
/* bd26 */                   BEQ.rel ("_bd30");            // branch if token for +
/* bd28 */                   CMP.imm (0x2b);               // else compare with "+"
/* bd2a */                   BEQ.rel ("_bd30");            // branch if "+"
/* bd2c */                   BNE.rel ("_bd35");            // branch always
/* bd2e */        _`_bd2e`;  ROR.zpg ("tempf2+4_0060");    // set exponent -ve flag (C, which=1, into b7)
/* bd30 */        _`_bd30`;  JSR.abs ("chrget+0_0073");    // increment and scan memory
/* bd33 */        _`_bd33`;  BCC.rel ("_bd91");            // branch if numeric character
/* bd35 */        _`_bd35`;  BIT.zpg ("tempf2+4_0060");    // test exponent -ve flag
/* bd37 */                   BPL.rel ("_bd47");            // if +ve go evaluate exponent
                                                           // else do exponent = -exponent
/* bd39 */                   LDA.imm (0x00);               // clear result
/* bd3b */                   SEC.imp ();                   // set carry for subtract
/* bd3c */                   SBC.zpg ("tempf2+2_005e");    // subtract exponent byte
/* bd3e */                   JMP.abs ("_bd49");            // go evaluate exponent
/* bd41 */        _`_bd41`;  ROR.zpg ("tempf2+3_005f");    // set decimal point flag
/* bd43 */                   BIT.zpg ("tempf2+3_005f");    // test decimal point flag
/* bd45 */                   BVC.rel ("_bd0a");            // branch if only one decimal point so far
                                                           // evaluate exponent
/* bd47 */        _`_bd47`;  LDA.zpg ("tempf2+2_005e");    // get exponent count byte
/* bd49 */        _`_bd49`;  SEC.imp ();                   // set carry for subtract
/* bd4a */                   SBC.zpg ("tempf2+1_005d");    // subtract numerator exponent
/* bd4c */                   STA.zpg ("tempf2+2_005e");    // save exponent count byte
/* bd4e */                   BEQ.rel ("_bd62");            // branch if no adjustment
/* bd50 */                   BPL.rel ("_bd5b");            // else if +ve go do FAC1*10^expcnt
                                                           // else go do FAC1/10^(0-expcnt)
/* bd52 */        _`_bd52`;  JSR.abs ("div10_bafe");       // divide FAC1 by 10
/* bd55 */                   INC.zpg ("tempf2+2_005e");    // increment exponent count byte
/* bd57 */                   BNE.rel ("_bd52");            // loop until all done
/* bd59 */                   BEQ.rel ("_bd62");            // branch always
/* bd5b */        _`_bd5b`;  JSR.abs ("mul10_bae2");       // multiply FAC1 by 10
/* bd5e */                   DEC.zpg ("tempf2+2_005e");    // decrement exponent count byte
/* bd60 */                   BNE.rel ("_bd5b");            // loop until all done
/* bd62 */        _`_bd62`;  LDA.zpg ("sgnflg_0067");      // get -ve flag
/* bd64 */                   BMI.rel ("_bd67");            // if -ve do - FAC1 and return
/* bd66 */                   RTS.imp ();

// ------------------------------------------------------- // do - FAC1 and return
/* bd67 */        _`_bd67`;  JMP.abs ("negop_bfb4");       // do - FAC1
                                                           // do unsigned FAC1*10+number
/* bd6a */        _`_bd6a`;  PHA.imp ();                   // save character
/* bd6b */                   BIT.zpg ("tempf2+3_005f");    // test decimal point flag
/* bd6d */                   BPL.rel ("_bd71");            // skip exponent increment if not set
/* bd6f */                   INC.zpg ("tempf2+1_005d");    // else increment number exponent
/* bd71 */        _`_bd71`;  JSR.abs ("mul10_bae2");       // multiply FAC1 by 10
/* bd74 */                   PLA.imp ();                   // restore character
/* bd75 */                   SEC.imp ();                   // set carry for subtract
/* bd76 */                   SBC.imm (0x30);               // convert to binary
/* bd78 */                   JSR.abs ("finlog_bd7e");      // evaluate new ASCII digit
/* bd7b */                   JMP.abs ("_bd0a");            // go do next character
                                                           // evaluate new ASCII digit
                                                           // multiply FAC1 by 10 then (ABS) add in new digit
/* bd7e */  _`finlog_bd7e`;  PHA.imp ();                   // save digit
/* bd7f */                   JSR.abs ("movaf_bc0c");       // round and copy FAC1 to FAC2
/* bd82 */                   PLA.imp ();                   // restore digit
/* bd83 */                   JSR.abs ("_bc3c");            // save A as integer byte
/* bd86 */                   LDA.zpg ("argsgn_006e");      // get FAC2 sign (b7)
/* bd88 */                   EOR.zpg ("facsgn_0066");      // toggle with FAC1 sign (b7)
/* bd8a */                   STA.zpg ("arisgn_006f");      // save sign compare (FAC1 EOR FAC2)
/* bd8c */                   LDX.zpg ("facexp_0061");      // get FAC1 exponent
/* bd8e */                   JMP.abs ("faddt_b86a");       // add FAC2 to FAC1 and return
                                                           // evaluate next character of exponential part of number
/* bd91 */        _`_bd91`;  LDA.zpg ("tempf2+2_005e");    // get exponent count byte
/* bd93 */                   CMP.imm (0x0a);               // compare with 10 decimal
/* bd95 */                   BCC.rel ("_bda0");            // branch if less
/* bd97 */                   LDA.imm (0x64);               // make all -ve exponents = -100 decimal (causes underflow)
/* bd99 */                   BIT.zpg ("tempf2+4_0060");    // test exponent -ve flag
/* bd9b */                   BMI.rel ("_bdae");            // branch if -ve
/* bd9d */                   JMP.abs ("overr_b97e");       // else do overflow error then warm start
/* bda0 */        _`_bda0`;  ASL.acc ();                   // *2
/* bda1 */                   ASL.acc ();                   // *4
/* bda2 */                   CLC.imp ();                   // clear carry for add
/* bda3 */                   ADC.zpg ("tempf2+2_005e");    // *5
/* bda5 */                   ASL.acc ();                   // *10
/* bda6 */                   CLC.imp ();                   // clear carry for add
/* bda7 */                   LDY.imm (0x00);               // set index
/* bda9 */                   ADC.iny ("txtptr+0_007a");    // add character (will be $30 too much!)
/* bdab */                   SEC.imp ();                   // set carry for subtract
/* bdac */                   SBC.imm (0x30);               // convert character to binary
/* bdae */        _`_bdae`;  STA.zpg ("tempf2+2_005e");    // save exponent count byte
/* bdb0 */                   JMP.abs ("_bd30");            // go get next character

// ------------------------------------------------------- // limits for scientific mode
                                                           // 99999999.90625, maximum value with at least one decimal
/* bdb3 */   _`n0999_bdb3`;  _.bytes(0x9b, 0x3e, 0xbc, 0x1f, 0xfd);
                                                           // 999999999.25, maximum value before scientific notation
/* bdb8 */                   _.bytes(0x9e, 0x6e, 0x6b, 0x27, 0xfd);
                                                           // 1000000000
/* bdbd */                   _.bytes(0x9e, 0x6e, 0x6b, 0x28, 0x00);

// ------------------------------------------------------- // do " IN " line number message
/* bdc2 */   _`inprt_bdc2`;  LDA.imm (0x71);               // set " IN " pointer low byte
/* bdc4 */                   LDY.imm (0xa3);               // set " IN " pointer high byte
/* bdc6 */                   JSR.abs ("_bdda");            // print null terminated string
/* bdc9 */                   LDA.zpg ("curlin+1_003a");    // get the current line number high byte
/* bdcb */                   LDX.zpg ("curlin+0_0039");    // get the current line number low byte

// ------------------------------------------------------- // print XA as unsigned integer
/* bdcd */  _`linprt_bdcd`;  STA.zpg ("facho+0_0062");     // save high byte as FAC1 mantissa1
/* bdcf */                   STX.zpg ("facho+1_0063");     // save low byte as FAC1 mantissa2
/* bdd1 */                   LDX.imm (0x90);               // set exponent to 16d bits
/* bdd3 */                   SEC.imp ();                   // set integer is +ve flag
/* bdd4 */                   JSR.abs ("_bc49");            // set exponent = X, clear mantissa 4 and 3 and normalise
                                                           // FAC1
/* bdd7 */                   JSR.abs ("_bddf");            // convert FAC1 to string
/* bdda */        _`_bdda`;  JMP.abs ("strout_ab1e");      // print null terminated string

// ------------------------------------------------------- // convert FAC1 to ASCII string result in (AY)
/* bddd */    _`fout_bddd`;  LDY.imm (0x01);               // set index = 1
/* bddf */        _`_bddf`;  LDA.imm (0x20);               // character = " " (assume +ve)
/* bde1 */                   BIT.zpg ("facsgn_0066");      // test FAC1 sign (b7)
/* bde3 */                   BPL.rel ("_bde7");            // branch if +ve
/* bde5 */                   LDA.imm (0x2d);               // else character = "-"
/* bde7 */        _`_bde7`;  STA.aby ("baszpt_00ff");      // save leading character (" " or "-")
/* bdea */                   STA.zpg ("facsgn_0066");      // save FAC1 sign (b7)
/* bdec */                   STY.zpg ("fbufpt+0_0071");    // save index
/* bdee */                   INY.imp ();                   // increment index
/* bdef */                   LDA.imm (0x30);               // set character = "0"
/* bdf1 */                   LDX.zpg ("facexp_0061");      // get FAC1 exponent
/* bdf3 */                   BNE.rel ("_bdf8");            // branch if FAC1<>0
                                                           // exponent was $00 so FAC1 is 0
/* bdf5 */                   JMP.abs ("_bf04");            // save last character, [EOT] and exit
                                                           // FAC1 is some non zero value
/* bdf8 */        _`_bdf8`;  LDA.imm (0x00);               // clear (number exponent count)
/* bdfa */                   CPX.imm (0x80);               // compare FAC1 exponent with $80 (<1.00000)
/* bdfc */                   BEQ.rel ("_be00");            // branch if 0.5 <= FAC1 < 1.0
/* bdfe */                   BCS.rel ("_be09");            // branch if FAC1=>1
/* be00 */        _`_be00`;  LDA.imm (0xbd);               // set 1000000000 pointer low byte
/* be02 */                   LDY.imm (0xbd);               // set 1000000000 pointer high byte
/* be04 */                   JSR.abs ("fmult_ba28");       // do convert AY, FCA1*(AY)
/* be07 */                   LDA.imm (0xf7);               // set number exponent count
/* be09 */        _`_be09`;  STA.zpg ("tempf2+1_005d");    // save number exponent count
/* be0b */        _`_be0b`;  LDA.imm (0xb8);               // set 999999999.25 pointer low byte (max before sci note)
/* be0d */                   LDY.imm (0xbd);               // set 999999999.25 pointer high byte
/* be0f */                   JSR.abs ("fcomp_bc5b");       // compare FAC1 with (AY)
/* be12 */                   BEQ.rel ("_be32");            // exit if FAC1 = (AY)
/* be14 */                   BPL.rel ("_be28");            // go do /10 if FAC1 > (AY)
                                                           // FAC1 < (AY)
/* be16 */        _`_be16`;  LDA.imm (0xb3);               // set 99999999.90625 pointer low byte
/* be18 */                   LDY.imm (0xbd);               // set 99999999.90625 pointer high byte
/* be1a */                   JSR.abs ("fcomp_bc5b");       // compare FAC1 with (AY)
/* be1d */                   BEQ.rel ("_be21");            // branch if FAC1 = (AY) (allow decimal places)
/* be1f */                   BPL.rel ("_be2f");            // branch if FAC1 > (AY) (no decimal places)
                                                           // FAC1 <= (AY)
/* be21 */        _`_be21`;  JSR.abs ("mul10_bae2");       // multiply FAC1 by 10
/* be24 */                   DEC.zpg ("tempf2+1_005d");    // decrement number exponent count
/* be26 */                   BNE.rel ("_be16");            // go test again, branch always
/* be28 */        _`_be28`;  JSR.abs ("div10_bafe");       // divide FAC1 by 10
/* be2b */                   INC.zpg ("tempf2+1_005d");    // increment number exponent count
/* be2d */                   BNE.rel ("_be0b");            // go test again, branch always
                                                           // now we have just the digits to do
/* be2f */        _`_be2f`;  JSR.abs ("faddh_b849");       // add 0.5 to FAC1 (round FAC1)
/* be32 */        _`_be32`;  JSR.abs ("qint_bc9b");        // convert FAC1 floating to fixed
/* be35 */                   LDX.imm (0x01);               // set default digits before dp = 1
/* be37 */                   LDA.zpg ("tempf2+1_005d");    // get number exponent count
/* be39 */                   CLC.imp ();                   // clear carry for add
/* be3a */                   ADC.imm (0x0a);               // up to 9 digits before point
/* be3c */                   BMI.rel ("_be47");            // if -ve then 1 digit before dp
/* be3e */                   CMP.imm (0x0b);               // A>=$0B if n>=1E9
/* be40 */                   BCS.rel ("_be48");            // branch if >= $0B
                                                           // carry is clear
/* be42 */                   ADC.imm (0xff);               // take 1 from digit count
/* be44 */                   TAX.imp ();                   // copy to X
/* be45 */                   LDA.imm (0x02);               // set exponent adjust
/* be47 */        _`_be47`;  SEC.imp ();                   // set carry for subtract
/* be48 */        _`_be48`;  SBC.imm (0x02);               // -2
/* be4a */                   STA.zpg ("tempf2+2_005e");    // save exponent adjust
/* be4c */                   STX.zpg ("tempf2+1_005d");    // save digits before dp count
/* be4e */                   TXA.imp ();                   // copy to A
/* be4f */                   BEQ.rel ("_be53");            // branch if no digits before dp
/* be51 */                   BPL.rel ("_be66");            // branch if digits before dp
/* be53 */        _`_be53`;  LDY.zpg ("fbufpt+0_0071");    // get output string index
/* be55 */                   LDA.imm (0x2e);               // character "."
/* be57 */                   INY.imp ();                   // increment index
/* be58 */                   STA.aby ("baszpt_00ff");      // save to output string
/* be5b */                   TXA.imp ();
/* be5c */                   BEQ.rel ("_be64");
/* be5e */                   LDA.imm (0x30);               // character "0"
/* be60 */                   INY.imp ();                   // increment index
/* be61 */                   STA.aby ("baszpt_00ff");      // save to output string
/* be64 */        _`_be64`;  STY.zpg ("fbufpt+0_0071");    // save output string index
/* be66 */        _`_be66`;  LDY.imm (0x00);               // clear index (point to 100,000)
/* be68 */  _`foutim_be68`;  LDX.imm (0x80);
/* be6a */        _`_be6a`;  LDA.zpg ("facho+3_0065");     // get FAC1 mantissa 4
/* be6c */                   CLC.imp ();                   // clear carry for add
/* be6d */                   ADC.aby (0xbf19);             // add byte 4, least significant
/* be70 */                   STA.zpg ("facho+3_0065");     // save FAC1 mantissa4
/* be72 */                   LDA.zpg ("facho+2_0064");     // get FAC1 mantissa 3
/* be74 */                   ADC.aby (0xbf18);             // add byte 3
/* be77 */                   STA.zpg ("facho+2_0064");     // save FAC1 mantissa3
/* be79 */                   LDA.zpg ("facho+1_0063");     // get FAC1 mantissa 2
/* be7b */                   ADC.aby (0xbf17);             // add byte 2
/* be7e */                   STA.zpg ("facho+1_0063");     // save FAC1 mantissa2
/* be80 */                   LDA.zpg ("facho+0_0062");     // get FAC1 mantissa 1
/* be82 */                   ADC.aby ("_bf16");            // add byte 1, most significant
/* be85 */                   STA.zpg ("facho+0_0062");     // save FAC1 mantissa1
/* be87 */                   INX.imp ();                   // increment the digit, set the sign on the test sense bit
/* be88 */                   BCS.rel ("_be8e");            // if the carry is set go test if the result was positive
                                                           // else the result needs to be negative
/* be8a */                   BPL.rel ("_be6a");            // not -ve so try again
/* be8c */                   BMI.rel ("_be90");            // else done so return the digit
/* be8e */        _`_be8e`;  BMI.rel ("_be6a");            // not +ve so try again
                                                           // else done so return the digit
/* be90 */        _`_be90`;  TXA.imp ();                   // copy the digit
/* be91 */                   BCC.rel ("_be97");            // if Cb=0 just use it
/* be93 */                   EOR.imm (0xff);               // else make the 2's complement ..
/* be95 */                   ADC.imm (0x0a);               // .. and subtract it from 10
/* be97 */        _`_be97`;  ADC.imm (0x2f);               // add "0"-1 to result
/* be99 */                   INY.imp ();                   // increment ..
/* be9a */                   INY.imp ();                   // .. index to..
/* be9b */                   INY.imp ();                   // .. next less ..
/* be9c */                   INY.imp ();                   // .. power of ten
/* be9d */                   STY.zpg ("varpnt+0_0047");    // save current variable pointer low byte
/* be9f */                   LDY.zpg ("fbufpt+0_0071");    // get output string index
/* bea1 */                   INY.imp ();                   // increment output string index
/* bea2 */                   TAX.imp ();                   // copy character to X
/* bea3 */                   AND.imm (0x7f);               // mask out top bit
/* bea5 */                   STA.aby ("baszpt_00ff");      // save to output string
/* bea8 */                   DEC.zpg ("tempf2+1_005d");    // decrement # of characters before the dp
/* beaa */                   BNE.rel ("_beb2");            // branch if still characters to do
                                                           // else output the point
/* beac */                   LDA.imm (0x2e);               // character "."
/* beae */                   INY.imp ();                   // increment output string index
/* beaf */                   STA.aby ("baszpt_00ff");      // save to output string
/* beb2 */        _`_beb2`;  STY.zpg ("fbufpt+0_0071");    // save output string index
/* beb4 */                   LDY.zpg ("varpnt+0_0047");    // get current variable pointer low byte
/* beb6 */                   TXA.imp ();                   // get character back
/* beb7 */                   EOR.imm (0xff);               // toggle the test sense bit
/* beb9 */                   AND.imm (0x80);               // clear the digit
/* bebb */                   TAX.imp ();                   // copy it to the new digit
/* bebc */                   CPY.imm (0x24);
                                                           // compare the table index with the max for decimal numbers
/* bebe */                   BEQ.rel ("_bec4");            // if at the max exit the digit loop
/* bec0 */                   CPY.imm (0x3c);
                                                           // compare the table index with the max for time
/* bec2 */                   BNE.rel ("_be6a");            // loop if not at the max
                                                           // now remove trailing zeroes
/* bec4 */        _`_bec4`;  LDY.zpg ("fbufpt+0_0071");    // restore the output string index
/* bec6 */        _`_bec6`;  LDA.aby ("baszpt_00ff");      // get character from output string
/* bec9 */                   DEY.imp ();                   // decrement output string index
/* beca */                   CMP.imm (0x30);               // compare with "0"
/* becc */                   BEQ.rel ("_bec6");            // loop until non "0" character found
/* bece */                   CMP.imm (0x2e);               // compare with "."
/* bed0 */                   BEQ.rel ("_bed3");            // branch if was dp
                                                           // restore last character
/* bed2 */                   INY.imp ();                   // increment output string index
/* bed3 */        _`_bed3`;  LDA.imm (0x2b);               // character "+"
/* bed5 */                   LDX.zpg ("tempf2+2_005e");    // get exponent count
/* bed7 */                   BEQ.rel ("_bf07");            // if zero go set null terminator and exit
                                                           // exponent isn't zero so write exponent
/* bed9 */                   BPL.rel ("_bee3");            // branch if exponent count +ve
/* bedb */                   LDA.imm (0x00);               // clear A
/* bedd */                   SEC.imp ();                   // set carry for subtract
/* bede */                   SBC.zpg ("tempf2+2_005e");    // subtract exponent count adjust (convert -ve to +ve)
/* bee0 */                   TAX.imp ();                   // copy exponent count to X
/* bee1 */                   LDA.imm (0x2d);               // character "-"
/* bee3 */        _`_bee3`;  STA.aby ("bad+1_0101");       // save to output string
/* bee6 */                   LDA.imm (0x45);               // character "E"
/* bee8 */                   STA.aby ("bad+0_0100");       // save exponent sign to output string
/* beeb */                   TXA.imp ();                   // get exponent count back
/* beec */                   LDX.imm (0x2f);               // one less than "0" character
/* beee */                   SEC.imp ();                   // set carry for subtract
/* beef */        _`_beef`;  INX.imp ();                   // increment 10's character
/* bef0 */                   SBC.imm (0x0a);               // subtract 10 from exponent count
/* bef2 */                   BCS.rel ("_beef");            // loop while still >= 0
/* bef4 */                   ADC.imm (0x3a);               // add character ":" ($30+$0A, result is 10 less that value)
/* bef6 */                   STA.aby ("bad+3_0103");       // save to output string
/* bef9 */                   TXA.imp ();                   // copy 10's character
/* befa */                   STA.aby ("bad+2_0102");       // save to output string
/* befd */                   LDA.imm (0x00);               // set null terminator
/* beff */                   STA.aby ("bad+4_0104");       // save to output string
/* bf02 */                   BEQ.rel ("_bf0c");            // go set string pointer (AY) and exit, branch always
                                                           // save last character, [EOT] and exit
/* bf04 */        _`_bf04`;  STA.aby ("baszpt_00ff");      // save last character to output string
                                                           // set null terminator and exit
/* bf07 */        _`_bf07`;  LDA.imm (0x00);               // set null terminator
/* bf09 */                   STA.aby ("bad+0_0100");       // save after last character
                                                           // set string pointer (AY) and exit
/* bf0c */        _`_bf0c`;  LDA.imm (0x00);               // set result string pointer low byte
/* bf0e */                   LDY.imm (0x01);               // set result string pointer high byte
/* bf10 */                   RTS.imp ();

// ------------------------------------------------------- // constants
/* bf11 */   _`fhalf_bf11`;  _.bytes(0x80, 0x00);          // 0.5, first two bytes
/* bf13 */                   _.bytes(0x00, 0x00, 0x00);    // null return for undefined variables
                                                           // -100 000 000
/* bf16 */        _`_bf16`;  _.bytes(0xfa, 0x0a, 0x1f, 0x00);
                                                           //  +10 000 000
/* bf1a */                   _.bytes(0x00, 0x98, 0x96, 0x80);
                                                           //   -1 000 000
/* bf1e */                   _.bytes(0xff, 0xf0, 0xbd, 0xc0);
                                                           //     +100 000
/* bf22 */                   _.bytes(0x00, 0x01, 0x86, 0xa0);
                                                           //      -10 000
/* bf26 */                   _.bytes(0xff, 0xff, 0xd8, 0xf0);
                                                           //       +1 000
/* bf2a */                   _.bytes(0x00, 0x00, 0x03, 0xe8);
                                                           //        - 100
/* bf2e */                   _.bytes(0xff, 0xff, 0xff, 0x9c);
                                                           //          +10
/* bf32 */                   _.bytes(0x00, 0x00, 0x00, 0x0a);
                                                           //           -1
/* bf36 */                   _.bytes(0xff, 0xff, 0xff, 0xff);

// ------------------------------------------------------- // jiffy counts
                                                           // -2160000    10s hours
/* bf3a */  _`fdcend_bf3a`;  _.bytes(0xff, 0xdf, 0x0a, 0x80);
                                                           //  +216000        hours
/* bf3e */                   _.bytes(0x00, 0x03, 0x4b, 0xc0);
                                                           //   -36000    10s mins
/* bf42 */                   _.bytes(0xff, 0xff, 0x73, 0x60);
                                                           //    +3600        mins
/* bf46 */                   _.bytes(0x00, 0x00, 0x0e, 0x10);
                                                           //     -600    10s secs
/* bf4a */                   _.bytes(0xff, 0xff, 0xfd, 0xa8);
                                                           //      +60        secs
/* bf4e */                   _.bytes(0x00, 0x00, 0x00, 0x3c);

// ------------------------------------------------------- // not referenced
/* bf52 */                   _.bytes(0xec);                // checksum byte

// ------------------------------------------------------- // spare bytes, not referenced
/* bf53 */                   _.bytes(0xaa, 0xaa, 0xaa, 0xaa, 0xaa);
/* bf58 */                   _.bytes(0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa);
/* bf60 */                   _.bytes(0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa);
/* bf68 */                   _.bytes(0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa);
/* bf70 */                   _.bytes(0xaa);

// ------------------------------------------------------- // perform SQR()
/* bf71 */     _`sqr_bf71`;  JSR.abs ("movaf_bc0c");       // round and copy FAC1 to FAC2
/* bf74 */                   LDA.imm (0x11);               // set 0.5 pointer low address
/* bf76 */                   LDY.imm (0xbf);               // set 0.5 pointer high address
/* bf78 */                   JSR.abs ("movfm_bba2");       // unpack memory (AY) into FAC1

// ------------------------------------------------------- // perform power function
/* bf7b */   _`fpwrt_bf7b`;  BEQ.rel ("exp_bfed");         // perform EXP()
/* bf7d */                   LDA.zpg ("argexp_0069");      // get FAC2 exponent
/* bf7f */                   BNE.rel ("_bf84");            // branch if FAC2<>0
/* bf81 */                   JMP.abs ("_b8f9");            // clear FAC1 exponent and sign and return
/* bf84 */        _`_bf84`;  LDX.imm (0x4e);               // set destination pointer low byte
/* bf86 */                   LDY.imm (0x00);               // set destination pointer high byte
/* bf88 */                   JSR.abs ("_bbd4");            // pack FAC1 into (XY)
/* bf8b */                   LDA.zpg ("argsgn_006e");      // get FAC2 sign (b7)
/* bf8d */                   BPL.rel ("_bf9e");            // branch if FAC2>0
                                                           // else FAC2 is -ve and can only be raised to an
                                                           // integer power which gives an x + j0 result
/* bf8f */                   JSR.abs ("int_bccc");         // perform INT()
/* bf92 */                   LDA.imm (0x4e);               // set source pointer low byte
/* bf94 */                   LDY.imm (0x00);               // set source pointer high byte
/* bf96 */                   JSR.abs ("fcomp_bc5b");       // compare FAC1 with (AY)
/* bf99 */                   BNE.rel ("_bf9e");            // branch if FAC1 <> (AY) to allow Function Call error
                                                           // this will leave FAC1 -ve and cause a Function Call
                                                           // error when LOG() is called
/* bf9b */                   TYA.imp ();                   // clear sign b7
/* bf9c */                   LDY.zpg ("charac_0007");      // get FAC1 mantissa 4 from INT() function as sign in
                                                           // Y for possible later negation, b0 only needed
/* bf9e */        _`_bf9e`;  JSR.abs ("_bbfe");            // save FAC1 sign and copy ABS(FAC2) to FAC1
/* bfa1 */                   TYA.imp ();                   // copy sign back ..
/* bfa2 */                   PHA.imp ();                   // .. and save it
/* bfa3 */                   JSR.abs ("log_b9ea");         // perform LOG()
/* bfa6 */                   LDA.imm (0x4e);               // set pointer low byte
/* bfa8 */                   LDY.imm (0x00);               // set pointer high byte
/* bfaa */                   JSR.abs ("fmult_ba28");       // do convert AY, FCA1*(AY)
/* bfad */                   JSR.abs ("exp_bfed");         // perform EXP()
/* bfb0 */                   PLA.imp ();                   // pull sign from stack
/* bfb1 */                   LSR.acc ();                   // b0 is to be tested
/* bfb2 */                   BCC.rel ("_bfbe");            // if no bit then exit
                                                           // do - FAC1
/* bfb4 */   _`negop_bfb4`;  LDA.zpg ("facexp_0061");      // get FAC1 exponent
/* bfb6 */                   BEQ.rel ("_bfbe");            // exit if FAC1_e = $00
/* bfb8 */                   LDA.zpg ("facsgn_0066");      // get FAC1 sign (b7)
/* bfba */                   EOR.imm (0xff);               // complement it
/* bfbc */                   STA.zpg ("facsgn_0066");      // save FAC1 sign (b7)
/* bfbe */        _`_bfbe`;  RTS.imp ();

// ------------------------------------------------------- // exp(n) constant and series
                                                           // 1.44269504 = 1/LOG(2)
/* bfbf */  _`logeb2_bfbf`;  _.bytes(0x81, 0x38, 0xaa, 0x3b, 0x29);
/* bfc4 */                   _.bytes(0x07);                // series count
                                                           // 2.14987637E-5
/* bfc5 */                   _.bytes(0x71, 0x34, 0x58, 0x3e, 0x56);
                                                           // 1.43523140E-4
/* bfca */                   _.bytes(0x74, 0x16, 0x7e, 0xb3, 0x1b);
                                                           // 1.34226348E-3
/* bfcf */                   _.bytes(0x77, 0x2f, 0xee, 0xe3, 0x85);
                                                           // 9.61401701E-3
/* bfd4 */                   _.bytes(0x7a, 0x1d, 0x84, 0x1c, 0x2a);
                                                           // 5.55051269E-2
/* bfd9 */                   _.bytes(0x7c, 0x63, 0x59, 0x58, 0x0a);
                                                           // 2.40226385E-1
/* bfde */                   _.bytes(0x7e, 0x75, 0xfd, 0xe7, 0xc6);
                                                           // 6.93147186E-1
/* bfe3 */                   _.bytes(0x80, 0x31, 0x72, 0x18, 0x10);
                                                           // 1.00000000
/* bfe8 */                   _.bytes(0x81, 0x00, 0x00, 0x00, 0x00);

// ------------------------------------------------------- // perform EXP()
/* bfed */     _`exp_bfed`;  LDA.imm (0xbf);               // set 1.443 pointer low byte
/* bfef */                   LDY.imm (0xbf);               // set 1.443 pointer high byte
/* bff1 */                   JSR.abs ("fmult_ba28");       // do convert AY, FCA1*(AY)
/* bff4 */                   LDA.zpg ("facov_0070");       // get FAC1 rounding byte
/* bff6 */                   ADC.imm (0x50);               // +$50/$100
/* bff8 */                   BCC.rel ("_bffd");            // skip rounding if no carry
/* bffa */                   JSR.abs ("_bc23");            // round FAC1 (no check)
/* bffd */        _`_bffd`;  JMP.abs ("(exp_e000");        // continue EXP()

  }
));


/***/ }),

/***/ "./src/target/rom/character.js":
/*!*************************************!*\
  !*** ./src/target/rom/character.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
   Characters ($d000 – $efff, when mapped)

   The source below assembles into a bytestream fully compatible with the C64's
   character ROM.

   If you want to substitute your own ROM, just export a byte array instead:
       export default [ 0x.., ... ];

   Unlike the rest of the Viciious project, which was authored from scratch and
   entered into the public domain, the source below is derived from works by
   multiple other authors and I make no representations as to its ownership or
   terms of use.
*/

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ([

  // Unshifted $00 (0) >@<
  "  XXXX  ",
  " XX  XX ",
  " XX XXX ",
  " XX XXX ",
  " XX     ",
  " XX   X ",
  "  XXXX  ",
  "        ",

  // Unshifted $01 (1) >A<
  "   XX   ",
  "  XXXX  ",
  " XX  XX ",
  " XXXXXX ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  "        ",

  // Unshifted $02 (2) >B<
  " XXXXX  ",
  " XX  XX ",
  " XX  XX ",
  " XXXXX  ",
  " XX  XX ",
  " XX  XX ",
  " XXXXX  ",
  "        ",

  // Unshifted $03 (3) >C<
  "  XXXX  ",
  " XX  XX ",
  " XX     ",
  " XX     ",
  " XX     ",
  " XX  XX ",
  "  XXXX  ",
  "        ",

  // Unshifted $04 (4) >D<
  " XXXX   ",
  " XX XX  ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  " XX XX  ",
  " XXXX   ",
  "        ",

  // Unshifted $05 (5) >E<
  " XXXXXX ",
  " XX     ",
  " XX     ",
  " XXXX   ",
  " XX     ",
  " XX     ",
  " XXXXXX ",
  "        ",

  // Unshifted $06 (6) >F<
  " XXXXXX ",
  " XX     ",
  " XX     ",
  " XXXX   ",
  " XX     ",
  " XX     ",
  " XX     ",
  "        ",

  // Unshifted $07 (7) >G<
  "  XXXX  ",
  " XX  XX ",
  " XX     ",
  " XX XXX ",
  " XX  XX ",
  " XX  XX ",
  "  XXXX  ",
  "        ",

  // Unshifted $08 (8) >H<
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  " XXXXXX ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  "        ",

  // Unshifted $09 (9) >I<
  "  XXXX  ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "  XXXX  ",
  "        ",

  // Unshifted $0a (10) >J<
  "   XXXX ",
  "    XX  ",
  "    XX  ",
  "    XX  ",
  "    XX  ",
  " XX XX  ",
  "  XXX   ",
  "        ",

  // Unshifted $0b (11) >K<
  " XX  XX ",
  " XX XX  ",
  " XXXX   ",
  " XXX    ",
  " XXXX   ",
  " XX XX  ",
  " XX  XX ",
  "        ",

  // Unshifted $0c (12) >L<
  " XX     ",
  " XX     ",
  " XX     ",
  " XX     ",
  " XX     ",
  " XX     ",
  " XXXXXX ",
  "        ",

  // Unshifted $0d (13) >M<
  " XX   XX",
  " XXX XXX",
  " XXXXXXX",
  " XX X XX",
  " XX   XX",
  " XX   XX",
  " XX   XX",
  "        ",

  // Unshifted $0e (14) >N<
  " XX  XX ",
  " XXX XX ",
  " XXXXXX ",
  " XXXXXX ",
  " XX XXX ",
  " XX  XX ",
  " XX  XX ",
  "        ",

  // Unshifted $0f (15) >O<
  "  XXXX  ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  "  XXXX  ",
  "        ",

  // Unshifted $10 (16) >P<
  " XXXXX  ",
  " XX  XX ",
  " XX  XX ",
  " XXXXX  ",
  " XX     ",
  " XX     ",
  " XX     ",
  "        ",

  // Unshifted $11 (17) >Q<
  "  XXXX  ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  "  XXXX  ",
  "    XXX ",
  "        ",

  // Unshifted $12 (18) >R<
  " XXXXX  ",
  " XX  XX ",
  " XX  XX ",
  " XXXXX  ",
  " XXXX   ",
  " XX XX  ",
  " XX  XX ",
  "        ",

  // Unshifted $13 (19) >S<
  "  XXXX  ",
  " XX  XX ",
  " XX     ",
  "  XXXX  ",
  "     XX ",
  " XX  XX ",
  "  XXXX  ",
  "        ",

  // Unshifted $14 (20) >T<
  " XXXXXX ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "        ",

  // Unshifted $15 (21) >U<
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  "  XXXX  ",
  "        ",

  // Unshifted $16 (22) >V<
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  "  XXXX  ",
  "   XX   ",
  "        ",

  // Unshifted $17 (23) >W<
  " XX   XX",
  " XX   XX",
  " XX   XX",
  " XX X XX",
  " XXXXXXX",
  " XXX XXX",
  " XX   XX",
  "        ",

  // Unshifted $18 (24) >X<
  " XX  XX ",
  " XX  XX ",
  "  XXXX  ",
  "   XX   ",
  "  XXXX  ",
  " XX  XX ",
  " XX  XX ",
  "        ",

  // Unshifted $19 (25) >Y<
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  "  XXXX  ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "        ",

  // Unshifted $1a (26) >Z<
  " XXXXXX ",
  "     XX ",
  "    XX  ",
  "   XX   ",
  "  XX    ",
  " XX     ",
  " XXXXXX ",
  "        ",

  // Unshifted $1b (27) >[<
  "  XXXX  ",
  "  XX    ",
  "  XX    ",
  "  XX    ",
  "  XX    ",
  "  XX    ",
  "  XXXX  ",
  "        ",

  // Unshifted $1c (28) >£<
  "    XX  ",
  "   X  X ",
  "  XX    ",
  " XXXXX  ",
  "  XX    ",
  " XX   X ",
  "XXXXXX  ",
  "        ",

  // Unshifted $1d (29) >]<
  "  XXXX  ",
  "    XX  ",
  "    XX  ",
  "    XX  ",
  "    XX  ",
  "    XX  ",
  "  XXXX  ",
  "        ",

  // Unshifted $1e (30) >↑<
  "        ",
  "   XX   ",
  "  XXXX  ",
  " XXXXXX ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",

  // Unshifted $1f (31) >←<
  "        ",
  "   X    ",
  "  XX    ",
  " XXXXXXX",
  " XXXXXXX",
  "  XX    ",
  "   X    ",
  "        ",

  // Unshifted $20 (32) > <
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",

  // Unshifted $21 (33) >!<
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "        ",
  "        ",
  "   XX   ",
  "        ",

  // Unshifted $22 (34) >"<
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",

  // Unshifted $23 (35) >#<
  " XX  XX ",
  " XX  XX ",
  "XXXXXXXX",
  " XX  XX ",
  "XXXXXXXX",
  " XX  XX ",
  " XX  XX ",
  "        ",

  // Unshifted $24 (36) >$<
  "   XX   ",
  "  XXXXX ",
  " XX     ",
  "  XXXX  ",
  "     XX ",
  " XXXXX  ",
  "   XX   ",
  "        ",

  // Unshifted $25 (37) >%<
  " XX   X ",
  " XX  XX ",
  "    XX  ",
  "   XX   ",
  "  XX    ",
  " XX  XX ",
  " X   XX ",
  "        ",

  // Unshifted $26 (38) >&<
  "  XXXX  ",
  " XX  XX ",
  "  XXXX  ",
  "  XXX   ",
  " XX  XXX",
  " XX  XX ",
  "  XXXXXX",
  "        ",

  // Unshifted $27 (39) >'<
  "     XX ",
  "    XX  ",
  "   XX   ",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",

  // Unshifted $28 (40) >(<
  "    XX  ",
  "   XX   ",
  "  XX    ",
  "  XX    ",
  "  XX    ",
  "   XX   ",
  "    XX  ",
  "        ",

  // Unshifted $29 (41) >)<
  "  XX    ",
  "   XX   ",
  "    XX  ",
  "    XX  ",
  "    XX  ",
  "   XX   ",
  "  XX    ",
  "        ",

  // Unshifted $2a (42) >*<
  "        ",
  " XX  XX ",
  "  XXXX  ",
  "XXXXXXXX",
  "  XXXX  ",
  " XX  XX ",
  "        ",
  "        ",

  // Unshifted $2b (43) >+<
  "        ",
  "   XX   ",
  "   XX   ",
  " XXXXXX ",
  "   XX   ",
  "   XX   ",
  "        ",
  "        ",

  // Unshifted $2c (44) >,<
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "   XX   ",
  "   XX   ",
  "  XX    ",

  // Unshifted $2d (45) >-<
  "        ",
  "        ",
  "        ",
  " XXXXXX ",
  "        ",
  "        ",
  "        ",
  "        ",

  // Unshifted $2e (46) >.<
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "   XX   ",
  "   XX   ",
  "        ",

  // Unshifted $2f (47) >/<
  "        ",
  "      XX",
  "     XX ",
  "    XX  ",
  "   XX   ",
  "  XX    ",
  " XX     ",
  "        ",

  // Unshifted $30 (48) >0<
  "  XXXX  ",
  " XX  XX ",
  " XX XXX ",
  " XXX XX ",
  " XX  XX ",
  " XX  XX ",
  "  XXXX  ",
  "        ",

  // Unshifted $31 (49) >1<
  "   XX   ",
  "   XX   ",
  "  XXX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  " XXXXXX ",
  "        ",

  // Unshifted $32 (50) >2<
  "  XXXX  ",
  " XX  XX ",
  "     XX ",
  "    XX  ",
  "  XX    ",
  " XX     ",
  " XXXXXX ",
  "        ",

  // Unshifted $33 (51) >3<
  "  XXXX  ",
  " XX  XX ",
  "     XX ",
  "   XXX  ",
  "     XX ",
  " XX  XX ",
  "  XXXX  ",
  "        ",

  // Unshifted $34 (52) >4<
  "     XX ",
  "    XXX ",
  "   XXXX ",
  " XX  XX ",
  " XXXXXXX",
  "     XX ",
  "     XX ",
  "        ",

  // Unshifted $35 (53) >5<
  " XXXXXX ",
  " XX     ",
  " XXXXX  ",
  "     XX ",
  "     XX ",
  " XX  XX ",
  "  XXXX  ",
  "        ",

  // Unshifted $36 (54) >6<
  "  XXXX  ",
  " XX  XX ",
  " XX     ",
  " XXXXX  ",
  " XX  XX ",
  " XX  XX ",
  "  XXXX  ",
  "        ",

  // Unshifted $37 (55) >7<
  " XXXXXX ",
  " XX  XX ",
  "    XX  ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "        ",

  // Unshifted $38 (56) >8<
  "  XXXX  ",
  " XX  XX ",
  " XX  XX ",
  "  XXXX  ",
  " XX  XX ",
  " XX  XX ",
  "  XXXX  ",
  "        ",

  // Unshifted $39 (57) >9<
  "  XXXX  ",
  " XX  XX ",
  " XX  XX ",
  "  XXXXX ",
  "     XX ",
  " XX  XX ",
  "  XXXX  ",
  "        ",

  // Unshifted $3a (58) >:<
  "        ",
  "        ",
  "   XX   ",
  "        ",
  "        ",
  "   XX   ",
  "        ",
  "        ",

  // Unshifted $3b (59) >;<
  "        ",
  "        ",
  "   XX   ",
  "        ",
  "        ",
  "   XX   ",
  "   XX   ",
  "  XX    ",

  // Unshifted $3c (60) ><<
  "    XXX ",
  "   XX   ",
  "  XX    ",
  " XX     ",
  "  XX    ",
  "   XX   ",
  "    XXX ",
  "        ",

  // Unshifted $3d (61) >=<
  "        ",
  "        ",
  " XXXXXX ",
  "        ",
  " XXXXXX ",
  "        ",
  "        ",
  "        ",

  // Unshifted $3e (62) >><
  " XXX    ",
  "   XX   ",
  "    XX  ",
  "     XX ",
  "    XX  ",
  "   XX   ",
  " XXX    ",
  "        ",

  // Unshifted $3f (63) >?<
  "  XXXX  ",
  " XX  XX ",
  "     XX ",
  "    XX  ",
  "   XX   ",
  "        ",
  "   XX   ",
  "        ",

  // Unshifted $40 (64) >─<
  "        ",
  "        ",
  "        ",
  "XXXXXXXX",
  "XXXXXXXX",
  "        ",
  "        ",
  "        ",

  // Unshifted $41 (65) >♠<
  "    X   ",
  "   XXX  ",
  "  XXXXX ",
  " XXXXXXX",
  " XXXXXXX",
  "   XXX  ",
  "  XXXXX ",
  "        ",

  // Unshifted $42 (66) >│<
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",

  // Unshifted $43 (67) >─<
  "        ",
  "        ",
  "        ",
  "XXXXXXXX",
  "XXXXXXXX",
  "        ",
  "        ",
  "        ",

  // Unshifted $44 (68) >─<
  "        ",
  "        ",
  "XXXXXXXX",
  "XXXXXXXX",
  "        ",
  "        ",
  "        ",
  "        ",

  // Unshifted $45 (69) >▔<
  "        ",
  "XXXXXXXX",
  "XXXXXXXX",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",

  // Unshifted $46 (70) >─<
  "        ",
  "        ",
  "        ",
  "        ",
  "XXXXXXXX",
  "XXXXXXXX",
  "        ",
  "        ",

  // Unshifted $47 (71) >│<
  "  XX    ",
  "  XX    ",
  "  XX    ",
  "  XX    ",
  "  XX    ",
  "  XX    ",
  "  XX    ",
  "  XX    ",

  // Unshifted $48 (72) >│<
  "    XX  ",
  "    XX  ",
  "    XX  ",
  "    XX  ",
  "    XX  ",
  "    XX  ",
  "    XX  ",
  "    XX  ",

  // Unshifted $49 (73) >╮<
  "        ",
  "        ",
  "        ",
  "XXX     ",
  "XXXX    ",
  "  XXX   ",
  "   XX   ",
  "   XX   ",

  // Unshifted $4a (74) >╰<
  "   XX   ",
  "   XX   ",
  "   XXX  ",
  "    XXXX",
  "     XXX",
  "        ",
  "        ",
  "        ",

  // Unshifted $4b (75) >╯<
  "   XX   ",
  "   XX   ",
  "  XXX   ",
  "XXXX    ",
  "XXX     ",
  "        ",
  "        ",
  "        ",

  // Unshifted $4c (76) >⌞<
  "XX      ",
  "XX      ",
  "XX      ",
  "XX      ",
  "XX      ",
  "XX      ",
  "XXXXXXXX",
  "XXXXXXXX",

  // Unshifted $4d (77) >╲<
  "XX      ",
  "XXX     ",
  " XXX    ",
  "  XXX   ",
  "   XXX  ",
  "    XXX ",
  "     XXX",
  "      XX",

  // Unshifted $4e (78) >╱<
  "      XX",
  "     XXX",
  "    XXX ",
  "   XXX  ",
  "  XXX   ",
  " XXX    ",
  "XXX     ",
  "XX      ",

  // Unshifted $4f (79) >⌜<
  "XXXXXXXX",
  "XXXXXXXX",
  "XX      ",
  "XX      ",
  "XX      ",
  "XX      ",
  "XX      ",
  "XX      ",

  // Unshifted $50 (80) >⌝<
  "XXXXXXXX",
  "XXXXXXXX",
  "      XX",
  "      XX",
  "      XX",
  "      XX",
  "      XX",
  "      XX",

  // Unshifted $51 (81) >●<
  "        ",
  "  XXXX  ",
  " XXXXXX ",
  " XXXXXX ",
  " XXXXXX ",
  " XXXXXX ",
  "  XXXX  ",
  "        ",

  // Unshifted $52 (82) >_<
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "XXXXXXXX",
  "XXXXXXXX",
  "        ",

  // Unshifted $53 (83) >♥<
  "  XX XX ",
  " XXXXXXX",
  " XXXXXXX",
  " XXXXXXX",
  "  XXXXX ",
  "   XXX  ",
  "    X   ",
  "        ",

  // Unshifted $54 (84) >▎<
  " XX     ",
  " XX     ",
  " XX     ",
  " XX     ",
  " XX     ",
  " XX     ",
  " XX     ",
  " XX     ",

  // Unshifted $55 (85) >╭<
  "        ",
  "        ",
  "        ",
  "     XXX",
  "    XXXX",
  "   XXX  ",
  "   XX   ",
  "   XX   ",

  // Unshifted $56 (86) >╳<
  "XX    XX",
  "XXX  XXX",
  " XXXXXX ",
  "  XXXX  ",
  "  XXXX  ",
  " XXXXXX ",
  "XXX  XXX",
  "XX    XX",

  // Unshifted $57 (87) >○<
  "        ",
  "  XXXX  ",
  " XXXXXX ",
  " XX  XX ",
  " XX  XX ",
  " XXXXXX ",
  "  XXXX  ",
  "        ",

  // Unshifted $58 (88) >♣<
  "   XX   ",
  "   XX   ",
  " XX  XX ",
  " XX  XX ",
  "   XX   ",
  "   XX   ",
  "  XXXX  ",
  "        ",

  // Unshifted $59 (89) >▕<
  "     XX ",
  "     XX ",
  "     XX ",
  "     XX ",
  "     XX ",
  "     XX ",
  "     XX ",
  "     XX ",

  // Unshifted $5a (90) >♦<
  "    X   ",
  "   XXX  ",
  "  XXXXX ",
  " XXXXXXX",
  "  XXXXX ",
  "   XXX  ",
  "    X   ",
  "        ",

  // Unshifted $5b (91) >┼<
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "XXXXXXXX",
  "XXXXXXXX",
  "   XX   ",
  "   XX   ",
  "   XX   ",

  // Unshifted $5c (92) >▒<
  "XX      ",
  "XX      ",
  "  XX    ",
  "  XX    ",
  "XX      ",
  "XX      ",
  "  XX    ",
  "  XX    ",

  // Unshifted $5d (93) >│<
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",

  // Unshifted $5e (94) >π<
  "        ",
  "        ",
  "      XX",
  "  XXXXX ",
  " XXX XX ",
  "  XX XX ",
  "  XX XX ",
  "        ",

  // Unshifted $5f (95) >◥<
  "XXXXXXXX",
  " XXXXXXX",
  "  XXXXXX",
  "   XXXXX",
  "    XXXX",
  "     XXX",
  "      XX",
  "       X",

  // Unshifted $60 (96) > <
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",

  // Unshifted $61 (97) >▌<
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",

  // Unshifted $62 (98) >▄<
  "        ",
  "        ",
  "        ",
  "        ",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Unshifted $63 (99) >▔<
  "XXXXXXXX",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",

  // Unshifted $64 (100) >▁<
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "XXXXXXXX",

  // Unshifted $65 (101) >▎<
  "XX      ",
  "XX      ",
  "XX      ",
  "XX      ",
  "XX      ",
  "XX      ",
  "XX      ",
  "XX      ",

  // Unshifted $66 (102) >▒<
  "XX  XX  ",
  "XX  XX  ",
  "  XX  XX",
  "  XX  XX",
  "XX  XX  ",
  "XX  XX  ",
  "  XX  XX",
  "  XX  XX",

  // Unshifted $67 (103) >▕<
  "      XX",
  "      XX",
  "      XX",
  "      XX",
  "      XX",
  "      XX",
  "      XX",
  "      XX",

  // Unshifted $68 (104) >▒<
  "        ",
  "        ",
  "        ",
  "        ",
  "XX  XX  ",
  "XX  XX  ",
  "  XX  XX",
  "  XX  XX",

  // Unshifted $69 (105) >◤<
  "XXXXXXXX",
  "XXXXXXX ",
  "XXXXXX  ",
  "XXXXX   ",
  "XXXX    ",
  "XXX     ",
  "XX      ",
  "X       ",

  // Unshifted $6a (106) >▕<
  "      XX",
  "      XX",
  "      XX",
  "      XX",
  "      XX",
  "      XX",
  "      XX",
  "      XX",

  // Unshifted $6b (107) >├<
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XXXXX",
  "   XXXXX",
  "   XX   ",
  "   XX   ",
  "   XX   ",

  // Unshifted $6c (108) >▗<
  "        ",
  "        ",
  "        ",
  "        ",
  "    XXXX",
  "    XXXX",
  "    XXXX",
  "    XXXX",

  // Unshifted $6d (109) >└<
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XXXXX",
  "   XXXXX",
  "        ",
  "        ",
  "        ",

  // Unshifted $6e (110) >┐<
  "        ",
  "        ",
  "        ",
  "XXXXX   ",
  "XXXXX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",

  // Unshifted $6f (111) >▂<
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "XXXXXXXX",
  "XXXXXXXX",

  // Unshifted $70 (112) >┌<
  "        ",
  "        ",
  "        ",
  "   XXXXX",
  "   XXXXX",
  "   XX   ",
  "   XX   ",
  "   XX   ",

  // Unshifted $71 (113) >┴<
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "XXXXXXXX",
  "XXXXXXXX",
  "        ",
  "        ",
  "        ",

  // Unshifted $72 (114) >┬<
  "        ",
  "        ",
  "        ",
  "XXXXXXXX",
  "XXXXXXXX",
  "   XX   ",
  "   XX   ",
  "   XX   ",

  // Unshifted $73 (115) >┤<
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "XXXXX   ",
  "XXXXX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",

  // Unshifted $74 (116) >▎<
  "XX      ",
  "XX      ",
  "XX      ",
  "XX      ",
  "XX      ",
  "XX      ",
  "XX      ",
  "XX      ",

  // Unshifted $75 (117) >▍<
  "XXX     ",
  "XXX     ",
  "XXX     ",
  "XXX     ",
  "XXX     ",
  "XXX     ",
  "XXX     ",
  "XXX     ",

  // Unshifted $76 (118) >▕<
  "     XXX",
  "     XXX",
  "     XXX",
  "     XXX",
  "     XXX",
  "     XXX",
  "     XXX",
  "     XXX",

  // Unshifted $77 (119) >▔<
  "XXXXXXXX",
  "XXXXXXXX",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",

  // Unshifted $78 (120) >▔<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",

  // Unshifted $79 (121) >▃<
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Unshifted $7a (122) >⌟<
  "      XX",
  "      XX",
  "      XX",
  "      XX",
  "      XX",
  "      XX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Unshifted $7b (123) >▖<
  "        ",
  "        ",
  "        ",
  "        ",
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",

  // Unshifted $7c (124) >▝<
  "    XXXX",
  "    XXXX",
  "    XXXX",
  "    XXXX",
  "        ",
  "        ",
  "        ",
  "        ",

  // Unshifted $7d (125) >┘<
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "XXXXX   ",
  "XXXXX   ",
  "        ",
  "        ",
  "        ",

  // Unshifted $7e (126) >▘<
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",
  "        ",
  "        ",
  "        ",
  "        ",

  // Unshifted $7f (127) >▚<
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",
  "    XXXX",
  "    XXXX",
  "    XXXX",
  "    XXXX",

  // Unshifted $80 (128) >@<
  "XX    XX",
  "X  XX  X",
  "X  X   X",
  "X  X   X",
  "X  XXXXX",
  "X  XX  X",
  "XX    XX",
  "XXXXXXXX",

  // Unshifted $81 (129) >A<
  "XXX  XXX",
  "XX    XX",
  "X  XX  X",
  "X      X",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "XXXXXXXX",

  // Unshifted $82 (130) >B<
  "X     XX",
  "X  XX  X",
  "X  XX  X",
  "X     XX",
  "X  XX  X",
  "X  XX  X",
  "X     XX",
  "XXXXXXXX",

  // Unshifted $83 (131) >C<
  "XX    XX",
  "X  XX  X",
  "X  XXXXX",
  "X  XXXXX",
  "X  XXXXX",
  "X  XX  X",
  "XX    XX",
  "XXXXXXXX",

  // Unshifted $84 (132) >D<
  "X    XXX",
  "X  X  XX",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "X  X  XX",
  "X    XXX",
  "XXXXXXXX",

  // Unshifted $85 (133) >E<
  "X      X",
  "X  XXXXX",
  "X  XXXXX",
  "X    XXX",
  "X  XXXXX",
  "X  XXXXX",
  "X      X",
  "XXXXXXXX",

  // Unshifted $86 (134) >F<
  "X      X",
  "X  XXXXX",
  "X  XXXXX",
  "X    XXX",
  "X  XXXXX",
  "X  XXXXX",
  "X  XXXXX",
  "XXXXXXXX",

  // Unshifted $87 (135) >G<
  "XX    XX",
  "X  XX  X",
  "X  XXXXX",
  "X  X   X",
  "X  XX  X",
  "X  XX  X",
  "XX    XX",
  "XXXXXXXX",

  // Unshifted $88 (136) >H<
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "X      X",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "XXXXXXXX",

  // Unshifted $89 (137) >I<
  "XX    XX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XX    XX",
  "XXXXXXXX",

  // Unshifted $8a (138) >J<
  "XXX    X",
  "XXXX  XX",
  "XXXX  XX",
  "XXXX  XX",
  "XXXX  XX",
  "X  X  XX",
  "XX   XXX",
  "XXXXXXXX",

  // Unshifted $8b (139) >K<
  "X  XX  X",
  "X  X  XX",
  "X    XXX",
  "X   XXXX",
  "X    XXX",
  "X  X  XX",
  "X  XX  X",
  "XXXXXXXX",

  // Unshifted $8c (140) >L<
  "X  XXXXX",
  "X  XXXXX",
  "X  XXXXX",
  "X  XXXXX",
  "X  XXXXX",
  "X  XXXXX",
  "X      X",
  "XXXXXXXX",

  // Unshifted $8d (141) >M<
  "X  XXX  ",
  "X   X   ",
  "X       ",
  "X  X X  ",
  "X  XXX  ",
  "X  XXX  ",
  "X  XXX  ",
  "XXXXXXXX",

  // Unshifted $8e (142) >N<
  "X  XX  X",
  "X   X  X",
  "X      X",
  "X      X",
  "X  X   X",
  "X  XX  X",
  "X  XX  X",
  "XXXXXXXX",

  // Unshifted $8f (143) >O<
  "XX    XX",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "XX    XX",
  "XXXXXXXX",

  // Unshifted $90 (144) >P<
  "X     XX",
  "X  XX  X",
  "X  XX  X",
  "X     XX",
  "X  XXXXX",
  "X  XXXXX",
  "X  XXXXX",
  "XXXXXXXX",

  // Unshifted $91 (145) >Q<
  "XX    XX",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "XX    XX",
  "XXXX   X",
  "XXXXXXXX",

  // Unshifted $92 (146) >R<
  "X     XX",
  "X  XX  X",
  "X  XX  X",
  "X     XX",
  "X    XXX",
  "X  X  XX",
  "X  XX  X",
  "XXXXXXXX",

  // Unshifted $93 (147) >S<
  "XX    XX",
  "X  XX  X",
  "X  XXXXX",
  "XX    XX",
  "XXXXX  X",
  "X  XX  X",
  "XX    XX",
  "XXXXXXXX",

  // Unshifted $94 (148) >T<
  "X      X",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXXXXXXX",

  // Unshifted $95 (149) >U<
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "XX    XX",
  "XXXXXXXX",

  // Unshifted $96 (150) >V<
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "XX    XX",
  "XXX  XXX",
  "XXXXXXXX",

  // Unshifted $97 (151) >W<
  "X  XXX  ",
  "X  XXX  ",
  "X  XXX  ",
  "X  X X  ",
  "X       ",
  "X   X   ",
  "X  XXX  ",
  "XXXXXXXX",

  // Unshifted $98 (152) >X<
  "X  XX  X",
  "X  XX  X",
  "XX    XX",
  "XXX  XXX",
  "XX    XX",
  "X  XX  X",
  "X  XX  X",
  "XXXXXXXX",

  // Unshifted $99 (153) >Y<
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "XX    XX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXXXXXXX",

  // Unshifted $9a (154) >Z<
  "X      X",
  "XXXXX  X",
  "XXXX  XX",
  "XXX  XXX",
  "XX  XXXX",
  "X  XXXXX",
  "X      X",
  "XXXXXXXX",

  // Unshifted $9b (155) >[<
  "XX    XX",
  "XX  XXXX",
  "XX  XXXX",
  "XX  XXXX",
  "XX  XXXX",
  "XX  XXXX",
  "XX    XX",
  "XXXXXXXX",

  // Unshifted $9c (156) >£<
  "XXXX  XX",
  "XXX XX X",
  "XX  XXXX",
  "X     XX",
  "XX  XXXX",
  "X  XXX X",
  "      XX",
  "XXXXXXXX",

  // Unshifted $9d (157) >]<
  "XX    XX",
  "XXXX  XX",
  "XXXX  XX",
  "XXXX  XX",
  "XXXX  XX",
  "XXXX  XX",
  "XX    XX",
  "XXXXXXXX",

  // Unshifted $9e (158) >↑<
  "XXXXXXXX",
  "XXX  XXX",
  "XX    XX",
  "X      X",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",

  // Unshifted $9f (159) >←<
  "XXXXXXXX",
  "XXX XXXX",
  "XX  XXXX",
  "X       ",
  "X       ",
  "XX  XXXX",
  "XXX XXXX",
  "XXXXXXXX",

  // Unshifted $a0 (160) > <
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Unshifted $a1 (161) >!<
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXX  XXX",
  "XXXXXXXX",

  // Unshifted $a2 (162) >"<
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Unshifted $a3 (163) >#<
  "X  XX  X",
  "X  XX  X",
  "        ",
  "X  XX  X",
  "        ",
  "X  XX  X",
  "X  XX  X",
  "XXXXXXXX",

  // Unshifted $a4 (164) >$<
  "XXX  XXX",
  "XX     X",
  "X  XXXXX",
  "XX    XX",
  "XXXXX  X",
  "X     XX",
  "XXX  XXX",
  "XXXXXXXX",

  // Unshifted $a5 (165) >%<
  "X  XXX X",
  "X  XX  X",
  "XXXX  XX",
  "XXX  XXX",
  "XX  XXXX",
  "X  XX  X",
  "X XXX  X",
  "XXXXXXXX",

  // Unshifted $a6 (166) >&<
  "XX    XX",
  "X  XX  X",
  "XX    XX",
  "XX   XXX",
  "X  XX   ",
  "X  XX  X",
  "XX      ",
  "XXXXXXXX",

  // Unshifted $a7 (167) >'<
  "XXXXX  X",
  "XXXX  XX",
  "XXX  XXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Unshifted $a8 (168) >(<
  "XXXX  XX",
  "XXX  XXX",
  "XX  XXXX",
  "XX  XXXX",
  "XX  XXXX",
  "XXX  XXX",
  "XXXX  XX",
  "XXXXXXXX",

  // Unshifted $a9 (169) >)<
  "XX  XXXX",
  "XXX  XXX",
  "XXXX  XX",
  "XXXX  XX",
  "XXXX  XX",
  "XXX  XXX",
  "XX  XXXX",
  "XXXXXXXX",

  // Unshifted $aa (170) >*<
  "XXXXXXXX",
  "X  XX  X",
  "XX    XX",
  "        ",
  "XX    XX",
  "X  XX  X",
  "XXXXXXXX",
  "XXXXXXXX",

  // Unshifted $ab (171) >+<
  "XXXXXXXX",
  "XXX  XXX",
  "XXX  XXX",
  "X      X",
  "XXX  XXX",
  "XXX  XXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Unshifted $ac (172) >,<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXX  XXX",
  "XXX  XXX",
  "XX  XXXX",

  // Unshifted $ad (173) >-<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "X      X",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Unshifted $ae (174) >.<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXXXXXXX",

  // Unshifted $af (175) >/<
  "XXXXXXXX",
  "XXXXXX  ",
  "XXXXX  X",
  "XXXX  XX",
  "XXX  XXX",
  "XX  XXXX",
  "X  XXXXX",
  "XXXXXXXX",

  // Unshifted $b0 (176) >0<
  "XX    XX",
  "X  XX  X",
  "X  X   X",
  "X   X  X",
  "X  XX  X",
  "X  XX  X",
  "XX    XX",
  "XXXXXXXX",

  // Unshifted $b1 (177) >1<
  "XXX  XXX",
  "XXX  XXX",
  "XX   XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "X      X",
  "XXXXXXXX",

  // Unshifted $b2 (178) >2<
  "XX    XX",
  "X  XX  X",
  "XXXXX  X",
  "XXXX  XX",
  "XX  XXXX",
  "X  XXXXX",
  "X      X",
  "XXXXXXXX",

  // Unshifted $b3 (179) >3<
  "XX    XX",
  "X  XX  X",
  "XXXXX  X",
  "XXX   XX",
  "XXXXX  X",
  "X  XX  X",
  "XX    XX",
  "XXXXXXXX",

  // Unshifted $b4 (180) >4<
  "XXXXX  X",
  "XXXX   X",
  "XXX    X",
  "X  XX  X",
  "X       ",
  "XXXXX  X",
  "XXXXX  X",
  "XXXXXXXX",

  // Unshifted $b5 (181) >5<
  "X      X",
  "X  XXXXX",
  "X     XX",
  "XXXXX  X",
  "XXXXX  X",
  "X  XX  X",
  "XX    XX",
  "XXXXXXXX",

  // Unshifted $b6 (182) >6<
  "XX    XX",
  "X  XX  X",
  "X  XXXXX",
  "X     XX",
  "X  XX  X",
  "X  XX  X",
  "XX    XX",
  "XXXXXXXX",

  // Unshifted $b7 (183) >7<
  "X      X",
  "X  XX  X",
  "XXXX  XX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXXXXXXX",

  // Unshifted $b8 (184) >8<
  "XX    XX",
  "X  XX  X",
  "X  XX  X",
  "XX    XX",
  "X  XX  X",
  "X  XX  X",
  "XX    XX",
  "XXXXXXXX",

  // Unshifted $b9 (185) >9<
  "XX    XX",
  "X  XX  X",
  "X  XX  X",
  "XX     X",
  "XXXXX  X",
  "X  XX  X",
  "XX    XX",
  "XXXXXXXX",

  // Unshifted $ba (186) >:<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXX  XXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXX  XXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Unshifted $bb (187) >;<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXX  XXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXX  XXX",
  "XXX  XXX",
  "XX  XXXX",

  // Unshifted $bc (188) ><<
  "XXXX   X",
  "XXX  XXX",
  "XX  XXXX",
  "X  XXXXX",
  "XX  XXXX",
  "XXX  XXX",
  "XXXX   X",
  "XXXXXXXX",

  // Unshifted $bd (189) >=<
  "XXXXXXXX",
  "XXXXXXXX",
  "X      X",
  "XXXXXXXX",
  "X      X",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Unshifted $be (190) >><
  "X   XXXX",
  "XXX  XXX",
  "XXXX  XX",
  "XXXXX  X",
  "XXXX  XX",
  "XXX  XXX",
  "X   XXXX",
  "XXXXXXXX",

  // Unshifted $bf (191) >?<
  "XX    XX",
  "X  XX  X",
  "XXXXX  X",
  "XXXX  XX",
  "XXX  XXX",
  "XXXXXXXX",
  "XXX  XXX",
  "XXXXXXXX",

  // Unshifted $c0 (192) >─<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "        ",
  "        ",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Unshifted $c1 (193) >♠<
  "XXXX XXX",
  "XXX   XX",
  "XX     X",
  "X       ",
  "X       ",
  "XXX   XX",
  "XX     X",
  "XXXXXXXX",

  // Unshifted $c2 (194) >│<
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",

  // Unshifted $c3 (195) >─<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "        ",
  "        ",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Unshifted $c4 (196) >─<
  "XXXXXXXX",
  "XXXXXXXX",
  "        ",
  "        ",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Unshifted $c5 (197) >▔<
  "XXXXXXXX",
  "        ",
  "        ",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Unshifted $c6 (198) >─<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "        ",
  "        ",
  "XXXXXXXX",
  "XXXXXXXX",

  // Unshifted $c7 (199) >│<
  "XX  XXXX",
  "XX  XXXX",
  "XX  XXXX",
  "XX  XXXX",
  "XX  XXXX",
  "XX  XXXX",
  "XX  XXXX",
  "XX  XXXX",

  // Unshifted $c8 (200) >│<
  "XXXX  XX",
  "XXXX  XX",
  "XXXX  XX",
  "XXXX  XX",
  "XXXX  XX",
  "XXXX  XX",
  "XXXX  XX",
  "XXXX  XX",

  // Unshifted $c9 (201) >╮<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "   XXXXX",
  "    XXXX",
  "XX   XXX",
  "XXX  XXX",
  "XXX  XXX",

  // Unshifted $ca (202) >╰<
  "XXX  XXX",
  "XXX  XXX",
  "XXX   XX",
  "XXXX    ",
  "XXXXX   ",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Unshifted $cb (203) >╯<
  "XXX  XXX",
  "XXX  XXX",
  "XX   XXX",
  "    XXXX",
  "   XXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Unshifted $cc (204) >⌞<
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",
  "        ",
  "        ",

  // Unshifted $cd (205) >╲<
  "  XXXXXX",
  "   XXXXX",
  "X   XXXX",
  "XX   XXX",
  "XXX   XX",
  "XXXX   X",
  "XXXXX   ",
  "XXXXXX  ",

  // Unshifted $ce (206) >╱<
  "XXXXXX  ",
  "XXXXX   ",
  "XXXX   X",
  "XXX   XX",
  "XX   XXX",
  "X   XXXX",
  "   XXXXX",
  "  XXXXXX",

  // Unshifted $cf (207) >⌜<
  "        ",
  "        ",
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",

  // Unshifted $d0 (208) >⌝<
  "        ",
  "        ",
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",

  // Unshifted $d1 (209) >●<
  "XXXXXXXX",
  "XX    XX",
  "X      X",
  "X      X",
  "X      X",
  "X      X",
  "XX    XX",
  "XXXXXXXX",

  // Unshifted $d2 (210) >_<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "        ",
  "        ",
  "XXXXXXXX",

  // Unshifted $d3 (211) >♥<
  "XX  X  X",
  "X       ",
  "X       ",
  "X       ",
  "XX     X",
  "XXX   XX",
  "XXXX XXX",
  "XXXXXXXX",

  // Unshifted $d4 (212) >▎<
  "X  XXXXX",
  "X  XXXXX",
  "X  XXXXX",
  "X  XXXXX",
  "X  XXXXX",
  "X  XXXXX",
  "X  XXXXX",
  "X  XXXXX",

  // Unshifted $d5 (213) >╭<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXX   ",
  "XXXX    ",
  "XXX   XX",
  "XXX  XXX",
  "XXX  XXX",

  // Unshifted $d6 (214) >╳<
  "  XXXX  ",
  "   XX   ",
  "X      X",
  "XX    XX",
  "XX    XX",
  "X      X",
  "   XX   ",
  "  XXXX  ",

  // Unshifted $d7 (215) >○<
  "XXXXXXXX",
  "XX    XX",
  "X      X",
  "X  XX  X",
  "X  XX  X",
  "X      X",
  "XX    XX",
  "XXXXXXXX",

  // Unshifted $d8 (216) >♣<
  "XXX  XXX",
  "XXX  XXX",
  "X  XX  X",
  "X  XX  X",
  "XXX  XXX",
  "XXX  XXX",
  "XX    XX",
  "XXXXXXXX",

  // Unshifted $d9 (217) >▕<
  "XXXXX  X",
  "XXXXX  X",
  "XXXXX  X",
  "XXXXX  X",
  "XXXXX  X",
  "XXXXX  X",
  "XXXXX  X",
  "XXXXX  X",

  // Unshifted $da (218) >♦<
  "XXXX XXX",
  "XXX   XX",
  "XX     X",
  "X       ",
  "XX     X",
  "XXX   XX",
  "XXXX XXX",
  "XXXXXXXX",

  // Unshifted $db (219) >┼<
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "        ",
  "        ",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",

  // Unshifted $dc (220) >▒<
  "  XXXXXX",
  "  XXXXXX",
  "XX  XXXX",
  "XX  XXXX",
  "  XXXXXX",
  "  XXXXXX",
  "XX  XXXX",
  "XX  XXXX",

  // Unshifted $dd (221) >│<
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",

  // Unshifted $de (222) >π<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXX  ",
  "XX     X",
  "X   X  X",
  "XX  X  X",
  "XX  X  X",
  "XXXXXXXX",

  // Unshifted $df (223) >◥<
  "        ",
  "X       ",
  "XX      ",
  "XXX     ",
  "XXXX    ",
  "XXXXX   ",
  "XXXXXX  ",
  "XXXXXXX ",

  // Unshifted $e0 (224) > <
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Unshifted $e1 (225) >▌<
  "    XXXX",
  "    XXXX",
  "    XXXX",
  "    XXXX",
  "    XXXX",
  "    XXXX",
  "    XXXX",
  "    XXXX",

  // Unshifted $e2 (226) >▄<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "        ",
  "        ",
  "        ",
  "        ",

  // Unshifted $e3 (227) >▔<
  "        ",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Unshifted $e4 (228) >▁<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "        ",

  // Unshifted $e5 (229) >▎<
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",

  // Unshifted $e6 (230) >▒<
  "  XX  XX",
  "  XX  XX",
  "XX  XX  ",
  "XX  XX  ",
  "  XX  XX",
  "  XX  XX",
  "XX  XX  ",
  "XX  XX  ",

  // Unshifted $e7 (231) >▕<
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",

  // Unshifted $e8 (232) >▒<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "  XX  XX",
  "  XX  XX",
  "XX  XX  ",
  "XX  XX  ",

  // Unshifted $e9 (233) >◤<
  "        ",
  "       X",
  "      XX",
  "     XXX",
  "    XXXX",
  "   XXXXX",
  "  XXXXXX",
  " XXXXXXX",

  // Unshifted $ea (234) >▕<
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",

  // Unshifted $eb (235) >├<
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX     ",
  "XXX     ",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",

  // Unshifted $ec (236) >▗<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",

  // Unshifted $ed (237) >└<
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX     ",
  "XXX     ",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Unshifted $ee (238) >┐<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "     XXX",
  "     XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",

  // Unshifted $ef (239) >▂<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "        ",
  "        ",

  // Unshifted $f0 (240) >┌<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXX     ",
  "XXX     ",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",

  // Unshifted $f1 (241) >┴<
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "        ",
  "        ",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Unshifted $f2 (242) >┬<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "        ",
  "        ",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",

  // Unshifted $f3 (243) >┤<
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "     XXX",
  "     XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",

  // Unshifted $f4 (244) >▎<
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",

  // Unshifted $f5 (245) >▍<
  "   XXXXX",
  "   XXXXX",
  "   XXXXX",
  "   XXXXX",
  "   XXXXX",
  "   XXXXX",
  "   XXXXX",
  "   XXXXX",

  // Unshifted $f6 (246) >▕<
  "XXXXX   ",
  "XXXXX   ",
  "XXXXX   ",
  "XXXXX   ",
  "XXXXX   ",
  "XXXXX   ",
  "XXXXX   ",
  "XXXXX   ",

  // Unshifted $f7 (247) >▔<
  "        ",
  "        ",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Unshifted $f8 (248) >▔<
  "        ",
  "        ",
  "        ",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Unshifted $f9 (249) >▃<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "        ",
  "        ",
  "        ",

  // Unshifted $fa (250) >⌟<
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",
  "        ",
  "        ",

  // Unshifted $fb (251) >▖<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "    XXXX",
  "    XXXX",
  "    XXXX",
  "    XXXX",

  // Unshifted $fc (252) >▝<
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Unshifted $fd (253) >┘<
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "     XXX",
  "     XXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Unshifted $fe (254) >▘<
  "    XXXX",
  "    XXXX",
  "    XXXX",
  "    XXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Unshifted $ff (255) >▚<
  "    XXXX",
  "    XXXX",
  "    XXXX",
  "    XXXX",
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",

  // Shifted $00 (0) >@<
  "  XXXX  ",
  " XX  XX ",
  " XX XXX ",
  " XX XXX ",
  " XX     ",
  " XX   X ",
  "  XXXX  ",
  "        ",

  // Shifted $01 (1) >a<
  "        ",
  "        ",
  "  XXXX  ",
  "     XX ",
  "  XXXXX ",
  " XX  XX ",
  "  XXXXX ",
  "        ",

  // Shifted $02 (2) >b<
  "        ",
  " XX     ",
  " XX     ",
  " XXXXX  ",
  " XX  XX ",
  " XX  XX ",
  " XXXXX  ",
  "        ",

  // Shifted $03 (3) >c<
  "        ",
  "        ",
  "  XXXX  ",
  " XX     ",
  " XX     ",
  " XX     ",
  "  XXXX  ",
  "        ",

  // Shifted $04 (4) >d<
  "        ",
  "     XX ",
  "     XX ",
  "  XXXXX ",
  " XX  XX ",
  " XX  XX ",
  "  XXXXX ",
  "        ",

  // Shifted $05 (5) >e<
  "        ",
  "        ",
  "  XXXX  ",
  " XX  XX ",
  " XXXXXX ",
  " XX     ",
  "  XXXX  ",
  "        ",

  // Shifted $06 (6) >f<
  "        ",
  "    XXX ",
  "   XX   ",
  "  XXXXX ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "        ",

  // Shifted $07 (7) >g<
  "        ",
  "        ",
  "  XXXXX ",
  " XX  XX ",
  " XX  XX ",
  "  XXXXX ",
  "     XX ",
  " XXXXX  ",

  // Shifted $08 (8) >h<
  "        ",
  " XX     ",
  " XX     ",
  " XXXXX  ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  "        ",

  // Shifted $09 (9) >i<
  "        ",
  "   XX   ",
  "        ",
  "  XXX   ",
  "   XX   ",
  "   XX   ",
  "  XXXX  ",
  "        ",

  // Shifted $0a (10) >j<
  "        ",
  "     XX ",
  "        ",
  "     XX ",
  "     XX ",
  "     XX ",
  "     XX ",
  "  XXXX  ",

  // Shifted $0b (11) >k<
  "        ",
  " XX     ",
  " XX     ",
  " XX XX  ",
  " XXXX   ",
  " XX XX  ",
  " XX  XX ",
  "        ",

  // Shifted $0c (12) >l<
  "        ",
  "  XXX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "  XXXX  ",
  "        ",

  // Shifted $0d (13) >m<
  "        ",
  "        ",
  " XX  XX ",
  " XXXXXXX",
  " XXXXXXX",
  " XX X XX",
  " XX   XX",
  "        ",

  // Shifted $0e (14) >n<
  "        ",
  "        ",
  " XXXXX  ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  "        ",

  // Shifted $0f (15) >o<
  "        ",
  "        ",
  "  XXXX  ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  "  XXXX  ",
  "        ",

  // Shifted $10 (16) >p<
  "        ",
  "        ",
  " XXXXX  ",
  " XX  XX ",
  " XX  XX ",
  " XXXXX  ",
  " XX     ",
  " XX     ",

  // Shifted $11 (17) >q<
  "        ",
  "        ",
  "  XXXXX ",
  " XX  XX ",
  " XX  XX ",
  "  XXXXX ",
  "     XX ",
  "     XX ",

  // Shifted $12 (18) >r<
  "        ",
  "        ",
  " XXXXX  ",
  " XX  XX ",
  " XX     ",
  " XX     ",
  " XX     ",
  "        ",

  // Shifted $13 (19) >s<
  "        ",
  "        ",
  "  XXXXX ",
  " XX     ",
  "  XXXX  ",
  "     XX ",
  " XXXXX  ",
  "        ",

  // Shifted $14 (20) >t<
  "        ",
  "   XX   ",
  " XXXXXX ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "    XXX ",
  "        ",

  // Shifted $15 (21) >u<
  "        ",
  "        ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  "  XXXXX ",
  "        ",

  // Shifted $16 (22) >v<
  "        ",
  "        ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  "  XXXX  ",
  "   XX   ",
  "        ",

  // Shifted $17 (23) >w<
  "        ",
  "        ",
  " XX   XX",
  " XX X XX",
  " XXXXXXX",
  "  XXXXX ",
  "  XX XX ",
  "        ",

  // Shifted $18 (24) >x<
  "        ",
  "        ",
  " XX  XX ",
  "  XXXX  ",
  "   XX   ",
  "  XXXX  ",
  " XX  XX ",
  "        ",

  // Shifted $19 (25) >y<
  "        ",
  "        ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  "  XXXXX ",
  "    XX  ",
  " XXXX   ",

  // Shifted $1a (26) >z<
  "        ",
  "        ",
  " XXXXXX ",
  "    XX  ",
  "   XX   ",
  "  XX    ",
  " XXXXXX ",
  "        ",

  // Shifted $1b (27) >[<
  "  XXXX  ",
  "  XX    ",
  "  XX    ",
  "  XX    ",
  "  XX    ",
  "  XX    ",
  "  XXXX  ",
  "        ",

  // Shifted $1c (28) >£<
  "    XX  ",
  "   X  X ",
  "  XX    ",
  " XXXXX  ",
  "  XX    ",
  " XX   X ",
  "XXXXXX  ",
  "        ",

  // Shifted $1d (29) >]<
  "  XXXX  ",
  "    XX  ",
  "    XX  ",
  "    XX  ",
  "    XX  ",
  "    XX  ",
  "  XXXX  ",
  "        ",

  // Shifted $1e (30) >↑<
  "        ",
  "   XX   ",
  "  XXXX  ",
  " XXXXXX ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",

  // Shifted $1f (31) >←<
  "        ",
  "   X    ",
  "  XX    ",
  " XXXXXXX",
  " XXXXXXX",
  "  XX    ",
  "   X    ",
  "        ",

  // Shifted $20 (32) > <
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",

  // Shifted $21 (33) >!<
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "        ",
  "        ",
  "   XX   ",
  "        ",

  // Shifted $22 (34) >"<
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",

  // Shifted $23 (35) >#<
  " XX  XX ",
  " XX  XX ",
  "XXXXXXXX",
  " XX  XX ",
  "XXXXXXXX",
  " XX  XX ",
  " XX  XX ",
  "        ",

  // Shifted $24 (36) >$<
  "   XX   ",
  "  XXXXX ",
  " XX     ",
  "  XXXX  ",
  "     XX ",
  " XXXXX  ",
  "   XX   ",
  "        ",

  // Shifted $25 (37) >%<
  " XX   X ",
  " XX  XX ",
  "    XX  ",
  "   XX   ",
  "  XX    ",
  " XX  XX ",
  " X   XX ",
  "        ",

  // Shifted $26 (38) >&<
  "  XXXX  ",
  " XX  XX ",
  "  XXXX  ",
  "  XXX   ",
  " XX  XXX",
  " XX  XX ",
  "  XXXXXX",
  "        ",

  // Shifted $27 (39) >'<
  "     XX ",
  "    XX  ",
  "   XX   ",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",

  // Shifted $28 (40) >(<
  "    XX  ",
  "   XX   ",
  "  XX    ",
  "  XX    ",
  "  XX    ",
  "   XX   ",
  "    XX  ",
  "        ",

  // Shifted $29 (41) >)<
  "  XX    ",
  "   XX   ",
  "    XX  ",
  "    XX  ",
  "    XX  ",
  "   XX   ",
  "  XX    ",
  "        ",

  // Shifted $2a (42) >*<
  "        ",
  " XX  XX ",
  "  XXXX  ",
  "XXXXXXXX",
  "  XXXX  ",
  " XX  XX ",
  "        ",
  "        ",

  // Shifted $2b (43) >+<
  "        ",
  "   XX   ",
  "   XX   ",
  " XXXXXX ",
  "   XX   ",
  "   XX   ",
  "        ",
  "        ",

  // Shifted $2c (44) >,<
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "   XX   ",
  "   XX   ",
  "  XX    ",

  // Shifted $2d (45) >-<
  "        ",
  "        ",
  "        ",
  " XXXXXX ",
  "        ",
  "        ",
  "        ",
  "        ",

  // Shifted $2e (46) >.<
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "   XX   ",
  "   XX   ",
  "        ",

  // Shifted $2f (47) >/<
  "        ",
  "      XX",
  "     XX ",
  "    XX  ",
  "   XX   ",
  "  XX    ",
  " XX     ",
  "        ",

  // Shifted $30 (48) >0<
  "  XXXX  ",
  " XX  XX ",
  " XX XXX ",
  " XXX XX ",
  " XX  XX ",
  " XX  XX ",
  "  XXXX  ",
  "        ",

  // Shifted $31 (49) >1<
  "   XX   ",
  "   XX   ",
  "  XXX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  " XXXXXX ",
  "        ",

  // Shifted $32 (50) >2<
  "  XXXX  ",
  " XX  XX ",
  "     XX ",
  "    XX  ",
  "  XX    ",
  " XX     ",
  " XXXXXX ",
  "        ",

  // Shifted $33 (51) >3<
  "  XXXX  ",
  " XX  XX ",
  "     XX ",
  "   XXX  ",
  "     XX ",
  " XX  XX ",
  "  XXXX  ",
  "        ",

  // Shifted $34 (52) >4<
  "     XX ",
  "    XXX ",
  "   XXXX ",
  " XX  XX ",
  " XXXXXXX",
  "     XX ",
  "     XX ",
  "        ",

  // Shifted $35 (53) >5<
  " XXXXXX ",
  " XX     ",
  " XXXXX  ",
  "     XX ",
  "     XX ",
  " XX  XX ",
  "  XXXX  ",
  "        ",

  // Shifted $36 (54) >6<
  "  XXXX  ",
  " XX  XX ",
  " XX     ",
  " XXXXX  ",
  " XX  XX ",
  " XX  XX ",
  "  XXXX  ",
  "        ",

  // Shifted $37 (55) >7<
  " XXXXXX ",
  " XX  XX ",
  "    XX  ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "        ",

  // Shifted $38 (56) >8<
  "  XXXX  ",
  " XX  XX ",
  " XX  XX ",
  "  XXXX  ",
  " XX  XX ",
  " XX  XX ",
  "  XXXX  ",
  "        ",

  // Shifted $39 (57) >9<
  "  XXXX  ",
  " XX  XX ",
  " XX  XX ",
  "  XXXXX ",
  "     XX ",
  " XX  XX ",
  "  XXXX  ",
  "        ",

  // Shifted $3a (58) >:<
  "        ",
  "        ",
  "   XX   ",
  "        ",
  "        ",
  "   XX   ",
  "        ",
  "        ",

  // Shifted $3b (59) >;<
  "        ",
  "        ",
  "   XX   ",
  "        ",
  "        ",
  "   XX   ",
  "   XX   ",
  "  XX    ",

  // Shifted $3c (60) ><<
  "    XXX ",
  "   XX   ",
  "  XX    ",
  " XX     ",
  "  XX    ",
  "   XX   ",
  "    XXX ",
  "        ",

  // Shifted $3d (61) >=<
  "        ",
  "        ",
  " XXXXXX ",
  "        ",
  " XXXXXX ",
  "        ",
  "        ",
  "        ",

  // Shifted $3e (62) >><
  " XXX    ",
  "   XX   ",
  "    XX  ",
  "     XX ",
  "    XX  ",
  "   XX   ",
  " XXX    ",
  "        ",

  // Shifted $3f (63) >?<
  "  XXXX  ",
  " XX  XX ",
  "     XX ",
  "    XX  ",
  "   XX   ",
  "        ",
  "   XX   ",
  "        ",

  // Shifted $40 (64) >─<
  "        ",
  "        ",
  "        ",
  "XXXXXXXX",
  "XXXXXXXX",
  "        ",
  "        ",
  "        ",

  // Shifted $41 (65) >A<
  "   XX   ",
  "  XXXX  ",
  " XX  XX ",
  " XXXXXX ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  "        ",

  // Shifted $42 (66) >B<
  " XXXXX  ",
  " XX  XX ",
  " XX  XX ",
  " XXXXX  ",
  " XX  XX ",
  " XX  XX ",
  " XXXXX  ",
  "        ",

  // Shifted $43 (67) >C<
  "  XXXX  ",
  " XX  XX ",
  " XX     ",
  " XX     ",
  " XX     ",
  " XX  XX ",
  "  XXXX  ",
  "        ",

  // Shifted $44 (68) >D<
  " XXXX   ",
  " XX XX  ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  " XX XX  ",
  " XXXX   ",
  "        ",

  // Shifted $45 (69) >E<
  " XXXXXX ",
  " XX     ",
  " XX     ",
  " XXXX   ",
  " XX     ",
  " XX     ",
  " XXXXXX ",
  "        ",

  // Shifted $46 (70) >F<
  " XXXXXX ",
  " XX     ",
  " XX     ",
  " XXXX   ",
  " XX     ",
  " XX     ",
  " XX     ",
  "        ",

  // Shifted $47 (71) >G<
  "  XXXX  ",
  " XX  XX ",
  " XX     ",
  " XX XXX ",
  " XX  XX ",
  " XX  XX ",
  "  XXXX  ",
  "        ",

  // Shifted $48 (72) >H<
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  " XXXXXX ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  "        ",

  // Shifted $49 (73) >I<
  "  XXXX  ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "  XXXX  ",
  "        ",

  // Shifted $4a (74) >J<
  "   XXXX ",
  "    XX  ",
  "    XX  ",
  "    XX  ",
  "    XX  ",
  " XX XX  ",
  "  XXX   ",
  "        ",

  // Shifted $4b (75) >K<
  " XX  XX ",
  " XX XX  ",
  " XXXX   ",
  " XXX    ",
  " XXXX   ",
  " XX XX  ",
  " XX  XX ",
  "        ",

  // Shifted $4c (76) >L<
  " XX     ",
  " XX     ",
  " XX     ",
  " XX     ",
  " XX     ",
  " XX     ",
  " XXXXXX ",
  "        ",

  // Shifted $4d (77) >M<
  " XX   XX",
  " XXX XXX",
  " XXXXXXX",
  " XX X XX",
  " XX   XX",
  " XX   XX",
  " XX   XX",
  "        ",

  // Shifted $4e (78) >N<
  " XX  XX ",
  " XXX XX ",
  " XXXXXX ",
  " XXXXXX ",
  " XX XXX ",
  " XX  XX ",
  " XX  XX ",
  "        ",

  // Shifted $4f (79) >O<
  "  XXXX  ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  "  XXXX  ",
  "        ",

  // Shifted $50 (80) >P<
  " XXXXX  ",
  " XX  XX ",
  " XX  XX ",
  " XXXXX  ",
  " XX     ",
  " XX     ",
  " XX     ",
  "        ",

  // Shifted $51 (81) >Q<
  "  XXXX  ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  "  XXXX  ",
  "    XXX ",
  "        ",

  // Shifted $52 (82) >R<
  " XXXXX  ",
  " XX  XX ",
  " XX  XX ",
  " XXXXX  ",
  " XXXX   ",
  " XX XX  ",
  " XX  XX ",
  "        ",

  // Shifted $53 (83) >S<
  "  XXXX  ",
  " XX  XX ",
  " XX     ",
  "  XXXX  ",
  "     XX ",
  " XX  XX ",
  "  XXXX  ",
  "        ",

  // Shifted $54 (84) >T<
  " XXXXXX ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "        ",

  // Shifted $55 (85) >U<
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  "  XXXX  ",
  "        ",

  // Shifted $56 (86) >V<
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  "  XXXX  ",
  "   XX   ",
  "        ",

  // Shifted $57 (87) >W<
  " XX   XX",
  " XX   XX",
  " XX   XX",
  " XX X XX",
  " XXXXXXX",
  " XXX XXX",
  " XX   XX",
  "        ",

  // Shifted $58 (88) >X<
  " XX  XX ",
  " XX  XX ",
  "  XXXX  ",
  "   XX   ",
  "  XXXX  ",
  " XX  XX ",
  " XX  XX ",
  "        ",

  // Shifted $59 (89) >Y<
  " XX  XX ",
  " XX  XX ",
  " XX  XX ",
  "  XXXX  ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "        ",

  // Shifted $5a (90) >Z<
  " XXXXXX ",
  "     XX ",
  "    XX  ",
  "   XX   ",
  "  XX    ",
  " XX     ",
  " XXXXXX ",
  "        ",

  // Shifted $5b (91) >┼<
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "XXXXXXXX",
  "XXXXXXXX",
  "   XX   ",
  "   XX   ",
  "   XX   ",

  // Shifted $5c (92) >▒<
  "XX      ",
  "XX      ",
  "  XX    ",
  "  XX    ",
  "XX      ",
  "XX      ",
  "  XX    ",
  "  XX    ",

  // Shifted $5d (93) >│<
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",

  // Shifted $5e (94) >▒<
  "  XX  XX",
  "  XX  XX",
  "XX  XX  ",
  "XX  XX  ",
  "  XX  XX",
  "  XX  XX",
  "XX  XX  ",
  "XX  XX  ",

  // Shifted $5f (95) >▒<
  "  XX  XX",
  "X  XX  X",
  "XX  XX  ",
  " XX  XX ",
  "  XX  XX",
  "X  XX  X",
  "XX  XX  ",
  " XX  XX ",

  // Shifted $60 (96) > <
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",

  // Shifted $61 (97) >▌<
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",

  // Shifted $62 (98) >▄<
  "        ",
  "        ",
  "        ",
  "        ",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Shifted $63 (99) >▔<
  "XXXXXXXX",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",

  // Shifted $64 (100) >▁<
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "XXXXXXXX",

  // Shifted $65 (101) >▎<
  "XX      ",
  "XX      ",
  "XX      ",
  "XX      ",
  "XX      ",
  "XX      ",
  "XX      ",
  "XX      ",

  // Shifted $66 (102) >▒<
  "XX  XX  ",
  "XX  XX  ",
  "  XX  XX",
  "  XX  XX",
  "XX  XX  ",
  "XX  XX  ",
  "  XX  XX",
  "  XX  XX",

  // Shifted $67 (103) >▕<
  "      XX",
  "      XX",
  "      XX",
  "      XX",
  "      XX",
  "      XX",
  "      XX",
  "      XX",

  // Shifted $68 (104) >▒<
  "        ",
  "        ",
  "        ",
  "        ",
  "XX  XX  ",
  "XX  XX  ",
  "  XX  XX",
  "  XX  XX",

  // Shifted $69 (105) >▒<
  "XX  XX  ",
  "X  XX  X",
  "  XX  XX",
  " XX  XX ",
  "XX  XX  ",
  "X  XX  X",
  "  XX  XX",
  " XX  XX ",

  // Shifted $6a (106) >▕<
  "      XX",
  "      XX",
  "      XX",
  "      XX",
  "      XX",
  "      XX",
  "      XX",
  "      XX",

  // Shifted $6b (107) >├<
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XXXXX",
  "   XXXXX",
  "   XX   ",
  "   XX   ",
  "   XX   ",

  // Shifted $6c (108) >▗<
  "        ",
  "        ",
  "        ",
  "        ",
  "    XXXX",
  "    XXXX",
  "    XXXX",
  "    XXXX",

  // Shifted $6d (109) >└<
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "   XXXXX",
  "   XXXXX",
  "        ",
  "        ",
  "        ",

  // Shifted $6e (110) >┐<
  "        ",
  "        ",
  "        ",
  "XXXXX   ",
  "XXXXX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",

  // Shifted $6f (111) >▂<
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "XXXXXXXX",
  "XXXXXXXX",

  // Shifted $70 (112) >┌<
  "        ",
  "        ",
  "        ",
  "   XXXXX",
  "   XXXXX",
  "   XX   ",
  "   XX   ",
  "   XX   ",

  // Shifted $71 (113) >┴<
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "XXXXXXXX",
  "XXXXXXXX",
  "        ",
  "        ",
  "        ",

  // Shifted $72 (114) >┬<
  "        ",
  "        ",
  "        ",
  "XXXXXXXX",
  "XXXXXXXX",
  "   XX   ",
  "   XX   ",
  "   XX   ",

  // Shifted $73 (115) >┤<
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "XXXXX   ",
  "XXXXX   ",
  "   XX   ",
  "   XX   ",
  "   XX   ",

  // Shifted $74 (116) >▎<
  "XX      ",
  "XX      ",
  "XX      ",
  "XX      ",
  "XX      ",
  "XX      ",
  "XX      ",
  "XX      ",

  // Shifted $75 (117) >▍<
  "XXX     ",
  "XXX     ",
  "XXX     ",
  "XXX     ",
  "XXX     ",
  "XXX     ",
  "XXX     ",
  "XXX     ",

  // Shifted $76 (118) >▕<
  "     XXX",
  "     XXX",
  "     XXX",
  "     XXX",
  "     XXX",
  "     XXX",
  "     XXX",
  "     XXX",

  // Shifted $77 (119) >▔<
  "XXXXXXXX",
  "XXXXXXXX",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",

  // Shifted $78 (120) >▔<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",

  // Shifted $79 (121) >▃<
  "        ",
  "        ",
  "        ",
  "        ",
  "        ",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Shifted $7a (122) >✓<
  "       X",
  "      XX",
  "     XX ",
  " XX XX  ",
  " XXXX   ",
  " XXX    ",
  " XX     ",
  "        ",

  // Shifted $7b (123) >▖<
  "        ",
  "        ",
  "        ",
  "        ",
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",

  // Shifted $7c (124) >▝<
  "    XXXX",
  "    XXXX",
  "    XXXX",
  "    XXXX",
  "        ",
  "        ",
  "        ",
  "        ",

  // Shifted $7d (125) >┘<
  "   XX   ",
  "   XX   ",
  "   XX   ",
  "XXXXX   ",
  "XXXXX   ",
  "        ",
  "        ",
  "        ",

  // Shifted $7e (126) >▘<
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",
  "        ",
  "        ",
  "        ",
  "        ",

  // Shifted $7f (127) >▚<
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",
  "    XXXX",
  "    XXXX",
  "    XXXX",
  "    XXXX",

  // Shifted $80 (128) >@<
  "XX    XX",
  "X  XX  X",
  "X  X   X",
  "X  X   X",
  "X  XXXXX",
  "X  XX  X",
  "XX    XX",
  "XXXXXXXX",

  // Shifted $81 (129) >a<
  "XXXXXXXX",
  "XXXXXXXX",
  "XX    XX",
  "XXXXX  X",
  "XX     X",
  "X  XX  X",
  "XX     X",
  "XXXXXXXX",

  // Shifted $82 (130) >b<
  "XXXXXXXX",
  "X  XXXXX",
  "X  XXXXX",
  "X     XX",
  "X  XX  X",
  "X  XX  X",
  "X     XX",
  "XXXXXXXX",

  // Shifted $83 (131) >c<
  "XXXXXXXX",
  "XXXXXXXX",
  "XX    XX",
  "X  XXXXX",
  "X  XXXXX",
  "X  XXXXX",
  "XX    XX",
  "XXXXXXXX",

  // Shifted $84 (132) >d<
  "XXXXXXXX",
  "XXXXX  X",
  "XXXXX  X",
  "XX     X",
  "X  XX  X",
  "X  XX  X",
  "XX     X",
  "XXXXXXXX",

  // Shifted $85 (133) >e<
  "XXXXXXXX",
  "XXXXXXXX",
  "XX    XX",
  "X  XX  X",
  "X      X",
  "X  XXXXX",
  "XX    XX",
  "XXXXXXXX",

  // Shifted $86 (134) >f<
  "XXXXXXXX",
  "XXXX   X",
  "XXX  XXX",
  "XX     X",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXXXXXXX",

  // Shifted $87 (135) >g<
  "XXXXXXXX",
  "XXXXXXXX",
  "XX     X",
  "X  XX  X",
  "X  XX  X",
  "XX     X",
  "XXXXX  X",
  "X     XX",

  // Shifted $88 (136) >h<
  "XXXXXXXX",
  "X  XXXXX",
  "X  XXXXX",
  "X     XX",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "XXXXXXXX",

  // Shifted $89 (137) >i<
  "XXXXXXXX",
  "XXX  XXX",
  "XXXXXXXX",
  "XX   XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XX    XX",
  "XXXXXXXX",

  // Shifted $8a (138) >j<
  "XXXXXXXX",
  "XXXXX  X",
  "XXXXXXXX",
  "XXXXX  X",
  "XXXXX  X",
  "XXXXX  X",
  "XXXXX  X",
  "XX    XX",

  // Shifted $8b (139) >k<
  "XXXXXXXX",
  "X  XXXXX",
  "X  XXXXX",
  "X  X  XX",
  "X    XXX",
  "X  X  XX",
  "X  XX  X",
  "XXXXXXXX",

  // Shifted $8c (140) >l<
  "XXXXXXXX",
  "XX   XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XX    XX",
  "XXXXXXXX",

  // Shifted $8d (141) >m<
  "XXXXXXXX",
  "XXXXXXXX",
  "X  XX  X",
  "X       ",
  "X       ",
  "X  X X  ",
  "X  XXX  ",
  "XXXXXXXX",

  // Shifted $8e (142) >n<
  "XXXXXXXX",
  "XXXXXXXX",
  "X     XX",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "XXXXXXXX",

  // Shifted $8f (143) >o<
  "XXXXXXXX",
  "XXXXXXXX",
  "XX    XX",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "XX    XX",
  "XXXXXXXX",

  // Shifted $90 (144) >p<
  "XXXXXXXX",
  "XXXXXXXX",
  "X     XX",
  "X  XX  X",
  "X  XX  X",
  "X     XX",
  "X  XXXXX",
  "X  XXXXX",

  // Shifted $91 (145) >q<
  "XXXXXXXX",
  "XXXXXXXX",
  "XX     X",
  "X  XX  X",
  "X  XX  X",
  "XX     X",
  "XXXXX  X",
  "XXXXX  X",

  // Shifted $92 (146) >r<
  "XXXXXXXX",
  "XXXXXXXX",
  "X     XX",
  "X  XX  X",
  "X  XXXXX",
  "X  XXXXX",
  "X  XXXXX",
  "XXXXXXXX",

  // Shifted $93 (147) >s<
  "XXXXXXXX",
  "XXXXXXXX",
  "XX     X",
  "X  XXXXX",
  "XX    XX",
  "XXXXX  X",
  "X     XX",
  "XXXXXXXX",

  // Shifted $94 (148) >t<
  "XXXXXXXX",
  "XXX  XXX",
  "X      X",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXXX   X",
  "XXXXXXXX",

  // Shifted $95 (149) >u<
  "XXXXXXXX",
  "XXXXXXXX",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "XX     X",
  "XXXXXXXX",

  // Shifted $96 (150) >v<
  "XXXXXXXX",
  "XXXXXXXX",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "XX    XX",
  "XXX  XXX",
  "XXXXXXXX",

  // Shifted $97 (151) >w<
  "XXXXXXXX",
  "XXXXXXXX",
  "X  XXX  ",
  "X  X X  ",
  "X       ",
  "XX     X",
  "XX  X  X",
  "XXXXXXXX",

  // Shifted $98 (152) >x<
  "XXXXXXXX",
  "XXXXXXXX",
  "X  XX  X",
  "XX    XX",
  "XXX  XXX",
  "XX    XX",
  "X  XX  X",
  "XXXXXXXX",

  // Shifted $99 (153) >y<
  "XXXXXXXX",
  "XXXXXXXX",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "XX     X",
  "XXXX  XX",
  "X    XXX",

  // Shifted $9a (154) >z<
  "XXXXXXXX",
  "XXXXXXXX",
  "X      X",
  "XXXX  XX",
  "XXX  XXX",
  "XX  XXXX",
  "X      X",
  "XXXXXXXX",

  // Shifted $9b (155) >[<
  "XX    XX",
  "XX  XXXX",
  "XX  XXXX",
  "XX  XXXX",
  "XX  XXXX",
  "XX  XXXX",
  "XX    XX",
  "XXXXXXXX",

  // Shifted $9c (156) >£<
  "XXXX  XX",
  "XXX XX X",
  "XX  XXXX",
  "X     XX",
  "XX  XXXX",
  "X  XXX X",
  "      XX",
  "XXXXXXXX",

  // Shifted $9d (157) >]<
  "XX    XX",
  "XXXX  XX",
  "XXXX  XX",
  "XXXX  XX",
  "XXXX  XX",
  "XXXX  XX",
  "XX    XX",
  "XXXXXXXX",

  // Shifted $9e (158) >↑<
  "XXXXXXXX",
  "XXX  XXX",
  "XX    XX",
  "X      X",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",

  // Shifted $9f (159) >←<
  "XXXXXXXX",
  "XXX XXXX",
  "XX  XXXX",
  "X       ",
  "X       ",
  "XX  XXXX",
  "XXX XXXX",
  "XXXXXXXX",

  // Shifted $a0 (160) > <
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Shifted $a1 (161) >!<
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXX  XXX",
  "XXXXXXXX",

  // Shifted $a2 (162) >"<
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Shifted $a3 (163) >#<
  "X  XX  X",
  "X  XX  X",
  "        ",
  "X  XX  X",
  "        ",
  "X  XX  X",
  "X  XX  X",
  "XXXXXXXX",

  // Shifted $a4 (164) >$<
  "XXX  XXX",
  "XX     X",
  "X  XXXXX",
  "XX    XX",
  "XXXXX  X",
  "X     XX",
  "XXX  XXX",
  "XXXXXXXX",

  // Shifted $a5 (165) >%<
  "X  XXX X",
  "X  XX  X",
  "XXXX  XX",
  "XXX  XXX",
  "XX  XXXX",
  "X  XX  X",
  "X XXX  X",
  "XXXXXXXX",

  // Shifted $a6 (166) >&<
  "XX    XX",
  "X  XX  X",
  "XX    XX",
  "XX   XXX",
  "X  XX   ",
  "X  XX  X",
  "XX      ",
  "XXXXXXXX",

  // Shifted $a7 (167) >'<
  "XXXXX  X",
  "XXXX  XX",
  "XXX  XXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Shifted $a8 (168) >(<
  "XXXX  XX",
  "XXX  XXX",
  "XX  XXXX",
  "XX  XXXX",
  "XX  XXXX",
  "XXX  XXX",
  "XXXX  XX",
  "XXXXXXXX",

  // Shifted $a9 (169) >)<
  "XX  XXXX",
  "XXX  XXX",
  "XXXX  XX",
  "XXXX  XX",
  "XXXX  XX",
  "XXX  XXX",
  "XX  XXXX",
  "XXXXXXXX",

  // Shifted $aa (170) >*<
  "XXXXXXXX",
  "X  XX  X",
  "XX    XX",
  "        ",
  "XX    XX",
  "X  XX  X",
  "XXXXXXXX",
  "XXXXXXXX",

  // Shifted $ab (171) >+<
  "XXXXXXXX",
  "XXX  XXX",
  "XXX  XXX",
  "X      X",
  "XXX  XXX",
  "XXX  XXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Shifted $ac (172) >,<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXX  XXX",
  "XXX  XXX",
  "XX  XXXX",

  // Shifted $ad (173) >-<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "X      X",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Shifted $ae (174) >.<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXXXXXXX",

  // Shifted $af (175) >/<
  "XXXXXXXX",
  "XXXXXX  ",
  "XXXXX  X",
  "XXXX  XX",
  "XXX  XXX",
  "XX  XXXX",
  "X  XXXXX",
  "XXXXXXXX",

  // Shifted $b0 (176) >0<
  "XX    XX",
  "X  XX  X",
  "X  X   X",
  "X   X  X",
  "X  XX  X",
  "X  XX  X",
  "XX    XX",
  "XXXXXXXX",

  // Shifted $b1 (177) >1<
  "XXX  XXX",
  "XXX  XXX",
  "XX   XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "X      X",
  "XXXXXXXX",

  // Shifted $b2 (178) >2<
  "XX    XX",
  "X  XX  X",
  "XXXXX  X",
  "XXXX  XX",
  "XX  XXXX",
  "X  XXXXX",
  "X      X",
  "XXXXXXXX",

  // Shifted $b3 (179) >3<
  "XX    XX",
  "X  XX  X",
  "XXXXX  X",
  "XXX   XX",
  "XXXXX  X",
  "X  XX  X",
  "XX    XX",
  "XXXXXXXX",

  // Shifted $b4 (180) >4<
  "XXXXX  X",
  "XXXX   X",
  "XXX    X",
  "X  XX  X",
  "X       ",
  "XXXXX  X",
  "XXXXX  X",
  "XXXXXXXX",

  // Shifted $b5 (181) >5<
  "X      X",
  "X  XXXXX",
  "X     XX",
  "XXXXX  X",
  "XXXXX  X",
  "X  XX  X",
  "XX    XX",
  "XXXXXXXX",

  // Shifted $b6 (182) >6<
  "XX    XX",
  "X  XX  X",
  "X  XXXXX",
  "X     XX",
  "X  XX  X",
  "X  XX  X",
  "XX    XX",
  "XXXXXXXX",

  // Shifted $b7 (183) >7<
  "X      X",
  "X  XX  X",
  "XXXX  XX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXXXXXXX",

  // Shifted $b8 (184) >8<
  "XX    XX",
  "X  XX  X",
  "X  XX  X",
  "XX    XX",
  "X  XX  X",
  "X  XX  X",
  "XX    XX",
  "XXXXXXXX",

  // Shifted $b9 (185) >9<
  "XX    XX",
  "X  XX  X",
  "X  XX  X",
  "XX     X",
  "XXXXX  X",
  "X  XX  X",
  "XX    XX",
  "XXXXXXXX",

  // Shifted $ba (186) >:<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXX  XXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXX  XXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Shifted $bb (187) >;<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXX  XXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXX  XXX",
  "XXX  XXX",
  "XX  XXXX",

  // Shifted $bc (188) ><<
  "XXXX   X",
  "XXX  XXX",
  "XX  XXXX",
  "X  XXXXX",
  "XX  XXXX",
  "XXX  XXX",
  "XXXX   X",
  "XXXXXXXX",

  // Shifted $bd (189) >=<
  "XXXXXXXX",
  "XXXXXXXX",
  "X      X",
  "XXXXXXXX",
  "X      X",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Shifted $be (190) >><
  "X   XXXX",
  "XXX  XXX",
  "XXXX  XX",
  "XXXXX  X",
  "XXXX  XX",
  "XXX  XXX",
  "X   XXXX",
  "XXXXXXXX",

  // Shifted $bf (191) >?<
  "XX    XX",
  "X  XX  X",
  "XXXXX  X",
  "XXXX  XX",
  "XXX  XXX",
  "XXXXXXXX",
  "XXX  XXX",
  "XXXXXXXX",

  // Shifted $c0 (192) >─<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "        ",
  "        ",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Shifted $c1 (193) >A<
  "XXX  XXX",
  "XX    XX",
  "X  XX  X",
  "X      X",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "XXXXXXXX",

  // Shifted $c2 (194) >B<
  "X     XX",
  "X  XX  X",
  "X  XX  X",
  "X     XX",
  "X  XX  X",
  "X  XX  X",
  "X     XX",
  "XXXXXXXX",

  // Shifted $c3 (195) >C<
  "XX    XX",
  "X  XX  X",
  "X  XXXXX",
  "X  XXXXX",
  "X  XXXXX",
  "X  XX  X",
  "XX    XX",
  "XXXXXXXX",

  // Shifted $c4 (196) >D<
  "X    XXX",
  "X  X  XX",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "X  X  XX",
  "X    XXX",
  "XXXXXXXX",

  // Shifted $c5 (197) >E<
  "X      X",
  "X  XXXXX",
  "X  XXXXX",
  "X    XXX",
  "X  XXXXX",
  "X  XXXXX",
  "X      X",
  "XXXXXXXX",

  // Shifted $c6 (198) >F<
  "X      X",
  "X  XXXXX",
  "X  XXXXX",
  "X    XXX",
  "X  XXXXX",
  "X  XXXXX",
  "X  XXXXX",
  "XXXXXXXX",

  // Shifted $c7 (199) >G<
  "XX    XX",
  "X  XX  X",
  "X  XXXXX",
  "X  X   X",
  "X  XX  X",
  "X  XX  X",
  "XX    XX",
  "XXXXXXXX",

  // Shifted $c8 (200) >H<
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "X      X",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "XXXXXXXX",

  // Shifted $c9 (201) >I<
  "XX    XX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XX    XX",
  "XXXXXXXX",

  // Shifted $ca (202) >J<
  "XXX    X",
  "XXXX  XX",
  "XXXX  XX",
  "XXXX  XX",
  "XXXX  XX",
  "X  X  XX",
  "XX   XXX",
  "XXXXXXXX",

  // Shifted $cb (203) >K<
  "X  XX  X",
  "X  X  XX",
  "X    XXX",
  "X   XXXX",
  "X    XXX",
  "X  X  XX",
  "X  XX  X",
  "XXXXXXXX",

  // Shifted $cc (204) >L<
  "X  XXXXX",
  "X  XXXXX",
  "X  XXXXX",
  "X  XXXXX",
  "X  XXXXX",
  "X  XXXXX",
  "X      X",
  "XXXXXXXX",

  // Shifted $cd (205) >M<
  "X  XXX  ",
  "X   X   ",
  "X       ",
  "X  X X  ",
  "X  XXX  ",
  "X  XXX  ",
  "X  XXX  ",
  "XXXXXXXX",

  // Shifted $ce (206) >N<
  "X  XX  X",
  "X   X  X",
  "X      X",
  "X      X",
  "X  X   X",
  "X  XX  X",
  "X  XX  X",
  "XXXXXXXX",

  // Shifted $cf (207) >O<
  "XX    XX",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "XX    XX",
  "XXXXXXXX",

  // Shifted $d0 (208) >P<
  "X     XX",
  "X  XX  X",
  "X  XX  X",
  "X     XX",
  "X  XXXXX",
  "X  XXXXX",
  "X  XXXXX",
  "XXXXXXXX",

  // Shifted $d1 (209) >Q<
  "XX    XX",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "XX    XX",
  "XXXX   X",
  "XXXXXXXX",

  // Shifted $d2 (210) >R<
  "X     XX",
  "X  XX  X",
  "X  XX  X",
  "X     XX",
  "X    XXX",
  "X  X  XX",
  "X  XX  X",
  "XXXXXXXX",

  // Shifted $d3 (211) >S<
  "XX    XX",
  "X  XX  X",
  "X  XXXXX",
  "XX    XX",
  "XXXXX  X",
  "X  XX  X",
  "XX    XX",
  "XXXXXXXX",

  // Shifted $d4 (212) >T<
  "X      X",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXXXXXXX",

  // Shifted $d5 (213) >U<
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "XX    XX",
  "XXXXXXXX",

  // Shifted $d6 (214) >V<
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "XX    XX",
  "XXX  XXX",
  "XXXXXXXX",

  // Shifted $d7 (215) >W<
  "X  XXX  ",
  "X  XXX  ",
  "X  XXX  ",
  "X  X X  ",
  "X       ",
  "X   X   ",
  "X  XXX  ",
  "XXXXXXXX",

  // Shifted $d8 (216) >X<
  "X  XX  X",
  "X  XX  X",
  "XX    XX",
  "XXX  XXX",
  "XX    XX",
  "X  XX  X",
  "X  XX  X",
  "XXXXXXXX",

  // Shifted $d9 (217) >Y<
  "X  XX  X",
  "X  XX  X",
  "X  XX  X",
  "XX    XX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXXXXXXX",

  // Shifted $da (218) >Z<
  "X      X",
  "XXXXX  X",
  "XXXX  XX",
  "XXX  XXX",
  "XX  XXXX",
  "X  XXXXX",
  "X      X",
  "XXXXXXXX",

  // Shifted $db (219) >┼<
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "        ",
  "        ",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",

  // Shifted $dc (220) >▒<
  "  XXXXXX",
  "  XXXXXX",
  "XX  XXXX",
  "XX  XXXX",
  "  XXXXXX",
  "  XXXXXX",
  "XX  XXXX",
  "XX  XXXX",

  // Shifted $dd (221) >│<
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",

  // Shifted $de (222) >▒<
  "XX  XX  ",
  "XX  XX  ",
  "  XX  XX",
  "  XX  XX",
  "XX  XX  ",
  "XX  XX  ",
  "  XX  XX",
  "  XX  XX",

  // Shifted $df (223) >▒<
  "XX  XX  ",
  " XX  XX ",
  "  XX  XX",
  "X  XX  X",
  "XX  XX  ",
  " XX  XX ",
  "  XX  XX",
  "X  XX  X",

  // Shifted $e0 (224) > <
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Shifted $e1 (225) >▌<
  "    XXXX",
  "    XXXX",
  "    XXXX",
  "    XXXX",
  "    XXXX",
  "    XXXX",
  "    XXXX",
  "    XXXX",

  // Shifted $e2 (226) >▄<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "        ",
  "        ",
  "        ",
  "        ",

  // Shifted $e3 (227) >▔<
  "        ",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Shifted $e4 (228) >▁<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "        ",

  // Shifted $e5 (229) >▎<
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",

  // Shifted $e6 (230) >▒<
  "  XX  XX",
  "  XX  XX",
  "XX  XX  ",
  "XX  XX  ",
  "  XX  XX",
  "  XX  XX",
  "XX  XX  ",
  "XX  XX  ",

  // Shifted $e7 (231) >▕<
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",

  // Shifted $e8 (232) >▒<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "  XX  XX",
  "  XX  XX",
  "XX  XX  ",
  "XX  XX  ",

  // Shifted $e9 (233) >▒<
  "  XX  XX",
  " XX  XX ",
  "XX  XX  ",
  "X  XX  X",
  "  XX  XX",
  " XX  XX ",
  "XX  XX  ",
  "X  XX  X",

  // Shifted $ea (234) >▕<
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",
  "XXXXXX  ",

  // Shifted $eb (235) >├<
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX     ",
  "XXX     ",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",

  // Shifted $ec (236) >▗<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",

  // Shifted $ed (237) >└<
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX     ",
  "XXX     ",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Shifted $ee (238) >┐<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "     XXX",
  "     XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",

  // Shifted $ef (239) >▂<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "        ",
  "        ",

  // Shifted $f0 (240) >┌<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXX     ",
  "XXX     ",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",

  // Shifted $f1 (241) >┴<
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "        ",
  "        ",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Shifted $f2 (242) >┬<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "        ",
  "        ",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",

  // Shifted $f3 (243) >┤<
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "     XXX",
  "     XXX",
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",

  // Shifted $f4 (244) >▎<
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",
  "  XXXXXX",

  // Shifted $f5 (245) >▍<
  "   XXXXX",
  "   XXXXX",
  "   XXXXX",
  "   XXXXX",
  "   XXXXX",
  "   XXXXX",
  "   XXXXX",
  "   XXXXX",

  // Shifted $f6 (246) >▕<
  "XXXXX   ",
  "XXXXX   ",
  "XXXXX   ",
  "XXXXX   ",
  "XXXXX   ",
  "XXXXX   ",
  "XXXXX   ",
  "XXXXX   ",

  // Shifted $f7 (247) >▔<
  "        ",
  "        ",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Shifted $f8 (248) >▔<
  "        ",
  "        ",
  "        ",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Shifted $f9 (249) >▃<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "        ",
  "        ",
  "        ",

  // Shifted $fa (250) >✓<
  "XXXXXXX ",
  "XXXXXX  ",
  "XXXXX  X",
  "X  X  XX",
  "X    XXX",
  "X   XXXX",
  "X  XXXXX",
  "XXXXXXXX",

  // Shifted $fb (251) >▖<
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "    XXXX",
  "    XXXX",
  "    XXXX",
  "    XXXX",

  // Shifted $fc (252) >▝<
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Shifted $fd (253) >┘<
  "XXX  XXX",
  "XXX  XXX",
  "XXX  XXX",
  "     XXX",
  "     XXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Shifted $fe (254) >▘<
  "    XXXX",
  "    XXXX",
  "    XXXX",
  "    XXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",
  "XXXXXXXX",

  // Shifted $ff (255) >▚<
  "    XXXX",
  "    XXXX",
  "    XXXX",
  "    XXXX",
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",
  "XXXX    ",

].map(
  str => Array
    .from(str)
    .reduce((acc, cur) => (acc << 1) | ((cur === " ") ? 0 : 1), 0)
));


/***/ }),

/***/ "./src/target/rom/kernal.js":
/*!**********************************!*\
  !*** ./src/target/rom/kernal.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tools_assembler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/assembler */ "./src/tools/assembler.js");
/*
   Kernal ($e000 – $ffff)

   The source below assembles into a bytestream fully compatible with the C64's
   Kernal ROM. It's adapted from Michael Steil's adaptation(†1) of Lee Davison's
   investigation into the original firmware. All comments below are Lee's.

   The labels are informed by Project64's collection of memory maps(†2) and
   those used in Mapping The Commodore 64(†3). Where sources disagree on names/
   locations, I've based my choices on which had the most consensus and which
   best corresponds to the instructions or data to which they relate.

   †1 https://github.com/mist64/c64disasm
   †2 https://github.com/Project-64/reloaded/blob/master/c64/64MAP11.TXT
   †3 https://github.com/Project-64/reloaded/blob/master/c64/mapc64/MAPC6412.TXT

   If you want to substitute your own ROM, just export a byte array instead:
       export default [ 0x.., ... ];

   Unlike the rest of the Viciious project, which was authored from scratch and
   entered into the public domain, the source below is derived from works by
   multiple other authors and I make no representations as to its ownership or
   terms of use.
*/



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_tools_assembler__WEBPACK_IMPORTED_MODULE_0__.assemble)(
  0xe000,
  ({
    NOP, LDA, LDX, LDY, STA, STX, STY, CLC, CLD, CLI, CLV, SEC, SED, SEI,
    TAX, TAY, TSX, TXA, TXS, TYA, CMP, CPX, CPY, BCS, BCC, BEQ, BNE, BMI,
    BPL, BVS, BVC, BIT, JSR, RTS, RTI, BRK, JMP, INC, DEC, DEX, DEY, INX,
    INY, ADC, SBC, AND, EOR, ORA, ASL, ROL, LSR, ROR, PHA, PHP, PLA, PLP,
    _
  }) => {
            // External labels (RAM)
            _.label(0x0002, "_0002");
            _.label(0x0003, "adray1+0_0003");
            _.label(0x0004, "adray1+1_0004");
            _.label(0x0005, "adray2+0_0005");
            _.label(0x0006, "adray2+1_0006");
            _.label(0x0007, "charac_0007");
            _.label(0x000a, "verck_000a");
            _.label(0x0012, "tansgn_0012");
            _.label(0x0013, "channl_0013");
            _.label(0x0014, "linnum+0_0014");
            _.label(0x0016, "temppt_0016");
            _.label(0x0018, "lastpt+1_0018");
            _.label(0x0022, "index+0_0022");
            _.label(0x0023, "index+1_0023");
            _.label(0x002b, "txttab+0_002b");
            _.label(0x002c, "txttab+1_002c");
            _.label(0x002d, "vartab+0_002d");
            _.label(0x002e, "vartab+1_002e");
            _.label(0x0033, "fretop+0_0033");
            _.label(0x0034, "fretop+1_0034");
            _.label(0x0037, "memsiz+0_0037");
            _.label(0x0038, "memsiz+1_0038");
            _.label(0x0049, "forpnt+0_0049");
            _.label(0x004a, "forpnt+1_004a");
            _.label(0x0053, "four6_0053");
            _.label(0x0054, "jmper+0_0054");
            _.label(0x0056, "jmper+2_0056");
            _.label(0x0061, "facexp_0061");
            _.label(0x0062, "facho+0_0062");
            _.label(0x0063, "facho+1_0063");
            _.label(0x0064, "facho+2_0064");
            _.label(0x0065, "facho+3_0065");
            _.label(0x0066, "facsgn_0066");
            _.label(0x0067, "sgnflg_0067");
            _.label(0x0068, "bits_0068");
            _.label(0x006e, "argsgn_006e");
            _.label(0x006f, "arisgn_006f");
            _.label(0x0070, "facov_0070");
            _.label(0x0071, "fbufpt+0_0071");
            _.label(0x0072, "fbufpt+1_0072");
            _.label(0x0079, "chrgot_0079");
            _.label(0x007a, "txtptr+0_007a");
            _.label(0x007b, "txtptr+1_007b");
            _.label(0x0090, "status_0090");
            _.label(0x0091, "stkey_0091");
            _.label(0x0092, "svxt_0092");
            _.label(0x0093, "verck_0093");
            _.label(0x0094, "c3po_0094");
            _.label(0x0095, "bsour_0095");
            _.label(0x0096, "syno_0096");
            _.label(0x0097, "xsav_0097");
            _.label(0x0098, "ldtnd_0098");
            _.label(0x0099, "dfltn_0099");
            _.label(0x009a, "dflto_009a");
            _.label(0x009b, "prty_009b");
            _.label(0x009c, "dpsw_009c");
            _.label(0x009d, "msgflg_009d");
            _.label(0x009e, "ptr1_009e");
            _.label(0x009f, "ptr2_009f");
            _.label(0x00a0, "time+0_00a0");
            _.label(0x00a1, "time+1_00a1");
            _.label(0x00a2, "time+2_00a2");
            _.label(0x00a3, "tsfcnt_00a3");
            _.label(0x00a4, "tbtcnt_00a4");
            _.label(0x00a5, "cntdn_00a5");
            _.label(0x00a6, "bufpnt_00a6");
            _.label(0x00a7, "inbit_00a7");
            _.label(0x00a8, "bitci_00a8");
            _.label(0x00a9, "rinone_00a9");
            _.label(0x00aa, "ridata_00aa");
            _.label(0x00ab, "riprty_00ab");
            _.label(0x00ac, "sal+0_00ac");
            _.label(0x00ad, "sal+1_00ad");
            _.label(0x00ae, "eal+0_00ae");
            _.label(0x00af, "eal+1_00af");
            _.label(0x00b0, "cmp0+0_00b0");
            _.label(0x00b1, "cmp0+1_00b1");
            _.label(0x00b2, "tape1+0_00b2");
            _.label(0x00b3, "tape1+1_00b3");
            _.label(0x00b4, "bitts_00b4");
            _.label(0x00b5, "nxtbit_00b5");
            _.label(0x00b6, "rodata_00b6");
            _.label(0x00b7, "fnlen_00b7");
            _.label(0x00b8, "la_00b8");
            _.label(0x00b9, "sa_00b9");
            _.label(0x00ba, "fa_00ba");
            _.label(0x00bb, "fnadr+0_00bb");
            _.label(0x00bc, "fnadr+1_00bc");
            _.label(0x00bd, "roprty_00bd");
            _.label(0x00be, "fsblk_00be");
            _.label(0x00bf, "mych_00bf");
            _.label(0x00c0, "cas1_00c0");
            _.label(0x00c1, "stal+0_00c1");
            _.label(0x00c2, "stal+1_00c2");
            _.label(0x00c3, "memuss+0_00c3");
            _.label(0x00c4, "memuss+1_00c4");
            _.label(0x00c5, "lstx_00c5");
            _.label(0x00c6, "ndx_00c6");
            _.label(0x00c7, "rvs_00c7");
            _.label(0x00c8, "indx_00c8");
            _.label(0x00c9, "lxsp+0_00c9");
            _.label(0x00ca, "lxsp+1_00ca");
            _.label(0x00cb, "sfdx_00cb");
            _.label(0x00cc, "blnsw_00cc");
            _.label(0x00cd, "blnct_00cd");
            _.label(0x00ce, "gdbln_00ce");
            _.label(0x00cf, "blnon_00cf");
            _.label(0x00d0, "crsw_00d0");
            _.label(0x00d1, "pnt+0_00d1");
            _.label(0x00d2, "pnt+1_00d2");
            _.label(0x00d3, "pntr_00d3");
            _.label(0x00d4, "qtsw_00d4");
            _.label(0x00d5, "lnmx_00d5");
            _.label(0x00d6, "tblx_00d6");
            _.label(0x00d7, "schar_00d7");
            _.label(0x00d8, "insrt_00d8");
            _.label(0x00d9, "ldtb1+0_00d9");
            _.label(0x00f1, "ldtb1+24_00f1");
            _.label(0x00f3, "user+0_00f3");
            _.label(0x00f4, "user+1_00f4");
            _.label(0x00f5, "keytab+0_00f5");
            _.label(0x00f6, "keytab+1_00f6");
            _.label(0x00f7, "ribuf+0_00f7");
            _.label(0x00f8, "ribuf+1_00f8");
            _.label(0x00f9, "robuf+0_00f9");
            _.label(0x00fa, "robuf+1_00fa");
            _.label(0x0100, "bad+0_0100");
            _.label(0x0101, "bad+1_0101");
            _.label(0x0104, "bad+4_0104");
            _.label(0x01fc, "bstack+189_01fc");
            _.label(0x01fd, "bstack+190_01fd");
            _.label(0x0200, "buf+0_0200");
            _.label(0x0259, "lat+0_0259");
            _.label(0x0263, "fat+0_0263");
            _.label(0x026d, "sat+0_026d");
            _.label(0x0276, "sat+9_0276");
            _.label(0x0277, "keyd+0_0277");
            _.label(0x0278, "keyd+1_0278");
            _.label(0x0281, "memstr+0_0281");
            _.label(0x0282, "memstr+1_0282");
            _.label(0x0283, "memsiz+0_0283");
            _.label(0x0284, "memsiz+1_0284");
            _.label(0x0285, "timout_0285");
            _.label(0x0286, "color_0286");
            _.label(0x0287, "gdcol_0287");
            _.label(0x0288, "hibase_0288");
            _.label(0x0289, "xmax_0289");
            _.label(0x028a, "rptflg_028a");
            _.label(0x028b, "kount_028b");
            _.label(0x028c, "delay_028c");
            _.label(0x028d, "shflag_028d");
            _.label(0x028e, "lstshf_028e");
            _.label(0x028f, "keylog+0_028f");
            _.label(0x0290, "keylog+1_0290");
            _.label(0x0291, "mode_0291");
            _.label(0x0292, "autodn_0292");
            _.label(0x0293, "m51ctr_0293");
            _.label(0x0294, "m51cdr_0294");
            _.label(0x0295, "m51ajb+0_0295");
            _.label(0x0296, "m51ajb+1_0296");
            _.label(0x0297, "rsstat_0297");
            _.label(0x0298, "bitnum_0298");
            _.label(0x0299, "baudof+0_0299");
            _.label(0x029a, "baudof+1_029a");
            _.label(0x029b, "ridbe_029b");
            _.label(0x029c, "ridbs_029c");
            _.label(0x029d, "rodbs_029d");
            _.label(0x029e, "rodbe_029e");
            _.label(0x029f, "irqtmp+0_029f");
            _.label(0x02a0, "irqtmp+1_02a0");
            _.label(0x02a1, "enabl_02a1");
            _.label(0x02a2, "todsns_02a2");
            _.label(0x02a3, "trdtmp_02a3");
            _.label(0x02a4, "td1irq_02a4");
            _.label(0x02a5, "tlnidx_02a5");
            _.label(0x02a6, "tvsflg_02a6");
            _.label(0x0300, "ierror+0_0300");
            _.label(0x030c, "sareg_030c");
            _.label(0x030d, "sxreg_030d");
            _.label(0x030e, "syreg_030e");
            _.label(0x030f, "spreg_030f");
            _.label(0x0310, "usrpok_0310");
            _.label(0x0311, "usradd+0_0311");
            _.label(0x0312, "usradd+1_0312");
            _.label(0x0314, "cinv+0_0314");
            _.label(0x0315, "cinv+1_0315");
            _.label(0x0316, "cbinv+0_0316");
            _.label(0x0318, "nminv+0_0318");
            _.label(0x031a, "iopen+0_031a");
            _.label(0x031c, "iclose+0_031c");
            _.label(0x031e, "ichkin+0_031e");
            _.label(0x0320, "ickout+0_0320");
            _.label(0x0322, "iclrch+0_0322");
            _.label(0x0324, "ibasin+0_0324");
            _.label(0x0326, "ibsout+0_0326");
            _.label(0x0328, "istop+0_0328");
            _.label(0x032a, "igetin+0_032a");
            _.label(0x032c, "iclall+0_032c");
            _.label(0x0330, "iload+0_0330");
            _.label(0x0332, "isave+0_0332");
            _.label(0x8000, "_8000");
            _.label(0x8002, "_8002");
            _.label(0x8003, "_8003");
            _.label(0xcfff, "_cfff");

            // External labels (Memory-mapped IO)
            _.label(0x0000, "d6510_0000");
            _.label(0x0001, "r6510_0001");
            _.label(0xd011, "scroly_d011");
            _.label(0xd012, "raster_d012");
            _.label(0xd016, "scrolx_d016");
            _.label(0xd018, "vmcsb_d018");
            _.label(0xd019, "vicirq_d019");
            _.label(0xd418, "sigvol_d418");
            _.label(0xdc00, "ciapra_dc00");
            _.label(0xdc01, "ciaprb_dc01");
            _.label(0xdc02, "ciddra_dc02");
            _.label(0xdc03, "ciddrb_dc03");
            _.label(0xdc04, "timalo_dc04");
            _.label(0xdc05, "timahi_dc05");
            _.label(0xdc06, "timblo_dc06");
            _.label(0xdc07, "timbhi_dc07");
            _.label(0xdc0d, "ciaicr_dc0d");
            _.label(0xdc0e, "ciacra_dc0e");
            _.label(0xdc0f, "ciacrb_dc0f");
            _.label(0xdd00, "ci2pra_dd00");
            _.label(0xdd01, "ci2prb_dd01");
            _.label(0xdd02, "c2ddra_dd02");
            _.label(0xdd03, "c2ddrb_dd03");
            _.label(0xdd04, "ti2alo_dd04");
            _.label(0xdd05, "ti2ahi_dd05");
            _.label(0xdd06, "ti2blo_dd06");
            _.label(0xdd07, "ti2bhi_dd07");
            _.label(0xdd0d, "ci2icr_dd0d");
            _.label(0xdd0e, "ci2cra_dd0e");
            _.label(0xdd0f, "ci2crb_dd0f");

            // External labels (Basic ROM)
            _.label(0xa000, "restart_a000");
            _.label(0xa002, "_a002");
            _.label(0xa408, "reason_a408");
            _.label(0xa437, "error_a437");
            _.label(0xa43a, "_a43a");
            _.label(0xa474, "ready_a474");
            _.label(0xa52a, "_a52a");
            _.label(0xa533, "linkprg_a533");
            _.label(0xa644, "_a644");
            _.label(0xa663, "_a663");
            _.label(0xa677, "_a677");
            _.label(0xa67a, "_a67a");
            _.label(0xa68e, "stxpt_a68e");
            _.label(0xab1e, "strout_ab1e");
            _.label(0xad8a, "frmnum_ad8a");
            _.label(0xad9e, "frmevl_ad9e");
            _.label(0xaefd, "_aefd");
            _.label(0xaf08, "synerr_af08");
            _.label(0xb6a3, "frestr_b6a3");
            _.label(0xb79e, "_b79e");
            _.label(0xb7f7, "getadr_b7f7");
            _.label(0xb849, "faddh_b849");
            _.label(0xb850, "fsub_b850");
            _.label(0xb853, "fsubt_b853");
            _.label(0xb867, "fadd_b867");
            _.label(0xb8d7, "_b8d7");
            _.label(0xba28, "fmult_ba28");
            _.label(0xbab9, "_bab9");
            _.label(0xbad4, "mldvex_bad4");
            _.label(0xbb07, "fdivf_bb07");
            _.label(0xbb0f, "fdiv_bb0f");
            _.label(0xbba2, "movfm_bba2");
            _.label(0xbbc7, "mov2f_bbc7");
            _.label(0xbbca, "_bbca");
            _.label(0xbbd4, "_bbd4");
            _.label(0xbc0c, "movaf_bc0c");
            _.label(0xbc0f, "movef_bc0f");
            _.label(0xbc2b, "sign_bc2b");
            _.label(0xbccc, "int_bccc");
            _.label(0xbdcd, "linprt_bdcd");
            _.label(0xbfb4, "negop_bfb4");

// ---------------------------------------------------------- start of the kernal ROM
                                                           // EXP() continued
/* e000 */    _`(exp_e000`;  STA.zpg ("jmper+2_0056");     // save FAC2 rounding byte
/* e002 */                   JSR.abs ("movef_bc0f");       // copy FAC1 to FAC2
/* e005 */                   LDA.zpg ("facexp_0061");      // get FAC1 exponent
/* e007 */                   CMP.imm (0x88);               // compare with EXP limit (256d)
/* e009 */                   BCC.rel ("_e00e");            // branch if less
/* e00b */        _`_e00b`;  JSR.abs ("mldvex_bad4");      // handle overflow and underflow
/* e00e */        _`_e00e`;  JSR.abs ("int_bccc");         // perform INT()
/* e011 */                   LDA.zpg ("charac_0007");      // get mantissa 4 from INT()
/* e013 */                   CLC.imp ();                   // clear carry for add
/* e014 */                   ADC.imm (0x81);               // normalise +1
/* e016 */                   BEQ.rel ("_e00b");            // if $00 result has overflowed so go handle it
/* e018 */                   SEC.imp ();                   // set carry for subtract
/* e019 */                   SBC.imm (0x01);               // exponent now correct
/* e01b */                   PHA.imp ();                   // save FAC2 exponent
                                                           // swap FAC1 and FAC2
/* e01c */                   LDX.imm (0x05);               // 4 bytes to do
/* e01e */        _`_e01e`;  LDA.zpx (0x69);               // get FAC2,X
/* e020 */                   LDY.zpx (0x61);               // get FAC1,X
/* e022 */                   STA.zpx (0x61);               // save FAC1,X
/* e024 */                   STY.zpx (0x69);               // save FAC2,X
/* e026 */                   DEX.imp ();                   // decrement count/index
/* e027 */                   BPL.rel ("_e01e");            // loop if not all done
/* e029 */                   LDA.zpg ("jmper+2_0056");     // get FAC2 rounding byte
/* e02b */                   STA.zpg ("facov_0070");       // save as FAC1 rounding byte
/* e02d */                   JSR.abs ("fsubt_b853");       // perform subtraction, FAC2 from FAC1
/* e030 */                   JSR.abs ("negop_bfb4");       // do - FAC1
/* e033 */                   LDA.imm (0xc4);               // set counter pointer low byte
/* e035 */                   LDY.imm (0xbf);               // set counter pointer high byte
/* e037 */                   JSR.abs ("poly2_e059");       // go do series evaluation
/* e03a */                   LDA.imm (0x00);               // clear A
/* e03c */                   STA.zpg ("arisgn_006f");      // clear sign compare (FAC1 EOR FAC2)
/* e03e */                   PLA.imp ();                   // get saved FAC2 exponent
/* e03f */                   JSR.abs ("_bab9");            // test and adjust accumulators
/* e042 */                   RTS.imp ();
                                                           // ^2 then series evaluation
/* e043 */   _`polyx_e043`;  STA.zpg ("fbufpt+0_0071");    // save count pointer low byte
/* e045 */                   STY.zpg ("fbufpt+1_0072");    // save count pointer high byte
/* e047 */                   JSR.abs ("_bbca");            // pack FAC1 into $57
/* e04a */                   LDA.imm (0x57);               // set pointer low byte (Y already $00)
/* e04c */                   JSR.abs ("fmult_ba28");       // do convert AY, FCA1*(AY)
/* e04f */                   JSR.abs ("_e05d");            // go do series evaluation
/* e052 */                   LDA.imm (0x57);               // pointer to original # low byte
/* e054 */                   LDY.imm (0x00);               // pointer to original # high byte
/* e056 */                   JMP.abs ("fmult_ba28");       // do convert AY, FCA1*(AY)
                                                           // do series evaluation
/* e059 */   _`poly2_e059`;  STA.zpg ("fbufpt+0_0071");    // save count pointer low byte
/* e05b */                   STY.zpg ("fbufpt+1_0072");    // save count pointer high byte
                                                           // do series evaluation
/* e05d */        _`_e05d`;  JSR.abs ("mov2f_bbc7");       // pack FAC1 into $5C
/* e060 */                   LDA.iny ("fbufpt+0_0071");    // get constants count
/* e062 */                   STA.zpg ("sgnflg_0067");      // save constants count
/* e064 */                   LDY.zpg ("fbufpt+0_0071");    // get count pointer low byte
/* e066 */                   INY.imp ();                   // increment it (now constants pointer)
/* e067 */                   TYA.imp ();                   // copy it
/* e068 */                   BNE.rel ("_e06c");            // skip next if no overflow
/* e06a */                   INC.zpg ("fbufpt+1_0072");    // else increment high byte
/* e06c */        _`_e06c`;  STA.zpg ("fbufpt+0_0071");    // save low byte
/* e06e */                   LDY.zpg ("fbufpt+1_0072");    // get high byte
/* e070 */        _`_e070`;  JSR.abs ("fmult_ba28");       // do convert AY, FCA1*(AY)
/* e073 */                   LDA.zpg ("fbufpt+0_0071");    // get constants pointer low byte
/* e075 */                   LDY.zpg ("fbufpt+1_0072");    // get constants pointer high byte
/* e077 */                   CLC.imp ();                   // clear carry for add
/* e078 */                   ADC.imm (0x05);               // +5 to low pointer (5 bytes per constant)
/* e07a */                   BCC.rel ("_e07d");            // skip next if no overflow
/* e07c */                   INY.imp ();                   // increment high byte
/* e07d */        _`_e07d`;  STA.zpg ("fbufpt+0_0071");    // save pointer low byte
/* e07f */                   STY.zpg ("fbufpt+1_0072");    // save pointer high byte
/* e081 */                   JSR.abs ("fadd_b867");        // add (AY) to FAC1
/* e084 */                   LDA.imm (0x5c);               // set pointer low byte to partial
/* e086 */                   LDY.imm (0x00);               // set pointer high byte to partial
/* e088 */                   DEC.zpg ("sgnflg_0067");      // decrement constants count
/* e08a */                   BNE.rel ("_e070");            // loop until all done
/* e08c */                   RTS.imp ();

// ------------------------------------------------------- // RND values
                                                           // 11879546            multiplier
/* e08d */   _`rmulc_e08d`;  _.bytes(0x98, 0x35, 0x44, 0x7a, 0x00);
                                                           // 3.927677739E-8      offset
/* e092 */   _`raddc_e092`;  _.bytes(0x68, 0x28, 0xb1, 0x46, 0x00);

// ------------------------------------------------------- // perform RND()
/* e097 */     _`rnd_e097`;  JSR.abs ("sign_bc2b");        // get FAC1 sign
                                                           // return A = $FF -ve, A = $01 +ve
/* e09a */                   BMI.rel ("_e0d3");            // if n<0 copy byte swapped FAC1 into RND() seed
/* e09c */                   BNE.rel ("_e0be");            // if n>0 get next number in RND() sequence
                                                           // else n=0 so get the RND() number from VIA 1 timers
/* e09e */                   JSR.abs ("iobase_fff3");      // return base address of I/O devices
/* e0a1 */                   STX.zpg ("index+0_0022");     // save pointer low byte
/* e0a3 */                   STY.zpg ("index+1_0023");     // save pointer high byte
/* e0a5 */                   LDY.imm (0x04);               // set index to T1 low byte
/* e0a7 */                   LDA.iny ("index+0_0022");     // get T1 low byte
/* e0a9 */                   STA.zpg ("facho+0_0062");     // save FAC1 mantissa 1
/* e0ab */                   INY.imp ();                   // increment index
/* e0ac */                   LDA.iny ("index+0_0022");     // get T1 high byte
/* e0ae */                   STA.zpg ("facho+2_0064");     // save FAC1 mantissa 3
/* e0b0 */                   LDY.imm (0x08);               // set index to T2 low byte
/* e0b2 */                   LDA.iny ("index+0_0022");     // get T2 low byte
/* e0b4 */                   STA.zpg ("facho+1_0063");     // save FAC1 mantissa 2
/* e0b6 */                   INY.imp ();                   // increment index
/* e0b7 */                   LDA.iny ("index+0_0022");     // get T2 high byte
/* e0b9 */                   STA.zpg ("facho+3_0065");     // save FAC1 mantissa 4
/* e0bb */                   JMP.abs ("_e0e3");            // set exponent and exit
/* e0be */        _`_e0be`;  LDA.imm (0x8b);               // set seed pointer low address
/* e0c0 */                   LDY.imm (0x00);               // set seed pointer high address
/* e0c2 */                   JSR.abs ("movfm_bba2");       // unpack memory (AY) into FAC1
/* e0c5 */                   LDA.imm (0x8d);               // set 11879546 pointer low byte
/* e0c7 */                   LDY.imm (0xe0);               // set 11879546 pointer high byte
/* e0c9 */                   JSR.abs ("fmult_ba28");       // do convert AY, FCA1*(AY)
/* e0cc */                   LDA.imm (0x92);               // set 3.927677739E-8 pointer low byte
/* e0ce */                   LDY.imm (0xe0);               // set 3.927677739E-8 pointer high byte
/* e0d0 */                   JSR.abs ("fadd_b867");        // add (AY) to FAC1
/* e0d3 */        _`_e0d3`;  LDX.zpg ("facho+3_0065");     // get FAC1 mantissa 4
/* e0d5 */                   LDA.zpg ("facho+0_0062");     // get FAC1 mantissa 1
/* e0d7 */                   STA.zpg ("facho+3_0065");     // save FAC1 mantissa 4
/* e0d9 */                   STX.zpg ("facho+0_0062");     // save FAC1 mantissa 1
/* e0db */                   LDX.zpg ("facho+1_0063");     // get FAC1 mantissa 2
/* e0dd */                   LDA.zpg ("facho+2_0064");     // get FAC1 mantissa 3
/* e0df */                   STA.zpg ("facho+1_0063");     // save FAC1 mantissa 2
/* e0e1 */                   STX.zpg ("facho+2_0064");     // save FAC1 mantissa 3
/* e0e3 */        _`_e0e3`;  LDA.imm (0x00);               // clear byte
/* e0e5 */                   STA.zpg ("facsgn_0066");      // clear FAC1 sign (always +ve)
/* e0e7 */                   LDA.zpg ("facexp_0061");      // get FAC1 exponent
/* e0e9 */                   STA.zpg ("facov_0070");       // save FAC1 rounding byte
/* e0eb */                   LDA.imm (0x80);               // set exponent = $80
/* e0ed */                   STA.zpg ("facexp_0061");      // save FAC1 exponent
/* e0ef */                   JSR.abs ("_b8d7");            // normalise FAC1
/* e0f2 */                   LDX.imm (0x8b);               // set seed pointer low address
/* e0f4 */                   LDY.imm (0x00);               // set seed pointer high address

// ------------------------------------------------------- // pack FAC1 into (XY)
/* e0f6 */        _`_e0f6`;  JMP.abs ("_bbd4");            // pack FAC1 into (XY)

// ------------------------------------------------------- // handle BASIC I/O error
/* e0f9 */  _`bioerr_e0f9`;  CMP.imm (0xf0);               // compare error with $F0
/* e0fb */                   BNE.rel ("_e104");            // branch if not $F0
/* e0fd */                   STY.zpg ("memsiz+1_0038");    // set end of memory high byte
/* e0ff */                   STX.zpg ("memsiz+0_0037");    // set end of memory low byte
/* e101 */                   JMP.abs ("_a663");            // clear from start to end and return
                                                           // error was not $F0
/* e104 */        _`_e104`;  TAX.imp ();                   // copy error #
/* e105 */                   BNE.rel ("_e109");            // branch if not $00
/* e107 */                   LDX.imm (0x1e);               // else error $1E, break error
/* e109 */        _`_e109`;  JMP.abs ("error_a437");       // do error #X then warm start

// ------------------------------------------------------- // output character to channel with error check
/* e10c */  _`bchout_e10c`;  JSR.abs ("chrout_ffd2");      // output character to channel
/* e10f */                   BCS.rel ("bioerr_e0f9");      // if error go handle BASIC I/O error
/* e111 */                   RTS.imp ();

// ------------------------------------------------------- // input character from channel with error check
/* e112 */   _`bchin_e112`;  JSR.abs ("chrin_ffcf");       // input character from channel
/* e115 */                   BCS.rel ("bioerr_e0f9");      // if error go handle BASIC I/O error
/* e117 */                   RTS.imp ();

// ------------------------------------------------------- // open channel for output with error check
/* e118 */  _`bckout_e118`;  JSR.abs ("_e4ad");            // open channel for output
/* e11b */                   BCS.rel ("bioerr_e0f9");      // if error go handle BASIC I/O error
/* e11d */                   RTS.imp ();

// ------------------------------------------------------- // open channel for input with error check
/* e11e */   _`bckin_e11e`;  JSR.abs ("chkin_ffc6");       // open channel for input
/* e121 */                   BCS.rel ("bioerr_e0f9");      // if error go handle BASIC I/O error
/* e123 */                   RTS.imp ();

// ------------------------------------------------------- // get character from input device with error check
/* e124 */  _`bgetin_e124`;  JSR.abs ("getin_ffe4");       // get character from input device
/* e127 */                   BCS.rel ("bioerr_e0f9");      // if error go handle BASIC I/O error
/* e129 */                   RTS.imp ();

// ------------------------------------------------------- // perform SYS
/* e12a */     _`sys_e12a`;  JSR.abs ("frmnum_ad8a");      // evaluate expression and check is numeric, else do
                                                           // type mismatch
/* e12d */                   JSR.abs ("getadr_b7f7");      // convert FAC_1 to integer in temporary integer
/* e130 */                   LDA.imm (0xe1);               // get return address high byte
/* e132 */                   PHA.imp ();                   // push as return address
/* e133 */                   LDA.imm (0x46);               // get return address low byte
/* e135 */                   PHA.imp ();                   // push as return address
/* e136 */                   LDA.abs ("spreg_030f");       // get saved status register
/* e139 */                   PHA.imp ();                   // put on stack
/* e13a */                   LDA.abs ("sareg_030c");       // get saved A
/* e13d */                   LDX.abs ("sxreg_030d");       // get saved X
/* e140 */                   LDY.abs ("syreg_030e");       // get saved Y
/* e143 */                   PLP.imp ();                   // pull processor status
/* e144 */                   JMP.ind ("linnum+0_0014");    // call SYS address
                                                           // tail end of SYS code
/* e147 */                   PHP.imp ();                   // save status
/* e148 */                   STA.abs ("sareg_030c");       // save returned A
/* e14b */                   STX.abs ("sxreg_030d");       // save returned X
/* e14e */                   STY.abs ("syreg_030e");       // save returned Y
/* e151 */                   PLA.imp ();                   // restore saved status
/* e152 */                   STA.abs ("spreg_030f");       // save status
/* e155 */                   RTS.imp ();

// ------------------------------------------------------- // perform SAVE
/* e156 */   _`savet_e156`;  JSR.abs ("slpara_e1d4");      // get parameters for LOAD/SAVE
/* e159 */                   LDX.zpg ("vartab+0_002d");    // get start of variables low byte
/* e15b */                   LDY.zpg ("vartab+1_002e");    // get start of variables high byte
/* e15d */                   LDA.imm (0x2b);               // index to start of program memory
/* e15f */                   JSR.abs ("save_ffd8");        // save RAM to device, A = index to start address, XY = end
                                                           // address low/high
/* e162 */                   BCS.rel ("bioerr_e0f9");      // if error go handle BASIC I/O error
/* e164 */                   RTS.imp ();

// ------------------------------------------------------- // perform VERIFY
/* e165 */  _`verfyt_e165`;  LDA.imm (0x01);               // flag verify
/* e167 */                   _.bytes(0x2c);                // makes next line BIT $00A9

// ------------------------------------------------------- // perform LOAD
/* e168 */                   LDA.imm (0x00);               // flag load
/* e16a */                   STA.zpg ("verck_000a");       // set load/verify flag
/* e16c */                   JSR.abs ("slpara_e1d4");      // get parameters for LOAD/SAVE
/* e16f */                   LDA.zpg ("verck_000a");       // get load/verify flag
/* e171 */                   LDX.zpg ("txttab+0_002b");    // get start of memory low byte
/* e173 */                   LDY.zpg ("txttab+1_002c");    // get start of memory high byte
/* e175 */                   JSR.abs ("load_ffd5");        // load RAM from a device
/* e178 */                   BCS.rel ("_e1d1");            // if error go handle BASIC I/O error
/* e17a */                   LDA.zpg ("verck_000a");       // get load/verify flag
/* e17c */                   BEQ.rel ("_e195");            // branch if load
/* e17e */                   LDX.imm (0x1c);               // error $1C, verify error
/* e180 */                   JSR.abs ("readst_ffb7");      // read I/O status word
/* e183 */                   AND.imm (0x10);               // mask for tape read error
/* e185 */                   BNE.rel ("_e19e");            // branch if no read error
/* e187 */                   LDA.zpg ("txtptr+0_007a");    // get the BASIC execute pointer low byte
                                                           // is this correct ?? won't this mean the "OK" prompt
                                                           // when doing a load from within a program ?
/* e189 */                   CMP.imm (0x02);
/* e18b */                   BEQ.rel ("_e194");            // if ?? skip "OK" prompt
/* e18d */                   LDA.imm (0x64);               // set "OK" pointer low byte
/* e18f */                   LDY.imm (0xa3);               // set "OK" pointer high byte
/* e191 */                   JMP.abs ("strout_ab1e");      // print null terminated string
/* e194 */        _`_e194`;  RTS.imp ();

// ------------------------------------------------------- // do READY return to BASIC
/* e195 */        _`_e195`;  JSR.abs ("readst_ffb7");      // read I/O status word
/* e198 */                   AND.imm (0xbf);               // mask x0xx xxxx, clear read error
/* e19a */                   BEQ.rel ("_e1a1");            // branch if no errors
/* e19c */                   LDX.imm (0x1d);               // error $1D, load error
/* e19e */        _`_e19e`;  JMP.abs ("error_a437");       // do error #X then warm start
/* e1a1 */        _`_e1a1`;  LDA.zpg ("txtptr+1_007b");    // get BASIC execute pointer high byte
/* e1a3 */                   CMP.imm (0x02);               // compare with $02xx
/* e1a5 */                   BNE.rel ("_e1b5");            // branch if not immediate mode
/* e1a7 */                   STX.zpg ("vartab+0_002d");    // set start of variables low byte
/* e1a9 */                   STY.zpg ("vartab+1_002e");    // set start of variables high byte
/* e1ab */                   LDA.imm (0x76);               // set "READY." pointer low byte
/* e1ad */                   LDY.imm (0xa3);               // set "READY." pointer high byte
/* e1af */                   JSR.abs ("strout_ab1e");      // print null terminated string
/* e1b2 */                   JMP.abs ("_a52a");            // reset execution, clear variables, flush stack,
                                                           // rebuild BASIC chain and do warm start
/* e1b5 */        _`_e1b5`;  JSR.abs ("stxpt_a68e");       // set BASIC execute pointer to start of memory - 1
/* e1b8 */                   JSR.abs ("linkprg_a533");     // rebuild BASIC line chaining
/* e1bb */                   JMP.abs ("_a677");            // rebuild BASIC line chaining, do RESTORE and return

// ------------------------------------------------------- // perform OPEN
/* e1be */   _`opent_e1be`;  JSR.abs ("ocpara_e219");      // get parameters for OPEN/CLOSE
/* e1c1 */                   JSR.abs ("open_ffc0");        // open a logical file
/* e1c4 */                   BCS.rel ("_e1d1");            // branch if error
/* e1c6 */                   RTS.imp ();

// ------------------------------------------------------- // perform CLOSE
/* e1c7 */  _`closet_e1c7`;  JSR.abs ("ocpara_e219");      // get parameters for OPEN/CLOSE
/* e1ca */                   LDA.zpg ("forpnt+0_0049");    // get logical file number
/* e1cc */                   JSR.abs ("close_ffc3");       // close a specified logical file
/* e1cf */                   BCC.rel ("_e194");            // exit if no error
/* e1d1 */        _`_e1d1`;  JMP.abs ("bioerr_e0f9");      // go handle BASIC I/O error

// ------------------------------------------------------- // get parameters for LOAD/SAVE
/* e1d4 */  _`slpara_e1d4`;  LDA.imm (0x00);               // clear file name length
/* e1d6 */                   JSR.abs ("setnam_ffbd");      // clear the filename
/* e1d9 */                   LDX.imm (0x01);               // set default device number, cassette
/* e1db */                   LDY.imm (0x00);               // set default command
/* e1dd */                   JSR.abs ("setlfs_ffba");      // set logical, first and second addresses
/* e1e0 */                   JSR.abs ("deflt_e206");       // exit function if [EOT] or ":"
/* e1e3 */                   JSR.abs ("_e257");            // set filename
/* e1e6 */                   JSR.abs ("deflt_e206");       // exit function if [EOT] or ":"
/* e1e9 */                   JSR.abs ("combyt_e200");      // scan and get byte, else do syntax error then warm start
/* e1ec */                   LDY.imm (0x00);               // clear command
/* e1ee */                   STX.zpg ("forpnt+0_0049");    // save device number
/* e1f0 */                   JSR.abs ("setlfs_ffba");      // set logical, first and second addresses
/* e1f3 */                   JSR.abs ("deflt_e206");       // exit function if [EOT] or ":"
/* e1f6 */                   JSR.abs ("combyt_e200");      // scan and get byte, else do syntax error then warm start
/* e1f9 */                   TXA.imp ();                   // copy command to A
/* e1fa */                   TAY.imp ();                   // copy command to Y
/* e1fb */                   LDX.zpg ("forpnt+0_0049");    // get device number back
/* e1fd */                   JMP.abs ("setlfs_ffba");      // set logical, first and second addresses and return

// ------------------------------------------------------- // scan and get byte, else do syntax error then warm start
/* e200 */  _`combyt_e200`;  JSR.abs ("cmmerr_e20e");      // scan for ",byte", else do syntax error then warm start
/* e203 */                   JMP.abs ("_b79e");            // get byte parameter and return
                                                           // exit function if [EOT] or ":"
/* e206 */   _`deflt_e206`;  JSR.abs ("chrgot_0079");      // scan memory
/* e209 */                   BNE.rel ("_e20d");            // branch if not [EOL] or ":"
/* e20b */                   PLA.imp ();                   // dump return address low byte
/* e20c */                   PLA.imp ();                   // dump return address high byte
/* e20d */        _`_e20d`;  RTS.imp ();

// ------------------------------------------------------- // scan for ",valid byte", else do syntax error then warm start
/* e20e */  _`cmmerr_e20e`;  JSR.abs ("_aefd");            // scan for ",", else do syntax error then warm start

// ------------------------------------------------------- // scan for valid byte, not [EOL] or ":", else do syntax error then warm start
/* e211 */        _`_e211`;  JSR.abs ("chrgot_0079");      // scan memory
/* e214 */                   BNE.rel ("_e20d");            // exit if following byte
/* e216 */                   JMP.abs ("synerr_af08");      // else do syntax error then warm start

// ------------------------------------------------------- // get parameters for OPEN/CLOSE
/* e219 */  _`ocpara_e219`;  LDA.imm (0x00);               // clear the filename length
/* e21b */                   JSR.abs ("setnam_ffbd");      // clear the filename
/* e21e */                   JSR.abs ("_e211");            // scan for valid byte, else do syntax error then warm start
/* e221 */                   JSR.abs ("_b79e");            // get byte parameter, logical file number
/* e224 */                   STX.zpg ("forpnt+0_0049");    // save logical file number
/* e226 */                   TXA.imp ();                   // copy logical file number to A
/* e227 */                   LDX.imm (0x01);               // set default device number, cassette
/* e229 */                   LDY.imm (0x00);               // set default command
/* e22b */                   JSR.abs ("setlfs_ffba");      // set logical, first and second addresses
/* e22e */                   JSR.abs ("deflt_e206");       // exit function if [EOT] or ":"
/* e231 */                   JSR.abs ("combyt_e200");      // scan and get byte, else do syntax error then warm start
/* e234 */                   STX.zpg ("forpnt+1_004a");    // save device number
/* e236 */                   LDY.imm (0x00);               // clear command
/* e238 */                   LDA.zpg ("forpnt+0_0049");    // get logical file number
/* e23a */                   CPX.imm (0x03);               // compare device number with screen
/* e23c */                   BCC.rel ("_e23f");            // branch if less than screen
/* e23e */                   DEY.imp ();                   // else decrement command
/* e23f */        _`_e23f`;  JSR.abs ("setlfs_ffba");      // set logical, first and second addresses
/* e242 */                   JSR.abs ("deflt_e206");       // exit function if [EOT] or ":"
/* e245 */                   JSR.abs ("combyt_e200");      // scan and get byte, else do syntax error then warm start
/* e248 */                   TXA.imp ();                   // copy command to A
/* e249 */                   TAY.imp ();                   // copy command to Y
/* e24a */                   LDX.zpg ("forpnt+1_004a");    // get device number
/* e24c */                   LDA.zpg ("forpnt+0_0049");    // get logical file number
/* e24e */                   JSR.abs ("setlfs_ffba");      // set logical, first and second addresses
/* e251 */                   JSR.abs ("deflt_e206");       // exit function if [EOT] or ":"
/* e254 */                   JSR.abs ("cmmerr_e20e");      // scan for ",byte", else do syntax error then warm start

// ------------------------------------------------------- // set filename
/* e257 */        _`_e257`;  JSR.abs ("frmevl_ad9e");      // evaluate expression
/* e25a */                   JSR.abs ("frestr_b6a3");      // evaluate string
/* e25d */                   LDX.zpg ("index+0_0022");     // get string pointer low byte
/* e25f */                   LDY.zpg ("index+1_0023");     // get string pointer high byte
/* e261 */                   JMP.abs ("setnam_ffbd");      // set the filename and return

// ------------------------------------------------------- // perform COS()
/* e264 */     _`cos_e264`;  LDA.imm (0xe0);               // set pi/2 pointer low byte
/* e266 */                   LDY.imm (0xe2);               // set pi/2 pointer high byte
/* e268 */                   JSR.abs ("fadd_b867");        // add (AY) to FAC1

// ------------------------------------------------------- // perform SIN()
/* e26b */     _`sin_e26b`;  JSR.abs ("movaf_bc0c");       // round and copy FAC1 to FAC2
/* e26e */                   LDA.imm (0xe5);               // set 2*pi pointer low byte
/* e270 */                   LDY.imm (0xe2);               // set 2*pi pointer high byte
/* e272 */                   LDX.zpg ("argsgn_006e");      // get FAC2 sign (b7)
/* e274 */                   JSR.abs ("fdivf_bb07");       // divide by (AY) (X=sign)
/* e277 */                   JSR.abs ("movaf_bc0c");       // round and copy FAC1 to FAC2
/* e27a */                   JSR.abs ("int_bccc");         // perform INT()
/* e27d */                   LDA.imm (0x00);               // clear byte
/* e27f */                   STA.zpg ("arisgn_006f");      // clear sign compare (FAC1 EOR FAC2)
/* e281 */                   JSR.abs ("fsubt_b853");       // perform subtraction, FAC2 from FAC1
/* e284 */                   LDA.imm (0xea);               // set 0.25 pointer low byte
/* e286 */                   LDY.imm (0xe2);               // set 0.25 pointer high byte
/* e288 */                   JSR.abs ("fsub_b850");        // perform subtraction, FAC1 from (AY)
/* e28b */                   LDA.zpg ("facsgn_0066");      // get FAC1 sign (b7)
/* e28d */                   PHA.imp ();                   // save FAC1 sign
/* e28e */                   BPL.rel ("_e29d");            // branch if +ve
                                                           // FAC1 sign was -ve
/* e290 */                   JSR.abs ("faddh_b849");       // add 0.5 to FAC1 (round FAC1)
/* e293 */                   LDA.zpg ("facsgn_0066");      // get FAC1 sign (b7)
/* e295 */                   BMI.rel ("_e2a0");            // branch if -ve
/* e297 */                   LDA.zpg ("tansgn_0012");      // get the comparison evaluation flag
/* e299 */                   EOR.imm (0xff);               // toggle flag
/* e29b */                   STA.zpg ("tansgn_0012");      // save the comparison evaluation flag
/* e29d */        _`_e29d`;  JSR.abs ("negop_bfb4");       // do - FAC1
/* e2a0 */        _`_e2a0`;  LDA.imm (0xea);               // set 0.25 pointer low byte
/* e2a2 */                   LDY.imm (0xe2);               // set 0.25 pointer high byte
/* e2a4 */                   JSR.abs ("fadd_b867");        // add (AY) to FAC1
/* e2a7 */                   PLA.imp ();                   // restore FAC1 sign
/* e2a8 */                   BPL.rel ("_e2ad");            // branch if was +ve
                                                           // else correct FAC1
/* e2aa */                   JSR.abs ("negop_bfb4");       // do - FAC1
/* e2ad */        _`_e2ad`;  LDA.imm (0xef);               // set pointer low byte to counter
/* e2af */                   LDY.imm (0xe2);               // set pointer high byte to counter
/* e2b1 */                   JMP.abs ("polyx_e043");       // ^2 then series evaluation and return

// ------------------------------------------------------- // perform TAN()
/* e2b4 */     _`tan_e2b4`;  JSR.abs ("_bbca");            // pack FAC1 into $57
/* e2b7 */                   LDA.imm (0x00);               // clear A
/* e2b9 */                   STA.zpg ("tansgn_0012");      // clear the comparison evaluation flag
/* e2bb */                   JSR.abs ("sin_e26b");         // perform SIN()
/* e2be */                   LDX.imm (0x4e);               // set sin(n) pointer low byte
/* e2c0 */                   LDY.imm (0x00);               // set sin(n) pointer high byte
/* e2c2 */                   JSR.abs ("_e0f6");            // pack FAC1 into (XY)
/* e2c5 */                   LDA.imm (0x57);               // set n pointer low byte
/* e2c7 */                   LDY.imm (0x00);               // set n pointer high byte
/* e2c9 */                   JSR.abs ("movfm_bba2");       // unpack memory (AY) into FAC1
/* e2cc */                   LDA.imm (0x00);               // clear byte
/* e2ce */                   STA.zpg ("facsgn_0066");      // clear FAC1 sign (b7)
/* e2d0 */                   LDA.zpg ("tansgn_0012");      // get the comparison evaluation flag
/* e2d2 */                   JSR.abs ("_e2dc");            // save flag and go do series evaluation
/* e2d5 */                   LDA.imm (0x4e);               // set sin(n) pointer low byte
/* e2d7 */                   LDY.imm (0x00);               // set sin(n) pointer high byte
/* e2d9 */                   JMP.abs ("fdiv_bb0f");        // convert AY and do (AY)/FAC1

// ------------------------------------------------------- // save comparison flag and do series evaluation
/* e2dc */        _`_e2dc`;  PHA.imp ();                   // save comparison flag
/* e2dd */                   JMP.abs ("_e29d");            // add 0.25, ^2 then series evaluation

// ------------------------------------------------------- // constants and series for SIN/COS(n)
                                                           // 1.570796371, pi/2, as floating number
/* e2e0 */     _`pi2_e2e0`;  _.bytes(0x81, 0x49, 0x0f, 0xda, 0xa2);
                                                           // 6.28319, 2*pi, as floating number
/* e2e5 */   _`twopi_e2e5`;  _.bytes(0x83, 0x49, 0x0f, 0xda, 0xa2);
                                                           // 0.25
/* e2ea */     _`fr4_e2ea`;  _.bytes(0x7f, 0x00, 0x00, 0x00, 0x00);
/* e2ef */  _`sincon_e2ef`;  _.bytes(0x05);                // series counter
                                                           // -14.3813907
/* e2f0 */                   _.bytes(0x84, 0xe6, 0x1a, 0x2d, 0x1b);
                                                           //  42.0077971
/* e2f5 */                   _.bytes(0x86, 0x28, 0x07, 0xfb, 0xf8);
                                                           // -76.7041703
/* e2fa */                   _.bytes(0x87, 0x99, 0x68, 0x89, 0x01);
                                                           //  81.6052237
/* e2ff */                   _.bytes(0x87, 0x23, 0x35, 0xdf, 0xe1);
                                                           // -41.3147021
/* e304 */                   _.bytes(0x86, 0xa5, 0x5d, 0xe7, 0x28);
                                                           //   6.28318531   2*pi
/* e309 */                   _.bytes(0x83, 0x49, 0x0f, 0xda, 0xa2);

// ------------------------------------------------------- // perform ATN()
/* e30e */     _`atn_e30e`;  LDA.zpg ("facsgn_0066");      // get FAC1 sign (b7)
/* e310 */                   PHA.imp ();                   // save sign
/* e311 */                   BPL.rel ("_e316");            // branch if +ve
/* e313 */                   JSR.abs ("negop_bfb4");       // else do - FAC1
/* e316 */        _`_e316`;  LDA.zpg ("facexp_0061");      // get FAC1 exponent
/* e318 */                   PHA.imp ();                   // push exponent
/* e319 */                   CMP.imm (0x81);               // compare with 1
/* e31b */                   BCC.rel ("_e324");            // branch if FAC1 < 1
/* e31d */                   LDA.imm (0xbc);               // pointer to 1 low byte
/* e31f */                   LDY.imm (0xb9);               // pointer to 1 high byte
/* e321 */                   JSR.abs ("fdiv_bb0f");        // convert AY and do (AY)/FAC1
/* e324 */        _`_e324`;  LDA.imm (0x3e);               // pointer to series low byte
/* e326 */                   LDY.imm (0xe3);               // pointer to series high byte
/* e328 */                   JSR.abs ("polyx_e043");       // ^2 then series evaluation
/* e32b */                   PLA.imp ();                   // restore old FAC1 exponent
/* e32c */                   CMP.imm (0x81);               // compare with 1
/* e32e */                   BCC.rel ("_e337");            // branch if FAC1 < 1
/* e330 */                   LDA.imm (0xe0);               // pointer to (pi/2) low byte
/* e332 */                   LDY.imm (0xe2);               // pointer to (pi/2) low byte
/* e334 */                   JSR.abs ("fsub_b850");        // perform subtraction, FAC1 from (AY)
/* e337 */        _`_e337`;  PLA.imp ();                   // restore FAC1 sign
/* e338 */                   BPL.rel ("_e33d");            // exit if was +ve
/* e33a */                   JMP.abs ("negop_bfb4");       // else do - FAC1 and return
/* e33d */        _`_e33d`;  RTS.imp ();

// ------------------------------------------------------- // series for ATN(n)
/* e33e */  _`atncon_e33e`;  _.bytes(0x0b);                // series counter
                                                           // -6.84793912E-04
/* e33f */                   _.bytes(0x76, 0xb3, 0x83, 0xbd, 0xd3);
                                                           //  4.85094216E-03
/* e344 */                   _.bytes(0x79, 0x1e, 0xf4, 0xa6, 0xf5);
                                                           //  -.0161117015
/* e349 */                   _.bytes(0x7b, 0x83, 0xfc, 0xb0, 0x10);
                                                           //   .034209638
/* e34e */                   _.bytes(0x7c, 0x0c, 0x1f, 0x67, 0xca);
                                                           //  -.054279133
/* e353 */                   _.bytes(0x7c, 0xde, 0x53, 0xcb, 0xc1);
                                                           //   .0724571965
/* e358 */                   _.bytes(0x7d, 0x14, 0x64, 0x70, 0x4c);
                                                           //  -.0898019185
/* e35d */                   _.bytes(0x7d, 0xb7, 0xea, 0x51, 0x7a);
                                                           //   .110932413
/* e362 */                   _.bytes(0x7d, 0x63, 0x30, 0x88, 0x7e);
                                                           //  -.142839808
/* e367 */                   _.bytes(0x7e, 0x92, 0x44, 0x99, 0x3a);
                                                           //   .19999912
/* e36c */                   _.bytes(0x7e, 0x4c, 0xcc, 0x91, 0xc7);
                                                           //  -.333333316
/* e371 */                   _.bytes(0x7f, 0xaa, 0xaa, 0xaa, 0x13);
                                                           //  1
/* e376 */                   _.bytes(0x81, 0x00, 0x00, 0x00, 0x00);

// ------------------------------------------------------- // BASIC warm start entry point
/* e37b */  _`bassft_e37b`;  JSR.abs ("clrchn_ffcc");      // close input and output channels
/* e37e */                   LDA.imm (0x00);               // clear A
/* e380 */                   STA.zpg ("channl_0013");      // set current I/O channel, flag default
/* e382 */                   JSR.abs ("_a67a");            // flush BASIC stack and clear continue pointer
/* e385 */                   CLI.imp ();                   // enable the interrupts
/* e386 */        _`_e386`;  LDX.imm (0x80);               // set -ve error, just do warm start
/* e388 */                   JMP.ind ("ierror+0_0300");    // go handle error message, normally $E38B
/* e38b */                   TXA.imp ();                   // copy the error number
/* e38c */                   BMI.rel ("_e391");            // if -ve go do warm start
/* e38e */                   JMP.abs ("_a43a");            // else do error #X then warm start
/* e391 */        _`_e391`;  JMP.abs ("ready_a474");       // do warm start

// ------------------------------------------------------- // BASIC cold start entry point
/* e394 */    _`init_e394`;  JSR.abs ("initv_e453");       // initialise the BASIC vector table
/* e397 */                   JSR.abs ("initcz_e3bf");      // initialise the BASIC RAM locations
/* e39a */                   JSR.abs ("initms_e422");      // print the start up message and initialise the memory
                                                           // pointers
                                                           // not ok ??
/* e39d */                   LDX.imm (0xfb);               // value for start stack
/* e39f */                   TXS.imp ();                   // set stack pointer
/* e3a0 */                   BNE.rel ("_e386");            // do "READY." warm start, branch always

// ------------------------------------------------------- // character get subroutine for zero page
                                                           // the target address for the LDA $EA60 becomes the BASIC execute pointer once the
                                                           // block is copied to its destination, any non zero page address will do at assembly
                                                           // time, to assemble a three byte instruction. $EA60 is RTS, NOP.
                                                           // page 0 initialisation table from $0073
                                                           // increment and scan memory
/* e3a2 */  _`initat_e3a2`;  INC.zpg ("txtptr+0_007a");    // increment BASIC execute pointer low byte
/* e3a4 */                   BNE.rel ("_e3a8");            // branch if no carry
                                                           // else
/* e3a6 */                   INC.zpg ("txtptr+1_007b");    // increment BASIC execute pointer high byte
                                                           // page 0 initialisation table from $0079
                                                           // scan memory
/* e3a8 */        _`_e3a8`;  LDA.abs (0xea60);             // get byte to scan, address set by call routine
/* e3ab */                   CMP.imm (0x3a);               // compare with ":"
/* e3ad */                   BCS.rel ("_e3b9");            // exit if>=
                                                           // page 0 initialisation table from $0080
                                                           // clear Cb if numeric
/* e3af */                   CMP.imm (0x20);               // compare with " "
/* e3b1 */                   BEQ.rel ("initat_e3a2");      // if " " go do next
/* e3b3 */                   SEC.imp ();                   // set carry for SBC
/* e3b4 */                   SBC.imm (0x30);               // subtract "0"
/* e3b6 */                   SEC.imp ();                   // set carry for SBC
/* e3b7 */                   SBC.imm (0xd0);               // subtract -"0"
                                                           // clear carry if byte = "0"-"9"
/* e3b9 */        _`_e3b9`;  RTS.imp ();

// ------------------------------------------------------- // spare bytes, not referenced
                                                           // 0.811635157
/* e3ba */  _`rndsed_e3ba`;  _.bytes(0x80, 0x4f, 0xc7, 0x52, 0x58);

// ------------------------------------------------------- // initialise BASIC RAM locations
/* e3bf */  _`initcz_e3bf`;  LDA.imm (0x4c);               // opcode for JMP
/* e3c1 */                   STA.zpg ("jmper+0_0054");     // save for functions vector jump
/* e3c3 */                   STA.abs ("usrpok_0310");      // save for USR() vector jump
                                                           // set USR() vector to illegal quantity error
/* e3c6 */                   LDA.imm (0x48);               // set USR() vector low byte
/* e3c8 */                   LDY.imm (0xb2);               // set USR() vector high byte
/* e3ca */                   STA.abs ("usradd+0_0311");    // save USR() vector low byte
/* e3cd */                   STY.abs ("usradd+1_0312");    // save USR() vector high byte
/* e3d0 */                   LDA.imm (0x91);               // set fixed to float vector low byte
/* e3d2 */                   LDY.imm (0xb3);               // set fixed to float vector high byte
/* e3d4 */                   STA.zpg ("adray2+0_0005");    // save fixed to float vector low byte
/* e3d6 */                   STY.zpg ("adray2+1_0006");    // save fixed to float vector high byte
/* e3d8 */                   LDA.imm (0xaa);               // set float to fixed vector low byte
/* e3da */                   LDY.imm (0xb1);               // set float to fixed vector high byte
/* e3dc */                   STA.zpg ("adray1+0_0003");    // save float to fixed vector low byte
/* e3de */                   STY.zpg ("adray1+1_0004");    // save float to fixed vector high byte
                                                           // copy the character get subroutine from $E3A2 to $0074
/* e3e0 */                   LDX.imm (0x1c);               // set the byte count
/* e3e2 */        _`_e3e2`;  LDA.abx ("initat_e3a2");      // get a byte from the table
/* e3e5 */                   STA.zpx (0x73);               // save the byte in page zero
/* e3e7 */                   DEX.imp ();                   // decrement the count
/* e3e8 */                   BPL.rel ("_e3e2");            // loop if not all done
                                                           // clear descriptors, strings, program area and mamory pointers
/* e3ea */                   LDA.imm (0x03);               // set the step size, collecting descriptors
/* e3ec */                   STA.zpg ("four6_0053");       // save the garbage collection step size
/* e3ee */                   LDA.imm (0x00);               // clear A
/* e3f0 */                   STA.zpg ("bits_0068");        // clear FAC1 overflow byte
/* e3f2 */                   STA.zpg ("channl_0013");      // clear the current I/O channel, flag default
/* e3f4 */                   STA.zpg ("lastpt+1_0018");    // clear the current descriptor stack item pointer high byte
/* e3f6 */                   LDX.imm (0x01);               // set X
/* e3f8 */                   STX.abs ("bstack+190_01fd");  // set the chain link pointer low byte
/* e3fb */                   STX.abs ("bstack+189_01fc");  // set the chain link pointer high byte
/* e3fe */                   LDX.imm (0x19);               // initial the value for descriptor stack
/* e400 */                   STX.zpg ("temppt_0016");      // set descriptor stack pointer
/* e402 */                   SEC.imp ();                   // set Cb = 1 to read the bottom of memory
/* e403 */                   JSR.abs ("membot_ff9c");      // read/set the bottom of memory
/* e406 */                   STX.zpg ("txttab+0_002b");    // save the start of memory low byte
/* e408 */                   STY.zpg ("txttab+1_002c");    // save the start of memory high byte
/* e40a */                   SEC.imp ();                   // set Cb = 1 to read the top of memory
/* e40b */                   JSR.abs ("memtop_ff99");      // read/set the top of memory
/* e40e */                   STX.zpg ("memsiz+0_0037");    // save the end of memory low byte
/* e410 */                   STY.zpg ("memsiz+1_0038");    // save the end of memory high byte
/* e412 */                   STX.zpg ("fretop+0_0033");    // set the bottom of string space low byte
/* e414 */                   STY.zpg ("fretop+1_0034");    // set the bottom of string space high byte
/* e416 */                   LDY.imm (0x00);               // clear the index
/* e418 */                   TYA.imp ();                   // clear the A
/* e419 */                   STA.iny ("txttab+0_002b");    // clear the the first byte of memory
/* e41b */                   INC.zpg ("txttab+0_002b");    // increment the start of memory low byte
/* e41d */                   BNE.rel ("_e421");            // if no rollover skip the high byte increment
/* e41f */                   INC.zpg ("txttab+1_002c");    // increment start of memory high byte
/* e421 */        _`_e421`;  RTS.imp ();

// ------------------------------------------------------- // print the start up message and initialise the memory pointers
/* e422 */  _`initms_e422`;  LDA.zpg ("txttab+0_002b");    // get the start of memory low byte
/* e424 */                   LDY.zpg ("txttab+1_002c");    // get the start of memory high byte
/* e426 */                   JSR.abs ("reason_a408");      // check available memory, do out of memory error if no room
/* e429 */                   LDA.imm (0x73);               // set "**** COMMODORE 64 BASIC V2 ****" pointer low byte
/* e42b */                   LDY.imm (0xe4);               // set "**** COMMODORE 64 BASIC V2 ****" pointer high byte
/* e42d */                   JSR.abs ("strout_ab1e");      // print a null terminated string
/* e430 */                   LDA.zpg ("memsiz+0_0037");    // get the end of memory low byte
/* e432 */                   SEC.imp ();                   // set carry for subtract
/* e433 */                   SBC.zpg ("txttab+0_002b");    // subtract the start of memory low byte
/* e435 */                   TAX.imp ();                   // copy the result to X
/* e436 */                   LDA.zpg ("memsiz+1_0038");    // get the end of memory high byte
/* e438 */                   SBC.zpg ("txttab+1_002c");    // subtract the start of memory high byte
/* e43a */                   JSR.abs ("linprt_bdcd");      // print XA as unsigned integer
/* e43d */                   LDA.imm (0x60);               // set " BYTES FREE" pointer low byte
/* e43f */                   LDY.imm (0xe4);               // set " BYTES FREE" pointer high byte
/* e441 */                   JSR.abs ("strout_ab1e");      // print a null terminated string
/* e444 */                   JMP.abs ("_a644");            // do NEW, CLEAR, RESTORE and return

// ------------------------------------------------------- // BASIC vectors, these are copied to RAM from $0300 onwards
/* e447 */   _`bvtrs_e447`;  _.bytes(0x8b, 0xe3);          // error message          $0300
/* e449 */                   _.bytes(0x83, 0xa4);          // BASIC warm start       $0302
/* e44b */                   _.bytes(0x7c, 0xa5);          // crunch BASIC tokens    $0304
/* e44d */                   _.bytes(0x1a, 0xa7);          // uncrunch BASIC tokens  $0306
/* e44f */                   _.bytes(0xe4, 0xa7);          // start new BASIC code   $0308
/* e451 */                   _.bytes(0x86, 0xae);          // get arithmetic element $030A

// ------------------------------------------------------- // initialise the BASIC vectors
/* e453 */   _`initv_e453`;  LDX.imm (0x0b);               // set byte count
/* e455 */        _`_e455`;  LDA.abx ("bvtrs_e447");       // get byte from table
/* e458 */                   STA.abx ("ierror+0_0300");    // save byte to RAM
/* e45b */                   DEX.imp ();                   // decrement index
/* e45c */                   BPL.rel ("_e455");            // loop if more to do
/* e45e */                   RTS.imp ();

// ------------------------------------------------------- // BASIC startup messages
                                                           // basic bytes free
/* e45f */                   _.bytes(0x00, 0x20, 0x42, 0x41, 0x53, 0x49, 0x43, 0x20);
/* e467 */                   _.bytes(0x42, 0x59, 0x54, 0x45, 0x53, 0x20, 0x46, 0x52);
/* e46f */                   _.bytes(0x45, 0x45, 0x0d, 0x00);
                                                           // (clr) **** commodore 64 basic v2 ****
/* e473 */                   _.bytes(0x93, 0x0d, 0x20, 0x20, 0x20, 0x20, 0x2a, 0x2a);
                                                           // (cr) (cr) 64k ram system
/* e47b */                   _.bytes(0x2a, 0x2a, 0x20, 0x43, 0x4f, 0x4d, 0x4d, 0x4f);
/* e483 */                   _.bytes(0x44, 0x4f, 0x52, 0x45, 0x20, 0x36, 0x34, 0x20);
/* e48b */                   _.bytes(0x42, 0x41, 0x53, 0x49, 0x43, 0x20, 0x56, 0x32);
/* e493 */                   _.bytes(0x20, 0x2a, 0x2a, 0x2a, 0x2a, 0x0d, 0x0d, 0x20);
/* e49b */                   _.bytes(0x36, 0x34, 0x4b, 0x20, 0x52, 0x41, 0x4d, 0x20);
/* e4a3 */                   _.bytes(0x53, 0x59, 0x53, 0x54, 0x45, 0x4d, 0x20, 0x20);
/* e4ab */                   _.bytes(0x00);

// ------------------------------------------------------- // unused
/* e4ac */                   _.bytes(0x81);

// ------------------------------------------------------- // open channel for output
/* e4ad */        _`_e4ad`;  PHA.imp ();                   // save the flag byte
/* e4ae */                   JSR.abs ("chkout_ffc9");      // open channel for output
/* e4b1 */                   TAX.imp ();                   // copy the returned flag byte
/* e4b2 */                   PLA.imp ();                   // restore the alling flag byte
/* e4b3 */                   BCC.rel ("_e4b6");            // if there is no error skip copying the error flag
/* e4b5 */                   TXA.imp ();                   // else copy the error flag
/* e4b6 */        _`_e4b6`;  RTS.imp ();

// ------------------------------------------------------- // unused bytes
/* e4b7 */                   _.bytes(0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa);
/* e4bf */                   _.bytes(0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa);
/* e4c7 */                   _.bytes(0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa);
/* e4cf */                   _.bytes(0xaa, 0xaa, 0xaa, 0xaa);

// ------------------------------------------------------- // flag the RS232 start bit and set the parity
/* e4d3 */        _`_e4d3`;  STA.zpg ("rinone_00a9");      // save the start bit check flag, set start bit received
/* e4d5 */                   LDA.imm (0x01);               // set the initial parity state
/* e4d7 */                   STA.zpg ("riprty_00ab");      // save the receiver parity bit
/* e4d9 */                   RTS.imp ();

// ------------------------------------------------------- // save the current colour to the colour RAM
/* e4da */        _`_e4da`;  LDA.abs ("color_0286");       // get the current colour code
/* e4dd */                   STA.iny ("user+0_00f3");      // save it to the colour RAM
/* e4df */                   RTS.imp ();

// ------------------------------------------------------- // wait ~8.5 seconds for any key from the STOP key column
/* e4e0 */        _`_e4e0`;  ADC.imm (0x02);               // set the number of jiffies to wait
/* e4e2 */        _`_e4e2`;  LDY.zpg ("stkey_0091");       // read the stop key column
/* e4e4 */                   INY.imp ();                   // test for $FF, no keys pressed
/* e4e5 */                   BNE.rel ("_e4eb");            // if any keys were pressed just exit
/* e4e7 */                   CMP.zpg ("time+1_00a1");      // compare the wait time with the jiffy clock mid byte
/* e4e9 */                   BNE.rel ("_e4e2");            // if not there yet go wait some more
/* e4eb */        _`_e4eb`;  RTS.imp ();

// ------------------------------------------------------- // baud rate tables for PAL C64
                                                           // baud rate word is calculated from ..

                                                           // (system clock / baud rate) / 2 - 100

                                                           //     system clock
                                                           //     ------------
                                                           // PAL       985248 Hz
                                                           // NTSC     1022727 Hz
/* e4ec */                   _.bytes(0x19, 0x26);          //   50   baud   985300
/* e4ee */                   _.bytes(0x44, 0x19);          //   75   baud   985200
/* e4f0 */                   _.bytes(0x1a, 0x11);          //  110   baud   985160
/* e4f2 */                   _.bytes(0xe8, 0x0d);          //  134.5 baud   984540
/* e4f4 */                   _.bytes(0x70, 0x0c);          //  150   baud   985200
/* e4f6 */                   _.bytes(0x06, 0x06);          //  300   baud   985200
/* e4f8 */                   _.bytes(0xd1, 0x02);          //  600   baud   985200
/* e4fa */                   _.bytes(0x37, 0x01);          // 1200   baud   986400
/* e4fc */                   _.bytes(0xae, 0x00);          // 1800   baud   986400
/* e4fe */                   _.bytes(0x69, 0x00);          // 2400   baud   984000

// ------------------------------------------------------- // return the base address of the I/O devices
/* e500 */  _`iobase_e500`;  LDX.imm (0x00);               // get the I/O base address low byte
/* e502 */                   LDY.imm (0xdc);               // get the I/O base address high byte
/* e504 */                   RTS.imp ();

// ------------------------------------------------------- // return the x,y organization of the screen
/* e505 */  _`screen_e505`;  LDX.imm (0x28);               // get the x size
/* e507 */                   LDY.imm (0x19);               // get the y size
/* e509 */                   RTS.imp ();

// ------------------------------------------------------- // read/set the x,y cursor position
/* e50a */    _`plot_e50a`;  BCS.rel ("_e513");            // if read cursor go do read
/* e50c */                   STX.zpg ("tblx_00d6");        // save the cursor row
/* e50e */                   STY.zpg ("pntr_00d3");        // save the cursor column
/* e510 */                   JSR.abs ("_e56c");            // set the screen pointers for the cursor row, column
/* e513 */        _`_e513`;  LDX.zpg ("tblx_00d6");        // get the cursor row
/* e515 */                   LDY.zpg ("pntr_00d3");        // get the cursor column
/* e517 */                   RTS.imp ();

// ------------------------------------------------------- // initialise the screen and keyboard
/* e518 */   _`cint1_e518`;  JSR.abs ("_e5a0");            // initialise the vic chip
/* e51b */                   LDA.imm (0x00);               // clear A
/* e51d */                   STA.abs ("mode_0291");        // clear the shift mode switch
/* e520 */                   STA.zpg ("blnon_00cf");       // clear the cursor blink phase
/* e522 */                   LDA.imm (0x48);               // get the keyboard decode logic pointer low byte
/* e524 */                   STA.abs ("keylog+0_028f");    // save the keyboard decode logic pointer low byte
/* e527 */                   LDA.imm (0xeb);               // get the keyboard decode logic pointer high byte
/* e529 */                   STA.abs ("keylog+1_0290");    // save the keyboard decode logic pointer high byte
/* e52c */                   LDA.imm (0x0a);               // set the maximum size of the keyboard buffer
/* e52e */                   STA.abs ("xmax_0289");        // save the maximum size of the keyboard buffer
/* e531 */                   STA.abs ("delay_028c");       // save the repeat delay counter
/* e534 */                   LDA.imm (0x0e);               // set light blue
/* e536 */                   STA.abs ("color_0286");       // save the current colour code
/* e539 */                   LDA.imm (0x04);               // speed 4
/* e53b */                   STA.abs ("kount_028b");       // save the repeat speed counter
/* e53e */                   LDA.imm (0x0c);               // set the cursor flash timing
/* e540 */                   STA.zpg ("blnct_00cd");       // save the cursor timing countdown
/* e542 */                   STA.zpg ("blnsw_00cc");       // save the cursor enable, $00 = flash cursor

// ------------------------------------------------------- // clear the screen
/* e544 */        _`_e544`;  LDA.abs ("hibase_0288");      // get the screen memory page
/* e547 */                   ORA.imm (0x80);               // set the high bit, flag every line is a logical line start
/* e549 */                   TAY.imp ();                   // copy to Y
/* e54a */                   LDA.imm (0x00);               // clear the line start low byte
/* e54c */                   TAX.imp ();                   // clear the index
/* e54d */        _`_e54d`;  STY.zpx (0xd9);               // save the start of line X pointer high byte
/* e54f */                   CLC.imp ();                   // clear carry for add
/* e550 */                   ADC.imm (0x28);               // add the line length to the low byte
/* e552 */                   BCC.rel ("_e555");            // if no rollover skip the high byte increment
/* e554 */                   INY.imp ();                   // else increment the high byte
/* e555 */        _`_e555`;  INX.imp ();                   // increment the line index
/* e556 */                   CPX.imm (0x1a);               // compare it with the number of lines + 1
/* e558 */                   BNE.rel ("_e54d");            // loop if not all done
/* e55a */                   LDA.imm (0xff);               // set the end of table marker
/* e55c */                   STA.zpx (0xd9);               // mark the end of the table
/* e55e */                   LDX.imm (0x18);               // set the line count, 25 lines to do, 0 to 24
/* e560 */        _`_e560`;  JSR.abs ("_e9ff");            // clear screen line X
/* e563 */                   DEX.imp ();                   // decrement the count
/* e564 */                   BPL.rel ("_e560");            // loop if more to do

// ------------------------------------------------------- // home the cursor
/* e566 */        _`_e566`;  LDY.imm (0x00);               // clear Y
/* e568 */                   STY.zpg ("pntr_00d3");        // clear the cursor column
/* e56a */                   STY.zpg ("tblx_00d6");        // clear the cursor row

// ------------------------------------------------------- // set screen pointers for cursor row, column
/* e56c */        _`_e56c`;  LDX.zpg ("tblx_00d6");        // get the cursor row
/* e56e */                   LDA.zpg ("pntr_00d3");        // get the cursor column
/* e570 */        _`_e570`;  LDY.zpx (0xd9);               // get start of line X pointer high byte
/* e572 */                   BMI.rel ("_e57c");            // if it is the logical line start continue
/* e574 */                   CLC.imp ();                   // else clear carry for add
/* e575 */                   ADC.imm (0x28);               // add one line length
/* e577 */                   STA.zpg ("pntr_00d3");        // save the cursor column
/* e579 */                   DEX.imp ();                   // decrement the cursor row
/* e57a */                   BPL.rel ("_e570");            // loop, branch always
/* e57c */        _`_e57c`;  JSR.abs ("_e9f0");            // fetch a screen address
/* e57f */                   LDA.imm (0x27);               // set the line length
/* e581 */                   INX.imp ();                   // increment the cursor row
/* e582 */        _`_e582`;  LDY.zpx (0xd9);               // get the start of line X pointer high byte
/* e584 */                   BMI.rel ("_e58c");            // if logical line start exit
/* e586 */                   CLC.imp ();                   // else clear carry for add
/* e587 */                   ADC.imm (0x28);               // add one line length to the current line length
/* e589 */                   INX.imp ();                   // increment the cursor row
/* e58a */                   BPL.rel ("_e582");            // loop, branch always
/* e58c */        _`_e58c`;  STA.zpg ("lnmx_00d5");        // save current screen line length
/* e58e */                   JMP.abs ("_ea24");            // calculate the pointer to colour RAM and return
/* e591 */        _`_e591`;  CPX.zpg ("lxsp+0_00c9");      // compare it with the input cursor row
/* e593 */                   BEQ.rel ("_e598");            // if there just exit
/* e595 */                   JMP.abs ("_e6ed");            // else go ??
/* e598 */        _`_e598`;  RTS.imp ();

// ------------------------------------------------------- // orphan bytes ??
/* e599 */                   NOP.imp ();                   // huh
/* e59a */                   JSR.abs ("_e5a0");            // initialise the vic chip
/* e59d */                   JMP.abs ("_e566");            // home the cursor and return

// ------------------------------------------------------- // initialise the vic chip
/* e5a0 */        _`_e5a0`;  LDA.imm (0x03);               // set the screen as the output device
/* e5a2 */                   STA.zpg ("dflto_009a");       // save the output device number
/* e5a4 */                   LDA.imm (0x00);               // set the keyboard as the input device
/* e5a6 */                   STA.zpg ("dfltn_0099");       // save the input device number
/* e5a8 */                   LDX.imm (0x2f);               // set the count/index
/* e5aa */        _`_e5aa`;  LDA.abx ("_ecb8");            // get a vic ii chip initialisation value
/* e5ad */                   STA.abx ("_cfff");            // save it to the vic ii chip
/* e5b0 */                   DEX.imp ();                   // decrement the count/index
/* e5b1 */                   BNE.rel ("_e5aa");            // loop if more to do
/* e5b3 */                   RTS.imp ();

// ------------------------------------------------------- // input from the keyboard buffer
/* e5b4 */     _`lp2_e5b4`;  LDY.abs ("keyd+0_0277");      // get the current character from the buffer
/* e5b7 */                   LDX.imm (0x00);               // clear the index
/* e5b9 */        _`_e5b9`;  LDA.abx ("keyd+1_0278");      // get the next character,X from the buffer
/* e5bc */                   STA.abx ("keyd+0_0277");      // save it as the current character,X in the buffer
/* e5bf */                   INX.imp ();                   // increment the index
/* e5c0 */                   CPX.zpg ("ndx_00c6");         // compare it with the keyboard buffer index
/* e5c2 */                   BNE.rel ("_e5b9");            // loop if more to do
/* e5c4 */                   DEC.zpg ("ndx_00c6");         // decrement keyboard buffer index
/* e5c6 */                   TYA.imp ();                   // copy the key to A
/* e5c7 */                   CLI.imp ();                   // enable the interrupts
/* e5c8 */                   CLC.imp ();                   // flag got byte
/* e5c9 */                   RTS.imp ();

// ------------------------------------------------------- // write character and wait for key
/* e5ca */        _`_e5ca`;  JSR.abs ("_e716");            // output character

// ------------------------------------------------------- // wait for a key from the keyboard
/* e5cd */        _`_e5cd`;  LDA.zpg ("ndx_00c6");         // get the keyboard buffer index
/* e5cf */                   STA.zpg ("blnsw_00cc");       // cursor enable, $00 = flash cursor, $xx = no flash
/* e5d1 */                   STA.abs ("autodn_0292");      // screen scrolling flag, $00 = scroll, $xx = no scroll
                                                           // this disables both the cursor flash and the screen scroll
                                                           // while there are characters in the keyboard buffer
/* e5d4 */                   BEQ.rel ("_e5cd");            // loop if the buffer is empty
/* e5d6 */                   SEI.imp ();                   // disable the interrupts
/* e5d7 */                   LDA.zpg ("blnon_00cf");       // get the cursor blink phase
/* e5d9 */                   BEQ.rel ("_e5e7");            // if cursor phase skip the overwrite
                                                           // else it is the character phase
/* e5db */                   LDA.zpg ("gdbln_00ce");       // get the character under the cursor
/* e5dd */                   LDX.abs ("gdcol_0287");       // get the colour under the cursor
/* e5e0 */                   LDY.imm (0x00);               // clear Y
/* e5e2 */                   STY.zpg ("blnon_00cf");       // clear the cursor blink phase
/* e5e4 */                   JSR.abs ("_ea13");            // print character A and colour X
/* e5e7 */        _`_e5e7`;  JSR.abs ("lp2_e5b4");         // input from the keyboard buffer
/* e5ea */                   CMP.imm (0x83);               // compare with [SHIFT][RUN]
/* e5ec */                   BNE.rel ("_e5fe");            // if not [SHIFT][RUN] skip the buffer fill
                                                           // keys are [SHIFT][RUN] so put "LOAD",$0D,"RUN",$0D into
                                                           // the buffer
/* e5ee */                   LDX.imm (0x09);               // set the byte count
/* e5f0 */                   SEI.imp ();                   // disable the interrupts
/* e5f1 */                   STX.zpg ("ndx_00c6");         // set the keyboard buffer index
/* e5f3 */        _`_e5f3`;  LDA.abx ("_ece6");            // get byte from the auto load/run table
/* e5f6 */                   STA.abx ("sat+9_0276");       // save it to the keyboard buffer
/* e5f9 */                   DEX.imp ();                   // decrement the count/index
/* e5fa */                   BNE.rel ("_e5f3");            // loop while more to do
/* e5fc */                   BEQ.rel ("_e5cd");            // loop for the next key, branch always
                                                           // was not [SHIFT][RUN]
/* e5fe */        _`_e5fe`;  CMP.imm (0x0d);               // compare the key with [CR]
/* e600 */                   BNE.rel ("_e5ca");            // if not [CR] print the character and get the next key
                                                           // else it was [CR]
/* e602 */                   LDY.zpg ("lnmx_00d5");        // get the current screen line length
/* e604 */                   STY.zpg ("crsw_00d0");        // input from keyboard or screen, $xx = screen,
                                                           // $00 = keyboard
/* e606 */        _`_e606`;  LDA.iny ("pnt+0_00d1");       // get the character from the current screen line
/* e608 */                   CMP.imm (0x20);               // compare it with [SPACE]
/* e60a */                   BNE.rel ("_e60f");            // if not [SPACE] continue
/* e60c */                   DEY.imp ();                   // else eliminate the space, decrement end of input line
/* e60d */                   BNE.rel ("_e606");            // loop, branch always
/* e60f */        _`_e60f`;  INY.imp ();                   // increment past the last non space character on line
/* e610 */                   STY.zpg ("indx_00c8");        // save the input [EOL] pointer
/* e612 */                   LDY.imm (0x00);               // clear A
/* e614 */                   STY.abs ("autodn_0292");      // clear the screen scrolling flag, $00 = scroll
/* e617 */                   STY.zpg ("pntr_00d3");        // clear the cursor column
/* e619 */                   STY.zpg ("qtsw_00d4");        // clear the cursor quote flag, $xx = quote, $00 = no quote
/* e61b */                   LDA.zpg ("lxsp+0_00c9");      // get the input cursor row
/* e61d */                   BMI.rel ("_e63a");
/* e61f */                   LDX.zpg ("tblx_00d6");        // get the cursor row
/* e621 */                   JSR.abs ("_e591");            // find and set the pointers for the start of logical line
/* e624 */                   CPX.zpg ("lxsp+0_00c9");      // compare with input cursor row
/* e626 */                   BNE.rel ("_e63a");
/* e628 */                   LDA.zpg ("lxsp+1_00ca");      // get the input cursor column
/* e62a */                   STA.zpg ("pntr_00d3");        // save the cursor column
/* e62c */                   CMP.zpg ("indx_00c8");        // compare the cursor column with input [EOL] pointer
/* e62e */                   BCC.rel ("_e63a");            // if less, cursor is in line, go ??
/* e630 */                   BCS.rel ("_e65d");            // else the cursor is beyond the line end, branch always

// ------------------------------------------------------- // input from screen or keyboard
/* e632 */        _`_e632`;  TYA.imp ();                   // copy Y
/* e633 */                   PHA.imp ();                   // save Y
/* e634 */                   TXA.imp ();                   // copy X
/* e635 */                   PHA.imp ();                   // save X
/* e636 */                   LDA.zpg ("crsw_00d0");        // input from keyboard or screen, $xx = screen,
                                                           // $00 = keyboard
/* e638 */                   BEQ.rel ("_e5cd");            // if keyboard go wait for key
/* e63a */        _`_e63a`;  LDY.zpg ("pntr_00d3");        // get the cursor column
/* e63c */                   LDA.iny ("pnt+0_00d1");       // get character from the current screen line
/* e63e */                   STA.zpg ("schar_00d7");       // save temporary last character
/* e640 */                   AND.imm (0x3f);               // mask key bits
/* e642 */                   ASL.zpg ("schar_00d7");       // << temporary last character
/* e644 */                   BIT.zpg ("schar_00d7");       // test it
/* e646 */                   BPL.rel ("_e64a");            // branch if not [NO KEY]
/* e648 */                   ORA.imm (0x80);
/* e64a */        _`_e64a`;  BCC.rel ("_e650");
/* e64c */                   LDX.zpg ("qtsw_00d4");        // get the cursor quote flag, $xx = quote, $00 = no quote
/* e64e */                   BNE.rel ("_e654");            // if in quote mode go ??
/* e650 */        _`_e650`;  BVS.rel ("_e654");
/* e652 */                   ORA.imm (0x40);
/* e654 */        _`_e654`;  INC.zpg ("pntr_00d3");        // increment the cursor column
/* e656 */                   JSR.abs ("_e684");            // if open quote toggle the cursor quote flag
/* e659 */                   CPY.zpg ("indx_00c8");        // compare ?? with input [EOL] pointer
/* e65b */                   BNE.rel ("_e674");            // if not at line end go ??
/* e65d */        _`_e65d`;  LDA.imm (0x00);               // clear A
/* e65f */                   STA.zpg ("crsw_00d0");        // clear input from keyboard or screen, $xx = screen,
                                                           // $00 = keyboard
/* e661 */                   LDA.imm (0x0d);               // set character [CR]
/* e663 */                   LDX.zpg ("dfltn_0099");       // get the input device number
/* e665 */                   CPX.imm (0x03);               // compare the input device with the screen
/* e667 */                   BEQ.rel ("_e66f");            // if screen go ??
/* e669 */                   LDX.zpg ("dflto_009a");       // get the output device number
/* e66b */                   CPX.imm (0x03);               // compare the output device with the screen
/* e66d */                   BEQ.rel ("_e672");            // if screen go ??
/* e66f */        _`_e66f`;  JSR.abs ("_e716");            // output the character
/* e672 */        _`_e672`;  LDA.imm (0x0d);               // set character [CR]
/* e674 */        _`_e674`;  STA.zpg ("schar_00d7");       // save character
/* e676 */                   PLA.imp ();                   // pull X
/* e677 */                   TAX.imp ();                   // restore X
/* e678 */                   PLA.imp ();                   // pull Y
/* e679 */                   TAY.imp ();                   // restore Y
/* e67a */                   LDA.zpg ("schar_00d7");       // restore character
/* e67c */                   CMP.imm (0xde);
/* e67e */                   BNE.rel ("_e682");
/* e680 */                   LDA.imm (0xff);
/* e682 */        _`_e682`;  CLC.imp ();                   // flag ok
/* e683 */                   RTS.imp ();

// ------------------------------------------------------- // if open quote toggle cursor quote flag
/* e684 */        _`_e684`;  CMP.imm (0x22);               // comapre byte with "
/* e686 */                   BNE.rel ("_e690");            // exit if not "
/* e688 */                   LDA.zpg ("qtsw_00d4");        // get cursor quote flag, $xx = quote, $00 = no quote
/* e68a */                   EOR.imm (0x01);               // toggle it
/* e68c */                   STA.zpg ("qtsw_00d4");        // save cursor quote flag
/* e68e */                   LDA.imm (0x22);               // restore the "
/* e690 */        _`_e690`;  RTS.imp ();

// ------------------------------------------------------- // insert uppercase/graphic character
/* e691 */        _`_e691`;  ORA.imm (0x40);               // change to uppercase/graphic
/* e693 */        _`_e693`;  LDX.zpg ("rvs_00c7");         // get the reverse flag
/* e695 */                   BEQ.rel ("_e699");            // branch if not reverse
                                                           // else ..
                                                           // insert reversed character
/* e697 */        _`_e697`;  ORA.imm (0x80);               // reverse character
/* e699 */        _`_e699`;  LDX.zpg ("insrt_00d8");       // get the insert count
/* e69b */                   BEQ.rel ("_e69f");            // branch if none
/* e69d */                   DEC.zpg ("insrt_00d8");       // else decrement the insert count
/* e69f */        _`_e69f`;  LDX.abs ("color_0286");       // get the current colour code
/* e6a2 */                   JSR.abs ("_ea13");            // print character A and colour X
/* e6a5 */                   JSR.abs ("_e6b6");            // advance the cursor
                                                           // restore the registers, set the quote flag and exit
/* e6a8 */        _`_e6a8`;  PLA.imp ();                   // pull Y
/* e6a9 */                   TAY.imp ();                   // restore Y
/* e6aa */                   LDA.zpg ("insrt_00d8");       // get the insert count
/* e6ac */                   BEQ.rel ("_e6b0");            // skip quote flag clear if inserts to do
/* e6ae */                   LSR.zpg ("qtsw_00d4");        // clear cursor quote flag, $xx = quote, $00 = no quote
/* e6b0 */        _`_e6b0`;  PLA.imp ();                   // pull X
/* e6b1 */                   TAX.imp ();                   // restore X
/* e6b2 */                   PLA.imp ();                   // restore A
/* e6b3 */                   CLC.imp ();
/* e6b4 */                   CLI.imp ();                   // enable the interrupts
/* e6b5 */                   RTS.imp ();

// ------------------------------------------------------- // advance the cursor
/* e6b6 */        _`_e6b6`;  JSR.abs ("_e8b3");            // test for line increment
/* e6b9 */                   INC.zpg ("pntr_00d3");        // increment the cursor column
/* e6bb */                   LDA.zpg ("lnmx_00d5");        // get current screen line length
/* e6bd */                   CMP.zpg ("pntr_00d3");        // compare ?? with the cursor column
/* e6bf */                   BCS.rel ("_e700");            // exit if line length >= cursor column
/* e6c1 */                   CMP.imm (0x4f);               // compare with max length
/* e6c3 */                   BEQ.rel ("_e6f7");            // if at max clear column, back cursor up and do newline
/* e6c5 */                   LDA.abs ("autodn_0292");      // get the autoscroll flag
/* e6c8 */                   BEQ.rel ("_e6cd");            // branch if autoscroll on
/* e6ca */                   JMP.abs ("_e967");            // else open space on screen
/* e6cd */        _`_e6cd`;  LDX.zpg ("tblx_00d6");        // get the cursor row
/* e6cf */                   CPX.imm (0x19);               // compare with max + 1
/* e6d1 */                   BCC.rel ("_e6da");            // if less than max + 1 go add this row to the current
                                                           // logical line
/* e6d3 */                   JSR.abs ("_e8ea");            // else scroll the screen
/* e6d6 */                   DEC.zpg ("tblx_00d6");        // decrement the cursor row
/* e6d8 */                   LDX.zpg ("tblx_00d6");        // get the cursor row
                                                           // add this row to the current logical line
/* e6da */        _`_e6da`;  ASL.zpx (0xd9);               // shift start of line X pointer high byte
/* e6dc */                   LSR.zpx (0xd9);               // shift start of line X pointer high byte back,
                                                           // make next screen line start of logical line, increment line length and set pointers
                                                           // clear b7, start of logical line
/* e6de */                   INX.imp ();                   // increment screen row
/* e6df */                   LDA.zpx (0xd9);               // get start of line X pointer high byte
/* e6e1 */                   ORA.imm (0x80);               // mark as start of logical line
/* e6e3 */                   STA.zpx (0xd9);               // set start of line X pointer high byte
/* e6e5 */                   DEX.imp ();                   // restore screen row
/* e6e6 */                   LDA.zpg ("lnmx_00d5");        // get current screen line length
                                                           // add one line length and set the pointers for the start of the line
/* e6e8 */                   CLC.imp ();                   // clear carry for add
/* e6e9 */                   ADC.imm (0x28);               // add one line length
/* e6eb */                   STA.zpg ("lnmx_00d5");        // save current screen line length
/* e6ed */        _`_e6ed`;  LDA.zpx (0xd9);               // get start of line X pointer high byte
/* e6ef */                   BMI.rel ("_e6f4");            // exit loop if start of logical line
/* e6f1 */                   DEX.imp ();                   // else back up one line
/* e6f2 */                   BNE.rel ("_e6ed");            // loop if not on first line
/* e6f4 */        _`_e6f4`;  JMP.abs ("_e9f0");            // fetch a screen address
/* e6f7 */        _`_e6f7`;  DEC.zpg ("tblx_00d6");        // decrement the cursor row
/* e6f9 */                   JSR.abs ("_e87c");            // do newline
/* e6fc */                   LDA.imm (0x00);               // clear A
/* e6fe */                   STA.zpg ("pntr_00d3");        // clear the cursor column
/* e700 */        _`_e700`;  RTS.imp ();

// ------------------------------------------------------- // back onto the previous line if possible
/* e701 */        _`_e701`;  LDX.zpg ("tblx_00d6");        // get the cursor row
/* e703 */                   BNE.rel ("_e70b");            // branch if not top row
/* e705 */                   STX.zpg ("pntr_00d3");        // clear cursor column
/* e707 */                   PLA.imp ();                   // dump return address low byte
/* e708 */                   PLA.imp ();                   // dump return address high byte
/* e709 */                   BNE.rel ("_e6a8");            // restore registers, set quote flag and exit, branch always
/* e70b */        _`_e70b`;  DEX.imp ();                   // decrement the cursor row
/* e70c */                   STX.zpg ("tblx_00d6");        // save the cursor row
/* e70e */                   JSR.abs ("_e56c");            // set the screen pointers for cursor row, column
/* e711 */                   LDY.zpg ("lnmx_00d5");        // get current screen line length
/* e713 */                   STY.zpg ("pntr_00d3");        // save the cursor column
/* e715 */                   RTS.imp ();

// ------------------------------------------------------- // output a character to the screen
/* e716 */        _`_e716`;  PHA.imp ();                   // save character
/* e717 */                   STA.zpg ("schar_00d7");       // save temporary last character
/* e719 */                   TXA.imp ();                   // copy X
/* e71a */                   PHA.imp ();                   // save X
/* e71b */                   TYA.imp ();                   // copy Y
/* e71c */                   PHA.imp ();                   // save Y
/* e71d */                   LDA.imm (0x00);               // clear A
/* e71f */                   STA.zpg ("crsw_00d0");        // clear input from keyboard or screen, $xx = screen,
                                                           // $00 = keyboard
/* e721 */                   LDY.zpg ("pntr_00d3");        // get cursor column
/* e723 */                   LDA.zpg ("schar_00d7");       // restore last character
/* e725 */                   BPL.rel ("_e72a");            // branch if unshifted
/* e727 */                   JMP.abs ("_e7d4");            // do shifted characters and return
/* e72a */        _`_e72a`;  CMP.imm (0x0d);               // compare with [CR]
/* e72c */                   BNE.rel ("_e731");            // branch if not [CR]
/* e72e */                   JMP.abs ("_e891");            // else output [CR] and return
/* e731 */        _`_e731`;  CMP.imm (0x20);               // compare with [SPACE]
/* e733 */                   BCC.rel ("_e745");            // branch if < [SPACE], not a printable character
/* e735 */                   CMP.imm (0x60);
/* e737 */                   BCC.rel ("_e73d");            // branch if $20 to $5F
                                                           // character is $60 or greater
/* e739 */                   AND.imm (0xdf);               // conversion of PETSCII character to screen code
/* e73b */                   BNE.rel ("_e73f");            // branch always
                                                           // character is $20 to $5F
/* e73d */        _`_e73d`;  AND.imm (0x3f);               // conversion of PETSCII character to screen code
/* e73f */        _`_e73f`;  JSR.abs ("_e684");            // if open quote toggle cursor direct/programmed flag
/* e742 */                   JMP.abs ("_e693");
                                                           // character was < [SPACE] so is a control character
                                                           // of some sort
/* e745 */        _`_e745`;  LDX.zpg ("insrt_00d8");       // get the insert count
/* e747 */                   BEQ.rel ("_e74c");            // if no characters to insert continue
/* e749 */                   JMP.abs ("_e697");            // insert reversed character
/* e74c */        _`_e74c`;  CMP.imm (0x14);               // compare the character with [INSERT]/[DELETE]
/* e74e */                   BNE.rel ("_e77e");            // if not [INSERT]/[DELETE] go ??
/* e750 */                   TYA.imp ();
/* e751 */                   BNE.rel ("_e759");
/* e753 */                   JSR.abs ("_e701");            // back onto the previous line if possible
/* e756 */                   JMP.abs ("_e773");
/* e759 */        _`_e759`;  JSR.abs ("_e8a1");            // test for line decrement
                                                           // now close up the line
/* e75c */                   DEY.imp ();                   // decrement index to previous character
/* e75d */                   STY.zpg ("pntr_00d3");        // save the cursor column
/* e75f */                   JSR.abs ("_ea24");            // calculate the pointer to colour RAM
/* e762 */        _`_e762`;  INY.imp ();                   // increment index to next character
/* e763 */                   LDA.iny ("pnt+0_00d1");       // get character from current screen line
/* e765 */                   DEY.imp ();                   // decrement index to previous character
/* e766 */                   STA.iny ("pnt+0_00d1");       // save character to current screen line
/* e768 */                   INY.imp ();                   // increment index to next character
/* e769 */                   LDA.iny ("user+0_00f3");      // get colour RAM byte
/* e76b */                   DEY.imp ();                   // decrement index to previous character
/* e76c */                   STA.iny ("user+0_00f3");      // save colour RAM byte
/* e76e */                   INY.imp ();                   // increment index to next character
/* e76f */                   CPY.zpg ("lnmx_00d5");        // compare with current screen line length
/* e771 */                   BNE.rel ("_e762");            // loop if not there yet
/* e773 */        _`_e773`;  LDA.imm (0x20);               // set [SPACE]
/* e775 */                   STA.iny ("pnt+0_00d1");       // clear last character on current screen line
/* e777 */                   LDA.abs ("color_0286");       // get the current colour code
/* e77a */                   STA.iny ("user+0_00f3");      // save to colour RAM
/* e77c */                   BPL.rel ("_e7cb");            // branch always
/* e77e */        _`_e77e`;  LDX.zpg ("qtsw_00d4");        // get cursor quote flag, $xx = quote, $00 = no quote
/* e780 */                   BEQ.rel ("_e785");            // branch if not quote mode
/* e782 */                   JMP.abs ("_e697");            // insert reversed character
/* e785 */        _`_e785`;  CMP.imm (0x12);               // compare with [RVS ON]
/* e787 */                   BNE.rel ("_e78b");            // if not [RVS ON] skip setting the reverse flag
/* e789 */                   STA.zpg ("rvs_00c7");         // else set the reverse flag
/* e78b */        _`_e78b`;  CMP.imm (0x13);               // compare with [CLR HOME]
/* e78d */                   BNE.rel ("_e792");            // if not [CLR HOME] continue
/* e78f */                   JSR.abs ("_e566");            // home the cursor
/* e792 */        _`_e792`;  CMP.imm (0x1d);               // compare with [CURSOR RIGHT]
/* e794 */                   BNE.rel ("_e7ad");            // if not [CURSOR RIGHT] go ??
/* e796 */                   INY.imp ();                   // increment the cursor column
/* e797 */                   JSR.abs ("_e8b3");            // test for line increment
/* e79a */                   STY.zpg ("pntr_00d3");        // save the cursor column
/* e79c */                   DEY.imp ();                   // decrement the cursor column
/* e79d */                   CPY.zpg ("lnmx_00d5");        // compare cursor column with current screen line length
/* e79f */                   BCC.rel ("_e7aa");            // exit if less
                                                           // else the cursor column is >= the current screen line
                                                           // length so back onto the current line and do a newline
/* e7a1 */                   DEC.zpg ("tblx_00d6");        // decrement the cursor row
/* e7a3 */                   JSR.abs ("_e87c");            // do newline
/* e7a6 */                   LDY.imm (0x00);               // clear cursor column
/* e7a8 */        _`_e7a8`;  STY.zpg ("pntr_00d3");        // save the cursor column
/* e7aa */        _`_e7aa`;  JMP.abs ("_e6a8");            // restore the registers, set the quote flag and exit
/* e7ad */        _`_e7ad`;  CMP.imm (0x11);               // compare with [CURSOR DOWN]
/* e7af */                   BNE.rel ("_e7ce");            // if not [CURSOR DOWN] go ??
/* e7b1 */                   CLC.imp ();                   // clear carry for add
/* e7b2 */                   TYA.imp ();                   // copy the cursor column
/* e7b3 */                   ADC.imm (0x28);               // add one line
/* e7b5 */                   TAY.imp ();                   // copy back to Y
/* e7b6 */                   INC.zpg ("tblx_00d6");        // increment the cursor row
/* e7b8 */                   CMP.zpg ("lnmx_00d5");        // compare cursor column with current screen line length
/* e7ba */                   BCC.rel ("_e7a8");            // if less go save cursor column and exit
/* e7bc */                   BEQ.rel ("_e7a8");            // if equal go save cursor column and exit
                                                           // else the cursor has moved beyond the end of this line
                                                           // so back it up until it's on the start of the logical line
/* e7be */                   DEC.zpg ("tblx_00d6");        // decrement the cursor row
/* e7c0 */        _`_e7c0`;  SBC.imm (0x28);               // subtract one line
/* e7c2 */                   BCC.rel ("_e7c8");            // if on previous line exit the loop
/* e7c4 */                   STA.zpg ("pntr_00d3");        // else save the cursor column
/* e7c6 */                   BNE.rel ("_e7c0");            // loop if not at the start of the line
/* e7c8 */        _`_e7c8`;  JSR.abs ("_e87c");            // do newline
/* e7cb */        _`_e7cb`;  JMP.abs ("_e6a8");            // restore the registers, set the quote flag and exit
/* e7ce */        _`_e7ce`;  JSR.abs ("_e8cb");            // set the colour code
/* e7d1 */                   JMP.abs ("_ec44");            // go check for special character codes
/* e7d4 */        _`_e7d4`;  AND.imm (0x7f);               // mask 0xxx xxxx, clear b7
/* e7d6 */                   CMP.imm (0x7f);               // was it $FF before the mask
/* e7d8 */                   BNE.rel ("_e7dc");            // branch if not
/* e7da */                   LDA.imm (0x5e);               // else make it $5E
/* e7dc */        _`_e7dc`;  CMP.imm (0x20);               // compare the character with [SPACE]
/* e7de */                   BCC.rel ("_e7e3");            // if < [SPACE] go ??
/* e7e0 */                   JMP.abs ("_e691");            // insert uppercase/graphic character and return
                                                           // character was $80 to $9F and is now $00 to $1F
/* e7e3 */        _`_e7e3`;  CMP.imm (0x0d);               // compare with [CR]
/* e7e5 */                   BNE.rel ("_e7ea");            // if not [CR] continue
/* e7e7 */                   JMP.abs ("_e891");            // else output [CR] and return
                                                           // was not [CR]
/* e7ea */        _`_e7ea`;  LDX.zpg ("qtsw_00d4");        // get the cursor quote flag, $xx = quote, $00 = no quote
/* e7ec */                   BNE.rel ("_e82d");            // branch if quote mode
/* e7ee */                   CMP.imm (0x14);               // compare with [INSERT DELETE]
/* e7f0 */                   BNE.rel ("_e829");            // if not [INSERT DELETE] go ??
/* e7f2 */                   LDY.zpg ("lnmx_00d5");        // get current screen line length
/* e7f4 */                   LDA.iny ("pnt+0_00d1");       // get character from current screen line
/* e7f6 */                   CMP.imm (0x20);               // compare the character with [SPACE]
/* e7f8 */                   BNE.rel ("_e7fe");            // if not [SPACE] continue
/* e7fa */                   CPY.zpg ("pntr_00d3");        // compare the current column with the cursor column
/* e7fc */                   BNE.rel ("_e805");            // if not cursor column go open up space on line
/* e7fe */        _`_e7fe`;  CPY.imm (0x4f);               // compare current column with max line length
/* e800 */                   BEQ.rel ("_e826");            // if at line end just exit
/* e802 */                   JSR.abs ("_e965");            // else open up a space on the screen
                                                           // now open up space on the line to insert a character
/* e805 */        _`_e805`;  LDY.zpg ("lnmx_00d5");        // get current screen line length
/* e807 */                   JSR.abs ("_ea24");            // calculate the pointer to colour RAM
/* e80a */        _`_e80a`;  DEY.imp ();                   // decrement the index to previous character
/* e80b */                   LDA.iny ("pnt+0_00d1");       // get the character from the current screen line
/* e80d */                   INY.imp ();                   // increment the index to next character
/* e80e */                   STA.iny ("pnt+0_00d1");       // save the character to the current screen line
/* e810 */                   DEY.imp ();                   // decrement the index to previous character
/* e811 */                   LDA.iny ("user+0_00f3");      // get the current screen line colour RAM byte
/* e813 */                   INY.imp ();                   // increment the index to next character
/* e814 */                   STA.iny ("user+0_00f3");      // save the current screen line colour RAM byte
/* e816 */                   DEY.imp ();                   // decrement the index to the previous character
/* e817 */                   CPY.zpg ("pntr_00d3");        // compare the index with the cursor column
/* e819 */                   BNE.rel ("_e80a");            // loop if not there yet
/* e81b */                   LDA.imm (0x20);               // set [SPACE]
/* e81d */                   STA.iny ("pnt+0_00d1");       // clear character at cursor position on current screen line
/* e81f */                   LDA.abs ("color_0286");       // get current colour code
/* e822 */                   STA.iny ("user+0_00f3");      // save to cursor position on current screen line colour RAM
/* e824 */                   INC.zpg ("insrt_00d8");       // increment insert count
/* e826 */        _`_e826`;  JMP.abs ("_e6a8");            // restore the registers, set the quote flag and exit
/* e829 */        _`_e829`;  LDX.zpg ("insrt_00d8");       // get the insert count
/* e82b */                   BEQ.rel ("_e832");            // branch if no insert space
/* e82d */        _`_e82d`;  ORA.imm (0x40);               // change to uppercase/graphic
/* e82f */                   JMP.abs ("_e697");            // insert reversed character
/* e832 */        _`_e832`;  CMP.imm (0x11);               // compare with [CURSOR UP]
/* e834 */                   BNE.rel ("_e84c");            // branch if not [CURSOR UP]
/* e836 */                   LDX.zpg ("tblx_00d6");        // get the cursor row
/* e838 */                   BEQ.rel ("_e871");            // if on the top line go restore the registers, set the
                                                           // quote flag and exit
/* e83a */                   DEC.zpg ("tblx_00d6");        // decrement the cursor row
/* e83c */                   LDA.zpg ("pntr_00d3");        // get the cursor column
/* e83e */                   SEC.imp ();                   // set carry for subtract
/* e83f */                   SBC.imm (0x28);               // subtract one line length
/* e841 */                   BCC.rel ("_e847");            // branch if stepped back to previous line
/* e843 */                   STA.zpg ("pntr_00d3");        // else save the cursor column ..
/* e845 */                   BPL.rel ("_e871");            // .. and exit, branch always
/* e847 */        _`_e847`;  JSR.abs ("_e56c");            // set the screen pointers for cursor row, column ..
/* e84a */                   BNE.rel ("_e871");            // .. and exit, branch always
/* e84c */        _`_e84c`;  CMP.imm (0x12);               // compare with [RVS OFF]
/* e84e */                   BNE.rel ("_e854");            // if not [RVS OFF] continue
/* e850 */                   LDA.imm (0x00);               // else clear A
/* e852 */                   STA.zpg ("rvs_00c7");         // clear the reverse flag
/* e854 */        _`_e854`;  CMP.imm (0x1d);               // compare with [CURSOR LEFT]
/* e856 */                   BNE.rel ("_e86a");            // if not [CURSOR LEFT] go ??
/* e858 */                   TYA.imp ();                   // copy the cursor column
/* e859 */                   BEQ.rel ("_e864");            // if at start of line go back onto the previous line
/* e85b */                   JSR.abs ("_e8a1");            // test for line decrement
/* e85e */                   DEY.imp ();                   // decrement the cursor column
/* e85f */                   STY.zpg ("pntr_00d3");        // save the cursor column
/* e861 */                   JMP.abs ("_e6a8");            // restore the registers, set the quote flag and exit
/* e864 */        _`_e864`;  JSR.abs ("_e701");            // back onto the previous line if possible
/* e867 */                   JMP.abs ("_e6a8");            // restore the registers, set the quote flag and exit
/* e86a */        _`_e86a`;  CMP.imm (0x13);               // compare with [CLR]
/* e86c */                   BNE.rel ("_e874");            // if not [CLR] continue
/* e86e */                   JSR.abs ("_e544");            // clear the screen
/* e871 */        _`_e871`;  JMP.abs ("_e6a8");            // restore the registers, set the quote flag and exit
/* e874 */        _`_e874`;  ORA.imm (0x80);               // restore b7, colour can only be black, cyan, magenta
                                                           // or yellow
/* e876 */                   JSR.abs ("_e8cb");            // set the colour code
/* e879 */                   JMP.abs ("_ec4f");            // go check for special character codes except fro switch
                                                           // to lower case

// ------------------------------------------------------- // do newline
/* e87c */        _`_e87c`;  LSR.zpg ("lxsp+0_00c9");      // shift >> input cursor row
/* e87e */                   LDX.zpg ("tblx_00d6");        // get the cursor row
/* e880 */        _`_e880`;  INX.imp ();                   // increment the row
/* e881 */                   CPX.imm (0x19);               // compare it with last row + 1
/* e883 */                   BNE.rel ("_e888");            // if not last row + 1 skip the screen scroll
/* e885 */                   JSR.abs ("_e8ea");            // else scroll the screen
/* e888 */        _`_e888`;  LDA.zpx (0xd9);               // get start of line X pointer high byte
/* e88a */                   BPL.rel ("_e880");            // loop if not start of logical line
/* e88c */                   STX.zpg ("tblx_00d6");        // save the cursor row
/* e88e */                   JMP.abs ("_e56c");            // set the screen pointers for cursor row, column and return

// ------------------------------------------------------- // output [CR]
/* e891 */        _`_e891`;  LDX.imm (0x00);               // clear X
/* e893 */                   STX.zpg ("insrt_00d8");       // clear the insert count
/* e895 */                   STX.zpg ("rvs_00c7");         // clear the reverse flag
/* e897 */                   STX.zpg ("qtsw_00d4");        // clear the cursor quote flag, $xx = quote, $00 = no quote
/* e899 */                   STX.zpg ("pntr_00d3");        // save the cursor column
/* e89b */                   JSR.abs ("_e87c");            // do newline
/* e89e */                   JMP.abs ("_e6a8");            // restore the registers, set the quote flag and exit

// ------------------------------------------------------- // test for line decrement
/* e8a1 */        _`_e8a1`;  LDX.imm (0x02);               // set the count
/* e8a3 */                   LDA.imm (0x00);               // set the column
/* e8a5 */        _`_e8a5`;  CMP.zpg ("pntr_00d3");        // compare the column with the cursor column
/* e8a7 */                   BEQ.rel ("_e8b0");            // if at the start of the line go decrement the cursor row
                                                           // and exit
/* e8a9 */                   CLC.imp ();                   // else clear carry for add
/* e8aa */                   ADC.imm (0x28);               // increment to next line
/* e8ac */                   DEX.imp ();                   // decrement loop count
/* e8ad */                   BNE.rel ("_e8a5");            // loop if more to test
/* e8af */                   RTS.imp ();
/* e8b0 */        _`_e8b0`;  DEC.zpg ("tblx_00d6");        // else decrement the cursor row
/* e8b2 */                   RTS.imp ();

// ------------------------------------------------------- // test for line increment

                                                           // if at end of the line, but not at end of the last line, increment the cursor row
/* e8b3 */        _`_e8b3`;  LDX.imm (0x02);               // set the count
/* e8b5 */                   LDA.imm (0x27);               // set the column
/* e8b7 */        _`_e8b7`;  CMP.zpg ("pntr_00d3");        // compare the column with the cursor column
/* e8b9 */                   BEQ.rel ("_e8c2");            // if at end of line test and possibly increment cursor row
/* e8bb */                   CLC.imp ();                   // else clear carry for add
/* e8bc */                   ADC.imm (0x28);               // increment to the next line
/* e8be */                   DEX.imp ();                   // decrement the loop count
/* e8bf */                   BNE.rel ("_e8b7");            // loop if more to test
/* e8c1 */                   RTS.imp ();
                                                           // cursor is at end of line
/* e8c2 */        _`_e8c2`;  LDX.zpg ("tblx_00d6");        // get the cursor row
/* e8c4 */                   CPX.imm (0x19);               // compare it with the end of the screen
/* e8c6 */                   BEQ.rel ("_e8ca");            // if at the end of screen just exit
/* e8c8 */                   INC.zpg ("tblx_00d6");        // else increment the cursor row
/* e8ca */        _`_e8ca`;  RTS.imp ();

// ------------------------------------------------------- // set the colour code. enter with the colour character in A. if A does not contain a
                                                           // colour character this routine exits without changing the colour
/* e8cb */        _`_e8cb`;  LDX.imm (0x0f);
                                                           // set the colour code count
/* e8cd */        _`_e8cd`;  CMP.abx ("_e8da");            // compare the character with a table code
/* e8d0 */                   BEQ.rel ("_e8d6");            // if a match go save the colour and exit
/* e8d2 */                   DEX.imp ();                   // else decrement the index
/* e8d3 */                   BPL.rel ("_e8cd");            // loop if more to do
/* e8d5 */                   RTS.imp ();
/* e8d6 */        _`_e8d6`;  STX.abs ("color_0286");       // save the current colour code
/* e8d9 */                   RTS.imp ();

// ------------------------------------------------------- // ASCII colour code table
                                                           // CHR$()  colour
                                                           // ------  ------
/* e8da */        _`_e8da`;  _.bytes(0x90);                //  144    black
/* e8db */                   _.bytes(0x05);                //    5    white 
/* e8dc */                   _.bytes(0x1c);                //   28    red 
/* e8dd */                   _.bytes(0x9f);                //  159    cyan
/* e8de */                   _.bytes(0x9c);                //  156    purple
/* e8df */                   _.bytes(0x1e);                //   30    green
/* e8e0 */                   _.bytes(0x1f);                //   31    blue
/* e8e1 */                   _.bytes(0x9e);                //  158    yellow
/* e8e2 */                   _.bytes(0x81);                //  129    orange
/* e8e3 */                   _.bytes(0x95);                //  149    brown
/* e8e4 */                   _.bytes(0x96);                //  150    light red
/* e8e5 */                   _.bytes(0x97);                //  151    dark grey
/* e8e6 */                   _.bytes(0x98);                //  152    medium grey
/* e8e7 */                   _.bytes(0x99);                //  153    light green
/* e8e8 */                   _.bytes(0x9a);                //  154    light blue
/* e8e9 */                   _.bytes(0x9b);                //  155    light grey

// ------------------------------------------------------- // scroll the screen
/* e8ea */        _`_e8ea`;  LDA.zpg ("sal+0_00ac");       // copy the tape buffer start pointer
/* e8ec */                   PHA.imp ();                   // save it
/* e8ed */                   LDA.zpg ("sal+1_00ad");       // copy the tape buffer start pointer
/* e8ef */                   PHA.imp ();                   // save it
/* e8f0 */                   LDA.zpg ("eal+0_00ae");       // copy the tape buffer end pointer
/* e8f2 */                   PHA.imp ();                   // save it
/* e8f3 */                   LDA.zpg ("eal+1_00af");       // copy the tape buffer end pointer
/* e8f5 */                   PHA.imp ();                   // save it
/* e8f6 */        _`_e8f6`;  LDX.imm (0xff);               // set to -1 for pre increment loop
/* e8f8 */                   DEC.zpg ("tblx_00d6");        // decrement the cursor row
/* e8fa */                   DEC.zpg ("lxsp+0_00c9");      // decrement the input cursor row
/* e8fc */                   DEC.abs ("tlnidx_02a5");      // decrement the screen row marker
/* e8ff */        _`_e8ff`;  INX.imp ();                   // increment the line number
/* e900 */                   JSR.abs ("_e9f0");            // fetch a screen address, set the start of line X
/* e903 */                   CPX.imm (0x18);               // compare with last line
/* e905 */                   BCS.rel ("_e913");            // branch if >= $16
/* e907 */                   LDA.abx (0xecf1);             // get the start of the next line pointer low byte
/* e90a */                   STA.zpg ("sal+0_00ac");       // save the next line pointer low byte
/* e90c */                   LDA.zpx (0xda);               // get the start of the next line pointer high byte
/* e90e */                   JSR.abs ("_e9c8");            // shift the screen line up
/* e911 */                   BMI.rel ("_e8ff");            // loop, branch always
/* e913 */        _`_e913`;  JSR.abs ("_e9ff");            // clear screen line X
                                                           // now shift up the start of logical line bits
/* e916 */                   LDX.imm (0x00);               // clear index
/* e918 */        _`_e918`;  LDA.zpx (0xd9);               // get the start of line X pointer high byte
/* e91a */                   AND.imm (0x7f);               // clear the line X start of logical line bit
/* e91c */                   LDY.zpx (0xda);               // get the start of the next line pointer high byte
/* e91e */                   BPL.rel ("_e922");            // if next line is not a start of line skip the start set
/* e920 */                   ORA.imm (0x80);               // set line X start of logical line bit
/* e922 */        _`_e922`;  STA.zpx (0xd9);               // set start of line X pointer high byte
/* e924 */                   INX.imp ();                   // increment line number
/* e925 */                   CPX.imm (0x18);               // compare with last line
/* e927 */                   BNE.rel ("_e918");            // loop if not last line
/* e929 */                   LDA.zpg ("ldtb1+24_00f1");    // get start of last line pointer high byte
/* e92b */                   ORA.imm (0x80);               // mark as start of logical line
/* e92d */                   STA.zpg ("ldtb1+24_00f1");    // set start of last line pointer high byte
/* e92f */                   LDA.zpg ("ldtb1+0_00d9");     // get start of first line pointer high byte
/* e931 */                   BPL.rel ("_e8f6");            // if not start of logical line loop back and
                                                           // scroll the screen up another line
/* e933 */                   INC.zpg ("tblx_00d6");        // increment the cursor row
/* e935 */                   INC.abs ("tlnidx_02a5");      // increment screen row marker
/* e938 */                   LDA.imm (0x7f);               // set keyboard column c7
/* e93a */                   STA.abs ("ciapra_dc00");      // save VIA 1 DRA, keyboard column drive
/* e93d */                   LDA.abs ("ciaprb_dc01");      // read VIA 1 DRB, keyboard row port
/* e940 */                   CMP.imm (0xfb);               // compare with row r2 active, [CTL]
/* e942 */                   PHP.imp ();                   // save status
/* e943 */                   LDA.imm (0x7f);               // set keyboard column c7
/* e945 */                   STA.abs ("ciapra_dc00");      // save VIA 1 DRA, keyboard column drive
/* e948 */                   PLP.imp ();                   // restore status
/* e949 */                   BNE.rel ("_e956");            // skip delay if ??
                                                           // first time round the inner loop X will be $16
/* e94b */                   LDY.imm (0x00);               // clear delay outer loop count, do this 256 times
/* e94d */        _`_e94d`;  NOP.imp ();                   // waste cycles
/* e94e */                   DEX.imp ();                   // decrement inner loop count
/* e94f */                   BNE.rel ("_e94d");            // loop if not all done
/* e951 */                   DEY.imp ();                   // decrement outer loop count
/* e952 */                   BNE.rel ("_e94d");            // loop if not all done
/* e954 */                   STY.zpg ("ndx_00c6");         // clear the keyboard buffer index
/* e956 */        _`_e956`;  LDX.zpg ("tblx_00d6");        // get the cursor row
                                                           // restore the tape buffer pointers and exit
/* e958 */        _`_e958`;  PLA.imp ();                   // pull tape buffer end pointer
/* e959 */                   STA.zpg ("eal+1_00af");       // restore it
/* e95b */                   PLA.imp ();                   // pull tape buffer end pointer
/* e95c */                   STA.zpg ("eal+0_00ae");       // restore it
/* e95e */                   PLA.imp ();                   // pull tape buffer pointer
/* e95f */                   STA.zpg ("sal+1_00ad");       // restore it
/* e961 */                   PLA.imp ();                   // pull tape buffer pointer
/* e962 */                   STA.zpg ("sal+0_00ac");       // restore it
/* e964 */                   RTS.imp ();

// ------------------------------------------------------- // open up a space on the screen
/* e965 */        _`_e965`;  LDX.zpg ("tblx_00d6");        // get the cursor row
/* e967 */        _`_e967`;  INX.imp ();                   // increment the row
/* e968 */                   LDA.zpx (0xd9);               // get the start of line X pointer high byte
/* e96a */                   BPL.rel ("_e967");            // loop if not start of logical line
/* e96c */                   STX.abs ("tlnidx_02a5");      // save the screen row marker
/* e96f */                   CPX.imm (0x18);               // compare it with the last line
/* e971 */                   BEQ.rel ("_e981");            // if = last line go ??
/* e973 */                   BCC.rel ("_e981");            // if < last line go ??
                                                           // else it was > last line
/* e975 */                   JSR.abs ("_e8ea");            // scroll the screen
/* e978 */                   LDX.abs ("tlnidx_02a5");      // get the screen row marker
/* e97b */                   DEX.imp ();                   // decrement the screen row marker
/* e97c */                   DEC.zpg ("tblx_00d6");        // decrement the cursor row
/* e97e */                   JMP.abs ("_e6da");            // add this row to the current logical line and return
/* e981 */        _`_e981`;  LDA.zpg ("sal+0_00ac");       // copy tape buffer pointer
/* e983 */                   PHA.imp ();                   // save it
/* e984 */                   LDA.zpg ("sal+1_00ad");       // copy tape buffer pointer
/* e986 */                   PHA.imp ();                   // save it
/* e987 */                   LDA.zpg ("eal+0_00ae");       // copy tape buffer end pointer
/* e989 */                   PHA.imp ();                   // save it
/* e98a */                   LDA.zpg ("eal+1_00af");       // copy tape buffer end pointer
/* e98c */                   PHA.imp ();                   // save it
/* e98d */                   LDX.imm (0x19);               // set to end line + 1 for predecrement loop
/* e98f */        _`_e98f`;  DEX.imp ();                   // decrement the line number
/* e990 */                   JSR.abs ("_e9f0");            // fetch a screen address
/* e993 */                   CPX.abs ("tlnidx_02a5");      // compare it with the screen row marker
/* e996 */                   BCC.rel ("_e9a6");            // if < screen row marker go ??
/* e998 */                   BEQ.rel ("_e9a6");            // if = screen row marker go ??
/* e99a */                   LDA.abx (0xecef);             // else get the start of the previous line low byte from the
                                                           // ROM table
/* e99d */                   STA.zpg ("sal+0_00ac");       // save previous line pointer low byte
/* e99f */                   LDA.zpx (0xd8);               // get the start of the previous line pointer high byte
/* e9a1 */                   JSR.abs ("_e9c8");            // shift the screen line down
/* e9a4 */                   BMI.rel ("_e98f");            // loop, branch always
/* e9a6 */        _`_e9a6`;  JSR.abs ("_e9ff");            // clear screen line X
/* e9a9 */                   LDX.imm (0x17);
/* e9ab */        _`_e9ab`;  CPX.abs ("tlnidx_02a5");      // compare it with the screen row marker
/* e9ae */                   BCC.rel ("_e9bf");
/* e9b0 */                   LDA.zpx (0xda);
/* e9b2 */                   AND.imm (0x7f);
/* e9b4 */                   LDY.zpx (0xd9);               // get start of line X pointer high byte
/* e9b6 */                   BPL.rel ("_e9ba");
/* e9b8 */                   ORA.imm (0x80);
/* e9ba */        _`_e9ba`;  STA.zpx (0xda);
/* e9bc */                   DEX.imp ();
/* e9bd */                   BNE.rel ("_e9ab");
/* e9bf */        _`_e9bf`;  LDX.abs ("tlnidx_02a5");      // get the screen row marker
/* e9c2 */                   JSR.abs ("_e6da");            // add this row to the current logical line
/* e9c5 */                   JMP.abs ("_e958");            // restore the tape buffer pointers and exit

// ------------------------------------------------------- // shift screen line up/down
/* e9c8 */        _`_e9c8`;  AND.imm (0x03);               // mask 0000 00xx, line memory page
/* e9ca */                   ORA.abs ("hibase_0288");      // OR with screen memory page
/* e9cd */                   STA.zpg ("sal+1_00ad");       // save next/previous line pointer high byte
/* e9cf */                   JSR.abs ("_e9e0");            // calculate pointers to screen lines colour RAM
/* e9d2 */                   LDY.imm (0x27);               // set the column count
/* e9d4 */        _`_e9d4`;  LDA.iny ("sal+0_00ac");       // get character from next/previous screen line
/* e9d6 */                   STA.iny ("pnt+0_00d1");       // save character to current screen line
/* e9d8 */                   LDA.iny ("eal+0_00ae");       // get colour from next/previous screen line colour RAM
/* e9da */                   STA.iny ("user+0_00f3");      // save colour to current screen line colour RAM
/* e9dc */                   DEY.imp ();                   // decrement column index/count
/* e9dd */                   BPL.rel ("_e9d4");            // loop if more to do
/* e9df */                   RTS.imp ();

// ------------------------------------------------------- // calculate pointers to screen lines colour RAM
/* e9e0 */        _`_e9e0`;  JSR.abs ("_ea24");            // calculate the pointer to the current screen line colour
                                                           // RAM
/* e9e3 */                   LDA.zpg ("sal+0_00ac");       // get the next screen line pointer low byte
/* e9e5 */                   STA.zpg ("eal+0_00ae");       // save the next screen line colour RAM pointer low byte
/* e9e7 */                   LDA.zpg ("sal+1_00ad");       // get the next screen line pointer high byte
/* e9e9 */                   AND.imm (0x03);               // mask 0000 00xx, line memory page
/* e9eb */                   ORA.imm (0xd8);               // set  1101 01xx, colour memory page
/* e9ed */                   STA.zpg ("eal+1_00af");       // save the next screen line colour RAM pointer high byte
/* e9ef */                   RTS.imp ();

// ------------------------------------------------------- // fetch a screen address
/* e9f0 */        _`_e9f0`;  LDA.abx ("_ecf0");            // get the start of line low byte from the ROM table
/* e9f3 */                   STA.zpg ("pnt+0_00d1");       // set the current screen line pointer low byte
/* e9f5 */                   LDA.zpx (0xd9);               // get the start of line high byte from the RAM table
/* e9f7 */                   AND.imm (0x03);               // mask 0000 00xx, line memory page
/* e9f9 */                   ORA.abs ("hibase_0288");      // OR with the screen memory page
/* e9fc */                   STA.zpg ("pnt+1_00d2");       // save the current screen line pointer high byte
/* e9fe */                   RTS.imp ();

// ------------------------------------------------------- // clear screen line X
/* e9ff */        _`_e9ff`;  LDY.imm (0x27);               // set number of columns to clear
/* ea01 */                   JSR.abs ("_e9f0");            // fetch a screen address
/* ea04 */                   JSR.abs ("_ea24");            // calculate the pointer to colour RAM
/* ea07 */        _`_ea07`;  JSR.abs ("_e4da");            // save the current colour to the colour RAM
/* ea0a */                   LDA.imm (0x20);               // set [SPACE]
/* ea0c */                   STA.iny ("pnt+0_00d1");       // clear character in current screen line
/* ea0e */                   DEY.imp ();                   // decrement index
/* ea0f */                   BPL.rel ("_ea07");            // loop if more to do
/* ea11 */                   RTS.imp ();

// ------------------------------------------------------- // orphan byte
/* ea12 */                   NOP.imp ();                   // unused

// ------------------------------------------------------- // print character A and colour X
/* ea13 */        _`_ea13`;  TAY.imp ();                   // copy the character
/* ea14 */                   LDA.imm (0x02);               // count to $02, usually $14 ??
/* ea16 */                   STA.zpg ("blnct_00cd");       // save the cursor countdown
/* ea18 */                   JSR.abs ("_ea24");            // calculate the pointer to colour RAM
/* ea1b */                   TYA.imp ();                   // get the character back

// ------------------------------------------------------- // save the character and colour to the screen @ the cursor
/* ea1c */        _`_ea1c`;  LDY.zpg ("pntr_00d3");        // get the cursor column
/* ea1e */                   STA.iny ("pnt+0_00d1");       // save the character from current screen line
/* ea20 */                   TXA.imp ();                   // copy the colour to A
/* ea21 */                   STA.iny ("user+0_00f3");      // save to colour RAM
/* ea23 */                   RTS.imp ();

// ------------------------------------------------------- // calculate the pointer to colour RAM
/* ea24 */        _`_ea24`;  LDA.zpg ("pnt+0_00d1");       // get current screen line pointer low byte
/* ea26 */                   STA.zpg ("user+0_00f3");      // save pointer to colour RAM low byte
/* ea28 */                   LDA.zpg ("pnt+1_00d2");       // get current screen line pointer high byte
/* ea2a */                   AND.imm (0x03);               // mask 0000 00xx, line memory page
/* ea2c */                   ORA.imm (0xd8);               // set  1101 01xx, colour memory page
/* ea2e */                   STA.zpg ("user+1_00f4");      // save pointer to colour RAM high byte
/* ea30 */                   RTS.imp ();

// ------------------------------------------------------- // IRQ vector
/* ea31 */                   JSR.abs ("udtim_ffea");       // increment the real time clock
/* ea34 */                   LDA.zpg ("blnsw_00cc");       // get the cursor enable, $00 = flash cursor
/* ea36 */                   BNE.rel ("_ea61");            // if flash not enabled skip the flash
/* ea38 */                   DEC.zpg ("blnct_00cd");       // decrement the cursor timing countdown
/* ea3a */                   BNE.rel ("_ea61");            // if not counted out skip the flash
/* ea3c */                   LDA.imm (0x14);               // set the flash count
/* ea3e */                   STA.zpg ("blnct_00cd");       // save the cursor timing countdown
/* ea40 */                   LDY.zpg ("pntr_00d3");        // get the cursor column
/* ea42 */                   LSR.zpg ("blnon_00cf");       // shift b0 cursor blink phase into carry
/* ea44 */                   LDX.abs ("gdcol_0287");       // get the colour under the cursor
/* ea47 */                   LDA.iny ("pnt+0_00d1");       // get the character from current screen line
/* ea49 */                   BCS.rel ("_ea5c");            // branch if cursor phase b0 was 1
/* ea4b */                   INC.zpg ("blnon_00cf");       // set the cursor blink phase to 1
/* ea4d */                   STA.zpg ("gdbln_00ce");       // save the character under the cursor
/* ea4f */                   JSR.abs ("_ea24");            // calculate the pointer to colour RAM
/* ea52 */                   LDA.iny ("user+0_00f3");      // get the colour RAM byte
/* ea54 */                   STA.abs ("gdcol_0287");       // save the colour under the cursor
/* ea57 */                   LDX.abs ("color_0286");       // get the current colour code
/* ea5a */                   LDA.zpg ("gdbln_00ce");       // get the character under the cursor
/* ea5c */        _`_ea5c`;  EOR.imm (0x80);               // toggle b7 of character under cursor
/* ea5e */                   JSR.abs ("_ea1c");            // save the character and colour to the screen @ the cursor
/* ea61 */        _`_ea61`;  LDA.zpg ("r6510_0001");       // read the 6510 I/O port
/* ea63 */                   AND.imm (0x10);               // mask 000x 0000, the cassette switch sense
/* ea65 */                   BEQ.rel ("_ea71");            // if the cassette sense is low skip the motor stop
                                                           // the cassette sense was high, the switch was open, so turn
                                                           // off the motor and clear the interlock
/* ea67 */                   LDY.imm (0x00);               // clear Y
/* ea69 */                   STY.zpg ("cas1_00c0");        // clear the tape motor interlock
/* ea6b */                   LDA.zpg ("r6510_0001");       // read the 6510 I/O port
/* ea6d */                   ORA.imm (0x20);               // mask xxxx xx1x, turn off the motor
/* ea6f */                   BNE.rel ("_ea79");            // go save the port value, branch always
                                                           // the cassette sense was low so turn the motor on, perhaps
/* ea71 */        _`_ea71`;  LDA.zpg ("cas1_00c0");        // get the tape motor interlock
/* ea73 */                   BNE.rel ("_ea7b");            // if the cassette interlock <> 0 don't turn on motor
/* ea75 */                   LDA.zpg ("r6510_0001");       // read the 6510 I/O port
/* ea77 */                   AND.imm (0x1f);               // mask xxxx xx0x, turn on the motor
/* ea79 */        _`_ea79`;  STA.zpg ("r6510_0001");       // save the 6510 I/O port
/* ea7b */        _`_ea7b`;  JSR.abs ("scnkey_ea87");      // scan the keyboard
/* ea7e */                   LDA.abs ("ciaicr_dc0d");      // read VIA 1 ICR, clear the timer interrupt flag
/* ea81 */                   PLA.imp ();                   // pull Y
/* ea82 */                   TAY.imp ();                   // restore Y
/* ea83 */                   PLA.imp ();                   // pull X
/* ea84 */                   TAX.imp ();                   // restore X
/* ea85 */                   PLA.imp ();                   // restore A
/* ea86 */                   RTI.imp ();

// ------------------------------------------------------- // scan keyboard performs the following ..

                                                           // 1) check if key pressed, if not then exit the routine

                                                           // 2) init I/O ports of VIA ?? for keyboard scan and set pointers to decode table 1.
                                                           // clear the character counter

                                                           // 3) set one line of port B low and test for a closed key on port A by shifting the
                                                           // byte read from the port. if the carry is clear then a key is closed so save the
                                                           // count which is incremented on each shift. check for shift/stop/cbm keys and
                                                           // flag if closed

                                                           // 4) repeat step 3 for the whole matrix

                                                           // 5) evaluate the SHIFT/CTRL/C= keys, this may change the decode table selected

                                                           // 6) use the key count saved in step 3 as an index into the table selected in step 5

                                                           // 7) check for key repeat operation

                                                           // 8) save the decoded key to the buffer if first press or repeat
                                                           // scan the keyboard
/* ea87 */  _`scnkey_ea87`;  LDA.imm (0x00);               // clear A
/* ea89 */                   STA.abs ("shflag_028d");      // clear the keyboard shift/control/c= flag
/* ea8c */                   LDY.imm (0x40);               // set no key
/* ea8e */                   STY.zpg ("sfdx_00cb");        // save which key
/* ea90 */                   STA.abs ("ciapra_dc00");      // clear VIA 1 DRA, keyboard column drive
/* ea93 */                   LDX.abs ("ciaprb_dc01");      // read VIA 1 DRB, keyboard row port
/* ea96 */                   CPX.imm (0xff);               // compare with all bits set
/* ea98 */                   BEQ.rel ("_eafb");            // if no key pressed clear current key and exit (does
                                                           // further BEQ to $EBBA)
/* ea9a */                   TAY.imp ();                   // clear the key count
/* ea9b */                   LDA.imm (0x81);               // get the decode table low byte
/* ea9d */                   STA.zpg ("keytab+0_00f5");    // save the keyboard pointer low byte
/* ea9f */                   LDA.imm (0xeb);               // get the decode table high byte
/* eaa1 */                   STA.zpg ("keytab+1_00f6");    // save the keyboard pointer high byte
/* eaa3 */                   LDA.imm (0xfe);               // set column 0 low
/* eaa5 */                   STA.abs ("ciapra_dc00");      // save VIA 1 DRA, keyboard column drive
/* eaa8 */        _`_eaa8`;  LDX.imm (0x08);               // set the row count
/* eaaa */                   PHA.imp ();                   // save the column
/* eaab */        _`_eaab`;  LDA.abs ("ciaprb_dc01");      // read VIA 1 DRB, keyboard row port
/* eaae */                   CMP.abs ("ciaprb_dc01");      // compare it with itself
/* eab1 */                   BNE.rel ("_eaab");            // loop if changing
/* eab3 */        _`_eab3`;  LSR.acc ();                   // shift row to Cb
/* eab4 */                   BCS.rel ("_eacc");            // if no key closed on this row go do next row
/* eab6 */                   PHA.imp ();                   // save row
/* eab7 */                   LDA.iny ("keytab+0_00f5");    // get character from decode table
/* eab9 */                   CMP.imm (0x05);               // compare with $05, there is no $05 key but the control
                                                           // keys are all less than $05
/* eabb */                   BCS.rel ("_eac9");            // if not shift/control/c=/stop go save key count
                                                           // else was shift/control/c=/stop key
/* eabd */                   CMP.imm (0x03);               // compare with $03, stop
/* eabf */                   BEQ.rel ("_eac9");            // if stop go save key count and continue
                                                           // character is $01 - shift, $02 - c= or $04 - control
/* eac1 */                   ORA.abs ("shflag_028d");      // OR it with the keyboard shift/control/c= flag
/* eac4 */                   STA.abs ("shflag_028d");      // save the keyboard shift/control/c= flag
/* eac7 */                   BPL.rel ("_eacb");            // skip save key, branch always
/* eac9 */        _`_eac9`;  STY.zpg ("sfdx_00cb");        // save key count
/* eacb */        _`_eacb`;  PLA.imp ();                   // restore row
/* eacc */        _`_eacc`;  INY.imp ();                   // increment key count
/* eacd */                   CPY.imm (0x41);               // compare with max+1
/* eacf */                   BCS.rel ("_eadc");            // exit loop if >= max+1
                                                           // else still in matrix
/* ead1 */                   DEX.imp ();                   // decrement row count
/* ead2 */                   BNE.rel ("_eab3");            // loop if more rows to do
/* ead4 */                   SEC.imp ();                   // set carry for keyboard column shift
/* ead5 */                   PLA.imp ();                   // restore the column
/* ead6 */                   ROL.acc ();                   // shift the keyboard column
/* ead7 */                   STA.abs ("ciapra_dc00");      // save VIA 1 DRA, keyboard column drive
/* eada */                   BNE.rel ("_eaa8");            // loop for next column, branch always
/* eadc */        _`_eadc`;  PLA.imp ();                   // dump the saved column
/* eadd */                   JMP.ind ("keylog+0_028f");    // evaluate the SHIFT/CTRL/C= keys, $EBDC
                                                           // key decoding continues here after the SHIFT/CTRL/C= keys are evaluated
/* eae0 */        _`_eae0`;  LDY.zpg ("sfdx_00cb");        // get saved key count
/* eae2 */                   LDA.iny ("keytab+0_00f5");    // get character from decode table
/* eae4 */                   TAX.imp ();                   // copy character to X
/* eae5 */                   CPY.zpg ("lstx_00c5");        // compare key count with last key count
/* eae7 */                   BEQ.rel ("_eaf0");            // if this key = current key, key held, go test repeat
/* eae9 */                   LDY.imm (0x10);               // set the repeat delay count
/* eaeb */                   STY.abs ("delay_028c");       // save the repeat delay count
/* eaee */                   BNE.rel ("_eb26");            // go save key to buffer and exit, branch always
/* eaf0 */        _`_eaf0`;  AND.imm (0x7f);               // clear b7
/* eaf2 */                   BIT.abs ("rptflg_028a");      // test key repeat
/* eaf5 */                   BMI.rel ("_eb0d");            // if repeat all go ??
/* eaf7 */                   BVS.rel ("_eb42");            // if repeat none go ??
/* eaf9 */                   CMP.imm (0x7f);               // compare with end marker
/* eafb */        _`_eafb`;  BEQ.rel ("_eb26");            // if $00/end marker go save key to buffer and exit
/* eafd */                   CMP.imm (0x14);               // compare with [INSERT]/[DELETE]
/* eaff */                   BEQ.rel ("_eb0d");            // if [INSERT]/[DELETE] go test for repeat
/* eb01 */                   CMP.imm (0x20);               // compare with [SPACE]
/* eb03 */                   BEQ.rel ("_eb0d");            // if [SPACE] go test for repeat
/* eb05 */                   CMP.imm (0x1d);               // compare with [CURSOR RIGHT]
/* eb07 */                   BEQ.rel ("_eb0d");            // if [CURSOR RIGHT] go test for repeat
/* eb09 */                   CMP.imm (0x11);               // compare with [CURSOR DOWN]
/* eb0b */                   BNE.rel ("_eb42");            // if not [CURSOR DOWN] just exit
                                                           // was one of the cursor movement keys, insert/delete
                                                           // key or the space bar so always do repeat tests
/* eb0d */        _`_eb0d`;  LDY.abs ("delay_028c");       // get the repeat delay counter
/* eb10 */                   BEQ.rel ("_eb17");            // if delay expired go ??
/* eb12 */                   DEC.abs ("delay_028c");       // else decrement repeat delay counter
/* eb15 */                   BNE.rel ("_eb42");            // if delay not expired go ??
                                                           // repeat delay counter has expired
/* eb17 */        _`_eb17`;  DEC.abs ("kount_028b");       // decrement the repeat speed counter
/* eb1a */                   BNE.rel ("_eb42");            // branch if repeat speed count not expired
/* eb1c */                   LDY.imm (0x04);               // set for 4/60ths of a second
/* eb1e */                   STY.abs ("kount_028b");       // save the repeat speed counter
/* eb21 */                   LDY.zpg ("ndx_00c6");         // get the keyboard buffer index
/* eb23 */                   DEY.imp ();                   // decrement it
/* eb24 */                   BPL.rel ("_eb42");            // if the buffer isn't empty just exit
                                                           // else repeat the key immediately
                                                           // possibly save the key to the keyboard buffer. if there was no key pressed or the key
                                                           // was not found during the scan (possibly due to key bounce) then X will be $FF here
/* eb26 */        _`_eb26`;  LDY.zpg ("sfdx_00cb");        // get the key count
/* eb28 */                   STY.zpg ("lstx_00c5");        // save it as the current key count
/* eb2a */                   LDY.abs ("shflag_028d");      // get the keyboard shift/control/c= flag
/* eb2d */                   STY.abs ("lstshf_028e");      // save it as last keyboard shift pattern
/* eb30 */                   CPX.imm (0xff);               // compare the character with the table end marker or no key
/* eb32 */                   BEQ.rel ("_eb42");            // if it was the table end marker or no key just exit
/* eb34 */                   TXA.imp ();                   // copy the character to A
/* eb35 */                   LDX.zpg ("ndx_00c6");         // get the keyboard buffer index
/* eb37 */                   CPX.abs ("xmax_0289");        // compare it with the keyboard buffer size
/* eb3a */                   BCS.rel ("_eb42");            // if the buffer is full just exit
/* eb3c */                   STA.abx ("keyd+0_0277");      // save the character to the keyboard buffer
/* eb3f */                   INX.imp ();                   // increment the index
/* eb40 */                   STX.zpg ("ndx_00c6");         // save the keyboard buffer index
/* eb42 */        _`_eb42`;  LDA.imm (0x7f);               // enable column 7 for the stop key
/* eb44 */                   STA.abs ("ciapra_dc00");      // save VIA 1 DRA, keyboard column drive
/* eb47 */                   RTS.imp ();

// ------------------------------------------------------- // evaluate the SHIFT/CTRL/C= keys
/* eb48 */                   LDA.abs ("shflag_028d");      // get the keyboard shift/control/c= flag
/* eb4b */                   CMP.imm (0x03);               // compare with [SHIFT][C=]
/* eb4d */                   BNE.rel ("_eb64");            // if not [SHIFT][C=] go ??
/* eb4f */                   CMP.abs ("lstshf_028e");      // compare with last
/* eb52 */                   BEQ.rel ("_eb42");            // exit if still the same
/* eb54 */                   LDA.abs ("mode_0291");        // get the shift mode switch $00 = enabled, $80 = locked
/* eb57 */                   BMI.rel ("_eb76");            // if locked continue keyboard decode
                                                           // toggle text mode
/* eb59 */                   LDA.abs ("vmcsb_d018");       // get the start of character memory address
/* eb5c */                   EOR.imm (0x02);               // toggle address b1
/* eb5e */                   STA.abs ("vmcsb_d018");       // save the start of character memory address
/* eb61 */                   JMP.abs ("_eb76");            // continue the keyboard decode
                                                           // select keyboard table
/* eb64 */        _`_eb64`;  ASL.acc ();                   // << 1
/* eb65 */                   CMP.imm (0x08);               // compare with [CTRL]
/* eb67 */                   BCC.rel ("_eb6b");            // if [CTRL] is not pressed skip the index change
/* eb69 */                   LDA.imm (0x06);               // else [CTRL] was pressed so make the index = $06
/* eb6b */        _`_eb6b`;  TAX.imp ();                   // copy the index to X
/* eb6c */                   LDA.abx ("_eb79");            // get the decode table pointer low byte
/* eb6f */                   STA.zpg ("keytab+0_00f5");    // save the decode table pointer low byte
/* eb71 */                   LDA.abx (0xeb7a);             // get the decode table pointer high byte
/* eb74 */                   STA.zpg ("keytab+1_00f6");    // save the decode table pointer high byte
/* eb76 */        _`_eb76`;  JMP.abs ("_eae0");            // continue the keyboard decode

// ------------------------------------------------------- // table addresses
/* eb79 */        _`_eb79`;  _.bytes(0x81, 0xeb);          // standard
/* eb7b */                   _.bytes(0xc2, 0xeb);          // shift
/* eb7d */                   _.bytes(0x03, 0xec);          // commodore
/* eb7f */                   _.bytes(0x78, 0xec);          // control

// ------------------------------------------------------- // standard keyboard table
/* eb81 */                   _.bytes(0x14, 0x0d, 0x1d, 0x88, 0x85, 0x86, 0x87, 0x11);
/* eb89 */                   _.bytes(0x33, 0x57, 0x41, 0x34, 0x5a, 0x53, 0x45, 0x01);
/* eb91 */                   _.bytes(0x35, 0x52, 0x44, 0x36, 0x43, 0x46, 0x54, 0x58);
/* eb99 */                   _.bytes(0x37, 0x59, 0x47, 0x38, 0x42, 0x48, 0x55, 0x56);
/* eba1 */                   _.bytes(0x39, 0x49, 0x4a, 0x30, 0x4d, 0x4b, 0x4f, 0x4e);
/* eba9 */                   _.bytes(0x2b, 0x50, 0x4c, 0x2d, 0x2e, 0x3a, 0x40, 0x2c);
/* ebb1 */                   _.bytes(0x5c, 0x2a, 0x3b, 0x13, 0x01, 0x3d, 0x5e, 0x2f);
/* ebb9 */                   _.bytes(0x31, 0x5f, 0x04, 0x32, 0x20, 0x02, 0x51, 0x03);
/* ebc1 */                   _.bytes(0xff);
// ------------------------------------------------------- // shifted keyboard table
/* ebc2 */                   _.bytes(0x94, 0x8d, 0x9d, 0x8c, 0x89, 0x8a, 0x8b, 0x91);
/* ebca */                   _.bytes(0x23, 0xd7, 0xc1, 0x24, 0xda, 0xd3, 0xc5, 0x01);
/* ebd2 */                   _.bytes(0x25, 0xd2, 0xc4, 0x26, 0xc3, 0xc6, 0xd4, 0xd8);
/* ebda */                   _.bytes(0x27, 0xd9, 0xc7, 0x28, 0xc2, 0xc8, 0xd5, 0xd6);
/* ebe2 */                   _.bytes(0x29, 0xc9, 0xca, 0x30, 0xcd, 0xcb, 0xcf, 0xce);
/* ebea */                   _.bytes(0xdb, 0xd0, 0xcc, 0xdd, 0x3e, 0x5b, 0xba, 0x3c);
/* ebf2 */                   _.bytes(0xa9, 0xc0, 0x5d, 0x93, 0x01, 0x3d, 0xde, 0x3f);
/* ebfa */                   _.bytes(0x21, 0x5f, 0x04, 0x22, 0xa0, 0x02, 0xd1, 0x83);
/* ec02 */                   _.bytes(0xff);
// ------------------------------------------------------- // CBM key keyboard table
/* ec03 */                   _.bytes(0x94, 0x8d, 0x9d, 0x8c, 0x89, 0x8a, 0x8b, 0x91);
/* ec0b */                   _.bytes(0x96, 0xb3, 0xb0, 0x97, 0xad, 0xae, 0xb1, 0x01);
/* ec13 */                   _.bytes(0x98, 0xb2, 0xac, 0x99, 0xbc, 0xbb, 0xa3, 0xbd);
/* ec1b */                   _.bytes(0x9a, 0xb7, 0xa5, 0x9b, 0xbf, 0xb4, 0xb8, 0xbe);
/* ec23 */                   _.bytes(0x29, 0xa2, 0xb5, 0x30, 0xa7, 0xa1, 0xb9, 0xaa);
/* ec2b */                   _.bytes(0xa6, 0xaf, 0xb6, 0xdc, 0x3e, 0x5b, 0xa4, 0x3c);
/* ec33 */                   _.bytes(0xa8, 0xdf, 0x5d, 0x93, 0x01, 0x3d, 0xde, 0x3f);
/* ec3b */                   _.bytes(0x81, 0x5f, 0x04, 0x95, 0xa0, 0x02, 0xab, 0x83);
/* ec43 */                   _.bytes(0xff);

// ------------------------------------------------------- // check for special character codes
/* ec44 */        _`_ec44`;  CMP.imm (0x0e);               // compare with [SWITCH TO LOWER CASE]
/* ec46 */                   BNE.rel ("_ec4f");            // if not [SWITCH TO LOWER CASE] skip the switch
/* ec48 */                   LDA.abs ("vmcsb_d018");       // get the start of character memory address
/* ec4b */                   ORA.imm (0x02);               // mask xxxx xx1x, set lower case characters
/* ec4d */                   BNE.rel ("_ec58");            // go save the new value, branch always
                                                           // check for special character codes except fro switch to lower case
/* ec4f */        _`_ec4f`;  CMP.imm (0x8e);               // compare with [SWITCH TO UPPER CASE]
/* ec51 */                   BNE.rel ("_ec5e");            // if not [SWITCH TO UPPER CASE] go do the [SHIFT]+[C=] key
                                                           // check
/* ec53 */                   LDA.abs ("vmcsb_d018");       // get the start of character memory address
/* ec56 */                   AND.imm (0xfd);               // mask xxxx xx0x, set upper case characters
/* ec58 */        _`_ec58`;  STA.abs ("vmcsb_d018");       // save the start of character memory address
/* ec5b */        _`_ec5b`;  JMP.abs ("_e6a8");            // restore the registers, set the quote flag and exit
                                                           // do the [SHIFT]+[C=] key check
/* ec5e */        _`_ec5e`;  CMP.imm (0x08);               // compare with disable [SHIFT][C=]
/* ec60 */                   BNE.rel ("_ec69");            // if not disable [SHIFT][C=] skip the set
/* ec62 */                   LDA.imm (0x80);               // set to lock shift mode switch
/* ec64 */                   ORA.abs ("mode_0291");        // OR it with the shift mode switch
/* ec67 */                   BMI.rel ("_ec72");            // go save the value, branch always
/* ec69 */        _`_ec69`;  CMP.imm (0x09);               // compare with enable [SHIFT][C=]
/* ec6b */                   BNE.rel ("_ec5b");            // exit if not enable [SHIFT][C=]
/* ec6d */                   LDA.imm (0x7f);               // set to unlock shift mode switch
/* ec6f */                   AND.abs ("mode_0291");        // AND it with the shift mode switch
/* ec72 */        _`_ec72`;  STA.abs ("mode_0291");        // save the shift mode switch $00 = enabled, $80 = locked
/* ec75 */                   JMP.abs ("_e6a8");            // restore the registers, set the quote flag and exit

// ------------------------------------------------------- // control keyboard table
/* ec78 */                   _.bytes(0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff);
/* ec80 */                   _.bytes(0x1c, 0x17, 0x01, 0x9f, 0x1a, 0x13, 0x05, 0xff);
/* ec88 */                   _.bytes(0x9c, 0x12, 0x04, 0x1e, 0x03, 0x06, 0x14, 0x18);
/* ec90 */                   _.bytes(0x1f, 0x19, 0x07, 0x9e, 0x02, 0x08, 0x15, 0x16);
/* ec98 */                   _.bytes(0x12, 0x09, 0x0a, 0x92, 0x0d, 0x0b, 0x0f, 0x0e);
/* eca0 */                   _.bytes(0xff, 0x10, 0x0c, 0xff, 0xff, 0x1b, 0x00, 0xff);
/* eca8 */                   _.bytes(0x1c, 0xff, 0x1d, 0xff, 0xff, 0x1f, 0x1e, 0xff);
/* ecb0 */                   _.bytes(0x90, 0x06, 0xff, 0x05, 0xff, 0xff, 0x11, 0xff);
/* ecb8 */        _`_ecb8`;  _.bytes(0xff);

// ------------------------------------------------------- // vic ii chip initialisation values
/* ecb9 */                   _.bytes(0x00, 0x00);          // sprite 0 x,y
/* ecbb */                   _.bytes(0x00, 0x00);          // sprite 1 x,y 
/* ecbd */                   _.bytes(0x00, 0x00);          // sprite 2 x,y 
/* ecbf */                   _.bytes(0x00, 0x00);          // sprite 3 x,y
/* ecc1 */                   _.bytes(0x00, 0x00);          // sprite 4 x,y 
/* ecc3 */                   _.bytes(0x00, 0x00);          // sprite 5 x,y 
/* ecc5 */                   _.bytes(0x00, 0x00);          // sprite 6 x,y 
/* ecc7 */                   _.bytes(0x00, 0x00);          // sprite 7 x,y
/* ecc9 */                   _.bytes(0x00);                // sprites 0 to 7 x bit 8
/* ecca */                   _.bytes(0x9b);                // enable screen, enable 25 rows
                                                           // vertical fine scroll and control
                                                           // bit function
                                                           // --- -------
                                                           //  7  raster compare bit 8
                                                           //  6  1 = enable extended color text mode
                                                           //  5  1 = enable bitmap graphics mode
                                                           //  4  1 = enable screen, 0 = blank screen
                                                           //  3  1 = 25 row display, 0 = 24 row display
                                                           // 2-0 vertical scroll count
/* eccb */                   _.bytes(0x37);                // raster compare
/* eccc */                   _.bytes(0x00);                // light pen x
/* eccd */                   _.bytes(0x00);                // light pen y
/* ecce */                   _.bytes(0x00);                // sprite 0 to 7 enable
/* eccf */                   _.bytes(0x08);                // enable 40 column display
                                                           // horizontal fine scroll and control
                                                           // bit function
                                                           // --- -------
                                                           // 7-6 unused
                                                           //  5  1 = vic reset, 0 = vic on
                                                           //  4  1 = enable multicolor mode
                                                           //  3  1 = 40 column display, 0 = 38 column display
                                                           // 2-0 horizontal scroll count
/* ecd0 */                   _.bytes(0x00);                // sprite 0 to 7 y expand
/* ecd1 */                   _.bytes(0x14);                // memory control
                                                           // bit function
                                                           // --- -------
                                                           // 7-4 video matrix base address
                                                           // 3-1 character data base address
                                                           //  0  unused
/* ecd2 */                   _.bytes(0x0f);                // clear all interrupts
                                                           // interrupt flags
                                                           //  7 1 = interrupt
                                                           // 6-4 unused
                                                           //  3  1 = light pen interrupt
                                                           //  2  1 = sprite to sprite collision interrupt
                                                           //  1  1 = sprite to foreground collision interrupt
                                                           //  0  1 = raster compare interrupt
/* ecd3 */                   _.bytes(0x00);                // all vic IRQs disabeld
                                                           // IRQ enable
                                                           // bit function
                                                           // --- -------
                                                           // 7-4 unused
                                                           //  3  1 = enable light pen
                                                           //  2  1 = enable sprite to sprite collision
                                                           //  1  1 = enable sprite to foreground collision
                                                           //  0  1 = enable raster compare
/* ecd4 */                   _.bytes(0x00);                // sprite 0 to 7 foreground priority
/* ecd5 */                   _.bytes(0x00);                // sprite 0 to 7 multicolour
/* ecd6 */                   _.bytes(0x00);                // sprite 0 to 7 x expand
/* ecd7 */                   _.bytes(0x00);                // sprite 0 to 7 sprite collision
/* ecd8 */                   _.bytes(0x00);                // sprite 0 to 7 foreground collision
/* ecd9 */                   _.bytes(0x0e);                // border colour
/* ecda */                   _.bytes(0x06);                // background colour 0
/* ecdb */                   _.bytes(0x01);                // background colour 1
/* ecdc */                   _.bytes(0x02);                // background colour 2
/* ecdd */                   _.bytes(0x03);                // background colour 3
/* ecde */                   _.bytes(0x04);                // sprite multicolour 0
/* ecdf */                   _.bytes(0x00);                // sprite multicolour 1
/* ece0 */                   _.bytes(0x01);                // sprite 0 colour
/* ece1 */                   _.bytes(0x02);                // sprite 1 colour
/* ece2 */                   _.bytes(0x03);                // sprite 2 colour
/* ece3 */                   _.bytes(0x04);                // sprite 3 colour
/* ece4 */                   _.bytes(0x05);                // sprite 4 colour
/* ece5 */                   _.bytes(0x06);                // sprite 5 colour
/* ece6 */        _`_ece6`;  _.bytes(0x07);                // sprite 6 colour
                                                           // sprite 7 colour is actually the first character of "LOAD" ($4C)

// ------------------------------------------------------- // keyboard buffer for auto load/run
/* ece7 */                   _.bytes(0x4c, 0x4f, 0x41);    // 'load (cr) run (cr)'
/* ecea */                   _.bytes(0x44, 0x0d, 0x52, 0x55, 0x4e, 0x0d);

// ------------------------------------------------------- // low bytes of screen line addresses
/* ecf0 */        _`_ecf0`;  _.bytes(0x00, 0x28, 0x50, 0x78, 0xa0, 0xc8, 0xf0, 0x18);
/* ecf8 */                   _.bytes(0x40, 0x68, 0x90, 0xb8, 0xe0, 0x08, 0x30, 0x58);
/* ed00 */                   _.bytes(0x80, 0xa8, 0xd0, 0xf8, 0x20, 0x48, 0x70, 0x98);
/* ed08 */                   _.bytes(0xc0);

// ------------------------------------------------------- // command serial bus device to TALK
/* ed09 */    _`talk_ed09`;  ORA.imm (0x40);               // OR with the TALK command
/* ed0b */                   _.bytes(0x2c);                // makes next line BIT $2009

// ------------------------------------------------------- // command devices on the serial bus to LISTEN
/* ed0c */  _`listen_ed0c`;  ORA.imm (0x20);               // OR with the LISTEN command
/* ed0e */                   JSR.abs ("_f0a4");            // check RS232 bus idle

// ------------------------------------------------------- // send a control character
/* ed11 */        _`_ed11`;  PHA.imp ();                   // save device address
/* ed12 */                   BIT.zpg ("c3po_0094");        // test deferred character flag
/* ed14 */                   BPL.rel ("_ed20");            // if no defered character continue
/* ed16 */                   SEC.imp ();                   // else flag EOI
/* ed17 */                   ROR.zpg ("tsfcnt_00a3");      // rotate into EOI flag byte
/* ed19 */                   JSR.abs ("_ed40");            // Tx byte on serial bus
/* ed1c */                   LSR.zpg ("c3po_0094");        // clear deferred character flag
/* ed1e */                   LSR.zpg ("tsfcnt_00a3");      // clear EOI flag
/* ed20 */        _`_ed20`;  PLA.imp ();                   // restore the device address

// ------------------------------------------------------- // defer a command
/* ed21 */                   STA.zpg ("bsour_0095");       // save as serial defered character
/* ed23 */                   SEI.imp ();                   // disable the interrupts
/* ed24 */                   JSR.abs ("_ee97");            // set the serial data out high
/* ed27 */                   CMP.imm (0x3f);               // compare read byte with $3F
/* ed29 */                   BNE.rel ("_ed2e");            // branch if not $3F, this branch will always be taken as
                                                           // after VIA 2's PCR is read it is ANDed with $DF, so the
                                                           // result can never be $3F ??
/* ed2b */                   JSR.abs ("_ee85");            // set the serial clock out high
/* ed2e */        _`_ed2e`;  LDA.abs ("ci2pra_dd00");      // read VIA 2 DRA, serial port and video address
/* ed31 */                   ORA.imm (0x08);               // mask xxxx 1xxx, set serial ATN low
/* ed33 */                   STA.abs ("ci2pra_dd00");      // save VIA 2 DRA, serial port and video address
                                                           // if the code drops through to here the serial clock is low and the serial data has been
                                                           // released so the following code will have no effect apart from delaying the first byte
                                                           // by 1ms
                                                           // set the serial clk/data, wait and Tx byte on the serial bus
/* ed36 */        _`_ed36`;  SEI.imp ();                   // disable the interrupts
/* ed37 */                   JSR.abs ("_ee8e");            // set the serial clock out low
/* ed3a */                   JSR.abs ("_ee97");            // set the serial data out high
/* ed3d */                   JSR.abs ("_eeb3");            // 1ms delay

// ------------------------------------------------------- // Tx byte on serial bus
/* ed40 */        _`_ed40`;  SEI.imp ();                   // disable the interrupts
/* ed41 */                   JSR.abs ("_ee97");            // set the serial data out high
/* ed44 */                   JSR.abs ("_eea9");            // get the serial data status in Cb
/* ed47 */                   BCS.rel ("_edad");            // if the serial data is high go do 'device not present'
/* ed49 */                   JSR.abs ("_ee85");            // set the serial clock out high
/* ed4c */                   BIT.zpg ("tsfcnt_00a3");      // test the EOI flag
/* ed4e */                   BPL.rel ("_ed5a");            // if not EOI go ??
                                                           // I think this is the EOI sequence so the serial clock has been released and the serial
                                                           // data is being held low by the peripheral. first up wait for the serial data to rise
/* ed50 */        _`_ed50`;  JSR.abs ("_eea9");            // get the serial data status in Cb
/* ed53 */                   BCC.rel ("_ed50");            // loop if the data is low
                                                           // now the data is high, EOI is signalled by waiting for at least 200us without pulling
                                                           // the serial clock line low again. the listener should respond by pulling the serial
                                                           // data line low
/* ed55 */        _`_ed55`;  JSR.abs ("_eea9");            // get the serial data status in Cb
/* ed58 */                   BCS.rel ("_ed55");            // loop if the data is high
                                                           // the serial data has gone low ending the EOI sequence, now just wait for the serial
                                                           // data line to go high again or, if this isn't an EOI sequence, just wait for the serial
                                                           // data to go high the first time
/* ed5a */        _`_ed5a`;  JSR.abs ("_eea9");            // get the serial data status in Cb
/* ed5d */                   BCC.rel ("_ed5a");            // loop if the data is low
                                                           // serial data is high now pull the clock low, preferably within 60us
/* ed5f */                   JSR.abs ("_ee8e");            // set the serial clock out low
                                                           // now the C64 has to send the eight bits, LSB first. first it sets the serial data line
                                                           // to reflect the bit in the byte, then it sets the serial clock to high. The serial
                                                           // clock is left high for 26 cycles, 23us on a PAL Vic, before it is again pulled low
                                                           // and the serial data is allowed high again
/* ed62 */                   LDA.imm (0x08);               // eight bits to do
/* ed64 */                   STA.zpg ("cntdn_00a5");       // set serial bus bit count
/* ed66 */        _`_ed66`;  LDA.abs ("ci2pra_dd00");      // read VIA 2 DRA, serial port and video address
/* ed69 */                   CMP.abs ("ci2pra_dd00");      // compare it with itself
/* ed6c */                   BNE.rel ("_ed66");            // if changed go try again
/* ed6e */                   ASL.acc ();                   // shift the serial data into Cb
/* ed6f */                   BCC.rel ("_edb0");            // if the serial data is low go do serial bus timeout
/* ed71 */                   ROR.zpg ("bsour_0095");       // rotate the transmit byte
/* ed73 */                   BCS.rel ("_ed7a");            // if the bit = 1 go set the serial data out high
/* ed75 */                   JSR.abs ("_eea0");            // else set the serial data out low
/* ed78 */                   BNE.rel ("_ed7d");            // continue, branch always
/* ed7a */        _`_ed7a`;  JSR.abs ("_ee97");            // set the serial data out high
/* ed7d */        _`_ed7d`;  JSR.abs ("_ee85");            // set the serial clock out high
/* ed80 */                   NOP.imp ();                   // waste ..
/* ed81 */                   NOP.imp ();                   // .. a ..
/* ed82 */                   NOP.imp ();                   // .. cycle ..
/* ed83 */                   NOP.imp ();                   // .. or two
/* ed84 */                   LDA.abs ("ci2pra_dd00");      // read VIA 2 DRA, serial port and video address
/* ed87 */                   AND.imm (0xdf);               // mask xx0x xxxx, set the serial data out high
/* ed89 */                   ORA.imm (0x10);               // mask xxx1 xxxx, set the serial clock out low
/* ed8b */                   STA.abs ("ci2pra_dd00");      // save VIA 2 DRA, serial port and video address
/* ed8e */                   DEC.zpg ("cntdn_00a5");       // decrement the serial bus bit count
/* ed90 */                   BNE.rel ("_ed66");            // loop if not all done
                                                           // now all eight bits have been sent it's up to the peripheral to signal the byte was
                                                           // received by pulling the serial data low. this should be done within one milisecond
/* ed92 */                   LDA.imm (0x04);               // wait for up to about 1ms
/* ed94 */                   STA.abs ("timbhi_dc07");      // save VIA 1 timer B high byte
/* ed97 */                   LDA.imm (0x19);               // load timer B, timer B single shot, start timer B
/* ed99 */                   STA.abs ("ciacrb_dc0f");      // save VIA 1 CRB
/* ed9c */                   LDA.abs ("ciaicr_dc0d");      // read VIA 1 ICR
/* ed9f */        _`_ed9f`;  LDA.abs ("ciaicr_dc0d");      // read VIA 1 ICR
/* eda2 */                   AND.imm (0x02);               // mask 0000 00x0, timer A interrupt
/* eda4 */                   BNE.rel ("_edb0");            // if timer A interrupt go do serial bus timeout
/* eda6 */                   JSR.abs ("_eea9");            // get the serial data status in Cb
/* eda9 */                   BCS.rel ("_ed9f");            // if the serial data is high go wait some more
/* edab */                   CLI.imp ();                   // enable the interrupts
/* edac */                   RTS.imp ();
                                                           // device not present
/* edad */        _`_edad`;  LDA.imm (0x80);               // error $80, device not present
/* edaf */                   _.bytes(0x2c);                // makes next line BIT $03A9
                                                           // timeout on serial bus
/* edb0 */        _`_edb0`;  LDA.imm (0x03);               // error $03, read timeout, write timeout
/* edb2 */        _`_edb2`;  JSR.abs ("_fe1c");            // OR into the serial status byte
/* edb5 */                   CLI.imp ();                   // enable the interrupts
/* edb6 */                   CLC.imp ();                   // clear for branch
/* edb7 */                   BCC.rel ("_ee03");            // ATN high, delay, clock high then data high, branch always

// ------------------------------------------------------- // send secondary address after LISTEN
/* edb9 */  _`second_edb9`;  STA.zpg ("bsour_0095");       // save the defered Tx byte
/* edbb */                   JSR.abs ("_ed36");            // set the serial clk/data, wait and Tx the byte

// ------------------------------------------------------- // set serial ATN high
/* edbe */        _`_edbe`;  LDA.abs ("ci2pra_dd00");      // read VIA 2 DRA, serial port and video address
/* edc1 */                   AND.imm (0xf7);               // mask xxxx 0xxx, set serial ATN high
/* edc3 */                   STA.abs ("ci2pra_dd00");      // save VIA 2 DRA, serial port and video address
/* edc6 */                   RTS.imp ();

// ------------------------------------------------------- // send secondary address after TALK
/* edc7 */    _`tksa_edc7`;  STA.zpg ("bsour_0095");       // save the defered Tx byte
/* edc9 */                   JSR.abs ("_ed36");            // set the serial clk/data, wait and Tx the byte

// ------------------------------------------------------- // wait for the serial bus end after send
                                                           // return address from patch 6
/* edcc */        _`_edcc`;  SEI.imp ();                   // disable the interrupts
/* edcd */                   JSR.abs ("_eea0");            // set the serial data out low
/* edd0 */                   JSR.abs ("_edbe");            // set serial ATN high
/* edd3 */                   JSR.abs ("_ee85");            // set the serial clock out high
/* edd6 */        _`_edd6`;  JSR.abs ("_eea9");            // get the serial data status in Cb
/* edd9 */                   BMI.rel ("_edd6");            // loop if the clock is high
/* eddb */                   CLI.imp ();                   // enable the interrupts
/* eddc */                   RTS.imp ();

// ------------------------------------------------------- // output a byte to the serial bus
/* eddd */   _`ciout_eddd`;  BIT.zpg ("c3po_0094");        // test the deferred character flag
/* eddf */                   BMI.rel ("_ede6");            // if there is a defered character go send it
/* ede1 */                   SEC.imp ();                   // set carry
/* ede2 */                   ROR.zpg ("c3po_0094");        // shift into the deferred character flag
/* ede4 */                   BNE.rel ("_edeb");            // save the byte and exit, branch always
/* ede6 */        _`_ede6`;  PHA.imp ();                   // save the byte
/* ede7 */                   JSR.abs ("_ed40");            // Tx byte on serial bus
/* edea */                   PLA.imp ();                   // restore the byte
/* edeb */        _`_edeb`;  STA.zpg ("bsour_0095");       // save the defered Tx byte
/* eded */                   CLC.imp ();                   // flag ok
/* edee */                   RTS.imp ();

// ------------------------------------------------------- // command serial bus to UNTALK
/* edef */   _`untlk_edef`;  SEI.imp ();                   // disable the interrupts
/* edf0 */                   JSR.abs ("_ee8e");            // set the serial clock out low
/* edf3 */                   LDA.abs ("ci2pra_dd00");      // read VIA 2 DRA, serial port and video address
/* edf6 */                   ORA.imm (0x08);               // mask xxxx 1xxx, set the serial ATN low
/* edf8 */                   STA.abs ("ci2pra_dd00");      // save VIA 2 DRA, serial port and video address
/* edfb */                   LDA.imm (0x5f);               // set the UNTALK command
/* edfd */                   _.bytes(0x2c);                // makes next line BIT $3FA9

// ------------------------------------------------------- // command serial bus to UNLISTEN
/* edfe */   _`unlsn_edfe`;  LDA.imm (0x3f);               // set the UNLISTEN command
/* ee00 */                   JSR.abs ("_ed11");            // send a control character
/* ee03 */        _`_ee03`;  JSR.abs ("_edbe");            // set serial ATN high
                                                           // 1ms delay, clock high then data high
/* ee06 */        _`_ee06`;  TXA.imp ();                   // save the device number
/* ee07 */                   LDX.imm (0x0a);               // short delay
/* ee09 */        _`_ee09`;  DEX.imp ();                   // decrement the count
/* ee0a */                   BNE.rel ("_ee09");            // loop if not all done
/* ee0c */                   TAX.imp ();                   // restore the device number
/* ee0d */                   JSR.abs ("_ee85");            // set the serial clock out high
/* ee10 */                   JMP.abs ("_ee97");            // set the serial data out high and return

// ------------------------------------------------------- // input a byte from the serial bus
/* ee13 */   _`acptr_ee13`;  SEI.imp ();                   // disable the interrupts
/* ee14 */                   LDA.imm (0x00);               // set 0 bits to do, will flag EOI on timeour
/* ee16 */                   STA.zpg ("cntdn_00a5");       // save the serial bus bit count
/* ee18 */                   JSR.abs ("_ee85");            // set the serial clock out high
/* ee1b */        _`_ee1b`;  JSR.abs ("_eea9");            // get the serial data status in Cb
/* ee1e */                   BPL.rel ("_ee1b");            // loop if the serial clock is low
/* ee20 */        _`_ee20`;  LDA.imm (0x01);               // set the timeout count high byte
/* ee22 */                   STA.abs ("timbhi_dc07");      // save VIA 1 timer B high byte
/* ee25 */                   LDA.imm (0x19);               // load timer B, timer B single shot, start timer B
/* ee27 */                   STA.abs ("ciacrb_dc0f");      // save VIA 1 CRB
/* ee2a */                   JSR.abs ("_ee97");            // set the serial data out high
/* ee2d */                   LDA.abs ("ciaicr_dc0d");      // read VIA 1 ICR
/* ee30 */        _`_ee30`;  LDA.abs ("ciaicr_dc0d");      // read VIA 1 ICR
/* ee33 */                   AND.imm (0x02);               // mask 0000 00x0, timer A interrupt
/* ee35 */                   BNE.rel ("_ee3e");            // if timer A interrupt go ??
/* ee37 */                   JSR.abs ("_eea9");            // get the serial data status in Cb
/* ee3a */                   BMI.rel ("_ee30");            // loop if the serial clock is low
/* ee3c */                   BPL.rel ("_ee56");            // else go set 8 bits to do, branch always
                                                           // timer A timed out
/* ee3e */        _`_ee3e`;  LDA.zpg ("cntdn_00a5");       // get the serial bus bit count
/* ee40 */                   BEQ.rel ("_ee47");            // if not already EOI then go flag EOI
/* ee42 */                   LDA.imm (0x02);               // else error $02, read timeour
/* ee44 */                   JMP.abs ("_edb2");            // set the serial status and exit
/* ee47 */        _`_ee47`;  JSR.abs ("_eea0");            // set the serial data out low
/* ee4a */                   JSR.abs ("_ee85");            // set the serial clock out high
/* ee4d */                   LDA.imm (0x40);               // set EOI
/* ee4f */                   JSR.abs ("_fe1c");            // OR into the serial status byte
/* ee52 */                   INC.zpg ("cntdn_00a5");       // increment the serial bus bit count, do error on the next
                                                           // timeout
/* ee54 */                   BNE.rel ("_ee20");            // go try again, branch always
/* ee56 */        _`_ee56`;  LDA.imm (0x08);               // set 8 bits to do
/* ee58 */                   STA.zpg ("cntdn_00a5");       // save the serial bus bit count
/* ee5a */        _`_ee5a`;  LDA.abs ("ci2pra_dd00");      // read VIA 2 DRA, serial port and video address
/* ee5d */                   CMP.abs ("ci2pra_dd00");      // compare it with itself
/* ee60 */                   BNE.rel ("_ee5a");            // if changing go try again
/* ee62 */                   ASL.acc ();                   // shift the serial data into the carry
/* ee63 */                   BPL.rel ("_ee5a");            // loop while the serial clock is low
/* ee65 */                   ROR.zpg ("tbtcnt_00a4");      // shift the data bit into the receive byte
/* ee67 */        _`_ee67`;  LDA.abs ("ci2pra_dd00");      // read VIA 2 DRA, serial port and video address
/* ee6a */                   CMP.abs ("ci2pra_dd00");      // compare it with itself
/* ee6d */                   BNE.rel ("_ee67");            // if changing go try again
/* ee6f */                   ASL.acc ();                   // shift the serial data into the carry
/* ee70 */                   BMI.rel ("_ee67");            // loop while the serial clock is high
/* ee72 */                   DEC.zpg ("cntdn_00a5");       // decrement the serial bus bit count
/* ee74 */                   BNE.rel ("_ee5a");            // loop if not all done
/* ee76 */                   JSR.abs ("_eea0");            // set the serial data out low
/* ee79 */                   BIT.zpg ("status_0090");      // test the serial status byte
/* ee7b */                   BVC.rel ("_ee80");            // if EOI not set skip the bus end sequence
/* ee7d */                   JSR.abs ("_ee06");            // 1ms delay, clock high then data high
/* ee80 */        _`_ee80`;  LDA.zpg ("tbtcnt_00a4");      // get the receive byte
/* ee82 */                   CLI.imp ();                   // enable the interrupts
/* ee83 */                   CLC.imp ();                   // flag ok
/* ee84 */                   RTS.imp ();

// ------------------------------------------------------- // set the serial clock out high
/* ee85 */        _`_ee85`;  LDA.abs ("ci2pra_dd00");      // read VIA 2 DRA, serial port and video address
/* ee88 */                   AND.imm (0xef);               // mask xxx0 xxxx, set serial clock out high
/* ee8a */                   STA.abs ("ci2pra_dd00");      // save VIA 2 DRA, serial port and video address
/* ee8d */                   RTS.imp ();

// ------------------------------------------------------- // set the serial clock out low
/* ee8e */        _`_ee8e`;  LDA.abs ("ci2pra_dd00");      // read VIA 2 DRA, serial port and video address
/* ee91 */                   ORA.imm (0x10);               // mask xxx1 xxxx, set serial clock out low
/* ee93 */                   STA.abs ("ci2pra_dd00");      // save VIA 2 DRA, serial port and video address
/* ee96 */                   RTS.imp ();

// ------------------------------------------------------- // set the serial data out high
/* ee97 */        _`_ee97`;  LDA.abs ("ci2pra_dd00");      // read VIA 2 DRA, serial port and video address
/* ee9a */                   AND.imm (0xdf);               // mask xx0x xxxx, set serial data out high
/* ee9c */                   STA.abs ("ci2pra_dd00");      // save VIA 2 DRA, serial port and video address
/* ee9f */                   RTS.imp ();

// ------------------------------------------------------- // set the serial data out low
/* eea0 */        _`_eea0`;  LDA.abs ("ci2pra_dd00");      // read VIA 2 DRA, serial port and video address
/* eea3 */                   ORA.imm (0x20);               // mask xx1x xxxx, set serial data out low
/* eea5 */                   STA.abs ("ci2pra_dd00");      // save VIA 2 DRA, serial port and video address
/* eea8 */                   RTS.imp ();

// ------------------------------------------------------- // get the serial data status in Cb
/* eea9 */        _`_eea9`;  LDA.abs ("ci2pra_dd00");      // read VIA 2 DRA, serial port and video address
/* eeac */                   CMP.abs ("ci2pra_dd00");      // compare it with itself
/* eeaf */                   BNE.rel ("_eea9");            // if changing got try again
/* eeb1 */                   ASL.acc ();                   // shift the serial data into Cb
/* eeb2 */                   RTS.imp ();

// ------------------------------------------------------- // 1ms delay
/* eeb3 */        _`_eeb3`;  TXA.imp ();                   // save X
/* eeb4 */                   LDX.imm (0xb8);               // set the loop count
/* eeb6 */        _`_eeb6`;  DEX.imp ();                   // decrement the loop count
/* eeb7 */                   BNE.rel ("_eeb6");            // loop if more to do
/* eeb9 */                   TAX.imp ();                   // restore X
/* eeba */                   RTS.imp ();

// ------------------------------------------------------- // RS232 Tx NMI routine
/* eebb */        _`_eebb`;  LDA.zpg ("bitts_00b4");       // get RS232 bit count
/* eebd */                   BEQ.rel ("_ef06");            // if zero go setup next RS232 Tx byte and return
/* eebf */                   BMI.rel ("_ef00");            // if -ve go do stop bit(s)
                                                           // else bit count is non zero and +ve
/* eec1 */                   LSR.zpg ("rodata_00b6");      // shift RS232 output byte buffer
/* eec3 */                   LDX.imm (0x00);               // set $00 for bit = 0
/* eec5 */                   BCC.rel ("_eec8");            // branch if bit was 0
/* eec7 */                   DEX.imp ();                   // set $FF for bit = 1
/* eec8 */        _`_eec8`;  TXA.imp ();                   // copy bit to A
/* eec9 */                   EOR.zpg ("roprty_00bd");      // EOR with RS232 parity byte
/* eecb */                   STA.zpg ("roprty_00bd");      // save RS232 parity byte
/* eecd */                   DEC.zpg ("bitts_00b4");       // decrement RS232 bit count
/* eecf */                   BEQ.rel ("_eed7");            // if RS232 bit count now zero go do parity bit
                                                           // save bit and exit
/* eed1 */        _`_eed1`;  TXA.imp ();                   // copy bit to A
/* eed2 */                   AND.imm (0x04);               // mask 0000 0x00, RS232 Tx DATA bit
/* eed4 */                   STA.zpg ("nxtbit_00b5");      // save the next RS232 data bit to send
/* eed6 */                   RTS.imp ();

// ------------------------------------------------------- // do RS232 parity bit, enters with RS232 bit count = 0
/* eed7 */        _`_eed7`;  LDA.imm (0x20);               // mask 00x0 0000, parity enable bit
/* eed9 */                   BIT.abs ("m51cdr_0294");      // test the pseudo 6551 command register
/* eedc */                   BEQ.rel ("_eef2");            // if parity disabled go ??
/* eede */                   BMI.rel ("_eefc");            // if fixed mark or space parity go ??
/* eee0 */                   BVS.rel ("_eef6");            // if even parity go ??
                                                           // else odd parity
/* eee2 */                   LDA.zpg ("roprty_00bd");      // get RS232 parity byte
/* eee4 */                   BNE.rel ("_eee7");            // if parity not zero leave parity bit = 0
/* eee6 */        _`_eee6`;  DEX.imp ();                   // make parity bit = 1
/* eee7 */        _`_eee7`;  DEC.zpg ("bitts_00b4");       // decrement RS232 bit count, 1 stop bit
/* eee9 */                   LDA.abs ("m51ctr_0293");      // get pseudo 6551 control register
/* eeec */                   BPL.rel ("_eed1");            // if 1 stop bit save parity bit and exit
                                                           // else two stop bits ..
/* eeee */                   DEC.zpg ("bitts_00b4");       // decrement RS232 bit count, 2 stop bits
/* eef0 */                   BNE.rel ("_eed1");            // save bit and exit, branch always
                                                           // parity is disabled so the parity bit becomes the first,
                                                           // and possibly only, stop bit. to do this increment the bit
                                                           // count which effectively decrements the stop bit count.
/* eef2 */        _`_eef2`;  INC.zpg ("bitts_00b4");       // increment RS232 bit count, = -1 stop bit
/* eef4 */                   BNE.rel ("_eee6");            // set stop bit = 1 and exit
                                                           // do even parity
/* eef6 */        _`_eef6`;  LDA.zpg ("roprty_00bd");      // get RS232 parity byte
/* eef8 */                   BEQ.rel ("_eee7");            // if parity zero leave parity bit = 0
/* eefa */                   BNE.rel ("_eee6");            // else make parity bit = 1, branch always
                                                           // fixed mark or space parity
/* eefc */        _`_eefc`;  BVS.rel ("_eee7");            // if fixed space parity leave parity bit = 0
/* eefe */                   BVC.rel ("_eee6");            // else fixed mark parity make parity bit = 1, branch always
                                                           // decrement stop bit count, set stop bit = 1 and exit. $FF is one stop bit, $FE is two
                                                           // stop bits
/* ef00 */        _`_ef00`;  INC.zpg ("bitts_00b4");       // decrement RS232 bit count
/* ef02 */                   LDX.imm (0xff);               // set stop bit = 1
/* ef04 */                   BNE.rel ("_eed1");            // save stop bit and exit, branch always

// ------------------------------------------------------- // setup next RS232 Tx byte
/* ef06 */        _`_ef06`;  LDA.abs ("m51cdr_0294");      // read the 6551 pseudo command register
/* ef09 */                   LSR.acc ();                   // handshake bit inot Cb
/* ef0a */                   BCC.rel ("_ef13");            // if 3 line interface go ??
/* ef0c */                   BIT.abs ("ci2prb_dd01");      // test VIA 2 DRB, RS232 port
/* ef0f */                   BPL.rel ("_ef2e");            // if DSR = 0 set DSR signal not present and exit
/* ef11 */                   BVC.rel ("_ef31");            // if CTS = 0 set CTS signal not present and exit
                                                           // was 3 line interface
/* ef13 */        _`_ef13`;  LDA.imm (0x00);               // clear A
/* ef15 */                   STA.zpg ("roprty_00bd");      // clear the RS232 parity byte
/* ef17 */                   STA.zpg ("nxtbit_00b5");      // clear the RS232 next bit to send
/* ef19 */                   LDX.abs ("bitnum_0298");      // get the number of bits to be sent/received
/* ef1c */                   STX.zpg ("bitts_00b4");       // set the RS232 bit count
/* ef1e */                   LDY.abs ("rodbs_029d");       // get the index to the Tx buffer start
/* ef21 */                   CPY.abs ("rodbe_029e");       // compare it with the index to the Tx buffer end
/* ef24 */                   BEQ.rel ("_ef39");            // if all done go disable T?? interrupt and return
/* ef26 */                   LDA.iny ("robuf+0_00f9");     // else get a byte from the buffer
/* ef28 */                   STA.zpg ("rodata_00b6");      // save it to the RS232 output byte buffer
/* ef2a */                   INC.abs ("rodbs_029d");       // increment the index to the Tx buffer start
/* ef2d */                   RTS.imp ();

// ------------------------------------------------------- // set DSR signal not present
/* ef2e */        _`_ef2e`;  LDA.imm (0x40);               // set DSR signal not present
/* ef30 */                   _.bytes(0x2c);                // makes next line BIT $10A9

// ------------------------------------------------------- // set CTS signal not present
/* ef31 */        _`_ef31`;  LDA.imm (0x10);               // set CTS signal not present
/* ef33 */                   ORA.abs ("rsstat_0297");      // OR it with the RS232 status register
/* ef36 */                   STA.abs ("rsstat_0297");      // save the RS232 status register

// ------------------------------------------------------- // disable timer A interrupt
/* ef39 */        _`_ef39`;  LDA.imm (0x01);               // disable timer A interrupt

// ------------------------------------------------------- // set VIA 2 ICR from A
/* ef3b */        _`_ef3b`;  STA.abs ("ci2icr_dd0d");      // save VIA 2 ICR
/* ef3e */                   EOR.abs ("enabl_02a1");       // EOR with the RS-232 interrupt enable byte
/* ef41 */                   ORA.imm (0x80);               // set the interrupts enable bit
/* ef43 */                   STA.abs ("enabl_02a1");       // save the RS-232 interrupt enable byte
/* ef46 */                   STA.abs ("ci2icr_dd0d");      // save VIA 2 ICR
/* ef49 */                   RTS.imp ();

// ------------------------------------------------------- // compute bit count
/* ef4a */        _`_ef4a`;  LDX.imm (0x09);               // set bit count to 9, 8 data + 1 stop bit
/* ef4c */                   LDA.imm (0x20);               // mask for 8/7 data bits
/* ef4e */                   BIT.abs ("m51ctr_0293");      // test pseudo 6551 control register
/* ef51 */                   BEQ.rel ("_ef54");            // branch if 8 bits
/* ef53 */                   DEX.imp ();                   // else decrement count for 7 data bits
/* ef54 */        _`_ef54`;  BVC.rel ("_ef58");            // branch if 7 bits
/* ef56 */                   DEX.imp ();                   // else decrement count ..
/* ef57 */                   DEX.imp ();                   // .. for 5 data bits
/* ef58 */        _`_ef58`;  RTS.imp ();

// ------------------------------------------------------- // RS232 Rx NMI
/* ef59 */        _`_ef59`;  LDX.zpg ("rinone_00a9");      // get start bit check flag
/* ef5b */                   BNE.rel ("_ef90");            // if no start bit received go ??
/* ef5d */                   DEC.zpg ("bitci_00a8");       // decrement receiver bit count in
/* ef5f */                   BEQ.rel ("_ef97");            // if the byte is complete go add it to the buffer
/* ef61 */                   BMI.rel ("_ef70");
/* ef63 */                   LDA.zpg ("inbit_00a7");       // get the RS232 received data bit
/* ef65 */                   EOR.zpg ("riprty_00ab");      // EOR with the receiver parity bit
/* ef67 */                   STA.zpg ("riprty_00ab");      // save the receiver parity bit
/* ef69 */                   LSR.zpg ("inbit_00a7");       // shift the RS232 received data bit
/* ef6b */                   ROR.zpg ("ridata_00aa");
/* ef6d */        _`_ef6d`;  RTS.imp ();
/* ef6e */        _`_ef6e`;  DEC.zpg ("bitci_00a8");       // decrement receiver bit count in
/* ef70 */        _`_ef70`;  LDA.zpg ("inbit_00a7");       // get the RS232 received data bit
/* ef72 */                   BEQ.rel ("_efdb");
/* ef74 */                   LDA.abs ("m51ctr_0293");      // get pseudo 6551 control register
/* ef77 */                   ASL.acc ();                   // shift the stop bit flag to Cb
/* ef78 */                   LDA.imm (0x01);               // + 1
/* ef7a */                   ADC.zpg ("bitci_00a8");       // add receiver bit count in
/* ef7c */                   BNE.rel ("_ef6d");            // exit, branch always

// ------------------------------------------------------- // setup to receive an RS232 bit
/* ef7e */        _`_ef7e`;  LDA.imm (0x90);               // enable FLAG interrupt
/* ef80 */                   STA.abs ("ci2icr_dd0d");      // save VIA 2 ICR
/* ef83 */                   ORA.abs ("enabl_02a1");       // OR with the RS-232 interrupt enable byte
/* ef86 */                   STA.abs ("enabl_02a1");       // save the RS-232 interrupt enable byte
/* ef89 */                   STA.zpg ("rinone_00a9");      // set start bit check flag, set no start bit received
/* ef8b */                   LDA.imm (0x02);               // disable timer B interrupt
/* ef8d */                   JMP.abs ("_ef3b");            // set VIA 2 ICR from A and return

// ------------------------------------------------------- // no RS232 start bit received
/* ef90 */        _`_ef90`;  LDA.zpg ("inbit_00a7");       // get the RS232 received data bit
/* ef92 */                   BNE.rel ("_ef7e");            // if ?? go setup to receive an RS232 bit and return
/* ef94 */                   JMP.abs ("_e4d3");            // flag the RS232 start bit and set the parity

// ------------------------------------------------------- // received a whole byte, add it to the buffer
/* ef97 */        _`_ef97`;  LDY.abs ("ridbe_029b");       // get index to Rx buffer end
/* ef9a */                   INY.imp ();                   // increment index
/* ef9b */                   CPY.abs ("ridbs_029c");       // compare with index to Rx buffer start
/* ef9e */                   BEQ.rel ("_efca");            // if buffer full go do Rx overrun error
/* efa0 */                   STY.abs ("ridbe_029b");       // save index to Rx buffer end
/* efa3 */                   DEY.imp ();                   // decrement index
/* efa4 */                   LDA.zpg ("ridata_00aa");      // get assembled byte
/* efa6 */                   LDX.abs ("bitnum_0298");      // get bit count
/* efa9 */        _`_efa9`;  CPX.imm (0x09);               // compare with byte + stop
/* efab */                   BEQ.rel ("_efb1");            // branch if all nine bits received
/* efad */                   LSR.acc ();                   // else shift byte
/* efae */                   INX.imp ();                   // increment bit count
/* efaf */                   BNE.rel ("_efa9");            // loop, branch always
/* efb1 */        _`_efb1`;  STA.iny ("ribuf+0_00f7");     // save received byte to Rx buffer
/* efb3 */                   LDA.imm (0x20);               // mask 00x0 0000, parity enable bit
/* efb5 */                   BIT.abs ("m51cdr_0294");      // test the pseudo 6551 command register
/* efb8 */                   BEQ.rel ("_ef6e");            // branch if parity disabled
/* efba */                   BMI.rel ("_ef6d");            // branch if mark or space parity
/* efbc */                   LDA.zpg ("inbit_00a7");       // get the RS232 received data bit
/* efbe */                   EOR.zpg ("riprty_00ab");      // EOR with the receiver parity bit
/* efc0 */                   BEQ.rel ("_efc5");
/* efc2 */                   BVS.rel ("_ef6d");            // if ?? just exit
/* efc4 */                   _.bytes(0x2c);                // makes next line BIT $A650
/* efc5 */        _`_efc5`;  BVC.rel ("_ef6d");            // if ?? just exit
/* efc7 */                   LDA.imm (0x01);               // set Rx parity error
/* efc9 */                   _.bytes(0x2c);                // makes next line BIT $04A9
/* efca */        _`_efca`;  LDA.imm (0x04);               // set Rx overrun error
/* efcc */                   _.bytes(0x2c);                // makes next line BIT $80A9
/* efcd */        _`_efcd`;  LDA.imm (0x80);               // set Rx break error
/* efcf */                   _.bytes(0x2c);                // makes next line BIT $02A9
/* efd0 */        _`_efd0`;  LDA.imm (0x02);               // set Rx frame error
/* efd2 */                   ORA.abs ("rsstat_0297");      // OR it with the RS232 status byte
/* efd5 */                   STA.abs ("rsstat_0297");      // save the RS232 status byte
/* efd8 */                   JMP.abs ("_ef7e");            // setup to receive an RS232 bit and return
/* efdb */        _`_efdb`;  LDA.zpg ("ridata_00aa");
/* efdd */                   BNE.rel ("_efd0");            // if ?? do frame error
/* efdf */                   BEQ.rel ("_efcd");            // else do break error, branch always

// ------------------------------------------------------- // open RS232 channel for output
/* efe1 */        _`_efe1`;  STA.zpg ("dflto_009a");       // save the output device number
/* efe3 */                   LDA.abs ("m51cdr_0294");      // read the pseudo 6551 command register
/* efe6 */                   LSR.acc ();                   // shift handshake bit to carry
/* efe7 */                   BCC.rel ("_f012");            // if 3 line interface go ??
/* efe9 */                   LDA.imm (0x02);               // mask 0000 00x0, RTS out
/* efeb */                   BIT.abs ("ci2prb_dd01");      // test VIA 2 DRB, RS232 port
/* efee */                   BPL.rel ("_f00d");            // if DSR = 0 set DSR not present and exit
/* eff0 */                   BNE.rel ("_f012");            // if RTS = 1 just exit
/* eff2 */        _`_eff2`;  LDA.abs ("enabl_02a1");       // get the RS-232 interrupt enable byte
/* eff5 */                   AND.imm (0x02);               // mask 0000 00x0, timer B interrupt
/* eff7 */                   BNE.rel ("_eff2");            // loop while the timer B interrupt is enebled
/* eff9 */        _`_eff9`;  BIT.abs ("ci2prb_dd01");      // test VIA 2 DRB, RS232 port
/* effc */                   BVS.rel ("_eff9");            // loop while CTS high
/* effe */                   LDA.abs ("ci2prb_dd01");      // read VIA 2 DRB, RS232 port
/* f001 */                   ORA.imm (0x02);               // mask xxxx xx1x, set RTS high
/* f003 */                   STA.abs ("ci2prb_dd01");      // save VIA 2 DRB, RS232 port
/* f006 */        _`_f006`;  BIT.abs ("ci2prb_dd01");      // test VIA 2 DRB, RS232 port
/* f009 */                   BVS.rel ("_f012");            // exit if CTS high
/* f00b */                   BMI.rel ("_f006");            // loop while DSR high
                                                           // set no DSR and exit
/* f00d */        _`_f00d`;  LDA.imm (0x40);               // set DSR signal not present
/* f00f */                   STA.abs ("rsstat_0297");      // save the RS232 status register
/* f012 */        _`_f012`;  CLC.imp ();                   // flag ok
/* f013 */                   RTS.imp ();

// ------------------------------------------------------- // send byte to the RS232 buffer
/* f014 */        _`_f014`;  JSR.abs ("_f028");            // setup for RS232 transmit
                                                           // send byte to the RS232 buffer, no setup
/* f017 */        _`_f017`;  LDY.abs ("rodbe_029e");       // get index to Tx buffer end
/* f01a */                   INY.imp ();                   // + 1
/* f01b */                   CPY.abs ("rodbs_029d");       // compare with index to Tx buffer start
/* f01e */                   BEQ.rel ("_f014");            // loop while buffer full
/* f020 */                   STY.abs ("rodbe_029e");       // set index to Tx buffer end
/* f023 */                   DEY.imp ();                   // index to available buffer byte
/* f024 */                   LDA.zpg ("ptr1_009e");        // read the RS232 character buffer
/* f026 */                   STA.iny ("robuf+0_00f9");     // save the byte to the buffer

// ------------------------------------------------------- // setup for RS232 transmit
/* f028 */        _`_f028`;  LDA.abs ("enabl_02a1");       // get the RS-232 interrupt enable byte
/* f02b */                   LSR.acc ();                   // shift the enable bit to Cb
/* f02c */                   BCS.rel ("_f04c");            // if interrupts are enabled just exit
/* f02e */                   LDA.imm (0x10);               // start timer A
/* f030 */                   STA.abs ("ci2cra_dd0e");      // save VIA 2 CRA
/* f033 */                   LDA.abs ("baudof+0_0299");    // get the baud rate bit time low byte
/* f036 */                   STA.abs ("ti2alo_dd04");      // save VIA 2 timer A low byte
/* f039 */                   LDA.abs ("baudof+1_029a");    // get the baud rate bit time high byte
/* f03c */                   STA.abs ("ti2ahi_dd05");      // save VIA 2 timer A high byte
/* f03f */                   LDA.imm (0x81);               // enable timer A interrupt
/* f041 */                   JSR.abs ("_ef3b");            // set VIA 2 ICR from A
/* f044 */                   JSR.abs ("_ef06");            // setup next RS232 Tx byte
/* f047 */                   LDA.imm (0x11);               // load timer A, start timer A
/* f049 */                   STA.abs ("ci2cra_dd0e");      // save VIA 2 CRA
/* f04c */        _`_f04c`;  RTS.imp ();

// ------------------------------------------------------- // input from RS232 buffer
/* f04d */        _`_f04d`;  STA.zpg ("dfltn_0099");       // save the input device number
/* f04f */                   LDA.abs ("m51cdr_0294");      // get pseudo 6551 command register
/* f052 */                   LSR.acc ();                   // shift the handshake bit to Cb
/* f053 */                   BCC.rel ("_f07d");            // if 3 line interface go ??
/* f055 */                   AND.imm (0x08);               // mask the duplex bit, pseudo 6551 command is >> 1
/* f057 */                   BEQ.rel ("_f07d");            // if full duplex go ??
/* f059 */                   LDA.imm (0x02);               // mask 0000 00x0, RTS out
/* f05b */                   BIT.abs ("ci2prb_dd01");      // test VIA 2 DRB, RS232 port
/* f05e */                   BPL.rel ("_f00d");            // if DSR = 0 set no DSR and exit
/* f060 */                   BEQ.rel ("_f084");            // if RTS = 0 just exit
/* f062 */        _`_f062`;  LDA.abs ("enabl_02a1");       // get the RS-232 interrupt enable byte
/* f065 */                   LSR.acc ();                   // shift the timer A interrupt enable bit to Cb
/* f066 */                   BCS.rel ("_f062");            // loop while the timer A interrupt is enabled
/* f068 */                   LDA.abs ("ci2prb_dd01");      // read VIA 2 DRB, RS232 port
/* f06b */                   AND.imm (0xfd);               // mask xxxx xx0x, clear RTS out
/* f06d */                   STA.abs ("ci2prb_dd01");      // save VIA 2 DRB, RS232 port
/* f070 */        _`_f070`;  LDA.abs ("ci2prb_dd01");      // read VIA 2 DRB, RS232 port
/* f073 */                   AND.imm (0x04);               // mask xxxx x1xx, DTR in
/* f075 */                   BEQ.rel ("_f070");            // loop while DTR low
/* f077 */        _`_f077`;  LDA.imm (0x90);               // enable the FLAG interrupt
/* f079 */                   CLC.imp ();                   // flag ok
/* f07a */                   JMP.abs ("_ef3b");            // set VIA 2 ICR from A and return
/* f07d */        _`_f07d`;  LDA.abs ("enabl_02a1");       // get the RS-232 interrupt enable byte
/* f080 */                   AND.imm (0x12);               // mask 000x 00x0
/* f082 */                   BEQ.rel ("_f077");            // if FLAG or timer B bits set go enable the FLAG inetrrupt
/* f084 */        _`_f084`;  CLC.imp ();                   // flag ok
/* f085 */                   RTS.imp ();

// ------------------------------------------------------- // get byte from RS232 buffer
/* f086 */        _`_f086`;  LDA.abs ("rsstat_0297");      // get the RS232 status register
/* f089 */                   LDY.abs ("ridbs_029c");       // get index to Rx buffer start
/* f08c */                   CPY.abs ("ridbe_029b");       // compare with index to Rx buffer end
/* f08f */                   BEQ.rel ("_f09c");            // return null if buffer empty
/* f091 */                   AND.imm (0xf7);               // clear the Rx buffer empty bit
/* f093 */                   STA.abs ("rsstat_0297");      // save the RS232 status register
/* f096 */                   LDA.iny ("ribuf+0_00f7");     // get byte from Rx buffer
/* f098 */                   INC.abs ("ridbs_029c");       // increment index to Rx buffer start
/* f09b */                   RTS.imp ();
/* f09c */        _`_f09c`;  ORA.imm (0x08);               // set the Rx buffer empty bit
/* f09e */                   STA.abs ("rsstat_0297");      // save the RS232 status register
/* f0a1 */                   LDA.imm (0x00);               // return null
/* f0a3 */                   RTS.imp ();

// ------------------------------------------------------- // check RS232 bus idle
/* f0a4 */        _`_f0a4`;  PHA.imp ();                   // save A
/* f0a5 */                   LDA.abs ("enabl_02a1");       // get the RS-232 interrupt enable byte
/* f0a8 */                   BEQ.rel ("_f0bb");            // if no interrupts enabled just exit
/* f0aa */        _`_f0aa`;  LDA.abs ("enabl_02a1");       // get the RS-232 interrupt enable byte
/* f0ad */                   AND.imm (0x03);               // mask 0000 00xx, the error bits
/* f0af */                   BNE.rel ("_f0aa");            // if there are errors loop
/* f0b1 */                   LDA.imm (0x10);               // disable FLAG interrupt
/* f0b3 */                   STA.abs ("ci2icr_dd0d");      // save VIA 2 ICR
/* f0b6 */                   LDA.imm (0x00);               // clear A
/* f0b8 */                   STA.abs ("enabl_02a1");       // clear the RS-232 interrupt enable byte
/* f0bb */        _`_f0bb`;  PLA.imp ();                   // restore A
/* f0bc */                   RTS.imp ();

// ------------------------------------------------------- // kernel I/O messages
                                                           // I/O ERROR #
/* f0bd */        _`_f0bd`;  _.bytes(0x0d, 0x49, 0x2f, 0x4f, 0x20, 0x45, 0x52, 0x52);
/* f0c5 */                   _.bytes(0x4f, 0x52, 0x20, 0xa3);
                                                           // SEARCHING
/* f0c9 */                   _.bytes(0x0d, 0x53, 0x45, 0x41, 0x52, 0x43, 0x48, 0x49);
/* f0d1 */                   _.bytes(0x4e, 0x47, 0xa0);
/* f0d4 */                   _.bytes(0x46, 0x4f, 0x52, 0xa0);
                                                           // PRESS PLAY ON TAPE
/* f0d8 */                   _.bytes(0x0d, 0x50, 0x52, 0x45, 0x53, 0x53, 0x20, 0x50);
/* f0e0 */                   _.bytes(0x4c, 0x41, 0x59, 0x20, 0x4f, 0x4e, 0x20, 0x54);
/* f0e8 */                   _.bytes(0x41, 0x50, 0xc5);
                                                           // PRESS RECORD & PLAY ON TAPE
/* f0eb */                   _.bytes(0x50, 0x52, 0x45, 0x53, 0x53, 0x20, 0x52, 0x45);
/* f0f3 */                   _.bytes(0x43, 0x4f, 0x52, 0x44, 0x20, 0x26, 0x20, 0x50);
/* f0fb */                   _.bytes(0x4c, 0x41, 0x59, 0x20, 0x4f, 0x4e, 0x20, 0x54);
/* f103 */                   _.bytes(0x41, 0x50, 0xc5);
                                                           // LOADING
/* f106 */                   _.bytes(0x0d, 0x4c, 0x4f, 0x41, 0x44, 0x49, 0x4e, 0xc7);
                                                           // SAVING
/* f10e */                   _.bytes(0x0d, 0x53, 0x41, 0x56, 0x49, 0x4e, 0x47, 0xa0);
                                                           // VERIFYING
/* f116 */                   _.bytes(0x0d, 0x56, 0x45, 0x52, 0x49, 0x46, 0x59, 0x49);
/* f11e */                   _.bytes(0x4e, 0xc7);
                                                           // FOUND
/* f120 */                   _.bytes(0x0d, 0x46, 0x4f, 0x55, 0x4e, 0x44, 0xa0);
                                                           // OK
/* f127 */                   _.bytes(0x0d, 0x4f, 0x4b, 0x8d);

// ------------------------------------------------------- // display control I/O message if in direct mode
/* f12b */        _`_f12b`;  BIT.zpg ("msgflg_009d");      // test message mode flag
/* f12d */                   BPL.rel ("_f13c");            // exit if control messages off
                                                           // display kernel I/O message
/* f12f */        _`_f12f`;  LDA.aby ("_f0bd");            // get byte from message table
/* f132 */                   PHP.imp ();                   // save status
/* f133 */                   AND.imm (0x7f);               // clear b7
/* f135 */                   JSR.abs ("chrout_ffd2");      // output character to channel
/* f138 */                   INY.imp ();                   // increment index
/* f139 */                   PLP.imp ();                   // restore status
/* f13a */                   BPL.rel ("_f12f");            // loop if not end of message
/* f13c */        _`_f13c`;  CLC.imp ();
/* f13d */                   RTS.imp ();

// ------------------------------------------------------- // get character from the input device
/* f13e */   _`getin_f13e`;  LDA.zpg ("dfltn_0099");       // get the input device number
/* f140 */                   BNE.rel ("_f14a");            // if not the keyboard go handle other devices
                                                           // the input device was the keyboard
/* f142 */                   LDA.zpg ("ndx_00c6");         // get the keyboard buffer index
/* f144 */                   BEQ.rel ("_f155");            // if the buffer is empty go flag no byte and return
/* f146 */                   SEI.imp ();                   // disable the interrupts
/* f147 */                   JMP.abs ("lp2_e5b4");         // get input from the keyboard buffer and return
                                                           // the input device was not the keyboard
/* f14a */        _`_f14a`;  CMP.imm (0x02);               // compare the device with the RS232 device
/* f14c */                   BNE.rel ("_f166");            // if not the RS232 device go ??
                                                           // the input device is the RS232 device
/* f14e */        _`_f14e`;  STY.zpg ("xsav_0097");        // save Y
/* f150 */                   JSR.abs ("_f086");            // get a byte from RS232 buffer
/* f153 */                   LDY.zpg ("xsav_0097");        // restore Y
/* f155 */        _`_f155`;  CLC.imp ();                   // flag no error
/* f156 */                   RTS.imp ();

// ------------------------------------------------------- // input a character from channel
/* f157 */   _`chrin_f157`;  LDA.zpg ("dfltn_0099");       // get the input device number
/* f159 */                   BNE.rel ("_f166");            // if not the keyboard continue
                                                           // the input device was the keyboard
/* f15b */                   LDA.zpg ("pntr_00d3");        // get the cursor column
/* f15d */                   STA.zpg ("lxsp+1_00ca");      // set the input cursor column
/* f15f */                   LDA.zpg ("tblx_00d6");        // get the cursor row
/* f161 */                   STA.zpg ("lxsp+0_00c9");      // set the input cursor row
/* f163 */                   JMP.abs ("_e632");            // input from screen or keyboard
                                                           // the input device was not the keyboard
/* f166 */        _`_f166`;  CMP.imm (0x03);               // compare device number with screen
/* f168 */                   BNE.rel ("_f173");            // if not screen continue
                                                           // the input device was the screen
/* f16a */                   STA.zpg ("crsw_00d0");        // input from keyboard or screen, $xx = screen,
                                                           // $00 = keyboard
/* f16c */                   LDA.zpg ("lnmx_00d5");        // get current screen line length
/* f16e */                   STA.zpg ("indx_00c8");        // save input [EOL] pointer
/* f170 */                   JMP.abs ("_e632");            // input from screen or keyboard
                                                           // the input device was not the screen
/* f173 */        _`_f173`;  BCS.rel ("_f1ad");            // if input device > screen go do IEC devices
                                                           // the input device was < screen
/* f175 */                   CMP.imm (0x02);               // compare the device with the RS232 device
/* f177 */                   BEQ.rel ("_f1b8");            // if RS232 device go get a byte from the RS232 device
                                                           // only the tape device left ..
/* f179 */                   STX.zpg ("xsav_0097");        // save X
/* f17b */                   JSR.abs ("_f199");            // get a byte from tape
/* f17e */                   BCS.rel ("_f196");            // if error just exit
/* f180 */                   PHA.imp ();                   // save the byte
/* f181 */                   JSR.abs ("_f199");            // get the next byte from tape
/* f184 */                   BCS.rel ("_f193");            // if error just exit
/* f186 */                   BNE.rel ("_f18d");            // if end reached ??
/* f188 */                   LDA.imm (0x40);               // set EOI
/* f18a */                   JSR.abs ("_fe1c");            // OR into the serial status byte
/* f18d */        _`_f18d`;  DEC.zpg ("bufpnt_00a6");      // decrement tape buffer index
/* f18f */                   LDX.zpg ("xsav_0097");        // restore X
/* f191 */                   PLA.imp ();                   // restore the saved byte
/* f192 */                   RTS.imp ();
/* f193 */        _`_f193`;  TAX.imp ();                   // copy the error byte
/* f194 */                   PLA.imp ();                   // dump the saved byte
/* f195 */                   TXA.imp ();                   // restore error byte
/* f196 */        _`_f196`;  LDX.zpg ("xsav_0097");        // restore X
/* f198 */                   RTS.imp ();

// ------------------------------------------------------- // get byte from tape
/* f199 */        _`_f199`;  JSR.abs ("_f80d");            // bump tape pointer
/* f19c */                   BNE.rel ("_f1a9");            // if not end get next byte and exit
/* f19e */                   JSR.abs ("_f841");            // initiate tape read
/* f1a1 */                   BCS.rel ("_f1b4");            // exit if error flagged
/* f1a3 */                   LDA.imm (0x00);               // clear A
/* f1a5 */                   STA.zpg ("bufpnt_00a6");      // clear tape buffer index
/* f1a7 */                   BEQ.rel ("_f199");            // loop, branch always
/* f1a9 */        _`_f1a9`;  LDA.iny ("tape1+0_00b2");     // get next byte from buffer
/* f1ab */                   CLC.imp ();                   // flag no error
/* f1ac */                   RTS.imp ();
                                                           // input device was serial bus
/* f1ad */        _`_f1ad`;  LDA.zpg ("status_0090");      // get the serial status byte
/* f1af */                   BEQ.rel ("_f1b5");            // if no errors flagged go input byte and return
/* f1b1 */        _`_f1b1`;  LDA.imm (0x0d);               // else return [EOL]
/* f1b3 */        _`_f1b3`;  CLC.imp ();                   // flag no error
/* f1b4 */        _`_f1b4`;  RTS.imp ();
/* f1b5 */        _`_f1b5`;  JMP.abs ("acptr_ee13");       // input byte from serial bus and return
                                                           // input device was RS232 device
/* f1b8 */        _`_f1b8`;  JSR.abs ("_f14e");            // get byte from RS232 device
/* f1bb */                   BCS.rel ("_f1b4");            // branch if error, this doesn't get taken as the last
                                                           // instruction in the get byte from RS232 device routine
                                                           // is CLC ??
/* f1bd */                   CMP.imm (0x00);               // compare with null
/* f1bf */                   BNE.rel ("_f1b3");            // exit if not null
/* f1c1 */                   LDA.abs ("rsstat_0297");      // get the RS232 status register
/* f1c4 */                   AND.imm (0x60);               // mask 0xx0 0000, DSR detected and ??
/* f1c6 */                   BNE.rel ("_f1b1");            // if ?? return null
/* f1c8 */                   BEQ.rel ("_f1b8");            // else loop, branch always

// ------------------------------------------------------- // output character to channel
/* f1ca */  _`chrout_f1ca`;  PHA.imp ();                   // save the character to output
/* f1cb */                   LDA.zpg ("dflto_009a");       // get the output device number
/* f1cd */                   CMP.imm (0x03);               // compare the output device with the screen
/* f1cf */                   BNE.rel ("_f1d5");            // if not the screen go ??
/* f1d1 */                   PLA.imp ();                   // else restore the output character
/* f1d2 */                   JMP.abs ("_e716");            // go output the character to the screen
/* f1d5 */        _`_f1d5`;  BCC.rel ("_f1db");            // if < screen go ??
/* f1d7 */                   PLA.imp ();                   // else restore the output character
/* f1d8 */                   JMP.abs ("ciout_eddd");       // go output the character to the serial bus
/* f1db */        _`_f1db`;  LSR.acc ();                   // shift b0 of the device into Cb
/* f1dc */                   PLA.imp ();                   // restore the output character

// ------------------------------------------------------- // output the character to the cassette or RS232 device
/* f1dd */        _`_f1dd`;  STA.zpg ("ptr1_009e");        // save the character to the character buffer
/* f1df */                   TXA.imp ();                   // copy X
/* f1e0 */                   PHA.imp ();                   // save X
/* f1e1 */                   TYA.imp ();                   // copy Y
/* f1e2 */                   PHA.imp ();                   // save Y
/* f1e3 */                   BCC.rel ("_f208");            // if Cb is clear it must be the RS232 device
                                                           // output the character to the cassette
/* f1e5 */                   JSR.abs ("_f80d");            // bump the tape pointer
/* f1e8 */                   BNE.rel ("_f1f8");            // if not end save next byte and exit
/* f1ea */                   JSR.abs ("_f864");            // initiate tape write
/* f1ed */                   BCS.rel ("_f1fd");            // exit if error
/* f1ef */                   LDA.imm (0x02);               // set data block type ??
/* f1f1 */                   LDY.imm (0x00);               // clear index
/* f1f3 */                   STA.iny ("tape1+0_00b2");     // save type to buffer ??
/* f1f5 */                   INY.imp ();                   // increment index
/* f1f6 */                   STY.zpg ("bufpnt_00a6");      // save tape buffer index
/* f1f8 */        _`_f1f8`;  LDA.zpg ("ptr1_009e");        // restore character from character buffer
/* f1fa */                   STA.iny ("tape1+0_00b2");     // save to buffer
/* f1fc */        _`_f1fc`;  CLC.imp ();                   // flag no error
/* f1fd */        _`_f1fd`;  PLA.imp ();                   // pull Y
/* f1fe */                   TAY.imp ();                   // restore Y
/* f1ff */                   PLA.imp ();                   // pull X
/* f200 */                   TAX.imp ();                   // restore X
/* f201 */                   LDA.zpg ("ptr1_009e");        // get the character from the character buffer
/* f203 */                   BCC.rel ("_f207");            // exit if no error
/* f205 */                   LDA.imm (0x00);               // else clear A
/* f207 */        _`_f207`;  RTS.imp ();
                                                           // output the character to the RS232 device
/* f208 */        _`_f208`;  JSR.abs ("_f017");            // send byte to the RS232 buffer, no setup
/* f20b */                   JMP.abs ("_f1fc");            // do no error exit

// ------------------------------------------------------- // open channel for input
/* f20e */   _`chkin_f20e`;  JSR.abs ("_f30f");            // find a file
/* f211 */                   BEQ.rel ("_f216");            // if the file is open continue
/* f213 */                   JMP.abs ("_f701");            // else do 'file not open' error and return
/* f216 */        _`_f216`;  JSR.abs ("_f31f");            // set file details from table,X
/* f219 */                   LDA.zpg ("fa_00ba");          // get the device number
/* f21b */                   BEQ.rel ("_f233");            // if the device was the keyboard save the device #, flag
                                                           // ok and exit
/* f21d */                   CMP.imm (0x03);               // compare the device number with the screen
/* f21f */                   BEQ.rel ("_f233");            // if the device was the screen save the device #, flag ok
                                                           // and exit
/* f221 */                   BCS.rel ("_f237");            // if the device was a serial bus device go ??
/* f223 */                   CMP.imm (0x02);               // else compare the device with the RS232 device
/* f225 */                   BNE.rel ("_f22a");            // if not the RS232 device continue
/* f227 */                   JMP.abs ("_f04d");            // else go get input from the RS232 buffer and return
/* f22a */        _`_f22a`;  LDX.zpg ("sa_00b9");          // get the secondary address
/* f22c */                   CPX.imm (0x60);
/* f22e */                   BEQ.rel ("_f233");
/* f230 */                   JMP.abs ("_f70a");            // go do 'not input file' error and return
/* f233 */        _`_f233`;  STA.zpg ("dfltn_0099");       // save the input device number
/* f235 */                   CLC.imp ();                   // flag ok
/* f236 */                   RTS.imp ();
                                                           // the device was a serial bus device
/* f237 */        _`_f237`;  TAX.imp ();                   // copy device number to X
/* f238 */                   JSR.abs ("talk_ed09");        // command serial bus device to TALK
/* f23b */                   LDA.zpg ("sa_00b9");          // get the secondary address
/* f23d */                   BPL.rel ("_f245");
/* f23f */                   JSR.abs ("_edcc");            // wait for the serial bus end after send
/* f242 */                   JMP.abs ("_f248");
/* f245 */        _`_f245`;  JSR.abs ("tksa_edc7");        // send secondary address after TALK
/* f248 */        _`_f248`;  TXA.imp ();                   // copy device back to A
/* f249 */                   BIT.zpg ("status_0090");      // test the serial status byte
/* f24b */                   BPL.rel ("_f233");            // if device present save device number and exit
/* f24d */                   JMP.abs ("_f707");            // do 'device not present' error and return

// ------------------------------------------------------- // open channel for output
/* f250 */  _`chkout_f250`;  JSR.abs ("_f30f");            // find a file
/* f253 */                   BEQ.rel ("_f258");            // if file found continue
/* f255 */                   JMP.abs ("_f701");            // else do 'file not open' error and return
/* f258 */        _`_f258`;  JSR.abs ("_f31f");            // set file details from table,X
/* f25b */                   LDA.zpg ("fa_00ba");          // get the device number
/* f25d */                   BNE.rel ("_f262");            // if the device is not the keyboard go ??
/* f25f */        _`_f25f`;  JMP.abs ("_f70d");            // go do 'not output file' error and return
/* f262 */        _`_f262`;  CMP.imm (0x03);               // compare the device with the screen
/* f264 */                   BEQ.rel ("_f275");            // if the device is the screen go save output the output
                                                           // device number and exit
/* f266 */                   BCS.rel ("_f279");            // if > screen then go handle a serial bus device
/* f268 */                   CMP.imm (0x02);               // compare the device with the RS232 device
/* f26a */                   BNE.rel ("_f26f");            // if not the RS232 device then it must be the tape device
/* f26c */                   JMP.abs ("_efe1");            // else go open RS232 channel for output
                                                           // open a tape channel for output
/* f26f */        _`_f26f`;  LDX.zpg ("sa_00b9");          // get the secondary address
/* f271 */                   CPX.imm (0x60);
/* f273 */                   BEQ.rel ("_f25f");            // if ?? do not output file error and return
/* f275 */        _`_f275`;  STA.zpg ("dflto_009a");       // save the output device number
/* f277 */                   CLC.imp ();                   // flag ok
/* f278 */                   RTS.imp ();
/* f279 */        _`_f279`;  TAX.imp ();                   // copy the device number
/* f27a */                   JSR.abs ("listen_ed0c");      // command devices on the serial bus to LISTEN
/* f27d */                   LDA.zpg ("sa_00b9");          // get the secondary address
/* f27f */                   BPL.rel ("_f286");            // if address to send go ??
/* f281 */                   JSR.abs ("_edbe");            // else set serial ATN high
/* f284 */                   BNE.rel ("_f289");            // go ??, branch always
/* f286 */        _`_f286`;  JSR.abs ("second_edb9");      // send secondary address after LISTEN
/* f289 */        _`_f289`;  TXA.imp ();                   // copy device number back to A
/* f28a */                   BIT.zpg ("status_0090");      // test the serial status byte
/* f28c */                   BPL.rel ("_f275");            // if the device is present go save the output device number
                                                           // and exit
/* f28e */                   JMP.abs ("_f707");            // else do 'device not present error' and return

// ------------------------------------------------------- // close a specified logical file
/* f291 */   _`close_f291`;  JSR.abs ("_f314");            // find file A
/* f294 */                   BEQ.rel ("_f298");            // if file found go close it
/* f296 */                   CLC.imp ();                   // else the file was closed so just flag ok
/* f297 */                   RTS.imp ();
                                                           // file found so close it
/* f298 */        _`_f298`;  JSR.abs ("_f31f");            // set file details from table,X
/* f29b */                   TXA.imp ();                   // copy file index to A
/* f29c */                   PHA.imp ();                   // save file index
/* f29d */                   LDA.zpg ("fa_00ba");          // get the device number
/* f29f */                   BEQ.rel ("_f2f1");            // if it is the keyboard go restore the index and close the
                                                           // file
/* f2a1 */                   CMP.imm (0x03);               // compare the device number with the screen
/* f2a3 */                   BEQ.rel ("_f2f1");            // if it is the screen go restore the index and close the
                                                           // file
/* f2a5 */                   BCS.rel ("_f2ee");            // if > screen go do serial bus device close
/* f2a7 */                   CMP.imm (0x02);               // compare the device with the RS232 device
/* f2a9 */                   BNE.rel ("_f2c8");            // if not the RS232 device go ??
                                                           // else close RS232 device
/* f2ab */                   PLA.imp ();                   // restore file index
/* f2ac */                   JSR.abs ("_f2f2");            // close file index X
/* f2af */                   JSR.abs ("_f483");            // initialise RS232 output
/* f2b2 */                   JSR.abs ("_fe27");            // read the top of memory
/* f2b5 */                   LDA.zpg ("ribuf+1_00f8");     // get the RS232 input buffer pointer high byte
/* f2b7 */                   BEQ.rel ("_f2ba");            // if no RS232 input buffer go ??
/* f2b9 */                   INY.imp ();                   // else reclaim RS232 input buffer memory
/* f2ba */        _`_f2ba`;  LDA.zpg ("robuf+1_00fa");     // get the RS232 output buffer pointer high byte
/* f2bc */                   BEQ.rel ("_f2bf");            // if no RS232 output buffer skip the reclaim
/* f2be */                   INY.imp ();                   // else reclaim the RS232 output buffer memory
/* f2bf */        _`_f2bf`;  LDA.imm (0x00);               // clear A
/* f2c1 */                   STA.zpg ("ribuf+1_00f8");     // clear the RS232 input buffer pointer high byte
/* f2c3 */                   STA.zpg ("robuf+1_00fa");     // clear the RS232 output buffer pointer high byte
/* f2c5 */                   JMP.abs ("_f47d");            // go set the top of memory to F0xx
                                                           // is not the RS232 device
/* f2c8 */        _`_f2c8`;  LDA.zpg ("sa_00b9");          // get the secondary address
/* f2ca */                   AND.imm (0x0f);               // mask the device #
/* f2cc */                   BEQ.rel ("_f2f1");            // if ?? restore index and close file
/* f2ce */                   JSR.abs ("_f7d0");            // get tape buffer start pointer in XY
/* f2d1 */                   LDA.imm (0x00);               // character $00
/* f2d3 */                   SEC.imp ();                   // flag the tape device
/* f2d4 */                   JSR.abs ("_f1dd");            // output the character to the cassette or RS232 device
/* f2d7 */                   JSR.abs ("_f864");            // initiate tape write
/* f2da */                   BCC.rel ("_f2e0");
/* f2dc */                   PLA.imp ();
/* f2dd */                   LDA.imm (0x00);
/* f2df */                   RTS.imp ();
/* f2e0 */        _`_f2e0`;  LDA.zpg ("sa_00b9");          // get the secondary address
/* f2e2 */                   CMP.imm (0x62);
/* f2e4 */                   BNE.rel ("_f2f1");            // if not ?? restore index and close file
/* f2e6 */                   LDA.imm (0x05);               // set logical end of the tape
/* f2e8 */                   JSR.abs ("_f76a");            // write tape header
/* f2eb */                   JMP.abs ("_f2f1");            // restore index and close file

// ------------------------------------------------------- // serial bus device close
/* f2ee */        _`_f2ee`;  JSR.abs ("_f642");            // close serial bus device
/* f2f1 */        _`_f2f1`;  PLA.imp ();                   // restore file index

// ------------------------------------------------------- // close file index X
/* f2f2 */        _`_f2f2`;  TAX.imp ();                   // copy index to file to close
/* f2f3 */                   DEC.zpg ("ldtnd_0098");       // decrement the open file count
/* f2f5 */                   CPX.zpg ("ldtnd_0098");       // compare the index with the open file count
/* f2f7 */                   BEQ.rel ("_f30d");            // exit if equal, last entry was closing file
                                                           // else entry was not last in list so copy last table entry
                                                           // file details over the details of the closing one
/* f2f9 */                   LDY.zpg ("ldtnd_0098");       // get the open file count as index
/* f2fb */                   LDA.aby ("lat+0_0259");       // get last+1 logical file number from logical file table
/* f2fe */                   STA.abx ("lat+0_0259");       // save logical file number over closed file
/* f301 */                   LDA.aby ("fat+0_0263");       // get last+1 device number from device number table
/* f304 */                   STA.abx ("fat+0_0263");       // save device number over closed file
/* f307 */                   LDA.aby ("sat+0_026d");       // get last+1 secondary address from secondary address table
/* f30a */                   STA.abx ("sat+0_026d");       // save secondary address over closed file
/* f30d */        _`_f30d`;  CLC.imp ();                   // flag ok
/* f30e */                   RTS.imp ();

// ------------------------------------------------------- // find a file
/* f30f */        _`_f30f`;  LDA.imm (0x00);               // clear A
/* f311 */                   STA.zpg ("status_0090");      // clear the serial status byte
/* f313 */                   TXA.imp ();                   // copy the logical file number to A

// ------------------------------------------------------- // find file A
/* f314 */        _`_f314`;  LDX.zpg ("ldtnd_0098");       // get the open file count
/* f316 */        _`_f316`;  DEX.imp ();                   // decrememnt the count to give the index
/* f317 */                   BMI.rel ("_f32e");            // if no files just exit
/* f319 */                   CMP.abx ("lat+0_0259");       // compare the logical file number with the table logical
                                                           // file number
/* f31c */                   BNE.rel ("_f316");            // if no match go try again
/* f31e */                   RTS.imp ();

// ------------------------------------------------------- // set file details from table,X
/* f31f */        _`_f31f`;  LDA.abx ("lat+0_0259");       // get logical file from logical file table
/* f322 */                   STA.zpg ("la_00b8");          // save the logical file
/* f324 */                   LDA.abx ("fat+0_0263");       // get device number from device number table
/* f327 */                   STA.zpg ("fa_00ba");          // save the device number
/* f329 */                   LDA.abx ("sat+0_026d");       // get secondary address from secondary address table
/* f32c */                   STA.zpg ("sa_00b9");          // save the secondary address
/* f32e */        _`_f32e`;  RTS.imp ();

// ------------------------------------------------------- // close all channels and files
/* f32f */   _`clall_f32f`;  LDA.imm (0x00);               // clear A
/* f331 */                   STA.zpg ("ldtnd_0098");       // clear the open file count

// ------------------------------------------------------- // close input and output channels
/* f333 */  _`clrchn_f333`;  LDX.imm (0x03);               // set the screen device
/* f335 */                   CPX.zpg ("dflto_009a");       // compare the screen with the output device number
/* f337 */                   BCS.rel ("_f33c");            // if <= screen skip the serial bus unlisten
/* f339 */                   JSR.abs ("unlsn_edfe");       // else command the serial bus to UNLISTEN
/* f33c */        _`_f33c`;  CPX.zpg ("dfltn_0099");       // compare the screen with the input device number
/* f33e */                   BCS.rel ("_f343");            // if <= screen skip the serial bus untalk
/* f340 */                   JSR.abs ("untlk_edef");       // else command the serial bus to UNTALK
/* f343 */        _`_f343`;  STX.zpg ("dflto_009a");       // save the screen as the output device number
/* f345 */                   LDA.imm (0x00);               // set the keyboard as the input device
/* f347 */                   STA.zpg ("dfltn_0099");       // save the input device number
/* f349 */                   RTS.imp ();

// ------------------------------------------------------- // open a logical file
/* f34a */    _`open_f34a`;  LDX.zpg ("la_00b8");          // get the logical file
/* f34c */                   BNE.rel ("_f351");            // if there is a file continue
/* f34e */                   JMP.abs ("_f70a");            // else do 'not input file error' and return
/* f351 */        _`_f351`;  JSR.abs ("_f30f");            // find a file
/* f354 */                   BNE.rel ("_f359");            // if file not found continue
/* f356 */                   JMP.abs ("_f6fe");            // else do 'file already open' error and return
/* f359 */        _`_f359`;  LDX.zpg ("ldtnd_0098");       // get the open file count
/* f35b */                   CPX.imm (0x0a);               // compare it with the maximum + 1
/* f35d */                   BCC.rel ("_f362");            // if less than maximum + 1 go open the file
/* f35f */                   JMP.abs ("_f6fb");            // else do 'too many files error' and return
/* f362 */        _`_f362`;  INC.zpg ("ldtnd_0098");       // increment the open file count
/* f364 */                   LDA.zpg ("la_00b8");          // get the logical file
/* f366 */                   STA.abx ("lat+0_0259");       // save it to the logical file table
/* f369 */                   LDA.zpg ("sa_00b9");          // get the secondary address
/* f36b */                   ORA.imm (0x60);               // OR with the OPEN CHANNEL command
/* f36d */                   STA.zpg ("sa_00b9");          // save the secondary address
/* f36f */                   STA.abx ("sat+0_026d");       // save it to the secondary address table
/* f372 */                   LDA.zpg ("fa_00ba");          // get the device number
/* f374 */                   STA.abx ("fat+0_0263");       // save it to the device number table
/* f377 */                   BEQ.rel ("_f3d3");            // if it is the keyboard go do the ok exit
/* f379 */                   CMP.imm (0x03);               // compare the device number with the screen
/* f37b */                   BEQ.rel ("_f3d3");            // if it is the screen go do the ok exit
/* f37d */                   BCC.rel ("_f384");            // if tape or RS232 device go ??
                                                           // else it is a serial bus device
/* f37f */                   JSR.abs ("_f3d5");            // send the secondary address and filename
/* f382 */                   BCC.rel ("_f3d3");            // go do ok exit, branch always
/* f384 */        _`_f384`;  CMP.imm (0x02);
/* f386 */                   BNE.rel ("_f38b");
/* f388 */                   JMP.abs ("_f409");            // go open RS232 device and return
/* f38b */        _`_f38b`;  JSR.abs ("_f7d0");            // get tape buffer start pointer in XY
/* f38e */                   BCS.rel ("_f393");            // if >= $0200 go ??
/* f390 */                   JMP.abs ("_f713");            // else do 'illegal device number' and return
/* f393 */        _`_f393`;  LDA.zpg ("sa_00b9");          // get the secondary address
/* f395 */                   AND.imm (0x0f);
/* f397 */                   BNE.rel ("_f3b8");
/* f399 */                   JSR.abs ("_f817");            // wait for PLAY
/* f39c */                   BCS.rel ("_f3d4");            // exit if STOP was pressed
/* f39e */                   JSR.abs ("_f5af");            // print "Searching..."
/* f3a1 */                   LDA.zpg ("fnlen_00b7");       // get file name length
/* f3a3 */                   BEQ.rel ("_f3af");            // if null file name just go find header
/* f3a5 */                   JSR.abs ("_f7ea");            // find specific tape header
/* f3a8 */                   BCC.rel ("_f3c2");            // branch if no error
/* f3aa */                   BEQ.rel ("_f3d4");            // exit if ??
/* f3ac */        _`_f3ac`;  JMP.abs ("_f704");            // do file not found error and return
/* f3af */        _`_f3af`;  JSR.abs ("_f72c");            // find tape header, exit with header in buffer
/* f3b2 */                   BEQ.rel ("_f3d4");            // exit if end of tape found
/* f3b4 */                   BCC.rel ("_f3c2");
/* f3b6 */                   BCS.rel ("_f3ac");
/* f3b8 */        _`_f3b8`;  JSR.abs ("_f838");            // wait for PLAY/RECORD
/* f3bb */                   BCS.rel ("_f3d4");            // exit if STOP was pressed
/* f3bd */                   LDA.imm (0x04);               // set data file header
/* f3bf */                   JSR.abs ("_f76a");            // write tape header
/* f3c2 */        _`_f3c2`;  LDA.imm (0xbf);
/* f3c4 */                   LDY.zpg ("sa_00b9");          // get the secondary address
/* f3c6 */                   CPY.imm (0x60);
/* f3c8 */                   BEQ.rel ("_f3d1");
/* f3ca */                   LDY.imm (0x00);               // clear index
/* f3cc */                   LDA.imm (0x02);
/* f3ce */                   STA.iny ("tape1+0_00b2");     // save to tape buffer
/* f3d0 */                   TYA.imp ();                   // clear A
/* f3d1 */        _`_f3d1`;  STA.zpg ("bufpnt_00a6");      // save tape buffer index
/* f3d3 */        _`_f3d3`;  CLC.imp ();                   // flag ok
/* f3d4 */        _`_f3d4`;  RTS.imp ();

// ------------------------------------------------------- // send secondary address and filename
/* f3d5 */        _`_f3d5`;  LDA.zpg ("sa_00b9");          // get the secondary address
/* f3d7 */                   BMI.rel ("_f3d3");            // ok exit if -ve
/* f3d9 */                   LDY.zpg ("fnlen_00b7");       // get file name length
/* f3db */                   BEQ.rel ("_f3d3");            // ok exit if null
/* f3dd */                   LDA.imm (0x00);               // clear A
/* f3df */                   STA.zpg ("status_0090");      // clear the serial status byte
/* f3e1 */                   LDA.zpg ("fa_00ba");          // get the device number
/* f3e3 */                   JSR.abs ("listen_ed0c");      // command devices on the serial bus to LISTEN
/* f3e6 */                   LDA.zpg ("sa_00b9");          // get the secondary address
/* f3e8 */                   ORA.imm (0xf0);               // OR with the OPEN command
/* f3ea */                   JSR.abs ("second_edb9");      // send secondary address after LISTEN
/* f3ed */                   LDA.zpg ("status_0090");      // get the serial status byte
/* f3ef */                   BPL.rel ("_f3f6");            // if device present skip the 'device not present' error
/* f3f1 */                   PLA.imp ();                   // else dump calling address low byte
/* f3f2 */                   PLA.imp ();                   // dump calling address high byte
/* f3f3 */                   JMP.abs ("_f707");            // do 'device not present' error and return
/* f3f6 */        _`_f3f6`;  LDA.zpg ("fnlen_00b7");       // get file name length
/* f3f8 */                   BEQ.rel ("_f406");            // branch if null name
/* f3fa */                   LDY.imm (0x00);               // clear index
/* f3fc */        _`_f3fc`;  LDA.iny ("fnadr+0_00bb");     // get file name byte
/* f3fe */                   JSR.abs ("ciout_eddd");       // output byte to serial bus
/* f401 */                   INY.imp ();                   // increment index
/* f402 */                   CPY.zpg ("fnlen_00b7");       // compare with file name length
/* f404 */                   BNE.rel ("_f3fc");            // loop if not all done
/* f406 */        _`_f406`;  JMP.abs ("_f654");            // command serial bus to UNLISTEN and return

// ------------------------------------------------------- // open RS232 device
/* f409 */        _`_f409`;  JSR.abs ("_f483");            // initialise RS232 output
/* f40c */                   STY.abs ("rsstat_0297");      // save the RS232 status register
/* f40f */        _`_f40f`;  CPY.zpg ("fnlen_00b7");       // compare with file name length
/* f411 */                   BEQ.rel ("_f41d");            // exit loop if done
/* f413 */                   LDA.iny ("fnadr+0_00bb");     // get file name byte
/* f415 */                   STA.aby ("m51ctr_0293");      // copy to 6551 register set
/* f418 */                   INY.imp ();                   // increment index
/* f419 */                   CPY.imm (0x04);               // compare with $04
/* f41b */                   BNE.rel ("_f40f");            // loop if not to 4 yet
/* f41d */        _`_f41d`;  JSR.abs ("_ef4a");            // compute bit count
/* f420 */                   STX.abs ("bitnum_0298");      // save bit count
/* f423 */                   LDA.abs ("m51ctr_0293");      // get pseudo 6551 control register
/* f426 */                   AND.imm (0x0f);               // mask 0000 xxxx, baud rate
/* f428 */                   BEQ.rel ("_f446");            // if zero skip the baud rate setup
/* f42a */                   ASL.acc ();                   // * 2 bytes per entry
/* f42b */                   TAX.imp ();                   // copy to the index
/* f42c */                   LDA.abs ("tvsflg_02a6");      // get the PAL/NTSC flag
/* f42f */                   BNE.rel ("_f43a");            // if PAL go set PAL timing
/* f431 */                   LDY.abx ("_fec1");            // get the NTSC baud rate value high byte
/* f434 */                   LDA.abx ("_fec0");            // get the NTSC baud rate value low byte
/* f437 */                   JMP.abs ("_f440");            // go save the baud rate values
/* f43a */        _`_f43a`;  LDY.abx ("_e4eb");            // get the PAL baud rate value high byte
/* f43d */                   LDA.abx (0xe4ea);             // get the PAL baud rate value low byte
/* f440 */        _`_f440`;  STY.abs ("m51ajb+1_0296");    // save the nonstandard bit timing high byte
/* f443 */                   STA.abs ("m51ajb+0_0295");    // save the nonstandard bit timing low byte
/* f446 */        _`_f446`;  LDA.abs ("m51ajb+0_0295");    // get the nonstandard bit timing low byte
/* f449 */                   ASL.acc ();                   // * 2
/* f44a */                   JSR.abs ("_ff2e");
/* f44d */                   LDA.abs ("m51cdr_0294");      // read the pseudo 6551 command register
/* f450 */                   LSR.acc ();                   // shift the X line/3 line bit into Cb
/* f451 */                   BCC.rel ("_f45c");            // if 3 line skip the DRS test
/* f453 */                   LDA.abs ("ci2prb_dd01");      // read VIA 2 DRB, RS232 port
/* f456 */                   ASL.acc ();                   // shift DSR in into Cb
/* f457 */                   BCS.rel ("_f45c");            // if DSR present skip the error set
/* f459 */                   JSR.abs ("_f00d");            // set no DSR
/* f45c */        _`_f45c`;  LDA.abs ("ridbe_029b");       // get index to Rx buffer end
/* f45f */                   STA.abs ("ridbs_029c");       // set index to Rx buffer start, clear Rx buffer
/* f462 */                   LDA.abs ("rodbe_029e");       // get index to Tx buffer end
/* f465 */                   STA.abs ("rodbs_029d");       // set index to Tx buffer start, clear Tx buffer
/* f468 */                   JSR.abs ("_fe27");            // read the top of memory
/* f46b */                   LDA.zpg ("ribuf+1_00f8");     // get the RS232 input buffer pointer high byte
/* f46d */                   BNE.rel ("_f474");            // if buffer already set skip the save
/* f46f */                   DEY.imp ();                   // decrement top of memory high byte, 256 byte buffer
/* f470 */                   STY.zpg ("ribuf+1_00f8");     // save the RS232 input buffer pointer high byte
/* f472 */                   STX.zpg ("ribuf+0_00f7");     // save the RS232 input buffer pointer low byte
/* f474 */        _`_f474`;  LDA.zpg ("robuf+1_00fa");     // get the RS232 output buffer pointer high byte
/* f476 */                   BNE.rel ("_f47d");            // if ?? go set the top of memory to F0xx
/* f478 */                   DEY.imp ();
/* f479 */                   STY.zpg ("robuf+1_00fa");     // save the RS232 output buffer pointer high byte
/* f47b */                   STX.zpg ("robuf+0_00f9");     // save the RS232 output buffer pointer low byte

// ------------------------------------------------------- // set the top of memory to F0xx
/* f47d */        _`_f47d`;  SEC.imp ();                   // read the top of memory
/* f47e */                   LDA.imm (0xf0);               // set $F000
/* f480 */                   JMP.abs ("_fe2d");            // set the top of memory and return

// ------------------------------------------------------- // initialise RS232 output
/* f483 */        _`_f483`;  LDA.imm (0x7f);               // disable all interrupts
/* f485 */                   STA.abs ("ci2icr_dd0d");      // save VIA 2 ICR
/* f488 */                   LDA.imm (0x06);               // set RS232 DTR output, RS232 RTS output
/* f48a */                   STA.abs ("c2ddrb_dd03");      // save VIA 2 DDRB, RS232 port
/* f48d */                   STA.abs ("ci2prb_dd01");      // save VIA 2 DRB, RS232 port
/* f490 */                   LDA.imm (0x04);               // mask xxxx x1xx, set RS232 Tx DATA high
/* f492 */                   ORA.abs ("ci2pra_dd00");      // OR it with VIA 2 DRA, serial port and video address
/* f495 */                   STA.abs ("ci2pra_dd00");      // save VIA 2 DRA, serial port and video address
/* f498 */                   LDY.imm (0x00);               // clear Y
/* f49a */                   STY.abs ("enabl_02a1");       // clear the RS-232 interrupt enable byte
/* f49d */                   RTS.imp ();

// ------------------------------------------------------- // load RAM from a device
/* f49e */    _`load_f49e`;  STX.zpg ("memuss+0_00c3");    // set kernal setup pointer low byte
/* f4a0 */                   STY.zpg ("memuss+1_00c4");    // set kernal setup pointer high byte
/* f4a2 */                   JMP.ind ("iload+0_0330");     // do LOAD vector, usually points to $F4A5

// ------------------------------------------------------- // load
/* f4a5 */                   STA.zpg ("verck_0093");       // save load/verify flag
/* f4a7 */                   LDA.imm (0x00);               // clear A
/* f4a9 */                   STA.zpg ("status_0090");      // clear the serial status byte
/* f4ab */                   LDA.zpg ("fa_00ba");          // get the device number
/* f4ad */                   BNE.rel ("_f4b2");            // if not the keyboard continue
                                                           // do 'illegal device number'
/* f4af */        _`_f4af`;  JMP.abs ("_f713");            // else do 'illegal device number' and return
/* f4b2 */        _`_f4b2`;  CMP.imm (0x03);
/* f4b4 */                   BEQ.rel ("_f4af");
/* f4b6 */                   BCC.rel ("_f533");
/* f4b8 */                   LDY.zpg ("fnlen_00b7");       // get file name length
/* f4ba */                   BNE.rel ("_f4bf");            // if not null name go ??
/* f4bc */                   JMP.abs ("_f710");            // else do 'missing file name' error and return
/* f4bf */        _`_f4bf`;  LDX.zpg ("sa_00b9");          // get the secondary address
/* f4c1 */                   JSR.abs ("_f5af");            // print "Searching..."
/* f4c4 */                   LDA.imm (0x60);
/* f4c6 */                   STA.zpg ("sa_00b9");          // save the secondary address
/* f4c8 */                   JSR.abs ("_f3d5");            // send secondary address and filename
/* f4cb */                   LDA.zpg ("fa_00ba");          // get the device number
/* f4cd */                   JSR.abs ("talk_ed09");        // command serial bus device to TALK
/* f4d0 */                   LDA.zpg ("sa_00b9");          // get the secondary address
/* f4d2 */                   JSR.abs ("tksa_edc7");        // send secondary address after TALK
/* f4d5 */                   JSR.abs ("acptr_ee13");       // input byte from serial bus
/* f4d8 */                   STA.zpg ("eal+0_00ae");       // save program start address low byte
/* f4da */                   LDA.zpg ("status_0090");      // get the serial status byte
/* f4dc */                   LSR.acc ();                   // shift time out read ..
/* f4dd */                   LSR.acc ();                   // .. into carry bit
/* f4de */                   BCS.rel ("_f530");            // if timed out go do file not found error and return
/* f4e0 */                   JSR.abs ("acptr_ee13");       // input byte from serial bus
/* f4e3 */                   STA.zpg ("eal+1_00af");       // save program start address high byte
/* f4e5 */                   TXA.imp ();                   // copy secondary address
/* f4e6 */                   BNE.rel ("_f4f0");            // load location not set in LOAD call, so continue with the
                                                           // load
/* f4e8 */                   LDA.zpg ("memuss+0_00c3");    // get the load address low byte
/* f4ea */                   STA.zpg ("eal+0_00ae");       // save the program start address low byte
/* f4ec */                   LDA.zpg ("memuss+1_00c4");    // get the load address high byte
/* f4ee */                   STA.zpg ("eal+1_00af");       // save the program start address high byte
/* f4f0 */        _`_f4f0`;  JSR.abs ("_f5d2");
/* f4f3 */        _`_f4f3`;  LDA.imm (0xfd);               // mask xxxx xx0x, clear time out read bit
/* f4f5 */                   AND.zpg ("status_0090");      // mask the serial status byte
/* f4f7 */                   STA.zpg ("status_0090");      // set the serial status byte
/* f4f9 */                   JSR.abs ("stop_ffe1");        // scan stop key, return Zb = 1 = [STOP]
/* f4fc */                   BNE.rel ("_f501");            // if not [STOP] go ??
/* f4fe */                   JMP.abs ("_f633");            // else close the serial bus device and flag stop
/* f501 */        _`_f501`;  JSR.abs ("acptr_ee13");       // input byte from serial bus
/* f504 */                   TAX.imp ();                   // copy byte
/* f505 */                   LDA.zpg ("status_0090");      // get the serial status byte
/* f507 */                   LSR.acc ();                   // shift time out read ..
/* f508 */                   LSR.acc ();                   // .. into carry bit
/* f509 */                   BCS.rel ("_f4f3");            // if timed out go try again
/* f50b */                   TXA.imp ();                   // copy received byte back
/* f50c */                   LDY.zpg ("verck_0093");       // get load/verify flag
/* f50e */                   BEQ.rel ("_f51c");            // if load go load
                                                           // else is verify
/* f510 */                   LDY.imm (0x00);               // clear index
/* f512 */                   CMP.iny ("eal+0_00ae");       // compare byte with previously loaded byte
/* f514 */                   BEQ.rel ("_f51e");            // if match go ??
/* f516 */                   LDA.imm (0x10);               // flag read error
/* f518 */                   JSR.abs ("_fe1c");            // OR into the serial status byte
/* f51b */                   _.bytes(0x2c);                // makes next line BIT $AE91
/* f51c */        _`_f51c`;  STA.iny ("eal+0_00ae");       // save byte to memory
/* f51e */        _`_f51e`;  INC.zpg ("eal+0_00ae");       // increment save pointer low byte
/* f520 */                   BNE.rel ("_f524");            // if no rollover go ??
/* f522 */                   INC.zpg ("eal+1_00af");       // else increment save pointer high byte
/* f524 */        _`_f524`;  BIT.zpg ("status_0090");      // test the serial status byte
/* f526 */                   BVC.rel ("_f4f3");            // loop if not end of file
                                                           // close file and exit
/* f528 */                   JSR.abs ("untlk_edef");       // command serial bus to UNTALK
/* f52b */                   JSR.abs ("_f642");            // close serial bus device
/* f52e */                   BCC.rel ("_f5a9");            // if ?? go flag ok and exit
/* f530 */        _`_f530`;  JMP.abs ("_f704");            // do file not found error and return

// ------------------------------------------------------- // ??
/* f533 */        _`_f533`;  LSR.acc ();
/* f534 */                   BCS.rel ("_f539");
/* f536 */                   JMP.abs ("_f713");            // else do 'illegal device number' and return
/* f539 */        _`_f539`;  JSR.abs ("_f7d0");            // get tape buffer start pointer in XY
/* f53c */                   BCS.rel ("_f541");            // if ??
/* f53e */                   JMP.abs ("_f713");            // else do 'illegal device number' and return
/* f541 */        _`_f541`;  JSR.abs ("_f817");            // wait for PLAY
/* f544 */                   BCS.rel ("_f5ae");            // exit if STOP was pressed
/* f546 */                   JSR.abs ("_f5af");            // print "Searching..."
/* f549 */        _`_f549`;  LDA.zpg ("fnlen_00b7");       // get file name length
/* f54b */                   BEQ.rel ("_f556");
/* f54d */                   JSR.abs ("_f7ea");            // find specific tape header
/* f550 */                   BCC.rel ("_f55d");            // if no error continue
/* f552 */                   BEQ.rel ("_f5ae");            // exit if ??
/* f554 */                   BCS.rel ("_f530");            // , branch always
/* f556 */        _`_f556`;  JSR.abs ("_f72c");            // find tape header, exit with header in buffer
/* f559 */                   BEQ.rel ("_f5ae");            // exit if ??
/* f55b */                   BCS.rel ("_f530");
/* f55d */        _`_f55d`;  LDA.zpg ("status_0090");      // get the serial status byte
/* f55f */                   AND.imm (0x10);               // mask 000x 0000, read error
/* f561 */                   SEC.imp ();                   // flag fail
/* f562 */                   BNE.rel ("_f5ae");            // if read error just exit
/* f564 */                   CPX.imm (0x01);
/* f566 */                   BEQ.rel ("_f579");
/* f568 */                   CPX.imm (0x03);
/* f56a */                   BNE.rel ("_f549");
/* f56c */        _`_f56c`;  LDY.imm (0x01);
/* f56e */                   LDA.iny ("tape1+0_00b2");
/* f570 */                   STA.zpg ("memuss+0_00c3");
/* f572 */                   INY.imp ();
/* f573 */                   LDA.iny ("tape1+0_00b2");
/* f575 */                   STA.zpg ("memuss+1_00c4");
/* f577 */                   BCS.rel ("_f57d");
/* f579 */        _`_f579`;  LDA.zpg ("sa_00b9");          // get the secondary address
/* f57b */                   BNE.rel ("_f56c");
/* f57d */        _`_f57d`;  LDY.imm (0x03);
/* f57f */                   LDA.iny ("tape1+0_00b2");
/* f581 */                   LDY.imm (0x01);
/* f583 */                   SBC.iny ("tape1+0_00b2");
/* f585 */                   TAX.imp ();
/* f586 */                   LDY.imm (0x04);
/* f588 */                   LDA.iny ("tape1+0_00b2");
/* f58a */                   LDY.imm (0x02);
/* f58c */                   SBC.iny ("tape1+0_00b2");
/* f58e */                   TAY.imp ();
/* f58f */                   CLC.imp ();
/* f590 */                   TXA.imp ();
/* f591 */                   ADC.zpg ("memuss+0_00c3");
/* f593 */                   STA.zpg ("eal+0_00ae");
/* f595 */                   TYA.imp ();
/* f596 */                   ADC.zpg ("memuss+1_00c4");
/* f598 */                   STA.zpg ("eal+1_00af");
/* f59a */                   LDA.zpg ("memuss+0_00c3");
/* f59c */                   STA.zpg ("stal+0_00c1");      // set I/O start addresses low byte
/* f59e */                   LDA.zpg ("memuss+1_00c4");
/* f5a0 */                   STA.zpg ("stal+1_00c2");      // set I/O start addresses high byte
/* f5a2 */                   JSR.abs ("_f5d2");            // display "LOADING" or "VERIFYING"
/* f5a5 */                   JSR.abs ("_f84a");            // do the tape read
/* f5a8 */                   _.bytes(0x24);                // makes next line BIT $18, keep the error flag in Cb
/* f5a9 */        _`_f5a9`;  CLC.imp ();                   // flag ok
/* f5aa */                   LDX.zpg ("eal+0_00ae");       // get the LOAD end pointer low byte
/* f5ac */                   LDY.zpg ("eal+1_00af");       // get the LOAD end pointer high byte
/* f5ae */        _`_f5ae`;  RTS.imp ();

// ------------------------------------------------------- // print "Searching..."
/* f5af */        _`_f5af`;  LDA.zpg ("msgflg_009d");      // get message mode flag
/* f5b1 */                   BPL.rel ("_f5d1");            // exit if control messages off
/* f5b3 */                   LDY.imm (0x0c);
                                                           // index to "SEARCHING "
/* f5b5 */                   JSR.abs ("_f12f");            // display kernel I/O message
/* f5b8 */                   LDA.zpg ("fnlen_00b7");       // get file name length
/* f5ba */                   BEQ.rel ("_f5d1");            // exit if null name
/* f5bc */                   LDY.imm (0x17);
                                                           // else index to "FOR "
/* f5be */                   JSR.abs ("_f12f");            // display kernel I/O message

// ------------------------------------------------------- // print file name
/* f5c1 */        _`_f5c1`;  LDY.zpg ("fnlen_00b7");       // get file name length
/* f5c3 */                   BEQ.rel ("_f5d1");            // exit if null file name
/* f5c5 */                   LDY.imm (0x00);               // clear index
/* f5c7 */        _`_f5c7`;  LDA.iny ("fnadr+0_00bb");     // get file name byte
/* f5c9 */                   JSR.abs ("chrout_ffd2");      // output character to channel
/* f5cc */                   INY.imp ();                   // increment index
/* f5cd */                   CPY.zpg ("fnlen_00b7");       // compare with file name length
/* f5cf */                   BNE.rel ("_f5c7");            // loop if more to do
/* f5d1 */        _`_f5d1`;  RTS.imp ();

// ------------------------------------------------------- // display "LOADING" or "VERIFYING"
/* f5d2 */        _`_f5d2`;  LDY.imm (0x49);
                                                           // point to "LOADING"
/* f5d4 */                   LDA.zpg ("verck_0093");       // get load/verify flag
/* f5d6 */                   BEQ.rel ("_f5da");            // branch if load
/* f5d8 */                   LDY.imm (0x59);
                                                           // point to "VERIFYING"
/* f5da */        _`_f5da`;  JMP.abs ("_f12b");            // display kernel I/O message if in direct mode and return

// ------------------------------------------------------- // save RAM to device, A = index to start address, XY = end address low/high
/* f5dd */    _`save_f5dd`;  STX.zpg ("eal+0_00ae");       // save end address low byte
/* f5df */                   STY.zpg ("eal+1_00af");       // save end address high byte
/* f5e1 */                   TAX.imp ();                   // copy index to start pointer
/* f5e2 */                   LDA.zpx (0x00);               // get start address low byte
/* f5e4 */                   STA.zpg ("stal+0_00c1");      // set I/O start addresses low byte
/* f5e6 */                   LDA.zpx (0x01);               // get start address high byte
/* f5e8 */                   STA.zpg ("stal+1_00c2");      // set I/O start addresses high byte
/* f5ea */                   JMP.ind ("isave+0_0332");     // go save, usually points to $F685

// ------------------------------------------------------- // save
/* f5ed */                   LDA.zpg ("fa_00ba");          // get the device number
/* f5ef */                   BNE.rel ("_f5f4");            // if not keyboard go ??
                                                           // else ..
/* f5f1 */        _`_f5f1`;  JMP.abs ("_f713");            // else do 'illegal device number' and return
/* f5f4 */        _`_f5f4`;  CMP.imm (0x03);               // compare device number with screen
/* f5f6 */                   BEQ.rel ("_f5f1");            // if screen do illegal device number and return
/* f5f8 */                   BCC.rel ("_f659");            // branch if < screen
                                                           // is greater than screen so is serial bus
/* f5fa */                   LDA.imm (0x61);               // set secondary address to $01
                                                           // when a secondary address is to be sent to a device on
                                                           // the serial bus the address must first be ORed with $60
/* f5fc */                   STA.zpg ("sa_00b9");          // save the secondary address
/* f5fe */                   LDY.zpg ("fnlen_00b7");       // get the file name length
/* f600 */                   BNE.rel ("_f605");            // if filename not null continue
/* f602 */                   JMP.abs ("_f710");            // else do 'missing file name' error and return
/* f605 */        _`_f605`;  JSR.abs ("_f3d5");            // send secondary address and filename
/* f608 */                   JSR.abs ("_f68f");            // print saving <file name>
/* f60b */                   LDA.zpg ("fa_00ba");          // get the device number
/* f60d */                   JSR.abs ("listen_ed0c");      // command devices on the serial bus to LISTEN
/* f610 */                   LDA.zpg ("sa_00b9");          // get the secondary address
/* f612 */                   JSR.abs ("second_edb9");      // send secondary address after LISTEN
/* f615 */                   LDY.imm (0x00);               // clear index
/* f617 */                   JSR.abs ("_fb8e");            // copy I/O start address to buffer address
/* f61a */                   LDA.zpg ("sal+0_00ac");       // get buffer address low byte
/* f61c */                   JSR.abs ("ciout_eddd");       // output byte to serial bus
/* f61f */                   LDA.zpg ("sal+1_00ad");       // get buffer address high byte
/* f621 */                   JSR.abs ("ciout_eddd");       // output byte to serial bus
/* f624 */        _`_f624`;  JSR.abs ("_fcd1");            // check read/write pointer, return Cb = 1 if pointer >= end
/* f627 */                   BCS.rel ("_f63f");            // go do UNLISTEN if at end
/* f629 */                   LDA.iny ("sal+0_00ac");       // get byte from buffer
/* f62b */                   JSR.abs ("ciout_eddd");       // output byte to serial bus
/* f62e */                   JSR.abs ("stop_ffe1");        // scan stop key
/* f631 */                   BNE.rel ("_f63a");            // if stop not pressed go increment pointer and loop for next
                                                           // else ..
                                                           // close the serial bus device and flag stop
/* f633 */        _`_f633`;  JSR.abs ("_f642");            // close serial bus device
/* f636 */                   LDA.imm (0x00);
/* f638 */                   SEC.imp ();                   // flag stop
/* f639 */                   RTS.imp ();
/* f63a */        _`_f63a`;  JSR.abs ("_fcdb");            // increment read/write pointer
/* f63d */                   BNE.rel ("_f624");            // loop, branch always
/* f63f */        _`_f63f`;  JSR.abs ("unlsn_edfe");       // command serial bus to UNLISTEN
                                                           // close serial bus device
/* f642 */        _`_f642`;  BIT.zpg ("sa_00b9");          // test the secondary address
/* f644 */                   BMI.rel ("_f657");            // if already closed just exit
/* f646 */                   LDA.zpg ("fa_00ba");          // get the device number
/* f648 */                   JSR.abs ("listen_ed0c");      // command devices on the serial bus to LISTEN
/* f64b */                   LDA.zpg ("sa_00b9");          // get the secondary address
/* f64d */                   AND.imm (0xef);               // mask the channel number
/* f64f */                   ORA.imm (0xe0);               // OR with the CLOSE command
/* f651 */                   JSR.abs ("second_edb9");      // send secondary address after LISTEN
/* f654 */        _`_f654`;  JSR.abs ("unlsn_edfe");       // command serial bus to UNLISTEN
/* f657 */        _`_f657`;  CLC.imp ();                   // flag ok
/* f658 */                   RTS.imp ();
/* f659 */        _`_f659`;  LSR.acc ();
/* f65a */                   BCS.rel ("_f65f");            // if not RS232 device ??
/* f65c */                   JMP.abs ("_f713");            // else do 'illegal device number' and return
/* f65f */        _`_f65f`;  JSR.abs ("_f7d0");            // get tape buffer start pointer in XY
/* f662 */                   BCC.rel ("_f5f1");            // if < $0200 do illegal device number and return
/* f664 */                   JSR.abs ("_f838");            // wait for PLAY/RECORD
/* f667 */                   BCS.rel ("_f68e");            // exit if STOP was pressed
/* f669 */                   JSR.abs ("_f68f");            // print saving <file name>
/* f66c */                   LDX.imm (0x03);               // set header for a non relocatable program file
/* f66e */                   LDA.zpg ("sa_00b9");          // get the secondary address
/* f670 */                   AND.imm (0x01);               // mask non relocatable bit
/* f672 */                   BNE.rel ("_f676");            // if non relocatable program go ??
/* f674 */                   LDX.imm (0x01);               // else set header for a relocatable program file
/* f676 */        _`_f676`;  TXA.imp ();                   // copy header type to A
/* f677 */                   JSR.abs ("_f76a");            // write tape header
/* f67a */                   BCS.rel ("_f68e");            // exit if error
/* f67c */                   JSR.abs ("_f867");            // do tape write, 20 cycle count
/* f67f */                   BCS.rel ("_f68e");            // exit if error
/* f681 */                   LDA.zpg ("sa_00b9");          // get the secondary address
/* f683 */                   AND.imm (0x02);               // mask end of tape flag
/* f685 */                   BEQ.rel ("_f68d");            // if not end of tape go ??
/* f687 */                   LDA.imm (0x05);               // else set logical end of the tape
/* f689 */                   JSR.abs ("_f76a");            // write tape header
/* f68c */                   _.bytes(0x24);                // makes next line BIT $18 so Cb is not changed
/* f68d */        _`_f68d`;  CLC.imp ();                   // flag ok
/* f68e */        _`_f68e`;  RTS.imp ();

// ------------------------------------------------------- // print saving <file name>
/* f68f */        _`_f68f`;  LDA.zpg ("msgflg_009d");      // get message mode flag
/* f691 */                   BPL.rel ("_f68e");            // exit if control messages off
/* f693 */                   LDY.imm (0x51);
                                                           // index to "SAVING "
/* f695 */                   JSR.abs ("_f12f");            // display kernel I/O message
/* f698 */                   JMP.abs ("_f5c1");            // print file name and return

// ------------------------------------------------------- // increment the real time clock
/* f69b */   _`udtim_f69b`;  LDX.imm (0x00);               // clear X
/* f69d */                   INC.zpg ("time+2_00a2");      // increment the jiffy clock low byte
/* f69f */                   BNE.rel ("_f6a7");            // if no rollover ??
/* f6a1 */                   INC.zpg ("time+1_00a1");      // increment the jiffy clock mid byte
/* f6a3 */                   BNE.rel ("_f6a7");            // branch if no rollover
/* f6a5 */                   INC.zpg ("time+0_00a0");      // increment the jiffy clock high byte
                                                           // now subtract a days worth of jiffies from current count
                                                           // and remember only the Cb result
/* f6a7 */        _`_f6a7`;  SEC.imp ();                   // set carry for subtract
/* f6a8 */                   LDA.zpg ("time+2_00a2");      // get the jiffy clock low byte
/* f6aa */                   SBC.imm (0x01);               // subtract $4F1A01 low byte
/* f6ac */                   LDA.zpg ("time+1_00a1");      // get the jiffy clock mid byte
/* f6ae */                   SBC.imm (0x1a);               // subtract $4F1A01 mid byte
/* f6b0 */                   LDA.zpg ("time+0_00a0");      // get the jiffy clock high byte
/* f6b2 */                   SBC.imm (0x4f);               // subtract $4F1A01 high byte
/* f6b4 */                   BCC.rel ("_f6bc");            // if less than $4F1A01 jiffies skip the clock reset
                                                           // else ..
/* f6b6 */                   STX.zpg ("time+0_00a0");      // clear the jiffy clock high byte
/* f6b8 */                   STX.zpg ("time+1_00a1");      // clear the jiffy clock mid byte
/* f6ba */                   STX.zpg ("time+2_00a2");      // clear the jiffy clock low byte
                                                           // this is wrong, there are $4F1A00 jiffies in a day so
                                                           // the reset to zero should occur when the value reaches
                                                           // $4F1A00 and not $4F1A01. this would give an extra jiffy
                                                           // every day and a possible TI value of 24:00:00
/* f6bc */        _`_f6bc`;  LDA.abs ("ciaprb_dc01");      // read VIA 1 DRB, keyboard row port
/* f6bf */                   CMP.abs ("ciaprb_dc01");      // compare it with itself
/* f6c2 */                   BNE.rel ("_f6bc");            // loop if changing
/* f6c4 */                   TAX.imp ();
/* f6c5 */                   BMI.rel ("_f6da");
/* f6c7 */                   LDX.imm (0xbd);               // set c6
/* f6c9 */                   STX.abs ("ciapra_dc00");      // save VIA 1 DRA, keyboard column drive
/* f6cc */        _`_f6cc`;  LDX.abs ("ciaprb_dc01");      // read VIA 1 DRB, keyboard row port
/* f6cf */                   CPX.abs ("ciaprb_dc01");      // compare it with itself
/* f6d2 */                   BNE.rel ("_f6cc");            // loop if changing
/* f6d4 */                   STA.abs ("ciapra_dc00");      // save VIA 1 DRA, keyboard column drive
/* f6d7 */                   INX.imp ();
/* f6d8 */                   BNE.rel ("_f6dc");
/* f6da */        _`_f6da`;  STA.zpg ("stkey_0091");       // save the stop key column
/* f6dc */        _`_f6dc`;  RTS.imp ();

// ------------------------------------------------------- // read the real time clock
/* f6dd */   _`rdtim_f6dd`;  SEI.imp ();                   // disable the interrupts
/* f6de */                   LDA.zpg ("time+2_00a2");      // get the jiffy clock low byte
/* f6e0 */                   LDX.zpg ("time+1_00a1");      // get the jiffy clock mid byte
/* f6e2 */                   LDY.zpg ("time+0_00a0");      // get the jiffy clock high byte

// ------------------------------------------------------- // set the real time clock
/* f6e4 */  _`settim_f6e4`;  SEI.imp ();                   // disable the interrupts
/* f6e5 */                   STA.zpg ("time+2_00a2");      // save the jiffy clock low byte
/* f6e7 */                   STX.zpg ("time+1_00a1");      // save the jiffy clock mid byte
/* f6e9 */                   STY.zpg ("time+0_00a0");      // save the jiffy clock high byte
/* f6eb */                   CLI.imp ();                   // enable the interrupts
/* f6ec */                   RTS.imp ();

// ------------------------------------------------------- // scan the stop key, return Zb = 1 = [STOP]
/* f6ed */    _`stop_f6ed`;  LDA.zpg ("stkey_0091");       // read the stop key column
/* f6ef */                   CMP.imm (0x7f);               // compare with [STP] down
/* f6f1 */                   BNE.rel ("_f6fa");            // if not [STP] or not just [STP] exit
                                                           // just [STP] was pressed
/* f6f3 */                   PHP.imp ();                   // save status
/* f6f4 */                   JSR.abs ("clrchn_ffcc");      // close input and output channels
/* f6f7 */                   STA.zpg ("ndx_00c6");         // save the keyboard buffer index
/* f6f9 */                   PLP.imp ();                   // restore status
/* f6fa */        _`_f6fa`;  RTS.imp ();

// ------------------------------------------------------- // file error messages
/* f6fb */        _`_f6fb`;  LDA.imm (0x01);               // 'too many files' error
/* f6fd */                   _.bytes(0x2c);                // makes next line BIT $02A9
/* f6fe */        _`_f6fe`;  LDA.imm (0x02);               // 'file already open' error
/* f700 */                   _.bytes(0x2c);                // makes next line BIT $03A9
/* f701 */        _`_f701`;  LDA.imm (0x03);               // 'file not open' error
/* f703 */                   _.bytes(0x2c);                // makes next line BIT $04A9
/* f704 */        _`_f704`;  LDA.imm (0x04);               // 'file not found' error
/* f706 */                   _.bytes(0x2c);                // makes next line BIT $05A9
/* f707 */        _`_f707`;  LDA.imm (0x05);               // 'device not present' error
/* f709 */                   _.bytes(0x2c);                // makes next line BIT $06A9
/* f70a */        _`_f70a`;  LDA.imm (0x06);               // 'not input file' error
/* f70c */                   _.bytes(0x2c);                // makes next line BIT $07A9
/* f70d */        _`_f70d`;  LDA.imm (0x07);               // 'not output file' error
/* f70f */                   _.bytes(0x2c);                // makes next line BIT $08A9
/* f710 */        _`_f710`;  LDA.imm (0x08);               // 'missing file name' error
/* f712 */                   _.bytes(0x2c);                // makes next line BIT $09A9
/* f713 */        _`_f713`;  LDA.imm (0x09);               // do 'illegal device number'
/* f715 */                   PHA.imp ();                   // save the error #
/* f716 */                   JSR.abs ("clrchn_ffcc");      // close input and output channels
/* f719 */                   LDY.imm (0x00);
                                                           // index to "I/O ERROR #"
/* f71b */                   BIT.zpg ("msgflg_009d");      // test message mode flag
/* f71d */                   BVC.rel ("_f729");            // exit if kernal messages off
/* f71f */                   JSR.abs ("_f12f");            // display kernel I/O message
/* f722 */                   PLA.imp ();                   // restore error #
/* f723 */                   PHA.imp ();                   // copy error #
/* f724 */                   ORA.imm (0x30);               // convert to ASCII
/* f726 */                   JSR.abs ("chrout_ffd2");      // output character to channel
/* f729 */        _`_f729`;  PLA.imp ();                   // pull error number
/* f72a */                   SEC.imp ();                   // flag error
/* f72b */                   RTS.imp ();

// ------------------------------------------------------- // find the tape header, exit with header in buffer
/* f72c */        _`_f72c`;  LDA.zpg ("verck_0093");       // get load/verify flag
/* f72e */                   PHA.imp ();                   // save load/verify flag
/* f72f */                   JSR.abs ("_f841");            // initiate tape read
/* f732 */                   PLA.imp ();                   // restore load/verify flag
/* f733 */                   STA.zpg ("verck_0093");       // save load/verify flag
/* f735 */                   BCS.rel ("_f769");            // exit if error
/* f737 */                   LDY.imm (0x00);               // clear the index
/* f739 */                   LDA.iny ("tape1+0_00b2");     // read first byte from tape buffer
/* f73b */                   CMP.imm (0x05);               // compare with logical end of the tape
/* f73d */                   BEQ.rel ("_f769");            // if end of the tape exit
/* f73f */                   CMP.imm (0x01);               // compare with header for a relocatable program file
/* f741 */                   BEQ.rel ("_f74b");            // if program file header go ??
/* f743 */                   CMP.imm (0x03);               // compare with header for a non relocatable program file
/* f745 */                   BEQ.rel ("_f74b");            // if program file header go  ??
/* f747 */                   CMP.imm (0x04);               // compare with data file header
/* f749 */                   BNE.rel ("_f72c");            // if data file loop to find the tape header
                                                           // was a program file header
/* f74b */        _`_f74b`;  TAX.imp ();                   // copy header type
/* f74c */                   BIT.zpg ("msgflg_009d");      // get message mode flag
/* f74e */                   BPL.rel ("_f767");            // exit if control messages off
/* f750 */                   LDY.imm (0x63);
                                                           // index to "FOUND "
/* f752 */                   JSR.abs ("_f12f");            // display kernel I/O message
/* f755 */                   LDY.imm (0x05);               // index to the tape filename
/* f757 */        _`_f757`;  LDA.iny ("tape1+0_00b2");     // get byte from tape buffer
/* f759 */                   JSR.abs ("chrout_ffd2");      // output character to channel
/* f75c */                   INY.imp ();                   // increment the index
/* f75d */                   CPY.imm (0x15);               // compare it with end+1
/* f75f */                   BNE.rel ("_f757");            // loop if more to do
/* f761 */                   LDA.zpg ("time+1_00a1");      // get the jiffy clock mid byte
/* f763 */                   JSR.abs ("_e4e0");            // wait ~8.5 seconds for any key from the STOP key column
/* f766 */                   NOP.imp ();                   // waste cycles
/* f767 */        _`_f767`;  CLC.imp ();                   // flag no error
/* f768 */                   DEY.imp ();                   // decrement the index
/* f769 */        _`_f769`;  RTS.imp ();

// ------------------------------------------------------- // write the tape header
/* f76a */        _`_f76a`;  STA.zpg ("ptr1_009e");        // save header type
/* f76c */                   JSR.abs ("_f7d0");            // get tape buffer start pointer in XY
/* f76f */                   BCC.rel ("_f7cf");            // if < $0200 just exit ??
/* f771 */                   LDA.zpg ("stal+1_00c2");      // get I/O start address high byte
/* f773 */                   PHA.imp ();                   // save it
/* f774 */                   LDA.zpg ("stal+0_00c1");      // get I/O start address low byte
/* f776 */                   PHA.imp ();                   // save it
/* f777 */                   LDA.zpg ("eal+1_00af");       // get tape end address high byte
/* f779 */                   PHA.imp ();                   // save it
/* f77a */                   LDA.zpg ("eal+0_00ae");       // get tape end address low byte
/* f77c */                   PHA.imp ();                   // save it
/* f77d */                   LDY.imm (0xbf);               // index to header end
/* f77f */                   LDA.imm (0x20);               // clear byte, [SPACE]
/* f781 */        _`_f781`;  STA.iny ("tape1+0_00b2");     // clear header byte
/* f783 */                   DEY.imp ();                   // decrement index
/* f784 */                   BNE.rel ("_f781");            // loop if more to do
/* f786 */                   LDA.zpg ("ptr1_009e");        // get the header type back
/* f788 */                   STA.iny ("tape1+0_00b2");     // write it to header
/* f78a */                   INY.imp ();                   // increment the index
/* f78b */                   LDA.zpg ("stal+0_00c1");      // get the I/O start address low byte
/* f78d */                   STA.iny ("tape1+0_00b2");     // write it to header
/* f78f */                   INY.imp ();                   // increment the index
/* f790 */                   LDA.zpg ("stal+1_00c2");      // get the I/O start address high byte
/* f792 */                   STA.iny ("tape1+0_00b2");     // write it to header
/* f794 */                   INY.imp ();                   // increment the index
/* f795 */                   LDA.zpg ("eal+0_00ae");       // get the tape end address low byte
/* f797 */                   STA.iny ("tape1+0_00b2");     // write it to header
/* f799 */                   INY.imp ();                   // increment the index
/* f79a */                   LDA.zpg ("eal+1_00af");       // get the tape end address high byte
/* f79c */                   STA.iny ("tape1+0_00b2");     // write it to header
/* f79e */                   INY.imp ();                   // increment the index
/* f79f */                   STY.zpg ("ptr2_009f");        // save the index
/* f7a1 */                   LDY.imm (0x00);               // clear Y
/* f7a3 */                   STY.zpg ("ptr1_009e");        // clear the name index
/* f7a5 */        _`_f7a5`;  LDY.zpg ("ptr1_009e");        // get name index
/* f7a7 */                   CPY.zpg ("fnlen_00b7");       // compare with file name length
/* f7a9 */                   BEQ.rel ("_f7b7");            // if all done exit the loop
/* f7ab */                   LDA.iny ("fnadr+0_00bb");     // get file name byte
/* f7ad */                   LDY.zpg ("ptr2_009f");        // get buffer index
/* f7af */                   STA.iny ("tape1+0_00b2");     // save file name byte to buffer
/* f7b1 */                   INC.zpg ("ptr1_009e");        // increment file name index
/* f7b3 */                   INC.zpg ("ptr2_009f");        // increment tape buffer index
/* f7b5 */                   BNE.rel ("_f7a5");            // loop, branch always
/* f7b7 */        _`_f7b7`;  JSR.abs ("_f7d7");            // set tape buffer start and end pointers
/* f7ba */                   LDA.imm (0x69);               // set write lead cycle count
/* f7bc */                   STA.zpg ("riprty_00ab");      // save write lead cycle count
/* f7be */                   JSR.abs ("_f86b");            // do tape write, no cycle count set
/* f7c1 */                   TAY.imp ();
/* f7c2 */                   PLA.imp ();                   // pull tape end address low byte
/* f7c3 */                   STA.zpg ("eal+0_00ae");       // restore it
/* f7c5 */                   PLA.imp ();                   // pull tape end address high byte
/* f7c6 */                   STA.zpg ("eal+1_00af");       // restore it
/* f7c8 */                   PLA.imp ();                   // pull I/O start addresses low byte
/* f7c9 */                   STA.zpg ("stal+0_00c1");      // restore it
/* f7cb */                   PLA.imp ();                   // pull I/O start addresses high byte
/* f7cc */                   STA.zpg ("stal+1_00c2");      // restore it
/* f7ce */                   TYA.imp ();
/* f7cf */        _`_f7cf`;  RTS.imp ();

// ------------------------------------------------------- // get the tape buffer start pointer
/* f7d0 */        _`_f7d0`;  LDX.zpg ("tape1+0_00b2");     // get tape buffer start pointer low byte
/* f7d2 */                   LDY.zpg ("tape1+1_00b3");     // get tape buffer start pointer high byte
/* f7d4 */                   CPY.imm (0x02);               // compare high byte with $02xx
/* f7d6 */                   RTS.imp ();

// ------------------------------------------------------- // set the tape buffer start and end pointers
/* f7d7 */        _`_f7d7`;  JSR.abs ("_f7d0");            // get tape buffer start pointer in XY
/* f7da */                   TXA.imp ();                   // copy tape buffer start pointer low byte
/* f7db */                   STA.zpg ("stal+0_00c1");      // save as I/O address pointer low byte
/* f7dd */                   CLC.imp ();                   // clear carry for add
/* f7de */                   ADC.imm (0xc0);               // add buffer length low byte
/* f7e0 */                   STA.zpg ("eal+0_00ae");       // save tape buffer end pointer low byte
/* f7e2 */                   TYA.imp ();                   // copy tape buffer start pointer high byte
/* f7e3 */                   STA.zpg ("stal+1_00c2");      // save as I/O address pointer high byte
/* f7e5 */                   ADC.imm (0x00);               // add buffer length high byte
/* f7e7 */                   STA.zpg ("eal+1_00af");       // save tape buffer end pointer high byte
/* f7e9 */                   RTS.imp ();

// ------------------------------------------------------- // find specific tape header
/* f7ea */        _`_f7ea`;  JSR.abs ("_f72c");            // find tape header, exit with header in buffer
/* f7ed */                   BCS.rel ("_f80c");            // just exit if error
/* f7ef */                   LDY.imm (0x05);               // index to name
/* f7f1 */                   STY.zpg ("ptr2_009f");        // save as tape buffer index
/* f7f3 */                   LDY.imm (0x00);               // clear Y
/* f7f5 */                   STY.zpg ("ptr1_009e");        // save as name buffer index
/* f7f7 */        _`_f7f7`;  CPY.zpg ("fnlen_00b7");       // compare with file name length
/* f7f9 */                   BEQ.rel ("_f80b");            // ok exit if match
/* f7fb */                   LDA.iny ("fnadr+0_00bb");     // get file name byte
/* f7fd */                   LDY.zpg ("ptr2_009f");        // get index to tape buffer
/* f7ff */                   CMP.iny ("tape1+0_00b2");     // compare with tape header name byte
/* f801 */                   BNE.rel ("_f7ea");            // if no match go get next header
/* f803 */                   INC.zpg ("ptr1_009e");        // else increment name buffer index
/* f805 */                   INC.zpg ("ptr2_009f");        // increment tape buffer index
/* f807 */                   LDY.zpg ("ptr1_009e");        // get name buffer index
/* f809 */                   BNE.rel ("_f7f7");            // loop, branch always
/* f80b */        _`_f80b`;  CLC.imp ();                   // flag ok
/* f80c */        _`_f80c`;  RTS.imp ();

// ------------------------------------------------------- // bump tape pointer
/* f80d */        _`_f80d`;  JSR.abs ("_f7d0");            // get tape buffer start pointer in XY
/* f810 */                   INC.zpg ("bufpnt_00a6");      // increment tape buffer index
/* f812 */                   LDY.zpg ("bufpnt_00a6");      // get tape buffer index
/* f814 */                   CPY.imm (0xc0);               // compare with buffer length
/* f816 */                   RTS.imp ();

// ------------------------------------------------------- // wait for PLAY
/* f817 */        _`_f817`;  JSR.abs ("_f82e");            // return cassette sense in Zb
/* f81a */                   BEQ.rel ("_f836");            // if switch closed just exit
                                                           // cassette switch was open
/* f81c */                   LDY.imm (0x1b);
                                                           // index to "PRESS PLAY ON TAPE"
/* f81e */        _`_f81e`;  JSR.abs ("_f12f");            // display kernel I/O message
/* f821 */        _`_f821`;  JSR.abs ("_f8d0");            // scan stop key and flag abort if pressed
                                                           // note if STOP was pressed the return is to the
                                                           // routine that called this one and not here
/* f824 */                   JSR.abs ("_f82e");            // return cassette sense in Zb
/* f827 */                   BNE.rel ("_f821");            // loop if the cassette switch is open
/* f829 */                   LDY.imm (0x6a);
                                                           // index to "OK"
/* f82b */                   JMP.abs ("_f12f");            // display kernel I/O message and return

// ------------------------------------------------------- // return cassette sense in Zb
/* f82e */        _`_f82e`;  LDA.imm (0x10);               // set the mask for the cassette switch
/* f830 */                   BIT.zpg ("r6510_0001");       // test the 6510 I/O port
/* f832 */                   BNE.rel ("_f836");            // branch if cassette sense high
/* f834 */                   BIT.zpg ("r6510_0001");       // test the 6510 I/O port
/* f836 */        _`_f836`;  CLC.imp ();
/* f837 */                   RTS.imp ();

// ------------------------------------------------------- // wait for PLAY/RECORD
/* f838 */        _`_f838`;  JSR.abs ("_f82e");            // return the cassette sense in Zb
/* f83b */                   BEQ.rel ("_f836");            // exit if switch closed
                                                           // cassette switch was open
/* f83d */                   LDY.imm (0x2e);
                                                           // index to "PRESS RECORD & PLAY ON TAPE"
/* f83f */                   BNE.rel ("_f81e");            // display message and wait for switch, branch always

// ------------------------------------------------------- // initiate a tape read
/* f841 */        _`_f841`;  LDA.imm (0x00);               // clear A
/* f843 */                   STA.zpg ("status_0090");      // clear serial status byte
/* f845 */                   STA.zpg ("verck_0093");       // clear the load/verify flag
/* f847 */                   JSR.abs ("_f7d7");            // set the tape buffer start and end pointers
/* f84a */        _`_f84a`;  JSR.abs ("_f817");            // wait for PLAY
/* f84d */                   BCS.rel ("_f86e");            // exit if STOP was pressed, uses a further BCS at the
                                                           // target address to reach final target at $F8DC
/* f84f */                   SEI.imp ();                   // disable interrupts
/* f850 */                   LDA.imm (0x00);               // clear A
/* f852 */                   STA.zpg ("ridata_00aa");
/* f854 */                   STA.zpg ("bitts_00b4");
/* f856 */                   STA.zpg ("cmp0+0_00b0");      // clear tape timing constant min byte
/* f858 */                   STA.zpg ("ptr1_009e");        // clear tape pass 1 error log/char buffer
/* f85a */                   STA.zpg ("ptr2_009f");        // clear tape pass 2 error log corrected
/* f85c */                   STA.zpg ("dpsw_009c");        // clear byte received flag
/* f85e */                   LDA.imm (0x90);               // enable CA1 interrupt ??
/* f860 */                   LDX.imm (0x0e);               // set index for tape read vector
/* f862 */                   BNE.rel ("_f875");            // go do tape read/write, branch always

// ------------------------------------------------------- // initiate a tape write
/* f864 */        _`_f864`;  JSR.abs ("_f7d7");            // set tape buffer start and end pointers
                                                           // do tape write, 20 cycle count
/* f867 */        _`_f867`;  LDA.imm (0x14);               // set write lead cycle count
/* f869 */                   STA.zpg ("riprty_00ab");      // save write lead cycle count
                                                           // do tape write, no cycle count set
/* f86b */        _`_f86b`;  JSR.abs ("_f838");            // wait for PLAY/RECORD
/* f86e */        _`_f86e`;  BCS.rel ("_f8dc");            // if STOPped clear save IRQ address and exit
/* f870 */                   SEI.imp ();                   // disable interrupts
/* f871 */                   LDA.imm (0x82);               // enable ?? interrupt
/* f873 */                   LDX.imm (0x08);               // set index for tape write tape leader vector

// ------------------------------------------------------- // tape read/write
/* f875 */        _`_f875`;  LDY.imm (0x7f);               // disable all interrupts
/* f877 */                   STY.abs ("ciaicr_dc0d");      // save VIA 1 ICR, disable all interrupts
/* f87a */                   STA.abs ("ciaicr_dc0d");      // save VIA 1 ICR, enable interrupts according to A
                                                           // check RS232 bus idle
/* f87d */                   LDA.abs ("ciacra_dc0e");      // read VIA 1 CRA
/* f880 */                   ORA.imm (0x19);               // load timer B, timer B single shot, start timer B
/* f882 */                   STA.abs ("ciacrb_dc0f");      // save VIA 1 CRB
/* f885 */                   AND.imm (0x91);               // mask x00x 000x, TOD clock, load timer A, start timer A
/* f887 */                   STA.abs ("todsns_02a2");      // save VIA 1 CRB shadow copy
/* f88a */                   JSR.abs ("_f0a4");
/* f88d */                   LDA.abs ("scroly_d011");      // read the vertical fine scroll and control register
/* f890 */                   AND.imm (0xef);               // mask xxx0 xxxx, blank the screen
/* f892 */                   STA.abs ("scroly_d011");      // save the vertical fine scroll and control register
/* f895 */                   LDA.abs ("cinv+0_0314");      // get IRQ vector low byte
/* f898 */                   STA.abs ("irqtmp+0_029f");    // save IRQ vector low byte
/* f89b */                   LDA.abs ("cinv+1_0315");      // get IRQ vector high byte
/* f89e */                   STA.abs ("irqtmp+1_02a0");    // save IRQ vector high byte
/* f8a1 */                   JSR.abs ("_fcbd");            // set the tape vector
/* f8a4 */                   LDA.imm (0x02);               // set copies count. the first copy is the load copy, the
                                                           // second copy is the verify copy
/* f8a6 */                   STA.zpg ("fsblk_00be");       // save copies count
/* f8a8 */                   JSR.abs ("_fb97");            // new tape byte setup
/* f8ab */                   LDA.zpg ("r6510_0001");       // read the 6510 I/O port
/* f8ad */                   AND.imm (0x1f);               // mask 000x xxxx, cassette motor on ??
/* f8af */                   STA.zpg ("r6510_0001");       // save the 6510 I/O port
/* f8b1 */                   STA.zpg ("cas1_00c0");        // set the tape motor interlock
                                                           // 326656 cycle delay, allow tape motor speed to stabilise
/* f8b3 */                   LDX.imm (0xff);               // outer loop count
/* f8b5 */        _`_f8b5`;  LDY.imm (0xff);               // inner loop count
/* f8b7 */        _`_f8b7`;  DEY.imp ();                   // decrement inner loop count
/* f8b8 */                   BNE.rel ("_f8b7");            // loop if more to do
/* f8ba */                   DEX.imp ();                   // decrement outer loop count
/* f8bb */                   BNE.rel ("_f8b5");            // loop if more to do
/* f8bd */                   CLI.imp ();                   // enable tape interrupts
/* f8be */        _`_f8be`;  LDA.abs ("irqtmp+1_02a0");    // get saved IRQ high byte
/* f8c1 */                   CMP.abs ("cinv+1_0315");      // compare with the current IRQ high byte
/* f8c4 */                   CLC.imp ();                   // flag ok
/* f8c5 */                   BEQ.rel ("_f8dc");            // if tape write done go clear saved IRQ address and exit
/* f8c7 */                   JSR.abs ("_f8d0");            // scan stop key and flag abort if pressed
                                                           // note if STOP was pressed the return is to the
                                                           // routine that called this one and not here
/* f8ca */                   JSR.abs ("_f6bc");            // increment real time clock
/* f8cd */                   JMP.abs ("_f8be");            // loop

// ------------------------------------------------------- // scan stop key and flag abort if pressed
/* f8d0 */        _`_f8d0`;  JSR.abs ("stop_ffe1");        // scan stop key
/* f8d3 */                   CLC.imp ();                   // flag no stop
/* f8d4 */                   BNE.rel ("_f8e1");            // exit if no stop
/* f8d6 */                   JSR.abs ("_fc93");            // restore everything for STOP
/* f8d9 */                   SEC.imp ();                   // flag stopped
/* f8da */                   PLA.imp ();                   // dump return address low byte
/* f8db */                   PLA.imp ();                   // dump return address high byte

// ------------------------------------------------------- // clear saved IRQ address
/* f8dc */        _`_f8dc`;  LDA.imm (0x00);               // clear A
/* f8de */                   STA.abs ("irqtmp+1_02a0");    // clear saved IRQ address high byte
/* f8e1 */        _`_f8e1`;  RTS.imp ();

// ------------------------------------------------------- // # set timing
/* f8e2 */        _`_f8e2`;  STX.zpg ("cmp0+1_00b1");      // save tape timing constant max byte
/* f8e4 */                   LDA.zpg ("cmp0+0_00b0");      // get tape timing constant min byte
/* f8e6 */                   ASL.acc ();                   // *2
/* f8e7 */                   ASL.acc ();                   // *4
/* f8e8 */                   CLC.imp ();                   // clear carry for add
/* f8e9 */                   ADC.zpg ("cmp0+0_00b0");      // add tape timing constant min byte *5
/* f8eb */                   CLC.imp ();                   // clear carry for add
/* f8ec */                   ADC.zpg ("cmp0+1_00b1");      // add tape timing constant max byte
/* f8ee */                   STA.zpg ("cmp0+1_00b1");      // save tape timing constant max byte
/* f8f0 */                   LDA.imm (0x00);
/* f8f2 */                   BIT.zpg ("cmp0+0_00b0");      // test tape timing constant min byte
/* f8f4 */                   BMI.rel ("_f8f7");            // branch if b7 set
/* f8f6 */                   ROL.acc ();                   // else shift carry into ??
/* f8f7 */        _`_f8f7`;  ASL.zpg ("cmp0+1_00b1");      // shift tape timing constant max byte
/* f8f9 */                   ROL.acc ();
/* f8fa */                   ASL.zpg ("cmp0+1_00b1");      // shift tape timing constant max byte
/* f8fc */                   ROL.acc ();
/* f8fd */                   TAX.imp ();
/* f8fe */        _`_f8fe`;  LDA.abs ("timblo_dc06");      // get VIA 1 timer B low byte
/* f901 */                   CMP.imm (0x16);               // compare with ??
/* f903 */                   BCC.rel ("_f8fe");            // loop if less
/* f905 */                   ADC.zpg ("cmp0+1_00b1");      // add tape timing constant max byte
/* f907 */                   STA.abs ("timalo_dc04");      // save VIA 1 timer A low byte
/* f90a */                   TXA.imp ();
/* f90b */                   ADC.abs ("timbhi_dc07");      // add VIA 1 timer B high byte
/* f90e */                   STA.abs ("timahi_dc05");      // save VIA 1 timer A high byte
/* f911 */                   LDA.abs ("todsns_02a2");      // read VIA 1 CRB shadow copy
/* f914 */                   STA.abs ("ciacra_dc0e");      // save VIA 1 CRA
/* f917 */                   STA.abs ("td1irq_02a4");      // save VIA 1 CRA shadow copy
/* f91a */                   LDA.abs ("ciaicr_dc0d");      // read VIA 1 ICR
/* f91d */                   AND.imm (0x10);               // mask 000x 0000, FLAG interrupt
/* f91f */                   BEQ.rel ("_f92a");            // if no FLAG interrupt just exit
                                                           // else first call the IRQ routine
/* f921 */                   LDA.imm (0xf9);               // set the return address high byte
/* f923 */                   PHA.imp ();                   // push the return address high byte
/* f924 */                   LDA.imm (0x2a);               // set the return address low byte
/* f926 */                   PHA.imp ();                   // push the return address low byte
/* f927 */                   JMP.abs ("_ff43");            // save the status and do the IRQ routine
/* f92a */        _`_f92a`;  CLI.imp ();                   // enable interrupts
/* f92b */                   RTS.imp ();

// ------------------------------------------------------- // On Commodore computers, the streams consist of four kinds of symbols
                                                           // that denote different kinds of low-to-high-to-low transitions on the
                                                           // read or write signals of the Commodore cassette interface.

                                                           // A A break in the communications, or a pulse with very long cycle
                                                           //   time.

                                                           // B A short pulse, whose cycle time typically ranges from 296 to 424
                                                           //   microseconds, depending on the computer model.

                                                           // C A medium-length pulse, whose cycle time typically ranges from
                                                           //   440 to 576 microseconds, depending on the computer model.

                                                           // D A long pulse, whose cycle time typically ranges from 600 to 744
                                                           //   microseconds, depending on the computer model.

                                                           //  The actual interpretation of the serial data takes a little more work to explain.
                                                           // The typical ROM tape loader (and the turbo loaders) will initialize a timer with a
                                                           // specified value and start it counting down. If either the tape data changes or the
                                                           // timer runs out, an IRQ will occur. The loader will determine which condition caused
                                                           // the IRQ. If the tape data changed before the timer ran out, we have a short pulse,
                                                           // or a "0" bit. If the timer ran out first, we have a long pulse, or a "1" bit. Doing
                                                           // this continuously and we decode the entire file.
                                                           // read tape bits, IRQ routine
                                                           // read T2C which has been counting down from $FFFF. subtract this from $FFFF
/* f92c */        _`_f92c`;  LDX.abs ("timbhi_dc07");      // read VIA 1 timer B high byte
/* f92f */                   LDY.imm (0xff);               // set $FF
/* f931 */                   TYA.imp ();                   // A = $FF
/* f932 */                   SBC.abs ("timblo_dc06");      // subtract VIA 1 timer B low byte
/* f935 */                   CPX.abs ("timbhi_dc07");      // compare it with VIA 1 timer B high byte
/* f938 */                   BNE.rel ("_f92c");            // if timer low byte rolled over loop
/* f93a */                   STX.zpg ("cmp0+1_00b1");      // save tape timing constant max byte
/* f93c */                   TAX.imp ();                   // copy $FF - T2C_l
/* f93d */                   STY.abs ("timblo_dc06");      // save VIA 1 timer B low byte
/* f940 */                   STY.abs ("timbhi_dc07");      // save VIA 1 timer B high byte
/* f943 */                   LDA.imm (0x19);               // load timer B, timer B single shot, start timer B
/* f945 */                   STA.abs ("ciacrb_dc0f");      // save VIA 1 CRB
/* f948 */                   LDA.abs ("ciaicr_dc0d");      // read VIA 1 ICR
/* f94b */                   STA.abs ("trdtmp_02a3");      // save VIA 1 ICR shadow copy
/* f94e */                   TYA.imp ();                   // y = $FF
/* f94f */                   SBC.zpg ("cmp0+1_00b1");      // subtract tape timing constant max byte
                                                           // A = $FF - T2C_h
/* f951 */                   STX.zpg ("cmp0+1_00b1");      // save tape timing constant max byte
                                                           // $B1 = $FF - T2C_l
/* f953 */                   LSR.acc ();                   // A = $FF - T2C_h >> 1
/* f954 */                   ROR.zpg ("cmp0+1_00b1");      // shift tape timing constant max byte
                                                           // $B1 = $FF - T2C_l >> 1
/* f956 */                   LSR.acc ();                   // A = $FF - T2C_h >> 1
/* f957 */                   ROR.zpg ("cmp0+1_00b1");      // shift tape timing constant max byte
                                                           // $B1 = $FF - T2C_l >> 1
/* f959 */                   LDA.zpg ("cmp0+0_00b0");      // get tape timing constant min byte
/* f95b */                   CLC.imp ();                   // clear carry for add
/* f95c */                   ADC.imm (0x3c);
/* f95e */                   CMP.zpg ("cmp0+1_00b1");      // compare with tape timing constant max byte
                                                           // compare with ($FFFF - T2C) >> 2
/* f960 */                   BCS.rel ("_f9ac");            // branch if min + $3C >= ($FFFF - T2C) >> 2
                                                           // min + $3C < ($FFFF - T2C) >> 2
/* f962 */                   LDX.zpg ("dpsw_009c");        // get byte received flag
/* f964 */                   BEQ.rel ("_f969");            //  if not byte received ??
/* f966 */                   JMP.abs ("_fa60");            // store the tape character
/* f969 */        _`_f969`;  LDX.zpg ("tsfcnt_00a3");      // get EOI flag byte
/* f96b */                   BMI.rel ("_f988");
/* f96d */                   LDX.imm (0x00);
/* f96f */                   ADC.imm (0x30);
/* f971 */                   ADC.zpg ("cmp0+0_00b0");      // add tape timing constant min byte
/* f973 */                   CMP.zpg ("cmp0+1_00b1");      // compare with tape timing constant max byte
/* f975 */                   BCS.rel ("_f993");
/* f977 */                   INX.imp ();
/* f978 */                   ADC.imm (0x26);
/* f97a */                   ADC.zpg ("cmp0+0_00b0");      // add tape timing constant min byte
/* f97c */                   CMP.zpg ("cmp0+1_00b1");      // compare with tape timing constant max byte
/* f97e */                   BCS.rel ("_f997");
/* f980 */                   ADC.imm (0x2c);
/* f982 */                   ADC.zpg ("cmp0+0_00b0");      // add tape timing constant min byte
/* f984 */                   CMP.zpg ("cmp0+1_00b1");      // compare with tape timing constant max byte
/* f986 */                   BCC.rel ("_f98b");
/* f988 */        _`_f988`;  JMP.abs ("_fa10");
/* f98b */        _`_f98b`;  LDA.zpg ("bitts_00b4");       // get the bit count
/* f98d */                   BEQ.rel ("_f9ac");            // if all done go ??
/* f98f */                   STA.zpg ("bitci_00a8");       // save receiver bit count in
/* f991 */                   BNE.rel ("_f9ac");            // branch always
/* f993 */        _`_f993`;  INC.zpg ("rinone_00a9");      // increment ?? start bit check flag
/* f995 */                   BCS.rel ("_f999");
/* f997 */        _`_f997`;  DEC.zpg ("rinone_00a9");      // decrement ?? start bit check flag
/* f999 */        _`_f999`;  SEC.imp ();
/* f99a */                   SBC.imm (0x13);
/* f99c */                   SBC.zpg ("cmp0+1_00b1");      // subtract tape timing constant max byte
/* f99e */                   ADC.zpg ("svxt_0092");        // add timing constant for tape
/* f9a0 */                   STA.zpg ("svxt_0092");        // save timing constant for tape
/* f9a2 */                   LDA.zpg ("tbtcnt_00a4");      // get tape bit cycle phase
/* f9a4 */                   EOR.imm (0x01);
/* f9a6 */                   STA.zpg ("tbtcnt_00a4");      // save tape bit cycle phase
/* f9a8 */                   BEQ.rel ("_f9d5");
/* f9aa */                   STX.zpg ("schar_00d7");
/* f9ac */        _`_f9ac`;  LDA.zpg ("bitts_00b4");       // get the bit count
/* f9ae */                   BEQ.rel ("_f9d2");            // if all done go ??
/* f9b0 */                   LDA.abs ("trdtmp_02a3");      // read VIA 1 ICR shadow copy
/* f9b3 */                   AND.imm (0x01);               // mask 0000 000x, timer A interrupt enabled
/* f9b5 */                   BNE.rel ("_f9bc");            // if timer A is enabled go ??
/* f9b7 */                   LDA.abs ("td1irq_02a4");      // read VIA 1 CRA shadow copy
/* f9ba */                   BNE.rel ("_f9d2");            // if ?? just exit
/* f9bc */        _`_f9bc`;  LDA.imm (0x00);               // clear A
/* f9be */                   STA.zpg ("tbtcnt_00a4");      // clear the tape bit cycle phase
/* f9c0 */                   STA.abs ("td1irq_02a4");      // save VIA 1 CRA shadow copy
/* f9c3 */                   LDA.zpg ("tsfcnt_00a3");      // get EOI flag byte
/* f9c5 */                   BPL.rel ("_f9f7");
/* f9c7 */                   BMI.rel ("_f988");
/* f9c9 */        _`_f9c9`;  LDX.imm (0xa6);               // set timimg max byte
/* f9cb */                   JSR.abs ("_f8e2");            // set timing
/* f9ce */                   LDA.zpg ("prty_009b");
/* f9d0 */                   BNE.rel ("_f98b");
/* f9d2 */        _`_f9d2`;  JMP.abs ("_febc");            // restore registers and exit interrupt
/* f9d5 */        _`_f9d5`;  LDA.zpg ("svxt_0092");        // get timing constant for tape
/* f9d7 */                   BEQ.rel ("_f9e0");
/* f9d9 */                   BMI.rel ("_f9de");
/* f9db */                   DEC.zpg ("cmp0+0_00b0");      // decrement tape timing constant min byte
/* f9dd */                   _.bytes(0x2c);                // makes next line BIT $B0E6
/* f9de */        _`_f9de`;  INC.zpg ("cmp0+0_00b0");      // increment tape timing constant min byte
/* f9e0 */        _`_f9e0`;  LDA.imm (0x00);
/* f9e2 */                   STA.zpg ("svxt_0092");        // clear timing constant for tape
/* f9e4 */                   CPX.zpg ("schar_00d7");
/* f9e6 */                   BNE.rel ("_f9f7");
/* f9e8 */                   TXA.imp ();
/* f9e9 */                   BNE.rel ("_f98b");
/* f9eb */                   LDA.zpg ("rinone_00a9");      // get start bit check flag
/* f9ed */                   BMI.rel ("_f9ac");
/* f9ef */                   CMP.imm (0x10);
/* f9f1 */                   BCC.rel ("_f9ac");
/* f9f3 */                   STA.zpg ("syno_0096");        // save cassette block synchronization number
/* f9f5 */                   BCS.rel ("_f9ac");
/* f9f7 */        _`_f9f7`;  TXA.imp ();
/* f9f8 */                   EOR.zpg ("prty_009b");
/* f9fa */                   STA.zpg ("prty_009b");
/* f9fc */                   LDA.zpg ("bitts_00b4");
/* f9fe */                   BEQ.rel ("_f9d2");
/* fa00 */                   DEC.zpg ("tsfcnt_00a3");      // decrement EOI flag byte
/* fa02 */                   BMI.rel ("_f9c9");
/* fa04 */                   LSR.zpg ("schar_00d7");
/* fa06 */                   ROR.zpg ("mych_00bf");        // parity count
/* fa08 */                   LDX.imm (0xda);               // set timimg max byte
/* fa0a */                   JSR.abs ("_f8e2");            // set timing
/* fa0d */                   JMP.abs ("_febc");            // restore registers and exit interrupt
/* fa10 */        _`_fa10`;  LDA.zpg ("syno_0096");        // get cassette block synchronization number
/* fa12 */                   BEQ.rel ("_fa18");
/* fa14 */                   LDA.zpg ("bitts_00b4");
/* fa16 */                   BEQ.rel ("_fa1f");
/* fa18 */        _`_fa18`;  LDA.zpg ("tsfcnt_00a3");      // get EOI flag byte
/* fa1a */                   BMI.rel ("_fa1f");
/* fa1c */                   JMP.abs ("_f997");
/* fa1f */        _`_fa1f`;  LSR.zpg ("cmp0+1_00b1");      // shift tape timing constant max byte
/* fa21 */                   LDA.imm (0x93);
/* fa23 */                   SEC.imp ();
/* fa24 */                   SBC.zpg ("cmp0+1_00b1");      // subtract tape timing constant max byte
/* fa26 */                   ADC.zpg ("cmp0+0_00b0");      // add tape timing constant min byte
/* fa28 */                   ASL.acc ();
/* fa29 */                   TAX.imp ();                   // copy timimg high byte
/* fa2a */                   JSR.abs ("_f8e2");            // set timing
/* fa2d */                   INC.zpg ("dpsw_009c");
/* fa2f */                   LDA.zpg ("bitts_00b4");
/* fa31 */                   BNE.rel ("_fa44");
/* fa33 */                   LDA.zpg ("syno_0096");        // get cassette block synchronization number
/* fa35 */                   BEQ.rel ("_fa5d");
/* fa37 */                   STA.zpg ("bitci_00a8");       // save receiver bit count in
/* fa39 */                   LDA.imm (0x00);               // clear A
/* fa3b */                   STA.zpg ("syno_0096");        // clear cassette block synchronization number
/* fa3d */                   LDA.imm (0x81);               // enable timer A interrupt
/* fa3f */                   STA.abs ("ciaicr_dc0d");      // save VIA 1 ICR
/* fa42 */                   STA.zpg ("bitts_00b4");
/* fa44 */        _`_fa44`;  LDA.zpg ("syno_0096");        // get cassette block synchronization number
/* fa46 */                   STA.zpg ("nxtbit_00b5");
/* fa48 */                   BEQ.rel ("_fa53");
/* fa4a */                   LDA.imm (0x00);
/* fa4c */                   STA.zpg ("bitts_00b4");
/* fa4e */                   LDA.imm (0x01);               // disable timer A interrupt
/* fa50 */                   STA.abs ("ciaicr_dc0d");      // save VIA 1 ICR
/* fa53 */        _`_fa53`;  LDA.zpg ("mych_00bf");        // parity count
/* fa55 */                   STA.zpg ("roprty_00bd");      // save RS232 parity byte
/* fa57 */                   LDA.zpg ("bitci_00a8");       // get receiver bit count in
/* fa59 */                   ORA.zpg ("rinone_00a9");      // OR with start bit check flag
/* fa5b */                   STA.zpg ("rodata_00b6");
/* fa5d */        _`_fa5d`;  JMP.abs ("_febc");            // restore registers and exit interrupt

// ------------------------------------------------------- // # store character
/* fa60 */        _`_fa60`;  JSR.abs ("_fb97");            // new tape byte setup
/* fa63 */                   STA.zpg ("dpsw_009c");        // clear byte received flag
/* fa65 */                   LDX.imm (0xda);               // set timimg max byte
/* fa67 */                   JSR.abs ("_f8e2");            // set timing
/* fa6a */                   LDA.zpg ("fsblk_00be");       // get copies count
/* fa6c */                   BEQ.rel ("_fa70");
/* fa6e */                   STA.zpg ("inbit_00a7");       // save receiver input bit temporary storage
/* fa70 */        _`_fa70`;  LDA.imm (0x0f);
/* fa72 */                   BIT.zpg ("ridata_00aa");
/* fa74 */                   BPL.rel ("_fa8d");
/* fa76 */                   LDA.zpg ("nxtbit_00b5");
/* fa78 */                   BNE.rel ("_fa86");
/* fa7a */                   LDX.zpg ("fsblk_00be");       // get copies count
/* fa7c */                   DEX.imp ();
/* fa7d */                   BNE.rel ("_fa8a");            // if ?? restore registers and exit interrupt
/* fa7f */                   LDA.imm (0x08);               // set short block
/* fa81 */                   JSR.abs ("_fe1c");            // OR into serial status byte
/* fa84 */                   BNE.rel ("_fa8a");            // restore registers and exit interrupt, branch always
/* fa86 */        _`_fa86`;  LDA.imm (0x00);
/* fa88 */                   STA.zpg ("ridata_00aa");
/* fa8a */        _`_fa8a`;  JMP.abs ("_febc");            // restore registers and exit interrupt
/* fa8d */        _`_fa8d`;  BVS.rel ("_fac0");
/* fa8f */                   BNE.rel ("_faa9");
/* fa91 */                   LDA.zpg ("nxtbit_00b5");
/* fa93 */                   BNE.rel ("_fa8a");
/* fa95 */                   LDA.zpg ("rodata_00b6");
/* fa97 */                   BNE.rel ("_fa8a");
/* fa99 */                   LDA.zpg ("inbit_00a7");       // get receiver input bit temporary storage
/* fa9b */                   LSR.acc ();
/* fa9c */                   LDA.zpg ("roprty_00bd");      // get RS232 parity byte
/* fa9e */                   BMI.rel ("_faa3");
/* faa0 */                   BCC.rel ("_faba");
/* faa2 */                   CLC.imp ();
/* faa3 */        _`_faa3`;  BCS.rel ("_faba");
/* faa5 */                   AND.imm (0x0f);
/* faa7 */                   STA.zpg ("ridata_00aa");
/* faa9 */        _`_faa9`;  DEC.zpg ("ridata_00aa");
/* faab */                   BNE.rel ("_fa8a");
/* faad */                   LDA.imm (0x40);
/* faaf */                   STA.zpg ("ridata_00aa");
/* fab1 */                   JSR.abs ("_fb8e");            // copy I/O start address to buffer address
/* fab4 */                   LDA.imm (0x00);
/* fab6 */                   STA.zpg ("riprty_00ab");
/* fab8 */                   BEQ.rel ("_fa8a");
/* faba */        _`_faba`;  LDA.imm (0x80);
/* fabc */                   STA.zpg ("ridata_00aa");
/* fabe */                   BNE.rel ("_fa8a");            // restore registers and exit interrupt, branch always
/* fac0 */        _`_fac0`;  LDA.zpg ("nxtbit_00b5");
/* fac2 */                   BEQ.rel ("_face");
/* fac4 */                   LDA.imm (0x04);
/* fac6 */                   JSR.abs ("_fe1c");            // OR into serial status byte
/* fac9 */                   LDA.imm (0x00);
/* facb */                   JMP.abs ("_fb4a");
/* face */        _`_face`;  JSR.abs ("_fcd1");            // check read/write pointer, return Cb = 1 if pointer >= end
/* fad1 */                   BCC.rel ("_fad6");
/* fad3 */                   JMP.abs ("_fb48");
/* fad6 */        _`_fad6`;  LDX.zpg ("inbit_00a7");       // get receiver input bit temporary storage
/* fad8 */                   DEX.imp ();
/* fad9 */                   BEQ.rel ("_fb08");
/* fadb */                   LDA.zpg ("verck_0093");       // get load/verify flag
/* fadd */                   BEQ.rel ("_faeb");            // if load go ??
/* fadf */                   LDY.imm (0x00);               // clear index
/* fae1 */                   LDA.zpg ("roprty_00bd");      // get RS232 parity byte
/* fae3 */                   CMP.iny ("sal+0_00ac");
/* fae5 */                   BEQ.rel ("_faeb");
/* fae7 */                   LDA.imm (0x01);
/* fae9 */                   STA.zpg ("rodata_00b6");
/* faeb */        _`_faeb`;  LDA.zpg ("rodata_00b6");
/* faed */                   BEQ.rel ("_fb3a");
/* faef */                   LDX.imm (0x3d);
/* faf1 */                   CPX.zpg ("ptr1_009e");
/* faf3 */                   BCC.rel ("_fb33");
/* faf5 */                   LDX.zpg ("ptr1_009e");
/* faf7 */                   LDA.zpg ("sal+1_00ad");
/* faf9 */                   STA.abx ("bad+1_0101");
/* fafc */                   LDA.zpg ("sal+0_00ac");
/* fafe */                   STA.abx ("bad+0_0100");
/* fb01 */                   INX.imp ();
/* fb02 */                   INX.imp ();
/* fb03 */                   STX.zpg ("ptr1_009e");
/* fb05 */                   JMP.abs ("_fb3a");
/* fb08 */        _`_fb08`;  LDX.zpg ("ptr2_009f");
/* fb0a */                   CPX.zpg ("ptr1_009e");
/* fb0c */                   BEQ.rel ("_fb43");
/* fb0e */                   LDA.zpg ("sal+0_00ac");
/* fb10 */                   CMP.abx ("bad+0_0100");
/* fb13 */                   BNE.rel ("_fb43");
/* fb15 */                   LDA.zpg ("sal+1_00ad");
/* fb17 */                   CMP.abx ("bad+1_0101");
/* fb1a */                   BNE.rel ("_fb43");
/* fb1c */                   INC.zpg ("ptr2_009f");
/* fb1e */                   INC.zpg ("ptr2_009f");
/* fb20 */                   LDA.zpg ("verck_0093");       // get load/verify flag
/* fb22 */                   BEQ.rel ("_fb2f");            // if load ??
/* fb24 */                   LDA.zpg ("roprty_00bd");      // get RS232 parity byte
/* fb26 */                   LDY.imm (0x00);
/* fb28 */                   CMP.iny ("sal+0_00ac");
/* fb2a */                   BEQ.rel ("_fb43");
/* fb2c */                   INY.imp ();
/* fb2d */                   STY.zpg ("rodata_00b6");
/* fb2f */        _`_fb2f`;  LDA.zpg ("rodata_00b6");
/* fb31 */                   BEQ.rel ("_fb3a");
/* fb33 */        _`_fb33`;  LDA.imm (0x10);
/* fb35 */                   JSR.abs ("_fe1c");            // OR into serial status byte
/* fb38 */                   BNE.rel ("_fb43");
/* fb3a */        _`_fb3a`;  LDA.zpg ("verck_0093");       // get load/verify flag
/* fb3c */                   BNE.rel ("_fb43");            // if verify go ??
/* fb3e */                   TAY.imp ();
/* fb3f */                   LDA.zpg ("roprty_00bd");      // get RS232 parity byte
/* fb41 */                   STA.iny ("sal+0_00ac");
/* fb43 */        _`_fb43`;  JSR.abs ("_fcdb");            // increment read/write pointer
/* fb46 */                   BNE.rel ("_fb8b");            // restore registers and exit interrupt, branch always
/* fb48 */        _`_fb48`;  LDA.imm (0x80);
/* fb4a */        _`_fb4a`;  STA.zpg ("ridata_00aa");
/* fb4c */                   SEI.imp ();
/* fb4d */                   LDX.imm (0x01);               // disable timer A interrupt
/* fb4f */                   STX.abs ("ciaicr_dc0d");      // save VIA 1 ICR
/* fb52 */                   LDX.abs ("ciaicr_dc0d");      // read VIA 1 ICR
/* fb55 */                   LDX.zpg ("fsblk_00be");       // get copies count
/* fb57 */                   DEX.imp ();
/* fb58 */                   BMI.rel ("_fb5c");
/* fb5a */                   STX.zpg ("fsblk_00be");       // save copies count
/* fb5c */        _`_fb5c`;  DEC.zpg ("inbit_00a7");       // decrement receiver input bit temporary storage
/* fb5e */                   BEQ.rel ("_fb68");
/* fb60 */                   LDA.zpg ("ptr1_009e");
/* fb62 */                   BNE.rel ("_fb8b");            // if ?? restore registers and exit interrupt
/* fb64 */                   STA.zpg ("fsblk_00be");       // save copies count
/* fb66 */                   BEQ.rel ("_fb8b");            // restore registers and exit interrupt, branch always
/* fb68 */        _`_fb68`;  JSR.abs ("_fc93");            // restore everything for STOP
/* fb6b */                   JSR.abs ("_fb8e");            // copy I/O start address to buffer address
/* fb6e */                   LDY.imm (0x00);               // clear index
/* fb70 */                   STY.zpg ("riprty_00ab");      // clear checksum
/* fb72 */        _`_fb72`;  LDA.iny ("sal+0_00ac");       // get byte from buffer
/* fb74 */                   EOR.zpg ("riprty_00ab");      // XOR with checksum
/* fb76 */                   STA.zpg ("riprty_00ab");      // save new checksum
/* fb78 */                   JSR.abs ("_fcdb");            // increment read/write pointer
/* fb7b */                   JSR.abs ("_fcd1");            // check read/write pointer, return Cb = 1 if pointer >= end
/* fb7e */                   BCC.rel ("_fb72");            // loop if not at end
/* fb80 */                   LDA.zpg ("riprty_00ab");      // get computed checksum
/* fb82 */                   EOR.zpg ("roprty_00bd");      // compare with stored checksum ??
/* fb84 */                   BEQ.rel ("_fb8b");            // if checksum ok restore registers and exit interrupt
/* fb86 */                   LDA.imm (0x20);               // else set checksum error
/* fb88 */                   JSR.abs ("_fe1c");            // OR into the serial status byte
/* fb8b */        _`_fb8b`;  JMP.abs ("_febc");            // restore registers and exit interrupt

// ------------------------------------------------------- // copy I/O start address to buffer address
/* fb8e */        _`_fb8e`;  LDA.zpg ("stal+1_00c2");      // get I/O start address high byte
/* fb90 */                   STA.zpg ("sal+1_00ad");       // set buffer address high byte
/* fb92 */                   LDA.zpg ("stal+0_00c1");      // get I/O start address low byte
/* fb94 */                   STA.zpg ("sal+0_00ac");       // set buffer address low byte
/* fb96 */                   RTS.imp ();

// ------------------------------------------------------- // new tape byte setup
/* fb97 */        _`_fb97`;  LDA.imm (0x08);               // eight bits to do
/* fb99 */                   STA.zpg ("tsfcnt_00a3");      // set bit count
/* fb9b */                   LDA.imm (0x00);               // clear A
/* fb9d */                   STA.zpg ("tbtcnt_00a4");      // clear tape bit cycle phase
/* fb9f */                   STA.zpg ("bitci_00a8");       // clear start bit first cycle done flag
/* fba1 */                   STA.zpg ("prty_009b");        // clear byte parity
/* fba3 */                   STA.zpg ("rinone_00a9");      // clear start bit check flag, set no start bit yet
/* fba5 */                   RTS.imp ();

// ------------------------------------------------------- // send lsb from tape write byte to tape
                                                           // this routine tests the least significant bit in the tape write byte and sets VIA 2 T2
                                                           // depending on the state of the bit. if the bit is a 1 a time of $00B0 cycles is set, if
                                                           // the bot is a 0 a time of $0060 cycles is set. note that this routine does not shift the
                                                           // bits of the tape write byte but uses a copy of that byte, the byte itself is shifted
                                                           // elsewhere
/* fba6 */        _`_fba6`;  LDA.zpg ("roprty_00bd");      // get tape write byte
/* fba8 */                   LSR.acc ();                   // shift lsb into Cb
/* fba9 */                   LDA.imm (0x60);               // set time constant low byte for bit = 0
/* fbab */                   BCC.rel ("_fbaf");            // branch if bit was 0
                                                           // set time constant for bit = 1 and toggle tape
/* fbad */        _`_fbad`;  LDA.imm (0xb0);               // set time constant low byte for bit = 1
                                                           // write time constant and toggle tape
/* fbaf */        _`_fbaf`;  LDX.imm (0x00);               // set time constant high byte
                                                           // write time constant and toggle tape
/* fbb1 */        _`_fbb1`;  STA.abs ("timblo_dc06");      // save VIA 1 timer B low byte
/* fbb4 */                   STX.abs ("timbhi_dc07");      // save VIA 1 timer B high byte
/* fbb7 */                   LDA.abs ("ciaicr_dc0d");      // read VIA 1 ICR
/* fbba */                   LDA.imm (0x19);               // load timer B, timer B single shot, start timer B
/* fbbc */                   STA.abs ("ciacrb_dc0f");      // save VIA 1 CRB
/* fbbf */                   LDA.zpg ("r6510_0001");       // read the 6510 I/O port
/* fbc1 */                   EOR.imm (0x08);               // toggle tape out bit
/* fbc3 */                   STA.zpg ("r6510_0001");       // save the 6510 I/O port
/* fbc5 */                   AND.imm (0x08);               // mask tape out bit
/* fbc7 */                   RTS.imp ();

// ------------------------------------------------------- // flag block done and exit interrupt
/* fbc8 */        _`_fbc8`;  SEC.imp ();                   // set carry flag
/* fbc9 */                   ROR.zpg ("rodata_00b6");      // set buffer address high byte negative, flag all sync,
                                                           // data and checksum bytes written
/* fbcb */                   BMI.rel ("_fc09");            // restore registers and exit interrupt, branch always

// ------------------------------------------------------- // tape write IRQ routine
                                                           // this is the routine that writes the bits to the tape. it is called each time VIA 2 T2
                                                           // times out and checks if the start bit is done, if so checks if the data bits are done,
                                                           // if so it checks if the byte is done, if so it checks if the synchronisation bytes are
                                                           // done, if so it checks if the data bytes are done, if so it checks if the checksum byte
                                                           // is done, if so it checks if both the load and verify copies have been done, if so it
                                                           // stops the tape
/* fbcd */                   LDA.zpg ("bitci_00a8");       // get start bit first cycle done flag
/* fbcf */                   BNE.rel ("_fbe3");            // if first cycle done go do rest of byte
                                                           // each byte sent starts with two half cycles of $0110 ststem clocks and the whole block
                                                           // ends with two more such half cycles
/* fbd1 */                   LDA.imm (0x10);               // set first start cycle time constant low byte
/* fbd3 */                   LDX.imm (0x01);               // set first start cycle time constant high byte
/* fbd5 */                   JSR.abs ("_fbb1");            // write time constant and toggle tape
/* fbd8 */                   BNE.rel ("_fc09");            // if first half cycle go restore registers and exit
                                                           // interrupt
/* fbda */                   INC.zpg ("bitci_00a8");       // set start bit first start cycle done flag
/* fbdc */                   LDA.zpg ("rodata_00b6");      // get buffer address high byte
/* fbde */                   BPL.rel ("_fc09");            // if block not complete go restore registers and exit
                                                           // interrupt. the end of a block is indicated by the tape
                                                           // buffer high byte b7 being set to 1
/* fbe0 */                   JMP.abs ("_fc57");            // else do tape routine, block complete exit
                                                           // continue tape byte write. the first start cycle, both half cycles of it, is complete
                                                           // so the routine drops straight through to here
/* fbe3 */        _`_fbe3`;  LDA.zpg ("rinone_00a9");      // get start bit check flag
/* fbe5 */                   BNE.rel ("_fbf0");            // if the start bit is complete go send the byte bits
                                                           // after the two half cycles of $0110 ststem clocks the start bit is completed with two
                                                           // half cycles of $00B0 system clocks. this is the same as the first part of a 1 bit
/* fbe7 */                   JSR.abs ("_fbad");            // set time constant for bit = 1 and toggle tape
/* fbea */                   BNE.rel ("_fc09");            // if first half cycle go restore registers and exit
                                                           // interrupt
/* fbec */                   INC.zpg ("rinone_00a9");      // set start bit check flag
/* fbee */                   BNE.rel ("_fc09");            // restore registers and exit interrupt, branch always
                                                           // continue tape byte write. the start bit, both cycles of it, is complete so the routine
                                                           // drops straight through to here. now the cycle pairs for each bit, and the parity bit,
                                                           // are sent
/* fbf0 */        _`_fbf0`;  JSR.abs ("_fba6");            // send lsb from tape write byte to tape
/* fbf3 */                   BNE.rel ("_fc09");            // if first half cycle go restore registers and exit
                                                           // interrupt
                                                           // else two half cycles have been done
/* fbf5 */                   LDA.zpg ("tbtcnt_00a4");      // get tape bit cycle phase
/* fbf7 */                   EOR.imm (0x01);               // toggle b0
/* fbf9 */                   STA.zpg ("tbtcnt_00a4");      // save tape bit cycle phase
/* fbfb */                   BEQ.rel ("_fc0c");            // if bit cycle phase complete go setup for next bit
                                                           // each bit is written as two full cycles. a 1 is sent as a full cycle of $0160 system
                                                           // clocks then a full cycle of $00C0 system clocks. a 0 is sent as a full cycle of $00C0
                                                           // system clocks then a full cycle of $0160 system clocks. to do this each bit from the
                                                           // write byte is inverted during the second bit cycle phase. as the bit is inverted it
                                                           // is also added to the, one bit, parity count for this byte
/* fbfd */                   LDA.zpg ("roprty_00bd");      // get tape write byte
/* fbff */                   EOR.imm (0x01);               // invert bit being sent
/* fc01 */                   STA.zpg ("roprty_00bd");      // save tape write byte
/* fc03 */                   AND.imm (0x01);               // mask b0
/* fc05 */                   EOR.zpg ("prty_009b");        // EOR with tape write byte parity bit
/* fc07 */                   STA.zpg ("prty_009b");        // save tape write byte parity bit
/* fc09 */        _`_fc09`;  JMP.abs ("_febc");            // restore registers and exit interrupt
                                                           // the bit cycle phase is complete so shift out the just written bit and test for byte
                                                           // end
/* fc0c */        _`_fc0c`;  LSR.zpg ("roprty_00bd");      // shift bit out of tape write byte
/* fc0e */                   DEC.zpg ("tsfcnt_00a3");      // decrement tape write bit count
/* fc10 */                   LDA.zpg ("tsfcnt_00a3");      // get tape write bit count
/* fc12 */                   BEQ.rel ("_fc4e");            // if all the data bits have been written go setup for
                                                           // sending the parity bit next and exit the interrupt
/* fc14 */                   BPL.rel ("_fc09");            // if all the data bits are not yet sent just restore the
                                                           // registers and exit the interrupt
                                                           // do next tape byte
                                                           // the byte is complete. the start bit, data bits and parity bit have been written to
                                                           // the tape so setup for the next byte
/* fc16 */        _`_fc16`;  JSR.abs ("_fb97");            // new tape byte setup
/* fc19 */                   CLI.imp ();                   // enable the interrupts
/* fc1a */                   LDA.zpg ("cntdn_00a5");       // get cassette synchronization character count
/* fc1c */                   BEQ.rel ("_fc30");            // if synchronisation characters done go do block data
                                                           // at the start of each block sent to tape there are a number of synchronisation bytes
                                                           // that count down to the actual data. the commodore tape system saves two copies of all
                                                           // the tape data, the first is loaded and is indicated by the synchronisation bytes
                                                           // having b7 set, and the second copy is indicated by the synchronisation bytes having b7
                                                           // clear. the sequence goes $09, $08, ..... $02, $01, data bytes
/* fc1e */                   LDX.imm (0x00);               // clear X
/* fc20 */                   STX.zpg ("schar_00d7");       // clear checksum byte
/* fc22 */                   DEC.zpg ("cntdn_00a5");       // decrement cassette synchronization byte count
/* fc24 */                   LDX.zpg ("fsblk_00be");       // get cassette copies count
/* fc26 */                   CPX.imm (0x02);               // compare with load block indicator
/* fc28 */                   BNE.rel ("_fc2c");            // branch if not the load block
/* fc2a */                   ORA.imm (0x80);               // this is the load block so make the synchronisation count
                                                           // go $89, $88, ..... $82, $81
/* fc2c */        _`_fc2c`;  STA.zpg ("roprty_00bd");      // save the synchronisation byte as the tape write byte
/* fc2e */                   BNE.rel ("_fc09");            // restore registers and exit interrupt, branch always
                                                           // the synchronization bytes have been done so now check and do the actual block data
/* fc30 */        _`_fc30`;  JSR.abs ("_fcd1");            // check read/write pointer, return Cb = 1 if pointer >= end
/* fc33 */                   BCC.rel ("_fc3f");            // if not all done yet go get the byte to send
/* fc35 */                   BNE.rel ("_fbc8");            // if pointer > end go flag block done and exit interrupt
                                                           // else the block is complete, it only remains to write the
                                                           // checksum byte to the tape so setup for that
/* fc37 */                   INC.zpg ("sal+1_00ad");       // increment buffer pointer high byte, this means the block
                                                           // done branch will always be taken next time without having
                                                           // to worry about the low byte wrapping to zero
/* fc39 */                   LDA.zpg ("schar_00d7");       // get checksum byte
/* fc3b */                   STA.zpg ("roprty_00bd");      // save checksum as tape write byte
/* fc3d */                   BCS.rel ("_fc09");            // restore registers and exit interrupt, branch always
                                                           // the block isn't finished so get the next byte to write to tape
/* fc3f */        _`_fc3f`;  LDY.imm (0x00);               // clear index
/* fc41 */                   LDA.iny ("sal+0_00ac");       // get byte from buffer
/* fc43 */                   STA.zpg ("roprty_00bd");      // save as tape write byte
/* fc45 */                   EOR.zpg ("schar_00d7");       // XOR with checksum byte
/* fc47 */                   STA.zpg ("schar_00d7");       // save new checksum byte
/* fc49 */                   JSR.abs ("_fcdb");            // increment read/write pointer
/* fc4c */                   BNE.rel ("_fc09");            // restore registers and exit interrupt, branch always
                                                           // set parity as next bit and exit interrupt
/* fc4e */        _`_fc4e`;  LDA.zpg ("prty_009b");        // get parity bit
/* fc50 */                   EOR.imm (0x01);               // toggle it
/* fc52 */                   STA.zpg ("roprty_00bd");      // save as tape write byte
/* fc54 */        _`_fc54`;  JMP.abs ("_febc");            // restore registers and exit interrupt
                                                           // tape routine, block complete exit
/* fc57 */        _`_fc57`;  DEC.zpg ("fsblk_00be");       // decrement copies remaining to read/write
/* fc59 */                   BNE.rel ("_fc5e");            // branch if more to do
/* fc5b */                   JSR.abs ("_fcca");            // stop the cassette motor
/* fc5e */        _`_fc5e`;  LDA.imm (0x50);               // set tape write leader count
/* fc60 */                   STA.zpg ("inbit_00a7");       // save tape write leader count
/* fc62 */                   LDX.imm (0x08);               // set index for write tape leader vector
/* fc64 */                   SEI.imp ();                   // disable the interrupts
/* fc65 */                   JSR.abs ("_fcbd");            // set the tape vector
/* fc68 */                   BNE.rel ("_fc54");            // restore registers and exit interrupt, branch always

// ------------------------------------------------------- // write tape leader IRQ routine
/* fc6a */                   LDA.imm (0x78);               // set time constant low byte for bit = leader
/* fc6c */                   JSR.abs ("_fbaf");            // write time constant and toggle tape
/* fc6f */                   BNE.rel ("_fc54");            // if tape bit high restore registers and exit interrupt
/* fc71 */                   DEC.zpg ("inbit_00a7");       // decrement cycle count
/* fc73 */                   BNE.rel ("_fc54");            // if not all done restore registers and exit interrupt
/* fc75 */                   JSR.abs ("_fb97");            // new tape byte setup
/* fc78 */                   DEC.zpg ("riprty_00ab");      // decrement cassette leader count
/* fc7a */                   BPL.rel ("_fc54");            // if not all done restore registers and exit interrupt
/* fc7c */                   LDX.imm (0x0a);               // set index for tape write vector
/* fc7e */                   JSR.abs ("_fcbd");            // set the tape vector
/* fc81 */                   CLI.imp ();                   // enable the interrupts
/* fc82 */                   INC.zpg ("riprty_00ab");      // clear cassette leader counter, was $FF
/* fc84 */                   LDA.zpg ("fsblk_00be");       // get cassette block count
/* fc86 */                   BEQ.rel ("_fcb8");            // if all done restore everything for STOP and exit the
                                                           // interrupt
/* fc88 */                   JSR.abs ("_fb8e");            // copy I/O start address to buffer address
/* fc8b */                   LDX.imm (0x09);               // set nine synchronisation bytes
/* fc8d */                   STX.zpg ("cntdn_00a5");       // save cassette synchronization byte count
/* fc8f */                   STX.zpg ("rodata_00b6");
/* fc91 */                   BNE.rel ("_fc16");            // go do the next tape byte, branch always

// ------------------------------------------------------- // restore everything for STOP
/* fc93 */        _`_fc93`;  PHP.imp ();                   // save status
/* fc94 */                   SEI.imp ();                   // disable the interrupts
/* fc95 */                   LDA.abs ("scroly_d011");      // read the vertical fine scroll and control register
/* fc98 */                   ORA.imm (0x10);               // mask xxx1 xxxx, unblank the screen
/* fc9a */                   STA.abs ("scroly_d011");      // save the vertical fine scroll and control register
/* fc9d */                   JSR.abs ("_fcca");            // stop the cassette motor
/* fca0 */                   LDA.imm (0x7f);               // disable all interrupts
/* fca2 */                   STA.abs ("ciaicr_dc0d");      // save VIA 1 ICR
/* fca5 */                   JSR.abs ("_fddd");
/* fca8 */                   LDA.abs ("irqtmp+1_02a0");    // get saved IRQ vector high byte
/* fcab */                   BEQ.rel ("_fcb6");            // branch if null
/* fcad */                   STA.abs ("cinv+1_0315");      // restore IRQ vector high byte
/* fcb0 */                   LDA.abs ("irqtmp+0_029f");    // get saved IRQ vector low byte
/* fcb3 */                   STA.abs ("cinv+0_0314");      // restore IRQ vector low byte
/* fcb6 */        _`_fcb6`;  PLP.imp ();                   // restore status
/* fcb7 */                   RTS.imp ();

// ------------------------------------------------------- // reset vector
/* fcb8 */        _`_fcb8`;  JSR.abs ("_fc93");            // restore everything for STOP
/* fcbb */                   BEQ.rel ("_fc54");            // restore registers and exit interrupt, branch always

// ------------------------------------------------------- // set tape vector
/* fcbd */        _`_fcbd`;  LDA.abx (0xfd93);             // get tape IRQ vector low byte
/* fcc0 */                   STA.abs ("cinv+0_0314");      // set IRQ vector low byte
/* fcc3 */                   LDA.abx (0xfd94);             // get tape IRQ vector high byte
/* fcc6 */                   STA.abs ("cinv+1_0315");      // set IRQ vector high byte
/* fcc9 */                   RTS.imp ();

// ------------------------------------------------------- // stop the cassette motor
/* fcca */        _`_fcca`;  LDA.zpg ("r6510_0001");       // read the 6510 I/O port
/* fccc */                   ORA.imm (0x20);               // mask xxxx xx1x, turn the cassette motor off
/* fcce */                   STA.zpg ("r6510_0001");       // save the 6510 I/O port
/* fcd0 */                   RTS.imp ();

// ------------------------------------------------------- // check read/write pointer
                                                           // return Cb = 1 if pointer >= end
/* fcd1 */        _`_fcd1`;  SEC.imp ();                   // set carry for subtract
/* fcd2 */                   LDA.zpg ("sal+0_00ac");       // get buffer address low byte
/* fcd4 */                   SBC.zpg ("eal+0_00ae");       // subtract buffer end low byte
/* fcd6 */                   LDA.zpg ("sal+1_00ad");       // get buffer address high byte
/* fcd8 */                   SBC.zpg ("eal+1_00af");       // subtract buffer end high byte
/* fcda */                   RTS.imp ();

// ------------------------------------------------------- // increment read/write pointer
/* fcdb */        _`_fcdb`;  INC.zpg ("sal+0_00ac");       // increment buffer address low byte
/* fcdd */                   BNE.rel ("_fce1");            // branch if no overflow
/* fcdf */                   INC.zpg ("sal+1_00ad");       // increment buffer address low byte
/* fce1 */        _`_fce1`;  RTS.imp ();

// ------------------------------------------------------- // RESET, hardware reset starts here
/* fce2 */                   LDX.imm (0xff);               // set X for stack
/* fce4 */                   SEI.imp ();                   // disable the interrupts
/* fce5 */                   TXS.imp ();                   // clear stack
/* fce6 */                   CLD.imp ();                   // clear decimal mode
/* fce7 */                   JSR.abs ("_fd02");            // scan for autostart ROM at $8000
/* fcea */                   BNE.rel ("_fcef");            // if not there continue startup
/* fcec */                   JMP.ind ("_8000");            // else call ROM start code
/* fcef */        _`_fcef`;  STX.abs ("scrolx_d016");      // read the horizontal fine scroll and control register
/* fcf2 */                   JSR.abs ("ioinit_fda3");      // initialise SID, CIA and IRQ
/* fcf5 */                   JSR.abs ("ramtas_fd50");      // RAM test and find RAM end
/* fcf8 */                   JSR.abs ("restor_fd15");      // restore default I/O vectors
/* fcfb */                   JSR.abs ("cint_ff5b");        // initialise VIC and screen editor
/* fcfe */                   CLI.imp ();                   // enable the interrupts
/* fcff */                   JMP.ind ("restart_a000");     // execute BASIC

// ------------------------------------------------------- // scan for autostart ROM at $8000, returns Zb=1 if ROM found
/* fd02 */        _`_fd02`;  LDX.imm (0x05);               // five characters to test
/* fd04 */        _`_fd04`;  LDA.abx ("_fd0f");            // get test character
/* fd07 */                   CMP.abx ("_8003");            // compare wiith byte in ROM space
/* fd0a */                   BNE.rel ("_fd0f");            // exit if no match
/* fd0c */                   DEX.imp ();                   // decrement index
/* fd0d */                   BNE.rel ("_fd04");            // loop if not all done
/* fd0f */        _`_fd0f`;  RTS.imp ();
// ------------------------------------------------------- // autostart ROM signature
                                                           // 'CBM80’
/* fd10 */                   _.bytes(0xc3, 0xc2, 0xcd, 0x38, 0x30);

// ------------------------------------------------------- // restore default I/O vectors
/* fd15 */  _`restor_fd15`;  LDX.imm (0x30);               // pointer to vector table low byte
/* fd17 */                   LDY.imm (0xfd);               // pointer to vector table high byte
/* fd19 */                   CLC.imp ();                   // flag set vectors

// ------------------------------------------------------- // set/read vectored I/O from (XY), Cb = 1 to read, Cb = 0 to set
/* fd1a */  _`vector_fd1a`;  STX.zpg ("memuss+0_00c3");    // save pointer low byte
/* fd1c */                   STY.zpg ("memuss+1_00c4");    // save pointer high byte
/* fd1e */                   LDY.imm (0x1f);               // set byte count
/* fd20 */        _`_fd20`;  LDA.aby ("cinv+0_0314");      // read vector byte from vectors
/* fd23 */                   BCS.rel ("_fd27");            // branch if read vectors
/* fd25 */                   LDA.iny ("memuss+0_00c3");    // read vector byte from (XY)
/* fd27 */        _`_fd27`;  STA.iny ("memuss+0_00c3");    // save byte to (XY)
/* fd29 */                   STA.aby ("cinv+0_0314");      // save byte to vector
/* fd2c */                   DEY.imp ();                   // decrement index
/* fd2d */                   BPL.rel ("_fd20");            // loop if more to do
/* fd2f */                   RTS.imp ();
                                                           //  The above code works but it tries to write to the ROM. while this is usually harmless
                                                           //  systems that use flash ROM may suffer. Here is a version that makes the extra write
                                                           //  to RAM instead but is otherwise identical in function. ##

                                                           //  set/read vectored I/O from (XY), Cb = 1 to read, Cb = 0 to set

                                                           // STX $C3         ; save pointer low byte
                                                           // STY $C4         ; save pointer high byte
                                                           // LDY #$1F        ; set byte count
                                                           // LDA ($C3),Y     ; read vector byte from (XY)
                                                           // BCC $FD29       ; branch if set vectors

                                                           // LDA $0314,Y     ; else read vector byte from vectors
                                                           // STA ($C3),Y     ; save byte to (XY)
                                                           // STA $0314,Y     ; save byte to vector
                                                           // DEY             ; decrement index
                                                           // BPL $FD20       ; loop if more to do

                                                           // RTS

// ------------------------------------------------------- // kernal vectors
/* fd30 */                   _.bytes(0x31, 0xea);          // $0314 IRQ vector
/* fd32 */                   _.bytes(0x66, 0xfe);          // $0316 BRK vector
/* fd34 */                   _.bytes(0x47, 0xfe);          // $0318 NMI vector
/* fd36 */                   _.bytes(0x4a, 0xf3);          // $031A open a logical file
/* fd38 */                   _.bytes(0x91, 0xf2);          // $031C close a specified logical file
/* fd3a */                   _.bytes(0x0e, 0xf2);          // $031E open channel for input
/* fd3c */                   _.bytes(0x50, 0xf2);          // $0320 open channel for output
/* fd3e */                   _.bytes(0x33, 0xf3);          // $0322 close input and output channels
/* fd40 */                   _.bytes(0x57, 0xf1);          // $0324 input character from channel
/* fd42 */                   _.bytes(0xca, 0xf1);          // $0326 output character to channel
/* fd44 */                   _.bytes(0xed, 0xf6);          // $0328 scan stop key
/* fd46 */                   _.bytes(0x3e, 0xf1);          // $032A get character from the input device
/* fd48 */                   _.bytes(0x2f, 0xf3);          // $032C close all channels and files
/* fd4a */                   _.bytes(0x66, 0xfe);          // $032E user function
                                                           // Vector to user defined command, currently points to BRK.
                                                           // This appears to be a holdover from PET days, when the built-in machine language monitor
                                                           // would jump through the $032E vector when it encountered a command that it did not
                                                           // understand, allowing the user to add new commands to the monitor.
                                                           // Although this vector is initialized to point to the routine called by STOP/RESTORE and
                                                           // the BRK interrupt, and is updated by the kernal vector routine at $FD57, it no longer
                                                           // has any function.
/* fd4c */                   _.bytes(0xa5, 0xf4);          // $0330 load
/* fd4e */                   _.bytes(0xed, 0xf5);          // $0332 save

// ------------------------------------------------------- // test RAM and find RAM end
/* fd50 */  _`ramtas_fd50`;  LDA.imm (0x00);               // clear A
/* fd52 */                   TAY.imp ();                   // clear index
/* fd53 */        _`_fd53`;  STA.aby ("_0002");            // clear page 0, don't do $0000 or $0001
/* fd56 */                   STA.aby ("buf+0_0200");       // clear page 2
/* fd59 */                   STA.aby ("ierror+0_0300");    // clear page 3
/* fd5c */                   INY.imp ();                   // increment index
/* fd5d */                   BNE.rel ("_fd53");            // loop if more to do
/* fd5f */                   LDX.imm (0x3c);               // set cassette buffer pointer low byte
/* fd61 */                   LDY.imm (0x03);               // set cassette buffer pointer high byte
/* fd63 */                   STX.zpg ("tape1+0_00b2");     // save tape buffer start pointer low byte
/* fd65 */                   STY.zpg ("tape1+1_00b3");     // save tape buffer start pointer high byte
/* fd67 */                   TAY.imp ();                   // clear Y
/* fd68 */                   LDA.imm (0x03);               // set RAM test pointer high byte
/* fd6a */                   STA.zpg ("stal+1_00c2");      // save RAM test pointer high byte
/* fd6c */        _`_fd6c`;  INC.zpg ("stal+1_00c2");      // increment RAM test pointer high byte
/* fd6e */        _`_fd6e`;  LDA.iny ("stal+0_00c1");
/* fd70 */                   TAX.imp ();
/* fd71 */                   LDA.imm (0x55);
/* fd73 */                   STA.iny ("stal+0_00c1");
/* fd75 */                   CMP.iny ("stal+0_00c1");
/* fd77 */                   BNE.rel ("_fd88");
/* fd79 */                   ROL.acc ();
/* fd7a */                   STA.iny ("stal+0_00c1");
/* fd7c */                   CMP.iny ("stal+0_00c1");
/* fd7e */                   BNE.rel ("_fd88");
/* fd80 */                   TXA.imp ();
/* fd81 */                   STA.iny ("stal+0_00c1");
/* fd83 */                   INY.imp ();
/* fd84 */                   BNE.rel ("_fd6e");
/* fd86 */                   BEQ.rel ("_fd6c");
/* fd88 */        _`_fd88`;  TYA.imp ();
/* fd89 */                   TAX.imp ();
/* fd8a */                   LDY.zpg ("stal+1_00c2");
/* fd8c */                   CLC.imp ();
/* fd8d */                   JSR.abs ("_fe2d");            // set the top of memory
/* fd90 */                   LDA.imm (0x08);
/* fd92 */                   STA.abs ("memstr+1_0282");    // save the OS start of memory high byte
/* fd95 */                   LDA.imm (0x04);
/* fd97 */                   STA.abs ("hibase_0288");      // save the screen memory page
/* fd9a */                   RTS.imp ();

// ------------------------------------------------------- // tape IRQ vectors
/* fd9b */                   _.bytes(0x6a, 0xfc);          // $08 write tape leader IRQ routine
/* fd9d */                   _.bytes(0xcd, 0xfb);          // $0A tape write IRQ routine
/* fd9f */                   _.bytes(0x31, 0xea);          // $0C normal IRQ vector
/* fda1 */                   _.bytes(0x2c, 0xf9);          // $0E read tape bits IRQ routine

// ------------------------------------------------------- // initialise SID, CIA and IRQ
/* fda3 */  _`ioinit_fda3`;  LDA.imm (0x7f);               // disable all interrupts
/* fda5 */                   STA.abs ("ciaicr_dc0d");      // save VIA 1 ICR
/* fda8 */                   STA.abs ("ci2icr_dd0d");      // save VIA 2 ICR
/* fdab */                   STA.abs ("ciapra_dc00");      // save VIA 1 DRA, keyboard column drive
/* fdae */                   LDA.imm (0x08);               // set timer single shot
/* fdb0 */                   STA.abs ("ciacra_dc0e");      // save VIA 1 CRA
/* fdb3 */                   STA.abs ("ci2cra_dd0e");      // save VIA 2 CRA
/* fdb6 */                   STA.abs ("ciacrb_dc0f");      // save VIA 1 CRB
/* fdb9 */                   STA.abs ("ci2crb_dd0f");      // save VIA 2 CRB
/* fdbc */                   LDX.imm (0x00);               // set all inputs
/* fdbe */                   STX.abs ("ciddrb_dc03");      // save VIA 1 DDRB, keyboard row
/* fdc1 */                   STX.abs ("c2ddrb_dd03");      // save VIA 2 DDRB, RS232 port
/* fdc4 */                   STX.abs ("sigvol_d418");      // clear the volume and filter select register
/* fdc7 */                   DEX.imp ();                   // set X = $FF
/* fdc8 */                   STX.abs ("ciddra_dc02");      // save VIA 1 DDRA, keyboard column
/* fdcb */                   LDA.imm (0x07);               // DATA out high, CLK out high, ATN out high, RE232 Tx DATA
                                                           // high, video address 15 = 1, video address 14 = 1
/* fdcd */                   STA.abs ("ci2pra_dd00");      // save VIA 2 DRA, serial port and video address
/* fdd0 */                   LDA.imm (0x3f);               // set serial DATA input, serial CLK input
/* fdd2 */                   STA.abs ("c2ddra_dd02");      // save VIA 2 DDRA, serial port and video address
/* fdd5 */                   LDA.imm (0xe7);               // set 1110 0111, motor off, enable I/O, enable KERNAL,
                                                           // enable BASIC
/* fdd7 */                   STA.zpg ("r6510_0001");       // save the 6510 I/O port
/* fdd9 */                   LDA.imm (0x2f);               // set 0010 1111, 0 = input, 1 = output
/* fddb */                   STA.zpg ("d6510_0000");       // save the 6510 I/O port direction register
/* fddd */        _`_fddd`;  LDA.abs ("tvsflg_02a6");      // get the PAL/NTSC flag
/* fde0 */                   BEQ.rel ("_fdec");            // if NTSC go set NTSC timing
                                                           // else set PAL timing
/* fde2 */                   LDA.imm (0x25);
/* fde4 */                   STA.abs ("timalo_dc04");      // save VIA 1 timer A low byte
/* fde7 */                   LDA.imm (0x40);
/* fde9 */                   JMP.abs ("_fdf3");
/* fdec */        _`_fdec`;  LDA.imm (0x95);
/* fdee */                   STA.abs ("timalo_dc04");      // save VIA 1 timer A low byte
/* fdf1 */                   LDA.imm (0x42);
/* fdf3 */        _`_fdf3`;  STA.abs ("timahi_dc05");      // save VIA 1 timer A high byte
/* fdf6 */                   JMP.abs ("_ff6e");

// ------------------------------------------------------- // set filename
/* fdf9 */  _`setnam_fdf9`;  STA.zpg ("fnlen_00b7");       // set file name length
/* fdfb */                   STX.zpg ("fnadr+0_00bb");     // set file name pointer low byte
/* fdfd */                   STY.zpg ("fnadr+1_00bc");     // set file name pointer high byte
/* fdff */                   RTS.imp ();

// ------------------------------------------------------- // set logical, first and second addresses
/* fe00 */  _`setlfs_fe00`;  STA.zpg ("la_00b8");          // save the logical file
/* fe02 */                   STX.zpg ("fa_00ba");          // save the device number
/* fe04 */                   STY.zpg ("sa_00b9");          // save the secondary address
/* fe06 */                   RTS.imp ();

// ------------------------------------------------------- // read I/O status word
/* fe07 */  _`readst_fe07`;  LDA.zpg ("fa_00ba");          // get the device number
/* fe09 */                   CMP.imm (0x02);               // compare device with RS232 device
/* fe0b */                   BNE.rel ("_fe1a");            // if not RS232 device go ??
                                                           // get RS232 device status
/* fe0d */                   LDA.abs ("rsstat_0297");      // get the RS232 status register
/* fe10 */                   PHA.imp ();                   // save the RS232 status value
/* fe11 */                   LDA.imm (0x00);               // clear A
/* fe13 */                   STA.abs ("rsstat_0297");      // clear the RS232 status register
/* fe16 */                   PLA.imp ();                   // restore the RS232 status value
/* fe17 */                   RTS.imp ();

// ------------------------------------------------------- // control kernal messages
/* fe18 */  _`setmsg_fe18`;  STA.zpg ("msgflg_009d");      // set message mode flag
/* fe1a */        _`_fe1a`;  LDA.zpg ("status_0090");      // read the serial status byte

// ------------------------------------------------------- // OR into the serial status byte
/* fe1c */        _`_fe1c`;  ORA.zpg ("status_0090");      // OR with the serial status byte
/* fe1e */                   STA.zpg ("status_0090");      // save the serial status byte
/* fe20 */                   RTS.imp ();

// ------------------------------------------------------- // set timeout on serial bus
/* fe21 */  _`settmo_fe21`;  STA.abs ("timout_0285");      // save serial bus timeout flag
/* fe24 */                   RTS.imp ();

// ------------------------------------------------------- // read/set the top of memory, Cb = 1 to read, Cb = 0 to set
/* fe25 */  _`memtop_fe25`;  BCC.rel ("_fe2d");            // if Cb clear go set the top of memory

// ------------------------------------------------------- // read the top of memory
/* fe27 */        _`_fe27`;  LDX.abs ("memsiz+0_0283");    // get memory top low byte
/* fe2a */                   LDY.abs ("memsiz+1_0284");    // get memory top high byte

// ------------------------------------------------------- // set the top of memory
/* fe2d */        _`_fe2d`;  STX.abs ("memsiz+0_0283");    // set memory top low byte
/* fe30 */                   STY.abs ("memsiz+1_0284");    // set memory top high byte
/* fe33 */                   RTS.imp ();

// ------------------------------------------------------- // read/set the bottom of memory, Cb = 1 to read, Cb = 0 to set
/* fe34 */  _`membot_fe34`;  BCC.rel ("_fe3c");            // if Cb clear go set the bottom of memory
/* fe36 */                   LDX.abs ("memstr+0_0281");    // get the OS start of memory low byte
/* fe39 */                   LDY.abs ("memstr+1_0282");    // get the OS start of memory high byte
/* fe3c */        _`_fe3c`;  STX.abs ("memstr+0_0281");    // save the OS start of memory low byte
/* fe3f */                   STY.abs ("memstr+1_0282");    // save the OS start of memory high byte
/* fe42 */                   RTS.imp ();

// ------------------------------------------------------- // NMI vector
/* fe43 */                   SEI.imp ();                   // disable the interrupts
/* fe44 */                   JMP.ind ("nminv+0_0318");     // do NMI vector

// ------------------------------------------------------- // NMI handler
/* fe47 */                   PHA.imp ();                   // save A
/* fe48 */                   TXA.imp ();                   // copy X
/* fe49 */                   PHA.imp ();                   // save X
/* fe4a */                   TYA.imp ();                   // copy Y
/* fe4b */                   PHA.imp ();                   // save Y
/* fe4c */                   LDA.imm (0x7f);               // disable all interrupts
/* fe4e */                   STA.abs ("ci2icr_dd0d");      // save VIA 2 ICR
/* fe51 */                   LDY.abs ("ci2icr_dd0d");      // save VIA 2 ICR
/* fe54 */                   BMI.rel ("_fe72");
/* fe56 */                   JSR.abs ("_fd02");            // scan for autostart ROM at $8000
/* fe59 */                   BNE.rel ("_fe5e");            // branch if no autostart ROM
/* fe5b */                   JMP.ind ("_8002");            // else do autostart ROM break entry
/* fe5e */        _`_fe5e`;  JSR.abs ("_f6bc");            // increment real time clock
/* fe61 */                   JSR.abs ("stop_ffe1");        // scan stop key
/* fe64 */                   BNE.rel ("_fe72");            // if not [STOP] restore registers and exit interrupt

// ------------------------------------------------------- // user function default vector
                                                           // BRK handler
/* fe66 */                   JSR.abs ("restor_fd15");      // restore default I/O vectors
/* fe69 */                   JSR.abs ("ioinit_fda3");      // initialise SID, CIA and IRQ
/* fe6c */                   JSR.abs ("cint1_e518");       // initialise the screen and keyboard
/* fe6f */                   JMP.ind ("_a002");            // do BASIC break entry

// ------------------------------------------------------- // RS232 NMI routine
/* fe72 */        _`_fe72`;  TYA.imp ();
/* fe73 */                   AND.abs ("enabl_02a1");       // AND with the RS-232 interrupt enable byte
/* fe76 */                   TAX.imp ();
/* fe77 */                   AND.imm (0x01);
/* fe79 */                   BEQ.rel ("_fea3");
/* fe7b */                   LDA.abs ("ci2pra_dd00");      // read VIA 2 DRA, serial port and video address
/* fe7e */                   AND.imm (0xfb);               // mask xxxx x0xx, clear RS232 Tx DATA
/* fe80 */                   ORA.zpg ("nxtbit_00b5");      // OR in the RS232 transmit data bit
/* fe82 */                   STA.abs ("ci2pra_dd00");      // save VIA 2 DRA, serial port and video address
/* fe85 */                   LDA.abs ("enabl_02a1");       // get the RS-232 interrupt enable byte
/* fe88 */                   STA.abs ("ci2icr_dd0d");      // save VIA 2 ICR
/* fe8b */                   TXA.imp ();
/* fe8c */                   AND.imm (0x12);
/* fe8e */                   BEQ.rel ("_fe9d");
/* fe90 */                   AND.imm (0x02);
/* fe92 */                   BEQ.rel ("_fe9a");
/* fe94 */                   JSR.abs ("_fed6");
/* fe97 */                   JMP.abs ("_fe9d");
/* fe9a */        _`_fe9a`;  JSR.abs ("_ff07");
/* fe9d */        _`_fe9d`;  JSR.abs ("_eebb");
/* fea0 */                   JMP.abs ("_feb6");
/* fea3 */        _`_fea3`;  TXA.imp ();                   // get active interrupts back
/* fea4 */                   AND.imm (0x02);               // mask ?? interrupt
/* fea6 */                   BEQ.rel ("_feae");            // branch if not ?? interrupt
                                                           // was ?? interrupt
/* fea8 */                   JSR.abs ("_fed6");
/* feab */                   JMP.abs ("_feb6");
/* feae */        _`_feae`;  TXA.imp ();                   // get active interrupts back
/* feaf */                   AND.imm (0x10);               // mask CB1 interrupt, Rx data bit transition
/* feb1 */                   BEQ.rel ("_feb6");            // if no bit restore registers and exit interrupt
/* feb3 */                   JSR.abs ("_ff07");
/* feb6 */        _`_feb6`;  LDA.abs ("enabl_02a1");       // get the RS-232 interrupt enable byte
/* feb9 */                   STA.abs ("ci2icr_dd0d");      // save VIA 2 ICR
/* febc */        _`_febc`;  PLA.imp ();                   // pull Y
/* febd */                   TAY.imp ();                   // restore Y
/* febe */                   PLA.imp ();                   // pull X
/* febf */                   TAX.imp ();                   // restore X
/* fec0 */        _`_fec0`;  PLA.imp ();                   // restore A
/* fec1 */        _`_fec1`;  RTI.imp ();

// ------------------------------------------------------- // baud rate word is calculated from ..

                                                           // (system clock / baud rate) / 2 - 100

                                                           //     system clock
                                                           //     ------------
                                                           // PAL        985248 Hz
                                                           // NTSC     1022727 Hz
                                                           // baud rate tables for NTSC C64
/* fec2 */                   _.bytes(0xc1, 0x27);          //   50   baud   1027700
/* fec4 */                   _.bytes(0x3e, 0x1a);          //   75   baud   1022700
/* fec6 */                   _.bytes(0xc5, 0x11);          //  110   baud   1022780
/* fec8 */                   _.bytes(0x74, 0x0e);          //  134.5 baud   1022200
/* feca */                   _.bytes(0xed, 0x0c);          //  150   baud   1022700
/* fecc */                   _.bytes(0x45, 0x06);          //  300   baud   1023000
/* fece */                   _.bytes(0xf0, 0x02);          //  600   baud   1022400
/* fed0 */                   _.bytes(0x46, 0x01);          // 1200   baud   1022400
/* fed2 */                   _.bytes(0xb8, 0x00);          // 1800   baud   1022400
/* fed4 */                   _.bytes(0x71, 0x00);          // 2400   baud   1022400

// ------------------------------------------------------- // ??
/* fed6 */        _`_fed6`;  LDA.abs ("ci2prb_dd01");      // read VIA 2 DRB, RS232 port
/* fed9 */                   AND.imm (0x01);               // mask 0000 000x, RS232 Rx DATA
/* fedb */                   STA.zpg ("inbit_00a7");       // save the RS232 received data bit
/* fedd */                   LDA.abs ("ti2blo_dd06");      // get VIA 2 timer B low byte
/* fee0 */                   SBC.imm (0x1c);
/* fee2 */                   ADC.abs ("baudof+0_0299");
/* fee5 */                   STA.abs ("ti2blo_dd06");      // save VIA 2 timer B low byte
/* fee8 */                   LDA.abs ("ti2bhi_dd07");      // get VIA 2 timer B high byte
/* feeb */                   ADC.abs ("baudof+1_029a");
/* feee */                   STA.abs ("ti2bhi_dd07");      // save VIA 2 timer B high byte
/* fef1 */                   LDA.imm (0x11);               // set timer B single shot, start timer B
/* fef3 */                   STA.abs ("ci2crb_dd0f");      // save VIA 2 CRB
/* fef6 */                   LDA.abs ("enabl_02a1");       // get the RS-232 interrupt enable byte
/* fef9 */                   STA.abs ("ci2icr_dd0d");      // save VIA 2 ICR
/* fefc */                   LDA.imm (0xff);
/* fefe */                   STA.abs ("ti2blo_dd06");      // save VIA 2 timer B low byte
/* ff01 */                   STA.abs ("ti2bhi_dd07");      // save VIA 2 timer B high byte
/* ff04 */                   JMP.abs ("_ef59");
/* ff07 */        _`_ff07`;  LDA.abs ("m51ajb+0_0295");    // nonstandard bit timing low byte
/* ff0a */                   STA.abs ("ti2blo_dd06");      // save VIA 2 timer B low byte
/* ff0d */                   LDA.abs ("m51ajb+1_0296");    // nonstandard bit timing high byte
/* ff10 */                   STA.abs ("ti2bhi_dd07");      // save VIA 2 timer B high byte
/* ff13 */                   LDA.imm (0x11);               // set timer B single shot, start timer B
/* ff15 */                   STA.abs ("ci2crb_dd0f");      // save VIA 2 CRB
/* ff18 */                   LDA.imm (0x12);
/* ff1a */                   EOR.abs ("enabl_02a1");       // EOR with the RS-232 interrupt enable byte
/* ff1d */                   STA.abs ("enabl_02a1");       // save the RS-232 interrupt enable byte
/* ff20 */                   LDA.imm (0xff);
/* ff22 */                   STA.abs ("ti2blo_dd06");      // save VIA 2 timer B low byte
/* ff25 */                   STA.abs ("ti2bhi_dd07");      // save VIA 2 timer B high byte
/* ff28 */                   LDX.abs ("bitnum_0298");
/* ff2b */                   STX.zpg ("bitci_00a8");
/* ff2d */                   RTS.imp ();

// ------------------------------------------------------- // ??
/* ff2e */        _`_ff2e`;  TAX.imp ();
/* ff2f */                   LDA.abs ("m51ajb+1_0296");    // nonstandard bit timing high byte
/* ff32 */                   ROL.acc ();
/* ff33 */                   TAY.imp ();
/* ff34 */                   TXA.imp ();
/* ff35 */                   ADC.imm (0xc8);
/* ff37 */                   STA.abs ("baudof+0_0299");
/* ff3a */                   TYA.imp ();
/* ff3b */                   ADC.imm (0x00);               // add any carry
/* ff3d */                   STA.abs ("baudof+1_029a");
/* ff40 */                   RTS.imp ();

// ------------------------------------------------------- // unused bytes
/* ff41 */                   NOP.imp ();                   // waste cycles
/* ff42 */                   NOP.imp ();                   // waste cycles

// ------------------------------------------------------- // save the status and do the IRQ routine
/* ff43 */        _`_ff43`;  PHP.imp ();                   // save the processor status
/* ff44 */                   PLA.imp ();                   // pull the processor status
/* ff45 */                   AND.imm (0xef);               // mask xxx0 xxxx, clear the break bit
/* ff47 */                   PHA.imp ();                   // save the modified processor status

// ------------------------------------------------------- // IRQ vector
/* ff48 */                   PHA.imp ();                   // save A
/* ff49 */                   TXA.imp ();                   // copy X
/* ff4a */                   PHA.imp ();                   // save X
/* ff4b */                   TYA.imp ();                   // copy Y
/* ff4c */                   PHA.imp ();                   // save Y
/* ff4d */                   TSX.imp ();                   // copy stack pointer
/* ff4e */                   LDA.abx ("bad+4_0104");       // get stacked status register
/* ff51 */                   AND.imm (0x10);               // mask BRK flag
/* ff53 */                   BEQ.rel ("_ff58");            // branch if not BRK
/* ff55 */                   JMP.ind ("cbinv+0_0316");     // else do BRK vector (iBRK)
/* ff58 */        _`_ff58`;  JMP.ind ("cinv+0_0314");      // do IRQ vector (iIRQ)

// ------------------------------------------------------- // initialise VIC and screen editor
/* ff5b */    _`cint_ff5b`;  JSR.abs ("cint1_e518");       // initialise the screen and keyboard
/* ff5e */        _`_ff5e`;  LDA.abs ("raster_d012");      // read the raster compare register
/* ff61 */                   BNE.rel ("_ff5e");            // loop if not raster line $00
/* ff63 */                   LDA.abs ("vicirq_d019");      // read the vic interrupt flag register
/* ff66 */                   AND.imm (0x01);               // mask the raster compare flag
/* ff68 */                   STA.abs ("tvsflg_02a6");      // save the PAL/NTSC flag
/* ff6b */                   JMP.abs ("_fddd");

// ------------------------------------------------------- // ??
/* ff6e */        _`_ff6e`;  LDA.imm (0x81);               // enable timer A interrupt
/* ff70 */                   STA.abs ("ciaicr_dc0d");      // save VIA 1 ICR
/* ff73 */                   LDA.abs ("ciacra_dc0e");      // read VIA 1 CRA
/* ff76 */                   AND.imm (0x80);               // mask x000 0000, TOD clock
/* ff78 */                   ORA.imm (0x11);               // mask xxx1 xxx1, load timer A, start timer A
/* ff7a */                   STA.abs ("ciacra_dc0e");      // save VIA 1 CRA
/* ff7d */                   JMP.abs ("_ee8e");            // set the serial clock out low and return

// ------------------------------------------------------- // unused
/* ff80 */                   _.bytes(0x03);

// ------------------------------------------------------- // initialise VIC and screen editor
/* ff81 */    _`cint_ff81`;  JMP.abs ("cint_ff5b");        // initialise VIC and screen editor

// ------------------------------------------------------- // initialise SID, CIA and IRQ, unused
/* ff84 */  _`ioinit_ff84`;  JMP.abs ("ioinit_fda3");      // initialise SID, CIA and IRQ

// ------------------------------------------------------- // RAM test and find RAM end
/* ff87 */  _`ramtas_ff87`;  JMP.abs ("ramtas_fd50");      // RAM test and find RAM end

// ------------------------------------------------------- // restore default I/O vectors
                                                           // this routine restores the default values of all system vectors used in KERNAL and
                                                           // BASIC routines and interrupts.
/* ff8a */  _`restor_ff8a`;  JMP.abs ("restor_fd15");      // restore default I/O vectors

// ------------------------------------------------------- // read/set vectored I/O
                                                           // this routine manages all system vector jump addresses stored in RAM. Calling this
                                                           // routine with the carry bit set will store the current contents of the RAM vectors
                                                           // in a list pointed to by the X and Y registers. When this routine is called with
                                                           // the carry bit clear, the user list pointed to by the X and Y registers is copied
                                                           // to the system RAM vectors.
                                                           // NOTE: This routine requires caution in its use. The best way to use it is to first
                                                           // read the entire vector contents into the user area, alter the desired vectors and
                                                           // then copy the contents back to the system vectors.
/* ff8d */  _`vector_ff8d`;  JMP.abs ("vector_fd1a");      // read/set vectored I/O

// ------------------------------------------------------- // control kernal messages
                                                           // this routine controls the printing of error and control messages by the KERNAL.
                                                           // Either print error messages or print control messages can be selected by setting
                                                           // the accumulator when the routine is called.
                                                           // FILE NOT FOUND is an example of an error message. PRESS PLAY ON CASSETTE is an
                                                           // example of a control message.
                                                           // bits 6 and 7 of this value determine where the message will come from. If bit 7
                                                           // is set one of the error messages from the KERNAL will be printed. If bit 6 is set
                                                           // a control message will be printed.
/* ff90 */  _`setmsg_ff90`;  JMP.abs ("setmsg_fe18");      // control kernal messages

// ------------------------------------------------------- // send secondary address after LISTEN
                                                           // this routine is used to send a secondary address to an I/O device after a call to
                                                           // the LISTEN routine is made and the device commanded to LISTEN. The routine cannot
                                                           // be used to send a secondary address after a call to the TALK routine.
                                                           // A secondary address is usually used to give set-up information to a device before
                                                           // I/O operations begin.
                                                           // When a secondary address is to be sent to a device on the serial bus the address
                                                           // must first be ORed with $60.
/* ff93 */  _`second_ff93`;  JMP.abs ("second_edb9");      // send secondary address after LISTEN

// ------------------------------------------------------- // send secondary address after TALK
                                                           // this routine transmits a secondary address on the serial bus for a TALK device.
                                                           // This routine must be called with a number between 4 and 31 in the accumulator.
                                                           // The routine will send this number as a secondary address command over the serial
                                                           // bus. This routine can only be called after a call to the TALK routine. It will
                                                           // not work after a LISTEN.
/* ff96 */    _`tksa_ff96`;  JMP.abs ("tksa_edc7");        // send secondary address after TALK

// ------------------------------------------------------- // read/set the top of memory
                                                           // this routine is used to read and set the top of RAM. When this routine is called
                                                           // with the carry bit set the pointer to the top of RAM will be loaded into XY. When
                                                           // this routine is called with the carry bit clear XY will be saved as the top of
                                                           // memory pointer changing the top of memory.
/* ff99 */  _`memtop_ff99`;  JMP.abs ("memtop_fe25");      // read/set the top of memory

// ------------------------------------------------------- // read/set the bottom of memory
                                                           // this routine is used to read and set the bottom of RAM. When this routine is
                                                           // called with the carry bit set the pointer to the bottom of RAM will be loaded
                                                           // into XY. When this routine is called with the carry bit clear XY will be saved as
                                                           // the bottom of memory pointer changing the bottom of memory.
/* ff9c */  _`membot_ff9c`;  JMP.abs ("membot_fe34");      // read/set the bottom of memory

// ------------------------------------------------------- // scan the keyboard
                                                           // this routine will scan the keyboard and check for pressed keys. It is the same
                                                           // routine called by the interrupt handler. If a key is down, its ASCII value is
                                                           // placed in the keyboard queue.
/* ff9f */  _`scnkey_ff9f`;  JMP.abs ("scnkey_ea87");      // scan keyboard

// ------------------------------------------------------- // set timeout on serial bus
                                                           // this routine sets the timeout flag for the serial bus. When the timeout flag is
                                                           // set, the computer will wait for a device on the serial port for 64 milliseconds.
                                                           // If the device does not respond to the computer's DAV signal within that time the
                                                           // computer will recognize an error condition and leave the handshake sequence. When
                                                           // this routine is called and the accumulator contains a 0 in bit 7, timeouts are
                                                           // enabled. A 1 in bit 7 will disable the timeouts.
                                                           // NOTE: The the timeout feature is used to communicate that a disk file is not found
                                                           // on an attempt to OPEN a file.
/* ffa2 */  _`settmo_ffa2`;  JMP.abs ("settmo_fe21");      // set timeout on serial bus

// ------------------------------------------------------- // input byte from serial bus

                                                           // this routine reads a byte of data from the serial bus using full handshaking. the
                                                           // data is returned in the accumulator. before using this routine the TALK routine,
                                                           // $FFB4, must have been called first to command the device on the serial bus to
                                                           // send data on the bus. if the input device needs a secondary command it must be sent
                                                           // by using the TKSA routine, $FF96, before calling this routine.

                                                           // errors are returned in the status word which can be read by calling the READST
                                                           // routine, $FFB7.
/* ffa5 */   _`acptr_ffa5`;  JMP.abs ("acptr_ee13");       // input byte from serial bus

// ------------------------------------------------------- // output a byte to serial bus
                                                           // this routine is used to send information to devices on the serial bus. A call to
                                                           // this routine will put a data byte onto the serial bus using full handshaking.
                                                           // Before this routine is called the LISTEN routine, $FFB1, must be used to
                                                           // command a device on the serial bus to get ready to receive data.
                                                           // the accumulator is loaded with a byte to output as data on the serial bus. A
                                                           // device must be listening or the status word will return a timeout. This routine
                                                           // always buffers one character. So when a call to the UNLISTEN routine, $FFAE,
                                                           // is made to end the data transmission, the buffered character is sent with EOI
                                                           // set. Then the UNLISTEN command is sent to the device.
/* ffa8 */   _`ciout_ffa8`;  JMP.abs ("ciout_eddd");       // output byte to serial bus

// ------------------------------------------------------- // command serial bus to UNTALK
                                                           // this routine will transmit an UNTALK command on the serial bus. All devices
                                                           // previously set to TALK will stop sending data when this command is received.
/* ffab */   _`untlk_ffab`;  JMP.abs ("untlk_edef");       // command serial bus to UNTALK

// ------------------------------------------------------- // command serial bus to UNLISTEN
                                                           // this routine commands all devices on the serial bus to stop receiving data from
                                                           // the computer. Calling this routine results in an UNLISTEN command being transmitted
                                                           // on the serial bus. Only devices previously commanded to listen will be affected.
                                                           // This routine is normally used after the computer is finished sending data to
                                                           // external devices. Sending the UNLISTEN will command the listening devices to get
                                                           // off the serial bus so it can be used for other purposes.
/* ffae */   _`unlsn_ffae`;  JMP.abs ("unlsn_edfe");       // command serial bus to UNLISTEN

// ------------------------------------------------------- // command devices on the serial bus to LISTEN
                                                           // this routine will command a device on the serial bus to receive data. The
                                                           // accumulator must be loaded with a device number between 4 and 31 before calling
                                                           // this routine. LISTEN convert this to a listen address then transmit this data as
                                                           // a command on the serial bus. The specified device will then go into listen mode
                                                           // and be ready to accept information.
/* ffb1 */  _`listen_ffb1`;  JMP.abs ("listen_ed0c");      // command devices on the serial bus to LISTEN

// ------------------------------------------------------- // command serial bus device to TALK
                                                           // to use this routine the accumulator must first be loaded with a device number
                                                           // between 4 and 30. When called this routine converts this device number to a talk
                                                           // address. Then this data is transmitted as a command on the Serial bus.
/* ffb4 */    _`talk_ffb4`;  JMP.abs ("talk_ed09");        // command serial bus device to TALK

// ------------------------------------------------------- // read I/O status word
                                                           // this routine returns the current status of the I/O device in the accumulator. The
                                                           // routine is usually called after new communication to an I/O device. The routine
                                                           // will give information about device status, or errors that have occurred during the
                                                           // I/O operation.
/* ffb7 */  _`readst_ffb7`;  JMP.abs ("readst_fe07");      // read I/O status word

// ------------------------------------------------------- // set logical, first and second addresses
                                                           // this routine will set the logical file number, device address, and secondary
                                                           // address, command number, for other KERNAL routines.
                                                           // the logical file number is used by the system as a key to the file table created
                                                           // by the OPEN file routine. Device addresses can range from 0 to 30. The following
                                                           // codes are used by the computer to stand for the following CBM devices:
                                                           // ADDRESS DEVICE
                                                           // ======= ======
                                                           //  0      Keyboard
                                                           //  1      Cassette #1
                                                           //  2      RS-232C device
                                                           //  3      CRT display
                                                           //  4      Serial bus printer
                                                           //  8      CBM Serial bus disk drive
                                                           // device numbers of four or greater automatically refer to devices on the serial
                                                           // bus.
                                                           // a command to the device is sent as a secondary address on the serial bus after
                                                           // the device number is sent during the serial attention handshaking sequence. If
                                                           // no secondary address is to be sent Y should be set to $FF.
/* ffba */  _`setlfs_ffba`;  JMP.abs ("setlfs_fe00");      // set logical, first and second addresses

// ------------------------------------------------------- // set the filename
                                                           // this routine is used to set up the file name for the OPEN, SAVE, or LOAD routines.
                                                           // The accumulator must be loaded with the length of the file and XY with the pointer
                                                           // to file name, X being th low byte. The address can be any valid memory address in
                                                           // the system where a string of characters for the file name is stored. If no file
                                                           // name desired the accumulator must be set to 0, representing a zero file length,
                                                           // in that case  XY may be set to any memory address.
/* ffbd */  _`setnam_ffbd`;  JMP.abs ("setnam_fdf9");      // set the filename

// ------------------------------------------------------- // open a logical file
                                                           // this routine is used to open a logical file. Once the logical file is set up it
                                                           // can be used for input/output operations. Most of the I/O KERNAL routines call on
                                                           // this routine to create the logical files to operate on. No arguments need to be
                                                           // set up to use this routine, but both the SETLFS, $FFBA, and SETNAM, $FFBD,
                                                           // KERNAL routines must be called before using this routine.
/* ffc0 */    _`open_ffc0`;  JMP.ind ("iopen+0_031a");     // do open a logical file

// ------------------------------------------------------- // close a specified logical file
                                                           // this routine is used to close a logical file after all I/O operations have been
                                                           // completed on that file. This routine is called after the accumulator is loaded
                                                           // with the logical file number to be closed, the same number used when the file was
                                                           // opened using the OPEN routine.
/* ffc3 */   _`close_ffc3`;  JMP.ind ("iclose+0_031c");    // do close a specified logical file

// ------------------------------------------------------- // open channel for input
                                                           // any logical file that has already been opened by the OPEN routine, $FFC0, can be
                                                           // defined as an input channel by this routine. the device on the channel must be an
                                                           // input device or an error will occur and the routine will abort.

                                                           // if you are getting data from anywhere other than the keyboard, this routine must be
                                                           // called before using either the CHRIN routine, $FFCF, or the GETIN routine,
                                                           // $FFE4. if you are getting data from the keyboard and no other input channels are
                                                           // open then the calls to this routine and to the OPEN routine, $FFC0, are not needed.

                                                           // when used with a device on the serial bus this routine will automatically send the
                                                           // listen address specified by the OPEN routine, $FFC0, and any secondary address.

                                                           // possible errors are:

                                                           // 3 : file not open
                                                           // 5 : device not present
                                                           // 6 : file is not an input file
/* ffc6 */   _`chkin_ffc6`;  JMP.ind ("ichkin+0_031e");    // do open channel for input

// ------------------------------------------------------- // open channel for output
                                                           // any logical file that has already been opened by the OPEN routine, $FFC0, can be
                                                           // defined as an output channel by this routine the device on the channel must be an
                                                           // output device or an error will occur and the routine will abort.

                                                           // if you are sending data to anywhere other than the screen this routine must be
                                                           // called before using the CHROUT routine, $FFD2. if you are sending data to the
                                                           // screen and no other output channels are open then the calls to this routine and to
                                                           // the OPEN routine, $FFC0, are not needed.

                                                           // when used with a device on the serial bus this routine will automatically send the
                                                           // listen address specified by the OPEN routine, $FFC0, and any secondary address.

                                                           // possible errors are:

                                                           // 3 : file not open
                                                           // 5 : device not present
                                                           // 7 : file is not an output file
/* ffc9 */  _`chkout_ffc9`;  JMP.ind ("ickout+0_0320");    // do open channel for output

// ------------------------------------------------------- // close input and output channels
                                                           // this routine is called to clear all open channels and restore the I/O channels to
                                                           // their original default values. It is usually called after opening other I/O
                                                           // channels and using them for input/output operations. The default input device is
                                                           // 0, the keyboard. The default output device is 3, the screen.
                                                           // If one of the channels to be closed is to the serial port, an UNTALK signal is sent
                                                           // first to clear the input channel or an UNLISTEN is sent to clear the output channel.
                                                           // By not calling this routine and leaving listener(s) active on the serial bus,
                                                           // several devices can receive the same data from the VIC at the same time. One way to
                                                           // take advantage of this would be to command the printer to TALK and the disk to
                                                           // LISTEN. This would allow direct printing of a disk file.
/* ffcc */  _`clrchn_ffcc`;  JMP.ind ("iclrch+0_0322");    // do close input and output channels

// ------------------------------------------------------- // input character from channel
                                                           // this routine will get a byte of data from the channel already set up as the input
                                                           // channel by the CHKIN routine, $FFC6.

                                                           // If CHKIN, $FFC6, has not been used to define another input channel the data is
                                                           // expected to be from the keyboard. the data byte is returned in the accumulator. the
                                                           // channel remains open after the call.

                                                           // input from the keyboard is handled in a special way. first, the cursor is turned on
                                                           // and it will blink until a carriage return is typed on the keyboard. all characters
                                                           // on the logical line, up to 80 characters, will be stored in the BASIC input buffer.
                                                           // then the characters can be returned one at a time by calling this routine once for
                                                           // each character. when the carriage return is returned the entire line has been
                                                           // processed. the next time this routine is called the whole process begins again.
/* ffcf */   _`chrin_ffcf`;  JMP.ind ("ibasin+0_0324");    // do input character from channel

// ------------------------------------------------------- // output character to channel
                                                           // this routine will output a character to an already opened channel. Use the OPEN
                                                           // routine, $FFC0, and the CHKOUT routine, $FFC9, to set up the output channel
                                                           // before calling this routine. If these calls are omitted, data will be sent to the
                                                           // default output device, device 3, the screen. The data byte to be output is loaded
                                                           // into the accumulator, and this routine is called. The data is then sent to the
                                                           // specified output device. The channel is left open after the call.
                                                           // NOTE: Care must be taken when using routine to send data to a serial device since
                                                           // data will be sent to all open output channels on the bus. Unless this is desired,
                                                           // all open output channels on the serial bus other than the actually intended
                                                           // destination channel must be closed by a call to the KERNAL close channel routine.
/* ffd2 */  _`chrout_ffd2`;  JMP.ind ("ibsout+0_0326");    // do output character to channel

// ------------------------------------------------------- // load RAM from a device
                                                           // this routine will load data bytes from any input device directly into the memory
                                                           // of the computer. It can also be used for a verify operation comparing data from a
                                                           // device with the data already in memory, leaving the data stored in RAM unchanged.
                                                           // The accumulator must be set to 0 for a load operation or 1 for a verify. If the
                                                           // input device was OPENed with a secondary address of 0 the header information from
                                                           // device will be ignored. In this case XY must contain the starting address for the
                                                           // load. If the device was addressed with a secondary address of 1 or 2 the data will
                                                           // load into memory starting at the location specified by the header. This routine
                                                           // returns the address of the highest RAM location which was loaded.
                                                           // Before this routine can be called, the SETLFS, $FFBA, and SETNAM, $FFBD,
                                                           // routines must be called.
/* ffd5 */    _`load_ffd5`;  JMP.abs ("load_f49e");        // load RAM from a device

// ------------------------------------------------------- // save RAM to a device
                                                           // this routine saves a section of memory. Memory is saved from an indirect address
                                                           // on page 0 specified by A, to the address stored in XY, to a logical file. The
                                                           // SETLFS, $FFBA, and SETNAM, $FFBD, routines must be used before calling this
                                                           // routine. However, a file name is not required to SAVE to device 1, the cassette.
                                                           // Any attempt to save to other devices without using a file name results in an error.
                                                           // NOTE: device 0, the keyboard, and device 3, the screen, cannot be SAVEd to. If
                                                           // the attempt is made, an error will occur, and the SAVE stopped.
/* ffd8 */    _`save_ffd8`;  JMP.abs ("save_f5dd");        // save RAM to device

// ------------------------------------------------------- // set the real time clock
                                                           // the system clock is maintained by an interrupt routine that updates the clock
                                                           // every 1/60th of a second. The clock is three bytes long which gives the capability
                                                           // to count from zero up to 5,184,000 jiffies - 24 hours plus one jiffy. At that point
                                                           // the clock resets to zero. Before calling this routine to set the clock the new time,
                                                           // in jiffies, should be in YXA, the accumulator containing the most significant byte.
/* ffdb */  _`settim_ffdb`;  JMP.abs ("settim_f6e4");      // set real time clock

// ------------------------------------------------------- // read the real time clock
                                                           // this routine returns the time, in jiffies, in AXY. The accumulator contains the
                                                           // most significant byte.
/* ffde */   _`rdtim_ffde`;  JMP.abs ("rdtim_f6dd");       // read real time clock

// ------------------------------------------------------- // scan the stop key
                                                           // if the STOP key on the keyboard is pressed when this routine is called the Z flag
                                                           // will be set. All other flags remain unchanged. If the STOP key is not pressed then
                                                           // the accumulator will contain a byte representing the last row of the keyboard scan.
                                                           // The user can also check for certain other keys this way.
/* ffe1 */    _`stop_ffe1`;  JMP.ind ("istop+0_0328");     // do scan stop key

// ------------------------------------------------------- // get character from input device
                                                           // in practice this routine operates identically to the CHRIN routine, $FFCF,
                                                           // for all devices except for the keyboard. If the keyboard is the current input
                                                           // device this routine will get one character from the keyboard buffer. It depends
                                                           // on the IRQ routine to read the keyboard and put characters into the buffer.
                                                           // If the keyboard buffer is empty the value returned in the accumulator will be zero.
/* ffe4 */   _`getin_ffe4`;  JMP.ind ("igetin+0_032a");    // do get character from input device

// ------------------------------------------------------- // close all channels and files
                                                           // this routine closes all open files. When this routine is called, the pointers into
                                                           // the open file table are reset, closing all files. Also the routine automatically
                                                           // resets the I/O channels.
/* ffe7 */   _`clall_ffe7`;  JMP.ind ("iclall+0_032c");    // do close all channels and files

// ------------------------------------------------------- // increment real time clock
                                                           // this routine updates the system clock. Normally this routine is called by the
                                                           // normal KERNAL interrupt routine every 1/60th of a second. If the user program
                                                           // processes its own interrupts this routine must be called to update the time. Also,
                                                           // the STOP key routine must be called if the stop key is to remain functional.
/* ffea */   _`udtim_ffea`;  JMP.abs ("udtim_f69b");       // increment real time clock

// ------------------------------------------------------- // return X,Y organization of screen
                                                           // this routine returns the x,y organisation of the screen in X,Y
/* ffed */  _`screen_ffed`;  JMP.abs ("screen_e505");      // return X,Y organization of screen

// ------------------------------------------------------- // read/set X,Y cursor position
                                                           // this routine, when called with the carry flag set, loads the current position of
                                                           // the cursor on the screen into the X and Y registers. X is the column number of
                                                           // the cursor location and Y is the row number of the cursor. A call with the carry
                                                           // bit clear moves the cursor to the position determined by the X and Y registers.
/* fff0 */    _`plot_fff0`;  JMP.abs ("plot_e50a");        // read/set X,Y cursor position

// ------------------------------------------------------- // return the base address of the I/O devices
                                                           // this routine will set XY to the address of the memory section where the memory
                                                           // mapped I/O devices are located. This address can then be used with an offset to
                                                           // access the memory mapped I/O devices in the computer.
/* fff3 */  _`iobase_fff3`;  JMP.abs ("iobase_e500");      // return the base address of the I/O devices

// ------------------------------------------------------- //
                                                           // RRBY
/* fff6 */                   _.bytes(0x52, 0x52, 0x42, 0x59);

// ------------------------------------------------------- // hardware vectors
/* fffa */                   _.bytes(0x43, 0xfe);          // NMI Vektor
/* fffc */                   _.bytes(0xe2, 0xfc);          // RESET Vektor
/* fffe */                   _.bytes(0x48, 0xff);          // IRQ Vektor
  }
));


/***/ }),

/***/ "./src/target/rom/skipRamTest.js":
/*!***************************************!*\
  !*** ./src/target/rom/skipRamTest.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tools_assembler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/assembler */ "./src/tools/assembler.js");
/* harmony import */ var _kernal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./kernal */ "./src/target/rom/kernal.js");
/*
   skipRamTest - exports a patched Kernal that skips the RAM test on boot, just
   to speed up the dev builds.
*/




const KERNAL_START = 0xe000;
const PATCH_START  = 0xfd67;

const patch = (0,_tools_assembler__WEBPACK_IMPORTED_MODULE_0__.assemble)(
  PATCH_START,
  ({ LDA, STA, JMP, _ }) => {

    _.label(0xa000, "memtop");

    LDA.imm (_.l`memtop`);
    STA.abs (0x283);        // store memory top low byte
    LDA.imm (_.h`memtop`);
    STA.abs (0x284);        // store memory top low byte
    JMP.abs (0xfd90);       // first instruction after RAM test
  }
);

const patchedKernal = [..._kernal__WEBPACK_IMPORTED_MODULE_1__["default"]];

for (let i = 0; i < patch.length; i++) {
  patchedKernal[i + PATCH_START - KERNAL_START] = patch[i];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (patchedKernal);


/***/ }),

/***/ "./src/target/runloop.js":
/*!*******************************!*\
  !*** ./src/target/runloop.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   attach: () => (/* binding */ attach)
/* harmony export */ });
/* harmony import */ var _tools_romLocations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/romLocations */ "./src/tools/romLocations.js");
/*
   runloop: performs operations like tick, serialize and deserialize on the
   target system as a whole, and runs the simulation in a time-throttled loop,
   with an optional hook for breakpoints
*/



// Node.js doesn't have `performance` loaded by default. Not that we make use
// of it in that version, but the runloop expects it to be there.
if (!globalThis.performance) {
  globalThis.performance = { now: () => 0 };
}

// How many frames to run for a single frames-per-second sample
const FRAMES_PER_WAYPOINT = 50;

// Bound by attach
let c64;

// configure by setDevices
let wires;
let cpu;
let vic;
let cias;
let sid;
let tape;

let state;
let masterStop = false;
let frameStop  = false;

function attach(nascentC64) {
  c64 = nascentC64;

  wires = c64.wires;
  cpu   = c64.cpu;
  vic   = c64.vic;
  cias  = c64.cias;
  sid   = c64.sid;
  tape  = c64.tape;

  reset();

  c64.runloop = {
    // Control
    run,
    stop,
    stopAfterFrame,
    isRunning,
    type,
    untilPc,
    reset,
    serialize,
    deserialize,
    // Debug
    getState,
  };
}

function reset() {
  state = {
    cycle: 0,
  };
  
  c64.wires.reset();
  c64.ram  .reset();
  c64.vic  .reset();
  c64.sid  .reset(); 
  c64.cpu  .reset();
  c64.cias .reset();
  c64.tape .reset();

  if (c64.hooks.setTitle) {
    c64.hooks.setTitle("");
  }
}

function getState() {
  return state;
}

function stop() {
  masterStop = true;
}

function stopAfterFrame() {
  frameStop = true;
}

function isRunning() {
  return !masterStop;
}

let timer;

function run(profile) {

  // Apply default run profile
  profile = {
    tick: () => false,
    fps: 50,
    ...profile,
  }

  let resolveBreakPromise;
  const breakPromise = new Promise(resolve => { resolveBreakPromise = resolve; });

  if (timer !== undefined) {
    masterStop = true;
    clearInterval(timer);
  }

  masterStop = false;
  frameStop  = false;

  const cleanUpOnBreak = () => {
    clearInterval(timer);
    if (c64.hooks.didStop) c64.hooks.didStop();
    timer = undefined;
    resolveBreakPromise();
  };

  let timeAtWaypoint = performance.now();
  let framesSinceWaypoint = 0;

  timer = setInterval(
    () => {
      try {
        // We'll loop for one video frame at a time. That is,
        // 312 rows of 63 cycles per row
        // (Which would be different if we support NTSC in future)
        for (let i = 0; i < (63 * 312); i++) {
          state.cycle++;

          cpu .tick();
          vic .tick();
          cias.tick();
          sid .tick();
          tape.tick();

          if (masterStop || profile.tick()) {
            cleanUpOnBreak();
            break;
          }
        }

        // Frames-per-second counter
        if (++framesSinceWaypoint === FRAMES_PER_WAYPOINT) {
          const now = performance.now();

          if (c64.hooks.updateFps) {
            c64.hooks.updateFps(
              Math.round((1000 * FRAMES_PER_WAYPOINT) / (now - timeAtWaypoint))
            );
          }

          timeAtWaypoint = now;
          framesSinceWaypoint = 0;
        }

        // Frame stop
        if (frameStop) cleanUpOnBreak();
      }
      catch (e) {
        console.error("Caught exception:", e);
        cleanUpOnBreak();
      }
    },
    1000 / profile.fps
  );

  if (c64.hooks.didStart) c64.hooks.didStart();

  return breakPromise;
}

async function untilPc(pc, fast = false) {

  const regs = c64.cpu.getState();

  if (pc === undefined) {
    // TODO: throw instead?
    console.error("Missing argument: PC address");
    return;
  }

  // If the PC was currently at the address we were waiting for,
  // advance past it. You want to be able to call this function
  // multple times to re-run.
  await run({
    tick: () => regs.pc !== pc,
  });

  const profile = {
    tick: () => regs.pc === pc,
  };

  if (fast) profile.fps = Infinity;

  return run(profile);
}

function type(str) {
  let bufLen = c64.wires.cpuRead(_tools_romLocations__WEBPACK_IMPORTED_MODULE_0__.KEYBOARD_BUFFER_INDEX);

  for (let char of str) {

    if (bufLen >= _tools_romLocations__WEBPACK_IMPORTED_MODULE_0__.KEYBOARD_BUFFER_LENGTH) {
      throw new Error("Overflow for Kernal keyboard buffer");
    }

    c64.wires.cpuWrite(_tools_romLocations__WEBPACK_IMPORTED_MODULE_0__.KEYBOARD_BUFFER_ADDR + bufLen, char.charCodeAt(0));
    c64.wires.cpuWrite(_tools_romLocations__WEBPACK_IMPORTED_MODULE_0__.KEYBOARD_BUFFER_INDEX, ++bufLen);
  }
}

function serialize() {
  return JSON.stringify(
    {
      version: {
        creator: "viciious",
        major: 0,
        minor: 1,
      },
      runloop: JSON.stringify(state),
      wires:   c64.wires.serialize(),
      ram:     c64.ram  .serialize(),
      vic:     c64.vic  .serialize(),
      sid:     c64.sid  .serialize(),
      cpu:     c64.cpu  .serialize(),
      cias:    c64.cias .serialize(),
      tape:    c64.tape .serialize(),
    }
  );
}

function deserialize(json) {
  const obj = JSON.parse(json);

  state = JSON.parse(obj.runloop);

  c64.wires.deserialize(obj.wires);
  c64.ram  .deserialize(obj.ram  );
  c64.vic  .deserialize(obj.vic  );
  c64.sid  .deserialize(obj.sid  );
  c64.cpu  .deserialize(obj.cpu  );
  c64.cias .deserialize(obj.cias );
  c64.tape .deserialize(obj.tape );
}


/***/ }),

/***/ "./src/target/sid.js":
/*!***************************!*\
  !*** ./src/target/sid.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   attach: () => (/* binding */ attach)
/* harmony export */ });
/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../debug */ "./src/debug.js");
/* harmony import */ var _sid_diag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sid_diag */ "./src/target/sid_diag.js");
/*
   sid: emulates the 6581 (SID) sound synthesizer

   This emulation is a pretty minimal implementation of the SID. It relies on a
   network of OscillatorNode nodes on the host side to actually do the sound
   synthesis. This is quirky for an emulator: it has the advantage that if the
   emulation is paused or slow, the sound will continue without stuttering a
   buffer loop; but it has manifest limitations.

   Essentially, this code is just emulating the ADSR envelope generator (and
   certainly has bugs in doing so), and hands everything else off to the host.

   As for those limitations:

   - no synchronization functionality (as in voice control registers bit 1)
   - voice 3 waveform output is noise only (which likely is its main purpose)
   - no timing accuracy within a frame. The core loop of the emulator runs a
     frame's worth of simulation in one go, then waits for a timeout to cue the
     next frame of simulation. As SID register writes are sent to the host as
     soon as they're encountered, this effectively means that sound commands
     are batched instead of staggered in real time. Since most sound commands
     are triggered from a 50 or 60Hz interrupt anyways, this isn't a big
     problem. But samples, on the other hand, will get badly distorted
     temporally. (Not that the host has a good way of playing them back, with
     the OscillatorNode network, even if timing could be guaranteed).
*/



// Just for diagnostics


// For pre-generating exponential attack/decay curves
const ASYMPTOTE = 1.1;

// 1000 CPU cycles (= 1ms) per ADSR consideration tick
const CYCLES_PER_ADSR_TICK = 100;

// So tick duration is about 1ms
const MS_PER_ADSR_TICK = (1 / 1e6) * CYCLES_PER_ADSR_TICK * 1000;

function getMultiplier(asymptote, steps) {
  // Returns the multiplier you'd need for an attack multiplier,
  // For an upside-down exponential signal that would approach `asymptote`,
  // and would reach 1.0 after `steps` steps.

  // That is, for y = (asymptote).(multiplier)^x,
  // this returns multiplier

  return (Math.E ** (Math.log((asymptote - 1) / asymptote) / steps));
}

const attackMultiplierForDuration = [
     2,
     8,
    16,
    24,
    38,
    56,
    68,
    80,
   100,
   240,
   500,
   800,
  1000,
  3000,
  5000,
  8000,
].map(
  ms => getMultiplier(ASYMPTOTE, ms / MS_PER_ADSR_TICK)
);

const decayMultiplierForDuration = [
      6,
     24,
     48,
     72,
    114,
    168,
    204,
    240,
    300,
    750,
   1500,
   2400,
   3000,
   9000,
  15000,
  24000,
].map(
  ms => getMultiplier(ASYMPTOTE, ms / MS_PER_ADSR_TICK)
);

let state;

// Bound by attach
let regWriteToHost = () => {};
let setVolumeToHost = () => {};

function toBridge(adsr) {
  // Sanity-checking assertions
  if (
    (adsr.voice !== 0) &&
    (adsr.voice !== 1) &&
    (adsr.voice !== 2)
  ) debugger;

  if (adsr.value !== adsr.value) debugger;

  setVolumeToHost(adsr.voice, adsr.value);
}


const initialAdsr = {
  phase: "off",
  value: 0,

  curveScale: 1,
  multiplier: 0,

  attackDuration: 0,
  decayDuration: 0,
  sustainVolume: 0,
  releaseDuration: 0,
};

function reset() {
  state = {
    regs: new Uint8Array(0x20),
    adsr: [
      { ...initialAdsr, voice: 0 },
      { ...initialAdsr, voice: 1 },
      { ...initialAdsr, voice: 2 },
    ],
    cyclesUntilAdsrTick: CYCLES_PER_ADSR_TICK,
  };

  // TODO: should we tell the bridge to reset things too, or should we
  // rely on the bridge getting its own reset?
}

function tick_adsr(adsr) {

  // NaN auditing
  if (adsr.value !== adsr.value) debugger;

  switch (adsr.phase) {

    case "off":
      // Do nothing
      // toBridge(adsr);     // JUST FOR ILLUSTRATION
      break;

    case "attack":
      {
        let value;

        // curve here I think is always offset 0 scale 1

        value = adsr.value;

        value = 1 - value;
        value += (ASYMPTOTE - 1);

        value *= adsr.multiplier;

        value -= (ASYMPTOTE - 1);
        value = 1 - value;

        value = Math.min(value, 1);

        if (value === 1) {
          adsr.phase = "decay";
          adsr.multiplier = decayMultiplierForDuration[adsr.decayDuration];
          adsr.curveOffset = adsr.sustainVolume;
          adsr.curveScale = 1 - adsr.sustainVolume;

          if (!adsr.curveScale) adsr.curveScale = 0.001; // TODO! To avoid a NaN, but...
        }

        adsr.value = value;
        toBridge(adsr);
      }

      break;

    case "decay":
      {
        let value;

        value = adsr.value;

        // curve is:
        //    offset = sustain volume)
        //    scale  = 1 - sustain volume

        value -= adsr.curveOffset;
        value /= adsr.curveScale;
        value += (ASYMPTOTE - 1);
        value *= adsr.multiplier;
        value -= (ASYMPTOTE - 1);
        value *= adsr.curveScale;
        value += adsr.curveOffset;

        value = Math.max(value, adsr.curveOffset);

        if (value === adsr.curveOffset) {
          adsr.phase = "sustain";
          // no parameters needed for that one
        }

        adsr.value = value;
        // console.log("value =", value);
        toBridge(adsr);
      }
      break;

    case "sustain":
      // do nothing
      // toBridge(adsr);     // JUST FOR ILLUSTRATION
      break;

    case "release":

      // curve is:
      //    offset = 0
      //    scale  = sustain volume

      {
        let value = adsr.value;

        value /= adsr.curveScale;
        value += (ASYMPTOTE - 1);
        value *= adsr.multiplier;
        value -= (ASYMPTOTE - 1);
        value *= adsr.curveScale;

        value = Math.max(value, 0);    // times voice value

        if (!value) {
          adsr.phase = "off";
        }

        adsr.value = value;

        toBridge(adsr);
      }
      break;
  }
}

function stop(adsr) {
  adsr.phase = "off";
  adsr.value = 0;
  toBridge(adsr);
}

function keyon(adsr) {
  adsr.phase = "attack";
  adsr.multiplier = attackMultiplierForDuration[adsr.attackDuration];

  tick_adsr(adsr);

  // Let's not set value. We could be pumping it.
  // toBridge(adsr);
}

function keyoff(adsr) {
  adsr.phase = "release";
  adsr.multiplier = decayMultiplierForDuration[adsr.releaseDuration];
  adsr.curveScale = adsr.sustainVolume;
  if (!adsr.curveScale) adsr.curveScale = 0.001; // TODO! To avoid a NaN, but...
}


function tick() {

  if (!state.cyclesUntilAdsrTick--) {
    state.cyclesUntilAdsrTick = CYCLES_PER_ADSR_TICK;
    tick_adsr(state.adsr[0]);
    tick_adsr(state.adsr[1]);
    tick_adsr(state.adsr[2]);

    // diag(c64, state);
  }
}

function read_d400_d7ff(addr) {
  const reg = addr & 0x1f;

  switch (reg) {

    case 0x19:
    case 0x1a:
      (0,_debug__WEBPACK_IMPORTED_MODULE_0__.unimplementedWarning)("paddles");
      return 0xff; // verified
      break;

    case 0x1b:
      (0,_debug__WEBPACK_IMPORTED_MODULE_0__.unimplementedWarning)("voice 3 waveform output");
      // We can't give them waveform data, because we don't have it. But
      // chances are they're using white noise as a random number generator
      // (eg. for the smoke-fades in Master of the Lamps' title screen). So
      // let's just give return random numbers...
      return (Math.random() * 256) & 0xff;
      
    case 0x1c:
      (0,_debug__WEBPACK_IMPORTED_MODULE_0__.unimplementedWarning)("voice 3 ADSR output");
      break;
  }

  // Verified on real hardware that you really do get zero here
  return 0x00;
}

function write_d400_d7ff(addr, byte) {
  
  const reg = addr & 0x1f;
  const voice = Math.floor(reg / 7);

  switch (reg) {

    case 0x04:      // $d404: Voice 1 control register
    case 0x0b:      // $d40b: Voice 2 control register
    case 0x12:      // $d412: Voice 3 control register
      {
        const adsr = state.adsr[voice];

        if (byte & 0x8) {
          stop(adsr);
        }
        else {
          if (byte & 0x1) keyon(adsr);
          else            keyoff(adsr);
        }
      }
      break;

    case 0x05:      // $d405: Voice 1 attack and decay length
    case 0x0c:      // $d40c: Voice 2 attack and decay length
    case 0x13:      // $d413: Voice 3 attack and decay length

      // Do we do these? Yes, we do these all the time.
      // if (state.adsr[voice].phase === "attack") debugger;
      // if (state.adsr[voice].phase === "decay") debugger;

      // Store as a code
      state.adsr[voice]. decayDuration = byte & 0xf;
      state.adsr[voice].attackDuration = byte >> 4;
      break;

    case 0x06:      // $d406: Voice 1 sustain volume and release length
    case 0x0d:      // $d40d: Voice 2 sustain volume and release length
    case 0x14:      // $d414: Voice 3 sustain volume and release length

      // Store as a code
      state.adsr[voice].releaseDuration = byte & 0xf;

      // Store as a ratio
      state.adsr[voice].sustainVolume = (byte >> 4) / 15;
      break;

    case 0x18:      // $d414: Master volume, filter modes, voice 3 disable
      break;

    case 0x1b:      // $d41b: Voice 3 waveform output
    case 0x1c:      // $d41b: Voice 3 ADSR output
      break;
  }

  state.regs[reg] = byte;
  regWriteToHost(reg, byte);
}

function serialize() {
  return JSON.stringify(state);
}

function deserialize(json) {
  state = JSON.parse(json);

  // This has not been carefully considered, but, dare I say it, seems to work.
  // The runloop's reset function doesn't currently reset all of the host
  // devices. Should it?
  for (let reg = 0; reg <= 0x18; reg++) {
    regWriteToHost(reg, state.regs[reg]);
  }

  toBridge(state.adsr[0]);
  toBridge(state.adsr[1]);
  toBridge(state.adsr[2]);
}

// hookups...

let c64;

function attach(nascentC64) {
  c64 = nascentC64;

  regWriteToHost  = c64.audio.onRegWrite;
  setVolumeToHost = c64.audio.setVoiceVolume;

  c64.sid = {
    // Control
    tick,
    reset,
    serialize,
    deserialize,
    // MMIO
    read_d400_d7ff,
    write_d400_d7ff,
  };

  reset();
}


/***/ }),

/***/ "./src/target/sid_diag.js":
/*!********************************!*\
  !*** ./src/target/sid_diag.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   diag: () => (/* binding */ diag)
/* harmony export */ });
/* harmony import */ var _tools_c64FontCodePoints__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/c64FontCodePoints */ "./src/tools/c64FontCodePoints.js");
/*
   For debugging only - prints, into C64 screen memory, diagnostic info about
   what the virtual SID is doing.
*/



const    LEFT_COLUMN = 7;
const ROWS_PER_VOICE = 7;

const    FREQ_ROW = 1;
const     PWM_ROW = 1;
const CONTROL_ROW = 2;
const    ADSR_ROW = 3;
const     BAR_ROW = 5;

const  FILTER_ROW = 21;
const  VOLUME_ROW = 22;

const seq = [
  0x20,         // space
  0x65,         // 2 left
  0x61,         // even
  0x67 | 0x80,  // 2 right, inverted
];

let getRunloopState;
let cpuWrite;
let state;

function writeChar(row, col, char) {
  const offset = (row * 40) + col;

  cpuWrite( 0x400 + offset, char);
  cpuWrite(0xd800 + offset, 1);
}

function writeX(row, col, nybble) {
  writeChar(row, col, _tools_c64FontCodePoints__WEBPACK_IMPORTED_MODULE_0__.hexDigitToC64FontCodePoint[nybble]);
}

function writeXx(row, col, byte) {
  writeChar(row, col + 0, _tools_c64FontCodePoints__WEBPACK_IMPORTED_MODULE_0__.hexDigitToC64FontCodePoint[byte >> 4]);
  writeChar(row, col + 1, _tools_c64FontCodePoints__WEBPACK_IMPORTED_MODULE_0__.hexDigitToC64FontCodePoint[byte & 0xf]);
}

function writeStr(row, col, str) {
  str = str.toUpperCase();

  for (let i = 0; i < str.length; i++) {
    writeChar(row, col + i, str.charCodeAt(i) - 0x40)
  }
}

function writeBit(row, col, char, condition) {
  writeChar(row, col, (0,_tools_c64FontCodePoints__WEBPACK_IMPORTED_MODULE_0__.charToC64FontCodePoint)(char) + (condition ? 0x80 : 0));
}

function showAdsrState(voice) {
  const row = ADSR_ROW + (voice * ROWS_PER_VOICE);
  const phase = state.adsr[voice].phase;

  writeBit(row, LEFT_COLUMN - 5 + 0, "a", phase === "attack" );
  writeBit(row, LEFT_COLUMN - 5 + 1, "d", phase === "decay"  );
  writeBit(row, LEFT_COLUMN - 5 + 2, "s", phase === "sustain");
  writeBit(row, LEFT_COLUMN - 5 + 3, "r", phase === "release");

  const ad = state.regs[(voice * 7) + 5];
  const sr = state.regs[(voice * 7) + 6];

  writeX(row, LEFT_COLUMN + 0, ad >> 4);
  writeX(row, LEFT_COLUMN + 1, ad & 0xf);

  writeX(row, LEFT_COLUMN + 2, sr >> 4);
  writeX(row, LEFT_COLUMN + 3, sr & 0xf);
}

function envelopeBar(voice) {
  const row = BAR_ROW + (voice * ROWS_PER_VOICE);
  const length = Math.floor(state.adsr[voice].value * 40);

  for (let i = 0; i < 40; i++) {
    writeChar(row, i, 0x20 + (i < length ? 0x80 : 0));
  }

  const subChar = (state.adsr[voice].value * 40) - length;

  if (subChar) {
    writeChar(row, length, seq[Math.floor(subChar * seq.length)]);
  }
}

function showFreq(voice) {
  const row = FREQ_ROW + (ROWS_PER_VOICE * voice);

  writeStr(row, LEFT_COLUMN - 5, "freq");
  writeXx (row, LEFT_COLUMN + 0, state.regs[(voice * 7) + 1]);
  writeXx (row, LEFT_COLUMN + 2, state.regs[(voice * 7) + 0]);
}

function showPwm(voice) {
  const row = PWM_ROW + (ROWS_PER_VOICE * voice);

  writeStr(row,20, "pwm");
  writeXx(row, 25, state.regs[(voice * 7) + 3]);
  writeXx(row, 27, state.regs[(voice * 7) + 2]);
}

function showControl(voice) {
  const row = CONTROL_ROW + (ROWS_PER_VOICE * voice);
  const byte = state.regs[(voice * 7) + 4];

  writeStr(row, LEFT_COLUMN - 5, "ctrl");

  writeBit(row, LEFT_COLUMN + 0,  "V", byte & 0x01);
  writeBit(row, LEFT_COLUMN + 2,  "S", byte & 0x02);
  writeBit(row, LEFT_COLUMN + 3,  "R", byte & 0x04);
  writeBit(row, LEFT_COLUMN + 5,  "D", byte & 0x08);
  writeBit(row, LEFT_COLUMN + 7,  "T", byte & 0x10);
  writeBit(row, LEFT_COLUMN + 8,  "S", byte & 0x20);
  writeBit(row, LEFT_COLUMN + 9,  "R", byte & 0x40);
  writeBit(row, LEFT_COLUMN + 10, "N", byte & 0x80);
}

function showFilter() {
  const row = FILTER_ROW;
  const d417 = state.regs[0x17];
  const d418 = state.regs[0x18];

  writeStr(row, LEFT_COLUMN - 5, "fltr");

  writeBit(row, LEFT_COLUMN + 0, "1", d417 & 0x01);
  writeBit(row, LEFT_COLUMN + 1, "2", d417 & 0x02);
  writeBit(row, LEFT_COLUMN + 2, "3", d417 & 0x04);
  writeBit(row, LEFT_COLUMN + 3, "E", d417 & 0x08);

  // Resonance
  writeX(row, LEFT_COLUMN + 5, d417 >> 4);

  writeBit(row, LEFT_COLUMN + 7,  "L", d418 & 0x10);
  writeBit(row, LEFT_COLUMN + 8,  "B", d418 & 0x20);
  writeBit(row, LEFT_COLUMN + 9,  "H", d418 & 0x40);
  writeBit(row, LEFT_COLUMN + 10, "3", d418 & 0x80);
}

function showVolume() {
  const row = VOLUME_ROW;
  const d418 = state.regs[0x18];

  writeStr(row, LEFT_COLUMN - 4, "vol");
  writeX  (row, LEFT_COLUMN + 0, d418 & 0xf);
}

function showCycle() {
  const cycleStr = String(getRunloopState().cycle);

  Array.from(cycleStr).forEach(
    (digit, index) => {
      writeChar(23, 39 - cycleStr.length + index, (0,_tools_c64FontCodePoints__WEBPACK_IMPORTED_MODULE_0__.charToC64FontCodePoint)(digit));
    }
  );
}

function diag(c64, sidState) {
  getRunloopState = c64.runloop.getState;
  cpuWrite        = c64.wires.cpuWrite;
  state           = sidState;

  // Clear the screen
  for (let i = 0; i < 1000; i++) {
    cpuWrite(0x400 + i, 0x20);
  }

  // Per-voice registers
  for (let voice = 0; voice < 3; voice++) {
    envelopeBar(voice);
    showAdsrState(voice);
    showFreq(voice);
    showPwm(voice);
    showControl(voice);
  }

  // SID-wide registers
  showFilter();
  showVolume();
  showCycle();
}


/***/ }),

/***/ "./src/target/tape.js":
/*!****************************!*\
  !*** ./src/target/tape.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   attach: () => (/* binding */ attach)
/* harmony export */ });
/*
   tape: emulates a 1530 'Datasette' cassette deck

   Basically just feeds .tap file format data into the CIA1. Does not support
   saving.

   References:

   - http://wav-prg.sourceforge.net/tape.html
   - http://unusedino.de/ec64/technical/formats/tap.html
*/


// Bound by attach
let raiseTapeInterrupt;
let c64; // but do we need it?

let state;

function setTapeMotor(isOn) {
  state.motorEnabled = isOn;
}

function scheduleNextInterrupt() {
  // We're using the .tap file format as-is to peel off the interrupt timings.
  // (Minus the header, which got stripped off by the ingestor)

  // TODO: bounds check for the image
  const val = state.image[state.imageOffset++];

  if (val === 0) {
    state.ticksUntilInterrupt  = state.image[state.imageOffset++];
    state.ticksUntilInterrupt |= state.image[state.imageOffset++] << 8;
    state.ticksUntilInterrupt |= state.image[state.imageOffset++] << 16;
  }

  else state.ticksUntilInterrupt = val * 8;
}

function tick() {
  if (state.playPressed && state.motorEnabled) {

    if (state.ticksUntilInterrupt) state.ticksUntilInterrupt--;
    else {
      raiseTapeInterrupt();
      scheduleNextInterrupt();
    }
  }
}


function attach(nascentC64) {
  c64 = nascentC64;
  raiseTapeInterrupt = c64.wires.raiseTapeInterrupt;

  reset();

  c64.tape = {
    // Control
    tick,
    reset,
    serialize,
    deserialize,
    // TODO: what did we call this section again?
    setTapeMotor,
    isAnyButtonPressed,

    setImage,
    pressPlay,
    pressStop,
  };
}

function reset() {
  state = {
    ticksUntilInterrupt: Infinity,
    image: null,
    imageOffset: 0,
    playPressed: false,
    motorEnabled: false,
  };
}

function serialize() {
  // TODO
  // (If this gets supported in future, expect the snapshot files to get huge)
}

function deserialize() {
  // TODO
}

function isAnyButtonPressed() {
  return state.playPressed;
}

function setImage(bytes) {
  state.image = bytes;
  state.imageOffset = 0;

  // Schedule an interrupt; it won't actually happen unless the play button's
  // pressed and the motor's enabled.
  scheduleNextInterrupt();
}

function pressPlay() {
  state.playPressed = true;
}

function pressStop() {
  state.playPressed = false;
}


/***/ }),

/***/ "./src/target/vic.js":
/*!***************************!*\
  !*** ./src/target/vic.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   attach: () => (/* binding */ attach)
/* harmony export */ });
/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../debug */ "./src/debug.js");
/* harmony import */ var _tools_palettes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tools/palettes */ "./src/tools/palettes.js");
/*
   vic: emulates the 6569 (VIC-II; PAL) graphics processor

   ...a big proof-of-concept that grew to encompass all of the chip's
   functionality, and really needs to be re-done. In particular, its timing
   is just placeholder, and it doesn't try stun the CPU for bad lines (the BA
   line) so raster-stable routines aren't going to work, to say nothing of
   tricks like DMA delay.

   (We're a little loose with terminology too)

   The Vic simulation takes by far the bulk of the emulation time, which we'd
   expect given how much work it does compared to the CPU. But still, it's ripe
   for optimization.

   References:

   †1 http://www.zimmers.net/cbmpics/cbm/c64/vic-ii.txt
   †2 sta64 memory map: https://sta.c64.org/cbm64mem.html
    - http://unusedino.de/ec64/technical/project64/mapping_c64.html 
*/




// Bound by attach
let c64;
let vicRead;
let setVicIrq;
let setPixel;
let blit;

let state = {};
const config = {
  ignoreSprSprCollisions: false,
  ignoreSprBgCollisions:  false,
  scopeSprites:           false,
  scopeBackground:        false,
  scopeCollision:         false,
  scopeColorRam:          false,
};

const specialStateValues = [
  ["charBuffer",       Uint8Array,  40    ],
  ["colorBuffer",      Uint8Array,  40    ],
  ["bgRgbQueue",       Uint32Array, 8     ],
  ["bgMaskQueue",      Uint8Array,  8     ],
  ["bgCollisionQueue", Uint8Array,  8     ],
  ["color",            Uint8Array,  0x400 ],
];

// Timing constants (PAL)

const     BORDER_OFF_LINE_25_ROWS = 51;
const     BORDER_OFF_LINE_24_ROWS = 55;
const      BORDER_ON_LINE_25_ROWS = 251;
const      BORDER_ON_LINE_24_ROWS = 247;

const            LAST_RASTER_LINE = 311;

// The first cycle within a line on which character pointer is read
const CHAR_FETCH_CYCLE = 16;

function attach(nascentC64) {
  c64 = nascentC64;

  vicRead   = c64.wires.vicRead;
  setVicIrq = c64.wires.setVicIrq;
  setPixel  = c64.video.setPixel;
  blit      = c64.video.blit;

  c64.vic = {
    // Control
    tick,
    reset,
    serialize,
    deserialize,
    // MMIO
    read_d000_d3ff,
    read_d800_dbff,
    write_d000_d3ff,
    write_d800_dbff,
    // Scopes
    setIgnoreSprBgCol,
    setIgnoreSprSprCol,
    setScope,
    // Gimmicks
    showStatic,
  };

  reset();
}

function reset() {

  const makeDefaultSprite = () => ({
    x:       0,         // $d000, $d002, $d004, ..., with $d010
    y:       0,         // $d001, $d003, $d005, ...
    x2h:     false,     // $d017
    x2w:     false,     // $d01d
    color:   0,         // $d027, $d028, $d029, ...
    mcm:     0,         // $d01c
    behind:  false,     // $d01b
    enabled: false,     // $d015

    // sequence for next scanline:

    colorQueue:     new Array(48),
    maskQueue:      new Array(48),
    collisionQueue: new Array(48),

    xStart: undefined,
    xEnd:   undefined,
  });

  state = {
    cyclesUntilRasterInc: 62,
    cycleOfLine: 0,
    lineOfRaster: 0,
    dflag: true,                // top/bottom border
    vflag: true,                // left/right border
    badline: 0,                 // just for dev

    raster: 0,                  // $d011-2 read
    rasterIrq: 0,               // $d011-2 write
    memorySetup: 0,             // $d018
    interruptStatus: 0,         // $d019, but not but 7 (derive that from irq)
    interruptControl: 0,        // $d01a
    irq: false,                 // derived from interruptStatus and interruptControl

    xscroll: 0,                 // $d016
    yscroll: 0,                 // $d011

    fortyColumns:   true,       // $d016
    twentyFiveRows: true,       // $d011
    displayEnable:  true,       // $d011

    // These are all 4-bit color codes:
    borderColor:            0,  // $d020
    backgroundColor:        0,  // $d021
    extraBgColor1:          0,  // $d022
    extraBgColor2:          0,  // $d023
    extraBgColor3:          0,  // $d024
    spriteMulticolorColor0: 0,  // $d025
    spriteMulticolorColor1: 0,  // $d026

    // Screen modes
    multicolor: false,          // $d016
    bitmap:     false,          // $d011
    extendedBg: false,          // $d011

    // Collisions
    sprSprCol: 0,               // $d01e
    sprBgCol:  0,               // $d01f

    charBuffer:  new Uint8Array(40),
    colorBuffer: new Uint8Array(40),

    // The 'sequencers' of the background pixels (char/bitmap)
    bgQueuePos:       0,
    bgRgbQueue:       new Uint32Array(8),
    bgMaskQueue:      new Uint8Array(8),
    bgCollisionQueue: new Uint8Array(8),

    nextCharCode: 0,
    nextBgByte:   0,
    nextFgCol:    0,

    // Color RAM
    color: new Uint8Array(0x400), // see $d800. Only one nybble per address

    sprites: [
      makeDefaultSprite(),
      makeDefaultSprite(),
      makeDefaultSprite(),
      makeDefaultSprite(),
      makeDefaultSprite(),
      makeDefaultSprite(),
      makeDefaultSprite(),
      makeDefaultSprite(),
    ],

    // Gimmicks
    static: false,
  };
}

function onNewLine() {

  // state.lineOfRaster has been updated

  const lineOfChar = (state.raster - state.yscroll) & 0x7;
  state.badline = lineOfChar === 7;

  if (state.twentyFiveRows) {
    if      (state.lineOfRaster === BORDER_OFF_LINE_25_ROWS) state.dflag = false;
    else if (state.lineOfRaster ===  BORDER_ON_LINE_25_ROWS) state.dflag = true;
  }
  else {
    if      (state.lineOfRaster === BORDER_OFF_LINE_24_ROWS) state.dflag = false;
    else if (state.lineOfRaster ===  BORDER_ON_LINE_24_ROWS) state.dflag = true;
  }

  if (state.lineOfRaster > LAST_RASTER_LINE) {
    state.lineOfRaster = 0;
    blit();
    if (c64.hooks.onFrameEnd) c64.hooks.onFrameEnd();
  }
}

function loadNextBgByte() {

  let indexOfCharBuffer = state.cycleOfLine - 17;

  if (state.bitmap) {

    let char = state.charBuffer[indexOfCharBuffer];

    // rows are 8 lines. We should formalize the terminology.
    const row = Math.floor((state.raster - state.yscroll + 3 - BORDER_OFF_LINE_25_ROWS) / 8);
    const lineOfChar = (state.raster - state.yscroll) & 0x7;

    const bitmapMemBase = ((state.memorySetup & 0b1000) >> 3) * 0x2000;

    let bmByte = vicRead(
      bitmapMemBase +
      (((row * 40) + indexOfCharBuffer) * 8) + lineOfChar
    );

    // nextFgCol only necessary in bitmap mode
    state.nextCharCode = char;
    state.nextBgByte   = bmByte;
    state.nextFgCol    = state.colorBuffer[indexOfCharBuffer] & 0xf;
    return;
  }

  else {

    let char = state.charBuffer[indexOfCharBuffer];
    const fgColor = state.colorBuffer[indexOfCharBuffer] & 0xf;

    // In extended background color mode, the most significant three bits of the
    // character code will determine the background color instead of the
    // character shape.
    let charShapeBase = (state.extendedBg ? (char & 0b00111111) : char) * 8;

    let charByte;
    const lineOfChar = (state.raster - state.yscroll) & 0x7;


    let charMemBase = ((state.memorySetup & 0b1110) >> 1) * 0x800;

    charByte = vicRead(charMemBase + (charShapeBase + lineOfChar));

    state.nextCharCode = char;
    state.nextBgByte   = charByte;
    state.nextFgCol    = state.colorBuffer[indexOfCharBuffer] & 0xf;
  }
}

function loadBgQueues() {

  let rgbPalette = (
    config.scopeSprites ||
    config.scopeCollision
  )
    ? _tools_palettes__WEBPACK_IMPORTED_MODULE_1__.grayscalePalette
    : _tools_palettes__WEBPACK_IMPORTED_MODULE_1__.systemPalette
  ;

  let charByte = state.nextBgByte;
  let fgColor = state.nextFgCol;

  if (config.scopeColorRam) {
    rgbPalette = _tools_palettes__WEBPACK_IMPORTED_MODULE_1__.colorColorPalettes[fgColor];
  }

  state.bgQueuePos = 0;

  // Illegal modes
  if (state.extendedBg && (state.multicolor || state.bitmap)) {

    if (config.scopeBackground) {
      rgbPalette = _tools_palettes__WEBPACK_IMPORTED_MODULE_1__.highlightPalettes[
        (state.multicolor ? 0b100 : 0) |
        (state.extendedBg ? 0b010 : 0) |
        (state.bitmap     ? 0b001 : 0)
      ];
    }

    state.bgRgbQueue      .fill(rgbPalette[0]);  // color code 0 being black
    state.bgMaskQueue     .fill(0);
    state.bgCollisionQueue.fill(0);
    return;
  }

  if (state.bitmap) {
    
    if (state.multicolor) {

      if (config.scopeBackground) rgbPalette = _tools_palettes__WEBPACK_IMPORTED_MODULE_1__.highlightPalettes[0b101];

      const palette = [
        state.backgroundColor,
        state.nextCharCode >> 4,
        state.nextCharCode & 0xf,
        fgColor & 0xf,
      ];

      let nextBgByte = state.nextBgByte;

      for (let x = 0; x < 4; x++) {

        const index     = (nextBgByte & 0b11000000) >> 6;
        const colorCode = palette[index];
        const rgbCode   = rgbPalette[colorCode];

        state.bgRgbQueue[(2 * x) + 0] = rgbCode;
        state.bgRgbQueue[(2 * x) + 1] = rgbCode;

        state.bgMaskQueue[(2 * x) + 0] = index > 0;
        state.bgMaskQueue[(2 * x) + 1] = index > 0;

        state.bgCollisionQueue[(2 * x) + 0] = index > 1;
        state.bgCollisionQueue[(2 * x) + 1] = index > 1;

        nextBgByte <<= 2;
      }
    }
    else {

      if (config.scopeBackground) rgbPalette = _tools_palettes__WEBPACK_IMPORTED_MODULE_1__.highlightPalettes[0b001];

      const col0 = state.nextCharCode & 0xf;
      const col1 = state.nextCharCode >> 4;

      const rgbCol0 = rgbPalette[col0];
      const rgbCol1 = rgbPalette[col1];

      let nextBgByte = state.nextBgByte;

      for (let x = 0; x < 8; x++) {

        state.bgRgbQueue[x] = (nextBgByte & 0b10000000) ? rgbCol1 : rgbCol0;
        state.bgMaskQueue[x] = state.bgCollisionQueue[x] = (nextBgByte & 0b10000000) ? 1 : 0;

        nextBgByte <<= 1;
      }
    }

    return;
  }

  if (state.extendedBg) {

    if (config.scopeBackground) rgbPalette = _tools_palettes__WEBPACK_IMPORTED_MODULE_1__.highlightPalettes[0b010];

    let bgColor;

    if      (state.nextCharCode < 64)  bgColor = state.backgroundColor;
    else if (state.nextCharCode < 128) bgColor = state.extraBgColor1;
    else if (state.nextCharCode < 192) bgColor = state.extraBgColor2;
    else                               bgColor = state.extraBgColor3;

    for (let x = 0; x < 8; x++) {

      const colorCode = (charByte & 0b10000000) ? fgColor : bgColor;
      state.bgRgbQueue[x] = rgbPalette[colorCode];

      // TODO: I'm presuming here. Check this.
      state.bgMaskQueue[x] = state.bgCollisionQueue[x] = (charByte & 0b10000000) ? 1 : 0;

      charByte <<= 1;
    }
  }

  else if (state.multicolor && (fgColor > 7)) {

    if (config.scopeBackground) rgbPalette = _tools_palettes__WEBPACK_IMPORTED_MODULE_1__.highlightPalettes[0b100];

    const palette = [
      state.backgroundColor,
      state.extraBgColor1,
      state.extraBgColor2,
      fgColor & 0x7,
    ];

    for (let x = 0; x < 4; x++) {

      let index = (charByte & 0b11000000) >> 6;

      const colorCode = palette[index];
      const rgbCode = rgbPalette[colorCode];

      state.bgRgbQueue[(2 * x) + 0] = rgbCode;
      state.bgRgbQueue[(2 * x) + 1] = rgbCode;

      state.bgMaskQueue[(2 * x) + 0] = index > 0;
      state.bgMaskQueue[(2 * x) + 1] = index > 0;

      state.bgCollisionQueue[(2 * x) + 0] = index > 1;
      state.bgCollisionQueue[(2 * x) + 1] = index > 1;

      charByte <<= 2;
    }
  }

  else {
    // Regular, no-color-tricks background mode

    if (config.scopeBackground) {
      // Since the multicolor mode with color code < 8 falls through to this case
      if (state.multicolor) rgbPalette = _tools_palettes__WEBPACK_IMPORTED_MODULE_1__.highlightPalettes[0b100];
      else rgbPalette = _tools_palettes__WEBPACK_IMPORTED_MODULE_1__.highlightPalettes[0b000];
    }

    for (let x = 0; x < 8; x++) {

      // I feel we should just paint them all as the foreground color, and make
      // the bgMaskQueue processor take it out.
      const colorCode = (charByte & 0b10000000) ? fgColor : state.backgroundColor;
      
      state.bgRgbQueue      [x] = rgbPalette[colorCode];
      state.bgMaskQueue     [x] = (charByte & 0b10000000);
      state.bgCollisionQueue[x] = (charByte & 0b10000000);

      charByte <<= 1;
    }
  }
}


function get8BackgroundPixels(xc, y, color, mask, collision) {
  
  const aboveTop = (
    ((state.raster - state.yscroll) >> 3) < 
    (BORDER_OFF_LINE_25_ROWS >> 3)
  );

  const belowBottom = (
    ((state.raster - state.yscroll) >> 3) > 
    (BORDER_ON_LINE_24_ROWS >> 3)
  );

  if (aboveTop || belowBottom) {

    // TODO: the real VIC serves char data from $3fff here
    for (let i = 0; i < 8; i++) {

      // TODO: We're mapping scope to palettes in too many different places.
      // This needs a more elegant solution.
      const rgbPalette = (
        config.scopeSprites    ||
        config.scopeBackground ||
        config.scopeCollision  ||
        config.scopeColorRam
      )
        ? _tools_palettes__WEBPACK_IMPORTED_MODULE_1__.grayscalePalette
        : _tools_palettes__WEBPACK_IMPORTED_MODULE_1__.systemPalette
      ;

      color[i]     = rgbPalette[state.backgroundColor];
      mask [i]     = false;
      collision[i] = false;
    }
  }
  else {
    const ret = [];

    for (let x = 0; x < 8; x++) {

      // This loads the dot queue for the next character needed, but
      // - TODO - we need to wipe it before the first one.
      if (x === state.xscroll) {
        loadBgQueues();
      }

      color    [x] =         state.bgRgbQueue      [state.bgQueuePos];
      mask     [x] = Boolean(state.bgMaskQueue     [state.bgQueuePos]);
      collision[x] = Boolean(state.bgCollisionQueue[state.bgQueuePos]);

      // Visualizing debug aid
      // color[x] = mask[x] ? 0xff0000 : 0x000000;

      if (config.scopeCollision) {
        // Sadly we've lost the original color code by this point
        if (collision[x]) color[x] = _tools_palettes__WEBPACK_IMPORTED_MODULE_1__.highlightPalettes[3][15];
      }

      state.bgQueuePos++;
    }
  }
}


function reconsiderVicIrq() {
  state.irq = Boolean(state.interruptStatus & state.interruptControl);
  setVicIrq(state.irq);
}


function sprSprCollision(a, b) {
  if (config.ignoreSprSprCollisions) return;

  // Sprite #a collided with sprite #b

  // TODO: questions:
  // 1) if sprite-to-sprite collision interrupts aren't requested, does this
  //    register still get updated? (assuming yes)
  // 2) once a collision has happened to raise an interrupt, do they continue
  //    to stack up as more sprites collide? (assuming yes).

  const emptyOnEntry = state.sprSprCol;

  state.sprSprCol = state.sprSprCol
    | (1 << a)
    | (1 << b)
  ;

  // More interrupts don't fire if the register hasn't been read
  if (!emptyOnEntry) return;

  // Set the and 'spr-spr collision' flag
  state.interruptStatus |= 0b100;

  reconsiderVicIrq();
}

function sprBgCollision(spriteNum) {
  if (config.ignoreSprBgCollisions) return;

  const emptyOnEntry = state.sprBgCol;

  state.sprBgCol |= 1 << spriteNum;

  // More interrupts don't fire if the register hasn't been read
  if (!emptyOnEntry) return;

  // Set the 'spr-bg collision' flag
  state.interruptStatus |= 0b10;

  reconsiderVicIrq();
}

// Kinda want a better name for this function. The point is the raster line has
// reached the number that triggers an IRQ, though if raster IRQ's aren't
// enabled, there'll be no IRQ.
function rasterMightIrq() {

  // So this is what I think I learned recently... that the bit gets written 
  // to $d019 regardless of whether the interrupts are enabled.

  state.interruptStatus |= 1;
  reconsiderVicIrq();
}

function get8Pixels(xc, y) {
  const defaultPalette = (
    (
      config.scopeSprites    ||
      config.scopeBackground ||
      config.scopeCollision  ||
      config.scopeColorRam
    )
    ? _tools_palettes__WEBPACK_IMPORTED_MODULE_1__.grayscalePalette
    : _tools_palettes__WEBPACK_IMPORTED_MODULE_1__.systemPalette
  );

  // Display off?
  if (!state.displayEnable) return new Array(8).fill(defaultPalette[state.borderColor]);

  // If we're on the top/bottom border, output the border color
  if (state.dflag) {
    return new Array(8).fill(defaultPalette[state.borderColor]);
  }

  // TODO: we should probably avoid reallocating these each time
  let color     = new Array(8);
  let mask      = new Array(8);
  let collision = new Array(8);

  // Some nasty magic numbers that haven't been thought through and are just a
  // band-aid optimization.
  if ((state.cycleOfLine >= 16) && (state.cycleOfLine <= 57)) {
    get8BackgroundPixels(xc, y, color, mask, collision);
  }

  // If we're on the left/right border, output the border color, now that we've
  // done the background pixel fetch at least.
  // (Had we not, the character tiles wouldn't have loaded correctly)
  if (state.vflag) {

    // oh this won't work. The right border gets brought in 9 pixels in 38-column mode.
    return new Array(8).fill(defaultPalette[state.borderColor]);
  }

  for (let pixel = 0; pixel < 8; pixel++) {

    // Just for the collision scope
    let isAnySprColPix = false;

    let x = (xc * 8) + pixel;

    let dominantSprite;   // Sprite number of dominant sprite
    let spriteCol;        // Color code for dominant sprite
    let collidedSprite;

    // Iterate backwards through the sprites, as sprite 0 gets drawn above all
    // the others.
    for (let spriteNum = 7; spriteNum >= 0; spriteNum--) {

      const sprObj = state.sprites[spriteNum];

      if (sprObj.xStart === undefined) continue;

      if ((x >= sprObj.xStart) && (x < sprObj.xEnd)) {

        const sx = x - sprObj.xStart;

        if (sprObj.maskQueue[sx]) {

          // Overwrite the previous, which, as a higher numbered sprite,
          // would have a lower priority
          spriteCol = sprObj.colorQueue[sx];
          dominantSprite = spriteNum;
        }

        // Might be expensive to do it this way
        if (sprObj.collisionQueue[sx]) {

          isAnySprColPix = true;

          // Look for sprite-background collisions
          if (collision[pixel]) sprBgCollision(spriteNum);

          // Look for sprite-sprite collisions
          if (collidedSprite !== undefined) {
            sprSprCollision(collidedSprite, spriteNum);
          }
          collidedSprite = spriteNum;
        }        
      }
    }

    // We've now gone through all the sprites to see which, if any, is on top.
    // If there was a sprite on top, and the priority of that sprite is above
    // the background, paint it.

    if (dominantSprite !== undefined) {
      if (!state.sprites[dominantSprite].behind || !mask[pixel]) {

        if (config.scopeSprites) {
          color[pixel] = _tools_palettes__WEBPACK_IMPORTED_MODULE_1__.highlightPalettes[dominantSprite][spriteCol];
        }
        else if (config.scopeCollision && isAnySprColPix) {
          color[pixel] = _tools_palettes__WEBPACK_IMPORTED_MODULE_1__.highlightPalettes[0][spriteCol];
        }
        else {
          color[pixel] = defaultPalette[spriteCol];
        }

      }
    }
  }

  return color;
}

function fetchNextRowOfCharMatrix() {
  // start pulling in the char buffer for the next line
  if (
    (state.cycleOfLine >= CHAR_FETCH_CYCLE) &&
    (state.cycleOfLine <= (CHAR_FETCH_CYCLE + 40))
  ) {

    // Set the pointer up with the x...
    let ptr = state.cycleOfLine - CHAR_FETCH_CYCLE;

    // add the y...
    ptr += ((state.raster >> 3) - 6) * 40;

    // Don't read memory out of bounds
    if ((ptr >= 0) && (ptr < 1000)) {

      // Which character of this row of text are we loading
      const bufferIndex = state.cycleOfLine - CHAR_FETCH_CYCLE;

      let screenBase = (state.memorySetup >> 4) * 0x400;

      state.charBuffer[bufferIndex] = vicRead(screenBase + ptr);
      state.colorBuffer[bufferIndex] = state.color[ptr];
    }
  }
}

function fetchSpriteSequencesForLine() {

  // What's not accurate about this is when it does the fetching

  const screenBase = (state.memorySetup >> 4) * 0x400;
  const sprPtrsAddr = screenBase + (1024 - 8);

  // Work through the sprites backwards, as 0 has priority
  for (let spriteNum = 7; spriteNum >= 0; spriteNum--) {

    const sprObj = state.sprites[spriteNum];

    sprObj.xStart = undefined;

    if (!sprObj.enabled) continue;

    const doubleWidth = sprObj.x2w;

    let x = sprObj.x;
    let y = sprObj.y;

    // to be at this raster, what would the sprite's y have needed to be?
    let lineOfSprite = state.lineOfRaster - y;

    if (sprObj.x2h) {
      lineOfSprite = Math.floor(lineOfSprite / 2);
    }

    if (lineOfSprite  < 0) continue;
    if (lineOfSprite >= 21) continue;

    const spritePtr = sprPtrsAddr + spriteNum;

    let spriteDataPtr = vicRead(spritePtr);
    
    spriteDataPtr *= 64;
    spriteDataPtr += (lineOfSprite * 3);

    const byte0 = vicRead(spriteDataPtr + 0);
    const byte1 = vicRead(spriteDataPtr + 1);
    const byte2 = vicRead(spriteDataPtr + 2);

    // No need to clear out the old structures; we'll just write over them
    let     spriteColorQueue = sprObj.    colorQueue;
    let      spriteMaskQueue = sprObj.     maskQueue;
    let spriteCollisionQueue = sprObj.collisionQueue;

    const spriteColor = sprObj.color;

    let sprite24bits = (byte0 << 16) | (byte1 << 8) | (byte2 << 0);

    if (sprObj.mcm) {

      const colorCodes = [
        0,                               // irrelevant; masked out
        state.spriteMulticolorColor0,
        spriteColor,
        state.spriteMulticolorColor1,
      ];

      let qPos = 0;

      for (let i = 0; i < 12; i++) {
        let index = (sprite24bits & (0b11 << 22)) >> 22;
        
        for (let j = 0; j < (doubleWidth ? 4 : 2); j++) {
               spriteMaskQueue[qPos] = index !== 0;
              spriteColorQueue[qPos] = colorCodes[index];
          spriteCollisionQueue[qPos] = index > 1;

          qPos++;
        }

        sprite24bits <<= 2;
      }
    }
    else {

      let qPos = 0;

      for (let i = 0; i < 24; i++) {
        for (let j = 0; j < (doubleWidth ? 2 : 1); j++) {

          let isOn = (sprite24bits & (1 << 23)) ? true : false;

               spriteMaskQueue[qPos] = isOn;
              spriteColorQueue[qPos] = spriteColor;
          spriteCollisionQueue[qPos] = isOn;

          qPos++;
        }

        sprite24bits <<= 1;
      }
    }

    sprObj.xStart = sprObj.x + 112;
    sprObj.xEnd   = sprObj.xStart + (doubleWidth ? 48 : 24);
  }
}

function tick() {

  {
    const xc = state.cycleOfLine++;
    const y = state.lineOfRaster;

    const sequence = get8Pixels(xc, y);

    for (let i = 0; i < sequence.length; i++) {
      
      let rgb = sequence[i];

      if (state.static) {
        const rand = Math.random();
        if      (rand < 0.6) rgb = 0x000000;
        else if (rand < 0.7) rgb = 0x444444;
        else if (rand < 0.8) rgb = 0x888888;
        else if (rand < 0.9) rgb = 0xcccccc;
        else                 rgb = 0xffffff;
      }

      const x = (xc * 8) + i;
      
      setPixel(
        x,
        y,
        ((rgb & 0xff0000) >> 16),
        ((rgb & 0x00ff00) >>  8),
        ((rgb & 0x0000ff) >>  0),
      );
    }

    // Line up logic for next cycle

    if (state.badline) fetchNextRowOfCharMatrix();

    // Load black where we don't have anything else to load. This is bad.
    // Set it to white (0x11111111) and you'll see it bleed through in Wizball.
    if (state.cycleOfLine === 16) {
      state.bgQueuePos = 0;
      state.bgRgbQueue .fill(0); // color code 0 = black
      state.bgMaskQueue.fill(0);
    }

    else if ((state.cycleOfLine >= 17) && (state.cycleOfLine < 57)) {
      loadNextBgByte();
    }

    if (state.cycleOfLine === 17) {
      if (state.fortyColumns) state.vflag = 0;
    }

    else if (state.cycleOfLine === 18) {
      if (!state.fortyColumns) state.vflag = 0;
    }

    else if (state.cycleOfLine === 56) {
      if (!state.fortyColumns) state.vflag = 1;
    }

    else if (state.cycleOfLine === 57) {
      if (state.fortyColumns) state.vflag = 1;
    }

    else if (state.cycleOfLine >= 63) {

      fetchSpriteSequencesForLine();

      state.cycleOfLine = 0;
      state.lineOfRaster++;
      onNewLine();
    }
  }

  if (!state.cyclesUntilRasterInc--) {

    // We're on a new raster line. Update our count, and maybe trigger an interrupt

    if (++state.raster >= 312) {
      state.raster = 0;
    }

    if (state.raster === state.rasterIrq) {
      rasterMightIrq();
    }

    state.cyclesUntilRasterInc = 62;
  }
}

function makeRead() {

  const fns = {};

  // One-byte-per-sprite registers
  for (let sprite = 0; sprite < 8; sprite++) {

    // X co-ord bits 0-7 ($d000, $d002, $d004, ...)
    fns[(sprite * 2) + 0] = () => state.sprites[sprite].x & 0xff;

    // Y co-ord ($d001, $d003, $d005, ...)
    fns[(sprite * 2) + 1] = () => state.sprites[sprite].y;

    // Color ($d027, $d028, $d029, ...)
    fns[(sprite * 1) + 0x27] = () => state.sprites[sprite].color;
  }

  // One-bit-per-sprite registers
  const oneBitPerSprite = (fn) => () => {
    let ret = 0;
    for (let spriteNum = 0; spriteNum < 8; spriteNum++) {
      ret |= (fn(state.sprites[spriteNum]) ? (1 << spriteNum) : 0);
    }
    return ret;
  };

  // $d010 - bit 8 of X co-ords
  fns[0x10] = oneBitPerSprite((sprite) => sprite.x & 0x100);

  // $d015 - enable
  fns[0x15] = oneBitPerSprite((sprite) => sprite.enabled);

  // $d017 - double height
  fns[0x17] = oneBitPerSprite((sprite) => sprite.x2h);

  // $d01b - priotiy
  fns[0x1b] = oneBitPerSprite((sprite) => sprite.behind);

  // $d01c - multicolor mode
  fns[0x1c] = oneBitPerSprite((sprite) => sprite.mcm);

  // $d01d - double width
  fns[0x1d] = oneBitPerSprite((sprite) => sprite.x2w);

  // $d01e - sprite-sprite collision
  fns[0x1e] = () => {
    // †1 says:
    //
    //    "The registers $d01e and $d01f cannot be written and are automatically
    //    cleared on reading"
    //
    // †2 says:
    //
    //    "Write: Enable further detection of sprite-sprite collisions."
    //
    // I'm going with †1
    const ret = state.sprSprCol;
    state.sprSprCol = 0;
    return ret;
  }

  // $d01f - sprite-background collision
  fns[0x1f] = () => {
    const ret = state.sprBgCol;
    state.sprBgCol = 0;
    return ret;
  }

  // $d020: Border color
  fns[0x20] = () => 0xf0 | state.borderColor;

  // $d021: Background color
  fns[0x21] = () => 0xf0 | state.backgroundColor;

  // $d022: Extra background color 1
  fns[0x22] = () => 0xf0 | state.extraBgColor1;

  // $d023: Extra background color 2
  fns[0x23] = () => 0xf0 | state.extraBgColor2;

  // $d024: Extra background color 3
  fns[0x24] = () => 0xf0 | state.extraBgColor3;

  // $d025: Sprite multicolor color 0
  fns[0x25] = () => state.spriteMulticolorColor0;

  // $d026: Sprite extra color 2
  fns[0x26] = () => state.spriteMulticolorColor1;


  // $d018: Memory setup
  fns[0x18] = () => state.memorySetup;

  // $d019: Interrupt status
  // TODO: does real hardware set unused bits high?
  fns[0x19] = () => state.interruptStatus | (state.irq ? 0b10000000 : 0);

  // $d01a: Interrupt control
  // TODO: does real hardware set unused bits high?
  fns[0x1a] = () => state.interruptControl | 0xf0;


  // $d013: (Read-only) light pen X
  fns[0x13] = () => {
    // With nothing connected, real hardware just seems to emit noise for the
    // light pen registers. Previously, we'd sound a warning about
    // unimplemented functionality on accesses, but lots of software seems to
    // touch them for no apparent reason, so here we're just returning one of
    // many values that I've seen appear on real hardware.
    return 213;
  }

  // $d014: (Read-only) light pen Y
  fns[0x14] = () => {
    // As above
    return 120;
  }

  // $d011: current raster line bit 8
  fns[0x11] = () => (
    // bit 7: bit 8 of the raster line number
    ((state.raster & 0x100) ? 0x80 : 0x00) |

    // bit 6: extended background mode
    (state.extendedBg ? (1 << 6) : 0) |

    // bit 5: bitmap mode
    (state.bitmap ? (1 << 5) : 0) |

    // bit 4: display enable
    (state.displayEnable ? (1 << 4) : 0) |

    // bit 3: 25-row mode
    (state.twentyFiveRows ? (1 << 3) : 0) |

    // bits 0-2: vertical raster scroll
    state.yscroll

    // TODO: and there's more
  );

  // $d012, current raster line bits 0-7
  fns[0x12] = () => state.raster & 0xff;

  // $d016, Screen control register #2
  fns[0x16] = () => (
    state.xscroll |
    (state.multicolor   ? 0x10 : 0x00) |
    (state.fortyColumns ? 0x08 : 0x00) |

    // TODO: †2 says default is %11001000. But bit 5 doesn't seem to be
    // anything. Is that correct? Check on real hardware
    0b11100000
  );

  // $d02f - $d03f: unmapped
  for (let reg = 0x2f; reg <= 0x3f; reg++) {
    // TODO: pretty sure, but double-check it's 0xff.
    fns[reg] = () => 0xff;
  }

  // Regs are from $d000-$d03f, with degenerate copies through $d3ff
  return (addr) => fns[addr & 0x3f]();
}

function makeWrite() {
  const fns = {};

  // One-byte-per-sprite registers
  for (let sprite = 0; sprite < 8; sprite++) {

    // X co-ord bits 0-7 ($d000, $d002, $d004, ...)
    fns[(sprite * 2) + 0] = (byte) => state.sprites[sprite].x = (state.sprites[sprite].x & 0x100) | byte;

    // Y co-ord ($d001, $d003, $d005, ...)
    fns[(sprite * 2) + 1] = (byte) => state.sprites[sprite].y = byte;

    // Color ($d027, $d028, $d029, ...)
    fns[(sprite * 1) + 0x27] = (byte) => state.sprites[sprite].color = byte & 0xf;
  }

  // One-bit-per-sprite registers
  const oneBitPerSprite = (fn) => (byte) => {
    let ret = 0;
    for (let spriteNum = 0; spriteNum < 8; spriteNum++) {
      fn(state.sprites[spriteNum], Boolean(byte & (1 << spriteNum)));
    }
    return ret;
  };

  // $d010 - bit 8 of X co-ords
  fns[0x10] = oneBitPerSprite((sprite, bit) => sprite.x = bit ? (sprite.x | 0x100) : (sprite.x & 0xff));
  fns[0x15] = oneBitPerSprite((sprite, bit) => sprite.enabled = bit);  // $d015 - enable
  fns[0x17] = oneBitPerSprite((sprite, bit) => sprite.x2h     = bit);  // $d017 - double height
  fns[0x1b] = oneBitPerSprite((sprite, bit) => sprite.behind  = bit);  // $d01b - priority
  fns[0x1c] = oneBitPerSprite((sprite, bit) => sprite.mcm     = bit);  // $d01c - multicolor mode
  fns[0x1d] = oneBitPerSprite((sprite, bit) => sprite.x2w     = bit);  // $d01d - double width


  // $d01e - sprite-sprite collision
  fns[0x1e] = (byte) => state.sprSprCol = byte;

  // $d01f - sprite-background collision
  fns[0x1f] = (byte) => state.sprBgCol = byte;


  // $d011, screen control register 1, current raster line bit 8
  fns[0x11] = (byte) => {
    // update our view of raster IRQ line setting,
    // and fall through to update the rest of the register
    const rasterBit8 = (byte & 0x80) << 1;

    state.rasterIrq &= 0xff;
    state.rasterIrq |= rasterBit8;

    state.yscroll        =         byte & 0b00000111;
    state.twentyFiveRows = Boolean(byte & 0b00001000);
    state.displayEnable  = Boolean(byte & 0b00010000);
    state.bitmap         = Boolean(byte & 0b00100000);
    state.extendedBg     = Boolean(byte & 0b01000000);
  };

  // $d012, current raster line bits 0-7
  fns[0x12] = (byte) => {
    const rasterBit8 = state.rasterIrq & 0x100;
    state.rasterIrq = byte | rasterBit8;
  };

  // $d013, Light pen X-coordinate (read-only)
  // $d014, Light pen Y-coordinate (read-only)
  fns[0x13] = () => {};
  fns[0x14] = () => {};

  // $d016, Screen control register #2
  fns[0x16] = (byte) => {    
    state.xscroll      = byte & 0x7;
    state.multicolor   = Boolean(byte & 0x10);
    state.fortyColumns = Boolean(byte & 0x08);
    // TODO: and there's other bits
  };

  // $d018, Memory setup
  fns[0x18] = (byte) => state.memorySetup = byte;
  
  // $d019: Interrupt acknowledge
  fns[0x19] = (byte) => {

    // clear the bits that the writer's asking us to
    state.interruptStatus &= ~byte;
    state.interruptStatus &= 0x0f;

    reconsiderVicIrq();
  };

  // $d01a, Interrupt control register
  fns[0x1a] = (byte) => {    
    state.interruptControl = byte & 0xf;

    if (byte & 0x8) (0,_debug__WEBPACK_IMPORTED_MODULE_0__.unimplementedWarning)("light pen interrupts");

    // TODO: if an interrupt isn't enabled now, but was responsible for pulling
    // the IRQ line low, I guess that means it'll no longer be pulling the IRQ
    // line low? Is this how real hardware operates?

    reconsiderVicIrq();
  };

  fns[0x20] = (byte) => state.borderColor            = byte & 0xf;  // $d020, Border color
  fns[0x21] = (byte) => state.backgroundColor        = byte & 0xf;  // $d021, Background color
  fns[0x22] = (byte) => state.extraBgColor1          = byte & 0xf;  // $d022, Extra background color 1
  fns[0x23] = (byte) => state.extraBgColor2          = byte & 0xf;  // $d023, Extra background color 2
  fns[0x24] = (byte) => state.extraBgColor3          = byte & 0xf;  // $d024, Extra background color 3
  fns[0x25] = (byte) => state.spriteMulticolorColor0 = byte & 0xf;  // $d025: Sprite multicolor color 0
  fns[0x26] = (byte) => state.spriteMulticolorColor1 = byte & 0xf;  // $d026: Sprite extra color 2

  // $d02f - $d03f: unmapped
  for (let reg = 0x2f; reg <= 0x3f; reg++) {
    fns[reg] = () => {};
  }

  // regs are from $d000-$d03f, with degenerate copies through $d3ff
  return (addr, byte) => fns[addr & 0x3f](byte);
};

const read_d000_d3ff = makeRead();

function read_d800_dbff(addr) {
  return state.color[addr - 0xd800] | 0xf0;
}

const write_d000_d3ff = makeWrite();

function write_d800_dbff(addr, byte) {
  state.color[addr - 0xd800] = byte & 0xf;
}

function showStatic() {
  state.static = true;
}

function setIgnoreSprBgCol(ignore) {
  config.ignoreSprBgCollisions = ignore;
}

function setIgnoreSprSprCol(ignore) {
  config.ignoreSprSprCollisions = ignore;
}

function setScope(key) {
  // Not the most elegant...
  for (let i in config) {
    if (/^scope/.test(i)) {
      config[i] = false;
    }
  }
  
  if (key) config[key] = true;
}

function serialize() {
  // Transfer the special arrays to regular arrays
  // (Otherwise they'll get serialized as { 0:..., 1:..., 2:..., ...})
  const stateCopy = {...state};

  for (let [key, type, size] of specialStateValues) {
    stateCopy[key] = [];

    for (let i in state[key]) {
      // Should warn if we see unexpected keys
      stateCopy[key][i] = state[key][i];
    }
  }

  return JSON.stringify(stateCopy);
}

function deserialize(json) {
  state = JSON.parse(json);

  // Transfer the arrays to special arrays
  for (let [key, type, size] of specialStateValues) {
    const arr = new type(size);

    // Should warn if sizes don't match!
    for (let i = 0; i < state[key].length; i++) {
      arr[i] = state[key][i];
    }

    state[key] = arr;
  }
}


/***/ }),

/***/ "./src/target/wires.js":
/*!*****************************!*\
  !*** ./src/target/wires.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   attach: () => (/* binding */ attach)
/* harmony export */ });
/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../debug */ "./src/debug.js");
/* harmony import */ var _tools_serializerSupport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tools/serializerSupport */ "./src/tools/serializerSupport.js");
/*
   wires: provides a system for interconnecting the hardware devices

   wires is the one part of the system that the bringup process guarantees is
   in place when the hardware devices attach, and those devices generally
   should use wires as a means to talk to each other, rather than accessing
   other devices' entries in the c64 structure directly.

   Wires simulates literal wires, like the IRQ and NMI lines, which can be
   driven from multiple sources, but arrive at the CPU as a wired-OR single
   value. It provides bus accesses, simulating the memory-mapping PLA that's
   driven by the processor port, and connecting the Vic to RAM or character
   ROM using the Vic bank output from CIA2 port A. It also simulates the
   processor port, which is really part of the CPU, but it was convenient to
   move it here since it's accessed through MMIO like the hardware devices.

   Contrary to what the name implies, wires does maintain state: it needs this
   for the processor port, but it also caches values that could be derived from
   other sources, like the interrupt lines and Vic bank.
*/

// References:
// Super helpful memory map: https://sta.c64.org/cbm64mem.html




// Configured by attach
let c64;
let basic, character, kernal;
let readRam, writeRam, vicReadRam;

let state;

function attach(nascentC64) {
  c64 = nascentC64;

  basic      = c64.rom.basic;
  kernal     = c64.rom.kernal;
  character  = c64.rom.character;
  readRam    = c64.ram.readRam;
  writeRam   = c64.ram.writeRam;
  vicReadRam = c64.ram.vicReadRam;

  (0,_tools_serializerSupport__WEBPACK_IMPORTED_MODULE_1__.addToSerializerRegistry)({
    readRam,
    writeRam,
  });

  reset();

  c64.wires = {
    // Control
    reset,
    serialize,
    deserialize,
    // State
    state,
    // Wires
    cpuRead,
    cpuWrite,
    vicRead,
    getIrq,
    getNmi,
    setVicIrq,
    setCia1Irq,
    setCia2Nmi,
    setVicBank,
    raiseTapeInterrupt,
  };
}

function reset() {
  state = {
    // Interrupt inputs
    // (use setVicIrq, setCia1Irq, setCia2Nmi to set them)
    irq_vic:  false,
    irq_cia1: false,
    nmi_cia2: false,

    // Interrupt outputs
    irq: false,
    nmi: false,

    // Processor port
    port:          0x37,
    portLastWrite: 0x37,
    portDirection: 0x2f,

    // CPU memory map
    // (as determined by the processor port)
    readAxxx: readAxxxBasic,
    readDxxx: readDxxxIo,
    readExxx: readExxxKernal,

    writeAxxx: writeRam,
    writeDxxx: writeDxxxIo,
    writeExxx: writeRam,

    // VIC memory map
    // (from CIA2, translated to a pointer. Use setVicBank to set)
    vicBankBase: 0x0000,

    // Tape
    lastTapeMotor: false,
  };

  mapMemoryFromPortOutput();
}

function readAxxxBasic     (addr) { return     basic[addr - 0xa000]; }
function readDxxxCharacter (addr) { return character[addr - 0xd000]; }
function readExxxKernal    (addr) { return    kernal[addr - 0xe000]; }

function reevaluateIrq() {
  state.irq = state.irq_vic || state.irq_cia1;
}

function reevaluateNmi() {
  // TODO: there are other sources. RESTORE key is one. Any others?
  state.nmi = state.nmi_cia2;
}

function getIrq() { return state.irq; }
function getNmi() { return state.nmi; }

function setVicIrq(status)  { state.irq_vic  = status; reevaluateIrq(); }
function setCia1Irq(status) { state.irq_cia1 = status; reevaluateIrq(); }
function setCia2Nmi(status) { state.nmi_cia2 = status; reevaluateNmi(); }

function setVicBank(bankNumber) {
  state.vicBankBase = bankNumber * 0x4000;
}

function vicRead(addr) {
  const { vicBankBase } = state;

  // We're translating to get character RAM here. I'm guessing that
  // all VIC reads to those addresses within its bank get the character
  // ROM, not just character reads.

  if ((vicBankBase === 0x0000) || (vicBankBase === 0x8000)) {
    if ((addr >= 0x1000) && (addr < 0x2000)) {
      return character[addr - 0x1000];
    }
  }

  return vicReadRam(vicBankBase + addr);
}

function cpuRead(addr) {
  (0,_debug__WEBPACK_IMPORTED_MODULE_0__.vetAddress)(addr);

  function realRead() {

    if ((addr === 0))                         return readPortDirection();
    if ((addr === 1))                         return readPort();

    if ((addr >= 0xa000) && (addr <= 0xbfff)) return state.readAxxx(addr);
    if ((addr >= 0xd000) && (addr <= 0xdfff)) return state.readDxxx(addr);
    if ((addr >= 0xe000) && (addr <= 0xffff)) return state.readExxx(addr);

    return readRam(addr);
  }

  const ret = realRead();

  if (!((ret >= 0) && (ret <= 255))) {
    debugger;
    throw new Error("Bus read got bad value for addr = " + addr);
  }

  return ret;
}

function readPortDirection() {
  return state.portDirection;
}

function readPort() {
  // TODO: what happens if a port input line is set to read/
  // write? If we read its value do we now get the last bit we tried to write
  // to it? I guess the CPU output would be fighting the external device
  // driving it.
 
  return state.port;
}

function getFloatingValue() {
  // datasette buttons: port shows 1 if nothing pressed
  const t = c64.tape.isAnyButtonPressed() ? 0 : 1;

  return (
    (0 << 7) |    // Not part of port. TODO: check value on real hardware
    (0 << 6) |    // Not part of port. TODO: check value on real hardware
    (1 << 5) |    // Datasette motor off
    (t << 4) |    // Datasette buttons (0 = something's pressed)
    (0 << 3) |    // Datasette output
    (1 << 2) |    // Memory config.
    (1 << 1) |    // Memory config.
    (1 << 0)      // Memory config.
  );
}

function writePortDirection(byte) {
  state.portDirection = byte;

  // Port lines that were read/write and are now read will now float to
  // wherever they're tied.

  state.port = (
    (state.portLastWrite & state.portDirection) |
    (getFloatingValue() & ~state.portDirection)
  );

  mapMemoryFromPortOutput();
}

function writePort(byte) {
  state.portLastWrite = byte;

  // Which lines are tied low/high. TODO: research this. The bank lines seem
  // to be tied high (or Buggy Boy and Hero of the Golden Talisman fail),

  // a 1 in a bit of portDirection means that bit can be written to
  state.port = (
    (byte               &  state.portDirection) |
    (getFloatingValue() & ~state.portDirection)
  );

  const tapeMotor = !(state.port & 0b00100000);
  if (tapeMotor !== state.lastTapeMotor) {
    state.lastTapeMotor = tapeMotor;
    c64.tape.setTapeMotor(tapeMotor);
  }

  mapMemoryFromPortOutput();
}

function mapMemoryFromPortOutput() {
  // The outgoing port value having changed, reconfigure the mappings accordingly

  const bank = state.port & 0b111;

  // TODO: I'm not _at all_ confident about these.
  // from https://sta.c64.org/cbm64mem.html
  ({
    0b000: () => {  state .readAxxx = readRam;
                    state .readDxxx = readRam;
                    state .readExxx = readRam;
                    state.writeAxxx = writeRam;
                    state.writeDxxx = writeRam;
                    state.writeExxx = writeRam;
    },
    0b001: () => {  state .readAxxx = readRam;
                    state .readDxxx = readDxxxCharacter;
                    state .readExxx = readRam;
                    state.writeAxxx = writeRam;
                    state.writeDxxx = writeRam;
                    state.writeExxx = writeRam;
    },
    0b010: () => {  state .readAxxx = readRam;
                    state .readDxxx = readDxxxCharacter;
                    state .readExxx = readExxxKernal;
                    state.writeAxxx = writeRam;
                    state.writeDxxx = writeRam;
                    state.writeExxx = writeRam;
    },
    0b011: () => {  state .readAxxx = readAxxxBasic;
                    state .readDxxx = readDxxxCharacter;
                    state .readExxx = readExxxKernal;
                    state.writeAxxx = writeRam;
                    state.writeDxxx = writeRam;
                    state.writeExxx = writeRam;
    },
    0b100: () => {  state .readAxxx = readRam;
                    state .readDxxx = readRam;
                    state .readExxx = readRam;
                    state.writeAxxx = writeRam;
                    state.writeDxxx = writeRam;
                    state.writeExxx = writeRam;
    },
    0b101: () => {  state .readAxxx = readRam;
                    state .readDxxx = readDxxxIo;
                    state .readExxx = readRam;
                    state.writeAxxx = writeRam;
                    state.writeDxxx = writeDxxxIo;
                    state.writeExxx = writeRam;
    },
    0b110: () => {  state .readAxxx = readRam;
                    state .readDxxx = readDxxxIo;
                    state .readExxx = readExxxKernal;
                    state.writeAxxx = writeRam;
                    state.writeDxxx = writeDxxxIo;
                    state.writeExxx = writeRam;
    },
    0b111: () => {  state .readAxxx = readAxxxBasic;
                    state .readDxxx = readDxxxIo;
                    state .readExxx = readExxxKernal;
                    state.writeAxxx = writeRam;
                    state.writeDxxx = writeDxxxIo;
                    state.writeExxx = writeRam;
    },
  })[bank]();
}

function cpuWrite(addr, byte) {
  (0,_debug__WEBPACK_IMPORTED_MODULE_0__.vetAddress)(addr);

  if ((addr === 0))                         return writePortDirection(byte);
  if ((addr === 1))                         return writePort(byte);

  if ((addr >= 0xa000) && (addr <= 0xbfff)) return state.writeAxxx(addr, byte);
  if ((addr >= 0xd000) && (addr <= 0xdfff)) return state.writeDxxx(addr, byte);
  if ((addr >= 0xe000) && (addr <= 0xffff)) return state.writeExxx(addr, byte);

                                            return writeRam(addr, byte);
}

function readDxxxIo(addr) {

  // VIC registers
  if ((addr >= 0xd000) && (addr <= 0xd3ff)) return c64.vic.read_d000_d3ff(addr);
  // SID
  if ((addr >= 0xd400) && (addr <= 0xd7ff)) return c64.sid.read_d400_d7ff(addr);
  // Color RAM
  if ((addr >= 0xd800) && (addr <= 0xdbff)) return c64.vic.read_d800_dbff(addr);
  // CIA1
  if ((addr >= 0xdc00) && (addr <= 0xdcff)) return c64.cias.read_dc00_dcff(addr);
  // CIA2
  if ((addr >= 0xdd00) && (addr <= 0xddff)) return c64.cias.read_dd00_ddff(addr);

  // $de00 - $dfff are for memory-mapped IO of any other devices you've plugged
  // into the bus. Consider them unmapped; a vanilla C64 just shows noise here.
  return 0xff;
}

function writeDxxxIo(addr, byte) {

  // VIC registers
  if ((addr >= 0xd000) && (addr <= 0xd3ff)) return c64.vic.write_d000_d3ff(addr, byte);
  // SID
  if ((addr >= 0xd400) && (addr <= 0xd7ff)) return c64.sid.write_d400_d7ff(addr, byte);
  // Color RAM
  if ((addr >= 0xd800) && (addr <= 0xdbff)) return c64.vic.write_d800_dbff(addr, byte);
  // CIA1
  if ((addr >= 0xdc00) && (addr <= 0xdcff)) return c64.cias.write_dc00_dcff(addr, byte);
  // CIA2
  if ((addr >= 0xdd00) && (addr <= 0xddff)) return c64.cias.write_dd00_ddff(addr, byte);

  // $de00 - $dfff are for memory-mapped IO of any other devices you've plugged
  // into the bus. Consider them unmapped.
  return;
}

function serialize() {
  return JSON.stringify({
    ...state,
    readAxxx:  (0,_tools_serializerSupport__WEBPACK_IMPORTED_MODULE_1__.functionToReference)(state.readAxxx),
    readDxxx:  (0,_tools_serializerSupport__WEBPACK_IMPORTED_MODULE_1__.functionToReference)(state.readDxxx),
    readExxx:  (0,_tools_serializerSupport__WEBPACK_IMPORTED_MODULE_1__.functionToReference)(state.readExxx),
    writeAxxx: (0,_tools_serializerSupport__WEBPACK_IMPORTED_MODULE_1__.functionToReference)(state.writeAxxx),
    writeDxxx: (0,_tools_serializerSupport__WEBPACK_IMPORTED_MODULE_1__.functionToReference)(state.writeDxxx),
    writeExxx: (0,_tools_serializerSupport__WEBPACK_IMPORTED_MODULE_1__.functionToReference)(state.writeExxx),
  });
}

function deserialize(json) {
  state = JSON.parse(json);

  state.readAxxx  = (0,_tools_serializerSupport__WEBPACK_IMPORTED_MODULE_1__.referenceToFunction)(state.readAxxx);
  state.readDxxx  = (0,_tools_serializerSupport__WEBPACK_IMPORTED_MODULE_1__.referenceToFunction)(state.readDxxx);
  state.readExxx  = (0,_tools_serializerSupport__WEBPACK_IMPORTED_MODULE_1__.referenceToFunction)(state.readExxx);
  state.writeAxxx = (0,_tools_serializerSupport__WEBPACK_IMPORTED_MODULE_1__.referenceToFunction)(state.writeAxxx);
  state.writeDxxx = (0,_tools_serializerSupport__WEBPACK_IMPORTED_MODULE_1__.referenceToFunction)(state.writeDxxx);
  state.writeExxx = (0,_tools_serializerSupport__WEBPACK_IMPORTED_MODULE_1__.referenceToFunction)(state.writeExxx);
}

function raiseTapeInterrupt() {
  c64.cias.raiseTapeInterrupt();
}

(0,_tools_serializerSupport__WEBPACK_IMPORTED_MODULE_1__.addToSerializerRegistry)({
  readAxxxBasic,
  readDxxxCharacter,
  readExxxKernal,
  readDxxxIo,
  writeDxxxIo,
});


/***/ }),

/***/ "./src/tools/assembler.js":
/*!********************************!*\
  !*** ./src/tools/assembler.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   assemble: () => (/* binding */ assemble)
/* harmony export */ });
/*
  This is a half-assembler. Rather than taking a text file as input, it
  converts 6502-esque JavaScript functions into object code, and links it,
  returning a byte array.

  Use like this:

  |   const bin = assemble(
  |     0x4000,                   // target address
  |     ({
  |       NOP, LDA, LDX, LDY, STA, STX, STY, CLC, CLD, CLI, CLV, SEC, SED, SEI,
  |       TAX, TAY, TSX, TXA, TXS, TYA, CMP, CPX, CPY, BCS, BCC, BEQ, BNE, BMI,
  |       BPL, BVS, BVC, BIT, JSR, RTS, RTI, BRK, JMP, INC, DEC, DEX, DEY, INX,
  |       INY, ADC, SBC, AND, EOR, ORA, ASL, ROL, LSR, ROR, PHA, PHP, PLA, PLP,
  |       _
  |     }) => {
  |
  |       LDX.imm (7);
  |       STX.abs (0xd020);       // set border color
  |
  |     _`loop`;
  |       STX.abs (0xd021);       // set background color
  |       DEX.imp ();
  |       BNE.rel `loop`;
  |
  |       RTS.imp ();
  |   });


  The format of the opcodes looks like this:

  |       Addressing mode   Assembler      JavaScript
  |       ---------------   ---------      ----------
  |       Implicit          RTI            RTI.imp ()
  |       Immediate         LDA #$10       LDA.imm (0x10)
  |       Accumulator       LSR A          LSR.acc ()
  |       Absolute          JMP $1000      JMP.abs (0x1000)
  |       Absolute,X        STA $3000,X    STA.abx (0x3000)
  |       Absolute,Y        AND $4000,Y    AND.aby (0x4000)
  |       Indirect          JMP ($FFFC)    JMP.ind (0xfffc)
  |       Indirect,X        LDA ($40,X)    LDA.inx (0x40)
  |       Indirect,Y        LDA ($40),Y    LDA.iny (0x40)
  |       Zero Page         LDA $20        LDA.zpg (0x20)
  |       Zero Page,X       STY $10,X      STY.zpx (0x10)
  |       Zero Page,Y       STX $10,Y      STX.zpy (0x10)
  |       Relative          BNE label      BNE.rel `label`


  Labels can be defined as:

  |       _`loop`;

  Or, for locations external to the program:

  |       _.label(0xd020, "extcol");

  ...and can then be referenced like:

  |       BNE.rel `label`;                    // label as branch target
  |       LDX.imm _.l`label`;                 // low byte of label
  |       LDY.imm _.h`label`;                 // high byte of label
  |       STA.abs (({label}) => label + 1);   // perform math on label

  In that last case, the function that's passed to that STA instruction is
  called during the linking phase, once all the labels have been assigned
  locations. It's passed in an object whose keys are all the labels' names, and
  whose values are the locations of those labels. The value it returns will
  become the operand to the STA instruction, converted automatically into
  lowbyte/highbyte.


  Arbitrary bytes can be injected into the code like this:

  |       _.bytes(0x4c, 0x16, 0x08, 0x00, 0x97, 0x32);


  The half-assembler also contains a Basic half-tokenizer, which provides
  only just enough commands to bootstrap a machine language routine. Call it
  like this:

  |       _.basic(
  |         ({REM, POKE, SYS}) => ({
  |           10: REM ("SIMPLE BASIC BOOTSTRAP"),
  |           20: POKE (53281, 0),
  |           30: SYS ("start"),
  |         })
  |       );
  |
  |       _`start`;
  |         // (6502 assembly starts here)

*/

// TODO: the quasi-ops aren't here yet, even though the rest of the emulator
// now supports them.
const opcodes = {
  ADC: { abs: 0x6d, abx: 0x7d, aby: 0x79, inx: 0x61, iny: 0x71, imm: 0x69, zpg: 0x65, zpx: 0x75 },
  AND: { abs: 0x2d, abx: 0x3d, aby: 0x39, inx: 0x21, iny: 0x31, imm: 0x29, zpg: 0x25, zpx: 0x35 },
  ASL: { abs: 0x0e, abx: 0x1e, acc: 0x0a, zpg: 0x06, zpx: 0x16 },
  BCC: { rel: 0x90 },
  BCS: { rel: 0xb0 },
  BEQ: { rel: 0xf0 },
  BIT: { abs: 0x2c, zpg: 0x24 },
  BMI: { rel: 0x30 },
  BNE: { rel: 0xd0 },
  BPL: { rel: 0x10 },
  BRK: { imp: 0x00 },
  BVC: { rel: 0x50 },
  BVS: { rel: 0x70 },
  CLC: { imp: 0x18 },
  CLD: { imp: 0xd8 },
  CLI: { imp: 0x58 },
  CLV: { imp: 0xb8 },
  CMP: { abs: 0xcd, abx: 0xdd, aby: 0xd9, inx: 0xc1, iny: 0xd1, imm: 0xc9, zpg: 0xc5, zpx: 0xd5 },
  CPX: { abs: 0xec, imm: 0xe0, zpg: 0xe4 },
  CPY: { abs: 0xcc, imm: 0xc0, zpg: 0xc4 },
  DEC: { abs: 0xce, abx: 0xde, zpg: 0xc6, zpx: 0xd6 },
  DEX: { imp: 0xca },
  DEY: { imp: 0x88 },
  EOR: { abs: 0x4d, abx: 0x5d, aby: 0x59, inx: 0x41, iny: 0x51, imm: 0x49, zpg: 0x45, zpx: 0x55 },
  INC: { abs: 0xee, abx: 0xfe, zpg: 0xe6, zpx: 0xf6 },
  INX: { imp: 0xe8 },
  INY: { imp: 0xc8 },
  JMP: { abs: 0x4c, ind: 0x6c },
  JSR: { abs: 0x20 },
  LDA: { abs: 0xad, abx: 0xbd, aby: 0xb9, inx: 0xa1, iny: 0xb1, imm: 0xa9, zpg: 0xa5, zpx: 0xb5 },
  LDX: { abs: 0xae, aby: 0xbe, imm: 0xa2, zpg: 0xa6, zpy: 0xb6 },
  LDY: { abs: 0xac, abx: 0xbc, imm: 0xa0, zpg: 0xa4, zpx: 0xb4 },
  LSR: { abs: 0x4e, abx: 0x5e, acc: 0x4a, zpg: 0x46, zpx: 0x56 },
  NOP: { imp: 0xea },
  ORA: { abs: 0x0d, abx: 0x1d, aby: 0x19, inx: 0x01, iny: 0x11, imm: 0x09, zpg: 0x05, zpx: 0x15 },
  PHA: { imp: 0x48 },
  PHP: { imp: 0x08 },
  PLA: { imp: 0x68 },
  PLP: { imp: 0x28 },
  ROL: { abs: 0x2e, abx: 0x3e, acc: 0x2a, zpg: 0x26, zpx: 0x36 },
  ROR: { abs: 0x6e, abx: 0x7e, acc: 0x6a, zpg: 0x66, zpx: 0x76 },
  RTI: { imp: 0x40 },
  RTS: { imp: 0x60 },
  SBC: { abs: 0xed, abx: 0xfd, aby: 0xf9, inx: 0xe1, iny: 0xf1, imm: 0xe9, zpg: 0xe5, zpx: 0xf5 },
  SEC: { imp: 0x38 },
  SED: { imp: 0xf8 },
  SEI: { imp: 0x78 },
  STA: { abs: 0x8d, abx: 0x9d, aby: 0x99, inx: 0x81, iny: 0x91, zpg: 0x85, zpx: 0x95 },
  STX: { abs: 0x8e, zpg: 0x86, zpy: 0x96 },
  STY: { abs: 0x8c, zpg: 0x84, zpx: 0x94 },
  TAX: { imp: 0xaa },
  TAY: { imp: 0xa8 },
  TSX: { imp: 0xba },
  TXA: { imp: 0x8a },
  TXS: { imp: 0x9a },
  TYA: { imp: 0x98 },
};

const basicTokens = {
  REM:  0x8f,
  POKE: 0x97,
  SYS:  0x9e,
}


function validateByte(byte) {
  if (typeof byte !== "number") throw new Error("Not a number");
  if (byte % 1)                 throw new Error("Not an integer");
  if (byte < 0)                 throw new Error("Can't be negative");
  if (byte > 0xff)              throw new Error("Too big");
}

function validateAddr(addr) {
  if (typeof addr !== "number") throw new Error("Not a number");
  if (addr % 1)                 throw new Error("Not an integer");
  if (addr < 0)                 throw new Error("Can't be negative");
  if (addr > 0xffff)            throw new Error("Too big");
}

// Operand handlers

function byteOperand(chunk, linkerTasks, arg) {
  let byte = "XX";

  if (typeof arg === "object") {
    // it's a reference, left by, say, a _.l``
    // (So shouldn't have called it a byte)
    linkerTasks.push({
      ...arg,
      at: chunk.length,
    });
  }

  else if (typeof arg === "string") {
    linkerTasks.push({
      at: chunk.length,
      format: "lo",
      label: arg,
    });
  }

  else {
    validateByte(arg);
    byte = arg;
  }

  chunk.push(byte);
}

function addrOperand(chunk, linkerTasks, arg) {
  if (typeof arg === "function") {

    linkerTasks.push({
      at: chunk.length,
      format: "lohiFn",
      fn: arg,
    });

    chunk.push("XX");
    return;
  }

  if (typeof arg === "number") {
    validateAddr(arg);
    chunk.push(arg & 0xff);
    chunk.push(arg >> 8);
    return;
  }

  else if (typeof arg === "string") {
    linkerTasks.push({
      at: chunk.length,
      format: "lo",
      label: arg,
    });

    chunk.push("XX");

    linkerTasks.push({
      at: chunk.length,
      format: "hi",
      label: arg,
    });

    chunk.push("XX");
  }

  else if (Array.isArray(arg)) {
     
    // Was called as, eg. "LDA `label`"

    linkerTasks.push({
      at: chunk.length,
      format: "lo",
      label: arg[0],
    });

    chunk.push("XX");

    linkerTasks.push({
      at: chunk.length,
      format: "hi",
      label: arg[0],
    });

    chunk.push("XX");
  }
}

function noOperand(chunk, linkerTasks, arg) {
}

function relOperand(chunk, linkerTasks, arg) {

  // TODO we should allow rel with a function arg
  if (typeof arg === "number") {

    // back when we pushed the relative arg
    // chunk.push(arg);

    linkerTasks.push({
      at: chunk.length,
      format: "relFromAbsolute",
      target: arg,
    });

    chunk.push("XX");
    return;
  }

  let label;

  if (Array.isArray(arg)) {
    label = arg[0];
  }
  else if (typeof arg === "string") {
    label = arg;
  }

  else throw new Error("Unexpected type for relative mode:" + arg);

  linkerTasks.push({
    at: chunk.length,
    format: "relFromLabel",
    label,
  });

  chunk.push("XX");
}

const operandHandler = {
  imm: byteOperand,
  acc:   noOperand,
  abs: addrOperand,
  abx: addrOperand,
  aby: addrOperand,
  imp:   noOperand,
  ind: addrOperand,
  inx: byteOperand,
  iny: byteOperand,
  rel:  relOperand,
  zpg: byteOperand,
  zpx: byteOperand,
  zpy: byteOperand,
};

function link(chunk, org, linkerTasks, labels) {

  const getLabel = label => {
    const addr = labels[label];
    if (addr === undefined) {
      throw new Error("Undefined label: " + label);
    }
    return addr;
  };

  linkerTasks.forEach(
    ({ at, format, label, fn, digits, target }) => {

      switch (format) {

        case "lohiFn":
        {
          // A function should be called, and its return value considered
          // an address, which we need to store in lowbyte/highbyte form.
          const addr = fn(labels);

          validateAddr(addr);

          chunk[at + 0] = addr & 0xff;
          chunk[at + 1] = addr >> 8;
          break;
        }

        case "petsciiFn":
        {
          // A function should be called, and its return value considered
          // an address, which we need to store in Petscii characters in
          // `digits` number of digits.
          const addr = fn(labels);

          validateAddr(addr);

          const addrAsString = String(addr);

          if (addrAsString.length > digits) {
            throw new Error("Can't fit address into requested number of digits");
          }

          const addrAsPaddedString = String(addr).padStart(digits, "0");

          Array.from(addrAsPaddedString).forEach(
            (letter, index) => {
              chunk[at + index] = letter.charCodeAt(0);
            }
          )

          break;
        }

        case "lo":
          chunk[at] = getLabel(label) & 0xff;
          break;

        case "hi":
          chunk[at] = getLabel(label) >> 8;
          break;

        case "relFromAbsolute":
        {
          // -1 instead of -2 because the 'at' in this case is the operand,
          // not the opcode
          const val = target - (at + org) - 1;

          if ((val > 127) || (val < -128)) 
            throw new Error(`branch target ${label} too far (${val}) at offset ${at}`);

          chunk[at] = val & 0xff;
          break;
        }

        case "relFromLabel":
        {
          const addr = getLabel(label);
          const val = addr - (at + org) - 1;

          if ((val > 127) || (val < -128)) 
            throw new Error(`branch target ${label} too far (${val})`);

          chunk[at] = val & 0xff;
          break;
        }
      }
    }
  );
}

function stringToPetsciiCodes(num) {
  return Array.from(num).map(char => char.charCodeAt(0));
}

function numberToPetsciiCodes(num) {
  return Array.from(String(num)).map(char => char.charCodeAt(0));
}

function basic(fn, chunk, org, linkerTasks) {

  const commands = {

    REM: (str) => () => {
      chunk.push(basicTokens.REM);
      chunk.push(...stringToPetsciiCodes(" "));
      chunk.push(...stringToPetsciiCodes(str));
    },

    POKE: (addr, byte) => () => {
      // The address, and the byte to store at that address, must both be
      // simple numbers. (Would be nice to change this in future).
      chunk.push(basicTokens.POKE);
      chunk.push(...stringToPetsciiCodes(" "));
      chunk.push(...numberToPetsciiCodes(addr));
      chunk.push(...stringToPetsciiCodes(","));
      chunk.push(...numberToPetsciiCodes(byte));
    },

    SYS: (addr, digits=5) => () => {
      // The address can be a number, a string (the name of a label), or a
      // function (which, given all the labels, returns a number)
      chunk.push(basicTokens.SYS);
      chunk.push(...stringToPetsciiCodes(" "));

      if (typeof addr === "string") {
        const label = addr;
        addr = (labels) => labels[label];
        // ...and fall through to function
      }

      if (typeof addr === "function") {
        linkerTasks.push({
          at: chunk.length,
          format: "petsciiFn",
          fn: addr,
          digits
        });

        for (let i = 0; i < digits; i++) {
          chunk.push("XX");
        }
      }

      else {
        chunk.push(...numberToPetsciiCodes(addr));
      }
    },
  };

  // Call the user-supplied function, which will return an object that maps
  // line numbers to functions which, when called, place the tokenized Basic
  // commands into the chunk.
  const numbersToLines = fn(commands);

  Object
    // Convert the object into a list of [line number, command] entries
    .entries(numbersToLines)

    // Sort the line numbers numerically
    .sort(
      ([numberA, commandA], [numberB, commandB]) => (
        Number(numberA) > Number(numberB) ? 1 : -1
      )
    )

    // Lay down each one
    .forEach(
      ([lineNum, lineFn]) => {

        // Add a placeholder for the address for the next line, while we're still
        // figuring out the length of this one.
        const posOfNextLinePtr = chunk.length;
        chunk.push("XX", "XX");

        // Declare the line number, in lowbyte/highbyte form.
        // It came from a object key, which is a string
        lineNum = Number(lineNum);
        chunk.push(lineNum & 0xff);
        chunk.push(lineNum >> 8);

        // Lay down the line (which may contain placeholders and generate
        // linker tasks)
        lineFn();

        // Null-terminate the Basic line
        chunk.push(0);

        // Now go back and set the 'next line address' of the current line to
        // the address that the next line is about to use.
        const addrOfNextLine = org + chunk.length;

        chunk[posOfNextLinePtr + 0] = addrOfNextLine & 0xff;
        chunk[posOfNextLinePtr + 1] = addrOfNextLine >> 8;
      }
    )
  ;

  // Two zero bytes instead of an address signifies the end of the Basic program
  chunk.push(0, 0);
}

function assemble(org, fn) {

  let chunk = [];
  const linkerTasks = [];
  const labels = {};

  // --- label tools ---

  const tools = {};

  tools._ = (arg) => {
    if (!Array.isArray(arg)) {
      throw new Error("_ should be called as _``");
    }
    const name = arg[0];
    labels[name] = org + chunk.length;
  }

  tools._.basic = (program) => basic(program, chunk, org, linkerTasks);

  tools._.bytes = (...bytes) => {
    bytes.forEach(
      byte => {
        validateByte(byte);
        chunk.push(byte);
      }
    );
  };

  tools._.l = (arg) => (
    {
      // Calling function will add the `at`
      format: "lo",
      label: arg[0],
    }
  );

  tools._.h = (arg) => (
    {
      // Calling function will add the `at`
      format: "hi",
      label: arg[0],
    }
  );

  tools._.label = (addr, name) => {
    labels[name] = addr;
  };

  // --- ops ---

  for (let insn in opcodes) {
    tools[insn] = {};

    for (let mode in opcodes[insn]) {
      const opcode = opcodes[insn][mode];

      tools[insn][mode] = (arg) => {
        chunk.push(opcode);
        operandHandler[mode](chunk, linkerTasks, arg);
      };
    }
  }

  // "Assemble"
  fn(tools);

  // Link
  link(chunk, org, linkerTasks, labels);

  return chunk;
}


/***/ }),

/***/ "./src/tools/base64.js":
/*!*****************************!*\
  !*** ./src/tools/base64.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base64Decode: () => (/* binding */ base64Decode),
/* harmony export */   base64Encode: () => (/* binding */ base64Encode)
/* harmony export */ });
/*
  Simple, basic Base64 encoding/decoding
*/

const tokens =
  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef" + 
  "ghijklmnopqrstuvwxyz0123456789+/";

function base64Encode(q) {
  let out = "";

  while (q.length) {

    let               w  = q[0] << 16;
    if (q.length > 1) w |= q[1] << 8;
    if (q.length > 2) w |= q[2] << 0;

    //                <--q0--><--q1--><--q2-->
    const o0 = (w & 0b111111000000000000000000) >> 18;
    const o1 = (w & 0b000000111111000000000000) >> 12;
    const o2 = (w & 0b000000000000111111000000) >> 6;
    const o3 = (w & 0b000000000000000000111111) >> 0;

    out +=                  tokens[o0]      ;
    out +=                  tokens[o1]      ;
    out += (q.length > 1) ? tokens[o2] : "=";
    out += (q.length > 2) ? tokens[o3] : "=";

    q = q.slice(3, q.length);
  }

  return out;
}

function base64Decode(q) {
  let out = [];

  while (q.length) {

    const i0 =                tokens.indexOf(q[0])    ;
    const i1 =                tokens.indexOf(q[1])    ;
    const i2 = q[2] !== "=" ? tokens.indexOf(q[2]) : 0;
    const i3 = q[3] !== "=" ? tokens.indexOf(q[3]) : 0;

    const w = (i0 << 18) | (i1 << 12) | (i2 << 6) | (i3 << 0);

                      out.push((w >> 16) & 0xff);
    if (q[2] !== "=") out.push((w >>  8) & 0xff);
    if (q[3] !== "=") out.push((w >>  0) & 0xff);

    q = q.substr(4);
  }

  return out;
}


/***/ }),

/***/ "./src/tools/c64FontCodePoints.js":
/*!****************************************!*\
  !*** ./src/tools/c64FontCodePoints.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c64FontCodePointToChar: () => (/* binding */ c64FontCodePointToChar),
/* harmony export */   charToC64FontCodePoint: () => (/* binding */ charToC64FontCodePoint),
/* harmony export */   hexDigitToC64FontCodePoint: () => (/* binding */ hexDigitToC64FontCodePoint),
/* harmony export */   petsciiToFontCodePoint: () => (/* binding */ petsciiToFontCodePoint)
/* harmony export */ });
/*
   Tools for translating in and out of C64 font codepoints.

   Note that C64 font codepoints aren't PETSCII. They're how PETSCII is
   delivered, but take a different layout. A-Z, for instance, are 65-90 in
   PETSCII (and ASCII for that matter), but occupy positions 1-26 of the font.

   Reference: https://style64.org/petscii/
*/

const ANSI_SGR_REVERSE_ON  = "\x1b[7m";
const ANSI_SGR_REVERSE_OFF = "\x1b[27m";

// The right pair is the 'wide' version, comprising 'full-width' characters,
// and pairs of regular characters. On my text editor, the two don't quite
// match in length, but on my terminal (macOS Terminal) they do. It's a
// pretty tenuous mode.
const CLOSEST_UNICODES = [
  // unshifted   unshifted
  //     shifted      shifted
  [["@", "@"], ["＠", "＠"]], // 0x00 (0)
  [["A", "a"], ["Ａ", "ａ"]], // 0x01 (1)
  [["B", "b"], ["Ｂ", "ｂ"]], // 0x02 (2)
  [["C", "c"], ["Ｃ", "ｃ"]], // 0x03 (3)
  [["D", "d"], ["Ｄ", "ｄ"]], // 0x04 (4)
  [["E", "e"], ["Ｅ", "ｅ"]], // 0x05 (5)
  [["F", "f"], ["Ｆ", "ｆ"]], // 0x06 (6)
  [["G", "g"], ["Ｇ", "ｇ"]], // 0x07 (7)
  [["H", "h"], ["Ｈ", "ｈ"]], // 0x08 (8)
  [["I", "i"], ["Ｉ", "ｉ"]], // 0x09 (9)
  [["J", "j"], ["Ｊ", "ｊ"]], // 0x0a (10)
  [["K", "k"], ["Ｋ", "ｋ"]], // 0x0b (11)
  [["L", "l"], ["Ｌ", "ｌ"]], // 0x0c (12)
  [["M", "m"], ["Ｍ", "ｍ"]], // 0x0d (13)
  [["N", "n"], ["Ｎ", "ｎ"]], // 0x0e (14)
  [["O", "o"], ["Ｏ", "ｏ"]], // 0x0f (15)
  [["P", "p"], ["Ｐ", "ｐ"]], // 0x10 (16)
  [["Q", "q"], ["Ｑ", "ｑ"]], // 0x11 (17)
  [["R", "r"], ["Ｒ", "ｒ"]], // 0x12 (18)
  [["S", "s"], ["Ｓ", "ｓ"]], // 0x13 (19)
  [["T", "t"], ["Ｔ", "ｔ"]], // 0x14 (20)
  [["U", "u"], ["Ｕ", "ｕ"]], // 0x15 (21)
  [["V", "v"], ["Ｖ", "ｖ"]], // 0x16 (22)
  [["W", "w"], ["Ｗ", "ｗ"]], // 0x17 (23)
  [["X", "x"], ["Ｘ", "ｘ"]], // 0x18 (24)
  [["Y", "y"], ["Ｙ", "ｙ"]], // 0x19 (25)
  [["Z", "z"], ["Ｚ", "ｚ"]], // 0x1a (26)
  [["[", "["], ["［", "［"]], // 0x1b (27)
  [["£", "£"], ["￡", "￡"]], // 0x1c (28)
  [["]", "]"], ["］", "］"]], // 0x1d (29)
  [["↑", "↑"], [" ↑", " ↑"]], // 0x1e (30)
  [["←", "←"], [" ←", " ←"]], // 0x1f (31)
  [[" ", " "], ["　", "　"]], // 0x20 (32)
  [["!", "!"], ["！", "！"]], // 0x21 (33)
  [['"', '"'], ["＂", '＂']], // 0x22 (34)
  [["#", "#"], ["＃", "＃"]], // 0x23 (35)
  [["$", "$"], ["＄", "＄"]], // 0x24 (36)
  [["%", "%"], ["％", "％"]], // 0x25 (37)
  [["&", "&"], ["＆", "＆"]], // 0x26 (38)
  [["'", "'"], ["＇", "＇"]], // 0x27 (39)
  [["(", "("], ["（", "（"]], // 0x28 (40)
  [[")", ")"], ["）", "）"]], // 0x29 (41)
  [["*", "*"], ["＊", "＊"]], // 0x2a (42)
  [["+", "+"], ["＋", "＋"]], // 0x2b (43)
  [[",", ","], ["，", "，"]], // 0x2c (44)
  [["-", "-"], ["－", "－"]], // 0x2d (45)
  [[".", "."], ["．", "．"]], // 0x2e (46)
  [["/", "/"], ["／", "／"]], // 0x2f (47)
  [["0", "0"], ["０", "０"]], // 0x30 (48)
  [["1", "1"], ["１", "１"]], // 0x31 (49)
  [["2", "2"], ["２", "２"]], // 0x32 (50)
  [["3", "3"], ["３", "３"]], // 0x33 (51)
  [["4", "4"], ["４", "４"]], // 0x34 (52)
  [["5", "5"], ["５", "５"]], // 0x35 (53)
  [["6", "6"], ["６", "６"]], // 0x36 (54)
  [["7", "7"], ["７", "７"]], // 0x37 (55)
  [["8", "8"], ["８", "８"]], // 0x38 (56)
  [["9", "9"], ["９", "９"]], // 0x39 (57)
  [[":", ":"], ["：", "："]], // 0x3a (58)
  [[";", ";"], ["；", "；"]], // 0x3b (59)
  [["<", "<"], ["＜", "＜"]], // 0x3c (60)
  [["=", "="], ["＝", "＝"]], // 0x3d (61)
  [[">", ">"], ["＞", "＞"]], // 0x3e (62)
  [["?", "?"], ["？", "？"]], // 0x3f (63)
  [["─", "─"], ["－", "──"]], // 0x40 (64)
  [["♠", "A"], [" ♠", "Ａ"]], // 0x41 (65)
  [["│", "B"], ["｜", "Ｂ"]], // 0x42 (66)
  [["─", "C"], ["──", "Ｃ"]], // 0x43 (67)
  [["─", "D"], ["──", "Ｄ"]], // 0x44 (68)
  [["▔", "E"], ["￣", "Ｅ"]], // 0x45 (69)
  [["─", "F"], ["──", "Ｆ"]], // 0x46 (70)
  [["│", "G"], ["｜", "Ｇ"]], // 0x47 (71)
  [["│", "H"], ["｜", "Ｈ"]], // 0x48 (72)
  [["╮", "I"], ["─╮", "Ｉ"]], // 0x49 (73)
  [["╰", "J"], [" ╰", "Ｊ"]], // 0x4a (74)
  [["╯", "K"], ["─╯", "Ｋ"]], // 0x4b (75)
  [["⌞", "L"], [" ⌞", "Ｌ"]], // 0x4c (76)
  [["╲", "M"], [" ╲", "Ｍ"]], // 0x4d (77)
  [["╱", "N"], [" ╱", "Ｎ"]], // 0x4e (78)
  [["⌜", "O"], [" ⌜", "Ｏ"]], // 0x4f (79)
  [["⌝", "P"], ["▔⌝", "Ｐ"]], // 0x50 (80)
  [["●", "Q"], [" ●", "Ｑ"]], // 0x51 (81)
  [["_", "R"], ["＿", "Ｒ"]], // 0x52 (82)
  [["♥", "S"], [" ♥", "Ｓ"]], // 0x53 (83)
  [["▎", "T"], ["│ ", "Ｔ"]], // 0x54 (84)
  [["╭", "U"], [" ╭", "Ｕ"]], // 0x55 (85)
  [["╳", "V"], ["><", "Ｖ"]], // 0x56 (86)
  [["○", "W"], [" ○", "Ｗ"]], // 0x57 (87)
  [["♣", "X"], [" ♣", "Ｘ"]], // 0x58 (88)
  [["▕", "Y"], [" ▕", "Ｙ"]], // 0x59 (89)
  [["♦", "Z"], [" ♦", "Ｚ"]], // 0x5a (90)
  [["┼", "┼"], ["─┼", "─┼"]], // 0x5b (91)
  [["▒", "▒"], ["▒ ", "▒ "]], // 0x5c (92)
  [["│", "│"], [" │", " │"]], // 0x5d (93)
  [["π", "▒"], [" π", "▒▒"]], // 0x5e (94)
  [["◥", "▒"], [" ◥", "▒▒"]], // 0x5f (95)
  [[" ", " "], ["  ", "  "]], // 0x60 (96)
  [["▌", "▌"], ["▌ ", "▌ "]], // 0x61 (97)
  [["▄", "▄"], ["▄▄", "▄▄"]], // 0x62 (98)
  [["▔", "▔"], ["▔▔", "▔▔"]], // 0x63 (99)
  [["▁", "▁"], ["▁▁", "▁▁"]], // 0x64 (100)
  [["▎", "▎"], ["▎ ", "▎ "]], // 0x65 (101)
  [["▒", "▒"], ["▒▒", "▒▒"]], // 0x66 (102)
  [["▕", "▕"], [" ▕", " ▕"]], // 0x67 (103)
  [["▒", "▒"], ["▒▒", "▒▒"]], // 0x68 (104)
  [["◤", "▒"], [" ◤", "▒▒"]], // 0x69 (105)
  [["▕", "▕"], [" ▕", " ▕"]], // 0x6a (106)
  [["├", "├"], [" ├", " ├"]], // 0x6b (107)
  [["▗", "▗"], [" ▄", " ▄"]], // 0x6c (108)
  [["└", "└"], [" └", " └"]], // 0x6d (109)
  [["┐", "┐"], ["─┐", "─┐"]], // 0x6e (110)
  [["▂", "▂"], ["▂▂", "▂▂"]], // 0x6f (111)
  [["┌", "┌"], [" ┌", " ┌"]], // 0x70 (112)
  [["┴", "┴"], ["─┴", "─┴"]], // 0x71 (113)
  [["┬", "┬"], ["─┬", "─┬"]], // 0x72 (114)
  [["┤", "┤"], ["─┤", "─┤"]], // 0x73 (115)
  [["▎", "▎"], ["▎ ", "▎ "]], // 0x74 (116)
  [["▍", "▍"], ["▍ ", "▍ "]], // 0x75 (117)
  [["▕", "▕"], [" ▕", "▕ "]], // 0x76 (118)
  [["▔", "▔"], ["▔▔", "▔▔"]], // 0x77 (119)
  [["▔", "▔"], ["▔▔", "▔▔"]], // 0x78 (120)
  [["▃", "▃"], ["▃▃", "▃▃"]], // 0x79 (121)
  [["⌟", "✓"], ["▁⌟", " ✓"]], // 0x7a (122)
  [["▖", "▖"], ["▃ ", "▃ "]], // 0x7b (123)
  [["▝", "▝"], [" ▝", " ▝"]], // 0x7c (124)
  [["┘", "┘"], ["─┘", "─┘"]], // 0x7d (125)
  [["▘", "▘"], ["▘ ", "▘ "]], // 0x7e (126)
  [["▚", "▚"], ["▚▄", "▚▄"]], // 0x7f (127)
];

function c64FontCodePointToChar(byte, shifted, wide) {
  if (byte >= 0x80) {
    return (
      ANSI_SGR_REVERSE_ON +
      c64FontCodePointToChar(byte & 0x7f, shifted, wide) +
      ANSI_SGR_REVERSE_OFF
    );
  };

  return CLOSEST_UNICODES[byte][wide ? 1 : 0][shifted ? 1 : 0];
}

function charToC64FontCodePoint(char, shifted) {
  if (!shifted) {
    // Quick cases
    if ((char >= "0") && (char <= "9")) return char.charCodeAt(0);
    if ((char >= "A") && (char <= "Z")) return char.charCodeAt(0) - 0x40;
    if ((char >= "a") && (char <= "z")) return char.charCodeAt(0) - 0x60;
    if (char === " ")                   return 0x20;
  }

  for (let i = 0; i < 128; i++) {
    if (CLOSEST_UNICODES[i][0][shifted ? 1 : 0] === char) return i; 
  }

  return 0x20;
}

const hexDigitToC64FontCodePoint = [
  0x30, 0x31, 0x32, 0x33,
  0x34, 0x35, 0x36, 0x37,
  0x38, 0x39, 0x01, 0x02,
  0x03, 0x04, 0x05, 0x06,
];

function petsciiToFontCodePoint(num) {
  // See Kernal around $e737
  if (num <  0x20) return 0x20;
  if (num >= 0x60) return num & 0xdf;
  else             return num & 0x3f;
}


/***/ }),

/***/ "./src/tools/disasm.js":
/*!*****************************!*\
  !*** ./src/tools/disasm.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   disasm: () => (/* binding */ disasm)
/* harmony export */ });
/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../debug */ "./src/debug.js");
/*
   A disassembler for live memory
*/



// Adapted from https://www.masswerk.at/6502/6502_instruction_set.html
// TODO: This doesn't include the quasi-ops
const opcodes = [
/*       x0           x1           x2       x3     x4           x5           x6           x7     x8          x9           xA          xB     xC           xD           xE           xF  */
/* 0x */ "BRK impl",  "ORA X,ind", "---",   "---", "---",       "ORA zpg",   "ASL zpg",   "---", "PHP impl", "ORA #",     "ASL A",    "---", "---",       "ORA abs",   "ASL abs",   "---",
/* 1x */ "BPL rel",   "ORA ind,Y", "---",   "---", "---",       "ORA zpg,X", "ASL zpg,X", "---", "CLC impl", "ORA abs,Y", "---",      "---", "---",       "ORA abs,X", "ASL abs,X", "---",
/* 2x */ "JSR abs",   "AND X,ind", "---",   "---", "BIT zpg",   "AND zpg",   "ROL zpg",   "---", "PLP impl", "AND #",     "ROL A",    "---", "BIT abs",   "AND abs",   "ROL abs",   "---",
/* 3x */ "BMI rel",   "AND ind,Y", "---",   "---", "---",       "AND zpg,X", "ROL zpg,X", "---", "SEC impl", "AND abs,Y", "---",      "---", "---",       "AND abs,X", "ROL abs,X", "---",
/* 4x */ "RTI impl",  "EOR X,ind", "---",   "---", "---",       "EOR zpg",   "LSR zpg",   "---", "PHA impl", "EOR #",     "LSR A",    "---", "JMP abs",   "EOR abs",   "LSR abs",   "---",
/* 5x */ "BVC rel",   "EOR ind,Y", "---",   "---", "---",       "EOR zpg,X", "LSR zpg,X", "---", "CLI impl", "EOR abs,Y", "---",      "---", "---",       "EOR abs,X", "LSR abs,X", "---",
/* 6x */ "RTS impl",  "ADC X,ind", "---",   "---", "---",       "ADC zpg",   "ROR zpg",   "---", "PLA impl", "ADC #",     "ROR A",    "---", "JMP ind",   "ADC abs",   "ROR abs",   "---",
/* 7x */ "BVS rel",   "ADC ind,Y", "---",   "---", "---",       "ADC zpg,X", "ROR zpg,X", "---", "SEI impl", "ADC abs,Y", "---",      "---", "---",       "ADC abs,X", "ROR abs,X", "---",
/* 8x */ "---",       "STA X,ind", "---",   "---", "STY zpg",   "STA zpg",   "STX zpg",   "---", "DEY impl", "---",       "TXA impl", "---", "STY abs",   "STA abs",   "STX abs",   "---",
/* 9x */ "BCC rel",   "STA ind,Y", "---",   "---", "STY zpg,X", "STA zpg,X", "STX zpg,Y", "---", "TYA impl", "STA abs,Y", "TXS impl", "---", "---",       "STA abs,X", "---",       "---",
/* Ax */ "LDY #",     "LDA X,ind", "LDX #", "---", "LDY zpg",   "LDA zpg",   "LDX zpg",   "---", "TAY impl", "LDA #",     "TAX impl", "---", "LDY abs",   "LDA abs",   "LDX abs",   "---",
/* Bx */ "BCS rel",   "LDA ind,Y", "---",   "---", "LDY zpg,X", "LDA zpg,X", "LDX zpg,Y", "---", "CLV impl", "LDA abs,Y", "TSX impl", "---", "LDY abs,X", "LDA abs,X", "LDX abs,Y", "---",
/* Cx */ "CPY #",     "CMP X,ind", "---",   "---", "CPY zpg",   "CMP zpg",   "DEC zpg",   "---", "INY impl", "CMP #",     "DEX impl", "---", "CPY abs",   "CMP abs",   "DEC abs",   "---",
/* Dx */ "BNE rel",   "CMP ind,Y", "---",   "---", "---",       "CMP zpg,X", "DEC zpg,X", "---", "CLD impl", "CMP abs,Y", "---",      "---", "---",       "CMP abs,X", "DEC abs,X", "---",
/* Ex */ "CPX #",     "SBC X,ind", "---",   "---", "CPX zpg",   "SBC zpg",   "INC zpg",   "---", "INX impl", "SBC #",     "NOP impl", "---", "CPX abs",   "SBC abs",   "INC abs",   "---",
/* Fx */ "BEQ rel",   "SBC ind,Y", "---",   "---", "---",       "SBC zpg,X", "INC zpg,X", "---", "SED impl", "SBC abs,Y", "---",      "---", "---",       "SBC abs,X", "INC abs,X", "---",
];

// Number of bytes that need to be read for opcodes of each addressing mode,
// including the opcode itself
const bytesForOpcode = opcodes.map(
  opcode => ({
      "abs":   3,
      "abs,X": 3,
      "abs,Y": 3,
      "ind":   3,
      "zpg":   2,
      "zpg,X": 2,
      "zpg,Y": 2,
      "rel":   2,
      "X,ind": 2,
      "ind,Y": 2,
      "#":     2,
      "A":     1,
      "impl":  1,
      "":      1
    })[opcode.substring(4)]
);

function uint8ToNum(b) {
  return b < 0x80 ? b : -(256 - b);
}

function disasm(cpuRead, addr, to) {

  const lines = [];

  while (addr < to) {

    // Display the address
    let line = `${(0,_debug__WEBPACK_IMPORTED_MODULE_0__.$xxxx)(addr)}: `;

    // Display the instruction's raw bytes, however many there might be
    const b0 = cpuRead((addr + 0) & 0xffff);
    const b1 = cpuRead((addr + 1) & 0xffff);
    const b2 = cpuRead((addr + 2) & 0xffff);

    const length = bytesForOpcode[b0];

    line += (               (0,_debug__WEBPACK_IMPORTED_MODULE_0__.xx)(b0)       ) + " ";
    line += ((length > 1) ? (0,_debug__WEBPACK_IMPORTED_MODULE_0__.xx)(b1) : "  ") + " ";
    line += ((length > 2) ? (0,_debug__WEBPACK_IMPORTED_MODULE_0__.xx)(b2) : "  ") + " ";
    line += "  ";

    // Display the opcode
    const op   = opcodes[b0].substring(0, 3);
    const mode = opcodes[b0].substring(4);
    line += op;

    // Display the parameters
    const table = {
      "A":     () => ``,
      "impl":  () => ``,
      "zpg":   () => ` ${(0,_debug__WEBPACK_IMPORTED_MODULE_0__.$xx)(b1)}`,
      "zpg,X": () => ` ${(0,_debug__WEBPACK_IMPORTED_MODULE_0__.$xx)(b1)},X`,
      "zpg,Y": () => ` ${(0,_debug__WEBPACK_IMPORTED_MODULE_0__.$xx)(b1)},Y`,
      "abs":   () => ` ${(0,_debug__WEBPACK_IMPORTED_MODULE_0__.$xx)(b2, 2)}${(0,_debug__WEBPACK_IMPORTED_MODULE_0__.xx)(b1, 2)}`,
      "abs,X": () => ` ${(0,_debug__WEBPACK_IMPORTED_MODULE_0__.$xx)(b2, 2)}${(0,_debug__WEBPACK_IMPORTED_MODULE_0__.xx)(b1, 2)},X`,
      "abs,Y": () => ` ${(0,_debug__WEBPACK_IMPORTED_MODULE_0__.$xx)(b2, 2)}${(0,_debug__WEBPACK_IMPORTED_MODULE_0__.xx)(b1, 2)},Y`,
      "ind":   () => ` (${(0,_debug__WEBPACK_IMPORTED_MODULE_0__.$xx)(b2, 2)}${(0,_debug__WEBPACK_IMPORTED_MODULE_0__.xx)(b1, 2)})`,
      "X,ind": () => ` (${(0,_debug__WEBPACK_IMPORTED_MODULE_0__.$xx)(b1)},X)`,
      "ind,Y": () => ` (${(0,_debug__WEBPACK_IMPORTED_MODULE_0__.$xx)(b1, 2)}),Y`,
      "#":     () => ` #${(0,_debug__WEBPACK_IMPORTED_MODULE_0__.$xx)(b1, 2)}`,
      "rel":   () => ` ${(0,_debug__WEBPACK_IMPORTED_MODULE_0__.$xxxx)(addr + uint8ToNum(b1) + 2)}`,
      "":      () => ``,
    };

    line += table[mode]();
    addr += length;

    lines.push(line);
  }

  return lines.join("\n");
}


/***/ }),

/***/ "./src/tools/loadPrg.js":
/*!******************************!*\
  !*** ./src/tools/loadPrg.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   loadPrg: () => (/* binding */ loadPrg)
/* harmony export */ });
/* harmony import */ var _tools_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/parser */ "./src/tools/parser.js");
/*
   A tool for injecting PRG files (C64 programs) into memory.

   The file format is super-simple: it's just the load address (in lowbyte/
   highbyte form) followed by an arbitrary sequence of bytes to store there.
   But there's a little more manipulation required than just blasting them in.
   (TODO: ...that's based on guesswork, looking at obvious pointers in the
   memory map and seeing what works. I should stufy the Kernal's file loader at
   some point to see if there's anything else.)
*/



const parsePrg = (0,_tools_parser__WEBPACK_IMPORTED_MODULE_0__.makeParser)((_) => ({
  org:     _.word_le(),
  program: _.remainder(),
}));

function loadPrg(c64, bytes) {
  const {wires: {cpuRead, cpuWrite}} = c64;

  const { org, program } = parsePrg(bytes);

  if (org !== 0x0801) {
    console.warn("Expecting PRGs to be loaded to $0801");
  }

  // Make a record of the current memory map configuation
  const dir  = cpuRead(0);
  const port = cpuRead(1);

  // Set the memory map to all-RAM. In other words, page out the MMIO, in case
  // the PRG's really big.
  cpuWrite(0, 0b111);
  cpuWrite(1, 0);

  // Perform the main write
  for (let i = 0; i < program.length; i++) cpuWrite(org + i, program[i]);

  // Having loaded the program into memory, we need to move the pointers to
  // Basic's variable regions to right after the program. Normally the Kernal's
  // loader would do this (and maybe we should be relying on that to load in
  // PRGs instead). If it's not done, Basic programs won't work, as the space
  // they'll allocate for the variables will overwrite the start of the program
  // itself.
  const endOfBasicPrg = 0x0801 + program.length;

  const hi = endOfBasicPrg >> 8;
  const lo = endOfBasicPrg & 0xff;

  cpuWrite(0x2d, lo); // pointer to beginning of variable area, low-byte
  cpuWrite(0x2e, hi); // pointer to beginning of variable area, high-byte

  cpuWrite(0x2f, lo); // pointer to beginning of array variable area, low-byte
  cpuWrite(0x30, hi); // pointer to beginning of array variable area, high-byte

  cpuWrite(0x31, lo); // pointer to end of array variable area, low-byte
  cpuWrite(0x32, hi); // pointer to end of array variable area, high-byte

  // Restore the CPU port, to return the memory mapping to what it was
  cpuWrite(0, dir);
  cpuWrite(1, port);
}


/***/ }),

/***/ "./src/tools/palettes.js":
/*!*******************************!*\
  !*** ./src/tools/palettes.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   colorColorPalettes: () => (/* binding */ colorColorPalettes),
/* harmony export */   grayscalePalette: () => (/* binding */ grayscalePalette),
/* harmony export */   highlightPalettes: () => (/* binding */ highlightPalettes),
/* harmony export */   systemPalette: () => (/* binding */ systemPalette)
/* harmony export */ });
const systemPalette = [
  0x000000,  // black
  0xffffff,  // white
  0x994444,  // red
  0x88cccc,  // cyan
  0x9955bb,  // purple
  0x77bb44,  // green
  0x4433aa,  // blue
  0xdddd77,  // yellow
  0x996622,  // orange
  0x664400,  // brown
  0xcc8888,  // pink
  0x666666,  // dark gray
  0x888888,  // mid gray
  0xbbee99,  // light green
  0x8877dd,  // light blue
  0xbbbbbb,  // light gray
];

// A reassignment of luminance values to the default palette for when it's
// reduced to grayscale. Many colors would map to the same values under the
// usual HSL formula; this distributes them enough that they're all
// distinguishable against each other.
const adjustedL = [
    0,       // black
  100,       // white
   40,       // red
   64,       // cyan
   46,       // purple
   52,       // green
   34,       // blue
   82,       // yellow
   22,       // orange
   16,       // brown
   70,       // pink
   28,       // dark gray
   58,       // mid gray
   94,       // light green
   76,       // light blue
   88,       // light gray
];

const grayscalePalette = systemPalette.map(
  (rgb, index) => {

    const r = (rgb & 0xff0000) >> 16;
    const g = (rgb & 0x00ff00) >>  8;
    const b = (rgb & 0x0000ff) >>  0;

    // Convert to HSL
    const [h, s, l] = rgbToHsl(r, g, b);

    // ...and then back to RGB, with no saturation, and scaled, nudged luminance
    {
      const [r, g, b] = hslToRgb(
        h,
        0,
        lerp(adjustedL[index], 0, 100, 20, 60)
      );

      return rgbToInt(r, g, b);
    }
  }
);


// highlightPalettes: an array of 8 palettes.
// highlightPalettes[0][colorCode] would give a red-ish highlight for colorCode.
// highlightPalettes[1][colorCode] would be more orange, etc.
const highlightPalettes = [];

for (let i = 0; i < 8; i++) {

  highlightPalettes[i] = new Array(16);

  for (let cc = 0; cc < 16; cc++) {

    const [r, g, b] = hslToRgb(
      // Make each index 45° around the color wheel
      i * (360 / 8),
      // ...with a fixed saturation that's not excessive
      50,
      // ...and a luminance that's proportional to the (nudged) original,
      // scaled to avoid it being over-bright, or too dark to clearly see the
      // hue.
      lerp(adjustedL[cc], 0, 100, 45, 70)
    );

    highlightPalettes[i][cc] = rgbToInt(r, g, b);
  }
}


// colorColorPalettes: an array of 16 palettes.
// colorColorPalettes[2][3] would give color code 2 (red), with a hint of the
// (nudged) grayscale brightness of color code 3 (cyan)
const colorColorPalettes = [];

for (let i = 0; i < 16; i++) {

  colorColorPalettes[i] = new Array(16);
  const [h, s, l] = rgbToHsl(...intToRgb(systemPalette[i]));

  for (let j = 0; j < 16; j++) {

    const modulatedL = lerp(
      l + (((adjustedL[j] - 50) / 100) * 10),
      -5,
      105,
      0,
      100
    );

    const [r, g, b] = hslToRgb(h, s, modulatedL);

    colorColorPalettes[i][j] = rgbToInt(r, g, b);
  }
}


function lerp(val, srcMin, srcMax, destMin, destMax) {
  return destMin + (((val - srcMin) / (srcMax - srcMin)) * (destMax - destMin));
}

function rgbToHsl(r,g,b) {
  // Source: https://css-tricks.com/converting-color-spaces-in-javascript/

  // Make r, g, and b fractions of 1
  r /= 255;
  g /= 255;
  b /= 255;

  // Find greatest and smallest channel values
  let cmin = Math.min(r,g,b);
  let cmax = Math.max(r,g,b);
  let delta = cmax - cmin;
  let h = 0;
  let s = 0;
  let l = 0;

  // Calculate hue
  // No difference
  if      (delta === 0) h = 0;
  else if (cmax === r)  h = ((g - b) / delta) % 6;
  else if (cmax === g)  h =  (b - r) / delta + 2;
  else                  h =  (r - g) / delta + 4;

  h = Math.round(h * 60);
    
  // Make negative hues positive behind 360°
  if (h < 0) h += 360;

   // Calculate lightness
  l = (cmax + cmin) / 2;

  // Calculate saturation
  s = delta === 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
    
  // Multiply l and s by 100
  s = +(s * 100).toFixed(1);
  l = +(l * 100).toFixed(1);

  return [h, s, l];
}

function hslToRgb(h,s,l) {
  // Source: https://css-tricks.com/converting-color-spaces-in-javascript/

  // Must be fractions of 1
  s /= 100;
  l /= 100;

  let c = (1 - Math.abs(2 * l - 1)) * s;
  let x = c * (1 - Math.abs((h / 60) % 2 - 1));
  let m = l - c/2;
  let r = 0;
  let g = 0;
  let b = 0;

  if      (  0 <= h && h < 60 ) { r = c; g = x; b = 0; }
  else if ( 60 <= h && h < 120) { r = x; g = c; b = 0; }
  else if (120 <= h && h < 180) { r = 0; g = c; b = x; }
  else if (180 <= h && h < 240) { r = 0; g = x; b = c; }
  else if (240 <= h && h < 300) { r = x; g = 0; b = c; }
  else if (300 <= h && h < 360) { r = c; g = 0; b = x; }
  
  r = Math.round((r + m) * 255);
  g = Math.round((g + m) * 255);
  b = Math.round((b + m) * 255);

  return [r, g, b];
}

function intToRgb(i) {
  return [
    (i >> 16) & 0xff,
    (i >>  8) & 0xff,
    (i >>  0) & 0xff,
  ];
}

function rgbToInt(r, g, b) {
  return (
    (Math.floor(r) << 16) |
    (Math.floor(g) <<  8) |
    (Math.floor(b) <<  0)
  );
}


/***/ }),

/***/ "./src/tools/parser.js":
/*!*****************************!*\
  !*** ./src/tools/parser.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   makeParser: () => (/* binding */ makeParser)
/* harmony export */ });
/*
  makeParser turns schema functions into parsers that can turn byte arrays to
  structures.

  ...meaning that you can create a parser with:

            const myParser = makeParser((_) => ({
              desc:    _.string(32),
              version: _.byte(),
              _:       _.skip(2),
              start:   _.word_le(),
              length:  _.long_le(),
            };

  ...then call it with:

            const myStruct = myParser([.., .., ..]);

  ...to get:

            {
              desc:    "...",
              version: 4,
              start:   12,
              length:  1048576,
            }

  ...or an exception if data overflows.

  Note that you'll have to be explicit about the byte ordering of words
  (16-bit) and longs (32-bit): use suffix _be for big endian and _le for
  little-endian.
*/

function makeParser(fn) {
  return (bytes) => {

    let offset = 0;
    function nextByte() {
      if (offset >= bytes.length) {
        throw new Error("Reading past the end of data");
      }
      return bytes[offset++];
    } 

    function remainder() {
      const ret = bytes.slice(offset);
      offset = bytes.length - 1;
      return ret;
    }

    return fn({
      byte:      () => byte(nextByte),
      word_be:   () => word_be(nextByte),
      word_le:   () => word_le(nextByte),
      long_be:   () => long_be(nextByte),
      long_le:   () => long_le(nextByte),
      skip:      (length) => skip(nextByte, length),
      string:    (length) => string(nextByte, length),
      remainder,
    });
  };
}

function byte(nextByte) {
  return nextByte();
}

function word_le(nextByte) {
  return nextByte() | (nextByte() << 8);
}

function word_be(nextByte) {
  return (nextByte() << 8) | nextByte();
}

function long_le(nextByte) {
  return (
    (nextByte() << 0)  ||
    (nextByte() << 8)  ||
    (nextByte() << 16) ||
    (nextByte() << 24)
  );
}

function long_be(nextByte) {
  return (
    (nextByte() << 24)  ||
    (nextByte() << 16)  ||
    (nextByte() << 8)   ||
    (nextByte() << 0)
  );
}

function skip(nextByte, length) {
  for (let i = 0; i < length; i++) nextByte();
}

function string(nextByte, length) {
  let ret = "";
  let ended = false;

  for (let offset = 0; offset < length; offset++) {
    const byte = nextByte();
    if (ended) continue;
    if (!byte) ended = true;
    else ret += String.fromCharCode(byte);
  }

  return ret.trim();
}


/***/ }),

/***/ "./src/tools/romLocations.js":
/*!***********************************!*\
  !*** ./src/tools/romLocations.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AWAIT_KEYBOARD_PC: () => (/* binding */ AWAIT_KEYBOARD_PC),
/* harmony export */   CLEAR_SCREEN_PC: () => (/* binding */ CLEAR_SCREEN_PC),
/* harmony export */   CURSOR_COL_ADDR: () => (/* binding */ CURSOR_COL_ADDR),
/* harmony export */   KEYBOARD_BUFFER_ADDR: () => (/* binding */ KEYBOARD_BUFFER_ADDR),
/* harmony export */   KEYBOARD_BUFFER_INDEX: () => (/* binding */ KEYBOARD_BUFFER_INDEX),
/* harmony export */   KEYBOARD_BUFFER_LENGTH: () => (/* binding */ KEYBOARD_BUFFER_LENGTH),
/* harmony export */   READY_PC: () => (/* binding */ READY_PC)
/* harmony export */ });
// Addresses of notable routines and buffers in Basic or Kernal. 
// Handy for use as breakpoints when controlling the runloop from a script.

// Warm start (prints the READY. prompt)
const READY_PC = 0xa474;

// A loop that waits for a key to be typed
const AWAIT_KEYBOARD_PC = 0xe5cd;

// Clear screen
const CLEAR_SCREEN_PC = 0xe544;


// Below are address that aren't ROM locations, but magic numbers hardcoded
// into the ROM routines.

// Cursor color code
const CURSOR_COL_ADDR = 0x0286;

// The keyboard buffer
const KEYBOARD_BUFFER_ADDR   = 0x0277; // 'keyd'
const KEYBOARD_BUFFER_INDEX  = 0x00c6; // 'ndx'
const KEYBOARD_BUFFER_LENGTH = 10;


/***/ }),

/***/ "./src/tools/serializerSupport.js":
/*!****************************************!*\
  !*** ./src/tools/serializerSupport.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addToSerializerRegistry: () => (/* binding */ addToSerializerRegistry),
/* harmony export */   functionToReference: () => (/* binding */ functionToReference),
/* harmony export */   referenceToFunction: () => (/* binding */ referenceToFunction)
/* harmony export */ });
const registry = {};

function addToSerializerRegistry(obj) {
  for (let fnName in obj) {

    if (registry[fnName] !== undefined) {
      throw new Error(`Multiple functions named ${name} added to serializer registry`);
    }

    registry[fnName] = obj[fnName];
  }
}

function functionToReference(fn) {
  if (fn === null) return null;

  // This could alternatively be done with a Map where the keys are functions,
  // but it's such an infrequently-called helper, why spend the extra memory?
  for (let i in registry) {
    if (registry[i] === fn) return i;
  }

  console.error("Serializer registry has no entry for function:", fn);
  throw new Error(`Serializer registry has no entry for function`);
}

function referenceToFunction(name) {
  if (name === null) return null;

  if (registry[name] === undefined) {
    throw new Error(`Serializer registry has no entry for a function named ${name}`);
  }

  return registry[name];
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!******************************!*\
  !*** ./src/entry/web-dev.js ***!
  \******************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _host_video_canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../host/video-canvas */ "./src/host/video-canvas.js");
/* harmony import */ var _host_audio_OscillatorNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../host/audio-OscillatorNode */ "./src/host/audio-OscillatorNode.js");
/* harmony import */ var _host_joystick_KeyboardEvent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../host/joystick-KeyboardEvent */ "./src/host/joystick-KeyboardEvent.js");
/* harmony import */ var _host_keyboard_KeyboardEvent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../host/keyboard-KeyboardEvent */ "./src/host/keyboard-KeyboardEvent.js");
/* harmony import */ var _target_wires__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../target/wires */ "./src/target/wires.js");
/* harmony import */ var _target_ram__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../target/ram */ "./src/target/ram.js");
/* harmony import */ var _target_vic__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../target/vic */ "./src/target/vic.js");
/* harmony import */ var _target_sid__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../target/sid */ "./src/target/sid.js");
/* harmony import */ var _target_cias__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../target/cias */ "./src/target/cias.js");
/* harmony import */ var _target_cpu__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../target/cpu */ "./src/target/cpu.js");
/* harmony import */ var _target_tape__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../target/tape */ "./src/target/tape.js");
/* harmony import */ var _target_rom_basic__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../target/rom/basic */ "./src/target/rom/basic.js");
/* harmony import */ var _target_rom_skipRamTest__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../target/rom/skipRamTest */ "./src/target/rom/skipRamTest.js");
/* harmony import */ var _target_rom_character__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../target/rom/character */ "./src/target/rom/character.js");
/* harmony import */ var _target_bringup__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../target/bringup */ "./src/target/bringup.js");
/* harmony import */ var _monitor__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../monitor */ "./src/monitor.js");
/* harmony import */ var _host_webFrontEnd__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../host/webFrontEnd */ "./src/host/webFrontEnd/index.js");
/* harmony import */ var _host_dragAndDrop__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../host/dragAndDrop */ "./src/host/dragAndDrop.js");
// Host interfaces





// Target devices








// ROMs




// Bringup


// Everything else





const c64 = (0,_target_bringup__WEBPACK_IMPORTED_MODULE_14__.bringup)({
  host:   { audio: _host_audio_OscillatorNode__WEBPACK_IMPORTED_MODULE_1__.attach, video: _host_video_canvas__WEBPACK_IMPORTED_MODULE_0__.attach, keyboard: _host_keyboard_KeyboardEvent__WEBPACK_IMPORTED_MODULE_3__.attach, joystick: _host_joystick_KeyboardEvent__WEBPACK_IMPORTED_MODULE_2__.attach },
  target: { wires: _target_wires__WEBPACK_IMPORTED_MODULE_4__.attach, ram: _target_ram__WEBPACK_IMPORTED_MODULE_5__.attach, vic: _target_vic__WEBPACK_IMPORTED_MODULE_6__.attach, sid: _target_sid__WEBPACK_IMPORTED_MODULE_7__.attach, cpu: _target_cpu__WEBPACK_IMPORTED_MODULE_9__.attach, cias: _target_cias__WEBPACK_IMPORTED_MODULE_8__.attach, tape: _target_tape__WEBPACK_IMPORTED_MODULE_10__.attach, basic: _target_rom_basic__WEBPACK_IMPORTED_MODULE_11__["default"], kernal: _target_rom_skipRamTest__WEBPACK_IMPORTED_MODULE_12__["default"], character: _target_rom_character__WEBPACK_IMPORTED_MODULE_13__["default"] },
  attachments: [
    _monitor__WEBPACK_IMPORTED_MODULE_15__.attach,
    _host_dragAndDrop__WEBPACK_IMPORTED_MODULE_17__.attach,
    _host_webFrontEnd__WEBPACK_IMPORTED_MODULE_16__.attach,
  ],
});

c64.runloop.run();


// To run a test program on load, uncomment the below:
/*
import { ingest } from "../host/ingest";
import prg from "../tests/tod-prg.js";

ingest(c64, ".prg", prg);
*/

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNPO0FBQ1A7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ08sMEJBQTBCLFFBQVE7QUFDbEMsMEJBQTBCLFVBQVU7QUFDM0M7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEtBQUs7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQzVXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDckZxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGtEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEdvRDtBQUNDO0FBQ0s7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5REFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esd0JBQXdCLHlEQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0VBQWlCO0FBQzdDLEVBQUUsdURBQU87QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLE1BQU07QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQzNMQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3BCMkM7QUFDZTtBQUMxRDtBQUNBO0FBQ087QUFDUDtBQUNBLDRCQUE0QixrRUFBaUI7QUFDN0M7QUFDQSxFQUFFLHVEQUFPO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDWnlEO0FBQ007QUFDSztBQUNMO0FBQ2I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlEQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMEJBQTBCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBLFFBQVEsZ0ZBQXNCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNkNBQUssY0FBYyxHQUFHLDZDQUFLLDJCQUEyQjtBQUN2RixpQ0FBaUMsNkNBQUsscUJBQXFCO0FBQzNELGlDQUFpQyw2Q0FBSyxxQkFBcUI7QUFDM0Qsb0NBQW9DLGNBQWMsU0FBUyxpQkFBaUI7QUFDNUUscUNBQXFDLDZDQUFLLGdCQUFnQixHQUFHLDZDQUFLLCtCQUErQjtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseURBQVE7QUFDcEM7QUFDQSxVQUFVLDZDQUE2QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZEQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQztBQUNBLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQztBQUNBLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQztBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQztBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0Esb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQztBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFdBQVc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2T29EO0FBQ0M7QUFDSztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseURBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtFQUFpQjtBQUM3QztBQUNBLEVBQUUsdURBQU87QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsaUJBQWlCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEY2QztBQUNhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5REFBVTtBQUMzQjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0VBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hDMkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNDO0FBQzVDO0FBQ0E7QUFDQSxlQUFlLG1EQUFVO0FBQ3pCLGVBQWUsbURBQVU7QUFDekIsZUFBZSxtREFBVTtBQUN6QixlQUFlLG1EQUFVO0FBQ3pCLGVBQWUsbURBQVU7QUFDekIsZUFBZSxxREFBVztBQUMxQjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pGNEI7QUFDNUI7QUFJMkI7QUFDM0I7QUFDZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvQ0FBb0M7QUFDOUMsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGlFQUEwQjtBQUNoQyxNQUFNLGdFQUF5QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG9FQUE2QjtBQUNuQyxNQUFNLG1FQUE0QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix5RUFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFNBQVMsTUFBTTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxNQUFNO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQzVLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sYUFBYTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLElBQUk7QUFDSjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwwQkFBMEI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYyxHQUFHO0FBQy9CLGVBQWUsY0FBYyxHQUFHO0FBQ2hDLGFBQWEsY0FBYyxHQUFHO0FBQzlCLFlBQVksY0FBYyxHQUFHO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUM3TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxJQUFJLDZEQUE2RDtBQUNqRSxJQUFJLDZEQUE2RDtBQUNqRSxJQUFJLDZEQUE2RDtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDhCQUE4QiwrQkFBK0I7QUFDN0Q7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQzFEcUQ7QUFDckQ7QUFDQTtBQUNBLGlFQUFlLDJEQUFZLG9oWUFBb2hZLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNIMy9YO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLDJEQUFZLDRvZEFBNG9kLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6QnhvZDtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFIb0Q7QUFDSDtBQUNzQjtBQUNwQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0Q0FBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQ0FBZ0M7QUFDM0QsMkJBQTJCLGdDQUFnQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdGQUFzQjtBQUM1QztBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQSxrQkFBa0IsNkRBQU87QUFDekI7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQSxTQUFTLHlCQUF5QixFQUFFLElBQUksS0FBSyxjQUFjLEVBQUUsS0FBSztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHlEQUFlO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN5RDtBQUNSO0FBQ1g7QUFDdEM7QUFDc0Q7QUFDRjtBQUNBO0FBQ0Y7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtREFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLHFEQUFXO0FBQ2IsRUFBRSxpREFBUztBQUNYLEVBQUUsbUVBQWtCO0FBQ3BCLEVBQUUsK0RBQWdCO0FBQ2xCLEVBQUUsK0RBQWdCO0FBQ2xCLEVBQUUsMkRBQWM7QUFDaEIsRUFBRSxtREFBVTtBQUNaO0FBQ0EsMEJBQTBCLHFEQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0EsbUNBQW1DLEtBQUssR0FBRyxhQUFhO0FBQ3hEOzs7Ozs7Ozs7Ozs7Ozs7O0FDdkV1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ2hEcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4Q3FEO0FBQ047QUFDL0M7QUFDNEM7QUFDVDtBQUNFO0FBQ3JDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsOERBQWM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msd0RBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsK0NBQU07QUFDUixFQUFFLHlEQUFlO0FBQ2pCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakNtQztBQUNLO0FBQ0U7QUFDMUM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRDQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHVEQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFEQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLElBQUk7QUFDNUI7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0Isb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2RThDO0FBQ0Q7QUFDQTtBQUNkO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFdBQVc7QUFDWDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsRUFBRSwwREFBVztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2SGtEO0FBQ2hCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLEVBQUUsOERBQWU7QUFDakI7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0w0QztBQUNBO0FBQ0k7QUFDSjtBQUM1QztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsMERBQVc7QUFDYjtBQUNBO0FBQ0E7QUFDTztBQUNQLEVBQUUseURBQWE7QUFDZixFQUFFLHlEQUFhO0FBQ2Y7Ozs7Ozs7Ozs7Ozs7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixVQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQzlGd0M7QUFDZ0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxxREFBTTtBQUN0RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDBDQUFFO0FBQ2hCLGVBQWUsaURBQWE7QUFDNUI7QUFDQTtBQUNBLGtCQUFrQixJQUFJO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkNBQUssT0FBTyxJQUFJLFFBQVEsRUFBRSxJQUFJO0FBQ2pEO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDOEM7QUFDOUM7QUFDTztBQUNQLFlBQVksa0NBQWtDO0FBQzlDLFlBQVksaUVBQWlFO0FBQzdFO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0RBQU87QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNEQ7QUFLeEI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUNBQWlDO0FBQ3JELG9CQUFvQixpQ0FBaUM7QUFDckQsQ0FBQztBQUNEO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywwQkFBMEI7QUFDdEUsNENBQTRDLDBCQUEwQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNERBQW9CO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDREQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNERBQW9CO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNERBQW9CO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNERBQW9CO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNERBQW9CO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNERBQW9CO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZFQUFtQjtBQUN2QyxPQUFPO0FBQ1A7QUFDQTtBQUNBLG9CQUFvQiw2RUFBbUI7QUFDdkMsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2RUFBbUI7QUFDdkMsT0FBTztBQUNQO0FBQ0E7QUFDQSxvQkFBb0IsNkVBQW1CO0FBQ3ZDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNkVBQW1CO0FBQ3JELGtDQUFrQyw2RUFBbUI7QUFDckQsa0NBQWtDLDZFQUFtQjtBQUNyRCxrQ0FBa0MsNkVBQW1CO0FBQ3JEO0FBQ0E7QUFDQSxpRkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMXdCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNEQ7QUFDbkI7QUFLTDtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qyx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZELHVEQUF1RDtBQUN2RCx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsNERBQW9CLHFCQUFxQiw2Q0FBSyxXQUFXO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QjtBQUNBLDhCQUE4QixtQkFBbUIsMkJBQTJCO0FBQzVFLDhCQUE4QixtQkFBbUIsMkJBQTJCO0FBQzVFLDhCQUE4QixtQkFBbUIsMkJBQTJCO0FBQzVFLDhCQUE4QixtQkFBbUIsMkJBQTJCO0FBQzVFLDhCQUE4QixtQkFBbUIsMkJBQTJCO0FBQzVFLDhCQUE4QjtBQUM5QjtBQUNBLDhCQUE4Qiw0QkFBNEIsMkJBQTJCO0FBQ3JGLDhCQUE4Qiw0QkFBNEIsMkJBQTJCO0FBQ3JGLDhCQUE4Qiw0QkFBNEIsMkJBQTJCO0FBQ3JGLDhCQUE4Qiw0QkFBNEIsMkJBQTJCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isb0JBQW9CLHVCQUF1QixnQ0FBZ0M7QUFDMUcsK0JBQStCLG9CQUFvQix1QkFBdUIsZ0NBQWdDO0FBQzFHLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzQkFBc0IscUNBQXFDO0FBQ3hGLDZCQUE2QixzQkFBc0IscUNBQXFDO0FBQ3hGLDZCQUE2QixzQkFBc0IscUNBQXFDO0FBQ3hGLDZCQUE2QixzQkFBc0IsMkJBQTJCLGlEQUFpRDtBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxxQkFBcUIsMkJBQTJCO0FBQ3ZGLHVDQUF1QyxxQkFBcUIsMkJBQTJCO0FBQ3ZGLHVDQUF1QyxxQkFBcUIsMkJBQTJCO0FBQ3ZGLDZCQUE2QiwrQkFBK0IsMkJBQTJCLHVDQUF1QztBQUM5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCLHdEQUF3RDtBQUNyRiw2QkFBNkIsd0RBQXdEO0FBQ3JGLDZCQUE2Qix3REFBd0Q7QUFDckYsNkJBQTZCLHdEQUF3RDtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQ0FBaUMsOEJBQThCLHVCQUF1QjtBQUNuSCw2QkFBNkIsaUNBQWlDLDhCQUE4Qix1QkFBdUI7QUFDbkgsNkJBQTZCLGlDQUFpQyw4QkFBOEIsdUJBQXVCO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGVBQWUsdUJBQXVCO0FBQ3RFLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2Q0FBSyxXQUFXO0FBQzVCLFlBQVksMkNBQUcsVUFBVTtBQUN6QixZQUFZLDJDQUFHLFVBQVU7QUFDekIsWUFBWSwyQ0FBRyxVQUFVO0FBQ3pCLGFBQWEsMkNBQUcsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkNBQUssVUFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxNQUFNLHFEQUFNO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZFQUFtQjtBQUMvQixZQUFZLDZFQUFtQjtBQUMvQixZQUFZLDZFQUFtQjtBQUMvQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2RUFBbUI7QUFDcEMsaUJBQWlCLDZFQUFtQjtBQUNwQyxpQkFBaUIsNkVBQW1CO0FBQ3BDO0FBQ0E7QUFDQSxpRkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDeDZFRDtBQUNBO0FBQ0E7QUFDQTtBQUM2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDJEQUFZO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyREFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDaUQ7QUFDakQ7QUFDQSxpRUFBZSwwREFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkI7QUFDN0I7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJELHNCQUFzQjtBQUNqRiwyR0FBMkc7QUFDM0csNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJELGtCQUFrQjtBQUM3RSwyREFBMkQsUUFBUTtBQUNuRSwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2QjtBQUM3QjtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELG9FQUFvRTtBQUNwRSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRCxpQkFBaUI7QUFDNUUsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0EsNkJBQTZCO0FBQzdCLDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCO0FBQzdCLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkI7QUFDN0I7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qiw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCO0FBQzdCLDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsNkJBQTZCO0FBQzdCLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBLENBQUMsRUFBQzs7Ozs7Ozs7Ozs7Ozs7O0FDcjFKRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyaEtGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2lEO0FBQ2pEO0FBQ0EsaUVBQWUsMERBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSw2QkFBNkI7QUFDN0IsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCO0FBQzdCLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCO0FBQzdCO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2QjtBQUM3Qiw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2QjtBQUM3QiwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkI7QUFDN0IsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2QjtBQUM3QjtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2QjtBQUM3QjtBQUNBLDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2QjtBQUM3QiwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCO0FBQzdCLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0EsNkJBQTZCO0FBQzdCLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkI7QUFDN0IsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkI7QUFDN0I7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2QjtBQUM3QiwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkI7QUFDN0I7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSwyREFBMkQ7QUFDM0QsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSw2QkFBNkI7QUFDN0IsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRixnRkFBZ0Y7QUFDaEYsZ0ZBQWdGO0FBQ2hGLGdGQUFnRjtBQUNoRixnRkFBZ0Y7QUFDaEY7QUFDQSxnRkFBZ0Y7QUFDaEYsZ0ZBQWdGO0FBQ2hGLGdGQUFnRjtBQUNoRixnRkFBZ0Y7QUFDaEYsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsMkRBQTJEO0FBQzNEO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0EsQ0FBQyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQzFxS0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpRDtBQUNiO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywwREFBUTtBQUN0QjtBQUNBLEtBQUssa0JBQWtCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsK0NBQU07QUFDaEM7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLGFBQWEsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQy9CN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSytCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdDQUFnQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0VBQXFCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1RUFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFFQUFvQjtBQUMzQyx1QkFBdUIsc0VBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQzdQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM0RDtBQUM1RDtBQUNBO0FBQ2tDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwQkFBMEI7QUFDbEMsUUFBUSwwQkFBMEI7QUFDbEMsUUFBUSwwQkFBMEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDREQUFvQjtBQUMxQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsTUFBTSw0REFBb0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDREQUFvQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDaGFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnRkFBMEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdGQUEwQjtBQUNwRCwwQkFBMEIsZ0ZBQTBCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0ZBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0ZBQXNCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQzdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0dBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNEQ7QUFNakM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw2REFBZ0I7QUFDdEIsTUFBTSwwREFBYTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0RBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOERBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsOERBQWlCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsOERBQWlCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDhEQUFpQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsOERBQWlCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsOERBQWlCO0FBQzFELHdCQUF3Qiw4REFBaUI7QUFDekM7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNkRBQWdCO0FBQzFCLFVBQVUsMERBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw4REFBaUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNkRBQWdCO0FBQ3RCLE1BQU0sMERBQWE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhEQUFpQjtBQUMxQztBQUNBO0FBQ0EseUJBQXlCLDhEQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5Qix3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RSx1RUFBdUU7QUFDdkUsdUVBQXVFO0FBQ3ZFLHVFQUF1RTtBQUN2RSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNERBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEUsb0VBQW9FO0FBQ3BFLG9FQUFvRTtBQUNwRSxvRUFBb0U7QUFDcEUsb0VBQW9FO0FBQ3BFLG9FQUFvRTtBQUNwRSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMseUJBQXlCO0FBQ3JFLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6dENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNzQztBQUtGO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsaUZBQXVCO0FBQ3pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQjtBQUNBLDhCQUE4Qix5QkFBeUI7QUFDdkQsOEJBQThCLHlCQUF5QjtBQUN2RCw4QkFBOEIseUJBQXlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGtEQUFVO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFLGtEQUFVO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2RUFBbUI7QUFDbEMsZUFBZSw2RUFBbUI7QUFDbEMsZUFBZSw2RUFBbUI7QUFDbEMsZUFBZSw2RUFBbUI7QUFDbEMsZUFBZSw2RUFBbUI7QUFDbEMsZUFBZSw2RUFBbUI7QUFDbEMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkVBQW1CO0FBQ3ZDLG9CQUFvQiw2RUFBbUI7QUFDdkMsb0JBQW9CLDZFQUFtQjtBQUN2QyxvQkFBb0IsNkVBQW1CO0FBQ3ZDLG9CQUFvQiw2RUFBbUI7QUFDdkMsb0JBQW9CLDZFQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7OztBQ3hZRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLDhDQUE4QztBQUM5Qyw4Q0FBOEM7QUFDOUMscUJBQXFCLE1BQU0sbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0ZBQXdGO0FBQ2pHLFNBQVMsd0ZBQXdGO0FBQ2pHLFNBQVMsdURBQXVEO0FBQ2hFLFNBQVMsV0FBVztBQUNwQixTQUFTLFdBQVc7QUFDcEIsU0FBUyxXQUFXO0FBQ3BCLFNBQVMsc0JBQXNCO0FBQy9CLFNBQVMsV0FBVztBQUNwQixTQUFTLFdBQVc7QUFDcEIsU0FBUyxXQUFXO0FBQ3BCLFNBQVMsV0FBVztBQUNwQixTQUFTLFdBQVc7QUFDcEIsU0FBUyxXQUFXO0FBQ3BCLFNBQVMsV0FBVztBQUNwQixTQUFTLFdBQVc7QUFDcEIsU0FBUyxXQUFXO0FBQ3BCLFNBQVMsV0FBVztBQUNwQixTQUFTLHdGQUF3RjtBQUNqRyxTQUFTLGlDQUFpQztBQUMxQyxTQUFTLGlDQUFpQztBQUMxQyxTQUFTLDRDQUE0QztBQUNyRCxTQUFTLFdBQVc7QUFDcEIsU0FBUyxXQUFXO0FBQ3BCLFNBQVMsd0ZBQXdGO0FBQ2pHLFNBQVMsNENBQTRDO0FBQ3JELFNBQVMsV0FBVztBQUNwQixTQUFTLFdBQVc7QUFDcEIsU0FBUyxzQkFBc0I7QUFDL0IsU0FBUyxXQUFXO0FBQ3BCLFNBQVMsd0ZBQXdGO0FBQ2pHLFNBQVMsdURBQXVEO0FBQ2hFLFNBQVMsdURBQXVEO0FBQ2hFLFNBQVMsdURBQXVEO0FBQ2hFLFNBQVMsV0FBVztBQUNwQixTQUFTLHdGQUF3RjtBQUNqRyxTQUFTLFdBQVc7QUFDcEIsU0FBUyxXQUFXO0FBQ3BCLFNBQVMsV0FBVztBQUNwQixTQUFTLFdBQVc7QUFDcEIsU0FBUyx1REFBdUQ7QUFDaEUsU0FBUyx1REFBdUQ7QUFDaEUsU0FBUyxXQUFXO0FBQ3BCLFNBQVMsV0FBVztBQUNwQixTQUFTLHdGQUF3RjtBQUNqRyxTQUFTLFdBQVc7QUFDcEIsU0FBUyxXQUFXO0FBQ3BCLFNBQVMsV0FBVztBQUNwQixTQUFTLDZFQUE2RTtBQUN0RixTQUFTLGlDQUFpQztBQUMxQyxTQUFTLGlDQUFpQztBQUMxQyxTQUFTLFdBQVc7QUFDcEIsU0FBUyxXQUFXO0FBQ3BCLFNBQVMsV0FBVztBQUNwQixTQUFTLFdBQVc7QUFDcEIsU0FBUyxXQUFXO0FBQ3BCLFNBQVMsV0FBVztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sdUNBQXVDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPLFdBQVcsSUFBSSxjQUFjLEdBQUc7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPLFdBQVcsSUFBSTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNubEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQUs7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDOUxBO0FBQ0E7QUFDQTtBQUNBO0FBQzBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNkNBQUssT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBDQUFFO0FBQzlCLDRCQUE0QiwwQ0FBRTtBQUM5Qiw0QkFBNEIsMENBQUU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwyQ0FBRyxLQUFLO0FBQ2pDLHlCQUF5QiwyQ0FBRyxLQUFLO0FBQ2pDLHlCQUF5QiwyQ0FBRyxLQUFLO0FBQ2pDLHlCQUF5QiwyQ0FBRyxRQUFRLEVBQUUsMENBQUUsUUFBUTtBQUNoRCx5QkFBeUIsMkNBQUcsUUFBUSxFQUFFLDBDQUFFLFFBQVE7QUFDaEQseUJBQXlCLDJDQUFHLFFBQVEsRUFBRSwwQ0FBRSxRQUFRO0FBQ2hELDBCQUEwQiwyQ0FBRyxRQUFRLEVBQUUsMENBQUUsUUFBUTtBQUNqRCwwQkFBMEIsMkNBQUcsS0FBSztBQUNsQywwQkFBMEIsMkNBQUcsUUFBUTtBQUNyQywwQkFBMEIsMkNBQUcsUUFBUTtBQUNyQyx5QkFBeUIsNkNBQUssNEJBQTRCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM2QztBQUM3QztBQUNBLGlCQUFpQix5REFBVTtBQUMzQjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ087QUFDUCxTQUFTLFFBQVEsb0JBQW9CO0FBQ3JDO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QjtBQUNBLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEI7QUFDQSxzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlETztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU8sT0FBTztBQUNoRCxrQ0FBa0MsT0FBTyxPQUFPO0FBQ2hELGtDQUFrQyxPQUFPLE9BQU87QUFDaEQsa0NBQWtDLE9BQU8sT0FBTztBQUNoRCxrQ0FBa0MsT0FBTyxPQUFPO0FBQ2hELGtDQUFrQyxPQUFPLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDL01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTyx1Q0FBdUM7QUFDdkMsdUNBQXVDO0FBQ3ZDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3RCUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsTUFBTTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLEtBQUs7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7VUNsQ0E7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7Ozs7V0N0QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx5Q0FBeUMsd0NBQXdDO1dBQ2pGO1dBQ0E7V0FDQTs7Ozs7V0NQQTs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSx1REFBdUQsaUJBQWlCO1dBQ3hFO1dBQ0EsZ0RBQWdELGFBQWE7V0FDN0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTkE7QUFDMEQ7QUFDUTtBQUNFO0FBQ0E7QUFDcEU7QUFDQTtBQUNrRDtBQUNGO0FBQ0E7QUFDQTtBQUNDO0FBQ0Q7QUFDQztBQUNqRDtBQUNBO0FBQzRDO0FBQ007QUFDRjtBQUNoRDtBQUNBO0FBQzRDO0FBQzVDO0FBQ0E7QUFDbUQ7QUFDUztBQUNBO0FBQzVEO0FBQ0E7QUFDQSxZQUFZLHlEQUFPO0FBQ25CLFlBQVksS0FBSyx1RUFBTyxrRUFBVSw0RUFBVSxvRUFBRTtBQUM5QyxZQUFZLEtBQUssd0RBQUssc0RBQUssc0RBQUssc0RBQUssdURBQU0sd0RBQU0sMERBQU8sb0VBQVEsNkVBQVcsa0VBQUU7QUFDN0U7QUFDQSxJQUFJLDZDQUFPO0FBQ1gsSUFBSSxzREFBVztBQUNmLElBQUksc0RBQVc7QUFDZjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWNpaW91cy8uL3NyYy9ob3N0L3dlYkZyb250RW5kL2RpYWxvZ3MuY3NzP2M3MjciLCJ3ZWJwYWNrOi8vdmljaWlvdXMvLi9zcmMvaG9zdC93ZWJGcm9udEVuZC9kaXNrRGlhbG9nLmNzcz8wM2QzIiwid2VicGFjazovL3ZpY2lpb3VzLy4vc3JjL2hvc3Qvd2ViRnJvbnRFbmQvam95c3RpY2tEaWFsb2cuY3NzPzdiZTYiLCJ3ZWJwYWNrOi8vdmljaWlvdXMvLi9zcmMvaG9zdC93ZWJGcm9udEVuZC9rZXlNYXBEaWFsb2cuY3NzPzRjMDkiLCJ3ZWJwYWNrOi8vdmljaWlvdXMvLi9zcmMvaG9zdC93ZWJGcm9udEVuZC9sb2FkZXJEaWFsb2cuY3NzPzc5YjUiLCJ3ZWJwYWNrOi8vdmljaWlvdXMvLi9zcmMvaG9zdC93ZWJGcm9udEVuZC9zY29wZXMuY3NzPzE4MGYiLCJ3ZWJwYWNrOi8vdmljaWlvdXMvLi9zcmMvaG9zdC93ZWJGcm9udEVuZC9zbmFwc2hvdHMuY3NzPzYyNGIiLCJ3ZWJwYWNrOi8vdmljaWlvdXMvLi9zcmMvaG9zdC93ZWJGcm9udEVuZC90cmF5cy5jc3M/YTZmOCIsIndlYnBhY2s6Ly92aWNpaW91cy8uL3NyYy9kZWJ1Zy5qcyIsIndlYnBhY2s6Ly92aWNpaW91cy8uL3NyYy9ob3N0L2F1ZGlvLU9zY2lsbGF0b3JOb2RlLmpzIiwid2VicGFjazovL3ZpY2lpb3VzLy4vc3JjL2hvc3QvYnV0dG9uTmFtZVRvTWF0cml4UG9zLmpzIiwid2VicGFjazovL3ZpY2lpb3VzLy4vc3JjL2hvc3QvZHJhZ0FuZERyb3AuanMiLCJ3ZWJwYWNrOi8vdmljaWlvdXMvLi9zcmMvaG9zdC9pbmdlc3QtZDY0LmpzIiwid2VicGFjazovL3ZpY2lpb3VzLy4vc3JjL2hvc3QvaW5nZXN0LWpzb24uanMiLCJ3ZWJwYWNrOi8vdmljaWlvdXMvLi9zcmMvaG9zdC9pbmdlc3QtcHJnLmpzIiwid2VicGFjazovL3ZpY2lpb3VzLy4vc3JjL2hvc3QvaW5nZXN0LXNpZC5qcyIsIndlYnBhY2s6Ly92aWNpaW91cy8uL3NyYy9ob3N0L2luZ2VzdC10NjQuanMiLCJ3ZWJwYWNrOi8vdmljaWlvdXMvLi9zcmMvaG9zdC9pbmdlc3QtdGFwLmpzIiwid2VicGFjazovL3ZpY2lpb3VzLy4vc3JjL2hvc3QvaW5nZXN0LmpzIiwid2VicGFjazovL3ZpY2lpb3VzLy4vc3JjL2hvc3Qvam95c3RpY2stS2V5Ym9hcmRFdmVudC5qcyIsIndlYnBhY2s6Ly92aWNpaW91cy8uL3NyYy9ob3N0L2tleWJvYXJkLUtleWJvYXJkRXZlbnQuanMiLCJ3ZWJwYWNrOi8vdmljaWlvdXMvLi9zcmMvaG9zdC9rZXlib2FyZC1kaXJlY3QuanMiLCJ3ZWJwYWNrOi8vdmljaWlvdXMvLi9zcmMvaG9zdC9rZXlib2FyZC1uYXR1cmFsLmpzIiwid2VicGFjazovL3ZpY2lpb3VzLy4vc3JjL2hvc3QvdmlkZW8tY2FudmFzLmpzIiwid2VicGFjazovL3ZpY2lpb3VzLy4vc3JjL2hvc3Qvd2ViRnJvbnRFbmQvY29sbGlzaW9uU2NvcGUuanMiLCJ3ZWJwYWNrOi8vdmljaWlvdXMvLi9zcmMvaG9zdC93ZWJGcm9udEVuZC9kZW1vcy9maXJzdF9wcmcuanMiLCJ3ZWJwYWNrOi8vdmljaWlvdXMvLi9zcmMvaG9zdC93ZWJGcm9udEVuZC9kZW1vcy9ob3ZlcmJvdnZlcl9wcmcuanMiLCJ3ZWJwYWNrOi8vdmljaWlvdXMvLi9zcmMvaG9zdC93ZWJGcm9udEVuZC9kaWFsb2dzLmpzIiwid2VicGFjazovL3ZpY2lpb3VzLy4vc3JjL2hvc3Qvd2ViRnJvbnRFbmQvZGlza0RpYWxvZy5qcyIsIndlYnBhY2s6Ly92aWNpaW91cy8uL3NyYy9ob3N0L3dlYkZyb250RW5kL2luZGV4LmpzIiwid2VicGFjazovL3ZpY2lpb3VzLy4vc3JjL2hvc3Qvd2ViRnJvbnRFbmQvam95c3RpY2tEaWFsb2cuanMiLCJ3ZWJwYWNrOi8vdmljaWlvdXMvLi9zcmMvaG9zdC93ZWJGcm9udEVuZC9rZXlNYXBEaWFsb2cuanMiLCJ3ZWJwYWNrOi8vdmljaWlvdXMvLi9zcmMvaG9zdC93ZWJGcm9udEVuZC9sb2FkZXJEaWFsb2cuanMiLCJ3ZWJwYWNrOi8vdmljaWlvdXMvLi9zcmMvaG9zdC93ZWJGcm9udEVuZC9sb3dlclRyYXkuanMiLCJ3ZWJwYWNrOi8vdmljaWlvdXMvLi9zcmMvaG9zdC93ZWJGcm9udEVuZC9yYW1BY2Nlc3NTY29wZS5qcyIsIndlYnBhY2s6Ly92aWNpaW91cy8uL3NyYy9ob3N0L3dlYkZyb250RW5kL3Njb3Blcy5qcyIsIndlYnBhY2s6Ly92aWNpaW91cy8uL3NyYy9ob3N0L3dlYkZyb250RW5kL3NuYXBzaG90LmpzIiwid2VicGFjazovL3ZpY2lpb3VzLy4vc3JjL2hvc3Qvd2ViRnJvbnRFbmQvdHJheXMuanMiLCJ3ZWJwYWNrOi8vdmljaWlvdXMvLi9zcmMvaG9zdC93ZWJGcm9udEVuZC91cHBlclRyYXkuanMiLCJ3ZWJwYWNrOi8vdmljaWlvdXMvLi9zcmMvbW9uaXRvci5qcyIsIndlYnBhY2s6Ly92aWNpaW91cy8uL3NyYy90YXJnZXQvYnJpbmd1cC5qcyIsIndlYnBhY2s6Ly92aWNpaW91cy8uL3NyYy90YXJnZXQvY2lhcy5qcyIsIndlYnBhY2s6Ly92aWNpaW91cy8uL3NyYy90YXJnZXQvY3B1LmpzIiwid2VicGFjazovL3ZpY2lpb3VzLy4vc3JjL3RhcmdldC9yYW0uanMiLCJ3ZWJwYWNrOi8vdmljaWlvdXMvLi9zcmMvdGFyZ2V0L3JvbS9iYXNpYy5qcyIsIndlYnBhY2s6Ly92aWNpaW91cy8uL3NyYy90YXJnZXQvcm9tL2NoYXJhY3Rlci5qcyIsIndlYnBhY2s6Ly92aWNpaW91cy8uL3NyYy90YXJnZXQvcm9tL2tlcm5hbC5qcyIsIndlYnBhY2s6Ly92aWNpaW91cy8uL3NyYy90YXJnZXQvcm9tL3NraXBSYW1UZXN0LmpzIiwid2VicGFjazovL3ZpY2lpb3VzLy4vc3JjL3RhcmdldC9ydW5sb29wLmpzIiwid2VicGFjazovL3ZpY2lpb3VzLy4vc3JjL3RhcmdldC9zaWQuanMiLCJ3ZWJwYWNrOi8vdmljaWlvdXMvLi9zcmMvdGFyZ2V0L3NpZF9kaWFnLmpzIiwid2VicGFjazovL3ZpY2lpb3VzLy4vc3JjL3RhcmdldC90YXBlLmpzIiwid2VicGFjazovL3ZpY2lpb3VzLy4vc3JjL3RhcmdldC92aWMuanMiLCJ3ZWJwYWNrOi8vdmljaWlvdXMvLi9zcmMvdGFyZ2V0L3dpcmVzLmpzIiwid2VicGFjazovL3ZpY2lpb3VzLy4vc3JjL3Rvb2xzL2Fzc2VtYmxlci5qcyIsIndlYnBhY2s6Ly92aWNpaW91cy8uL3NyYy90b29scy9iYXNlNjQuanMiLCJ3ZWJwYWNrOi8vdmljaWlvdXMvLi9zcmMvdG9vbHMvYzY0Rm9udENvZGVQb2ludHMuanMiLCJ3ZWJwYWNrOi8vdmljaWlvdXMvLi9zcmMvdG9vbHMvZGlzYXNtLmpzIiwid2VicGFjazovL3ZpY2lpb3VzLy4vc3JjL3Rvb2xzL2xvYWRQcmcuanMiLCJ3ZWJwYWNrOi8vdmljaWlvdXMvLi9zcmMvdG9vbHMvcGFsZXR0ZXMuanMiLCJ3ZWJwYWNrOi8vdmljaWlvdXMvLi9zcmMvdG9vbHMvcGFyc2VyLmpzIiwid2VicGFjazovL3ZpY2lpb3VzLy4vc3JjL3Rvb2xzL3JvbUxvY2F0aW9ucy5qcyIsIndlYnBhY2s6Ly92aWNpaW91cy8uL3NyYy90b29scy9zZXJpYWxpemVyU3VwcG9ydC5qcyIsIndlYnBhY2s6Ly92aWNpaW91cy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly92aWNpaW91cy93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vdmljaWlvdXMvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly92aWNpaW91cy93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3ZpY2lpb3VzLy4vc3JjL2VudHJ5L3dlYi1kZXYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307IiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307IiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307IiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307IiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307IiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307IiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307IiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307IiwiLy8gVE9ETzogdGhpcyBiZWxvbmdzIGluIHRvb2xzXHJcblxyXG5leHBvcnQgY29uc3QgcGV0c2NpaVRvQ2hhciA9IChcclxuICAvKiAweDAwICovIFwi77+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+9XCIgKyAvKiAweDEwICovIFwi77+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+9XCIgK1xyXG4gIC8qIDB4MjAgKi9cIiAhXFxcIiMkJSYnKCkqKywtLi9cIiArIC8qIDB4MzAgKi8gXCIwMTIzNDU2Nzg5Ojs8PT4/XCIgK1xyXG4gIC8qIDB4NDAgKi8gXCJAYWJjZGVmZ2hpamtsbW5vXCIgKyAvKiAweDUwICovIFwicHFyc3R1dnd4eXpbwqNd4oaR4oaQXCIgK1xyXG4gIC8qIDB4NjAgKi8gXCLigJRBQkNERUZHSElKS0xNTk9cIiArIC8qIDB4NzAgKi8gXCJQUVJTVFVWV1hZWuKUvOKWkuKUguKWkuKWklwiICtcclxuICAvKiAweDgwICovIFwi77+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+9XCIgKyAvKiAweDkwICovIFwi77+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+9XCIgK1xyXG4gIC8qIDB4YTAgKi8gXCIg4paM4paE4paU4paB4paO4paS4paV4paS4paS4paV4pSc4paX4pSU4pSQ4paCXCIgKyAvKiAweGIwICovIFwi4pSM4pS04pSs4pSk4paO4paN4paV4paU4paU4paD4pyT4paW4pad4pSY4paY4paaXCIgK1xyXG4gIC8qIDB4YzAgKi8gXCLilIBBQkNERUZHSElKS0xNTk9cIiArIC8qIDB4ZDAgKi8gXCJQUVJTVFVWV1hZWuKUvOKWkuKUguKWkuKWklwiICtcclxuICAvKiAweGUwICovIFwiIOKWjOKWhOKWlOKWgeKWjuKWkuKWleKWkuKWkuKWleKUnOKWl+KUlOKUkOKWglwiICsgLyogMHhmMCAqLyBcIuKUjOKUtOKUrOKUpOKWjuKWjeKWleKWlOKWlOKWg+Kck+KWluKWneKUmOKWmOKWklwiXHJcbik7XHJcblxyXG5mdW5jdGlvbiB0b0hleFN0cih2YWwsIGRpZ2l0cz0yKSB7XHJcbiAgcmV0dXJuIHZhbC50b1N0cmluZygxNikucGFkU3RhcnQoZGlnaXRzLCBcIjBcIik7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCB4eCAgID0gdmFsID0+IHRvSGV4U3RyKHZhbCwgMik7XHJcbmV4cG9ydCBjb25zdCB4eHh4ID0gdmFsID0+IHRvSGV4U3RyKHZhbCwgNCk7XHJcblxyXG5leHBvcnQgY29uc3QgJHh4ICAgPSB2YWwgPT4gYFxcJCR7eHgodmFsKX1gO1xyXG5leHBvcnQgY29uc3QgJHh4eHggPSB2YWwgPT4gYFxcJCR7eHh4eCh2YWwpfWA7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdmV0QWRkcmVzcyhhZGRyKSB7XHJcbiAgaWYgKFxyXG4gICAgKGFkZHIgIT09IGFkZHIpIC8vIGlzIE5hTj9cclxuICAgIHx8ICh0eXBlb2YgYWRkciAhPT0gXCJudW1iZXJcIilcclxuICAgIHx8IChhZGRyICE9PSBNYXRoLmZsb29yKGFkZHIpKVxyXG4gICAgfHwgKGFkZHIgPCAwKVxyXG4gICAgfHwgKGFkZHIgPiAweGZmZmYpXHJcbiAgKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYnVzIGFkZHJlc3M6ICR7YWRkcn1gKTtcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IGVuY291bnRlcmVkV2FybmluZ3MgPSBuZXcgU2V0KCk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdW5pbXBsZW1lbnRlZFdhcm5pbmcocHJvYmxlbSwgZGV0YWlscykge1xyXG5cclxuICAvLyBSZW1vdmUgdGhpcyB0byBzaG93IHdhcm5pbmdzIHdoZW4gdGhlIHRhcmdldCBzb2Z0d2FyZSB0cmllcyBleGVyY2lzaW5nXHJcbiAgLy8gdW5pbXBsZW1lbnRlZCBoYXJkd2FyZSBmdW5jdGlvbmFsaXR5LCBidXQgeW91J2xsIHNlZSBsb3RzIG9mIGZhbHNlXHJcbiAgLy8gcG9zaXRpdmVzLlxyXG4gIHJldHVybjtcclxuXHJcbiAgaWYgKGVuY291bnRlcmVkV2FybmluZ3MuaGFzKHByb2JsZW0pKSByZXR1cm47XHJcbiAgXHJcbiAgY29uc29sZS53YXJuKFwiVW5pbXBsZW1lbnRlZDpcIiwgcHJvYmxlbSk7XHJcbiAgaWYgKGRldGFpbHMpIGNvbnNvbGUubG9nKGRldGFpbHMpO1xyXG5cclxuICBlbmNvdW50ZXJlZFdhcm5pbmdzLmFkZChwcm9ibGVtKTtcclxufVxyXG4iLCIvKlxyXG4gICBTSUQgb3V0cHV0IHVzaW5nIHRoZSBXZWIgQXVkaW8gQVBJLiBTcGVjaWZpY2FsbHksIGFuIG91dHB1dCBwYXRoIGJ1aWx0IHVwb25cclxuICAgYSBuZXR3b3JrIG9mIE9zY2lsbGF0b3JOb2RlIG5vZGVzLiBNYXliZSBzb21lZGF5IHRoZXJlJ2QgYmUgYW4gYWx0ZXJuYXRpdmVcclxuICAgYXVkaW8tQXVkaW9Xb3JrbGV0IHRvbywgc28gdG8gYXZvaWQgY29uZnVzaW9uIGJldHdlZW4gdGhlIHR3bywgdGhpcyBmaWxlXHJcbiAgIGlzbid0IGNhbGxlZCBhdWRpby1XZWJBdWRpby5cclxuKi9cclxuXHJcbmNvbnN0IHN0YXRlID0ge1xyXG4gIHJlZ3M6IG5ldyBVaW50OEFycmF5KDMyKSxcclxuICBzdXNwZW5kZWQ6IHRydWUsXHJcbn07XHJcblxyXG4vLyBTcXVhcmUgd2F2ZXMgYXJlIGFzIGxvdWQgYXMgaXQgZ2V0cy4gRGlhbCBpdCBkb3duLi4uXHJcbmNvbnN0IE1BU1RFUl9NVUxUSVBMSUVSID0gMC4yO1xyXG5cclxuLy8gRGl2aWRlIGhpYnl0ZS9sb2J5dGUgZnJlcXVlbmN5IGJ5IE1BU1RFUl9UVU5JTkcgdG8gZ2V0IEh6LlxyXG4vLyBUT0RPOiB0aGlzIGlzbid0IGFjY3VyYXRlLiBUYWJsZXMgZXhpc3Qgd2hpY2ggY291bGQgZ2l2ZSBhIGJldHRlciBudW1iZXIsXHJcbi8vIGVnLiBodHRwczovL2NvZGViYXNlNjQub3JnL2Rva3UucGhwP2lkPWJhc2U6cGFsX2ZyZXF1ZW5jeV90YWJsZVxyXG4vLyAgICAgaHR0cHM6Ly9jb2RlYmFzZTY0Lm9yZy9kb2t1LnBocD9pZD1iYXNlOm50c2NfZnJlcXVlbmN5X3RhYmxlXHJcbi8vXHJcbi8vIE5vdGUgdGhhdCBpdCdzIGRpZmZlcmVudCBmb3IgUEFMIHZzIE5UU0NcclxuY29uc3QgTUFTVEVSX1RVTklORyA9IDE2Ljk7XHJcblxyXG4vLyBjcmVhdGUgd2ViIGF1ZGlvIEFQSSBjb250ZXh0XHJcbmNvbnN0IGF1ZGlvQ3R4ID0gbmV3IChnbG9iYWxUaGlzLkF1ZGlvQ29udGV4dCB8fCBnbG9iYWxUaGlzLndlYmtpdEF1ZGlvQ29udGV4dCkoKTtcclxuXHJcbi8vIElmIHRoZSBicm93c2VyIHdvbid0IGFsbG93IGF1ZGlvIGNvbnRleHQgY3JlYXRpb24gaW1tZWRpYXRlbHkgd2UnbGwgY29udGludWVcclxuLy8gcmVnYXJkbGVzcyBhbmQgaG9wZSB0aGF0IHVzZXJEaWRJbnRlcmFjdCBnZXRzIGNhbGxlZCB0byB1bmJsb2NrIGl0LiBJZiB0aGF0XHJcbi8vIGRvZXNuJ3QgaGFwcGVuLCB0aGUgZW11bGF0b3Igd2lsbCBzbG93IGRyYW1hdGljYWxseSB0aGUgbW9yZSB0aGUgYXVkaW8gQVBJXHJcbi8vIGlzIHVzZWQuXHJcbnN0YXRlLnN1c3BlbmRlZCA9IChhdWRpb0N0eC5zdGF0ZSA9PT0gXCJzdXNwZW5kZWRcIik7XHJcblxyXG5pZiAoc3RhdGUuc3VzcGVuZGVkKSB7XHJcbiAgLy8gTGlzdGVuIG91dCBmb3IgZXZlbnRzIHRoYXQgY291bGQgYWxsb3cgcmVzdW1wdGlvbiAodGhvdWdoIG1vc3QgbGlrZWx5XHJcbiAgLy8gaXQnbGwgYmUgdGhlIGRyYWctYW5kLWRyb3AgdGhhdCB1bmJsb2NrcyB1cykuXHJcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXHJcbiAgICBcImxvYWRcIixcclxuICAgICgpID0+IHtcclxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICAgdXNlckRpZEludGVyYWN0KTtcclxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdXNlckRpZEludGVyYWN0KTtcclxuICAgIH1cclxuICApO1xyXG5cclxuICAvLyBSZXN1bXB0aW9uIG1heSBiZSBhc3luY2hyb25vdXMsIHNvIHN0YXJ0IGFuIGludGVydmFsIHBvbGxlciB0aGF0IHdhdGNoZXNcclxuICAvLyBvdXQgZm9yIGl0IGFuZCB0ZWFycyBkb3duIHRoZSBsaXN0ZW5lcnMuXHJcbiAgY29uc3QgcG9sbGVyID0gc2V0SW50ZXJ2YWwoXHJcbiAgICAoKSA9PiB7XHJcbiAgICAgIGlmIChhdWRpb0N0eC5zdGF0ZSA9PT0gXCJydW5uaW5nXCIpIHtcclxuICAgICAgICBzdGF0ZS5zdXNwZW5kZWQgPSBmYWxzZTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkF1ZGlvQ29udGV4dCByZXN1bWVkXCIpO1xyXG5cclxuICAgICAgICAvLyBUZWFyIGRvd24gdGhlIGxpc3RlbmVycyB0aGF0IGFyZSB0cnlpbmcgdG8gdXBkYXRlIGBzdXNwZW5kZWRgLiBXZSdsbFxyXG4gICAgICAgIC8vIHN0aWxsIGdldCBldmVudHMgZnJvbSBkcmFnLWFuZC1kcm9wLCBidXQgdGhleSdyZSBjb21wbGV0ZWx5IGhhcm1sZXNzLlxyXG4gICAgICAgIGNsZWFySW50ZXJ2YWwocG9sbGVyKTtcclxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgICB1c2VyRGlkSW50ZXJhY3QpO1xyXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHVzZXJEaWRJbnRlcmFjdCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICAyNTBcclxuICApO1xyXG59XHJcblxyXG4vLyB1aUdhaW4gaXMgdGhlIHVsdGltYXRlIGNoYWluIGluIHRoZSBsaW5rLCBjb25uZWN0aW5nIHRoZSBlbXVsYXRlZCBuZXR3b3JrXHJcbi8vIHRvIHRoZSBicm93c2VyLlxyXG5jb25zdCB1aUdhaW4gPSBhdWRpb0N0eC5jcmVhdGVHYWluKCk7XHJcbnVpR2Fpbi5nYWluLnZhbHVlID0gMTtcclxudWlHYWluLmNvbm5lY3QoYXVkaW9DdHguZGVzdGluYXRpb24pO1xyXG5cclxuLy8gJ21hc3RlcicgaW4gdGhlIGNvbnRleHQgb2YgJ3dpdGhpbiB0aGUgQzY0J1xyXG5jb25zdCBtYXN0ZXJHYWluID0gYXVkaW9DdHguY3JlYXRlR2FpbigpO1xyXG5tYXN0ZXJHYWluLmdhaW4udmFsdWUgPSAwO1xyXG5tYXN0ZXJHYWluLmNvbm5lY3QodWlHYWluKTtcclxuXHJcbmxldCB2b2ljZXMgPSBbXTtcclxuXHJcbi8vIFRoZSB0aHJlc2hvbGRlciBjdXJ2ZSBpcyBhIHJlc3BvbnNlIHRhYmxlIHRoYXQgbWFwcyBpbnB1dCAoLTEsIDEpIHRvIG91dHB1dFxyXG4vLyAoLTEsIDEpLiBUaGUgV2F2ZVNoYXBlck5vZGUgQVBJIGxpbmVhcmx5IGludGVycG9sYXRlcyBiZXR3ZWVuIHBvaW50cyBpbiB0aGVcclxuLy8gdGFibGUgdGhhdCB0aGUgZG9tYWluIG1hcHMgdG8sIHNvIHdlIG5lZWQgYSB0YWJsZSB3aXRoIGVub3VnaCBlbnRyaWVzIHRoYXRcclxuLy8gdGhhdCdzIHVubGlrZWx5IHRvIG1hdHRlciBtdWNoLiAyNTYgd2lsbCBkby5cclxuY29uc3QgblRocmVzaG9sZGVyQ3VydmVQb2ludHMgPSAyNTY7XHJcbmNvbnN0IHRocmVzaG9sZGVyQ3VydmUgPSBuZXcgRmxvYXQzMkFycmF5KG5UaHJlc2hvbGRlckN1cnZlUG9pbnRzKTtcclxuZm9yIChsZXQgbiA9IDA7IG4gPCBuVGhyZXNob2xkZXJDdXJ2ZVBvaW50czsgbisrKSB7XHJcbiAgdGhyZXNob2xkZXJDdXJ2ZVtuXSA9IChuIDwgKG5UaHJlc2hvbGRlckN1cnZlUG9pbnRzIC8gMikpID8gLTEgOiAxO1xyXG59XHJcblxyXG4vLyBTdGF0aWMgbm9pc2UgZGF0YVxyXG5jb25zdCBub2lzZUJ1ZmZlclNpemUgPSAyICogYXVkaW9DdHguc2FtcGxlUmF0ZTtcclxuY29uc3Qgbm9pc2VCdWZmZXIgPSBhdWRpb0N0eC5jcmVhdGVCdWZmZXIoMSwgbm9pc2VCdWZmZXJTaXplLCBhdWRpb0N0eC5zYW1wbGVSYXRlKTtcclxuY29uc3Qgbm9pc2VEYXRhID0gbm9pc2VCdWZmZXIuZ2V0Q2hhbm5lbERhdGEoMCk7XHJcblxyXG4vLyBPciwgYmV0dGVyLCB1c2UgdGhlIGFjdHVhbCBTSUQgbm9pc2UgcGF0dGVybi4gU2VlOlxyXG4vLyBodHRwczovL2NvZGViYXNlNjQub3JnL2Rva3UucGhwP2lkPWJhc2U6bm9pc2Vfd2F2ZWZvcm1cclxuZm9yIChsZXQgaSA9IDA7IGkgPCBub2lzZUJ1ZmZlclNpemU7IGkrKykge1xyXG4gIG5vaXNlRGF0YVtpXSA9IChNYXRoLnJhbmRvbSgpICogMikgLSAxO1xyXG59XHJcblxyXG4vLyBBdCB0aW1lIG9mIHdyaXRpbmcsIG1hY09TIFNhZmFyaSAodjEzLjAuMykgZG9lc24ndCBzdXBwb3J0XHJcbi8vIENvbnN0YW50U291cmNlTm9kZSwgc28gd2UnbGwgbW9ua2V5IHBhdGNoIGEgc3R1YiBpbiBpdHMgcGxhY2UuXHJcbi8vIEFsdGVybmF0aXZlbHksIHdlIGNvdWxkIHVzZSBhIGJ1ZmZlciBub2RlIHdpdGggY29uc3RhbnQgb3V0cHV0LCBidXQgSSdtXHJcbi8vIGhvcGluZyBBcHBsZSB3aWxsIGV2ZW50dWFsbHkgaW1wbGVtZW50IGl0LlxyXG5pZiAoZ2xvYmFsVGhpcy5Db25zdGFudFNvdXJjZU5vZGUgPT09IHVuZGVmaW5lZCkge1xyXG4gIGNvbnNvbGUud2FybihcIllvdXIgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgQ29uc3RhbnRTb3VyY2VOb2RlLiBQdWxzZSB3aWR0aCBtb2R1bGF0aW9uIGRpc2FibGVkLlwiKTtcclxuICBnbG9iYWxUaGlzLkNvbnN0YW50U291cmNlTm9kZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuc3RhcnQgICA9ICgpID0+IHt9O1xyXG4gICAgdGhpcy5jb25uZWN0ID0gKCkgPT4ge307XHJcbiAgICB0aGlzLm9mZnNldCAgPSB7fTtcclxuICB9O1xyXG59XHJcblxyXG4vLyBTZXQgdXAgdm9pY2VzXHJcblswLCAxLCAyXS5mb3JFYWNoKFxyXG4gIHZvaWNlID0+IHtcclxuXHJcbiAgICBjb25zdCBvc2NpbGxhdG9yICA9IGF1ZGlvQ3R4LmNyZWF0ZU9zY2lsbGF0b3IoKTtcclxuICAgIGNvbnN0IHdoaXRlTm9pc2UgID0gYXVkaW9DdHguY3JlYXRlQnVmZmVyU291cmNlKCk7XHJcbiAgICBjb25zdCB2b2ljZUdhaW4gICA9IGF1ZGlvQ3R4LmNyZWF0ZUdhaW4oKTtcclxuICAgIGNvbnN0IHdhdmVHYWluICAgID0gYXVkaW9DdHguY3JlYXRlR2FpbigpO1xyXG4gICAgY29uc3Qgbm9pc2VHYWluICAgPSBhdWRpb0N0eC5jcmVhdGVHYWluKCk7XHJcbiAgICBjb25zdCB0aHJlc2hvbGRlciA9IGF1ZGlvQ3R4LmNyZWF0ZVdhdmVTaGFwZXIoKTtcclxuXHJcbiAgICAvLyB2b2ljZUdhaW46IHNldHMgYSB2b2ljZSB2b2x1bWUgKGZvciB0aGUgQURTUiBlbnZlbG9wZSksIGZsb3dpbmcgaW4gdG9cclxuICAgIC8vIHRoZSBtYXN0ZXIgZ2Fpbi5cclxuICAgIHZvaWNlR2Fpbi5nYWluLnZhbHVlID0gMDtcclxuICAgIHZvaWNlR2Fpbi5jb25uZWN0KG1hc3RlckdhaW4pO1xyXG5cclxuICAgIC8vIHRocmVzaG9sZGVyOiB0byBpbXBsZW1lbnQgcmVjdGFuZ2xlIHdhdmVzLiBJdHMgaW5wdXRzIGFyZSBhIHRyaWFuZ2xlXHJcbiAgICAvLyB3YXZlIChmcm9tIHdhdmVHYWluKSBhbmQgYSB2YXJpYWJsZSBEQyBvZmZzZXQgKGZyb20gZGNTb3VyY2UpLlxyXG4gICAgLy8gSXQgc3VtcyB0aGVtIGFuZCB0aHJlc2hvbGRzIHRoZSBvdXRwdXQgdG8gKC0xLCAxKS5cclxuICAgIHRocmVzaG9sZGVyLmN1cnZlID0gdGhyZXNob2xkZXJDdXJ2ZTtcclxuICAgIHRocmVzaG9sZGVyLmNvbm5lY3Qod2F2ZUdhaW4pO1xyXG5cclxuICAgIC8vIGRjU291cmNlOiBzZXQgYnkgdGhlIHB1bHNlIHdpZHRoIHJlZ2lzdGVycywgdG8gaW5mbHVlbmNlIHRoZSB0aHJlc2hvbGRlci5cclxuICAgIGNvbnN0IGRjU291cmNlID0gbmV3IENvbnN0YW50U291cmNlTm9kZShhdWRpb0N0eCk7XHJcbiAgICBkY1NvdXJjZS5zdGFydCgpO1xyXG4gICAgZGNTb3VyY2UuY29ubmVjdCh0aHJlc2hvbGRlcik7XHJcblxyXG4gICAgLy8gb3NjaWxsYXRvcjogdGhlIHdhdmUgZ2VuZXJhdG9yIHRoYXQgd2lsbCBiZSB1c2VkIGZvciB0cmlhbmdsZSwgc2F3dG9vdGgsXHJcbiAgICAvLyBhbmQgcmVjdGFuZ2xlIHdhdmVmb3Jtcy5cclxuICAgIG9zY2lsbGF0b3IudHlwZSA9IFwidHJpYW5nbGVcIjtcclxuICAgIG9zY2lsbGF0b3IuZnJlcXVlbmN5LnZhbHVlID0gNDQwOyAgLy8gaGVydHpcclxuICAgIG9zY2lsbGF0b3IuY29ubmVjdCh3YXZlR2Fpbik7XHJcbiAgICBvc2NpbGxhdG9yLnN0YXJ0KCk7XHJcblxyXG4gICAgLy8gd2hpdGVOb2lzZTogdGhlIGdlbmVyYXRvciB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgdGhlIG5vaXNlIHdhdmVmb3JtLlxyXG4gICAgd2hpdGVOb2lzZS5idWZmZXIgPSBub2lzZUJ1ZmZlcjtcclxuICAgIHdoaXRlTm9pc2UubG9vcCA9IHRydWU7XHJcbiAgICB3aGl0ZU5vaXNlLmNvbm5lY3Qobm9pc2VHYWluKTtcclxuICAgIHdoaXRlTm9pc2Uuc3RhcnQoMCk7XHJcblxyXG4gICAgLy8gbm9pc2VHYWluOiBzaXRzIGJldHdlZW4gdGhlIHdoaXRlTm9pc2UgZ2VuZXJhdG9yIGFuZCB2b2ljZUdhaW4gdG9cclxuICAgIC8vIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCBub2lzZSB3aWxsIGdvIG91dCBvbiB0aGUgdm9pY2UgKGFsbCBvclxyXG4gICAgLy8gbm90aGluZykuXHJcbiAgICBub2lzZUdhaW4uZ2Fpbi52YWx1ZSA9IDA7XHJcbiAgICBub2lzZUdhaW4uY29ubmVjdCh2b2ljZUdhaW4pO1xyXG5cclxuICAgIC8vIHdhdmVHYWluOiBzaXRzIGJldHdlZW4gZWl0aGVyIHRoZSB0aHJlc2hvbGRlciBvciB0aGUgb3NjaWxsYXRvclxyXG4gICAgLy8gKGRlcGVuZGluZyBvbiB3aGV0aGVyIHdlJ3JlIHBsYXlpbmcgYSByZWN0YW5nbGUgd2F2ZSB2cy4gc2F3dG9vdGggb3JcclxuICAgIC8vIHRyaWFuZ2xlKSwgYW5kIGRldGVybWluZXMgd2hldGhlciBvciBub3Qgc291bmQgZnJvbSB0aGF0IHNvdXJjZSB3aWxsXHJcbiAgICAvLyBnbyBvdXQgb24gdGhlIHZvaWNlIChhbGwgb3Igbm90aGluZykuXHJcbiAgICB3YXZlR2Fpbi5nYWluLnZhbHVlID0gMDtcclxuICAgIHdhdmVHYWluLmNvbm5lY3Qodm9pY2VHYWluKTtcclxuXHJcblxyXG4gICAgdm9pY2VzW3ZvaWNlXSA9IHtcclxuICAgICAgb3NjaWxsYXRvcixcclxuICAgICAgdm9pY2VHYWluLFxyXG4gICAgICBub2lzZUdhaW4sXHJcbiAgICAgIHdhdmVHYWluLFxyXG4gICAgICB3aGl0ZU5vaXNlLFxyXG4gICAgICBkY1NvdXJjZSxcclxuICAgICAgdGhyZXNob2xkZXJcclxuICAgIH07XHJcbiAgfVxyXG4pXHJcblxyXG5mdW5jdGlvbiBzZXRNYXN0ZXJWb2x1bWUoYnl0ZSkge1xyXG4gIC8vIGJ5dGUgaXMgdGhlIHJhdyB3cml0ZSBieXRlOyBuZWVkcyBkaXNlbnRhbmdsaW5nXHJcbiAgbWFzdGVyR2Fpbi5nYWluLnZhbHVlID0gKChieXRlICYgMHhmKSAvIDE1KSAqIE1BU1RFUl9NVUxUSVBMSUVSO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRWb2ljZUZyZXF1ZW5jeSh2b2ljZSkge1xyXG5cclxuICBjb25zdCBsbyA9IHN0YXRlLnJlZ3NbKHZvaWNlICogNykgKyAwXTtcclxuICBjb25zdCBoaSA9IHN0YXRlLnJlZ3NbKHZvaWNlICogNykgKyAxXTtcclxuXHJcbiAgY29uc3Qgd29yZCA9IChoaSA8PCA4KSB8IGxvO1xyXG4gIGNvbnN0IGZyZXEgPSB3b3JkIC8gTUFTVEVSX1RVTklORztcclxuXHJcbiAgLy8gdm9pY2VzW3ZvaWNlXS5vc2NpbGxhdG9yLmZyZXF1ZW5jeS5zZXRWYWx1ZUF0VGltZShmcmVxLCBhdWRpb0N0eC5jdXJyZW50VGltZSk7XHJcbiAgdm9pY2VzW3ZvaWNlXS5vc2NpbGxhdG9yLmZyZXF1ZW5jeS52YWx1ZSA9IGZyZXE7XHJcbiAgdm9pY2VzW3ZvaWNlXS53aGl0ZU5vaXNlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IGZyZXEgLyAyMDAwO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRWb2ljZVB1bHNlV2lkdGgodm9pY2UpIHtcclxuXHJcbiAgLy8gUHVsc2Ugd2lkdGggaXMgYSAxMi1iaXQgbnVtYmVyLCBzcGxpdCBiZXR3ZWVuIGEgbG93Ynl0ZSBhbmQgaGlnaGJ5dGUuXHJcbiAgY29uc3QgbG8gPSAoc3RhdGUucmVnc1sodm9pY2UgKiA3KSArIDJdKSAmIDB4ZmY7XHJcbiAgY29uc3QgaGkgPSAoc3RhdGUucmVnc1sodm9pY2UgKiA3KSArIDNdKSAmIDB4MGY7XHJcblxyXG4gIGNvbnN0IHdpZHRoID0gKGhpIDw8IDgpIHwgbG87XHJcblxyXG4gIC8vIE1hcCAoMDAwLCBmZmYpIHdpZHRoIHZhbHVlIHRvIGEgKC0xLCAxKSBEQyBvZmZzZXRcclxuICBjb25zdCBkY09mZnNldCA9ICgod2lkdGggLyAweGZmZikgKiAyKSAtIDE7IFxyXG5cclxuICB2b2ljZXNbdm9pY2VdLmRjU291cmNlLm9mZnNldC52YWx1ZSA9IGRjT2Zmc2V0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRDb250cm9sUmVnaXN0ZXIodm9pY2UsIGJ5dGUpIHtcclxuXHJcbiAgLy8gVE9ETzogdGhpcyByZWxpZXMgb24gcmVzZXQgY29uZmlndXJpbmcgaXQgdG8gdGhlIGxhc3RDb250cm9sUmVnaXN0ZXIgdmFsdWVcclxuICAvLyBidXQgSSBoYXZlbid0IG1hZGUgaXQgZG8gdGhhdCB5ZXQuXHJcbiAgaWYgKChieXRlICYgMHhmMCkgIT09IHZvaWNlc1t2b2ljZV0ubGFzdENvbnRyb2xSZWdpc3Rlcikge1xyXG5cclxuICAgIC8vIFRoZW9yZXRpY2FsbHksIG5vIHR3byB3YXZlZm9ybXMgc2hvdWxkIGJlIG9uIGF0IHRoZSBzYW1lIHRpbWUuIEJ1dFxyXG4gICAgLy8gV2l6YmFsbCBkb2VzIHRoYXQgaW4gdm9pY2VzIDEgYW5kIDIgKHRyaWFuZ2xlIGFuZCByZWN0YW5nbGUpIGxhdGUgaW50b1xyXG4gICAgLy8gc29uZyAzLCBhbmQgaXQncyBjbGVhciBmcm9tIHJlYWwgaGFyZHdhcmUgKGF0IGxlYXN0IG9uIGEgNjU4MSkgdGhhdFxyXG4gICAgLy8gcmVjdGFuZ2xlIHdpbnMgb3V0LlxyXG4gICAgaWYgKGJ5dGUgJiAweDgwKSB7XHJcbiAgICAgIC8vIE5vaXNlXHJcbiAgICAgIHZvaWNlc1t2b2ljZV0uIHdhdmVHYWluLmdhaW4udmFsdWUgPSAwO1xyXG4gICAgICB2b2ljZXNbdm9pY2VdLm5vaXNlR2Fpbi5nYWluLnZhbHVlID0gMTtcclxuICAgIH1cclxuXHJcbiAgICBlbHNlIGlmIChieXRlICYgMHg0MCkge1xyXG4gICAgICAvLyBSZWN0YW5nbGUgKHB1bHNlKVxyXG4gICAgICAvLyAoWWVzIGltcGxlbWVudGVkIGFzIGEgdHJpYW5nbGUgd2F2ZS4gSXQgZ2V0cyBhZGRlZCB0byBhbiBvZmZzZXQsIHRoZW5cclxuICAgICAgLy8gdGhyZXNob2xkZWQsIHRvIGVuZCB1cCBhcyB0aGUgcHVsc2Ugd2F2ZSByZXF1ZXN0ZWQuKVxyXG4gICAgICB2b2ljZXNbdm9pY2VdLm9zY2lsbGF0b3IudHlwZSA9IFwidHJpYW5nbGVcIjtcclxuICAgICAgdm9pY2VzW3ZvaWNlXS4gd2F2ZUdhaW4uZ2Fpbi52YWx1ZSA9IDE7XHJcbiAgICAgIHZvaWNlc1t2b2ljZV0ubm9pc2VHYWluLmdhaW4udmFsdWUgPSAwO1xyXG4gICAgICB2b2ljZXNbdm9pY2VdLm9zY2lsbGF0b3IuZGlzY29ubmVjdCgpO1xyXG4gICAgICB2b2ljZXNbdm9pY2VdLm9zY2lsbGF0b3IuY29ubmVjdCh2b2ljZXNbdm9pY2VdLnRocmVzaG9sZGVyKTtcclxuICAgIH1cclxuXHJcbiAgICBlbHNlIGlmIChieXRlICYgMHgyMCkge1xyXG4gICAgICAvLyBTYXd0b290aFxyXG4gICAgICB2b2ljZXNbdm9pY2VdLm9zY2lsbGF0b3IudHlwZSA9IFwic2F3dG9vdGhcIjtcclxuICAgICAgdm9pY2VzW3ZvaWNlXS4gd2F2ZUdhaW4uZ2Fpbi52YWx1ZSA9IDE7XHJcbiAgICAgIHZvaWNlc1t2b2ljZV0ubm9pc2VHYWluLmdhaW4udmFsdWUgPSAwO1xyXG4gICAgICB2b2ljZXNbdm9pY2VdLm9zY2lsbGF0b3IuZGlzY29ubmVjdCgpO1xyXG4gICAgICB2b2ljZXNbdm9pY2VdLm9zY2lsbGF0b3IuY29ubmVjdCh2b2ljZXNbdm9pY2VdLndhdmVHYWluKTtcclxuICAgIH1cclxuXHJcbiAgICBlbHNlIGlmIChieXRlICYgMHgxMCkge1xyXG4gICAgICAvLyBUcmlhbmdsZVxyXG4gICAgICB2b2ljZXNbdm9pY2VdLm9zY2lsbGF0b3IudHlwZSA9IFwidHJpYW5nbGVcIjtcclxuICAgICAgdm9pY2VzW3ZvaWNlXS4gd2F2ZUdhaW4uZ2Fpbi52YWx1ZSA9IDE7XHJcbiAgICAgIHZvaWNlc1t2b2ljZV0ubm9pc2VHYWluLmdhaW4udmFsdWUgPSAwO1xyXG4gICAgICB2b2ljZXNbdm9pY2VdLm9zY2lsbGF0b3IuZGlzY29ubmVjdCgpO1xyXG4gICAgICB2b2ljZXNbdm9pY2VdLm9zY2lsbGF0b3IuY29ubmVjdCh2b2ljZXNbdm9pY2VdLndhdmVHYWluKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFRPRE86IGFkZCB0aGlzIHRvIGRvY3NcclxuICB2b2ljZXNbdm9pY2VdLmxhc3RDb250cm9sUmVnaXN0ZXIgPSBieXRlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRWb2ljZVZvbHVtZSh2b2ljZSwgdm9sdW1lKSB7XHJcbiAgdm9pY2VzW3ZvaWNlXS52b2ljZUdhaW4uZ2Fpbi52YWx1ZSA9IHZvbHVtZTtcclxufVxyXG5cclxuZnVuY3Rpb24gb25SZWdXcml0ZShyZWcsIGJ5dGUpIHtcclxuXHJcbiAgc3RhdGUucmVnc1tyZWddID0gYnl0ZTtcclxuXHJcbiAgc3dpdGNoIChyZWcpIHtcclxuXHJcbiAgICBjYXNlIDB4MDA6ICAgIC8vICRkNDAwOiB2b2ljZSAxIGZyZXF1ZW5jeSAobG93LWJ5dGUpXHJcbiAgICBjYXNlIDB4MDE6ICAgIC8vICRkNDAxOiB2b2ljZSAxIGZyZXF1ZW5jeSAoaGlnaC1ieXRlKVxyXG4gICAgICByZXR1cm4gc2V0Vm9pY2VGcmVxdWVuY3koMCk7XHJcblxyXG4gICAgY2FzZSAweDAyOiAgICAvLyAkZDQwMjogdm9pY2UgMSBwdWxzZSB3aWR0aCAobG93LWJ5dGUpXHJcbiAgICBjYXNlIDB4MDM6ICAgIC8vICRkNDAzOiB2b2ljZSAxIHB1bHNlIHdpZHRoIChoaWdoLWJ5dGUpXHJcbiAgICAgIHJldHVybiBzZXRWb2ljZVB1bHNlV2lkdGgoMCk7XHJcblxyXG4gICAgY2FzZSAweDA0OiAgICAvLyAkZDQwNDogdm9pY2UgMSBjb250cm9sIHJlZ2lzdGVyXHJcbiAgICAgIHJldHVybiBzZXRDb250cm9sUmVnaXN0ZXIoMCwgYnl0ZSk7XHJcblxyXG5cclxuICAgIGNhc2UgMHgwNzogICAgLy8gJGQ0MDc6IHZvaWNlIDIgZnJlcXVlbmN5IChsb3ctYnl0ZSlcclxuICAgIGNhc2UgMHgwODogICAgLy8gJGQ0MDg6IHZvaWNlIDIgZnJlcXVlbmN5IChoaWdoLWJ5dGUpXHJcbiAgICAgIHJldHVybiBzZXRWb2ljZUZyZXF1ZW5jeSgxKTtcclxuXHJcbiAgICBjYXNlIDB4MDk6ICAgIC8vICRkNDA5OiB2b2ljZSAyIHB1bHNlIHdpZHRoIChsb3ctYnl0ZSlcclxuICAgIGNhc2UgMHgwYTogICAgLy8gJGQ0MGE6IHZvaWNlIDIgcHVsc2Ugd2lkdGggKGhpZ2gtYnl0ZSlcclxuICAgICAgcmV0dXJuIHNldFZvaWNlUHVsc2VXaWR0aCgxKTtcclxuXHJcbiAgICBjYXNlIDB4MGI6ICAgIC8vICRkNDBiOiB2b2ljZSAyIGNvbnRyb2wgcmVnaXN0ZXJcclxuICAgICAgcmV0dXJuIHNldENvbnRyb2xSZWdpc3RlcigxLCBieXRlKTtcclxuXHJcblxyXG4gICAgY2FzZSAweDBlOiAgICAvLyAkZDQwZTogdm9pY2UgMyBmcmVxdWVuY3kgKGxvdy1ieXRlKVxyXG4gICAgY2FzZSAweDBmOiAgICAvLyAkZDQwZjogdm9pY2UgMyBmcmVxdWVuY3kgKGhpZ2gtYnl0ZSlcclxuICAgICAgcmV0dXJuIHNldFZvaWNlRnJlcXVlbmN5KDIpO1xyXG5cclxuICAgIGNhc2UgMHgxMDogICAgLy8gJGQ0MTA6IHZvaWNlIDMgcHVsc2Ugd2lkdGggKGxvdy1ieXRlKVxyXG4gICAgY2FzZSAweDExOiAgICAvLyAkZDQxMTogdm9pY2UgMyBwdWxzZSB3aWR0aCAoaGlnaC1ieXRlKVxyXG4gICAgICByZXR1cm4gc2V0Vm9pY2VQdWxzZVdpZHRoKDIpO1xyXG5cclxuICAgIGNhc2UgMHgxMjogICAgLy8gJGQ0MTI6IHZvaWNlIDMgY29udHJvbCByZWdpc3RlclxyXG4gICAgICByZXR1cm4gc2V0Q29udHJvbFJlZ2lzdGVyKDIsIGJ5dGUpO1xyXG5cclxuXHJcbiAgICBjYXNlIDB4MTg6ICAgIC8vICRkNDE4OiBtYXN0ZXIgdm9sdW1lIGFuZCBmaWx0ZXIgbW9kZXNcclxuICAgICAgcmV0dXJuIHNldE1hc3RlclZvbHVtZShieXRlKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlc2V0KCkge1xyXG4gIC8vIFRPRE8hXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhdHRhY2gobmFzY2VudEM2NCkge1xyXG4gIG5hc2NlbnRDNjQuYXVkaW8gPSB7XHJcbiAgICAvLyBDb250cm9sXHJcbiAgICByZXNldCxcclxuICAgIC8vIEludGVyZmFjZS1zcGVjaWZpYyBoYW5kbGVyc1xyXG4gICAgc2V0Vm9pY2VWb2x1bWUsXHJcbiAgICBvblJlZ1dyaXRlLFxyXG4gICAgdXNlckRpZEludGVyYWN0LFxyXG4gICAgc2V0VWlHYWluLFxyXG4gIH07XHJcblxyXG4gIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc5NDQ0NjAvZGV0ZWN0LXNhZmFyaS1icm93c2VyXHJcbiAgY29uc3QgaXNTYWZhcmkgPSAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG5cclxuICBpZiAoaXNTYWZhcmkpIHtcclxuICAgIC8vIEVmZmVjdHMgcmVwb3J0ZWQgYmVsb3cgcmVsYXRlIHRvIG1hY09TIFNhZmFyaSB2MTMuMC4zLCBjdXJyZW50IGF0IHRpbWVcclxuICAgIC8vIG9mIHdyaXRpbmcuIEFsc28sIGl0J2xsIHJ1biByZWFsbHkgc2xvd2x5IGlmIHRoZSBKYXZhU2NyaXB0IGNvbnNvbGUnc1xyXG4gICAgLy8gb3Blbi5cclxuICAgIGNvbnN0IHVzZVN0dWIgPSBjb25maXJtKFxyXG4gICAgICBcIkl0IGxvb2tzIGxpa2UgeW91J3JlIHJ1bm5pbmcgU2FmYXJpLiBTYWZhcmkncyBzb3VuZCBpbXBsZW1lbnRhdGlvbiBcIiArXHJcbiAgICAgIFwiaW50cm9kdWNlcyB3ZWlyZCBzbGlkZXMsIGFuZCBpc24ndCBjb21wdGlibGUgd2l0aCBvdXIgcHVsc2Ugd2lkdGggXCIgK1xyXG4gICAgICBcIm1vZHVsYXRvci4gRGlzYWJsZSBhdWRpbz9cIlxyXG4gICAgKTtcclxuXHJcbiAgICBpZiAodXNlU3R1Yikge1xyXG4gICAgICBuYXNjZW50QzY0LmF1ZGlvLnNldFZvaWNlVm9sdW1lICA9ICgpID0+IHt9O1xyXG4gICAgICBuYXNjZW50QzY0LmF1ZGlvLm9uUmVnV3JpdGUgICAgICA9ICgpID0+IHt9O1xyXG4gICAgICBuYXNjZW50QzY0LmF1ZGlvLnVzZXJEaWRJbnRlcmFjdCA9ICgpID0+IHt9O1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gdXNlckRpZEludGVyYWN0KCkge1xyXG4gIC8vIElmIHRoZSBhdWRpb0NvbnRleHQgd2FzIGNyZWF0ZWQgaW4gYSBzdXNwZW5kZWQgc3RhdGUgKHNlZVxyXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi91cGRhdGVzLzIwMTcvMDkvYXV0b3BsYXktcG9saWN5LWNoYW5nZXMjd2ViYXVkaW9cclxuICAvLyApLCBsZXQncyB0cnkgdG8gcmVzdW1lIGl0IG5vdyB0aGF0IHdlJ3ZlIG9ic2VydmVkIGEgdXNlciBpbnRlcmFjdGlvbi5cclxuICBpZiAoc3RhdGUuc3VzcGVuZGVkKSBhdWRpb0N0eC5yZXN1bWUoKTtcclxuXHJcbiAgLy8gSWYgc3VjY2Vzc2Z1bCwgYXVkaW9DdHguc3RhdGUgbWF5IG5vdCBjaGFuZ2UgaW1tZWRpYXRlbHkuIChNeSBvYnNlcnZhdGlvbjpcclxuICAvLyBGaXJlZm94IDc1IGRvZXM7IENocm9tZSA4MSBkb2VzIG5vdC4pXHJcbiAgLy8gVGh1cywganVzdCB0byB0cmFjayB3aGV0aGVyIHRoZSBhdWRpbydzIGFjdHVhbGx5IG9uIGF0IGFueSBnaXZlbiB0aW1lIChub3RcclxuICAvLyB0aGF0IHRoZSBmcm9udGVuZCBjdXJyZW50bHkgcmVwb3J0cyBpdCksIHdlIGhhdmUgYW4gaW50ZXJ2YWwgcG9sbGVyIHRoYXQgXHJcbiAgLy8gY2hlY2tzIGFuZCB1cGRhdGVzIHRoZSBgc3VzcGVuZGVkYCB2YXJpYWJsZS5cclxuXHJcbiAgLy8gQWxzbywgbm90ZSB0aGF0IHRoaXMgcmVzdW1wdGlvbiBtYXkgbm90IGJlIHN1Y2Nlc3NmdWwuIEEga2V5ZG93biBldmVudCBvZlxyXG4gIC8vIGEgbW9kaWZpZXIgb3IgZXNjYXBlIGtleSwgZm9yIGV4YW1wbGUsIHdvdWxkIHRyaWdnZXIgdGhpcyBmdW5jdGlvbiwgYnV0IGlzXHJcbiAgLy8gaW5zdWZmaWNpZW50IGZvciB0aGUgYnJvd3NlcidzIGFudGktbnVpc2FuY2UgcG9saWN5IHRvIGFsbG93IHRoZSBhdWRpb1xyXG4gIC8vIHJlc3VtcHRpb24uXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldFVpR2Fpbih2YWx1ZSkge1xyXG4gIHVpR2Fpbi5nYWluLnZhbHVlID0gdmFsdWU7IFxyXG59XHJcbiIsIi8qXHJcbiAgIENvbHVtbi1yb3cgY29tYmluYXRpb25zIGZvciB0aGUgQzY0J3MgcGh5c2ljYWwga2V5c1xyXG4gIFxyXG4gICBFeGFtcGxlOiBDb21tb2RvcmUga2V5IGlzIFs3LCA1XSwgbWVhbmluZyB0aGF0IGlmLCB3aGVuIHdyaXRpbmcgdG8gQ0lBMVxyXG4gICBwb3J0IEEgKCRkYzAwKSwgSSBzZXQgdGhlIGtleWJvYXJkIHNjYW4gdG8gY29sdW1uIDcgKGJ5IHdyaXRpbmcgYml0IDcsIHNvXHJcbiAgIDBiMTAwMDAwMDApLCBJJ2QgZXhwZWN0IHRvIHNlZSB0aGUgc3RhdHVzIG9mIHRoZSBDb21tb2RvcmUga2V5IGluIGJpdCA1IHdoZW5cclxuICAgcmVhZGluZyBDSUExIHBvcnQgQi5cclxuICBcclxuICAgTm90ZSB0aGF0IHRoZSBSZXN0b3JlIGtleSBkb2Vzbid0IGhhdmUgYSBwb3NpdGlvbiBpbiB0aGlzIHRhYmxlOiBpdCdzIHdpcmVkXHJcbiAgIGRpcmVjdGx5IHRvIHRoZSBOTUkgbGluZSBhbmQgaGFzIG5vIHBvc2l0aW9uIGluIHRoZSBtYXRyaXguIFRoZXJlJ3Mgbm9cclxuICAgc2VwYXJhdGUgZW50cnkgZm9yIFNoaWZ0IExvY2sgZWl0aGVyLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjb25zdCBidXR0b25OYW1lVG9NYXRyaXhQb3MgPSB7XHJcbiAgUnVuU3RvcDogICAgICBbIDcsIDcgXSxcclxuICBROiAgICAgICAgICAgIFsgNywgNiBdLFxyXG4gIENvbW1vZG9yZTogICAgWyA3LCA1IF0sICAgLy8gdW5tYXBwZWQgaW4gbmF0dXJhbFxyXG4gIFNwYWNlOiAgICAgICAgWyA3LCA0IF0sXHJcbiAgTnVtMjogICAgICAgICBbIDcsIDMgXSxcclxuICBDdHJsOiAgICAgICAgIFsgNywgMiBdLFxyXG4gIExlZnRBcnJvdzogICAgWyA3LCAxIF0sICAgLy8gdGhlIGtleSB0aGF0IGRyYXdzIGEgJ+KGkCcsIG5vdCBjdXJzb3ItbGVmdFxyXG4gIE51bTE6ICAgICAgICAgWyA3LCAwIF0sXHJcblxyXG4gIFNsYXNoOiAgICAgICAgWyA2LCA3IF0sXHJcbiAgVXBBcnJvdzogICAgICBbIDYsIDYgXSwgICAvLyB0aGUga2V5IHRoYXQgZHJhd3MgYSAn4oaRJywgbm90IGN1cnNvci11cFxyXG4gIEVxdWFsOiAgICAgICAgWyA2LCA1IF0sXHJcbiAgUmlnaHRTaGlmdDogICBbIDYsIDQgXSwgICAvLyB1bm1hcHBlZCBpbiBuYXR1cmFsXHJcbiAgQ2xySG9tZTogICAgICBbIDYsIDMgXSxcclxuICBTZW1pY29sb246ICAgIFsgNiwgMiBdLFxyXG4gIEFzdGVyaXNrOiAgICAgWyA2LCAxIF0sXHJcbiAgUG91bmQ6ICAgICAgICBbIDYsIDAgXSxcclxuXHJcbiAgQ29tbWE6ICAgICAgICBbIDUsIDcgXSxcclxuICBBdDogICAgICAgICAgIFsgNSwgNiBdLFxyXG4gIENvbG9uOiAgICAgICAgWyA1LCA1IF0sXHJcbiAgUGVyaW9kOiAgICAgICBbIDUsIDQgXSxcclxuICBNaW51czogICAgICAgIFsgNSwgMyBdLFxyXG4gIEw6ICAgICAgICAgICAgWyA1LCAyIF0sXHJcbiAgUDogICAgICAgICAgICBbIDUsIDEgXSxcclxuICBQbHVzOiAgICAgICAgIFsgNSwgMCBdLFxyXG5cclxuICBOOiAgICAgICAgICAgIFsgNCwgNyBdLFxyXG4gIE86ICAgICAgICAgICAgWyA0LCA2IF0sXHJcbiAgSzogICAgICAgICAgICBbIDQsIDUgXSxcclxuICBNOiAgICAgICAgICAgIFsgNCwgNCBdLFxyXG4gIE51bTA6ICAgICAgICAgWyA0LCAzIF0sXHJcbiAgSjogICAgICAgICAgICBbIDQsIDIgXSxcclxuICBJOiAgICAgICAgICAgIFsgNCwgMSBdLFxyXG4gIE51bTk6ICAgICAgICAgWyA0LCAwIF0sXHJcblxyXG4gIFY6ICAgICAgICAgICAgWyAzLCA3IF0sXHJcbiAgVTogICAgICAgICAgICBbIDMsIDYgXSxcclxuICBIOiAgICAgICAgICAgIFsgMywgNSBdLFxyXG4gIEI6ICAgICAgICAgICAgWyAzLCA0IF0sXHJcbiAgTnVtODogICAgICAgICBbIDMsIDMgXSxcclxuICBHOiAgICAgICAgICAgIFsgMywgMiBdLFxyXG4gIFk6ICAgICAgICAgICAgWyAzLCAxIF0sXHJcbiAgTnVtNzogICAgICAgICBbIDMsIDAgXSxcclxuXHJcbiAgWDogICAgICAgICAgICBbIDIsIDcgXSxcclxuICBUOiAgICAgICAgICAgIFsgMiwgNiBdLFxyXG4gIEY6ICAgICAgICAgICAgWyAyLCA1IF0sXHJcbiAgQzogICAgICAgICAgICBbIDIsIDQgXSxcclxuICBOdW02OiAgICAgICAgIFsgMiwgMyBdLFxyXG4gIEQ6ICAgICAgICAgICAgWyAyLCAyIF0sXHJcbiAgUjogICAgICAgICAgICBbIDIsIDEgXSxcclxuICBOdW01OiAgICAgICAgIFsgMiwgMCBdLFxyXG5cclxuICBMZWZ0U2hpZnQ6ICAgIFsgMSwgNyBdLFxyXG4gIEU6ICAgICAgICAgICAgWyAxLCA2IF0sXHJcbiAgUzogICAgICAgICAgICBbIDEsIDUgXSxcclxuICBaOiAgICAgICAgICAgIFsgMSwgNCBdLFxyXG4gIE51bTQ6ICAgICAgICAgWyAxLCAzIF0sXHJcbiAgQTogICAgICAgICAgICBbIDEsIDIgXSxcclxuICBXOiAgICAgICAgICAgIFsgMSwgMSBdLFxyXG4gIE51bTM6ICAgICAgICAgWyAxLCAwIF0sXHJcblxyXG4gIEN1cnNvckRvd246ICAgWyAwLCA3IF0sXHJcbiAgRjU6ICAgICAgICAgICBbIDAsIDYgXSxcclxuICBGMzogICAgICAgICAgIFsgMCwgNSBdLFxyXG4gIEYxOiAgICAgICAgICAgWyAwLCA0IF0sXHJcbiAgRjc6ICAgICAgICAgICBbIDAsIDMgXSxcclxuICBDdXJzb3JSaWdodDogIFsgMCwgMiBdLFxyXG4gIFJldHVybjogICAgICAgWyAwLCAxIF0sXHJcbiAgSW5zdERlbDogICAgICBbIDAsIDAgXSxcclxufTtcclxuIiwiaW1wb3J0IHsgaW5nZXN0IH0gZnJvbSBcIi4vaW5nZXN0LmpzXCI7XHJcblxyXG4vLyBib3VuZCBieSBhdHRhY2hcclxubGV0IGM2NDtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhdHRhY2gobmFzY2VudEM2NCkge1xyXG4gIGM2NCA9IG5hc2NlbnRDNjQ7XHJcblxyXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxyXG4gICAgXCJsb2FkXCIsXHJcbiAgICAoKSA9PiB7XHJcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXHJcbiAgICAgICAgXCJkcmFnb3ZlclwiLFxyXG4gICAgICAgIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgLy8gVGhpcyBsb29rcyBsaWtlIGl0IGlzbid0IGRvaW5nIGFueXRoaW5nLCBidXQgd2l0aG91dCBpdCwgZHJhZy1hbmQtZHJvcFxyXG4gICAgICAgICAgLy8gZG9lc24ndCB3b3JrLlxyXG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICk7XHJcblxyXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFxyXG4gICAgICAgIFwiZHJvcFwiLFxyXG4gICAgICAgIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgIG9uRHJvcChldmVudCk7XHJcblxyXG4gICAgICAgICAgLy8gRm9yIHRoZSB3ZWIgYXVkaW8gQVBJLCB0aGUgZHJvcCBldmVudCBpcyBvbmUgb2YgdGhlIGludGVyYWN0aW9uc1xyXG4gICAgICAgICAgLy8gd2hvc2Ugb2NjdXJyZW5jZSBwZXJtaXRzIHRoZSBBdWRpb0NvbnRleHQgdG8gYmUgcmVzdW1lZC4gTW9yZW92ZXIsXHJcbiAgICAgICAgICAvLyBpdCdzIGxpa2VseSB0byBiZSB0aGUgb25seSBzdWNoIGludGVyYWN0aW9uIGJlZm9yZSB0aGUgdXNlciB3b3VsZFxyXG4gICAgICAgICAgLy8gZXhwZWN0IHRvIGhlYXIgc291bmQuXHJcbiAgICAgICAgICBpZiAoYzY0LmF1ZGlvLnVzZXJEaWRJbnRlcmFjdCkgYzY0LmF1ZGlvLnVzZXJEaWRJbnRlcmFjdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgKTtcclxuICAgIH1cclxuICApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvbkRyb3AoZXZlbnQpIHtcclxuICBjb25zdCBbZmlsZSwgZXh0cmFGaWxlXSA9IGV2ZW50LmRhdGFUcmFuc2Zlci5maWxlcztcclxuXHJcbiAgaWYgKGV4dHJhRmlsZSkge1xyXG4gICAgZXJyKFwiRHJvcCBvbmx5IG9uZSBmaWxlIGF0IG9uY2VcIik7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpZiAoIWZpbGUpIHtcclxuICAgIHRyeUxvYWRGcm9tSW50ZXJuYWxseURyYWdnZWRTbmFwc2hvdChldmVudCk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG4gIHJlYWRlci5vbmxvYWQgPSAoZXZlbnQpID0+IHtcclxuICAgIGluZ2VzdChjNjQsIGZpbGUubmFtZSwgbmV3IFVpbnQ4QXJyYXkocmVhZGVyLnJlc3VsdCkpO1xyXG4gIH07XHJcblxyXG4gIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihmaWxlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZXJyKHN0cikge1xyXG4gIGlmIChjNjQuaG9va3MucmVwb3J0RXJyb3IpIGM2NC5ob29rcy5yZXBvcnRFcnJvcihzdHIpO1xyXG4gIGVsc2UgYWxlcnQoc3RyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJ5TG9hZEZyb21JbnRlcm5hbGx5RHJhZ2dlZFNuYXBzaG90KGV2ZW50KSB7XHJcbiAgLy8gVGhlIGV2ZW50LmZpbGUgd2FzIGZhbHN5LCBtZWFuaW5nIHF1aXRlIHBvc3NpYmx5IHRoYXQgdGhlIHVzZXIgZHJhZ2dlZCBhXHJcbiAgLy8gc25hcHNob3QgbGluayBmcm9tIHRoZSA8YT4gdG8gdGhlIG1haW4gd2luZG93LiBUaGUgY29kZSBiZWxvdyBpcyBhIHN1cGVyXHJcbiAgLy8gYXdrd2FyZCBhdHRlbXB0IGF0IGxvYWRpbmcgaW4gdGhhdCBjaXJjdW1zdGFuY2UuIEF0IHRpbWUgb2Ygd3JpdGluZywgaXRcclxuICAvLyB3b3JrcyBpbiBDaHJvbWUsIEZpcmVmb3gsIGFuZCBTYWZhcmksIGJ1dCBJIGRvbid0IHRydXN0IGl0IHZlcnkgZmFyLlxyXG4gIC8vXHJcbiAgLy8gSSBiZWxpZXZlIHRoZXJlJ3MgYSBkcmFnLWFuZC1kcm9wIGludGVyZmFjZSB3aGljaCB3b3VsZCBhbGxvdyBmb3IgRE9NXHJcbiAgLy8gbm9kZXMgdG8gYmUgZHJhZ2dlZCB0byB5b3VyIGRlc2t0b3AgaW4gYSB3YXkgdGhhdCBjcmVhdGVzIGZpbGVzIHRoZXJlLiBJZlxyXG4gIC8vIHNvLCBpdCdkIGJlIGdvb2QgdG8gc3VwcG9ydCB0aGF0OyBhbmQgdGhlIGJlbG93IHdvdWxkIGxpa2VseSBhZG9wdFxyXG4gIC8vIGFjY29yZGluZ2x5LlxyXG5cclxuICBmb3IgKGxldCBpdGVtIG9mIGV2ZW50LmRhdGFUcmFuc2Zlci5pdGVtcykge1xyXG4gICAgaWYgKGl0ZW0udHlwZSAhPT0gXCJ0ZXh0L3BsYWluXCIpIGNvbnRpbnVlO1xyXG5cclxuICAgIGl0ZW0uZ2V0QXNTdHJpbmcoXHJcbiAgICAgIGFzeW5jICh1cmwpID0+IHtcclxuXHJcbiAgICAgICAgLy8gZXhwZWN0IGEgVVJMIGxpa2UgYGJsb2I6aHR0cDovL2xvY2FsaG9zdDo4MDgwLyhzb21lIGd1aWQpYFxyXG4gICAgICAgIGlmICghL15ibG9iXFw6Ly50ZXN0KHVybCkpIHJldHVybjtcclxuXHJcbiAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IChhd2FpdCBmZXRjaCh1cmwpKS5qc29uKCk7XHJcblxyXG4gICAgICAgIGluZ2VzdChcclxuICAgICAgICAgIGM2NCxcclxuICAgICAgICAgIFwic25hcHNob3QuanNvblwiLFxyXG4gICAgICAgICAgLy8g8J+krlxyXG4gICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoXHJcbiAgICAgICAgICAgIEFycmF5XHJcbiAgICAgICAgICAgICAgLmZyb20oSlNPTi5zdHJpbmdpZnkoanNvbikpXHJcbiAgICAgICAgICAgICAgLm1hcChzdHIgPT4gc3RyLmNoYXJDb2RlQXQoMCkpXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgKTtcclxuXHJcbiAgICBicmVhaztcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgbWFrZVBhcnNlciB9ICAgICAgICBmcm9tIFwiLi4vdG9vbHMvcGFyc2VyXCI7XHJcbmltcG9ydCB7IGxvYWRQcmcgfSAgICAgICAgICAgZnJvbSBcIi4uL3Rvb2xzL2xvYWRQcmdcIjtcclxuaW1wb3J0IHsgQVdBSVRfS0VZQk9BUkRfUEMgfSBmcm9tIFwiLi4vdG9vbHMvcm9tTG9jYXRpb25zXCI7IFxyXG5cclxuXHJcbi8vIEZvcm1hdCByZWZlcmVuY2U6XHJcbi8vIOKAoDEgaHR0cDovL3VudXNlZGluby5kZS9lYzY0L3RlY2huaWNhbC9mb3JtYXRzL2Q2NC5odG1sXHJcblxyXG5jb25zdCBwYXJzZURpclNlY3RvciA9IG1ha2VQYXJzZXIoKF8pID0+IHtcclxuXHJcbiAgY29uc3QgZW50cnkgPSAoXykgPT4gKHtcclxuICAgIG5leHRUcmFjazogICAgIF8uYnl0ZSgpLFxyXG4gICAgbmV4dFNlY3RvcjogICAgXy5ieXRlKCksXHJcbiAgICB0eXBlOiAgICAgICAgICBfLmJ5dGUoKSxcclxuICAgIHRyYWNrOiAgICAgICAgIF8uYnl0ZSgpLFxyXG4gICAgc2VjdG9yOiAgICAgICAgXy5ieXRlKCksXHJcbiAgICBuYW1lOiAgICAgICAgICBfLnN0cmluZygxNiksXHJcbiAgICBzaWRlU2VjVHJhY2s6ICBfLmJ5dGUoKSxcclxuICAgIHNpZGVTZWNTZWN0b3I6IF8uYnl0ZSgpLFxyXG4gICAgcmVsTGVuZ3RoOiAgICAgXy5ieXRlKCksXHJcbiAgICBfOiAgICAgICAgICAgICBfLnNraXAoNiksXHJcbiAgICBibG9ja3M6ICAgICAgICBfLndvcmRfbGUoKSxcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIG5ldyBBcnJheSg4KVxyXG4gICAgLmZpbGwoKVxyXG4gICAgLm1hcCgoKSA9PiBlbnRyeShfKSlcclxuICA7XHJcbn0pO1xyXG5cclxuY29uc3QgcGFyc2VGaWxlU2VjdG9yID0gbWFrZVBhcnNlcigoXykgPT4gKHtcclxuICBuZXh0VHJhY2s6ICBfLmJ5dGUoKSxcclxuICBuZXh0U2VjdG9yOiBfLmJ5dGUoKSxcclxuICBieXRlczogICAgICBfLnJlbWFpbmRlcigpLFxyXG59KSk7XHJcblxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluZ2VzdF9kNjQoYzY0LCBieXRlcykge1xyXG5cclxuICBpZiAoIWM2NC5ob29rcy5vbkQ2NEluZ2VzdCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fu4oCZdCBzaG93IC5kNjQgZGlyZWN0b3JpZXMgd2l0aCB0aGlzIGZyb250ZW5kXCIpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgZGlyID0gbG9hZERpcihieXRlcyk7XHJcblxyXG4gIC8vIGQ2NCBpbmdlc3RvciBob29rOiBnaXZlIGl0IGEgZGlyZWN0b3J5OyBpdCdsbCBwcmVzZW50IGEgZGlhbG9nIGZvciBwaWNraW5nXHJcbiAgLy8gd2hpY2ggUFJHIHRvIGxvYWQsIGFuZCByZXR1cm4gYSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIGFuIGVudHJ5IGZyb21cclxuICAvLyB0aGUgZGlyZWN0b3J5LiBUaGF0IGVudHJ5IGNvbnRhaW5zIGEgdHJhY2svc2VjdG9yLCB3aGljaCBkZWZpbmVkIHRoZSBzdGFydFxyXG4gIC8vIG9mIHRoZSBQUkcuXHJcbiAgLy9cclxuICAvLyAoVE9ETzogcmlnaHQgbm93LCBpZiB5b3UgY2xvc2UgdGhlIGRpYWxvZywgdGhlIHByb21pc2UganVzdCBzaXRzXHJcbiAgLy8gdW5yZXNvbHZlZCBmb3JldmVyLiBCZXR0ZXIgaWYgaXQgcmVzb2x2ZWQgdG8sIG9yIHRocmV3LCBudWxsKVxyXG4gIGNvbnN0IHsgdHJhY2ssIHNlY3RvciB9ID0gYXdhaXQgYzY0Lmhvb2tzLm9uRDY0SW5nZXN0KGRpcik7XHJcblxyXG4gIC8vIEZvbGxvdyB0aGUgdHJhY2svc2VjdG9yIGxpbmtzIHRvIHB1bGwgaW4gYWxsIHRoZSBieXRlc1xyXG4gIGNvbnN0IHByZyA9IGxvYWRGaWxlKGJ5dGVzLCB0cmFjaywgc2VjdG9yKTtcclxuXHJcbiAgLy8gLi4udGhlbiBib290IGl0IGluIHRoZSB1c3VhbCB3YXkuXHJcbiAgYzY0LnJ1bmxvb3AucmVzZXQoKTtcclxuICBhd2FpdCBjNjQucnVubG9vcC51bnRpbFBjKEFXQUlUX0tFWUJPQVJEX1BDKTtcclxuICBsb2FkUHJnKGM2NCwgcHJnKTtcclxuICBjNjQucnVubG9vcC50eXBlKFwiUlVOXFxyXCIpO1xyXG4gIGM2NC5ydW5sb29wLnJ1bigpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjYWxjQWJzU2VjdG9yKHRyYWNrLCBzZWN0b3IpIHtcclxuICAvLyBOb3RlOiBieSBjb252ZW50aW9uLCBgdHJhY2tgIGlzIG9uZS1pbmRleGVkOyBgc2VjdG9yYCBpcyB6ZXJvLWluZGV4ZWQuXHJcbiAgLy8gV2UgY291bGQgZG8gYSBzYW5pdHkgY2hlY2sgdGhhdCBzZWN0b3IgaXNuJ3QgdG9vIGJpZyBhIG51bWJlciBmb3IgdGhhdFxyXG4gIC8vIHRyYWNrLlxyXG4gIGlmICgodHJhY2sgPCAxKSB8fCAodHJhY2sgPiA0MCkpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIlRyYWNrIG91dCBvZiByYW5nZTogXCIgKyB0cmFjayk7XHJcbiAgfVxyXG5cclxuICAvLyBDb252ZXJ0IGBzZWN0b3JgIGZyb20gYmVpbmcgdHJhY2stcmVsYXRpdmUgdG8gYWJzb2x1dGVcclxuICB3aGlsZSAoLS10cmFjaykge1xyXG4gICAgaWYgICAgICAodHJhY2sgPj0gMzEpIHNlY3RvciArPSAxNztcclxuICAgIGVsc2UgaWYgKHRyYWNrID49IDI1KSBzZWN0b3IgKz0gMTg7XHJcbiAgICBlbHNlIGlmICh0cmFjayA+PSAxOCkgc2VjdG9yICs9IDE5O1xyXG4gICAgZWxzZSAgICAgICAgICAgICAgICAgIHNlY3RvciArPSAyMTtcclxuICB9XHJcblxyXG4gIHJldHVybiBzZWN0b3I7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxvYWRBYnNTZWN0b3IoZDY0LCBhYnNTZWN0b3IpIHtcclxuICBjb25zdCBkNjRPZmZzZXQgPSBhYnNTZWN0b3IgKiAyNTY7XHJcbiAgcmV0dXJuIGQ2NC5zbGljZShkNjRPZmZzZXQsIGQ2NE9mZnNldCArIDI1Nik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldExvYWRUcmFja1NlY3RvcldpdGhSZWN1ckNoZWNrKGQ2NCkge1xyXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgcmV0dXJuIGEgc2VjdG9yJ3MgYnl0ZXMsIGdpdmVuIGEgdHJhY2svc2VjdG9yXHJcbiAgLy8gbG9jYXRpb24sIGFuZCB3aWxsIHRocm93IGlmIHRoZSBzYW1lIGFic29sdXRlIHNlY3RvciBpcyByZXF1ZXN0ZWQgdHdpY2UuXHJcbiAgY29uc3Qgc2VlbkFic1NlY3RvcnMgPSBuZXcgU2V0KCk7ICBcclxuXHJcbiAgcmV0dXJuICh0cmFjaywgc2VjdG9yKSA9PiB7XHJcbiAgICBjb25zdCBhYnNTZWN0b3IgPSBjYWxjQWJzU2VjdG9yKHRyYWNrLCBzZWN0b3IpO1xyXG5cclxuICAgIGlmIChzZWVuQWJzU2VjdG9ycy5oYXMoYWJzU2VjdG9yKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGFpbiBvZiBkaXNrIHNlY3RvciBsaW5rcyBjb250YWlucyBhIGxvb3BcIik7XHJcbiAgICB9XHJcblxyXG4gICAgc2VlbkFic1NlY3RvcnMuYWRkKGFic1NlY3Rvcik7XHJcbiAgICByZXR1cm4gbG9hZEFic1NlY3RvcihkNjQsIGFic1NlY3Rvcik7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBsb2FkRGlyKGQ2NCkge1xyXG5cclxuICAvLyBEaXJlY3RvcnkgbGlzdGluZyBzdGFydHMgYXQgMTgvMSAoZXZlbiBpZiAxOC8wIHBvaW50cyBlbHNld2hlcmUpXHJcbiAgbGV0IHRyYWNrID0gMTg7XHJcbiAgbGV0IHNlY3RvciA9IDE7XHJcblxyXG4gIGxldCBlbnRyaWVzID0gW107XHJcbiAgY29uc3QgbG9hZFRyYWNrU2VjdG9yID0gZ2V0TG9hZFRyYWNrU2VjdG9yV2l0aFJlY3VyQ2hlY2soZDY0KTtcclxuXHJcbiAgd2hpbGUgKHRyYWNrKSB7XHJcblxyXG4gICAgY29uc3QgbmV3RW50cmllcyA9IHBhcnNlRGlyU2VjdG9yKFxyXG4gICAgICBsb2FkVHJhY2tTZWN0b3IodHJhY2ssIHNlY3RvcilcclxuICAgICk7XHJcblxyXG4gICAgZW50cmllcyA9IFtcclxuICAgICAgLi4uZW50cmllcyxcclxuICAgICAgLi4ubmV3RW50cmllcyxcclxuICAgIF07XHJcblxyXG4gICAgdHJhY2sgID0gbmV3RW50cmllc1swXS5uZXh0VHJhY2s7XHJcbiAgICBzZWN0b3IgPSBuZXdFbnRyaWVzWzBdLm5leHRTZWN0b3I7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZW50cmllc1xyXG4gICAgLm1hcChcclxuICAgICAgKGVudHJ5KSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCAuLi5yZXQgfSA9IGVudHJ5O1xyXG5cclxuICAgICAgICByZXQudHlwZSA9IFtcclxuICAgICAgICAgIFwiREVMXCIsXHJcbiAgICAgICAgICBcIlNFUVwiLFxyXG4gICAgICAgICAgXCJQUkdcIixcclxuICAgICAgICAgIFwiVVNSXCIsXHJcbiAgICAgICAgICBcIlJFTFwiLFxyXG4gICAgICAgIF1bZW50cnkudHlwZSAmIDBiMTExXTtcclxuXHJcbiAgICAgICAgcmV0LmxvY2tlZCA9IEJvb2xlYW4oZW50cnkudHlwZSAmICgxIDw8IDYpKTtcclxuICAgICAgICByZXQuY2xvc2VkID0gQm9vbGVhbihlbnRyeS50eXBlICYgKDEgPDwgNykpO1xyXG5cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICB9XHJcbiAgICApXHJcbiAgICAuZmlsdGVyKFxyXG4gICAgICAvLyBJIHRoaW5rIHRoaXMgaXMgcmlnaHQ/IERFTCdzIGRvbid0IHNob3cgdXAgaW4gdGhlIFwiJFwiP1xyXG4gICAgICAoeyB0eXBlIH0pID0+ICh0eXBlICE9PSBcIkRFTFwiKVxyXG4gICAgKVxyXG4gIDtcclxufVxyXG5cclxuZnVuY3Rpb24gbG9hZEZpbGUoZDY0LCB0cmFjaywgc2VjdG9yKSB7XHJcbiAgbGV0IHJldCA9IFtdO1xyXG4gIGNvbnN0IGxvYWRUcmFja1NlY3RvciA9IGdldExvYWRUcmFja1NlY3RvcldpdGhSZWN1ckNoZWNrKGQ2NCk7XHJcblxyXG4gIHdoaWxlICh0cmFjaykge1xyXG5cclxuICAgIGNvbnN0IHNlYyA9IHBhcnNlRmlsZVNlY3RvcihcclxuICAgICAgbG9hZFRyYWNrU2VjdG9yKHRyYWNrLCBzZWN0b3IpXHJcbiAgICApO1xyXG5cclxuICAgIGlmICghc2VjLm5leHRUcmFjaykge1xyXG4gICAgICAvLyBJZiB0aGUgbmV4dFRyYWNrIHZhbHVlIGlzIHplcm8sIHRoZW4gbmV4dFNlY3RvciByZXZlYWxzIGhvdyBtdWNoIG9mXHJcbiAgICAgIC8vIHRoaXMgc2VjdG9yIGNvbnRhaW5zIGZpbGUgZGF0YS4g4oCgMSBpbXBsaWVzIHRoYXQgaWYgbmV4dFNlY3RvciBoYXMgYVxyXG4gICAgICAvLyB2YWx1ZSBvZiA0LCB0aGVuLCBiZWFyaW5nIGluIG1pbmQgdGhhdCB0aGUgbmV4dCBsaW5rJ3MgdHJhY2svc2VjdG9yXHJcbiAgICAgIC8vIHZhbHVlcyBhcmUgaW4gYnl0ZXMgMCBhbmQgMSByZXNwZWN0aXZlbHksIHRoZSBmaWxlIGRhdGEgd291bGQgYmUgaW5cclxuICAgICAgLy8gYnl0ZXMgMiwgMywgYW5kIDQuXHJcbiAgICAgIC8vIFRodXMgYSAnNCcgd291bGQgbWVhbiBhIHNsaWNlIHBhcmFtZXRlciBvZiAnNScgd3J0LiB0aGUgcmF3IHNlY3RvcidzXHJcbiAgICAgIC8vIGRhdGEsIGhlbmNlIGEgc2xpY2UgcGFyYW1ldGVyIG9mICczJyB3cnQuIHRoZSBwYXJzZWQgYGJ5dGVzYCBhcnJheVxyXG4gICAgICAvLyBmcm9tIHRoYXQgc2VjdG9yLiBIZW5jZSwgaW4gZ2VuZXJhbCwgc2xpY2UgdW50aWwgYHNlY3RvcmAgbWludXMgb25lLlxyXG5cclxuICAgICAgcmV0ID0gWy4uLnJldCwgLi4uc2VjLmJ5dGVzLnNsaWNlKDAsIHNlYy5uZXh0U2VjdG9yIC0gMSldO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHJldCA9IFsuLi5yZXQsIC4uLnNlYy5ieXRlc107XHJcbiAgICB9XHJcblxyXG4gICAgdHJhY2sgID0gc2VjLm5leHRUcmFjaztcclxuICAgIHNlY3RvciA9IHNlYy5uZXh0U2VjdG9yO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJldDtcclxufVxyXG4iLCIvLyBUaGUgb25seSBmaWxlIHR5cGUgdGhhdCBjYW4gYmUgYnJvdWdodCBpbiBmcm9tIEpTT04gaXMgYSBzbmFwc2hvdC5cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbmdlc3RfanNvbihjNjQsIGJ5dGVzKSB7XHJcbiAgLy8gQ29udmVydCB0aGUgaW5jb21pbmcgYnl0ZSBhcnJheSB0byBhIHN0cmluZ1xyXG4gIGxldCBqc29uID0gXCJcIjtcclxuXHJcbiAgZm9yIChsZXQgaSBvZiBieXRlcykge1xyXG4gICAganNvbiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xyXG4gIH1cclxuXHJcbiAgLy8gT25jZSB0aGUgb3JpZ2luYWwgc25hcHNob3Qgd2FzIHNlcmlhbGl6ZWQsIGl0IHdhcyBzYXZlZCBvdXQgaW4gYSBKU09OXHJcbiAgLy8gZm9ybWF0LCBtZWFuaW5nIHlldCBhbm90aGVyIGxheWVyIG9mIHRoZSBvbmlvbi4gVW5wZWVsIHRoYXQgbGFzdCBvbmVcclxuICAvLyB0byBnZXQgdGhlIG9yaWdpbmFsIHNlcmlhbGlhemF0aW9uICh3aGljaCBpcyBpbiBKU09OLCBhbmQgZW5jb2RlcyB5ZXRcclxuICAvLyBtb3JlIEpTT04gaW4gaXRzIHN1YnNlY3Rpb25zKVxyXG4gIGNvbnN0IHNuYXBzaG90ID0gSlNPTi5wYXJzZShqc29uKTtcclxuXHJcbiAgYzY0LnJ1bmxvb3Auc3RvcCgpOyAgICAgICAgICAgICAgICAvLyBqdXN0IG91dCBvZiBjYXV0aW9uXHJcbiAgYzY0LnJ1bmxvb3AucmVzZXQoKTsgICAgICAgICAgICAgICAvLyBqdXN0IG91dCBvZiBjYXV0aW9uXHJcbiAgYzY0LnJ1bmxvb3AuZGVzZXJpYWxpemUoc25hcHNob3QpO1xyXG4gIGM2NC5ydW5sb29wLnJ1bigpO1xyXG59XHJcbiIsImltcG9ydCB7IGxvYWRQcmcgfSBmcm9tIFwiLi4vdG9vbHMvbG9hZFByZ1wiO1xyXG5pbXBvcnQgeyBBV0FJVF9LRVlCT0FSRF9QQyB9IGZyb20gXCIuLi90b29scy9yb21Mb2NhdGlvbnNcIjsgXHJcblxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluZ2VzdF9wcmcoYzY0LCBieXRlcykge1xyXG4gIGM2NC5ydW5sb29wLnJlc2V0KCk7XHJcbiAgYXdhaXQgYzY0LnJ1bmxvb3AudW50aWxQYyhBV0FJVF9LRVlCT0FSRF9QQyk7XHJcblxyXG4gIGxvYWRQcmcoYzY0LCBieXRlcyk7XHJcblxyXG4gIGM2NC5ydW5sb29wLnR5cGUoXCJSVU5cXHJcIik7XHJcbiAgYzY0LnJ1bmxvb3AucnVuKCk7XHJcbn1cclxuIiwiaW1wb3J0IHsgbWFrZVBhcnNlciB9ICAgICAgICAgICAgIGZyb20gXCIuLi90b29scy9wYXJzZXJcIjtcclxuaW1wb3J0IHsgYXNzZW1ibGUgfSAgICAgICAgICAgICAgIGZyb20gXCIuLi90b29scy9hc3NlbWJsZXIuanNcIjtcclxuaW1wb3J0IHsgY2hhclRvQzY0Rm9udENvZGVQb2ludCB9IGZyb20gXCIuLi90b29scy9jNjRGb250Q29kZVBvaW50c1wiO1xyXG5pbXBvcnQgeyBSRUFEWV9QQyB9ICAgICAgICAgICAgICAgZnJvbSBcIi4uL3Rvb2xzL3JvbUxvY2F0aW9uc1wiOyBcclxuaW1wb3J0IHsgJHh4eHggfSAgICAgICAgICAgICAgICAgIGZyb20gXCIuLi9kZWJ1Z1wiO1xyXG5cclxuXHJcbi8vIEZvcm1hdCByZWZlcmVuY2VzOlxyXG4vLyAtIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2NibWVla3MvMmIxMDdmMGE4ZDM2ZmM0NjFlYmIwNTZlOTRiMmY0ZDZcclxuLy8gLSBodHRwOi8vdW51c2VkaW5vLmRlL2VjNjQvdGVjaG5pY2FsL2Zvcm1hdHMvc2lkcGxheS5odG1sXHJcbi8vXHJcbi8vIChCZXdhcmU6IG5laXRoZXIgc2lnbmFsIHZlcnkgd2VsbCB3aGV0aGVyIHRoZSBudW1iZXJzIHRoZXkgcXVvdGUgYXJlXHJcbi8vIGRlY2ltYWwgb3IgaGV4LilcclxuXHJcbmNvbnN0IHBhcnNlSGVhZGVyID0gbWFrZVBhcnNlcigoXykgPT4gKHtcclxuICBtYWdpY0lEOiAgICAgXy5zdHJpbmcoNCksXHJcbiAgdmVyc2lvbjogICAgIF8ud29yZF9iZSgpLFxyXG4gIGRhdGFPZmZzZXQ6ICBfLndvcmRfYmUoKSxcclxuICBsb2FkQWRkcmVzczogXy53b3JkX2JlKCksXHJcbiAgaW5pdEFkZHJlc3M6IF8ud29yZF9iZSgpLFxyXG4gIHBsYXlBZGRyZXNzOiBfLndvcmRfYmUoKSxcclxuICBzb25nczogICAgICAgXy53b3JkX2JlKCksXHJcbiAgc3RhcnRTb25nOiAgIF8ud29yZF9iZSgpLFxyXG4gIHNwZWVkOiAgICAgICBfLmxvbmdfYmUoKSxcclxuICBuYW1lOiAgICAgICAgXy5zdHJpbmcoMzIpLFxyXG4gIGF1dGhvcjogICAgICBfLnN0cmluZygzMiksXHJcbiAgcmVsZWFzZWQ6ICAgIF8uc3RyaW5nKDMyKSxcclxufSkpO1xyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluZ2VzdF9zaWQoYzY0LCBieXRlcykge1xyXG4gIGxldCBoZWFkZXI7XHJcbiAgXHJcbiAgdHJ5IHtcclxuICAgIGhlYWRlciA9IHBhcnNlSGVhZGVyKGJ5dGVzKTtcclxuICB9XHJcbiAgY2F0Y2ggKGUpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJVbmV4cGVjdGVkIGVhcmx5IGVuZCBvZiBmaWxlXCIpO1xyXG4gIH1cclxuXHJcbiAgdmFsaWRhdGUoaGVhZGVyKTtcclxuXHJcbiAgbGV0IHsgbG9hZEFkZHJlc3MsIGRhdGFPZmZzZXQgfSA9IGhlYWRlcjtcclxuXHJcbiAgaWYgKGxvYWRBZGRyZXNzID09PSAwKSB7XHJcbiAgICAvLyBtZWFucyB0aGUgbG9hZCBhZGRyZXNzIGlzIGF0IHRoZSBzdGFydCBvZiB0aGUgZGF0YSBzZWNpb24sIGxpa2UgYVxyXG4gICAgLy8gLnByZyBmaWxlXHJcbiAgICBsb2FkQWRkcmVzcyA9IChcclxuICAgICAgYnl0ZXNbZGF0YU9mZnNldCsrXSB8IFxyXG4gICAgICBieXRlc1tkYXRhT2Zmc2V0KytdIDw8IDhcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBmaWxlRGF0YSA9IGJ5dGVzLnNsaWNlKGRhdGFPZmZzZXQpO1xyXG5cclxuICAvLyBJdCdzIG9ubHkgMTMwIGJ5dGVzIG9yIHNvLiBTZWVtcyBhIHNhZmUgcGxhY2UgdG8gc3Rhc2ggaXQsIG5vP1xyXG4gIC8vIEp1c3QgbmVlZCB0byBjYXJlZnVsIHRoYXQgaXQgZG9lc24ndCBydW4gaW50byB0aGUgUEFML05UU0MgZmxhZyBhdCAkMDJhNlxyXG4gIC8vIGFzIFNJRHMgY2FuIHJlbHkgb24gdGhhdC5cclxuICBjb25zdCBwbGF5ZXJPcmcgPSAweDAyMDA7XHJcbiAgLy8gKFBvc3RzY3JpcHQ6IG1vc3Qgb2YgUmljaGFyZCBKb2VzcGgncyBzb25ncyB3b24ndCBwbGF5IGF0IGFsbCB3aXRoIHRoZVxyXG4gIC8vIHBsYXllciBvcmcnZWQgdGhlcmUuIE9yZyBpdCBzb21ld2hlcmUgZWxzZSBhbmQgdGhleSdsbCBwbGF5IGEgbGl0dGUgYmV0dGVyXHJcbiAgLy8gYnV0IHN0aWxsIG5vdCByaWdodC4gSGF2ZW4ndCBsb29rZWQgaW50byB3aHkuKVxyXG5cclxuICAvLyBQU0lEIGZpbGUgaXMgMS1pbmRleGVkLCBjb2RlIGV4cGVjdHMgMC1pbmRleGVkXHJcbiAgbGV0IHN0YXJ0U29uZyA9IChoZWFkZXIuc3RhcnRTb25nIC0gMSkgJiAweGZmO1xyXG5cclxuICBwbGF5U29uZyhcclxuICAgIGM2NCxcclxuICAgIGZpbGVEYXRhLFxyXG4gICAgcGxheWVyT3JnLFxyXG4gICAgbG9hZEFkZHJlc3MsXHJcbiAgICBoZWFkZXJcclxuICApO1xyXG59XHJcblxyXG5mdW5jdGlvbiB2YWxpZGF0ZShoZWFkZXIpIHtcclxuICBpZiAoaGVhZGVyLm1hZ2ljSUQgIT09IFwiUFNJRFwiKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IFBTSUQgLnNpZCBmaWxlcyBjYW4gYmUgcGxheWVkLlwiKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNob3dIZWFkZXIoYzY0LCBoZWFkZXIsIGxvYWRBZGRyZXNzLCBwbGF5ZXJBZGRyZXNzLCBwbGF5ZXJMZW5ndGgsIGxvYWRMZW5ndGgpIHtcclxuXHJcbiAgY29uc3Qgc3RyaW5nVG9TY3JlZW4gPSAocm93LCBjb2wsIHN0cmluZykgPT4ge1xyXG4gICAgc3RyaW5nID0gc3RyaW5nLnRvTG93ZXJDYXNlKCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjNjQud2lyZXMuY3B1V3JpdGUoXHJcbiAgICAgICAgMHg0MDAgKyBjb2wgKyAoNDAgKiByb3cpICsgaSwgXHJcbiAgICAgICAgY2hhclRvQzY0Rm9udENvZGVQb2ludChzdHJpbmdbaV0sIHRydWUpXHJcbiAgICAgICk7XHJcbiAgICAgIGM2NC53aXJlcy5jcHVXcml0ZShcclxuICAgICAgICAweGQ4MDAgKyBjb2wgKyAoNDAgKiByb3cpICsgaSwgXHJcbiAgICAgICAgMTVcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBzdHJpbmdUb1NjcmVlbiggNiwgNCwgaGVhZGVyLm5hbWUpO1xyXG4gIHN0cmluZ1RvU2NyZWVuKCA3LCA0LCBoZWFkZXIuYXV0aG9yKTtcclxuICBzdHJpbmdUb1NjcmVlbiggOCwgNCwgaGVhZGVyLnJlbGVhc2VkKTtcclxuICBzdHJpbmdUb1NjcmVlbigxMCwgNCwgYGxvYWQ6ICR7JHh4eHgobG9hZEFkZHJlc3MpfS0keyR4eHh4KGxvYWRBZGRyZXNzICsgbG9hZExlbmd0aCl9YCk7XHJcbiAgc3RyaW5nVG9TY3JlZW4oMTEsIDQsIGBpbml0OiAkeyR4eHh4KGhlYWRlci5pbml0QWRkcmVzcyl9YCk7XHJcbiAgc3RyaW5nVG9TY3JlZW4oMTIsIDQsIGBwbGF5OiAkeyR4eHh4KGhlYWRlci5wbGF5QWRkcmVzcyl9YCk7XHJcbiAgc3RyaW5nVG9TY3JlZW4oMTQsIDQsIGAjIHNvbmdzOiAke2hlYWRlci5zb25nc30gKHN0YXJ0ICR7aGVhZGVyLnN0YXJ0U29uZ30pYCk7XHJcbiAgc3RyaW5nVG9TY3JlZW4oMTYsIDQsIGBwbGF5ZXIgYXQgJHskeHh4eChwbGF5ZXJBZGRyZXNzKX0tJHskeHh4eChwbGF5ZXJBZGRyZXNzICsgcGxheWVyTGVuZ3RoKX1gKTtcclxuICBzdHJpbmdUb1NjcmVlbigyMCwgMiwgYGpveXN0aWNrICMyIGxlZnQvcmlnaHQgZm9yIHByZXYvbmV4dGApO1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBwbGF5U29uZyhcclxuICBjNjQsXHJcbiAgZmlsZURhdGEsXHJcbiAgcGxheWVyT3JnLFxyXG4gIGZpbGVPcmcsXHJcbiAgaGVhZGVyXHJcbikge1xyXG5cclxuICBjNjQucnVubG9vcC5yZXNldCgpO1xyXG4gIGF3YWl0IGM2NC5ydW5sb29wLnVudGlsUGMoUkVBRFlfUEMpO1xyXG5cclxuICBjb25zdCB7IGluaXRBZGRyZXNzLCBwbGF5QWRkcmVzcywgc29uZ3MsIHN0YXJ0U29uZyB9ID0gaGVhZGVyO1xyXG5cclxuICAvLyBSaWdodCBub3cgdGhlIHBsYXllciBqdXN0IHVzZXMgcmFzdGVyIHRpbWUgdG8gY3VlIHRoZSBQU0lEJ3MgdGljayByb3V0aW5lXHJcbiAgLy8gc28gd2UncmUgc3R1Y2sgd2l0aCA1MEh6IHBsYXliYWNrLCB3aGljaCBhIGxvdCBvZiBQU0lEJ3MgYXJlbid0IHVzaW5nLlxyXG4gIC8vIFdlIHNob3VsZCB1c2UgYSBDSUEgdG8gZml4IHRoYXQuXHJcblxyXG4gIGNvbnN0IHBsYXllckRhdGEgPSBhc3NlbWJsZShcclxuICAgIHBsYXllck9yZyxcclxuICAgICh7XHJcbiAgICAgIE5PUCwgTERBLCBMRFgsIExEWSwgU1RBLCBTVFgsIFNUWSwgQ0xDLCBDTEQsIENMSSwgQ0xWLCBTRUMsIFNFRCwgU0VJLCBcclxuICAgICAgVEFYLCBUQVksIFRTWCwgVFhBLCBUWFMsIFRZQSwgQ01QLCBDUFgsIENQWSwgQkNTLCBCQ0MsIEJFUSwgQk5FLCBCTUksXHJcbiAgICAgIEJQTCwgQlZTLCBCVkMsIEJJVCwgSlNSLCBSVFMsIFJUSSwgQlJLLCBKTVAsIElOQywgREVDLCBERVgsIERFWSwgSU5YLFxyXG4gICAgICBJTlksIEFEQywgU0JDLCBBTkQsIEVPUiwgT1JBLCBBU0wsIFJPTCwgTFNSLCBST1IsIFBIQSwgUEhQLCBQTEEsIFBMUCxcclxuICAgICAgX1xyXG4gICAgfSkgPT4ge1xyXG5cclxuICAgICAgICAvLyBXZSd2ZSBjb21lIGluIGZyb20gQmFzaWMsIHNvIHN0b3AgZXZlcnl0aGluZ1xyXG4gICAgICAgIExEQS5pbW0gKDApOyBcclxuICAgICAgICBTVEEuYWJzICgweGRjMGUpOyAgICAgICAgICAgLy8gc3RvcCBDSUExIHRpbWVyIEFcclxuICAgICAgICBTVEEuYWJzICgweGRjMGYpOyAgICAgICAgICAgLy8gc3RvcCBDSUExIHRpbWVyIEJcclxuICAgICAgICBTVEEuYWJzICgweGRkMGUpOyAgICAgICAgICAgLy8gc3RvcCBDSUEyIHRpbWVyIEFcclxuICAgICAgICBTVEEuYWJzICgweGRkMGYpOyAgICAgICAgICAgLy8gc3RvcCBDSUEyIHRpbWVyIEJcclxuXHJcbiAgICAgICAgTERBLnpwZyAoMSk7ICAgICAgICAgICAgICAgIC8vIHJlYWQgcHJvY2Vzc29yIHBvcnRcclxuICAgICAgICBBTkQuaW1tICgweGY4KTsgICAgICAgICAgICAgLy8gY2xlYXIgYm90dG9tIDMgYml0c1xyXG4gICAgICAgIE9SQS5pbW0gKDB4MDUpOyAgICAgICAgICAgICAvLyAwYjEwMSA9IEkvTyBtYXBwZWQsIG90aGVyd2lzZSBtYXggUkFNXHJcbiAgICAgICAgU1RBLnpwZyAoMSk7ICAgICAgICAgICAgICAgIC8vIHN0b3JlIHByb2Nlc3NvciBwb3J0XHJcblxyXG4gICAgICAgIExEQS5pbW0gKHN0YXJ0U29uZyAtIDEpOyAgICAvLyBoZWFkZXIncyBzdGFydFNvbmcgaXMgMS1pbmRleGVkXHJcbiAgICAgICAgSk1QLmFicyAoXCJzdGFydFNvbmdcIik7ICAgICAgLy8gcGxheSBpdCBhbmQgZW50ZXIgbG9vcFxyXG5cclxuICAgICAgX2BtYWluYDtcclxuICAgICAgICBMREEuYWJzICgweGQwMTIpOyAgICAgICAgICAgLy8gcmVhZCByYXN0ZXIgbGluZSAoYml0cyAwLTcpXHJcbiAgICAgICAgQ01QLmltbSAoMHg0MCk7ICAgICAgICAgICAgIC8vIHRoZXJlJ3Mgbm8gbGluZSAweDE0MCwgc28gaWYgYml0cyAwLTdcclxuICAgICAgICBCTkUucmVsIChcIm1haW5cIik7ICAgICAgICAgICAvLyBzYXkgMHg0MCwgd2UncmUgYXQgMHgwNDAuIExvb3AgdW50aWwgdGhlbi5cclxuXHJcbiAgICAgICAgTERBLmltbSAoMTUpO1xyXG4gICAgICAgIFNUQS5hYnMgKDB4ZDAyMCk7ICAgICAgICAgICAvLyBsaWdodCBib3JkZXIgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgcGxheSByb3V0aW5nXHJcbiAgICAgICAgSlNSLmFicyAocGxheUFkZHJlc3MpOyAgICAgIC8vIGNhbGwgcGxheWVyJ3MgdGljayByb3V0aW5lXHJcbiAgICAgICAgTERBLmltbSAoMTQpO1xyXG4gICAgICAgIFNUQS5hYnMgKDB4ZDAyMCk7ICAgICAgICAgICAvLyBicmluZyB0aGUgYm9yZGVyIGJhY2tcclxuXHJcbiAgICAgICAgTERYLmFicyAoMHhkYzAwKTsgICAgICAgICAgIC8vIHJlYWQgam95c3RpY2sgcG9ydCAyXHJcbiAgICAgICAgVFhBLmltcCAoKTtcclxuICAgICAgICBBTkQuaW1tICgwYjEwMDApOyAgICAgICAgICAgLy8gcmlnaHQ/XHJcbiAgICAgICAgQkVRLnJlbCAoXCJuZXh0U29uZ1wiKTtcclxuICAgICAgICBUWEEuaW1wICgpO1xyXG4gICAgICAgIEFORC5pbW0gKDBiMTAwKTsgICAgICAgICAgICAvLyBsZWZ0P1xyXG4gICAgICAgIEJFUS5yZWwgKFwicHJldlNvbmdcIik7XHJcblxyXG4gICAgICBfYHRhaWxgO1xyXG4gICAgICAgIExEQS5hYnMgKDB4ZDAxMik7ICAgICAgICAgICAvLyBubyBjaGFuZ2VzIHRvIHRoZSBzb25nLiBqdXN0IGJlIHN1cmUgd2UncmVcclxuICAgICAgICBDTVAuaW1tICgweDQwKTsgICAgICAgICAgICAgLy8gbm90IHN0aWxsIG9uIHRoYXQgc2FtZSAweDA0MCBzY2FubGluZS4uLlxyXG4gICAgICAgIEJFUS5yZWwgKFwidGFpbFwiKTtcclxuICAgICAgICBCTkUucmVsIChcIm1haW5cIik7ICAgICAgICAgICAvLyB3ZSdyZSBub3QuIFNvIG5vdyBsb29wIHVudGlsIHdlIGFyZS5cclxuXHJcbiAgICAgIF9gcHJldlNvbmdgO1xyXG4gICAgICAgIERFQy5hYnMgKFwic29uZ1wiKTtcclxuICAgICAgICBERUMuYWJzIChcInNvbmdcIik7ICAgICAgICAgICAvLyBiZWNhdXNlIGl0IGZhbGxzIHRocm91Z2guLi5cclxuXHJcbiAgICAgIF9gbmV4dFNvbmdgO1xyXG4gICAgICAgIElOQy5hYnMgKFwic29uZ1wiKTtcclxuXHJcbiAgICAgIF9gdW50aWxSZWxlYXNlZGA7XHJcbiAgICAgICAgTERBLmFicyAoMHhkYzAwKTsgICAgICAgICAgIC8vIHdhaXQgdW50aWwgdGhlIGpveXN0aWNrJ3MgbGV0IGdvIG9mXHJcbiAgICAgICAgQ01QLmltbSAoMHg3Zik7ICAgICAgICAgICAgIC8vIHRvIHByZXZlbnQgYSBkb3VibGUtYWR2YW5jZVxyXG4gICAgICAgIEJORS5yZWwgKFwidW50aWxSZWxlYXNlZFwiKTtcclxuXHJcbiAgICAgICAgTERBLmFicyAoXCJzb25nXCIpOyAgICAgICAgICAgLy8gbm93IGxldCdzIGNsYW1wIHRoZSBzb25nIG51bWJlclxyXG4gICAgICAgIEJQTC5yZWwgKFwiY2xhbXBcIik7ICAgICAgICAgIC8vIGlmIHBvc2l0aXZlLCBnbyBjaGVjayBpdCdzIG5vdCB0b28gaGlnaFxyXG4gICAgICAgIExEQS5pbW0gKDApOyAgICAgICAgICAgICAgICAvLyB3YXMgbmVnYXRpdmUgc28gY2xhbXAgdG8gemVyb1xyXG4gICAgICAgIEJFUS5yZWwgKFwic3RhcnRTb25nXCIpOyAgICAgIC8vIHBsYXlcclxuXHJcbiAgICAgIF9gY2xhbXBgO1xyXG4gICAgICAgIENNUC5pbW0gKHNvbmdzKTsgICAgICAgICAgICAvLyBhbHJlYWR5IGF0IHRoZSBsYXN0IHNvbmc/XHJcbiAgICAgICAgQk5FLnJlbCAoXCJzdGFydFNvbmdcIik7ICAgICAgLy8gbm8/IGtpY2sgaXRcclxuICAgICAgICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgLy8gKHNlcmlvdXNseSwgd2h5IGlzIHRoZXJlIG5vIERFQy5hY2M/KVxyXG4gICAgICAgIEFEQy5pbW0gKDB4ZmYpOyAgICAgICAgICAgICAvLyBkZWNyZW1lbnQgYmFjayB0byB0aGUgbGFzdFxyXG5cclxuICAgICAgX2BzdGFydFNvbmdgO1xyXG4gICAgICAgIFNUQS5hYnMgKFwic29uZ1wiKTsgICAgICAgICAgIC8vIHN0b3JlIHBvc3QtaW5jL2RlYyBzb25nIG51bVxyXG5cclxuICAgICAgICBMRFguaW1tICgwYjEwMDApOyAgICAgICAgIFxyXG4gICAgICAgIFNUWC5hYnMgKDB4ZDQwNCk7ICAgICAgICAgICAvLyBzdG9wIHZvaWNlIDFcclxuICAgICAgICBTVFguYWJzICgweGQ0MGIpOyAgICAgICAgICAgLy8gc3RvcCB2b2ljZSAyXHJcbiAgICAgICAgU1RYLmFicyAoMHhkNDEyKTsgICAgICAgICAgIC8vIHN0b3Agdm9pY2UgM1xyXG5cclxuICAgICAgICBMRFguaW1tICgwKTtcclxuICAgICAgICBTVFguYWJzICgweGQ0MTcpOyAgICAgICAgICAgLy8gcmVzZXQgZmlsdGVyc1xyXG4gICAgICAgIFNUWC5hYnMgKDB4ZDQxOCk7ICAgICAgICAgICAvLyB2b2x1bWUgMCwgcmVzZXQgbW9yZSBmaWx0ZXJzXHJcblxyXG4gICAgICAgIEpTUi5hYnMgKGluaXRBZGRyZXNzKTsgICAgICAvLyBjYWxsIHBsYXllcidzIGluaXQgcm91dGluZSBmb3Igc29uZyBpbiBhY2NcclxuICAgICAgICBKTVAuYWJzIChcIm1haW5cIik7ICAgICAgICAgICAvLyByZS1ydW4gbWFpbiBsb29wXHJcblxyXG4gICAgICBfYHNvbmdgO1xyXG4gICAgICAgIF8uYnl0ZXMoMCk7ICAgICAgICAgICAgICAgICAvLyBjdXJyZW50IHNvbmcgKGluaXQnZWQgYnkgc3RhcnRTb25nKVxyXG4gICAgfVxyXG4gICk7XHJcblxyXG4gIHNob3dIZWFkZXIoYzY0LCBoZWFkZXIsIGZpbGVPcmcsIHBsYXllck9yZywgcGxheWVyRGF0YS5sZW5ndGgsIGZpbGVEYXRhLmxlbmd0aCk7XHJcblxyXG4gIGNvbnN0IHsgY3B1V3JpdGUgfSA9IGM2NC53aXJlcztcclxuXHJcbiAgZmlsZURhdGEuZm9yRWFjaChcclxuICAgIChieXRlLCBpbmRleCkgPT4gY3B1V3JpdGUoZmlsZU9yZyArIGluZGV4LCBieXRlKVxyXG4gICk7XHJcblxyXG4gIHBsYXllckRhdGEuZm9yRWFjaChcclxuICAgIChieXRlLCBpbmRleCkgPT4gY3B1V3JpdGUocGxheWVyT3JnICsgaW5kZXgsIGJ5dGUpXHJcbiAgKTtcclxuXHJcbiAgYzY0LmNwdS5nZXRTdGF0ZSgpLnBjID0gcGxheWVyT3JnO1xyXG4gIGM2NC5ydW5sb29wLnJ1bigpO1xyXG59XHJcbiIsImltcG9ydCB7IG1ha2VQYXJzZXIgfSAgICAgICAgZnJvbSBcIi4uL3Rvb2xzL3BhcnNlclwiO1xyXG5pbXBvcnQgeyBsb2FkUHJnIH0gICAgICAgICAgIGZyb20gXCIuLi90b29scy9sb2FkUHJnXCI7XHJcbmltcG9ydCB7IEFXQUlUX0tFWUJPQVJEX1BDIH0gZnJvbSBcIi4uL3Rvb2xzL3JvbUxvY2F0aW9uc1wiOyBcclxuXHJcblxyXG4vLyBGb3JtYXQgcmVmZXJlbmNlczpcclxuLy8gICAgaHR0cDovL3VudXNlZGluby5kZS9lYzY0L3RlY2huaWNhbC9mb3JtYXRzL3Q2NC5odG1sXHJcbi8vICAgIGh0dHBzOi8vdmljZS1lbXUuc291cmNlZm9yZ2UuaW8vdmljZV8xNi5odG1sXHJcblxyXG5jb25zdCBwYXJzZUhlYWRlciA9IG1ha2VQYXJzZXIoKF8pID0+ICh7XHJcbiAgZGVzYzogICAgICAgIF8uc3RyaW5nKDMyKSxcclxuICB2ZXJzaW9uOiAgICAgXy53b3JkX2xlKCksXHJcbiAgZW50cmllczogICAgIF8ud29yZF9sZSgpLFxyXG4gIHVzZWRFbnRyaWVzOiBfLndvcmRfbGUoKSxcclxuICBfOiAgICAgICAgICAgXy5za2lwKDIpLFxyXG4gIHVzZXJEZXNjOiAgICBfLnN0cmluZygyNCksXHJcblxyXG4gIC8vIFRoZSBiZWxvdyBzaG91bGQgaGF2ZSBpdHMgb3duIHNlcGFyYXRlIHN0cnVjdHVyZSwgYXMgdGhlb3JldGljYWxseVxyXG4gIC8vIHRoZXJlJ3MgYSBzZXF1ZW5jZSBvZiBtdWx0aXBsZSBpbnN0YW5jZXMgb2YgaXRcclxuICBlbnRyeVR5cGU6ICAgXy5ieXRlKCksXHJcbiAgZmlsZVR5cGU6ICAgIF8uYnl0ZSgpLFxyXG4gIHN0YXJ0QWRkcjogICBfLndvcmRfbGUoKSxcclxuICBlbmRBZGRyOiAgICAgXy53b3JkX2xlKCksXHJcbiAgXzogICAgICAgICAgIF8uc2tpcCgyKSxcclxuICBzdGFydDogICAgICAgXy5sb25nX2xlKCksXHJcbiAgXzogICAgICAgICAgIF8uc2tpcCg0KSxcclxuICBmaWxlbmFtZTogICAgXy5zdHJpbmcoMTYpLFxyXG59KSk7XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5nZXN0X3Q2NChjNjQsIGJ5dGVzKSB7XHJcbiAgbGV0IGhlYWRlcjtcclxuICBcclxuICB0cnkge1xyXG4gICAgaGVhZGVyID0gcGFyc2VIZWFkZXIoYnl0ZXMpO1xyXG4gIH1cclxuICBjYXRjaCAoZSkge1xyXG4gICAgY29uc29sZS5lcnJvcihcIlVuZXhwZWN0IGVhcmx5IGVuZCB0byBmaWxlXCIpO1xyXG4gIH1cclxuXHJcbiAgdmFsaWRhdGUoaGVhZGVyKTtcclxuXHJcbiAgY29uc3QgcHJnID0gW1xyXG4gICAgaGVhZGVyLnN0YXJ0QWRkciAmIDB4ZmYsXHJcbiAgICBoZWFkZXIuc3RhcnRBZGRyID4+IDgsXHJcbiAgICAuLi5ieXRlcy5zbGljZShoZWFkZXIuc3RhcnQpXHJcbiAgXTtcclxuXHJcbiAgYzY0LnJ1bmxvb3AucmVzZXQoKTtcclxuICBhd2FpdCBjNjQucnVubG9vcC51bnRpbFBjKEFXQUlUX0tFWUJPQVJEX1BDKTtcclxuXHJcbiAgbG9hZFByZyhjNjQsIHByZyk7XHJcblxyXG4gIGM2NC5ydW5sb29wLnR5cGUoXCJSVU5cXHJcIik7XHJcbiAgYzY0LnJ1bmxvb3AucnVuKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHZhbGlkYXRlKGhlYWRlcikge1xyXG4gIC8vIEdlbmVyYWwgcG9saWN5IGlzIHRoYXQgd2UnbGwgd2FpdmUgYXMgbXVjaCBhcyB3ZSBwb3NzaWJseSBjYW4gd2l0aFxyXG4gIC8vIHdhcm5pbmdzLCBhbmQgb25seSBlcnJvciBpZiB3ZSBhYnNvbHV0ZWx5IGNhbid0IGxvYWQgdGhlIGZpbGVcclxuXHJcbiAgY29uc3Qgd2FybiA9IGNvbnNvbGUud2FybjtcclxuXHJcbiAgaWYgKGhlYWRlci51c2VkRW50cmllcyAhPT0gMSkge1xyXG4gICAgLy8gSSd2ZSBzZWVuIGFuIG90aGVyd2lzZSB3b3JraW5nIC50NjQgcmVwb3J0IHplcm8gdXNlZCBlbnRyaWVzLCBzbyB3YWl2ZVxyXG4gICAgLy8gd2hhdCB5b3UnZCB0aGluayB3b3VsZCBiZSBhIGJyZWFraW5nIGNhc2UuXHJcbiAgICB3YXJuKGAudDY0IGZpbGUgaGFzICR7aGVhZGVyLnVzZWRFbnRyaWVzfSB1c2VkIGVudHJpZXMuIE9uZSB3YXMgZXhwZWN0ZWQuYCk7XHJcbiAgfVxyXG5cclxuICBpZiAoaGVhZGVyLnN0YXJ0QWRkciAhPT0gMHgwODAxKSB7XHJcbiAgICB3YXJuKFwiLnQ2NCBmaWxlIHN0YXJ0IGFkZHJlc3MgaXNuJ3QgJDA4MDFcIik7XHJcbiAgfVxyXG5cclxuICAvLyBXZSBpZ25vcmUgdGhlIGVuZCBhZGRyXHJcblxyXG4gIGlmIChoZWFkZXIuZW50cnlUeXBlICE9PSAxKSB7XHJcbiAgICB3YXJuKGAudDY0IGVycm9yOiBvbmx5IGVudHJ5IHR5cGUgMSBzdXBwb3J0ZWQgKGdvdCAke2hlYWRlci5lbnRyeVR5cGV9KWApO1xyXG4gIH1cclxuXHJcbiAgLy8gU2hvdWxkIHRyeSB3YXJuIGlmIHRoZSBmaWxlIHNpemUgZG9lc24ndCBtYXRjaCB3aGF0IHdlJ2QgZXhwZWN0IGZyb20gdGhlXHJcbiAgLy8gaGVhZGVyLCB0aG91Z2ggdGhpcyBoYXBwZW5zIGNvbW1vbmx5IGZvciBmaWxlcyB0aGF0IG90aGVyd2lzZSB3b3JrLlxyXG59XHJcbiIsImltcG9ydCB7IG1ha2VQYXJzZXIgfSBmcm9tIFwiLi4vdG9vbHMvcGFyc2VyXCI7XHJcbmltcG9ydCB7IEFXQUlUX0tFWUJPQVJEX1BDIH0gZnJvbSBcIi4uL3Rvb2xzL3JvbUxvY2F0aW9uc1wiOyBcclxuXHJcblxyXG4vLyBGb3JtYXQgcmVmZXJlbmNlczpcclxuLy8gICAgaHR0cDovL3dhdi1wcmcuc291cmNlZm9yZ2UubmV0L3RhcGUuaHRtbFxyXG4vLyAgICBodHRwOi8vdW51c2VkaW5vLmRlL2VjNjQvdGVjaG5pY2FsL2Zvcm1hdHMvdGFwLmh0bWxcclxuXHJcbmNvbnN0IHBhcnNlVGFwID0gbWFrZVBhcnNlcigoXykgPT4gKHtcclxuICBoZWFkZXI6ICAgXy5zdHJpbmcoMjApLFxyXG4gIGNvbnRlbnRzOiBfLnJlbWFpbmRlcigpLFxyXG59KSk7XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5nZXN0X3RhcChjNjQsIGJ5dGVzKSB7XHJcblxyXG4gIGNvbnN0IHN0cnVjdCA9IHBhcnNlVGFwKGJ5dGVzKTtcclxuXHJcbiAgdmFsaWRhdGUoc3RydWN0KTtcclxuXHJcbiAgYzY0LnJ1bmxvb3AucmVzZXQoKTtcclxuICBhd2FpdCBjNjQucnVubG9vcC51bnRpbFBjKEFXQUlUX0tFWUJPQVJEX1BDKTtcclxuXHJcbiAgYzY0LnRhcGUuc2V0SW1hZ2UoYnl0ZXMuc2xpY2UoMjApKTtcclxuXHJcbiAgYzY0LnJ1bmxvb3AudHlwZShcIkxPQURcXHJcIik7XHJcbiAgYzY0LnJ1bmxvb3AucnVuKCk7XHJcbiAgYzY0LnRhcGUucHJlc3NQbGF5KCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHZhbGlkYXRlKHN0cnVjdCkge1xyXG4gIC8vIEluIG15IGV4cGVyaWVuY2UsIGhlYWRlcnMgYXJlIGFsd2F5c1xyXG4gIC8vICAgIFwiQzY0LVRBUEUtUkFXXCJcclxuICAvLyBvciBcIkM2NC1UQVBFLVJBV1xcdTAwMDFcIlxyXG5cclxuICBpZiAoc3RydWN0LmhlYWRlci5pbmRleE9mKFwiQzY0LVRBUEUtUkFXXCIpICE9PSAwKSB7XHJcbiAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgIFwiRXhwZWN0ZWQgdG8gZmluZCAnQzY0LVRBUEUtUkFXJyBpbiBoZWFkZXIsIGJ1dCBnb3Q6XCIsXHJcbiAgICAgIHN0cnVjdC5oZWFkZXJcclxuICAgICk7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IGluZ2VzdF9wcmcgfSAgZnJvbSBcIi4vaW5nZXN0LXByZ1wiO1xyXG5pbXBvcnQgeyBpbmdlc3RfdDY0IH0gIGZyb20gXCIuL2luZ2VzdC10NjRcIjtcclxuaW1wb3J0IHsgaW5nZXN0X2Q2NCB9ICBmcm9tIFwiLi9pbmdlc3QtZDY0XCI7XHJcbmltcG9ydCB7IGluZ2VzdF9zaWQgfSAgZnJvbSBcIi4vaW5nZXN0LXNpZFwiO1xyXG5pbXBvcnQgeyBpbmdlc3RfdGFwIH0gIGZyb20gXCIuL2luZ2VzdC10YXBcIjtcclxuaW1wb3J0IHsgaW5nZXN0X2pzb24gfSBmcm9tIFwiLi9pbmdlc3QtanNvblwiO1xyXG5cclxuY29uc3QgaW5nZXN0b3JzID0gW1xyXG4gIFsvXFwucHJnJC9pICwgaW5nZXN0X3ByZyAgXSxcclxuICBbL1xcLnQ2NCQvaSAsIGluZ2VzdF90NjQgIF0sXHJcbiAgWy9cXC5kNjQkL2kgLCBpbmdlc3RfZDY0ICBdLFxyXG4gIFsvXFwuc2lkJC9pICwgaW5nZXN0X3NpZCAgXSxcclxuICBbL1xcLnRhcCQvaSAsIGluZ2VzdF90YXAgIF0sXHJcbiAgWy9cXC5qc29uJC9pLCBpbmdlc3RfanNvbiBdLFxyXG5dO1xyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluZ2VzdChjNjQsIGZpbGVuYW1lLCBieXRlcykge1xyXG4gIHRyeSB7XHJcblxyXG4gICAgZm9yIChsZXQgW3JlZ2V4LCBmbl0gb2YgaW5nZXN0b3JzKSB7XHJcbiAgICAgIGlmIChyZWdleC50ZXN0KGZpbGVuYW1lKSkge1xyXG4gICAgICAgIGF3YWl0IGZuKGM2NCwgYnl0ZXMpO1xyXG5cclxuICAgICAgICBpZiAoYzY0Lmhvb2tzLnNldFRpdGxlKSB7XHJcbiAgICAgICAgICBjNjQuaG9va3Muc2V0VGl0bGUoZmlsZW5hbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fu4oCZdCBndWVzcyBmaWxlIGZvcm1hdCBmcm9tIG5hbWUsIG9yIGZvcm1hdCBpcyB1bnN1cHBvcnRlZC5cIik7XHJcbiAgfVxyXG4gIGNhdGNoIChlKSB7XHJcbiAgICBjb25zdCB7IG1lc3NhZ2UgfSA9IGU7XHJcbiAgICBjb25zb2xlLmVycm9yKGUpO1xyXG4gICAgaWYgKGM2NC5ob29rcy5yZXBvcnRFcnJvcikgYzY0Lmhvb2tzLnJlcG9ydEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgZWxzZSBhbGVydChtZXNzYWdlKTtcclxuICB9XHJcbn1cclxuIiwiLy8gYm91bmQgYnkgYXR0YWNoXHJcbmxldCBjNjQ7XHJcblxyXG4vLyBQb3B1bGF0ZWQgYnkgY2lhc1xyXG5sZXQgc2V0Sm95c3RpY2sxID0gKCkgPT4ge307XHJcbmxldCBzZXRKb3lzdGljazIgPSAoKSA9PiB7fTtcclxuXHJcbi8vIENhbGxlZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24gdG8gdGVsbCB0aGUga2V5Ym9hcmQgZXZlbnQgaGFuZGxlciBob3cgdG8gc2VuZFxyXG4vLyBrZXkgbWF0cmljZXMgdG8gQ0lBMS5cclxuZnVuY3Rpb24gc2V0U2V0Sm95c3RpY2sxKGZuKSB7IHNldEpveXN0aWNrMSA9IGZuOyB9XHJcbmZ1bmN0aW9uIHNldFNldEpveXN0aWNrMihmbikgeyBzZXRKb3lzdGljazIgPSBmbjsgfVxyXG5cclxuXHJcbmNvbnN0IEpPU1RJQ0tfVVAgICAgPSAweDAxO1xyXG5jb25zdCBKT1NUSUNLX0RPV04gID0gMHgwMjtcclxuY29uc3QgSk9TVElDS19MRUZUICA9IDB4MDQ7XHJcbmNvbnN0IEpPU1RJQ0tfUklHSFQgPSAweDA4O1xyXG5jb25zdCBKT1NUSUNLX0ZJUkUgID0gMHgxMDtcclxuXHJcbmxldCBidXR0b25zRG93biA9IG5ldyBTZXQoKTtcclxuXHJcbmZ1bmN0aW9uIGV2ZW50VG9Kb3lzdGlja0J1dHRvbihldmVudCkge1xyXG4gIHN3aXRjaCAoZXZlbnQua2V5KSB7XHJcbiAgICBjYXNlIFwiU2hpZnRcIjogICAgICByZXR1cm4gSk9TVElDS19GSVJFO1xyXG4gICAgY2FzZSBcIkFycm93VXBcIjogICAgcmV0dXJuIEpPU1RJQ0tfVVA7XHJcbiAgICBjYXNlIFwiQXJyb3dEb3duXCI6ICByZXR1cm4gSk9TVElDS19ET1dOO1xyXG4gICAgY2FzZSBcIkFycm93TGVmdFwiOiAgcmV0dXJuIEpPU1RJQ0tfTEVGVDtcclxuICAgIGNhc2UgXCJBcnJvd1JpZ2h0XCI6IHJldHVybiBKT1NUSUNLX1JJR0hUO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gdGVsbENpYSgpIHtcclxuICBsZXQgYnl0ZSA9IDA7XHJcblxyXG4gIGZvciAobGV0IHZhbCBvZiBidXR0b25zRG93bi52YWx1ZXMoKSkge1xyXG4gICAgYnl0ZSB8PSB2YWw7XHJcbiAgfVxyXG5cclxuICAvLyB2YWx1ZXMgZmxvYXQgaGlnaDsgdGhlIGJ1dHRvbnMgcHVsbCB0aGVtIGxvd1xyXG4gIGlmIChjNjQuam95c3RpY2sudG9Db250cm9sUG9ydDEpIHNldEpveXN0aWNrMSgofmJ5dGUpICYgMHhmZik7XHJcbiAgaWYgKGM2NC5qb3lzdGljay50b0NvbnRyb2xQb3J0Mikgc2V0Sm95c3RpY2syKCh+Ynl0ZSkgJiAweGZmKTtcclxufVxyXG5cclxuZ2xvYmFsVGhpcy5hZGRFdmVudExpc3RlbmVyKFxyXG4gIFwia2V5ZG93blwiLFxyXG4gIGV2ZW50ID0+IHtcclxuICAgIGNvbnN0IHNldEtleSA9IGV2ZW50VG9Kb3lzdGlja0J1dHRvbihldmVudCk7XHJcbiAgICBpZiAoIXNldEtleSkgcmV0dXJuO1xyXG5cclxuICAgIGJ1dHRvbnNEb3duLmFkZChzZXRLZXkpO1xyXG4gICAgdGVsbENpYSgpO1xyXG4gIH1cclxuKTtcclxuXHJcbmdsb2JhbFRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcclxuICBcImtleXVwXCIsXHJcbiAgZXZlbnQgPT4ge1xyXG4gICAgY29uc3Qgc2V0S2V5ID0gZXZlbnRUb0pveXN0aWNrQnV0dG9uKGV2ZW50KTtcclxuICAgIGlmICghc2V0S2V5KSByZXR1cm47XHJcblxyXG4gICAgYnV0dG9uc0Rvd24uZGVsZXRlKHNldEtleSk7XHJcbiAgICB0ZWxsQ2lhKCk7XHJcbiAgfVxyXG4pO1xyXG5cclxuZ2xvYmFsVGhpcy5hZGRFdmVudExpc3RlbmVyKFxyXG4gIFwiYmx1clwiLFxyXG4gIGV2ZW50ID0+IHtcclxuICAgIGJ1dHRvbnNEb3duLmNsZWFyKCk7XHJcbiAgICB0ZWxsQ2lhKCk7XHJcbiAgfVxyXG4pO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGF0dGFjaChuYXNjZW50QzY0KSB7XHJcblxyXG4gIGM2NCA9IG5hc2NlbnRDNjQ7XHJcbiAgLy8gVE9ETzogdGhpcyBzaG91bGQgYmUgd2hlcmUgd2Ugc2V0IHVwIHRoZSBldmVudCBsaXN0ZW5lcnNcclxuXHJcbiAgbmFzY2VudEM2NC5qb3lzdGljayA9IHtcclxuICAgIHNldFNldEpveXN0aWNrMSxcclxuICAgIHNldFNldEpveXN0aWNrMixcclxuICAgIHRvQ29udHJvbFBvcnQxOiBmYWxzZSxcclxuICAgIHRvQ29udHJvbFBvcnQyOiB0cnVlLFxyXG4gIH07XHJcbn1cclxuIiwiaW1wb3J0IHtcclxuICBldmVudFRvQnV0dG9uTmFtZXMgICAgIGFzIGV2ZW50VG9CdXR0b25OYW1lc19uYXR1cmFsLFxyXG4gIGtleVN0YWNrVG9CdXR0b25OYW1lcyAgYXMga2V5U3RhY2tUb0J1dHRvbk5hbWVzX25hdHVyYWwsXHJcbn0gZnJvbSBcIi4va2V5Ym9hcmQtbmF0dXJhbFwiO1xyXG5cclxuaW1wb3J0IHtcclxuICBldmVudFRvQnV0dG9uTmFtZXMgICAgIGFzIGV2ZW50VG9CdXR0b25OYW1lc19kaXJlY3QsXHJcbiAga2V5U3RhY2tUb0J1dHRvbk5hbWVzICBhcyBrZXlTdGFja1RvQnV0dG9uTmFtZXNfZGlyZWN0LFxyXG59IGZyb20gXCIuL2tleWJvYXJkLWRpcmVjdFwiO1xyXG5cclxuaW1wb3J0IHsgYnV0dG9uTmFtZVRvTWF0cml4UG9zIH0gZnJvbSBcIi4vYnV0dG9uTmFtZVRvTWF0cml4UG9zXCI7XHJcblxyXG4vLyBCb3VuZCBieSBhdHRhY2hcclxubGV0IGM2NDtcclxuXHJcbi8vIFBvcHVsYXRlZCBieSBzZXRTZXRLZXlNYXRyaXg7XHJcbmxldCBzZXRLZXlNYXRyaXggPSAoKSA9PiB7fTtcclxuXHJcbi8qXHJcbiAgIGtleVN0YWNrOiBhbiBldmVudCBzdGFjayB0aGF0IGNocm9uaWNsZXMgd2hpY2ggQzY0IGtleWJvYXJkIGJ1dHRvbnMgKGxldCdzXHJcbiAgIGNhbGwgdGhlbSAnYnV0dG9ucycgYW5kIHRob3NlIG9mIGhvc3QgbWFjaGluZSdzLCAna2V5cycpIGdvdCBoZWxkIGRvd24gd2hlbi5cclxuXHJcbiAgIEV4YW1wbGU6IGlmIHlvdSB3ZXJlIHRvIGhvbGQgZG93biB5b3VyIFNoaWZ0IGtleSwgdGhlbiB5b3VyIDgga2V5LCBrZXlTdGFja1xyXG4gICB3b3VsZCBiZTpcclxuXHJcbiAgICAgIFtcclxuICAgICAgICB7IGNvZGU6IFwiRGlnaXQ4XCIsIGJ1dHRvbkNvZGVzOiBbLi4uXSB9LFxyXG4gICAgICAgIHsgY29kZTogXCJTaGlmdExlZnRcIiwgYnV0dG9uQ29kZXM6IFsuLi5dIH1cclxuICAgICAgXVxyXG5cclxuICAgLi4ud2hlcmUgYnV0dG9uQ29kZXMgaXMgYW4gYXJyYXkgb2YgbmFtZXMgb2YgQzY0IGJ1dHRvbnMgKHNlZVxyXG4gICBidXR0b25OYW1lVG9NYXRyaXhQb3MpIHRoYXQgY29ycmVzcG9uZGVkIHRvIHRoZSBrZXlib2FyZCBldmVudCwgYW5kIHZhcmllc1xyXG4gICBkZXBlbmRpbmcgb24gdGhlIGtleWJvYXJkIG1hcHBlciB1c2VkLlxyXG5cclxuICAgVGhlICduYXR1cmFsJyBrZXlib2FyZCBtYXBwaW5nLCBmb3IgZXhhbXBsZSwgd291bGQgaGF2ZSBpZGVudGlmaWVkIHRoYXQgdGhlXHJcbiAgIGV2ZW50IHRoYXQgaGFkIHRoZSBgY29kZWAgb2YgRGlnaXQ4IHdhcyBhbiBhc3RlcmlzayBwcmVzcyAoaW4gdGhlIGNhc2Ugb2YgYVxyXG4gICBVUyBrZXlib2FyZCk7IHRodXMgd291bGQgcmVjb3JkIFtcIkFzdGVyaXNrXCJdIGluIGJ1dHRvbkNvZGVzLCB3aGVyZWFzIHRoZVxyXG4gICAnZGlyZWN0JyBrZXlib2FyZCBtYXBwaW5nIHdvdWxkIHJlY29yZCBpdCBhcyBbXCJOdW04XCJdLlxyXG5cclxuICAgV2hlbiBuZXcga2V5cyBhcmUgcHJlc3NlZCwgdGhleSdyZSBwdXNoZWQvbW92ZWQgdG8gdGhlIGZyb250IG9mIHRoZSBzdGFjay5cclxuICAgUmVsZWFzZWQga2V5cyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBzdGFjay5cclxuXHJcbiAgIEl0J3MgaW1wb3J0YW50IHRvIG5vdGUgdGhhdCB0aGUgYGNvZGVgIG9mIHRoZSBzdGFjayBlbnRyaWVzIGlzIHRoZSBgY29kZWBcclxuICAgZmllbGQgb2YgYSBET00ga2V5Ym9hcmQgZXZlbnQsIGFuZCwgaW4gc3BpdGUgb2YgdGhlIG5hbWVzIG9mIGl0cyB2YWx1ZXMsXHJcbiAgIHJlcHJlc2VudHMgdGhlIHBvc2l0aW9uIG9mIGEga2V5LCBub3QgdGhlIHN5bWJvbCBpdCByZXByZXNlbnRzLiBXZSB1c2UgdGhpc1xyXG4gICBwb3NpdGlvbiBpbmZvcm1hdGlvbiBmb3IgaWRlbnRpZnlpbmcsIGluIHRoZSBrZXl1cCwgd2hpY2ggc3RhY2sgZW50cnkgd2FzXHJcbiAgIGdlbmVyYXRlZCBieSB0aGUgb3JpZ2luYWwga2V5ZG93bi4gSGFkIHdlIHVzZWQgYGV2ZW50LmtleWAgaW5zdGVhZCwga2V5c1xyXG4gICB3b3VsZCBqYW0gaW4gY2FzZXMgbGlrZTpcclxuXHJcbiAgICAgICAgICAoaG9sZC1zaGlmdCwgaG9sZC1SLCByZWxlYXNlLXNoaWZ0LCByZWxlYXNlLVIpXHJcblxyXG4gICAuLi53aGVyZSB0aGUgZXZlbnRzIHdlJ2xsIHJlY2VpdmUgd291bGQgaGF2ZSBhIGtleWRvd24gZm9yIFwiUlwiLCBidXQgYSBrZXl1cFxyXG4gICBmb3IgXCJyXCIsIGFuZCB3ZSdkIGJlIHN0dWNrIHdpdGggdGhlIFwiUlwiIG9uIHRoZSBrZXlTdGFjay5cclxuKi9cclxuXHJcbmxldCBrZXlTdGFjayA9IFtcclxuICAvLyB7XHJcbiAgLy8gICBjb2RlXHJcbiAgLy8gICBidXR0b25OYW1lc1xyXG4gIC8vIH1cclxuXTtcclxuXHJcbmZ1bmN0aW9uIGdldEV2ZW50VG9CdXR0b25OYW1lcygpIHtcclxuICByZXR1cm4gKFxyXG4gICAgYzY0LmtleWJvYXJkLm5hdHVyYWxNYXBwaW5nXHJcbiAgICA/IGV2ZW50VG9CdXR0b25OYW1lc19uYXR1cmFsXHJcbiAgICA6IGV2ZW50VG9CdXR0b25OYW1lc19kaXJlY3RcclxuICApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRLZXlTdGFja1RvQnV0dG9uTmFtZXMoKSB7XHJcbiAgcmV0dXJuIChcclxuICAgIGM2NC5rZXlib2FyZC5uYXR1cmFsTWFwcGluZ1xyXG4gICAgPyBrZXlTdGFja1RvQnV0dG9uTmFtZXNfbmF0dXJhbFxyXG4gICAgOiBrZXlTdGFja1RvQnV0dG9uTmFtZXNfZGlyZWN0XHJcbiAgKTtcclxufVxyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhdHRhY2gobmFzY2VudEM2NCkge1xyXG4gIGM2NCA9IG5hc2NlbnRDNjQ7XHJcblxyXG4gIGM2NC5rZXlib2FyZCA9IHtcclxuICAgIHNldFNldEtleU1hdHJpeCxcclxuICAgIGN1cnNvcnNUb0tleXM6IHRydWUsXHJcbiAgICBuYXR1cmFsTWFwcGluZzogdHJ1ZSxcclxuICB9O1xyXG5cclxuICBnbG9iYWxUaGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG9uS2V5RG93bik7XHJcbiAgZ2xvYmFsVGhpcy5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgICBvbktleVVwKTtcclxuICBnbG9iYWxUaGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsICAgIG9uQmx1cik7XHJcbn1cclxuXHJcbi8vIENhbGxlZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24gdG8gdGVsbCB0aGUga2V5Ym9hcmQgZXZlbnQgaGFuZGxlciBob3cgdG8gc2VuZFxyXG4vLyBrZXkgbWF0cmljZXMgdG8gQ0lBMS5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldFNldEtleU1hdHJpeChfc2V0S2V5TWF0cml4KSB7XHJcbiAgc2V0S2V5TWF0cml4ID0gX3NldEtleU1hdHJpeDtcclxufVxyXG5cclxuZnVuY3Rpb24gYnV0dG9uTmFtZXNUb0tleU1hdHJpeChidXR0b25OYW1lcykge1xyXG4gIGNvbnN0IGtleU1hdHJpeCA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcclxuXHJcbiAgZm9yIChsZXQgYnV0dG9uTmFtZSBvZiBidXR0b25OYW1lcykge1xyXG4gICAgY29uc3QgW2NvbHVtbiwgcm93XSA9IGJ1dHRvbk5hbWVUb01hdHJpeFBvc1tidXR0b25OYW1lXTtcclxuICAgIGtleU1hdHJpeFtjb2x1bW5dIHw9ICgxIDw8IHJvdyk7XHJcbiAgfVxyXG5cclxuICBzZXRLZXlNYXRyaXgoa2V5TWF0cml4KTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIG9uS2V5RG93bihldmVudCkge1xyXG4gIC8vIEFueSBrZXlwcmVzcyB3aXRoIHRoZSBNZXRhIGtleSAoY21kL2N0cmwvLi4uKSBkb3duIGlzbid0IGZvciB1cy5cclxuICBpZiAoZXZlbnQubWV0YUtleSkgcmV0dXJuO1xyXG5cclxuICAvLyBTaGlmdC9DdXJzb3JzIG1heSBiZSBkaXNhYmxlZCBmb3Iga2V5Ym9hcmRzIHNvIHRoYXQgdGhleSBjYW4gZ28gdG8gdGhlXHJcbiAgLy8gam95c3RpY2tzIG9ubHkgKG90aGVyd2lzZSBnYW1lcyBsaWtlIEJ1Z2d5IEJveSBnZXQgc3R1Y2spXHJcbiAgaWYgKCFjNjQua2V5Ym9hcmQuY3Vyc29yc1RvS2V5cykge1xyXG4gICAgaWYgKGV2ZW50LmtleSA9PT0gXCJTaGlmdFwiKSAgICAgIHJldHVybjtcclxuICAgIGlmIChldmVudC5rZXkgPT09IFwiQXJyb3dVcFwiKSAgICByZXR1cm47XHJcbiAgICBpZiAoZXZlbnQua2V5ID09PSBcIkFycm93RG93blwiKSAgcmV0dXJuO1xyXG4gICAgaWYgKGV2ZW50LmtleSA9PT0gXCJBcnJvd0xlZnRcIikgIHJldHVybjtcclxuICAgIGlmIChldmVudC5rZXkgPT09IFwiQXJyb3dSaWdodFwiKSByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBNYXAgdGhlIGV2ZW50IHRvIGEgbGlzdCBvZiBDNjQgYnV0dG9ucyB0aGF0IHRoZSBrZXlwcmVzcyBjb3JyZXNwb25kcyB0b1xyXG4gIC8vIChpZiBhbnkpXHJcbiAgY29uc3QgYnV0dG9uTmFtZXMgPSBnZXRFdmVudFRvQnV0dG9uTmFtZXMoKShldmVudCk7XHJcbiAgaWYgKCFidXR0b25OYW1lcykgcmV0dXJuO1xyXG5cclxuICAvLyBGb3IgZGVidWdcclxuICBpZiAoZ2xvYmFsVGhpcy5pbmhpYml0S2V5Ym9hcmQpIHJldHVybjtcclxuXHJcbiAgLy8gQXNzb2NpYXRlIHRoZSBwb3NpdGlvbi1jZW50cmljIGV2ZW50LmNvZGUgd2l0aCB0aGUgbmFtZXMgb2YgdGhlIGJ1dHRvbnMgaXRcclxuICAvLyB0cmFuc2xhdGVzIHRvXHJcbiAga2V5U3RhY2sgPSBbXHJcbiAgICB7XHJcbiAgICAgIGNvZGU6IGV2ZW50LmNvZGUsXHJcbiAgICAgIGJ1dHRvbk5hbWVzXHJcbiAgICB9LFxyXG4gICAgLi4ua2V5U3RhY2suZmlsdGVyKFxyXG4gICAgICAoeyBjb2RlIH0pID0+IChjb2RlICE9PSBldmVudC5jb2RlKVxyXG4gICAgKVxyXG4gIF07XHJcblxyXG4gIC8vIE1ha2UgYXZhaWxhYmxlIHRvIENJQTFcclxuICBidXR0b25OYW1lc1RvS2V5TWF0cml4KFxyXG4gICAgZ2V0S2V5U3RhY2tUb0J1dHRvbk5hbWVzKCkoa2V5U3RhY2spXHJcbiAgKTtcclxuXHJcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gb25LZXlVcChldmVudCkge1xyXG4gIGNvbnN0IGJ1dHRvbk5hbWVzID0gZ2V0RXZlbnRUb0J1dHRvbk5hbWVzKCkoZXZlbnQpO1xyXG4gIGlmICghYnV0dG9uTmFtZXMpIHJldHVybjtcclxuXHJcbiAga2V5U3RhY2sgPSBrZXlTdGFjay5maWx0ZXIoXHJcbiAgICAoeyBjb2RlIH0pID0+IChjb2RlICE9PSBldmVudC5jb2RlKVxyXG4gICk7XHJcblxyXG4gIGJ1dHRvbk5hbWVzVG9LZXlNYXRyaXgoXHJcbiAgICBnZXRLZXlTdGFja1RvQnV0dG9uTmFtZXMoKShrZXlTdGFjaylcclxuICApO1xyXG5cclxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvbkJsdXIoZXZlbnQpIHtcclxuICAvLyBBbGwgYmV0cyBhcmUgb2ZmIHdoZW4gd2UgbG9zZSBmb2N1cy4gU28gYXNzdW1lIGFsbCBrZXlzIGdvdCByZWxlYXNlZC5cclxuICBrZXlTdGFjayA9IFtdO1xyXG4gIGJ1dHRvbk5hbWVzVG9LZXlNYXRyaXgoW10pO1xyXG59XHJcbiIsIi8qXHJcbiAgIFwiRGlyZWN0XCIga2V5Ym9hcmQgbWFwcGluZzogdHJhbnNsYXRlcyB3aGF0IGtleSB5b3UgcHJlc3Mgb24geW91ciBrZXlib2FyZCB0b1xyXG4gICB0aGUgQzY0IGtleSBpbiBhIHJvdWdobHktY29ycmVzcG9uZGluZyBwb3NpdGlvbiAoc2VlIGltYWdlcyBhdFxyXG4gICBodHRwczovL3d3dy5jNjQtd2lraS5jb20vd2lraS9LZXlib2FyZCkuIE5vdGFibGUgZXhjZXB0aW9ucyBhcmU6XHJcbiAgXHJcbiAgICAgKiBSVU4gU1RPUCBpcyBtb3ZlZCB0byBFc2NhcGUuXHJcbiAgICAgKiDihpAgYW5kIOKGkSBhcmUgbW92ZWQgdG8gY3Vyc29yLWxlZnQgYW5kIGN1cnNvci11cC4gVGhvc2UgdHdvIHdlcmUgdW51c2VkXHJcbiAgICAgICBhcyB0aGUgQzY0IHJlcXVpcmVzIHlvdSB0byB1c2Ugc2hpZnQrY3Vyc29yLXJpZ2h0IGFuZCBzaGlmdCtjdXJzb3ItdXBcclxuICAgICAgIGZvciB0aGVtIGFueXdheXMuXHJcbiAgICAgICAoTGlrZSwgc2VyaW91c2x5LCDCoywgQCwg4oaQIGFuZCDihpEgZ290IHRoZWlyIG93biBidXR0b25zLCBidXQgY3Vyc29yLXVwIGFuZFxyXG4gICAgICAgY3Vyc29yLWxlZnQgaGFkIHRvIHNoYXJlPyEpXHJcbiAgICAgKiA9IGlzIG1vdmVkIHRvIHRoZSBiYWNrc2xhc2ggYWJvdmUgRW50ZXIgKG9uIGEgVVMga2V5Ym9hcmQpXHJcbiAgICAgKiDCoyBpcyBtb3ZlZCB0byB0aGUgYmFja3RpY2sgdG8gdGhlIGxlZnQgb2YgMSAob24gYSBVUyBrZXlib2FyZClcclxuICAgICAqIENMUiBIT01FIGlzIG1vdmVkIHRvIEY4LCBhbmQsIGlmIHlvdXIga2V5Ym9hcmQgZmVhdHVyZXMgaXQsIEhvbWUuIElmXHJcbiAgICAgICB5b3UgaGF2ZSBhIG51bWVyaWMga2V5cGFkIHdpdGggYSBDbGVhciBrZXkgKGxpa2UgdGhlIE1hYyBleHRlbmRlZFxyXG4gICAgICAga2V5Ym9hcmQpLCBpdCB3aWxsIGVmZmVjdCBhIGxlZnQtc2hpZnQgYW5kIENMUiBIT01FLlxyXG4gICAgICogUkVTVE9SRSBpcyBwcmVzZW50bHkgdW5tYXBwZWQsIG1vc3RseSBiZWNhdXNlIGl0J3MgY29ubmVjdGVkIHRvIHRoZSBOTUlcclxuICAgICAgIGxpbmUgcmF0aGVyIHRoYW4gdGhlIGtleWJvYXJkIG1hdHJpeC4gU3RpbGwsIGl0IHdvdWxkIGJlIG5pY2UgdG8gZ2V0IGl0XHJcbiAgICAgICBpbiBzb21lZGF5LCBub3QgdGhhdCB3ZSBoYXZlIGFuIG9idmlvdXMgcGh5c2ljYWwgc3BhY2UgZm9yIGl0LlxyXG5cclxuICAgUmVmZXJlbmNlOiBzZWVcclxuICAgICBodHRwczovL2hhY2tzLm1vemlsbGEub3JnLzIwMTcvMDMvaW50ZXJuYXRpb25hbGl6ZS15b3VyLWtleWJvYXJkLWNvbnRyb2xzL1xyXG4gIFxyXG4gICBOb3RlIHRoYXQsIHVubGlrZSBldmVudC5rZXksIGFuZCB1bmxpa2Ugd2hhdCB0aGUgbmFtZXMgb2YgaXRzIHZhbHVlcyB3b3VsZFxyXG4gICBzdWdnZXN0LCBldmVudC5jb2RlIHRlbGxzIHlvdSB0aGUgcGh5c2ljYWwgbG9jYXRpb24gb2YgdGhlIGtleSB0aGF0IHdhc1xyXG4gICBwcmVzc2VkLiBTbyBhbiBldmVudC5jb2RlIG9mIFwiS2V5UVwiIG1lYW5zIHlvdSdkIGhpdCB0aGUgXCJRXCIgb2YgYSBRV0VSVFlcclxuICAga2V5Ym9hcmQgKm9yKiB0aGUgXCJBXCIgb2YgYSBGcmVuY2ggQVpFUlRZIGtleWJvYXJkLiBBIFwiS2V5WVwiIG1lYW5zIHlvdSdkIGhpdFxyXG4gICB0aGUgWSBvZiBhIFFXRVJUWSBrZXlib2FyZCwgb3IgdGhlIFogb2YgYSBHZXJtYW4gUVdFUlRaIGtleWJvYXJkLlxyXG4qL1xyXG5cclxuY29uc3QgZXZlbnRDb2RlVG9CdXR0b25OYW1lcyA9IHtcclxuXHJcbiAgLy8gVG9wIHJvdywgbGVmdC10by1yaWdodFxyXG4gIFwiQXJyb3dMZWZ0XCI6ICAgICAgW1wiTGVmdEFycm93XCJdLCAgICAvLyBOb3Qgd2hlcmUgeW91IG1pZ2h0IGV4cGVjdFxyXG4gIFwiRGlnaXQxXCI6ICAgICAgICAgW1wiTnVtMVwiXSxcclxuICBcIkRpZ2l0MlwiOiAgICAgICAgIFtcIk51bTJcIl0sXHJcbiAgXCJEaWdpdDNcIjogICAgICAgICBbXCJOdW0zXCJdLFxyXG4gIFwiRGlnaXQ0XCI6ICAgICAgICAgW1wiTnVtNFwiXSxcclxuICBcIkRpZ2l0NVwiOiAgICAgICAgIFtcIk51bTVcIl0sXHJcbiAgXCJEaWdpdDZcIjogICAgICAgICBbXCJOdW02XCJdLFxyXG4gIFwiRGlnaXQ3XCI6ICAgICAgICAgW1wiTnVtN1wiXSxcclxuICBcIkRpZ2l0OFwiOiAgICAgICAgIFtcIk51bThcIl0sXHJcbiAgXCJEaWdpdDlcIjogICAgICAgICBbXCJOdW05XCJdLFxyXG4gIFwiRGlnaXQwXCI6ICAgICAgICAgW1wiTnVtMFwiXSxcclxuICBcIk1pbnVzXCI6ICAgICAgICAgIFtcIlBsdXNcIl0sXHJcbiAgXCJFcXVhbFwiOiAgICAgICAgICBbXCJNaW51c1wiXSxcclxuICBcIkJhY2txdW90ZVwiOiAgICAgIFtcIlBvdW5kXCJdLCAgICAgICAgLy8gTm90IHdoZXJlIHlvdSBtaWdodCBleHBlY3RcclxuICBcIkY4XCI6ICAgICAgICAgICAgIFtcIkNsckhvbWVcIl0sICAgICAgLy8gTm90IHdoZXJlIHlvdSBtaWdodCBleHBlY3RcclxuICBcIkJhY2tzcGFjZVwiOiAgICAgIFtcIkluc3REZWxcIl0sXHJcblxyXG4gIC8vIFNlY29uZCByb3csIGxlZnQtdG8tcmlnaHRcclxuICBcIlRhYlwiOiAgICAgICAgICAgIFtcIkN0cmxcIl0sXHJcbiAgXCJLZXlRXCI6ICAgICAgICAgICBbXCJRXCJdLFxyXG4gIFwiS2V5V1wiOiAgICAgICAgICAgW1wiV1wiXSxcclxuICBcIktleUVcIjogICAgICAgICAgIFtcIkVcIl0sXHJcbiAgXCJLZXlSXCI6ICAgICAgICAgICBbXCJSXCJdLFxyXG4gIFwiS2V5VFwiOiAgICAgICAgICAgW1wiVFwiXSxcclxuICBcIktleVlcIjogICAgICAgICAgIFtcIllcIl0sXHJcbiAgXCJLZXlVXCI6ICAgICAgICAgICBbXCJVXCJdLFxyXG4gIFwiS2V5SVwiOiAgICAgICAgICAgW1wiSVwiXSxcclxuICBcIktleU9cIjogICAgICAgICAgIFtcIk9cIl0sXHJcbiAgXCJLZXlQXCI6ICAgICAgICAgICBbXCJQXCJdLFxyXG4gIFwiQnJhY2tldExlZnRcIjogICAgW1wiQXRcIl0sXHJcbiAgXCJCcmFja2V0UmlnaHRcIjogICBbXCJBc3Rlcmlza1wiXSxcclxuICBcIkFycm93VXBcIjogICAgICAgIFtcIlVwQXJyb3dcIl0sICAgICAgLy8gTm90IHdoZXJlIHlvdSBtaWdodCBleHBlY3RcclxuXHJcbiAgLy8gVGhpcmQgcm93LCBsZWZ0LXRvLXJpZ2h0XHJcbiAgXCJFc2NhcGVcIjogICAgICAgICBbXCJSdW5TdG9wXCJdLFxyXG4gIFwiS2V5QVwiOiAgICAgICAgICAgW1wiQVwiXSxcclxuICBcIktleVNcIjogICAgICAgICAgIFtcIlNcIl0sXHJcbiAgXCJLZXlEXCI6ICAgICAgICAgICBbXCJEXCJdLFxyXG4gIFwiS2V5RlwiOiAgICAgICAgICAgW1wiRlwiXSxcclxuICBcIktleUdcIjogICAgICAgICAgIFtcIkdcIl0sXHJcbiAgXCJLZXlIXCI6ICAgICAgICAgICBbXCJIXCJdLFxyXG4gIFwiS2V5SlwiOiAgICAgICAgICAgW1wiSlwiXSxcclxuICBcIktleUtcIjogICAgICAgICAgIFtcIktcIl0sXHJcbiAgXCJLZXlMXCI6ICAgICAgICAgICBbXCJMXCJdLFxyXG4gIFwiU2VtaWNvbG9uXCI6ICAgICAgW1wiQ29sb25cIl0sXHJcbiAgXCJRdW90ZVwiOiAgICAgICAgICBbXCJTZW1pY29sb25cIl0sXHJcbiAgXCJCYWNrc2xhc2hcIjogICAgICBbXCJFcXVhbFwiXSwgICAgICAgIC8vIE5vdCB3aGVyZSB5b3UgbWlnaHQgZXhwZWN0XHJcbiAgXCJFbnRlclwiOiAgICAgICAgICBbXCJSZXR1cm5cIl0sXHJcblxyXG4gIC8vIEZvdXJ0aCByb3csIGxlZnQtdG8tcmlnaHRcclxuICBcIkFsdExlZnRcIjogICAgICAgIFtcIkNvbW1vZG9yZVwiXSxcclxuICBcIlNoaWZ0TGVmdFwiOiAgICAgIFtcIkxlZnRTaGlmdFwiXSxcclxuICBcIktleVpcIjogICAgICAgICAgIFtcIlpcIl0sXHJcbiAgXCJLZXlYXCI6ICAgICAgICAgICBbXCJYXCJdLFxyXG4gIFwiS2V5Q1wiOiAgICAgICAgICAgW1wiQ1wiXSxcclxuICBcIktleVZcIjogICAgICAgICAgIFtcIlZcIl0sXHJcbiAgXCJLZXlCXCI6ICAgICAgICAgICBbXCJCXCJdLFxyXG4gIFwiS2V5TlwiOiAgICAgICAgICAgW1wiTlwiXSxcclxuICBcIktleU1cIjogICAgICAgICAgIFtcIk1cIl0sXHJcbiAgXCJDb21tYVwiOiAgICAgICAgICBbXCJDb21tYVwiXSxcclxuICBcIlBlcmlvZFwiOiAgICAgICAgIFtcIlBlcmlvZFwiXSxcclxuICBcIlNsYXNoXCI6ICAgICAgICAgIFtcIlNsYXNoXCJdLFxyXG4gIFwiU2hpZnRSaWdodFwiOiAgICAgW1wiUmlnaHRTaGlmdFwiXSxcclxuICBcIkFycm93RG93blwiOiAgICAgIFtcIkN1cnNvckRvd25cIl0sXHJcbiAgXCJBcnJvd1JpZ2h0XCI6ICAgICBbXCJDdXJzb3JSaWdodFwiXSxcclxuXHJcbiAgLy8gRmlmdGggcm93LCBsZWZ0LXRvLXJpZ2h0XHJcbiAgXCJTcGFjZVwiOiAgICAgICAgICBbXCJTcGFjZVwiXSxcclxuXHJcbiAgLy8gRnVuY3Rpb24ga2V5c1xyXG4gIFwiRjFcIjogICAgICAgICAgICAgW1wiRjFcIl0sXHJcbiAgXCJGM1wiOiAgICAgICAgICAgICBbXCJGM1wiXSxcclxuICBcIkY1XCI6ICAgICAgICAgICAgIFtcIkY1XCJdLFxyXG4gIFwiRjdcIjogICAgICAgICAgICAgW1wiRjdcIl0sXHJcblxyXG4gIC8vIEFib3ZlIHRoYXQncyBhIDE6MSBtYXBwaW5nIG9mIGV2ZXJ5dGhpbmcuIE5vdyBsZXQncyBtYXAgc29tZSBleHRyYSBrZXlzLFxyXG4gIC8vIGlmIHlvdXIga2V5Ym9hcmQgaGFzIHRoZW0sIHRvIHNvbWV0aGluZyB2YWd1ZWx5IGludHVpdGl2ZTpcclxuICBcIkhvbWVcIjogICAgICAgICAgIFtcIkNsckhvbWVcIl0sXHJcbiAgXCJDbGVhclwiOiAgICAgICAgICBbXCJIb21lXCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG4gIFwiRGVsZXRlXCI6ICAgICAgICAgW1wiSW5zdERlbFwiXSxcclxuICBcIk51bXBhZDBcIjogICAgICAgIFtcIk51bTBcIl0sXHJcbiAgXCJOdW1wYWQxXCI6ICAgICAgICBbXCJOdW0xXCJdLFxyXG4gIFwiTnVtcGFkMlwiOiAgICAgICAgW1wiTnVtMlwiXSxcclxuICBcIk51bXBhZDNcIjogICAgICAgIFtcIk51bTNcIl0sXHJcbiAgXCJOdW1wYWQ0XCI6ICAgICAgICBbXCJOdW00XCJdLFxyXG4gIFwiTnVtcGFkNVwiOiAgICAgICAgW1wiTnVtNVwiXSxcclxuICBcIk51bXBhZDZcIjogICAgICAgIFtcIk51bTZcIl0sXHJcbiAgXCJOdW1wYWQ3XCI6ICAgICAgICBbXCJOdW03XCJdLFxyXG4gIFwiTnVtcGFkOFwiOiAgICAgICAgW1wiTnVtOFwiXSxcclxuICBcIk51bXBhZDlcIjogICAgICAgIFtcIk51bTlcIl0sXHJcbiAgXCJOdW1wYWRFcXVhbFwiOiAgICBbXCJFcXVhbFwiXSxcclxuICBcIk51bXBhZERpdmlkZVwiOiAgIFtcIlNsYXNoXCJdLFxyXG4gIFwiTnVtcGFkTXVsdGlwbHlcIjogW1wiQXN0ZXJpc2tcIl0sXHJcbiAgXCJOdW1wYWRTdWJ0cmFjdFwiOiBbXCJNaW51c1wiXSxcclxuICBcIk51bXBhZEFkZFwiOiAgICAgIFtcIlBsdXNcIl0sXHJcbiAgXCJOdW1wYWRFbnRlclwiOiAgICBbXCJSZXR1cm5cIl0sXHJcbiAgXCJGMlwiOiAgICAgICAgICAgICBbXCJGMVwiLCBcIkxlZnRTaGlmdFwiXSxcclxuICBcIkY0XCI6ICAgICAgICAgICAgIFtcIkYzXCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG4gIFwiRjZcIjogICAgICAgICAgICAgW1wiRjVcIiwgXCJMZWZ0U2hpZnRcIl0sXHJcbiAgXCJGOFwiOiAgICAgICAgICAgICBbXCJGN1wiLCBcIkxlZnRTaGlmdFwiXSxcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGV2ZW50VG9CdXR0b25OYW1lcyhldmVudCkge1xyXG4gIHJldHVybiBldmVudENvZGVUb0J1dHRvbk5hbWVzW2V2ZW50LmNvZGVdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24ga2V5U3RhY2tUb0J1dHRvbk5hbWVzKGtleVN0YWNrKSB7XHJcbiAgLy8gRm9yIHRoZSBkaXJlY3Qga2V5Ym9hcmQgaGFuZGxlciwgd2UncmUgc3RhY2tpbmcgYWxsIHRoZSBwcmVzc2VkIGtleXMgb25cclxuICAvLyB0b3Agb2YgZWFjaCBvdGhlci5cclxuICBjb25zdCBidXR0b25zID0gbmV3IFNldCgpO1xyXG5cclxuICBrZXlTdGFjay5mb3JFYWNoKFxyXG4gICAgKHsgYnV0dG9uTmFtZXMgfSkgPT4gKFxyXG4gICAgICBidXR0b25OYW1lcy5mb3JFYWNoKFxyXG4gICAgICAgIGJ1dHRvbk5hbWUgPT4gYnV0dG9ucy5hZGQoYnV0dG9uTmFtZSlcclxuICAgICAgKVxyXG4gICAgKVxyXG4gICk7XHJcblxyXG4gIHJldHVybiBBcnJheS5mcm9tKGJ1dHRvbnMpO1xyXG59XHJcbiIsIi8qXHJcbiAgIFwiTmF0dXJhbFwiIGtleWJvYXJkIG1hcHBpbmc6IHRyaWVzIHRvIG1hcCB3aGF0IHdhcyB3cml0dGVuIG9uIHlvdXIga2V5IHRvIGFcclxuICAgY29tYmluYXRpb24gb2YgQzY0IHBoeXNpY2FsIGtleXMuIENvbnZlbmllbnQgZm9yIHR5cGluZywgYnV0IG1ha2VzIG1hbnkgQzY0XHJcbiAgIGtleXMsIG9yIGtleSBjb21iaW5hdGlvbnMsIGluYWNjZXNzaWJsZS5cclxuXHJcbiAgIFRoZXJlIGlzIGEgcHJvYmxlbSB3aXRoIHRoaXMgYXBwcm9hY2g6IHByZXNzaW5nIHJlcGVhdGVkIGFzdGVyaXNrcyAoaWZcclxuICAgdGhhdCdzIFNoaWZ0LTggb24geW91ciBrZXlib2FyZCkgYWx0ZXJuYXRlcyBiZXR3ZWVuIHRlbGxpbmcgdGhlIHZpcnR1YWxcclxuICAgbWFjaGluZSB0aGF0IG9ubHkgU0hJRlQgaXMgcHJlc3NlZCwgYW5kIG9ubHkgdGhlICoga2V5IGlzIHByZXNzZWQuIElmIHRoYXRcclxuICAgdHJhbnNpdGlvbiBoYXBwZW5zIGluIHRoZSBtaWRkbGUgb2YgdGhlIGtleWJvYXJkIG1hdHJpeCBzY2FuLCBpdCBjYW4gbG9va1xyXG4gICBsaWtlIGJvdGggYXJlIHByZXNzZWQsIHJlc3VsdGluZyBpbiBhIHNoaWZ0ZWQtKiBrZXkgZ2V0dGluZyB0eXBlZCAoYSBQRVRTQ0lJXHJcbiAgIGhvcml6b250YWwgbGluZSBjaGFyYWN0ZXIpLiBJdCdzIG5vdCBhcyBkaWZmaWN1bHQgdG8gYWNoaWV2ZSBhcyB5b3UgbWlnaHRcclxuICAgdGhpbmsuXHJcblxyXG4gICBBcmd1YWJseSB3ZSBzaG91bGRuJ3QgYmUgc2VuZGluZyBzaGlmdC1vbi1pdHMtb3duIHRvIHRoZSB2aXJ0dWFsIG1hY2hpbmUuXHJcbiovXHJcblxyXG5jb25zdCBldmVudEtleVRvQnV0dG9uTmFtZXMgPSB7XHJcbiAgXCJhXCI6ICAgICAgICAgIFtcIkFcIl0sXHJcbiAgXCJiXCI6ICAgICAgICAgIFtcIkJcIl0sXHJcbiAgXCJjXCI6ICAgICAgICAgIFtcIkNcIl0sXHJcbiAgXCJkXCI6ICAgICAgICAgIFtcIkRcIl0sXHJcbiAgXCJlXCI6ICAgICAgICAgIFtcIkVcIl0sXHJcbiAgXCJmXCI6ICAgICAgICAgIFtcIkZcIl0sXHJcbiAgXCJnXCI6ICAgICAgICAgIFtcIkdcIl0sXHJcbiAgXCJoXCI6ICAgICAgICAgIFtcIkhcIl0sXHJcbiAgXCJpXCI6ICAgICAgICAgIFtcIklcIl0sXHJcbiAgXCJqXCI6ICAgICAgICAgIFtcIkpcIl0sXHJcbiAgXCJrXCI6ICAgICAgICAgIFtcIktcIl0sXHJcbiAgXCJsXCI6ICAgICAgICAgIFtcIkxcIl0sXHJcbiAgXCJtXCI6ICAgICAgICAgIFtcIk1cIl0sXHJcbiAgXCJuXCI6ICAgICAgICAgIFtcIk5cIl0sXHJcbiAgXCJvXCI6ICAgICAgICAgIFtcIk9cIl0sXHJcbiAgXCJwXCI6ICAgICAgICAgIFtcIlBcIl0sXHJcbiAgXCJxXCI6ICAgICAgICAgIFtcIlFcIl0sXHJcbiAgXCJyXCI6ICAgICAgICAgIFtcIlJcIl0sXHJcbiAgXCJzXCI6ICAgICAgICAgIFtcIlNcIl0sXHJcbiAgXCJ0XCI6ICAgICAgICAgIFtcIlRcIl0sXHJcbiAgXCJ1XCI6ICAgICAgICAgIFtcIlVcIl0sXHJcbiAgXCJ2XCI6ICAgICAgICAgIFtcIlZcIl0sXHJcbiAgXCJ3XCI6ICAgICAgICAgIFtcIldcIl0sXHJcbiAgXCJ4XCI6ICAgICAgICAgIFtcIlhcIl0sXHJcbiAgXCJ5XCI6ICAgICAgICAgIFtcIllcIl0sXHJcbiAgXCJ6XCI6ICAgICAgICAgIFtcIlpcIl0sXHJcblxyXG4gIFwiQVwiOiAgICAgICAgICBbXCJBXCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG4gIFwiQlwiOiAgICAgICAgICBbXCJCXCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG4gIFwiQ1wiOiAgICAgICAgICBbXCJDXCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG4gIFwiRFwiOiAgICAgICAgICBbXCJEXCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG4gIFwiRVwiOiAgICAgICAgICBbXCJFXCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG4gIFwiRlwiOiAgICAgICAgICBbXCJGXCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG4gIFwiR1wiOiAgICAgICAgICBbXCJHXCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG4gIFwiSFwiOiAgICAgICAgICBbXCJIXCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG4gIFwiSVwiOiAgICAgICAgICBbXCJJXCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG4gIFwiSlwiOiAgICAgICAgICBbXCJKXCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG4gIFwiS1wiOiAgICAgICAgICBbXCJLXCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG4gIFwiTFwiOiAgICAgICAgICBbXCJMXCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG4gIFwiTVwiOiAgICAgICAgICBbXCJNXCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG4gIFwiTlwiOiAgICAgICAgICBbXCJOXCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG4gIFwiT1wiOiAgICAgICAgICBbXCJPXCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG4gIFwiUFwiOiAgICAgICAgICBbXCJQXCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG4gIFwiUVwiOiAgICAgICAgICBbXCJRXCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG4gIFwiUlwiOiAgICAgICAgICBbXCJSXCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG4gIFwiU1wiOiAgICAgICAgICBbXCJTXCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG4gIFwiVFwiOiAgICAgICAgICBbXCJUXCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG4gIFwiVVwiOiAgICAgICAgICBbXCJVXCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG4gIFwiVlwiOiAgICAgICAgICBbXCJWXCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG4gIFwiV1wiOiAgICAgICAgICBbXCJXXCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG4gIFwiWFwiOiAgICAgICAgICBbXCJYXCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG4gIFwiWVwiOiAgICAgICAgICBbXCJZXCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG4gIFwiWlwiOiAgICAgICAgICBbXCJaXCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG5cclxuICBcIjBcIjogICAgICAgICAgW1wiTnVtMFwiXSxcclxuICBcIjFcIjogICAgICAgICAgW1wiTnVtMVwiXSxcclxuICBcIjJcIjogICAgICAgICAgW1wiTnVtMlwiXSxcclxuICBcIjNcIjogICAgICAgICAgW1wiTnVtM1wiXSxcclxuICBcIjRcIjogICAgICAgICAgW1wiTnVtNFwiXSxcclxuICBcIjVcIjogICAgICAgICAgW1wiTnVtNVwiXSxcclxuICBcIjZcIjogICAgICAgICAgW1wiTnVtNlwiXSxcclxuICBcIjdcIjogICAgICAgICAgW1wiTnVtN1wiXSxcclxuICBcIjhcIjogICAgICAgICAgW1wiTnVtOFwiXSxcclxuICBcIjlcIjogICAgICAgICAgW1wiTnVtOVwiXSxcclxuXHJcbiAgXCIhXCI6ICAgICAgICAgIFtcIk51bTFcIiwgXCJMZWZ0U2hpZnRcIl0sXHJcbiAgJ1wiJzogICAgICAgICAgW1wiTnVtMlwiLCBcIkxlZnRTaGlmdFwiXSxcclxuICBcIiNcIjogICAgICAgICAgW1wiTnVtM1wiLCBcIkxlZnRTaGlmdFwiXSxcclxuICBcIiRcIjogICAgICAgICAgW1wiTnVtNFwiLCBcIkxlZnRTaGlmdFwiXSxcclxuICBcIiVcIjogICAgICAgICAgW1wiTnVtNVwiLCBcIkxlZnRTaGlmdFwiXSxcclxuICBcIiZcIjogICAgICAgICAgW1wiTnVtNlwiLCBcIkxlZnRTaGlmdFwiXSxcclxuICBcIidcIjogICAgICAgICAgW1wiTnVtN1wiLCBcIkxlZnRTaGlmdFwiXSxcclxuICBcIihcIjogICAgICAgICAgW1wiTnVtOFwiLCBcIkxlZnRTaGlmdFwiXSxcclxuICBcIilcIjogICAgICAgICAgW1wiTnVtOVwiLCBcIkxlZnRTaGlmdFwiXSxcclxuXHJcbiAgXCIgXCI6ICAgICAgICAgIFtcIlNwYWNlXCJdLFxyXG4gIFwiQmFja3NwYWNlXCI6ICBbXCJJbnN0RGVsXCJdLFxyXG4gIFwiRW50ZXJcIjogICAgICBbXCJSZXR1cm5cIl0sXHJcbiAgXCJFc2NhcGVcIjogICAgIFtcIlJ1blN0b3BcIl0sXHJcblxyXG4gIFwiK1wiOiAgICAgICAgICBbXCJQbHVzXCJdLFxyXG4gIFwiLVwiOiAgICAgICAgICBbXCJNaW51c1wiXSxcclxuICBcIj1cIjogICAgICAgICAgW1wiRXF1YWxcIl0sXHJcbiAgXCJAXCI6ICAgICAgICAgIFtcIkF0XCJdLFxyXG4gIFwiwqNcIjogICAgICAgICAgW1wiUG91bmRcIl0sXHJcbiAgXCIqXCI6ICAgICAgICAgIFtcIkFzdGVyaXNrXCJdLFxyXG4gIFwiLFwiOiAgICAgICAgICBbXCJDb21tYVwiXSxcclxuICBcIi5cIjogICAgICAgICAgW1wiUGVyaW9kXCJdLFxyXG4gIFwiL1wiOiAgICAgICAgICBbXCJTbGFzaFwiXSxcclxuICBcIj9cIjogICAgICAgICAgW1wiU2xhc2hcIiwgXCJMZWZ0U2hpZnRcIl0sXHJcbiAgXCI6XCI6ICAgICAgICAgIFtcIkNvbG9uXCJdLFxyXG4gIFwiO1wiOiAgICAgICAgICBbXCJTZW1pY29sb25cIl0sXHJcbiAgXCJbXCI6ICAgICAgICAgIFtcIkNvbG9uXCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG4gIFwiXVwiOiAgICAgICAgICBbXCJTZW1pY29sb25cIiwgXCJMZWZ0U2hpZnRcIl0sXHJcblxyXG4gIFwiU2hpZnRcIjogICAgICBbXCJMZWZ0U2hpZnRcIl0sXHJcbiAgXCJIb21lXCI6ICAgICAgIFtcIkNsckhvbWVcIl0sXHJcbiAgXCJBcnJvd0xlZnRcIjogIFtcIkN1cnNvclJpZ2h0XCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG4gIFwiQXJyb3dSaWdodFwiOiBbXCJDdXJzb3JSaWdodFwiXSxcclxuICBcIkFycm93VXBcIjogICAgW1wiQ3Vyc29yRG93blwiLCBcIkxlZnRTaGlmdFwiXSxcclxuICBcIkFycm93RG93blwiOiAgW1wiQ3Vyc29yRG93blwiXSxcclxuXHJcbiAgXCJGMVwiOiAgICAgICAgIFtcIkYxXCJdLFxyXG4gIFwiRjJcIjogICAgICAgICBbXCJGMVwiLCBcIkxlZnRTaGlmdFwiXSxcclxuICBcIkYzXCI6ICAgICAgICAgW1wiRjNcIl0sXHJcbiAgXCJGNFwiOiAgICAgICAgIFtcIkYzXCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG4gIFwiRjVcIjogICAgICAgICBbXCJGNVwiXSxcclxuICBcIkY2XCI6ICAgICAgICAgW1wiRjVcIiwgXCJMZWZ0U2hpZnRcIl0sXHJcbiAgXCJGN1wiOiAgICAgICAgIFtcIkY3XCJdLFxyXG4gIFwiRjhcIjogICAgICAgICBbXCJGN1wiLCBcIkxlZnRTaGlmdFwiXSxcclxuXHJcbiAgLy8gV2UncmUgbm90IGdvaW5nIHRvIHRyYW5zbGF0ZSBhbGwgb2Ygb3VyIFVuaWNvZGUgdHJhbnNsYXRpb25zIChzZWVcclxuICAvLyB2aWRlb0FzQW5zaS5qcykgYmFjayB0byBQRVRTQ0lJLCBidXQgd2UnbGwgbWFrZSBhbiBleGNlcHRpb24gZm9yIM+ALCBzaW5jZVxyXG4gIC8vIEJhc2ljIHVuZGVyc3RhbmRzIGl0IGFzIGEgdG9rZW4uXHJcbiAgXCLPgFwiOiAgICAgICAgICBbXCJVcEFycm93XCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG5cclxuICAvLyBOb3QgbGl0ZXJhbDsgcHJvdmlkZWQgZm9yIGNvbnZlbmllbmNlXHJcbiAgXCJgXCI6ICAgICAgICAgIFtcIkxlZnRBcnJvd1wiXSxcclxuICBcIn5cIjogICAgICAgICAgW1wiVXBBcnJvd1wiXSxcclxuICBcIlxcXFxcIjogICAgICAgICBbXCJDbHJIb21lXCJdLFxyXG4gIFwifFwiOiAgICAgICAgICBbXCJDbHJIb21lXCIsIFwiTGVmdFNoaWZ0XCJdLFxyXG4gIFwiXlwiOiAgICAgICAgICBbXCJDb21tb2RvcmVcIiwgXCJMZWZ0U2hpZnRcIl0sXHJcbiAgXCJfXCI6ICAgICAgICAgIFtcIlJ1blN0b3BcIiwgXCJMZWZ0U2hpZnRcIl0sXHJcbiAgXCJ7XCI6ICAgICAgICAgIFtcIkN0cmxcIiwgXCJOdW05XCJdLFxyXG4gIFwifVwiOiAgICAgICAgICBbXCJDdHJsXCIsIFwiTnVtMFwiXSxcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBldmVudFRvQnV0dG9uTmFtZXMoZXZlbnQpIHtcclxuICByZXR1cm4gZXZlbnRLZXlUb0J1dHRvbk5hbWVzW2V2ZW50LmtleV07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBrZXlTdGFja1RvQnV0dG9uTmFtZXMoa2V5U3RhY2spIHtcclxuICAvLyBGb3IgdGhlIG5hdHVyYWwga2V5Ym9hcmQgaGFuZGxlciwgb25seSB0aGUgYnV0dG9ucyBmb3IgdGhlIG1vc3QgcmVjZW50IGtleVxyXG4gIC8vIGV2ZW50IGFyZSBoZWxkLiBUaHVzLCBpZiB5b3UgdHlwZSBhbiBhc3RlcmlzayBieSBTaGlmdC04IChlZy4gb24gYSBVU1xyXG4gIC8vIGtleWJvYXJkKSwgdGhlIHJlc3VsdCB3aWxsIGJlIGp1c3QgdGhlIHNpbmdsZSBrZXksIFtcIkFzdGVyaXNrXCJdLCBub3RcclxuICAvLyB0aGUgY29tYmluYXRpb24gW1wiQXN0ZXJpc2ssIExlZnRTaGlmdFwiXSwgd2hpY2ggY29ycmVzcG9uZHMgdG8gYSBQRVRTQ0lJXHJcbiAgLy8gaG9yaXpvbnRhbCBsaW5lIGNoYXJhY3Rlci5cclxuICBpZiAoIWtleVN0YWNrLmxlbmd0aCkgcmV0dXJuIFtdO1xyXG4gIHJldHVybiBrZXlTdGFja1swXS5idXR0b25OYW1lcztcclxufVxyXG4iLCIvLyBSZWZlcmVuY2VzOlxyXG4vLyDigKAxIGh0dHA6Ly93d3cuemltbWVycy5uZXQvY2JtcGljcy9jYm0vYzY0L3ZpYy1paS50eHRcclxuXHJcbi8vIEEgUEFMIGZyYW1lICjigKAxKSBpcyAzMTIgbGluZXMgb2YgNTA0IHBpeGVscyBlYWNoLiAoOCBwaXhlbHMvY3ljbGUsIDYzIGN5Y2xlc1xyXG4vLyBwZXIgbGluZSkuIFRoZSBlbXVsYXRlZCBWaWMgd2lsbCBjYWxsIG91ciBzZXRQaXhlbCBmb3IgZWFjaCBvZiB0aG9zZSAxNTcsMjQ4XHJcbi8vIHZpcnR1YWwgcGl4ZWxzLCBtYW55IG9mIHdoaWNoIGFyZSBpbiB0aGUgaGJsYW5rIG9yIHZibGFuaywgYW5kIGl0J3MgdXAgdG9cclxuLy8gdGhpcyBpbnRlcmZhY2UgdG8gZGlzY2FyZCB0aG9zZS5cclxuLy9cclxuLy8gQWNjb3JkaW5nIHRvIHRoYXQgc2FtZSBzb3VyY2UsIHRoZXJlIGFyZSAyODQgdmlzaWJsZSBsaW5lcyBvZiA0MDMgdmlzaWJsZVxyXG4vLyBwaXhlbHMgZWFjaC4gSSdtIGNvZXJjaW5nIHRob3NlIG51bWJlcnMgYSBsaXR0bGUgdG8gZ2V0IHRoZSBkaW1lbnRpb25zXHJcbi8vIGJlbG93LCBhbmQgdGhleSdsbCBsaWtlbHkgY2hhbmdlIHdoZW4gdGhlIFZpYyBlbXVsYXRpb24gZ2V0cyBtb3JlIGN5Y2xlLVxyXG4vLyBhY2N1cmF0ZS5cclxuXHJcblxyXG4vLyBDb25zdGFudHMgdGhhdCBtYXkgYmUgdmFyaWFibGUgaW4gZnV0dXJlXHJcbi8vIHggYW5kIHkgcG9zaXRpb24gKGFzIGFyZ3VtZW50cyB0byBzZXRQaXhlbCkgZm9yIGZpcnN0IHZpc2libGUgcGl4ZWxzXHJcbmxldCBmaXJzdF94ID0gOTU7XHJcbmxldCBmaXJzdF95ID0gMTA7XHJcblxyXG5sZXQgY2FudmFzX3cgPSA0MDI7XHJcbmxldCBjYW52YXNfaCA9IDI4MjtcclxuXHJcbmNvbnN0IFNDT1BFX1dJRFRIID0gMjc0O1xyXG5jb25zdCBUUkFZX0hFSUdIVCA9IDcwOyAgICAgLy8gVE9ETzogdW5sZXNzIHRoZSB3aW5kb3cgaXMgbmFycm93XHJcbmNvbnN0IFNOQVBTSE9UU19XSURUSCA9IDE1MDtcclxuXHJcbmxldCBjYW52YXM7XHJcbmxldCBjb250ZXh0O1xyXG5sZXQgaW1hZ2VEYXRhO1xyXG5sZXQgYml0bWFwO1xyXG5sZXQgc2hvd2luZ1RyYXlzICAgICA9IGZhbHNlO1xyXG5sZXQgc2hvd2luZ1Njb3BlICAgICA9IGZhbHNlO1xyXG5sZXQgc2hvd2luZ1NuYXBzaG90cyA9IGZhbHNlO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGF0dGFjaChuYXNjZW50QzY0KSB7XHJcbiAgbmFzY2VudEM2NC52aWRlbyA9IHtcclxuICAgIC8vIENvbnRyb2xcclxuICAgIHJlc2V0LFxyXG4gICAgLy8gSW50ZXJmYWNlLXNwZWNpZmljIGhhbmRsZXJzXHJcbiAgICBzZXRQaXhlbCxcclxuICAgIGJsaXQsXHJcbiAgfTtcclxuXHJcbiAgY3JlYXRlQ2FudmFzKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlc2V0KCkge1xyXG4gIGNsZWFyQ2FudmFzKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUNhbnZhcygpIHtcclxuICBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNhbnZhc1wiKTtcclxuICBjYW52YXMuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgIGNhbnZhc193KTtcclxuICBjYW52YXMuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGNhbnZhc19oKTtcclxuXHJcbiAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzX3csIGNhbnZhc19oKTtcclxuICBiaXRtYXAgPSBpbWFnZURhdGEuZGF0YTsgIFxyXG4gIGNsZWFyQ2FudmFzKCk7XHJcblxyXG4gIHBvc2l0aW9uQ2FudmFzKCk7XHJcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgb25SZXNpemUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2V0SGFzU2NvcGUoaGFzU2NvcGUpIHtcclxuICBzaG93aW5nU2NvcGUgPSBoYXNTY29wZTtcclxuICBwb3NpdGlvbkNhbnZhcygpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2V0SGFzVHJheXMoaGFzVHJheXMpIHtcclxuICBzaG93aW5nVHJheXMgPSBoYXNUcmF5cztcclxuICBwb3NpdGlvbkNhbnZhcygpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2V0SGFzU25hcHNob3RzKGhhc1NuYXBzaG90cykge1xyXG4gIHNob3dpbmdTbmFwc2hvdHMgPSBoYXNTbmFwc2hvdHM7XHJcbiAgcG9zaXRpb25DYW52YXMoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gb25SZXNpemUoKSB7XHJcbiAgLy8gRG9uJ3QgYWxsb3cgdGhlIGNhbnZhcyBzaXplIHRyYW5zaXRpb24gdG8gaGFwcGVuIHdoZW4gdGhlIHdpbmRvdyByZXNpemVzLFxyXG4gIC8vIG9yIGl0J2xsIGJlIGEgc2xvdyBnbG9vcHkgbWVzcy5cclxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoXHJcbiAgICAoKSA9PiB7XHJcbiAgICAgIGNhbnZhcy5jbGFzc0xpc3QuYWRkKFwibm8tdHJhbnNpdGlvblwiKTtcclxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKFxyXG4gICAgICAgICgpID0+IHtcclxuICAgICAgICAgIHBvc2l0aW9uQ2FudmFzKCk7XHJcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoXHJcbiAgICAgICAgICAgICgpID0+IHtcclxuICAgICAgICAgICAgICBjYW52YXMuY2xhc3NMaXN0LnJlbW92ZShcIm5vLXRyYW5zaXRpb25cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICk7ICAgICAgICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBvc2l0aW9uQ2FudmFzKCkge1xyXG4gIGNvbnN0IHsgaW5uZXJXaWR0aCwgaW5uZXJIZWlnaHQgfSA9IHdpbmRvdztcclxuXHJcbiAgLy8gRmlyc3QgYXNzZXNzIHRoZSBleHRlbnRzIG9mIHRoZSBwb3RlbnRpYWwgYXJlYSBpbnRvIHdoaWNoIHRoZSBjYW52YXMgY291bGRcclxuICAvLyBiZSBwb3NpdGlvbmVkLlxyXG5cclxuICAvLyBhdmFpbFdpZHRoL0hlaWdodCwgbWluL21heFVzYWJsZVgvWTogYXJlYXMgb2YgdGhlIHdpbmRvdyBub3Qgb2NjdXBpZWQgYnlcclxuICAvLyB0aGUgdHJheXMvcmFpbHMuXHJcbiAgbGV0IGF2YWlsV2lkdGggID0gaW5uZXJXaWR0aDtcclxuICBsZXQgYXZhaWxIZWlnaHQgPSBpbm5lckhlaWdodDtcclxuICBsZXQgbWluVXNhYmxlWCAgPSAwO1xyXG4gIGxldCBtYXhVc2FibGVYICA9IGlubmVyV2lkdGg7XHJcbiAgbGV0IG1pblVzYWJsZVkgID0gMDtcclxuICBsZXQgbWF4VXNhYmxlWSAgPSBpbm5lckhlaWdodDtcclxuXHJcbiAgaWYgKHNob3dpbmdTY29wZSkge1xyXG4gICAgYXZhaWxXaWR0aCAtPSBTQ09QRV9XSURUSDtcclxuICAgIG1heFVzYWJsZVggLT0gU0NPUEVfV0lEVEg7XHJcbiAgfVxyXG4gIFxyXG4gIGlmIChzaG93aW5nVHJheXMpIHtcclxuICAgIGF2YWlsSGVpZ2h0IC09IDIgKiBUUkFZX0hFSUdIVDtcclxuICAgIG1pblVzYWJsZVkgKz0gVFJBWV9IRUlHSFQ7XHJcbiAgICBtYXhVc2FibGVZIC09IFRSQVlfSEVJR0hUO1xyXG4gIH1cclxuXHJcbiAgaWYgKHNob3dpbmdTbmFwc2hvdHMpIHtcclxuICAgIGF2YWlsV2lkdGggLT0gU05BUFNIT1RTX1dJRFRIO1xyXG4gICAgbWluVXNhYmxlWCArPSBTTkFQU0hPVFNfV0lEVEg7XHJcbiAgfVxyXG5cclxuICAvLyBOb3cgY29uc2lkZXIgaXRzIHdpZHRoIGFuZCBoZWlnaHQ6IGZpbGwgdGhlIGF2YWlsYWJsZSB3aWR0aCBvciBoZWlnaHRcclxuICAvLyBkZXBlbmRpbmcgb24gd2hpY2ggY29uc3RyYWlucyB1cyBmaXJzdC5cclxuXHJcbiAgY29uc3Qgc3JjUmF0aW8gPSBjYW52YXNfdyAvIGNhbnZhc19oO1xyXG4gIGxldCB3LCBoO1xyXG5cclxuICBpZiAoKGF2YWlsV2lkdGggLyBhdmFpbEhlaWdodCkgPiBzcmNSYXRpbykge1xyXG4gICAgLy8gY2FudmFzIGhhcyBhIHdpZGVyIHJhdGlvIHNvIGJvdW5kIGl0IGJ5IGhlaWdodFxyXG4gICAgaCA9IGF2YWlsSGVpZ2h0O1xyXG4gICAgdyA9IGF2YWlsSGVpZ2h0ICogc3JjUmF0aW87XHJcbiAgfVxyXG4gIGVsc2Uge1xyXG4gICAgLy8gY2FudmFzIGhhcyBhIHRhbGxlciByYXRpbyBzbyBib3VuZCBpdCBieSB3aWR0aFxyXG4gICAgaCA9IGF2YWlsV2lkdGggLyBzcmNSYXRpbztcclxuICAgIHcgPSBhdmFpbFdpZHRoO1xyXG4gIH1cclxuXHJcbiAgLy8gRmluYWxseSBjb25zaWRlciBjZW50ZXJpbmcuIFdlJ2xsIGZpcnN0IHRyeSBjZW50ZXJpbmcgd2l0aGluIHRoZSBvcmlnaW5hbFxyXG4gIC8vIHdpbmRvdyByYXRoZXIgdGhhbiB3aXRoaW4gdGhlIHdoaXR0bGVkIGRvd24tc3BhY2UuIElmIHdlJ2QgaGl0IGEgcmFpbCBpblxyXG4gIC8vIGRvaW5nIHNvLCBudWRnZSBpdCB1bnRpbCBpdCdzIG9ubHkganVzdCB0b3VjaGluZyB0aGF0IHJhaWwuXHJcblxyXG4gIGxldCBpZGVhbFggPSAoaW5uZXJXaWR0aCAtIHcpIC8gMjtcclxuICBsZXQgeDtcclxuXHJcbiAgaWYgKGlkZWFsWCA8IG1pblVzYWJsZVgpIHggPSBtaW5Vc2FibGVYO1xyXG4gIGVsc2UgaWYgKChpZGVhbFggKyB3KSA+PSBtYXhVc2FibGVYKSB4ID0gbWF4VXNhYmxlWCAtIHc7XHJcbiAgZWxzZSB4ID0gaWRlYWxYO1xyXG5cclxuICAvLyBWZXJ0aWNhbCBjZW50ZXJpbmcncyBlYXN5OiBlaXRoZXIgYm90aCB0cmF5cyBhcmUgc2hvd2luZywgb3IgbmVpdGhlciBhcmUuXHJcbiAgLy8gQW5kIHRoZXknZCBib3RoIHRoZSBzYW1lIGhlaWdodCwgc28gdGhlIGNhbGN1bGF0aW9uIGNhbiBpZ25vcmUgdGhlbS5cclxuXHJcbiAgbGV0IHkgPSBtaW5Vc2FibGVZO1xyXG4gIHkgKz0gKGF2YWlsSGVpZ2h0IC0gaCkgLyAyO1xyXG5cclxuICBjYW52YXMuc2V0QXR0cmlidXRlKFxyXG4gICAgXCJzdHlsZVwiLFxyXG4gICAgYHdpZHRoOiAke01hdGgucm91bmQodyl9cHg7YCArXHJcbiAgICBgaGVpZ2h0OiAke01hdGgucm91bmQoaCl9cHg7YCArXHJcbiAgICBgbGVmdDogJHtNYXRoLnJvdW5kKHgpfXB4O2AgK1xyXG4gICAgYHRvcDogJHtNYXRoLnJvdW5kKHkpfXB4O2BcclxuICApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjbGVhckNhbnZhcygpIHtcclxuICBsZXQgaW5kZXggPSAwO1xyXG5cclxuICBmb3IgKGxldCB5ID0gMDsgeSA8IGNhbnZhc19oOyB5KyspIHtcclxuICAgIGZvciAobGV0IHggPSAwOyB4IDwgY2FudmFzX3c7IHgrKykge1xyXG4gICAgICBiaXRtYXBbaW5kZXgrK10gPSAwO1xyXG4gICAgICBiaXRtYXBbaW5kZXgrK10gPSAwO1xyXG4gICAgICBiaXRtYXBbaW5kZXgrK10gPSAwOyBcclxuICAgICAgYml0bWFwW2luZGV4KytdID0gMjU1O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYmxpdCgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRQaXhlbCh4LCB5LCByLCBnLCBiKSB7XHJcbiAgeCAtPSBmaXJzdF94O1xyXG4gIHkgLT0gZmlyc3RfeTtcclxuXHJcbiAgaWYgKCh4IDwgMCkgfHwgKHggPj0gY2FudmFzX3cpKSByZXR1cm47XHJcbiAgaWYgKCh5IDwgMCkgfHwgKHkgPj0gY2FudmFzX2gpKSByZXR1cm47XHJcblxyXG4gIGxldCBpbmRleCA9ICgoKHkgKiBjYW52YXNfdykgKyB4KSAqIDQpO1xyXG5cclxuICAvLyBSZWxpZXMgb24gdGhlIGFscGhhIHZhbHVlcyBoYXZpbmcgYWxyZWFkeSBiZWVuIHNldCBieSBjbGVhckNhbnZhc1xyXG4gIGJpdG1hcFtpbmRleCsrXSA9IHI7XHJcbiAgYml0bWFwW2luZGV4KytdID0gZztcclxuICBiaXRtYXBbaW5kZXggIF0gPSBiO1xyXG59XHJcblxyXG5mdW5jdGlvbiBibGl0KCkge1xyXG4gIGNvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7IFxyXG59XHJcbiIsIi8vIGJvdW5kIGJ5IGF0dGFjaFxyXG5sZXQgYzY0O1xyXG5cclxuY29uc3QgYWxsT2ZmU3RhdGUgPSB7XHJcbiAgaWdub3JlU3ByU3ByOiBmYWxzZSxcclxuICBpZ25vcmVTcHJCZzogIGZhbHNlLFxyXG4gIGRvbnRWaXM6ICAgICAgZmFsc2UsXHJcbn07XHJcblxyXG5jb25zdCBkZXNpcmVkU3RhdGUgPSB7IC4uLmFsbE9mZlN0YXRlIH07XHJcblxyXG5jb25zdCBjaGVja2JveGVzID0gW1xyXG4gIHsgZG9tSWQ6IFwibm9TcHJTcHJDb2xCdXR0b25cIiwgZGVzaXJlZFN0YXRlS2V5OiBcImlnbm9yZVNwclNwclwiIH0sXHJcbiAgeyBkb21JZDogXCJub1NwckJnQ29sQnV0dG9uXCIsICBkZXNpcmVkU3RhdGVLZXk6IFwiaWdub3JlU3ByQmdcIiAgfSxcclxuICB7IGRvbUlkOiBcIm5vVmlzQ29sQnV0dG9uXCIsICAgIGRlc2lyZWRTdGF0ZUtleTogXCJkb250VmlzXCIgICAgICB9LFxyXG5dO1xyXG5cclxuZnVuY3Rpb24gYXR0YWNoKG5hc2NlbnRDNjQpIHtcclxuICBjNjQgPSBuYXNjZW50QzY0O1xyXG5cclxuICBmb3IgKGxldCB7IGRvbUlkLCBkZXNpcmVkU3RhdGVLZXkgfSBvZiBjaGVja2JveGVzKSB7XHJcbiAgICBhdHRhY2hFdmVudEhhbmRsZXIoZG9tSWQsIGRlc2lyZWRTdGF0ZUtleSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBseVN0YXRlKHN0YXRlKSB7XHJcbiAgYzY0LnZpYy5zZXRTY29wZShzdGF0ZS5kb250VmlzID8gbnVsbCA6IFwic2NvcGVDb2xsaXNpb25cIik7XHJcbiAgYzY0LnZpYy5zZXRJZ25vcmVTcHJCZ0NvbCAoc3RhdGUuaWdub3JlU3ByQmcpO1xyXG4gIGM2NC52aWMuc2V0SWdub3JlU3ByU3ByQ29sKHN0YXRlLmlnbm9yZVNwclNwcik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldENoZWNrYm94ZXNGcm9tU3RhdGUoc3RhdGUpIHtcclxuICBmb3IgKGxldCB7IGRvbUlkLCBkZXNpcmVkU3RhdGVLZXkgfSBvZiBjaGVja2JveGVzKSB7XHJcbiAgICBjb25zdCB7IGNsYXNzTGlzdCB9ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZG9tSWQpO1xyXG4gICAgY2xhc3NMaXN0LnJlbW92ZShcInNlbGVjdGVkXCIpO1xyXG4gICAgaWYgKHN0YXRlW2Rlc2lyZWRTdGF0ZUtleV0pIGNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZFwiKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGF0dGFjaEV2ZW50SGFuZGxlcihkb21JZCwgZGVzaXJlZFN0YXRlS2V5KSB7XHJcbiAgZG9jdW1lbnRcclxuICAgIC5nZXRFbGVtZW50QnlJZChkb21JZClcclxuICAgIC5hZGRFdmVudExpc3RlbmVyKFxyXG4gICAgICBcImNsaWNrXCIsXHJcbiAgICAgIChldmVudCkgPT4ge1xyXG4gICAgICAgIGRlc2lyZWRTdGF0ZVtkZXNpcmVkU3RhdGVLZXldID0gIWRlc2lyZWRTdGF0ZVtkZXNpcmVkU3RhdGVLZXldO1xyXG4gICAgICAgIHNldENoZWNrYm94ZXNGcm9tU3RhdGUoZGVzaXJlZFN0YXRlKTtcclxuICAgICAgICBhcHBseVN0YXRlKGRlc2lyZWRTdGF0ZSk7XHJcbiAgICAgIH1cclxuICAgIClcclxuICA7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBjb2xsaXNpb24gPSB7XHJcbiAgZG9tSWQ6ICAgXCJjb2xsaXNpb25TY29wZVwiLFxyXG4gIG9uRW50ZXI6ICgpID0+IGFwcGx5U3RhdGUoZGVzaXJlZFN0YXRlKSxcclxuICBvbkV4aXQ6ICAoKSA9PiBhcHBseVN0YXRlKHsgLi4uYWxsT2ZmU3RhdGUsIGRvbnRWaXM6IHRydWUgfSksXHJcbiAgYXR0YWNoLFxyXG59O1xyXG4iLCJpbXBvcnQgeyBiYXNlNjREZWNvZGUgfSBmcm9tIFwiLi4vLi4vLi4vdG9vbHMvYmFzZTY0XCI7XHJcblxyXG4vLyBUaGFuayB5b3UgSmFzb25cclxuZXhwb3J0IGRlZmF1bHQgYmFzZTY0RGVjb2RlKFwiQVFnTENJUWhuakl3TmpFQUFBQ3BBRXkzQ0FBSkxBQUFJM3ZkQWdBQUFBQUFFQWdFQUFDbjl1Z0FBQmtFQXdBQXh2bkcrN0g0a2ZySTBQbkcvTkR4cHYrOUFBR0YrcjBGQVlYN29BQzlEd0h3RVlYOHNmMlIrc2pRK2ViKzV2dkcvTkR4dlFvQjhCV0YvTEg5a2ZySXhQelE5NWdZWmYyRi9aQUM1djdLRU1HbDkvQW9oZnVwMklYK29BQ0UvWVQ2b2dQR0FiSDlrZnJJMFBubS91Yjd5aER5aXNiN29QaVIrc2pRKzZrY2pmZ0hxVGVGQVV3QUNIaWkvNXJZU0sybUFpa0JTS1dpU0trM2hRRWdoUCtpTHIxR0NaMy96OHJROTZrSGpRRGRxUUNkQU5pZEFObWRBTnFkQU52bzBQR2lIYWtQblMzWXloRDZvZzY5ZFFtZFhOaktFUGVneUtJbnFRSGdCL0FGc0FXcERTeXBCNGlab05pWlFObktFT3VZME9TcERKa3cyc2pBb05ENHFUU0ZBYWtEalNnRHFRaU5LUU9ncGJrUkNKbjJBSWpROTB3VUFRQ1NBQUFBQUFBQUFBQUFBQUFBQUFBQWF6Y0FBQUVJQUJZUEFBQUFBQUFBQUFBQkFnTUVBQVlDQXdRRkJnY0pDd2dNQ2c4SEFRMEhBd3dPQkFZZ0lDQWdjRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUc0Z0lDQWdJQ0FnSUYxUVUwbEVOalFnRmpFdU1TQUNHU0JTRHd3QkRnUWdTQVVTRFFFT0V5RmRJQ0FnSUNBZ0lDQnRRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBZlNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnVGdFTkJTQWdJRG9nUmtsU1UxUWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lFRVZGQWdQRWlBNklFb0JFdzhPSUZBQkJ3VWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JTQlF3RkFSTUZPaUF5TURFMUxUQTVMVEkySUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1RBOEJCQ0FnSURvZ0pERXdNREF0SkRJNVFUY2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRWtPQ1JRZ0lDQTZJQ1F4TURBd0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCUURBRVpJQ0FnT2lBa01UQXdNeUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdVdzhPQnhNZ0lEb2dNU0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUVZTUFRY1RJQ0E2SUZCQlRDd2dPRFU0TUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQkREQThEQ3lBZ09pQWdJRG9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnR3pFZElGTUZEQVVERkNBVER3NEhJQnNySFNCT0JSZ1VJQk1QRGdjZ0lDQWdJQ0FnSUJzdEhTQlFFZ1VXQ1E4VkV5QVREdzRISUJ0RVJVd2RJRUlNQVE0TElCTURFZ1VGRGlBZ0d4OGRJRVlCRXhRZ0JnOFNGd0VTQkNBYlRFOURTeDBnVXdnUEZ5QVNBUk1VQlJJZ0ZBa05CU0FnRzFKVlRpOVRWRTlRSFNCVEZBOFFJQnREVkZKTUswTkNUU3RFUlV3ZElGSUZFd1VVSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnVndVQ0V3a1VCVG9nQ0JRVUVEb3ZMeEFUQ1FRMk5DNFREeFVTQXdVR0R4SUhCUzRPQlJRZ1RJa0lUTElKVEFBUVRBTVFBUUVBQUFBRk56Y0FBQUFiQUFBQUFBQUFBQWdBQVFNRWdBakNDWWdJclNEUVNLMEEzRWlwL1kwQTNLMEIzREFGcVFhTklOQ2xBVWl0RXdpRkFha0FJQWtJYUlVQnFmK05BTnl0QU53cEVQQU1xWCtOQU55dEFkd3BBdEFKN2lEUUlJQUxURUVJYUkwQTNHaU5JTkN0R2RDTkdkQ3REZHhvcUdpcWFFQm9qUllJYUkwVkNHaU5GQWg0MktML21xVUJLUVBRQXFrQkNUU0ZBU0FNQ3FrQThEK3VGQWpvaXFBQW9qREpaSkFQNldUb3lXU3crWTRBQU1paU1OQUh5UXFRRHVrSzZNa0tzUGxJaXBrQUFNaG9DVENaQUFDcEtaa0JBS2tneU1BRGtQYWlCS2t3dkI4SW1la0Z5dEQzamhrSWpob0lqaHNJamg0SUlBRU1yaEVJTUFtOUpBaWRGQVBLRVBldEZ3aWlBSTBSMEk0UzBLMFZDUEFHcVNXaVFOQUVxWldpUW8wRTNJNEYzS3dVQ013TUNKQUNvQUNZU0trQThCdTVBQUNpQUNEdkM3a0FBT2dnN3d1NUFBQ05IQWk1QUFDTkhRaXRFZ2p3SHNBZ2tBS2dINmtBcWpncWtBSXE2SWdRK0QwTkNOQUhxWUdOR3REUUJhbUJqUTNjcVFHTkR0eXRFd2p3QmFrcWpSUURxUytGQUswU0NOQURxVGRZaFFGb3JoWUlvQURLMFBzZ0JnaXRFZ2p3RDYwVENQQUpxVGVGQWRBRG92K2FXQ0JkQ2doNElIOEtJRUVMcVgrTkFOeXRBZHdwSk5BWW92Nk9BTnl0QWR4S3NBMGdEQXFwTjRVQmpRU0FiUHovS0swWENDa1E4QWtnUVF3Z21Rd2djZ3dnZ0F0TXhnbWlBSTRhMEswWjBJMFowS2wvalEzY2pRM2RyUTNjclEzZHFRaU5EdHlORHQyTkQ5eU5EOTJOQk5TTkM5U05FdFNOQk5TTkM5U05FdFNLb2hlZEFOU2RBTlRLRVBlT0dRaXBENDBZMUkwWTFHRHVGZ2l0RXRBUStLNGZDRGpwdzhrZ2tBS2lDSTRXMEswUzBERHNxUWlORnRCZ3J2QUtNQTY5OFFxTkFOeXRBZHc5R1F2d0lhME1DQmhwQThrb2tBS3BKNnE5OFFxTkFOeXRBZHc5R1F2d0I4b1E3NDd3Q21DTzhBcUswQU5NREFySzBBeXRGd2hKRUkwWENJMFIwR0RLMEEydUZBam83QXdJa0JTaUFQQVF5dEFNcmhRSTBBT3VEQWpLVE93S3lvcE1rZ2ovZi83ZjMzOS8vZjM3Ky9mMzcrLzk5L3Y3L2Z2MzkrL3Y3OS92NysvZmYvdjkrL2YzL2Z2My9ZQUJBUWdCQ0FFSUFRZ0JDQUVJQkJBUUJFQWdCQ0FDQkNBRUVJQkFBa0FDSUVCQWdBS0FBaENwLzQwQTNLMEEzS3BOR0FndEdBaU9HQWhLa0EydUZBam83QXdJa0JDaUFQQU1TcEFOcmhRSTBBT3VEQWpLaWt5U0NFcVFBMHdNQ2txUUEweVZDR0N1R1Fnd1llaUtyQlVJMmVzTGtCcWlCTHdmQ0xucEJXa0EzZVlMa0FPcE1DeWlBWm5wQmNyUTZJNFpDS3dWQ0w3dEM2d2NDSmdOSFFqd0srNGFDTkFEN2hzSXpCb0kwQml0SFFqdEd3alFFSTBhQ0kwYkNLMGVDTW1Zc0FQdUhnakswTmdnQVF4Z09qbzJPand5QlFaSVNrcEtTaUQ2QzJncER3a3duUU1HNkdDdEhnaXFLZmdZYVpDTkFOQ3BBQ3FORU5DS0tRZW91VGtNb0JpWi9RYUlpSWpRK0lwS1NrcXFxUWJLRUFLcERwbnYyY2pBRTlEellBQ0F3T0R3K1B6K3JBVFlvZ0M5QmRpZEJOam80QitROWExTDJJMGoySzF6MkkxTDJLSWV2VlRZblZYWXloRDNyU3pZalZUWWpDellZTzZJREsySURFb3BENmk1aVF5aUpaM0IyOG9RK21BQUNRSUVDZ2NOQVEwSENnUUNDUUFBQUtBQThFK2lKcjFJMjUxSjI4b1E5ODRmQ000ZkNCQThxUWFOSHdqdTdReXQ3UXdwQjZxOTdneU5TTnVpQUwxSkI1MUlCK2pnSjVEMXJ0VU00UC9RQ2VpTzBneU0wd3p3OEk1dkIrN1NETkFEN3RNTVlBQUZCUVVERFFFTkEwd21HS0lBSVBnWG9nY2crQmVpRGlENEY2a0FqUlhVcVFDTkZ0U3BBUEF3clZZUTBDYXQyUmp3QnpBRmpWWVEwQnF0NEJqd0J6QUZqVllRMEE2dDV4andCekFGalZZUTBBS3BBSzBkRUFrQWpSZlVxUThKQUkwWTFLNWdHT2pnQmJBRFRIUVNybUVZRUFOTTF4TG80RUR3Qm81aEdFempFS0lBam1FWXJtSVk2T0F6a0JPcC9vMkxHSTJTR0kyWkdLbUFqV0VZVE5jU2ptSVl2WjhtaGZDOTBpYUY4YjAzS0kzR0dMMEZKNFh5dlRnbmhmTzlhaWlOelJpOWF5ZUY5TDJlSjRYMXZaMG9qZFFZdmRFbmhmYTlCQ2lGOTZrQWplc1FqVzRSamZFUmpZVVN6bVFZMEg2aUFLQUFzZkF3SHZBK3lVQ1FBeWsveXNwS2pXUVlrQWpJc2ZDTnJ4aXBnSTJnR0V4T0VRcU5paGdLallrWVNrb3BINDJJR0txOWFCdlFDNDExR0kxMkdLbitqWjhZb2dHcEFZMWtHTWl4OEkyZ0dCQU9LWCtOaGhqSXNmQ05yeGhNVGhHTmhoaU9peGpJRUErWUtYK29wZkFZYVlDRjhKQUM1dkdNNnhET1pSalFmcUlBb0FDeDhqQWU4RDdKUUpBREtUL0t5a3FOWlJpUUNNaXg4bzIyR0ttQWphY1lUTkVSQ28yUkdBcU5rQmhLU2lrZmpZOFlxcjFvRzlBTGpYd1lqWDBZcWY2TnBoaWlBYWtCaldVWXlMSHlqYWNZRUE0cGY0Mk5HTWl4OG8yMkdFelJFWTJOR0k2U0dNZ1FENWdwZjZpbDhoaHBnSVh5a0FMbTg0eHVFYzVtR05CK29nQ2dBTEgwTUI3d1BzbEFrQU1wUDhyS1NvMW1HSkFJeUxIMGpiMFlxWUNOcmhoTVZCSUtqWmdZQ28yWEdFcEtLUitObGhpcXZXZ2IwQXVOZ3hpTmhCaXAvbzJ0R0tJQnFRR05aaGpJc2ZTTnJoZ1FEaWwvalpRWXlMSDBqYjBZVEZRU2paUVlqcGtZeUJBUG1DbC9xS1gwR0dtQWhmU1FBdWIxalBFUnFRQ05ZQmhNMXhLT1lCamdBdkJzNEFIUVdNNWpHTkJUb0FDeDloQUZ5Q2wvRUMvSklMQUp5RXFOYlJpd0lySDJ5VUN3QzhoS0tRK05WQkN3RTdIMktUK05YeENxeXVBQ2tBS2lBbzU0RXNpcEFZMWpHSXlGRXBnUUVDbC9qWVVTcGZZWWFZQ0Y5cEFDNXZlaUFDRGNGYUlISU53Vm9nNGczQlZnb2dBZ2Z4T2lCeUIvRTZJT0lIOFRUUGtTckljWXVjSVpNQVNvdVdVYWpka1lySTRZdWNJWk1BU291V1VhamVBWXJKVVl1Y0laTUFTb3VXVWFqZWNZcVFDaUFPelpHUEFDQ1FIczRCandBZ2tDN09jWThBSUpCSTBkRUdDcEFLeUhHTDdDR1RBRHZtVWFqdGtZOEFJSkFheU9HTDdDR1RBRHZtVWFqdUFZOEFJSkFxeVZHTDdDR1RBRHZtVWFqdWNZOEFJSkJJMGRFR0M5b0JnUUk3MnZHQXFkc2hpcEFKQUNxZitkc3hpOWl4Z1FKRDJmR0oyZkdLa0FuYUFZVE53VnZZc1lFQWs5bnhpZG54aE0zQldvcVFDZHNoandBNmlwQUoyd0dKMnhHTUFCOERHOGh4aTVWUnZ3RDcyR0dCaDl4aGhwUkoyRkdFemNGYjJHR0JoOXhoaWRoUmlvdWRBb25ja1l1VEFwbmNvWVROd1ZuY2NZbmNnWXZZWVlHSDNHR0oyRkdMMklHSjJIR0tuL25aOFl2SWNZdWU0WW5YVVl1UUVablhZWXZYUVlLZjZkQk5TNUZCbWRkQmk1VlJ1ZG5oandJNmk5aFJnWWFVU2RoUmk1bFJvUUJCaDloUmlvdWM4b25ja1l1UzhwbmNvWVRHMFV2SVVZdWRBb25ja1l1VEFwbmNvWXZZa1lFRTY4aHhpNUp4bW9uWm9ZRUNpNU9CbWRteGk1TGhtZG5CZ1FCS24vMEFLcEFKMmRHTGthR2ZBbXVTUVpuWElZblhNWVRNQVV1VG9ablhJWW5YTVlxUUNkbXhpNVdobWRuQmk1YWhtZG5SaTlpaGd3QTB4S0ZieUhHT3h0R05COXVjSVpqV2NZcUJBNXVROGFqV3NZdWRNWmpVOFF1ZmNaU28xV0VKQUx1ZjBaalJnUXFRQ05FeENwQUkxb0dMa0pHbzFxR0xrREdrcU5hUmlRUGU1b0dOQTR1ZFVaalJnUXFRQ05FeENOYUJpNVV4cU5UeEM1WlJxTlZoQzUrUm1OYWhpNTV4bEtqV2tZa0FQdWFCaTVDeHFOYXhpNUhScU5iQmk4aHhpNWV4dWR0QmdRQTB5ckY2a0FuYlVZdVk0YkdHa0JTcDNFR0pBSHVhRWJTcDNIR0xtaEc1M0ZHRXlyRjk2YkdEQUkwRWJJdVRnWjBBaXAvNTJiR0V3bkZoQU5uWm9ZcUxrNEdaMmJHRXlrRloyYkdKaWRtaGk1TGhtZG5CZ1FCS24vMEFLcEFKMmRHTGthR2ZCdHVTUVpuWElZblhNWVRDY1d2WElZR0gyY0dKMXlHTDF6R0gyZEdKMXpHRXduRnJ5YUdEQ1kzcHdZMEJ2ZW5SZ1FGcmw2R1oyY0dMbUtHWjJkR0wyYkdFa0JuWnNZRUNhOW14alFFaGk5Y2hoNVNobWRjaGlRRmY1ekdFd25Gamk5Y2hqNVNobWRjaGl3QTk1ekdMMnlHUEFRR0gyd0dKMndHTDJ6R0gyeEdKMnhHTDIwR1BBSE1GM2V0QmdRV0x5SEdMMjFHTkFldmNjWUdIM0ZHSjNIR0pBRC9zZ1kzc1FZMER5NWpodWR4QmlwQVJBY3ZjY1lPUDNGR0ozSEdMQUQzc2dZM3NRWTBCNjVqaHVkeEJpcEFKMjFHTG0wRy9BT0dIM0ZHSjNGR0pBRnFmK2R4UmpzYlJqd0EweFpGNnhuR0JCWXptc1lNQWpRY2NpNUR4clFDS24valdzWVRGa1hFQTJOWnhpb3VROGFqV3NZVE5nV2pXc1ltSTFuR0xuM0dVcU5WaENRQzduOUdZMFlFS2tBalJNUXFRQ05hQmk1Q1JxTmFoaTVBeHBLaldrWWtGbnVhQmpRVk01ckdOQWJ6bXdZRUJhNUx4cU5heGk1UVJxTmJCaXRhQmhKQVkxb0dCQTByV2dZMEJxdEV4QUorQmh0YVJncEI0MFRFSzBZRUcxcUdJMFlFRXhaRjYwVEVEanRhUmdwQjQwVEVLMFlFTzFxR0kwWUVMeWVHUEF2dVpZYTBBcTU5aHFkbmhpb1RIRVgvcDRZeUxuMUdwMTBHTG1WR2hCb0dIMkZHS2k1enlpZHlSaTVMeW1keWhpOXRCandKcjNKR0JoOXNCaWRjQmk5eWhoOXNSamRzeGp3UzUxeEdHQzl5UmlkY0JpOXloaWRjUmhndmNrWUdIMndHSTF1R0wzS0dIMnhHTjJ6R1BBbGpXOFlyVzRZR0gzSEdKMXdHSzF2R0gzSUdKMXhHR0NvdWM4b25YQVl1UzhwblhFWVlLa0FuYklZWUwxMEdEMmZHSjBFMUwxMUdKMEYxTDEyR0owRzFMMXlHSjBDMUwxekdKMEQxTDF3R0owQTFMMXhHSjBCMUdDcDNxSmRqUVRjamdYY3FRQ2lGSjF3R01vUStvMkZFcWtCaldNWWpXUVlqV1VZaldZWXFmK05ZaGlwUDQxaEdLbitqV0FZcVFXTlh4QmcvZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUdjZ1lBQXdBUENRY1pDQWNBQ2lBSUJUR3dBQmpvbUJtWXFJQ0FDWnI0bUpwcVlha2dnWUdGZ1VFQlFVRkJRUlZCZ1VGQlFVTkJGQUFCQWdNRWdBVUdCNFFJQ1FvTERBME9ody9VeHdqSENBZ0lHQ0JReHdpSUVIZ0lMQUFBQUJjQUFBa0FQd0FBVGdFZ0FENEJBUUZaQVFGWUFUNEJBUXdUTFFFQUFBQUFBQUFBQUFBQUFBQUFBZ0FBV2dFQkFiRUJBVmdCUHdFQkZoTndBUUFBQUFBQUFBQUFBQUFBQUFBQ0FBQUJBUUVBQVFFQUFRRUFnSDhlQUFRSUFKZWxBQTBBRHdBQUFBQUFBQUFCQWh1QUFnS0VBZ0tIZ0FBQkFnTUVCUVlIQ0FrS0N3d05EZzhRRVJRb1dSUVVGQ2dVRkNnVVdSUjRGQlQvL3drSkFBa0pDUWtKQ1FrSkFBa0JDUWdBQUFBQUFBQUFBQUFBQUFBQUFBQUdBQUFBQUJWTEFSVVZGVXNWRlVzVkFSVVVGVzhCQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJXUkFSVVZGWkVWRlpFVkFSVVVGWmNCQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVBEd0FQRHc4UER3OFBEd0FQRHc4UER3OEFBQUFBQUFBQUFBQUFBQUFBQmdBQkFBQU1FaElTRWdBUG1rVWdvS0FBQUFCd0FBQUFBQUNRQUFBQUVCQXdZR2hBQlB2UUJCTEVJZUhrVXpFaWNpTGdDOHZiRUFTU1FkRmhNU0VROEF2Y0RFQUZST1RnQzl3Y1FBcmVYR3diKzhNaTRzS2lrb0p5WWxBTDFMdmIwQVNTNHRIbEViVkFDOXdzVUF2YjI5dlFDOXZjREF4QURKeWNuSnZiMjl2UUM5QUFDQlFRS0JRWUJBUUlDQUVJQVFnQWVGRlJVUmdVRVJFUkVSRVJBYlFVRkJIUUdCQVNOQlFVRWxRWUZBUUVCQlFFQkFRRUJBUUVCQU54VVZGUlE4Z1VGQVFJQkFnRU5CUVVGR1FVRlZRVTFCUVVGQlFVOURRVUZCUVVGQlFWVVVYZ0VFRUJRZElTVXBBQUE1QUQ1R1NrOVZBRjRBQUFBQUFBQUFBQUFBQUFBQUFBQUJBQUFCZ0lBTGdJQ0FnSUFHRDRBWGdJQ0FnSUFKZ0FBQUJnQUFBQUFBQlFjQUJRQUFBQUFBQkFBQUFFMEFBQUFBQUNVUUFGY0FBQUFBQUZ3QUFBQUFBQUFBQUFBQUJBQUFBQUFBQUFBQUFPQVlCT0FZNFNKQzRqemdKT0FZNEIvZ0l1QVk0U1JDNGp4QzRCWUU0QmJoSkVMaVBPQWQ0QllDNENMZ0Z1RXdRdUFYUXVBWUJPQVk0U1JDNGp6Z0pPQVk0Qi9nSXVBWTRTUkM0anhDNEJZRTRCYmhKRUxpUEVMZ0ZnVGdGdUVrUXVBVzRTVGpKRUxrTU9Rd1F1VTc1RERrTU9Na1F1UXc1RERpTUVMa01PUXc0eVJDNWk3bUxrTGxQT1l1NWk3akpFTG1MdVl1NWk1QzVpNUM0eVJDNUREa01FTGxQT1F3NUREakpFTGtNT1F3NURCQzVUemtNT01rUXVZdTVpNUM1VFhtTGtMakpFTG1Ma0xtTGtMbUx1WXVmbjVFNXlSQzZEQkM2RExvTTBMb3RpVUFOd2JvUEFib3ZUZ0FQZ1RvUHdUb1BnVHBQd0xwUGdBNkFETUFNdW8zUXVnMUJPZzNBa0xvT2dUcFBBVHB0aVVBTitrMUZ1Y3JRdWNyNXl2b3RpVUFOK2czNkRNRTZEQUU2RERvTStndzZEZm9NK2d3NnpQb05RUUFPZ1FBUGdib1B3THBQdWsvNlVIcE91ZWtNa0xvdXpJQVBBTG91eklBUEFMb053TG9PdWcxQk9nM0F1azZCdWsxQnVzM0J1czRCdUFVQk9BZzdCaEM0anhDNENBRTRCdmhKRUxpUEVMZ0hRVGdIZUVrUXVJODRCM2dIUUxnR09BWTRUQkM0QnRDNEI4RTRCL2hKRUxpUE9BYjRCOEM0QmpnR09Fa1F1SThRdUFXQk9BVzRTUkM0anhDNEJZRTRDTGhKRUxnRnVFazR5UkM1aXptTEVMbE8rWXM1aXpqSkVMa01PUXc0akJDNUREa01PTWtRdVFwNUNsQzVUemtLZVFwNHlSQzVDbmtLZVExUXVRMVF1TWtRdVF3NURCQzVUemtNT1F3NHlSQzVERGtNT1F3UXVVODVERGpKRUxtTHVZdVF1VTE1aTVDNHlSQzVpNUM1aTVDNWk3bUx1dTNKd0E0R09va1F1czNRdXM0UXVzMzZ6TkM2ekFDUXVzelF1czRRdXM2UXV1NllRQThFa0xxSkVMbkpFTHJQa0xyUDBMclB1czZRdXMxQk9rL0F1aytBdWNrUXVBVUJPQWc3QmhDNGp4QzRDQUU0QnZoSkVMaVBFTGdIUVRnSGVFa1F1STg0QjNnSFFMZ0dPQVk0VEJDNEJ0QzRCZ0U0QmpoSkVMaVBPQWI0QmhDNEJqZ0dPRWtRdUk4NEJiZ0ZnVGdHT0VrUXVJOFF1QVc0Q0xnRnVBVzRTUkM0QmJoSk91M0p3QTRHT29rUXVzM1F1czRRdXMzNnpOQzZ6QUNRdXN6UXVzNFF1czNRdXV1SlFBd0VBMzQ2eTRXNXlSQzV5UkM0QlFFNENEc0dFTGlQRUxnSUFUZ0crRWtRdUk4UXVBZEJPQWQ0U1JDNGp6Z0hlQWRBdUFZNEJqaE1FTGdHMExnR0FUZ0dPRWtRdUk4NEJ2Z0dFTGdHT0FZNFNSQzRqemdGdUFZQk9BWTRTUkM0anhDNEJqZ0grQWs0QmpoSkVMZ0crRWs0eVJDNWl6bUxFTGxPK1lzNWl6akpFTGtNT1F3NGpCQzVERGtNT01rUXVRcDVDbEM1VHprS2VRcDR5UkM1Q25rS2VRMVF1UTFRdU1rUXVRdzVEQkM1VHprTU9RdzR5UkM1RERrTU9Rd1F1VTg1RERqSkVMa01PUXdRdVUxNURCQzR5UkM1eVJDNXlSQzV5VG5KT3UzSndBNEdPb2tRdXMzUXVzNFF1czM2ek5DNnpBQzZ6RHJNK3N3Nnpqck1PczM2elBycmlVQU1CSkM2aVJDNXlSRzRrYmlTT0pENGtiaVFlSkQ0ai9pUE9JLzRqemlPdUk4NXlSQzRCZ0M2Q1RnR09FaTZDZmlQT0FrNEJqZ0grQWk0QmpoSkVMaVBFTGdHQUxvSk9BWTRTVG9KK0k4NEIzZ0ZnTGdJdUFXNFRCQzRCZm9KT0FZQk9BWTRTUkM0anpnSk9BWTRCL2dJdUFZNFNSQzRqeEM0QmdDNkNUZ0dPRWtRdUk4UXVBZ0F1Z2s0Q0RoSkVMZ0crRWs0eVJDNUREa01FTGxPK1F3NUREakpFTGtNT1F3NGpCQzVERGtNT01rUXVRdzVEQkM1VHprTU9RdzR5UkM1aTdtTHVZdVF1WXVRdU1rUXVRdzVEQkM1VHprTU9RdzR5UkM1RERrTU9Rd1F1VTg1RERqSkVMa01PUXdRdVUxNURCQzR5UkM3VEJDN1RCQzdURHRNT2NrUXU0a1F1NG1BQ2NDN2lzT1F1Y2tRdTRrUXU0bUFDY0M3aXdJNWo4Q1F1UThVTzh3SnVja1F1Y2s1eVRuSkVMdUpFTHVKdTRuUXU0ckRrTG5KRUx1SkVMdUp1NG5RdTRzQ09ZL0FrTGtQRkR2TUI3cnVtRUFQQVFBT2diZ0ZBVGdJT3dZUXVJOFF1QWdCT0FiNFNSQzRqeEM0QjBFNEIzaEpFTGlQT0FkNEIwQzRCamdHT0V3UXVBYlF1QVlCT0FZNFNSQzRqemdHK0FZUXVBWTRCamhKRUxpUE9BVzRCZ0U0QmpoSkVMaVBFTGdHT0FmNENUZ0dQQWJCdkFnSHZBZEh2QVlGdkFiQnZBV0hrTHJ0eWNBT0JoRTZ6ZEM2emhDNnpmck0wTHJNQUpDNnpOQzZ6aEM2enBDNjdwaEFEd2M2ejVDNno5QzZ6N3JPa0xyTlE3cnR5Y0FPQmhFNnpkQzZ6aEM2emZyTTBMck1BSkM2ek5DNnpoQzZ6cEM2N3BoQUR3YzZ6NUM2ejlDNno3ck9rTHJOUVRwUHdMcFBnTG5KRUx3SUI3d0hSN3dHQjd3R3g1QzY3Y25BRGdjNnpkQzZ6aEM2emZyTTBMck1BSkM2ek5DNnpoQzZ6ZEM2NjRsQURBUURmanJMaHpydHljQU9CanFKRUxyTjBMck9FTHJOK3N6UXVzd0FrTHJNMExyT0VMck4wTHJyaVVBTUJBTitPc3VGdWNrUXVja1F2QWdIdkFkSHZBWU5rVG5KQUpDNjdjbkFEZ2M2emRDNnpoQzZ6ZnJNMExyTUFKQzZ6TkM2emhDNnpkQzY2NGxBREFhNFNSRzRTUkc0U1JDNFNUaEpPRWtBdUVrNFNUcnR5Y0FPQmpxSkVMck4wTHJPRUxyTitzelF1c3dBa0xyTTBMck9FTHJOMExycmlVQU1CeFk2NzFuQUQvclBRTHJ0eWNBT0JqcUpFTHJOMExyT0VMck4rc3pRdXN3QWtMck0rc3c2empyTU9zNjZ6RHJ1bUVBUEJKQzZpUkM1eVJDNno1QzZ6OUM2ejdyT2tMck5RVHBQd0xyTndJQU9nTHh2WE1BUHdMeHZYTUFQd0x4dlhNQVB3VHhPdkU5QUQveFF2RkI4VDN4eEg4QVJnTHhTUVR4eVg4QVN3VHhUdkZMOFZBQVMvRk9BRXZ4MEg4QVVnTHhVUVFBVUFUeFRnUUFTd0x4U1VMeHhIOEFSdkZKOFVVRUFFUUU4VUlFQUVRQzhVVUM4VWJ4U2ZGTDhVbnhTL0ZHOFVYeFJFTHh3bjhBUkVMeFJ2Rko4VXZ4U1FCT0F2Rk5RdkZHQUVueFJBQkM4VVJDOFVMeFJBTHhSUEZDOFVUeFJnSUFQd0x4UGZFL0FEb0FPUUE0QXZFMjhUanhPZ0EyQURnQzhUb0FOZ0E0QXZFNjhUMEFPQUx4T3ZFOThUanhQZkUvOFVMeFJQRkY4Y1IvQUVZTTZqeEM2amRDNmpqcU5VVG5KRUx4UlFJQVJBQkNBa0x4UlFJQVJBQkNRdkZFQUVieFNmSEVmd0JHRE9vM1F1b3dRdW84NmpkRTV5UkM4VWxDOFV2eFJ2RkY4VVFBUWtMeFJBQS82akFHOGNKL0FFUU02anhDNmpkQzZqanFOVVRuSkVMeFJBSUFRZ0EvQWtMeE9nSUFQUUE0UXZFNkFEWUFPUEd4T1FBekRPbzNRdW93UXVvODZqZEU4Uzd4TWZFejhUSHhNL0UyOFRQeE52RTQ4VGJ4T1BFNThUcnhPUEU2OFQzb0lBTHlSa2J5UmtMb0lBTHlSdkpHUlBKR1F1Z3BBdkpHUnZKR1F1Z3A4a2J5UmtMeVJrTHlSdkpHNkNRQzhrWkc4a1pDNkNUeVJ2SkdRdW9rUXVja1F1Z25BdkpHUnZKR1F1Z21BdkpHUXZKRzhrYm5KRUxvSUFMeVJrYnlSa0xvSUFMeVJ2SkdSUEpHUXVncEF2SkdSdkpHUXVncDhrYnlSa0x5UmtMeVJ2Skc2Q1FDOGtaRzhrWkM2Q1R5UnZKR1F1b2tRdWNrUXVnbkF2SkdSdkpHUXVncEF2SkdRdkpHOGtibkpFTG9JQUx5UmtieVJrTG9JQUx5UnZKR1JQSkdRdWdwQXZKR1J2SkdRdWdwOGtieVJrTHlSa0x5UnZKRzZDUUM4a1pHOGtaQzZDVHlSdkpHUXVva1F1Y2tRdWdrQXZKR1J2SkdRdWdrQXZKR1F2Skc4a2JuSkVMZ0d3VGdHK3dZUXVJODRCN2dHd1RnRytFazRCN2dJT0FlNEJzRTRCdmhKRUxpUE9BZDRCNEM0QnZnRytFd1F1QVpRdUFiQk9BYjRTUkM0anpnRytBYkF1QWI0QnZoSk9BZTRDRGdHZUFiQk9BYjRTUkM0anpnSXVBYkJPQWI0U1JDNEJiaEpQQWJQajRDNkNjQzhrWkc4a1pDNkNjQzhrYnlSa1R5UmtMb0p3THlSa2J5UmtMb0ovSkc4a1pDOGtaQzhrYnlSdWduQXZKR1J2SkdRdWduOGtieVJrTHFKRUxuSkVMb0p3THlSa2J5UmtMb0p3THlSa0x5UnZKR1JINStSTUEvZ3plRE1ZTXRneW1ESjRNbGhpT0lJWmZIeDhmSE8wdzc0Y2ZITzB3NzRmNysvdjQ3VERzNGx4YVhmanRNT3pqSHg4Zkh4OGZIeHp0TU96ZzdURHM0eXNxWW1KZ2JHeHNiSFI0ZEhoc2JIUjRkSGg4Zkh4OGRIaDBoSVNJaEloMGVIU0ViR3hzYkd4c2JHeDBlSFNFZEhoMGhKU1VjSEJ3ckt5c3JtcHFhUkNzcm1wcWFSRzF0YlcyYW1wcEVwaUttaTVxYW1rUXJLeXNyUkVSRVJKcWFta1NhbXBwRUx5OHZMNWdjSEJ3Y0hSMGRIeHdjSFIwZEh5QWdJQ0FkSFIwZklTSWhJaDBkSFI4Y0hCd2NIeDhmSHgwZEhSOGRIUjBmSmlZbUpoeVltSnZsQjY4SHNadmxCNjhIc2RyYTJnZ0hyd2V4Mmt6YXhBZXY5TEdiNVR5Z0ZXa1ZhUWV2OUxIRkhNVnpORFEwTklrY0hCd2NIaDRlSHh3Y0hoNGVIeUFnSUNFZUhoNGZJU0loSWg0ZUloOGNIQ01qSkNRa0pCNGVJaDhrSlNRbEppWW1KaWFNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJMG1KaVltSmlZbUppWW1KaVltSmlZbUppWW1KaVltSmlZbUppWW1KaVltSmlZbUppWW1KaVltSmlZbUppWW1KaVltSmlZQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFNREF3TURBd01EQXdNREF3TURBd01EQXdNREFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU1EQXdNREF3TURBd01EQXdNREF3TURBd01EQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTURBd01EQXdBQUFBQUFBQU1EQXdNREF3TURBQUFBQUFBV0p6aExYbk9Kb2JyVThBMHRUbkdXdmVjVFFuU280QnRhbk9Jc2U4OG5oZWhSd1RlME9NUlo5NTVQQ3RDamdtNW9jWW16N2p5ZUZLRkdCTnpRNGhObTNYZzhLVU9NQ0xpaHhDZk51dkY0VTRjWkVIRkNpVStiZE9Md3BnNHpJUDhCQVFFQkFRRUJBUUVCQVFJQ0FnSUNBZ0lEQXdNREF3UUVCQVFGQlFVR0JnWUhCd2dJQ1FrS0Nnc01EUTBPRHhBUkVoTVVGUmNZR2hzZEh5QWlKQ2NwS3k0eE5EYzZQa0ZGU1U1U1YxeGlhRzUxZklPTGs1eWxyN25FME4zcStQOTRJQUFRcVhITkV0RFErODRnMENBREVPNGcwRXlVS1E9PVwiKTtcclxuIiwiaW1wb3J0IHsgYmFzZTY0RGVjb2RlIH0gZnJvbSBcIi4uLy4uLy4uL3Rvb2xzL2Jhc2U2NFwiO1xyXG5cclxuLypcclxuaHR0cDovL3d3dy5sbGFtYXNvZnRhcmNoaXZlLm9yZy9vbGRzaXRlL2xsYW1hc29mdC9yZWFkbWUudHh0XHJcbihhcyBhdCAyMDIwLTA1LTE1LCAyMDo0MCBQRFQpXHJcblxyXG5MTEFNQVNPRlQgR0FNRVMgRk9SIEVNVUxBVE9SIFVTRVxyXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuVGhlc2UgZ2FtZSBpbWFnZXMgbWF5IGJlIGRpc3RyaWJ1dGVkIGZyZWUgb2YgY2hhcmdlIHRvIGFueW9uZVxyXG53aG8gd2FudHMgdG8gdXNlIHRoZW0gb24gZW11bGF0b3JzLiAgUGxlYXNlIGZlZWwgZnJlZVxyXG50byBjYXJyeSB0aGVtIG9uIGVtdWxhdG9yIHNpdGVzIG9yIHdoYXRldmVyLiAgTGxhbWFzb2Z0XHJcbmZlZWxzIHRoYXQgc29mdHdhcmUgb2xkIGVub3VnaCB0byBiZSBydW5uaW5nIG9uIGVtdWxhdG9yc1xyXG5pcyBub3QgZ29pbmcgdG8gYmUgZXhhY3RseSBnZW5lcmF0aW5nIGEgaHVnZSBhbW91bnQgb2ZcclxucmV2ZW51ZSwgYW5kIGFzIHN1Y2ggdGhlIGltYWdlcyBhcmUgY29uc2lkZXJlZCBieSBMbGFtYXNvZnRcclxudG8gYmUgaW4gdGhlIHB1YmxpYyBkb21haW4sIGFuZCB0aGVyZSB3aWxsIGJlICpubyogbGVnYWxcclxuaGFzc2xlcyBpZiB5b3VyIHNpdGUgY2FycmllcyB0aGUgaW1hZ2VzLlxyXG5cclxuRW5qb3khXHJcblxyXG5cXFxyXG4oOi0pIC0gWSBhIEsgIDEvMTIvOTZcclxuLyBcclxuKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGJhc2U2NERlY29kZShcIkFRZ1RDSm9DbmpJd09EQWdVME5KSURZMk5nQUFBT3JxNnVycTZ1cnE2dXJxNnVycTZ1cnE2dXJxNnVycTZ1cnE2dXJxNnVycTZ1cnE2dXJxNnVycTZ1cnE2dXFwQUkwZzBLa0xqUkhRZUtrMGhRR2kwcjJGQ0ozNUFPQnpzQWE5VndtZE13UEswTzNLbXFBQXh2M09kQWl4L0puLy80alErS2I5NEFqUTdZWXV5SVF0VEFBQjhBVGxNK1RWb2dNZ05BUHdNOGtIMEJhaUFTQTBBOUFLb2dRZ05BTVlhUWNRQmFJS0lEUURoZmVsOW9YNHBmNkYvS1gvaGYwZ2F3T2wvWVgvcGZ5Ri9xSUNJRFFEU3JBMzBCNmlDQ0EwQTZBQ2hQZUY5VGlsTGVYMWhmeWxMdVgyaGYwZ2FRTk1BQUhvSURRRDhBbWlDQ0EwQTZBRDBOcWlEaUEwQTB4dEFkQXBvQVNFK2VnZ05BUFFDYUlRSURRRHBQblF2ZWdnTkFQUUNLSU1JRFFEVElvQm9nZ2dOQU5NaWdIb0lEUUQwQXJvSURRREdHa0ZxTkRKNkNBMEE5QUw2S0lDSURRREdHa0gwT3lpQ0NBMEE5RGxxUUNGOXFUNzhBd0craW9tOXNiN3l0RHlxR0JJc2Y2Ritxa0loZnRvNXY3UTV1Yi8wT0xtQWFrYmpSSFFxVGVGQVZoTUVBaUcrS0FBeFBqUUNLVDMwQVRtTHViOXh2aUlzZnlSTFpqUStLWDRNQWpRN0tUMzBPam1MaGlsTFdYM2tBUG1MaGlGTGFYOFpmZUYvSkFDNXYxZ0NvRU9DSm9DbmlBb01qQTJOQ2tBQUFCNHFUU0ZBYUlGdlVJSW5TMEF5aEQzbXFBQXhqTE9MQWl4TVpuZVVNalErS1V5eVFqUTdibElDRHlCQWVqM1RBYmpBUWdreUJWQnNTOHFLZ0M0Z0NrSHFyMGFBWTBZQWY4R0FTa2ZxaUFpQVV6L0FhUkRxM2xZT3o4cDVpL1FBdVl3WUtGRjVaRXQ1aTBPNXk3SzBQWHd4YWtBOE8rcC85RHJCb0F1TnlVY1k2Qm92dkNvSUhFQklabHdnOFk1RVBFd2o0WTVDS3BNR1JTRWVKNXlLU0hwczVRczJnR3BOOURoV0NCWnBreXVwK0FhZUZ6dXFRTXNxUWlGLzgyWXlNVC9QTWNZcFMxbC80VXRwUzVwQUlVdVlBN0k1U1JvTDVNdnBUQ2lSakNpTTdrQTc3RGUvODRBenR3Qnp0OEJyUS9Cb01uZjBPcGdZQ29oQ0FvQW5qSXhOREE2anlCSVQxWkZVaUJDR0RnL0dFOUxWQ2M0TXdBc0NCUkI0TUF6TWpjMk9LTWtPVEUxTXFUckZDOVFVazlIVWtGTlRVVlBBVWhWVEZDUUVmQUtqeUxrRkNFeTUxM2pTYWtKalhNSXFXQ05kZ2lnUUtJQXZRQUpuUUJnNk1IdUJVanVKOHlJME81Z0F2d0N5WVhRSWFrVEZEQVNxYUNodVJLZ0VFRVRDZ3VnbEFCVWd1NWh5am1BNHdKZ0llOFE3d1Nud2ZjaDM0SUFCU0QvUUVDQTk4Z0FBc3Ewa085QzdRQkNHS0l2dWhJOUJaa2lWazlQVWxOVVZVc2lvMkZFTUVjWVJrSWlBRGtUeXdDREloM2NSamd5TURNNFFUSkJPVEF3T0FNYkF5Z0RLUU1yQXpBR0tRSUlnQ3VEckVIMUpnWWZoZ3pGaUFZVnpQQURIUXdrQmpBRU1BSXZCaTBCRUFUQUFJS2FTZ1FvQWlZSUtSTUdKQVNoUkFRS0lDaEJEZ3FIbFdWQVpIc3FEQ3VEQ2lTR0xRTERLbDBRSmdOTW5DTUNFZ01oQkI4Q0FLSWhLdER5blZDQ0lRQzZIaTJVQTNoUm9Ya0JuQUlBVTNBNEJqVUdPUVEzQWlVMUJEUUNNcUNBRWpRM1lORXlvalFETUF3d1F0UUI0b2lRTDBpQUxrUURBakF0RVlHNkVTanJIRjVnbENXT2d3UVk0WVVNVnZIaGNLMkFDSE9NRHd5RjFBY0FSQWJvSDgwQzRTQUNZSUNFa0FsWWdDYkFyeUFNTWZDcmdkWUhIYm9COE1oWFRTNi9EbXdjd0lBc1FBd01KMk9QMUZHQVhQQUc4UERTWVZvRUdtQkZFQlRnZHhjakNoWDJPQ01ESVFOZ29VTnc1UVlmQWZCQkhBTlhRQmdCL3dRWUFob0VIQUlZQmgwR0hpd0RSaEFrQWhZWUlncUJJSURER2g0c1FoeGpCT1NaSUFVTkpnUWdJZkFJaDRaaGdnTUFBNElhSEJBUXFJZ2RnRWdVc0hqdWtjSUtIUUljQ2hvQ0d3WUFpRGtDQkNLQkNEQWdBaC9LUGdNZEF4OVFGSVVtNENrQ0tBb21BaWVBa0tnckVBb2FCQzZBL0Jnc0NIa3FZVjBRR1ZNdkFhVVFKcUFERHVGWERDOGppR2ZHYVVJQ0ZEZWVIazJUSVBCQ0hHK2l0MkJVdFFCZ2V6QnUyd3daREJzTXBpQXFwaGdDcmlBcllCZ0FJQ3ZGSU9BVERCZ0I4QVFZZjNHWllEWExGNWtLbm80VkJGRkZCMy9Pd21CMExETXNBSkEyTEFWQU9Td2tSamJETWM0ZnlnQUZaTVE3SUM1Q1dWUkZJT05NTUN3eEJUUTBHQUNoeW9BUUFMNWdOeXd5TUR4bTI3R3gyMlk4R0NlWWZzek16Z0Q4Wm1aOHhzejRBQS9oWU1EQXhud0ErR3dFUTRnUS9rQ0NlQWYrTUliandDbmtCRzRZNDNnQTQyWWhmdVBNSkFBUVlCampNQ01oMng3akRDM1kySEFBNW14NGNOak14Z0RnNDJBMVRnQlJnWGQvYThiR3g0aDJmbjdPQklEQUJ5Z296RUFadUFGQWdqb0FDQlE4NWdZZ0tjQjJCVHdHWUFDNktzV2g1R1lrekhiUUNyRXJ4bXlzQVR3NVkyTnIzOWZqQU1iY2tHNGdCc0xBa0RpNmpXWU1HRERtMEZkWFgxOEVvT1JmS2xkVlZ6MS9YL1gxMWRYay9TTFY5ZVA5S2d2d1lBQVFNSDkvTUJDcEp3d2NIRGd3QUdDaUp2OGNObVBCL3dnZy9rTml3UDRDR2Z3Y05QNUEvSUw0SndBaTBQaWlLL0FRaVBBQU1IZ0lVS1VtNEFBZ040amdvaUhBb2lOQXdNQUlvWUNqSW9DQVlDQUJ0QUJFcFNSSWdKYlFveUYrcUNPZG9tQldBd1lNVVUwQXBpOTJoaTB3QTlVdy9CQUF3TFZCd2cwYzZBUXJZR3hzcCtEQ2RHQjhCa0FEQWdMUUtZQjlJUENBRUJBUmdVUURoQ0ErRENBTUlGd0FHYVNneUNvWUlEUU9qd1l3R0E2akkzNFdvekZ3R0F5NkduQldLRGdjZXNMLy9PUE1Lcy9Nd00vZC9QenN6UHltS3VDMDNNd0dGOXdNbEQ5Z3o5eGRnY2RnUDVEd0dJemNDNERzakJqd1lmd2JPS3JzZkh4dk16QWZwaUVFSnRqNCtDMkw0Smd4eCsvd1NPN1hZTXljM0R5aStPWVcvYy9BMi82dmlxbkFKUGdNRFB5b0llN0UzU3JnNmVQRHc4bk0vd1dRd0hDK0FUTWpWN0drSTVpYXU4TjU0TVNxdytQOUlWWGozeXRWVVZWRlZWUlZWUlNxcXVTODQ3QUZPQUNrNUF2QVB1TU9JZ0lDS0FMWTQ0QWlOcWpuZ0VrQ2NKUUNNd0wwaVpXVjVlWDUrZjcrVmxaYlcyOXZ2NzhFcWtvQ2QzSENyTXNuQUQ4ek0vTUEvNmdrLzlzZEcrTVlKUjRod2dzUDVBd3MvSHljYWdBd21RODhZTkR3NURBb1B6NDVOejVoOEhLRXVOZ1VjQUF4ZUgvMy9YL2RwdCtFRVA4VUFIYkNJZjNDT1lSMGo2cSsvOWZYLzc2cXE3cXFydXF1cXJyY0FHcHFXbHJrVmk0b0FrUEZ3S1dscWFramlPaFZLYSt2djYrcnI0N2grdVArSlBycS92b3N1QUFpcisvRUl2dTZudjRwUlVRZ1UxbE5RazlNNVNvd1JGVlFURWxEUVZSRnNUY3ZTVTBJS0RCUWhLQUMya05QUkVYbUpNSk9Wa0ZnRzNBQ1FVUkVVa1ZUVTFoZ1RTNUJJRTBkQWJST1QxUWdCeGhNVDFlclF5b3FVa0ZPWEVaR0lFVk9SQVFBSEFybVVvclJURUZDUlV4NGdWU2tWQzRoUlRsVERCWXRXdUt3VkU5UElEdGtUa2ZuUVU0QnlDMlFoRkJJSkZWTlBZSklFUlF4Ums5U1Z6VUNVQnpJUmlRRk5rTkY1RHdTa0N3T3BGaDdRbFZUYVVJZmlGak9DblpaS2tNYklTZFUyQlNnVXdEcFVIbzBTVThrQUtnSElDOFh0UUpFU1hSRFZFbFdSWTBsUWhnU1NFaHNubFZVaEFHZ2ZCUlVtRWtLUlVlZUMrb0JJQnNDWFFKWlVNQTZHNXVPTXNBM0drK2p4MEVzV0N4WkxGTXNVQ0JaUUZwRlZ0TGpTak1sVUVOa1ZCRHNTUzB0eGtCandEQXFUVUZEVWs4bGc2Q1VUTzFHVlV5RnNHWW1JQ0ZBQnpsTGlZdklQQzhUQmRwTlVCNkJ5SGN5RkJzSkVBRkpVL1NEVk9QQ0xnc0JtaE5YU1ZSSUJpQ0dDQWtCTGdIRnJBU3BUUjVCcEFpUzUwU2NOTTZGakFLQVlWc0h3MFZGVURlRGhSTk5YNGhaSUNnK09Ta2dVRUhqOFZKTlV5cjVJdzRrSXlRNEpFMGtvakJpSkhja2pDU2hKTFlreXlUZ0pQVWtwR0FmQ2lVZkpUUWxTU1ZlSlhNbGlDV2RKYklseHlYY0pmRWxCaVlCQ21Ub0VLTmhvd01uaEFTR0JhMS9DQ2tROEFOTUVTZUZBWFdBMEVjcy9LQndNNklDN0RrSThBc2d6UDlSamdLNlFTREcveURQLzZhUThCV29paWxBMEFtQUNIVzUvaWRNclNlcEFJMUxDSmlrQktZRllLSURtZGh6TUNkMVVJVW1JRFFuMEFZZ1FDMU1ZeWJKUDlEZC9ubzQ2VEFneml5Z0FMRVFqWTBKeUF6QWpna05sdEFrcFFWaGVnbWxFWTE3WEpCTG9BdUFoUkN0ZXlrUkNraXRQV2lSRU1pdGpqQ3poQWtuQUNnRXhSOEFrS1BtN3AyZ0ErNG9Pb0xRbjN2RDcwZ0ZiazZ0aDBaY2lJeTVoeG1Jekl4WitQNkpDYjBCOEFISk90QUlxVENkT3NyUTdxMTRDY1dnclhrWU9rSzVpU0I0RGZFcHlNQUVrUFZ4UXJuTllLa05oZ1dFQkVnc2N3Z1FISzNGeVFTd2lKWUVFUjRqeWY5b1NDRFMvNjV5ejRZRElCYm5hRXluSm81QXFRRWd3eFM0QkNrRm9LaXRkSUVCWEpFcHFRWnhJd2RCUlNUbVRIRW9JT0gvOEFGZ0lHMExlS0lDQW9ZRkRtR0Z4bGdnNVA4SkFQRDV5VUx3QWNCZkMyQlhRRHZHQWdDb0FDSUNxcUloWEFHUVZBeFFNbEFCa1B3UGpLdWlKLy8xQUtyMEFQOE1BUFFvODhBQUFQaUVBOFBBQWdQQThDb1BVQUhmUEFxQUt0RW16NkFwOHdBREJnUGdJSXArZ3c4cDVEd0FJb0RvZVQ1OUE4R2lMZi9RQVpDL0RJNjg2Q0FQRkdJOG9pTW84cHo0aHlvTUF2L3dQd0FZek8wQkp2RG5xTXB6NFZBUk1qLzRBREJaRVBBTWdQNWtPRDJnSU5HN0lhRHdvR1FvQTBJS29qR0F6RFNBS1h6Z0dnSkFBQm9uVUFCV1ZBRlZWYjdnbytLU2djMEVvQUNFQUF1QU1TZ0FBVm9GbEFEWWxRQVZCZ0l5UUU2UUNtUlFNaW9Ma0Fmd0F3ZzdRQ0lsUUVBYTBBc2dESGN3QmdFQllBR0ljQVpCQW1jOEx2QmlCQVVCUUFQQVg4UUZCRlBESmRaNmVEN1BRQ296TnlBSXVRd0RCQW5aVVEzd1VBWUhRRmtyUEF2b0V4ZWdLb2ZucHpiRWM5TlFReFdnQXhQQm9RSVBQZ0Frb0lDZ1B5TXFBQS9PRHppSjdxS0RET3ZkQXlId05VRGdLa21BQU1BZUIxSGp1NkNndzNCakFrVGRNd0EvcncvY1FBYzBBY0FFa0VEMWdLSWhZR0tCb2RpaVlBQm13SUdLQmdMUUQzR0FJWDhDLzhEZlB2K0FIMmdPZndNRGZRd0JnQnNEQVBtNEJzQVpoc0F4ak1BOHp1RFJwYytJV0FaemNBa200SFRnY0FFQ0RrMy9SaFRvdVNUWkFnMnRIaThIZ0RZRDRRMkFaaG1BOTczQXAwUXdMaFFNZ0N4bU9KNkhPa1FsNEtnT1JYWlpIeW03RHJPeUF3a0FEUUFiQjhBTklCd1k3M1VibkE4WTNVMEhPZ1ZnSzhGWjFJWmdNTXd3ZU80YzBha21BY09BQStmQURrSC80Q1lEcEFCZ0N5RUJnU0ppbURCK0xJQUI4dkVZc3lUVXFxcWdBb0lJSUNPRU1DR3FCU1NBcXN3Q1lLb0dWS0FGV3RQR29qRC9BTTVRRC8vd1AvLzhEcXF3RHJZQ0VWRFZJNElEQWdDWGhyQUNEcW13SVE0RWpLQWlxalJTVHdaQUlkR0FRUCt2SWdGVUJBQUZWYUVEQnZrQUpRWlpBQUpZQlVJSWZDR2dBRDFRb0FTekkwVFFBd0E4Z3FFRll3QkxxTFBCcnlVQkZjSXFwUVZBaC9VbVFBUVFRRGlDdG9RbUJnSTZhcWdKWFYvQ0pRZ09LQXh3SUJFdUJCTExEQUF3WUFHb3JBTWNtU2loQUFNVVJCdExBcmZHTWxNcFFnYmloN25HTWpNbFFnQU9RQUwyQUNFSU5wRzFOQW9FQTdnQ3lPTWZQQzlvUTV6bENBSUE0Z0txczdnb0VSNDlrcEcyU1ZHaUp3SGorVDhvc3pRQ2dBSityUUo2b0FBS0JrQzZOYjZ0QkFCT3VNRXdLR0FFZzR3UEdNWVFBdm9HZC80WVZMSWtZMUY2QXErQUNpcWlyZ1dhcmk1NXVjWEFHak1YSGkrTGdOU0FlbUhGeTZva0dJSjhpZ2ZBSDZJd1Z4QUNWZ0h4bHFvd0RxcndQcXJBTTZ0TUU4QW12VFhBQ0pHdEdDRVFvaWhVQUNJaEFCQUpTRDVHeENJUXF4V3BJbk9GSXlFMVdkQUE0TlFBTWxZR3Fhb0E4S2lFQUVHZ01BQVBKaEFoRUJ6QWdsMm5zRUVLTnhBUExRQXdyM2s1QWhUNG5UQWhBd0xRRUFNaHdDeldJL0txTjhBbHFBQVNqRHRKSlFoRm1TU2lBS0J2dHNHbWpja0FNQkNBQTF5b01QWUFQQlh5QUNVUUh3QmpuMHdPb0tCUUlRY2VJWERBNXVpd0FMNFp0QlQ0TnJmZ0FyL2dBTEJDSVpJWEtEU3RDRkZRb2NPTVVRUWtzTWl3QWdSQXRDSWdBa0I0T01XTXdCSkVPVkU5Z3dZT01xSXNEd3FhS3BnV1FMZzR5dEVtd09RQU5SK3U0YmxRZ2ZTQlJZaS9hQ0p5QW12NEFBZnNQQzhwRUJSZ0xJNjM0WklKbUdnUmNXaWc0b2FPc1pFR2hRK2lIM3hkRU9pRUpVc2dBUmtDRmNnQXNEcktEUDBRQUFVRnNJUzh3WHdsQkFUVVVHR1lTYmlDRG96RlNENEdkdmdWQUdxUllLWjRnS1FoMGFaZ1FEa3kvaENRZklSQkZBMzZHQm1ObWlBR1BFc3dBVGs1Q2MwNjdobVlFTHdrODN1WUVBZ00wd1lBQVlnZDJReWlRM01CbWVHNnJHTjVZT0pEd3ZVVHNFd0daNE9zd0ZpaFMwWmhKRHRqSS93WThPekJ3U1BSQWRuT1FQUEFJQ0VRQUh2Qm5NTTRnQUFNaXllWkFBeDRic1hPc3lHRW9qQ0lRQUgrWUFmLytCa0RFQ0F3RGlxQUxBbGVlQWpHQ0E4d1FERmlBQVp3Z3dDRWdDa0FOeEFRaGdnSWNMTkFHVE03QVkyYWh2SFFnQ29BTXlFQkFoRUNCbi9NSC8vd0F6SEFBaURmZ0JHQUxRQXZFSUFYSUFDSnhnWEwrWXVIR09DQUtBQTZCQ0FBRWdnQzNpaWdCb2pnREVIWW5JUUFJSUlBUUNZb1ZRQXJLVDhCUjdOTXRMeGhYRUpsdm5BQWhRMkZES2tGaFE2cEJvVURwaXZDWUFxRkFyM0VuWVVGcGcycEI0VVB2UUZNaFFTR0NTQkpnS1lKNk9ZQ3hnL1E3YVVDR0drRmxRU3BBWXVwQThWeUtJWU5wUU1TRVFJL2l1WU14Zzd3QTB3T2ZKYXdIS2tJdFZBZ2lMQTQ0Q0JZaG9qUStuTlQwUGJHRGREeVBwZm5ZS1V0eVFId0RPWWNwUnpKQTlBRU1LSWdIb3FwRXlLcERkMnpnS0lBdmRXZXBCelA0TkFEdmQrZUtUL3JkUU9uVmVqZ0N0RGlZRTFGUjBFZ0lFMVBWMFZTQitKQlRrbEJRMU9pK0pvREM0ZWZnQkFJNEVNWGVBZkxHbjNDOCtBdmlpUnpRQklkYWQyZ0p0RFhUR1o5VlZORklFWXhMRE1zTlNCVVR5QnZHRlFnVmtGTVZVVlRMaTR1Y3pjVDdsUkJVbFJGVGxSU1dTQk1RVmRPT2lBeDR5QXFVQUxKV1FKelV3MUJZSDRiU1VOTGNONENwY1hKUU5BT29qVmZXWUtueXREM1dIaEF5UVRRRXU0VkJxMDJ5VG5RVUtBeGpTVUNUR3pHQllzUUlsaUNJc2N6TVdNaW1MRUdvc1F1Rmp3dTRzVXV4WVFFck5QNStqanBNSVVoR0l6Q0NDMUdNd2pqSGt4OGdzVzl3YUpnWTRDYzBBQmtuUUFnR0lCbHhDRUdJR1l4SWdHSVp3eEFJMkpvQXhBa0dJQnB4Q1VHSUdveEpnR0lhdzNISitqUXphQUFxV3lGQ0FJZFFnZXBZUXFoSE5RSnNRZVJDZVlIMEFMbUNPWUpHZDBLcFFvdkJ5bnFxWUNOa1FKZ2daenFKZ0RxNmlBQWZ1WHFZYmhNLzRHcEJJVkpxVWdmT01DbFNKMUFBNlZKbldBRHBoaHBLQW1BTVFOcEFMeUE2T0FiME9SZ3BnT2tBcjM0QlVpOVBnRk9hbUFnTklDeFNHQ2xBc2tvRVBrWTZhVUVrWEFOU05RMndhVUZrWkVCdnlRZzhRUUF5QVVHUUFZNEI4clE3d3B3V0M5NHFjQ05GQU9PSnhVRFRJYUFxYitOR0ExVkdRUC9nQzlZcVlHTkd0QUt3STBTMEswUjBEVFVLWCtOQWdVYU1Cb3JyZ0FRaFJHZ0Fha1B3NVRVSUpXSllFQ3RHZEFwQWRCRVhESHE1Z015MFZDQU1pb3FUT0lrRGhwaitNWVEwUG1sRVQvanBTL3dEc1l2MEFxaUtMTGtSNDRRTFJvWDBEaWxFOFgwN3hPbEZEY2dGS0FBakFUVXNST0ZGOGdMd01udzhCdXF2WVFud0FEVXZjSVpWZ0hVY0E2b3BWOE9jU0doSk1abWJxT2xGWGpwRmFVVzRSWVBJYkVWakF2NGdCbklnVThyaHNuLzBBZmRQRXptZ05IT0Iyam5DSjBJQlVLTStRUVlPRnA5bzh6MkkxT0d1L1F3Y0xUN1I1anRSNmNNZCtsaDRXajNqekRhajA0WTc5TER3OUh2SDJDMUhwd3gzNldIaHFMZlBzRnJQRGxqdmtzUERPY0M1UVBrQk9NRklnWUc0d2RoUndnSUNRa0tDd3NNRFE0T0R4QVJFaE1WRmhjWkdod2RIeUVqSlNjcUxDOHlOVGc3UDBNZ0RZQWd6SjBnZG9DcENZMEYxSTBNYXpjNWpSUGJJQmRwQmdESURRYVlGTlR6UWVHdVQ0MFJUNFVkRkY5TW9KK2laQmZhR3d3b29tUVQ5Y2VwWUlVVXFXSzRCb0hHSUMwcS9HQ0NzUHVwTW14bU1rSXVFT09qY3hHNTZBbk1ZQWJnQVlCVUF2QjFaaUJuaGdhTjJlQ2xJWTBDRWNNU1QweHloaUJpZ0dONVFDRFFqU0hRcVJpTkdOQ2lBUEdTS0JZRFFWNFl2UTJESVAyQ3FRVWcrUWFpVTFnZy80SXhjalhpNjcxZE1HT0ZtUmtXZ2hNWHJRb01oQnhaS05DK0lEYUNUTldESWtFSFpEaGdCK1lERUNSNklDQk1URUZOUVZOUFJsUWdVRkpGVTRPcVUrTUlZY0JLUlVaR0lFMUpCM2d3UlZJblUrUWdZQ1ZOVlZOSlEwRk1JRUZTVWtGT1IwVk41VEFnUWxrZ0tnSDREY0NOeFVsVFRrVlo1aUErUjBQRlNtQlBSMUpJQW8xRUl4NFpwaEhvS09ZalJJUkVSZlZIVGtlQVdJWXVTL0Fwa0VTZDlTNURMcE9oSjBCcUR6RTVPRE5uTXI2RU9DcFhRU21BejhoaERxa0RqUlhRcVFlTkp3S3dDbzBsRmxFT2pTYlFSUnpRQTEzQStBZXB4WTM1S1FTQ0JqWlNoUWdVQU1KY01oTmpXWktiWUNDU2hLSUU3cUNBclhQSnhkQUZNMDV3NWdlZ0FTQmNoS1VIU0RqcERJVTAwQURVYUlYb3hBc01IRXdCd3d2UTlzclF4K1lDQS9MckxkQzNUQkdGaWtpWXF1Z0txS1VJbVFIUURyQUttUURRc0JMZ2dqZ3FiZ0Q4U2Y4dEVOQ05EZkZNajRTSkhBM0VGR2lxRU1VTWhReWtCSmZBS1lEd0JhVU1RV0F1d1VBTTRRYkVoUUs5NDRRZDhBTWd5WVI2d1cwRklSdmdHMkJ5SURhaDhBM0dCd1F3NHhCYlRFbEMyVVFBeUVnR1FFdzVVS1VoVkxoNDZ4SzdxbVFOcWNnbys0MEUwSUtXR013SkNCeEVCUkJBb01zY0Nra29ZVWxnS2REdXVhMEE1OG5RMEFVWkdEK0hmK0RJU0ZqbUI2VkJXRkRRMXFuSFdrakFvamlGSUliTVljVEd3bklMZ2Q1d0lPYUJ6TTFnTXo1Z0dZc3JxYmdpWUZvc1V0Q04rZ2NDeW1rQ3dPOGVHUThJenRDRVVHUER1V0d3MUk4TzVzWnl4R2hqR1E1WThPaDJoNGZudzhOaDZUNEZGdzlKQnZETlFGVG5zdEMza2V4eVFJcElwaDI5QU54Si80VWJiemdnSUVxR3BSc3BFS3M4c0ZtQ1RONThxUUNpSUozL1RsVERZQWU0RUlBZ1M0Z1RNMnFGQkdKMkVJUVRBd0dsRFBaQmhyQ3pBaFNuME9vYUJ2QWJVS2xyVENENzRZZXNBMkFDRmRueDdha2dqWjl2RWNiR1VDWkJEL0RpNGc1Q21BeUg4dmk4cFJ6SkFmQUh2UmFITGoyQzZCZ0lRdkhlZ2ZnZ0lGa09zME9IVE1LSzhZaERJMDlPUmVNS2RsUlhUeGd3c1FISWIxWTc2RGtaOWVZRHBRUEpGdERwWUtBZXdaN1lDSmhJU0xXb3lNQUYwUFRsNGFZZ3lpQUFtNmtmRDRRYVpGRGI4QVlZYVFnQkFlYUZES1lNdlJDSmpTdlF2UkdKWTVsc0FvMHAyV2NxSWw4ZUdSMUJGNEU1a2EyS0FRa1FqUmFsMFlrZGdOS04vTExUamZzSEJJWlkrZS9JK2dyWURJMGlwNVlqMEVkNlNsdUFDU0NGQlJCMzFoNGdPc29MMEFxcFpzSmlBZkZEbUF6UTJ4UXBTVm9FaDRwbHBBN1pCSGp4TEZ6UkVuT3RBbTA4TEVRaW1LQURtTWhjaUlxdEs0SUlKNHUyZ3d5SmQ3ME5pWkRMSU1ZRDhCN0VCUkVPUmlpQW8rVU94OVVQaWFzZ1lKand6SXdDQTV5TkN4S0p3ZG1Rb0FTNkhFRFJDd0RIdUJoMGhuYUdaUU9NV0FoeHJRamdBUEFYd3hBK1pZWUprZlFNajlzR3BnbkswTzNtUkdRWkdaTmc2T2pnQ3ZBTGRFRFlSVWxnVExDSU9CekVFV0NDeGtPZUg4SEhUQ09KRVJZTUZnOEhEVWdhRGd3T0R3a0RjaFVQRE9NUFlKRUZkb3dRT0dHeGlBeU1tR1I0NHlHRUZrREFDNUJIaGtlRVdDdlh4NGJHZ2diUXlsUllBb2ZIRWRLT0kzWWQ2Q080MUNTNDBNWmdDdXVFcG9tZEFFQ2RnRUM3OEdsNDBQSmdSRTlISUV4UFdVRk1WRms2NUNEdklpRWc1ekF4SU1Xa1ZFOU1SUm15VVVORk9pQ0ZPQ0JFV0UwblV3N1lUVTlYc3doV0NnT09ERUZFT3ZJZ1lJM0V3RFhndktJSXZRQlBwQnpBQXRBRHZSQlBsUi9LME8rcFFJVUtDeFRBQ2NwQUxNQUVxWUNrb0FET05oaTh3eHFTc1Fsak9rS0VCNENCQjhLa0I4akFVWVBzcGlEREl0VXdBeTFVcXFCWklMYUtsZ09adVFmb3hBT3k1S0lQdlplS25hZmJuWC9iTXNBU2dzL2JYd2J0N21BR0JnSUNCQVFGQlFNREJ3ZmpBZVVGNVFmbEFtUjRTa2xOb0Ria1JrcERUUXpqb0tVaTBBYWxJOUFDOEFOTTBKaXBEWDBBSUdMaUxBbGNSSE9GRUQrTEk2bEloU0xFY3lQRkk1VUF0eERwSUtpTFREQ1B4aUthaE1uL3ZnakdJMkNsQnlsL0lFc01DUWlCZnhBSTB3aW1DcVFMcFFseW1FaUtTS0FLUG1DQXlkZ1FpMmlxYUtoRllvalE1NUFzamR3M0FhZ2dCdVpnTHh4SlFEWmx4d1NpQWt3Ri9IRG1DY1pFa2VJNVdNaWp4NGhsWndneXZ0S3Bib1VOcVl5RkRxWWh5b29wRDZyb29BQ3hEYUpCOEFqbURXaVlEdER5RUF0QUJCUEtIR1l6eVh6d1ZzbCs4R3pKRzlBQWMzQUJZSVVISUdONlhBZ1V1QWtwQ25CU0MrQ21ESUt6SUJ1TG1qL0pDZERFa0FyUTVnemtxUEM0SmJUR0MvQ3dvSVNzaEFXSXBLOU1FNHpFdEpWU2kwSWZUTkdMaU9OQjFsVjlpeG9ielllWTQyRC85Z0VCQmhNRTlpSE1HSUFIeUFZSEJpNE9ETE1iQVFZT0dZQjhEd0VUZkJkTTloSUJCQVFEQXhvUURBT2VCd1VGQ2d3Sjloa0dnSHdUQUFnaURnZDA0Z2tjTVBZTEF4b0FBdllUQmNCVVFCd0dNUVVHRGhKakJSREdBRkl6R0RRTll3QitBQWtTZmhhRE9IQVVnQmpRRG1GalJtRENoZ0ZxMEFFSUJYd0VRd2RCRFFvRU5BMFEwQ1ZESWtFTkh3UTBIQkVNR1Fna0VDbENFd2s1RDZEZ08wRUlCM2dZaXhlRGNPOStBUkFPZmhjRUQ5SUwwd2xYQURab0VXRUhMd1ZpRy8yTG53RU5Bd0VQTkF3RUU4b0hkZzBFV2dEQ0VRTUFTQldnUlJRWUFtS0dBcWdiNEFZdUZUQUY1UWtDUVpVWUNnd0NlZ1FEUElPeEFCd0tCeVF3WWdwdW9Rb0RpR1lOd0FJTkpBWUhmZ1FwcW40ZUNHOFB1eFFGQlFJWkNRWC9WQXF6QTJKRGd3THlDd1VFQ1FuQ2d3Z0tpZ0VFZ0tpQUVCUU1DM3dnQkNML0l3SWtBcWxHRVlNS2F1Z1lCUWZaQlFFVkRBVWZGQkNKRElDa0FTQVh3U1JjRVJtUUVnTUl3Qkl1RGd3TE5BVUxTS0FhQWhnS0NBd0NMVFFRRVFBV0RZb2FEWnFYQkxzQU1RMEJoQVhJNWdRTU13eUJCZ0lpQXFvQUVLREFkbmNBQWc1Z0FtTElvQWtHNUpjZFFzaUJHUVVRQWFNd1lnMFNrUkRRMEJkZ2I2b0hCQWhBRGtVYkJFRUZDRlFSQlJFR0RRWWdWZ3c2eFIvQmhWaFFLQUVTUmdjVUEyUWdDQWtSUUI0Smp5RUhEUm9JOVlNSEJ3WjhId2RLQUEwSGZpRUNDNjhDRkF3QkFXUUxCUk1LQ0NDUENId2hCQ1orMEFFSUZ3ajZ3bUNXbmJSQjN3WlBGaG5nVEE4ZDNIY2pwd1NpRUtrQW5mL1BEdlR4cVNPSE5UZUZPSVU1cVJTRk5La1NoVE1ROEhveWhUR3BDSVV3cVZHRk5hbk5oVGFwd0lVNklJNlBUR2FRcGpDOXdZOEx4NkM5eW84WVpUbjRES1UxaFFSNU5vVUlNTUs5MDZMSUI0VWVOTndnMFFoVUFFd0srRUlBMU5VQTE2TW0xZ0RZMndEaG95SGVwQ0VNb3lUMEFCTHVwaVJrSGtZQTVDNWdkUUNrWWdvREJnUURvZ1M5NUkrZEFCKzk2TVFRQmlEc054QXdINmtCblNBZm5WQUdRRUF5WUFvellaQ2RQQmNrMTlJUGNrMGJjWGhtaFZlRlhFanU2UER3Q1haZ3FRUk1YWkFFWENDOWxCM1NBZ1k0NVFkOEVLVWhLUThZYW9XRm9PSDhFRkNGV0dBQUJ3dGg4SEg0WDRVOWhUNkZYcWtlaFNxRks2a1FoU3dnOW8raUF5QUFteUNVa0NEMWtTQTBraUFua3lBYWxVeUNrS0NBaU5EOUJ0ZmpZQ0RBbGFVK3lRSFFBUlg1QURmd1BxVXdLUUh3QjhZMkowellrRU5JQWhyNDVqYm13MjRFOEFYR05lRjlGUWp3QXVZMXhqZm1PYVU1eVFQUUJQSkJPVXlPajRhTUJ4aHJpZ05NeFprZ1RwR2xBZ0thWUFPVXBIZDZrQXFTa1VoWUF6TUZmQzQwSUtoV2tUQ0NuTmdqeVgzd0h5bnRHOGwvOEJjTVJCV1NoaEhKS1BBTjRBb0Qwc2tWZ3pHUmVpQWE1VEdIR0Q4SWNQTXpCYjlnTklVRHVMYUMzSWhCR0FIRUhLelE1bk1FUTRnQ0R3QUkwUHZtZmxCTVE0QWdTb2FsR3lVdzhCM3dDSkRtTXFVeUd4Qm0wQ1UrQklVM2VPWk1xNUFSaC9WVnFRRjlBZE9Sb1BVSFFPTUxCNWpyQ3dlWTR3c1BEa2RnMkNVeDBBL3l3NDQ4RlN2L2tKMU1aa1RKeGpydzhEaTQ0d28zRFVsR2dOUjRNenBNblpESmUvQWN5WGZ3R01sMjBBa0NJSU9TYUhwTURKWUdlaFF2c2lBWGs2bDdZQ0FxS1NnbUpTUWpJc1kvMFBJRlV1OC9xUmhSTElPaGd6ZU95U0R3RTZJSjNTcVM4QStpNFBpOUtTcGdFNEhRek1Zc0Fza1BnSUFUTE9XUEdkQzl2QlNORXRTRlBxbUJIREdhQmpFU1hrVEFTRWlsU1F5QUEyWUNEcUdPbUVpdE1SL0pjeENaYUFyVGhUMkR2LytGUEF6Ym55THdGb1h0eGl1M0FFeEFaQnZza3VhNHNSL1FGZVJ1Zmx3UkZJNEJZQzRRSnFWb3FBZWhBZ2xvRWdBR1FFazBTR0EzUVA2UEI3MFBnTWs2MEFpcE1KMEpBbkh1Q01RZkFMeGdSd09pQjZRaElQMlNtMWhneGtEUSt4V3NRQ0FMbmM1OFFKSTdSNWlXcFQ3UUdLVTk4T0xHUFBBR3BUeU5EOVJnVUZlTTNrUUg5QVlrN3VFZ3JSb0tDcU5CaGpobklCeHlGS1pYM2lDY1dRWWdqNU5NaTVPOU1LZUtHZ2ZiNkdDOThZOERoa0RlWVBzWHFRT0J3OUQrVUIrOVVJU1VCQUJDRURuT0VTQlpsaUEwbENESDc0NVdDaGhsVmhocDVJVU1rQWdYT1FJNWdDSm9ESGNFRUIrRkNMMEFId3Q5ajFVcEFhaWxDQ1VnQXBOTThaTUNuRGpwQWd2S1pzS1U4QWxNSUNxbVdwS2FBa3BDQjFJQkdUQk1GcFFvQktLRkJ5VTVCYU1BUkVFSndIYUhuUkRMSlpXS3FNZ0VmQ1ZnbUs1Q0FnU2dlNVdTaUZHdEMxU0ZVazFmOEJ0SkRhMEJIMFRRRVI4blhFeG5sSzBDTk5BUzE2VlJTQVFtQUdxbFVuQ0FDQXE0SENDUlV5TXdnMVFCSU9CVnBWVEZVakFFTWdVS3BGUEZVVEFHNGdrQ0F3VmFGV0JRMUVrREJvZlVJVWtLVm1nUWlHaWF3R0FZYWlFQnF3VC9DY2tzOEViSnp2QkNYY0xKQ1BBOHlhVHdPR09YQ0ZrdkF1eG9LRkNDU2hZREk2ZHo4Q0lDNlRBZUxwb2FoUTVvcWg1YUR1QUQ4QW9OVHdId0JNbDJVQW13cWY5Z0ZCSWFZTVpZMFB1bENZUEJUSFNUcFZyUUhKK29HWUdDaXpqOVRuWVlhUWlGRFNtQTBEZWxEY2tRRUVBdURGcXA2aGg5VUIrR1BESTdJTVlNQ0JYQmtwRUZwUXpFQXhnQU9lQ0NDQUF1Z1F5ZCtRZGd1RXhybGQ1QUgzRGxwVnRNajVXdEV0Q0ZXeWsvZ3IwUUthaHg4YmhncVJZWGhTckpEL0FZeUwwSGg4YThJRzRrQWFOUUttQkVZUVFBY0ZEUUlHWWVHREVmcFY3UUM2VXJHNUVGSk1VUEZCZUxNaCtOTXg4Z1paWmdOTGZhb2dRRENFQ3BBdUNDOTQzSE9VZkdYTkFlcFdDRlhFeWFsYW5WVjRvQzl3eGxlYXF0RmRBSkVKZnRDbmRnUXAyUytSbGtxUmNvZzhTajZIbmR4aXU3SE5YZGxhSUlRUmthRXlBa2xzalBoQWhWd0RqdEFrMmNFSVVPQk5tR0hLVU9zaEFXclJHTEdoSXNjeGdXTkFaWkdqQXdvem1RT2owODhDS1BETkFoVk9ZOENFd3BCNFU4alRCZmtRRXg0aWtmaFYxZ3hsM1Erd3dBTUFMNVVUajlBRkxPQjJsbVNhVytEUkJEb2F3WmlwbzBLN1lRTUFOTUg1Y2N2Z0lreVFEd0dja0NPR3g5aXFBQkI5aXRvZ1hZenN4QWhEWXVUSzZYcFRYckJ3VTBNeHRRN1FvUUZhVTJXQTdhT3U0SkRuQXBrSUpCRUJqSTFWN0Q4Z0ZMTGw2d1BDNUxVTWt6eS9BVHFTS1JTT1lzeUV4cWx3STFkUytpQ3NBd3E2cXBFRWtCTklDcElPNHZ5TUFmMFBtcEQ0VXJEcE1JWnl3Z004VUd6Z1pEUkNCb2doQUNjaEJDNHlQaDBoY2NCWkM0ZFNEUUtzenFDZGhzZDhBMkRDSkFPUnNnRzlhTitiOUNpNWlwRlJxZ0FJTzY4SVNJMFByR0RORDIvdUFxQWY4c3dOQ1pJQ2lZVExDWXFWQ0ZFZ3dHNHVlNEhNa0NPckZVY1FFQ0lBVDRnbTZDOUFmQzhjR1JCNlZKZHdIVWhVbWxDRWdDRVM2QnNVZ3lhQU9pNWdjWlh1WUlBc2dJbDRqaWJ5ZlE5ZFk0eTREd1BDOFlXNkJnd3BqbUdaTEpLSUNweUVxWTVnTTdvUmFoZDBTWVlLVXRKWDNIaXBubUlLVWdVSUtqVUNLWlREZWRHQlVJSG9xRGo0Y2dJSWNlQUVCVWg3TWM5YU43MERTVHNRVHpCTTZLR0tBRmFLSXJTWUE2QUZNeEFxVUN5VHJRMmdEZHpvalF6a3d3ajJJTkhjTU5vZ2kxSDUwQVR3TDFlVXcvbVlhWEVBMU9xUkRZQklTcElpd0dPeEZUUUhZekJRY0FCSVVKRHFvZzBpWGYxVU9RaUFnb094aW1IT0NueGdhWkFFQk1oSm1aZ0VCOGRySjQwT3Bnb3ZpYXBSN0pBZkFNeGgybEhjbi8wSVVUSFpoZG9aOUpDU0lEL1F2WXFPWWNXUVBNZ044Y1hVeHloaURHbWdHbVZha0NqSXdLZkRTaUFMMk1taWsvaFlRVEtvcEl3cUpvcWg3WjZPQWwwT2RURFdLNFRBNmxEcUlLblpIWkdmcW1Eb29EVXgzRzFjR2dRSWpRL2NZT0E5TjVEZERaSWFDMmI1cm1JV0ZoRnBMV1RNS0txUW1URFFGaEVCUVJXMDZ4YmFQQzlwc1YwT3VpQnBPZUN0aHlQQ3hSa2VJTW5KTld5UlR3QzZJQ1VWOVJUR3B3blpxVm1FQmF1NEFtbWxkRlRFd2dSRTlPUlNIaklHRFRVRkpGVUVGT0FDQkdUMUlnVFU4a1VGNFFWMGxPUnlGRFFVNGNVWFJKUkJmUVNWUlpJRUxGRVZWVDZJMFRaMjRHaFF6a08vT2I3aVBRdTRaRFZ3aWdBRjFjVE4yYUMzaVk2RUF2R2ZxSVBaMUhoUXVwbTRMUUdDOGl4cGhJNEFEd0dvRVQ4RUFMeWYvd0NlWUxoZVlNVEJPYjRTVEtUQTQwRHRhWlNBZDlnQmVXMjhqQUtORHZxVENGTDJpb0N4RUlTVTBnVjdRblZGUUNmZ0JFSUVsR1lKc0Z1Vkl0WlNCSVNWTzlCdlZTNHk3QjVUYVpIMGtuMEFNQVdvQ3NHVXhRSUVFdUhPVThVRlJQVFNkVEllUWd3UkFJSVVkUFR3eXdUMHhFaFloTVJpR0VSUm9BVVNBOUdFTkZUbkU0UTBoQlVNb1FJa05xUkVVV1FVTkxFZ0dJa0VXTVNWUklidGxaSUV4QlYwNjZsaUVVNUN6L01CQldNbzh1TGlCTFNhUWhVQUx4SUN0TkxIa2dXV1pUU1VWYVJTSE1hQURjWVA4Z0lPTkJZQ1JTUjBoZ3FLUlpKMEZHUmtOWlQxVUxFVVZCWm9aTVdYQUdBc3dEb0NxSDZ5QXlSN0FmZ1hBSThFb09OdExyU3hIa3dBYkpTU0hPZzhVblJrd2FPVk9pZ1VnSGdDeFdTVVAwalNwQUlpWklrQldFQkdDSU5vQytFQi9DUnhDRDNVQkxVMFZKVGpTQlJVU1ZZQzFhaHVWRVVqbEdVeUVRY3FHN2FTQWR3RlFmWEFJZ0d6bEZ5ZWZsSUQ1RVFVMWpCdkVob2loSkp4OFFHQU5VenIvZzFTSG1JR0U1LzYyTkFpa0MwQUZncGNYSkpOQU5wVjlKLzRWZkRPRkEwUHBneVNuUSs5d3NPREh3QkVNaVVJTEhkTEVDb2dDbEF5a0hxTG5FbllVRnZidWRlYWlHRGhlYXBnNWk4MGNKME1LVG5ja05uaFhRMEdhRURUUWRTQWs3d0IzUTk4Z081RVQwK0V6YW5ZcWtPQ3BBaGRpcUZjWThtQkE3bGcrZ3dNY1R3QS9RK1V5aG5VZHBuRVg2ZWFFR0FnUUZBd2NCQUtJeXZVS2VCanNBVE1yUTlXQ0pBbmpCb0FHaUFZUU52WThIMlg4RjhqQUs4QUlRTE9qSTRBalE3cVFObUJocENxakFNOURmVStCWW5CeVJNTUVHU3h0TTNwMGpQVXltbjZVTlB2akU4RkNnTXFJS3VmWkxtU0tJTFREMmhBNVlCMzAwQ2NVTzhEZWtEa3dubnVjd0kwcERUUm5RVGs5VVoxUkZSMEdZV2tGUURVWmdqVkJQVjVCQWl2NHA2c2pvcnpmMGhBeXBDaUVKRUdneGtoVlkxWjZrSE1BbUs3M2Zuc2hRQ3cwS0FRMWhRSGtLME9JaWtRVUxCU2crNlNHUDhFQVowT3RNQXA5UW84UUgyRUVJUnhoVFZGZFBnWWNBSkRFdEVGSzNoMDVKVkVsQlRGTTZJc0lpMDBEUG1lUUtwUjdBWkFEbUVISk9nQ1BhSUVxR3BSc3BCUEFQM2lNR3ZRMUJ5Zi9MVUJxZEVpaXBDQVZPL3VLbEc1MEliaXJnRU5BUnZLY05acFVRVVYzMlRCU2ZwQXhKUS9PRGlIVTlLSUkvQUpneVB3NGtjUkFqMHdlUTRpcnc3bXpyNXFrQjRESmRBL0FEUUhCTUJKNFh5aUNmZ2lDc0JpYWduMnREQW45SkNQbzRsVTE0eW54OFRBWVVBZ1BZQUh6THUyQW5URTFQQURLVXQvLzgvd0QvZndKd1FTTkpIZ0NQSUVVY3pFVU9aTUJXUXdoQ0RDZzdvd0FNXCIpO1xyXG4iLCJpbXBvcnQgY3NzIGZyb20gXCIuL2RpYWxvZ3MuY3NzXCI7XHJcblxyXG5sZXQgb3BlbkRpYWxvZ3M7XHJcbmxldCBtZW51RWw7XHJcbmxldCBlcnJvckRpYWxvZztcclxuXHJcbmV4cG9ydCBjbGFzcyBEaWFsb2cge1xyXG5cclxuICBjb25zdHJ1Y3RvcihpZCkge1xyXG4gICAgLy8gdGhpcy5zdGF0ZSBjYW4gYmU6IFwiY2xvc2VkXCIsIFwib3BlbmluZ1wiLCBcIm9wZW5cIiwgXCJjbG9zaW5nXCJcclxuICAgIHRoaXMuc3RhdGUgPSBcImNsb3NlZFwiO1xyXG4gICAgdGhpcy5lbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcclxuICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIiwgdGhpcy50cmFuc2l0aW9uRGlkRW5kLmJpbmQodGhpcykpO1xyXG5cclxuICAgIGZvciAobGV0IGNsb3NlQnV0dG9uIG9mIHRoaXMuZWwuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImNsb3NlXCIpKSB7XHJcbiAgICAgIGNsb3NlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXHJcbiAgICAgICAgXCJjbGlja1wiLFxyXG4gICAgICAgIHRoaXMuY2xvc2UuYmluZCh0aGlzKSAgICAgICAgXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvcGVuKCkge1xyXG5cclxuICAgIG9wZW5EaWFsb2dzLmFkZCh0aGlzKTtcclxuICAgIHJlY29uc2lkZXJCbGFua2V0KCk7XHJcblxyXG4gICAgLy8gTWF5YmUgaXQgbWF0dGVycyB3aGF0IHN0YXRlIHdlIHdlcmUgaW4gYmVmb3JlP1xyXG4gICAgdGhpcy5zdGF0ZSA9IFwib3BlbmluZ1wiO1xyXG5cclxuICAgIC8vIE9uIHRoZSBmaXJzdCBmcmFtZSwgbWFrZSBpdCBkaXNwbGF5Li4uXHJcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoXHJcbiAgICAgICgpID0+IHtcclxuICAgICAgICB0aGlzLmVsLmNsYXNzTmFtZSA9IFwiZGlhbG9nIHRyYW5zcGFyZW50XCI7XHJcbiAgICAgICAgLy8gLi4ub25seSB0aGVuLCBvbmNlIGl0J3MgdXAsIGNhbiB3ZSBzdGFydCB0aGUgdHJhbnNpdGlvblxyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShcclxuICAgICAgICAgICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5lbC5jbGFzc05hbWUgPSBcImRpYWxvZyBvcGVuXCI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBCYW5kLWFpZDogd2l0aG91dCB0aGlzLCBjbGlja2luZyBvbiBidXR0b25zIHRvIG9wZW4gdGhlIGRpYWxvZ3MgdG9vXHJcbiAgICAvLyBxdWlja2x5IGNhbiByZXN1bHQgaW4gdGhlbSBvcGVuaW5nIHdpdGggZXZlcnl0aGluZyBoaWdoaWdodGVkLlxyXG4gICAgZ2xvYmFsVGhpcy5nZXRTZWxlY3Rpb24oKS5lbXB0eSgpO1xyXG4gIH1cclxuXHJcbiAgY2xvc2UoKSB7XHJcbiAgICAvLyAoQXNzdW1pbmcgaXQgd2Fzbid0IGFscmVhZHkgY2xvc2VkKVxyXG4gICAgdGhpcy5zdGF0ZSA9IFwiY2xvc2luZ1wiO1xyXG4gICAgdGhpcy5lbC5jbGFzc05hbWUgPSBcImRpYWxvZyB0cmFuc3BhcmVudFwiO1xyXG4gIH1cclxuXHJcbiAgdHJhbnNpdGlvbkRpZEVuZCgpIHtcclxuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xyXG4gICAgICBjYXNlIFwiY2xvc2luZ1wiOlxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBcImNsb3NlZFwiO1xyXG4gICAgICAgIHRoaXMuZWwuY2xhc3NOYW1lID0gXCJkaWFsb2cgdW5kaXNwbGF5ZWRcIjtcclxuICAgICAgICBvcGVuRGlhbG9ncy5kZWxldGUodGhpcyk7XHJcbiAgICAgICAgcmVjb25zaWRlckJsYW5rZXQoKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcIm9wZW5pbmdcIjpcclxuICAgICAgICB0aGlzLnN0YXRlID0gXCJvcGVuXCI7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZWNvbnNpZGVyQmxhbmtldCgpIHtcclxuICAvLyBUT0RPOiB1Z2hcclxuICBpZiAob3BlbkRpYWxvZ3Muc2l6ZSkge1xyXG4gICAgbWVudUVsLnNldEF0dHJpYnV0ZShcclxuICAgICAgXCJzdHlsZVwiLFxyXG4gICAgICBgZGlzcGxheTogYmxvY2s7YFxyXG4gICAgKTtcclxuICB9XHJcbiAgZWxzZSB7XHJcbiAgICBtZW51RWwuc2V0QXR0cmlidXRlKFxyXG4gICAgICBcInN0eWxlXCIsXHJcbiAgICAgIGBkaXNwbGF5OiBub25lO2BcclxuICAgICk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2hvd0Vycm9yRGlhbG9nKHRleHQpIHtcclxuICAvLyBUaGlzIGV4cG9zZXMgdGhlIHdlYWtuZXNzIG9mIG5vdCBoYXZpbmcgYSBkeW5hbWljIGRpYWxvZyBtYW5hZ2VyLCB3aGljaFxyXG4gIC8vIGNyZWF0ZXMgYW5kIGRlc3Ryb3lzIHRoZSBET00gZWxlbWVudHMgb24tZGVtYW5kLiBJdCdzIGx1Y2sgdGhhdCBtdWx0aXBsZVxyXG4gIC8vIGRpYWxvZ3MgZG9uJ3Qgb2NjdXIgYXQgdGhlIHNhbWUgdGltZSwgYW5kIHdlIGRvbid0IGhhbmRsZSB0aGUgY2FzZSB3ZWxsXHJcbiAgLy8gd2hlbiB0aGV5IGRvLiBIZW5jZSB0aGUgZXJyb3JEaWFsb2cgaXMgYXQgdGhlIGVuZCBvZiB0aGUgcHJlLWJha2VkIEhUTUwuXHJcbiAgZG9jdW1lbnRcclxuICAgIC5nZXRFbGVtZW50QnlJZChcImVycm9yRGlhbG9nLXRleHRcIilcclxuICAgIC5pbm5lclRleHQgPSB0ZXh0O1xyXG5cclxuICBlcnJvckRpYWxvZy5vcGVuKCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpbml0RGlhbG9ncygpIHtcclxuXHJcbiAgb3BlbkRpYWxvZ3MgPSBuZXcgU2V0KCk7XHJcbiAgbWVudUVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtZW51XCIpO1xyXG5cclxuICBkb2N1bWVudFxyXG4gICAgLmdldEVsZW1lbnRCeUlkKFwiYmxhbmtldFwiKVxyXG4gICAgLmFkZEV2ZW50TGlzdGVuZXIoXHJcbiAgICAgIFwiY2xpY2tcIixcclxuICAgICAgKCkgPT4ge1xyXG4gICAgICAgIEFycmF5LmZyb20ob3BlbkRpYWxvZ3MpLmZvckVhY2goXHJcbiAgICAgICAgICBkaWFsb2cgPT4gZGlhbG9nLmNsb3NlKClcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICApXHJcbiAgO1xyXG5cclxuICBlcnJvckRpYWxvZyA9IG5ldyBEaWFsb2coXCJlcnJvckRpYWxvZ1wiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNsb3NlQWxsRGlhbG9ncygpIHtcclxuICBmb3IgKGxldCBkaWFsb2cgb2Ygb3BlbkRpYWxvZ3MpIHtcclxuICAgIC8vIERvZXNuJ3QgbXV0YXRlIHRoZSBsaXN0IHdlJ3JlIGl0ZXJhdGluZyBvdmVyXHJcbiAgICBkaWFsb2cuY2xvc2UoKTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgRGlhbG9nLCBjbG9zZUFsbERpYWxvZ3MgfSBmcm9tIFwiLi9kaWFsb2dzXCI7XHJcbmltcG9ydCBjaGFyUm9tIGZyb20gXCIuLi8uLi90YXJnZXQvcm9tL2NoYXJhY3RlclwiO1xyXG5pbXBvcnQgeyBwZXRzY2lpVG9Gb250Q29kZVBvaW50IH0gZnJvbSBcIi4uLy4uL3Rvb2xzL2M2NEZvbnRDb2RlUG9pbnRzXCI7XHJcbmltcG9ydCBjc3MgZnJvbSBcIi4vZGlza0RpYWxvZy5jc3NcIjtcclxuXHJcbmxldCBjNjQ7XHJcbmxldCBkaWFsb2c7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaW5pdERpc2tEaWFsb2cobmFzY2VudEM2NCkge1xyXG4gIGM2NCA9IG5hc2NlbnRDNjQ7XHJcblxyXG4gIGM2NC5ob29rcy5vbkQ2NEluZ2VzdCA9IHNob3dEaXNrRGlhbG9nO1xyXG4gIGRpYWxvZyA9IG5ldyBEaWFsb2coXCJkaXNrRGlhbG9nXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwZXRzY2lpU3RyaW5nVG9DYW52YXMocGV0c2NpaVNlcSkge1xyXG5cclxuICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gIGNhbnZhcy53aWR0aCAgPSA4ICogcGV0c2NpaVNlcS5sZW5ndGg7XHJcbiAgY2FudmFzLmhlaWdodCA9IDg7XHJcblxyXG4gIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG5cclxuICBjYW52YXMuc3R5bGUud2lkdGggID0gYCR7TWF0aC5yb3VuZChjYW52YXMud2lkdGggICogMS4wKX1weGA7XHJcbiAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke01hdGgucm91bmQoY2FudmFzLmhlaWdodCAqIDEuMCl9cHhgO1xyXG4gIGNhbnZhcy5zdHlsZS5pbWFnZVJlbmRlcmluZyA9IFwicGl4ZWxhdGVkXCI7XHJcbiAgXHJcbiAgY29uc3QgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICBjb25zdCBiaXRtYXAgPSBpbWFnZURhdGEuZGF0YTsgIFxyXG5cclxuICBBcnJheS5mcm9tKHBldHNjaWlTZXEpLmZvckVhY2goXHJcbiAgICAoY2hhciwgaW5kZXgpID0+IHtcclxuXHJcbiAgICAgIGxldCBjb2RlcG9pbnQgPSBwZXRzY2lpVG9Gb250Q29kZVBvaW50KGNoYXIuY2hhckNvZGVBdCgwKSk7XHJcblxyXG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDg7IHkrKykge1xyXG5cclxuICAgICAgICBjb25zdCBmb250T2Zmc2V0ID0gKGNvZGVwb2ludCAqIDgpICsgeTtcclxuICAgICAgICBsZXQgc2VxID0gY2hhclJvbVtmb250T2Zmc2V0XTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCA4OyB4KyspIHtcclxuICAgICAgICAgIGxldCBjYW52YXNPZmZzZXQgPSAoKHkgKiBjYW52YXMud2lkdGgpICsgKGluZGV4ICogOCkgKyB4KSAqIDQ7XHJcblxyXG4gICAgICAgICAgaWYgKHNlcSAmIDBiMTAwMDAwMDApIHtcclxuICAgICAgICAgICAgYml0bWFwW2NhbnZhc09mZnNldCArIDBdID0gMHhmZjtcclxuICAgICAgICAgICAgYml0bWFwW2NhbnZhc09mZnNldCArIDFdID0gMHhmZjtcclxuICAgICAgICAgICAgYml0bWFwW2NhbnZhc09mZnNldCArIDJdID0gMHhmZjtcclxuICAgICAgICAgICAgYml0bWFwW2NhbnZhc09mZnNldCArIDNdID0gMjU1O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHNlcSA8PD0gMTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICApO1xyXG5cclxuICBjb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xyXG4gIHJldHVybiBjYW52YXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNob3dEaXNrRGlhbG9nKGRpcikge1xyXG5cclxuICBsZXQgcmVzb2x2ZVdpdGhEaXJFbnRyeTtcclxuXHJcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKFxyXG4gICAgKHJlc29sdmUpID0+IHtcclxuICAgICAgcmVzb2x2ZVdpdGhEaXJFbnRyeSA9IHJlc29sdmU7XHJcbiAgICB9XHJcbiAgKTtcclxuXHJcbiAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkaXNrRGlhbG9nLWRpckVudHJpZXNcIik7XHJcblxyXG4gIC8vIEVtcHR5IHdoYXRldmVyIG1pZ2h0IGhhdmUgYmVlbiB0aGVyZSBiZWZvcmVcclxuICB3aGlsZSAoY29udGFpbmVyLmZpcnN0Q2hpbGQpIHtcclxuICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIubGFzdENoaWxkKTtcclxuICB9XHJcblxyXG4gIGZvciAobGV0IGVudHJ5IG9mIGRpcikge1xyXG4gICAgY29uc3QgeyBuYW1lLCBibG9ja3MsIHR5cGUgfSA9IGVudHJ5O1xyXG4gICAgXHJcbiAgICBjb25zdCBjYW52YXMgPSBwZXRzY2lpU3RyaW5nVG9DYW52YXMoXHJcbiAgICAgIGAke1N0cmluZyhibG9ja3MpLnBhZEVuZCg1KX0ke2BcIiR7bmFtZX1cImAucGFkRW5kKDIwKX0ke3R5cGV9YFxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xyXG4gICAgYnV0dG9uLmFwcGVuZENoaWxkKGNhbnZhcyk7XHJcblxyXG4gICAgaWYgKHR5cGUgPT09IFwiUFJHXCIpIHtcclxuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXHJcbiAgICAgICAgXCJjbGlja1wiLFxyXG4gICAgICAgICgpID0+IHtcclxuICAgICAgICAgIGNsb3NlQWxsRGlhbG9ncygpO1xyXG4gICAgICAgICAgcmVzb2x2ZVdpdGhEaXJFbnRyeShlbnRyeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcImRpc2FibGVkXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChidXR0b24pO1xyXG4gIH1cclxuXHJcbiAgZGlhbG9nLm9wZW4oKTtcclxuICByZXR1cm4gcHJvbWlzZTtcclxufVxyXG4iLCIvKlxyXG4gICBUaGlzIHdlYiBmcm9udCBlbmQgbWFpbnRhaW5zIGEgd2hvbGUgVUkgdGhyb3VnaCBkaXJlY3QgRE9NIG1hbmlwdWxhdGlvbi5cclxuICAgVGhhdCdzIGEgYmFkIGlkZWEuIE9uZSBpbml0aWFsIGdvYWwgb2YgdGhlIGVtdWxhdG9yIHdhcyB0byBoYXZlIG5vIGV4dGVybmFsXHJcbiAgIGRlcGVuZGVuY2llcywgYnV0IHRoZW4gdGhlIGZyb250IGVuZCBncmV3LCBhbmQgbm93IGl0J3MgbG9uZyBwYXN0IHRoZSBwb2ludFxyXG4gICB0aGF0IGl0IHNob3VsZCBqdXN0IGJlIHJld3JpdHRlbiBpbiBSZWFjdCBvciBvdGhlciBmcmFtZXdvcmsuIFNvLi4uIGV4cGVjdFxyXG4gICB0aGlzIGZvbGRlciB0byBsb29rIHZlcnkgZGlmZmVyZW50IGluIGZ1dHVyZS5cclxuKi9cclxuXHJcbmltcG9ydCB7IGluaXREaWFsb2dzLCBzaG93RXJyb3JEaWFsb2cgfSBmcm9tIFwiLi9kaWFsb2dzXCI7XHJcbmltcG9ydCB7IGluaXRUcmF5cywgdG9nZ2xlVHJheXMgfSBmcm9tIFwiLi90cmF5c1wiO1xyXG5pbXBvcnQgeyBpbml0U2NvcGVzIH0gZnJvbSBcIi4vc2NvcGVzXCI7XHJcblxyXG5pbXBvcnQgeyBpbml0Sm95c3RpY2tEaWFsb2cgfSBmcm9tIFwiLi9qb3lzdGlja0RpYWxvZ1wiO1xyXG5pbXBvcnQgeyBpbml0S2V5TWFwRGlhbG9nIH0gICBmcm9tIFwiLi9rZXlNYXBEaWFsb2dcIjtcclxuaW1wb3J0IHsgaW5pdExvYWRlckRpYWxvZyB9ICAgZnJvbSBcIi4vbG9hZGVyRGlhbG9nXCI7XHJcbmltcG9ydCB7IGluaXREaXNrRGlhbG9nIH0gICAgIGZyb20gXCIuL2Rpc2tEaWFsb2dcIjtcclxuXHJcbi8vIEEgZGV2ZWxvcG1lbnQgYWlkLiBEb24ndCBjb21taXQgd2l0aCB0aGlzIHR1cm5lZCBvbi5cclxuY29uc3QgcGF1c2VPbk1lbnVzID0gZmFsc2U7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYXR0YWNoKG5hc2NlbnRDNjQpIHtcclxuICBjb25zdCBjNjQgPSBuYXNjZW50QzY0O1xyXG5cclxuICAvLyBBdHRhY2ggY2xpY2sgaGFuZGxlcnMgZm9yIGJhY2tncm91cCBlbGVtZW50cyB0byBvcGVuIHRoZSB1cHBlciB0cmF5XHJcbiAgZm9yIChsZXQgZWwgb2YgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIl9pc0JhY2tncm91bmRcIikpIHtcclxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXHJcbiAgICAgIFwiY2xpY2tcIixcclxuICAgICAgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gZWwpIHtcclxuICAgICAgICAgIC8vIFRoaXMgcGFyYWRpZ20gZmVlbHMgd3JvbmdcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHNob3dpbmcgPSB0b2dnbGVUcmF5cygpO1xyXG5cclxuICAgICAgICBpZiAocGF1c2VPbk1lbnVzKSB7XHJcbiAgICAgICAgICAvLyBUaGlzIGlzIGEgaGFjaywgYW5kIHdpbGwgY29uZmxpY3Qgd2l0aCBzZXR0aW5ncyB5b3VcclxuICAgICAgICAgIC8vIG1ha2UgdG8gdGhlIHJ1bmxvb3AgYW5kIG11dGUgd2l0aGluIHRoZSBtZW51LlxyXG4gICAgICAgICAgaWYgKHNob3dpbmcpIHtcclxuICAgICAgICAgICAgYzY0LnJ1bmxvb3Auc3RvcCgpO1xyXG4gICAgICAgICAgICBjNjQuYXVkaW8uc2V0VWlHYWluKDApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGM2NC5ydW5sb29wLnJ1bigpO1xyXG4gICAgICAgICAgICBjNjQuYXVkaW8uc2V0VWlHYWluKDEpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8vIFdpcmUtdXAgYWxsIHRoZSBvdGhlciBVSSBlbGVtZW50cyAoZXhpc3RpbmcgSFRNTCkgdG8gY29kZVxyXG4gIGluaXREaWFsb2dzKCk7XHJcbiAgaW5pdFRyYXlzKGM2NCk7XHJcbiAgaW5pdEpveXN0aWNrRGlhbG9nKGM2NCk7XHJcbiAgaW5pdEtleU1hcERpYWxvZyhjNjQpO1xyXG4gIGluaXRMb2FkZXJEaWFsb2coYzY0KTtcclxuICBpbml0RGlza0RpYWxvZyhjNjQpO1xyXG4gIGluaXRTY29wZXMoYzY0KTtcclxuXHJcbiAgYzY0Lmhvb2tzLnJlcG9ydEVycm9yID0gc2hvd0Vycm9yRGlhbG9nO1xyXG4gIGM2NC5ob29rcy5zZXRUaXRsZSA9IHNldFRpdGxlO1xyXG59XHJcblxyXG5jb25zdCBpbml0aWFsVGl0bGUgPSBkb2N1bWVudC50aXRsZTtcclxuXHJcbmZ1bmN0aW9uIHNldFRpdGxlKHN0cikge1xyXG4gIC8vIFRPRE86IHdlIHNob3VsZCBkbyB0aGlzIGZvciBBTlNJIG1vZGUgdG9vLFxyXG4gIC8vIEFuZCBnZXQgaXQgaW50byB0aGUgc25hcHNob3QgbmFtZTsgYXQgbGVhc3Qgc28gdGhhdCBjbGlja2luZyBvbiB0aGVcclxuICAvLyBzbmFwc2hvdCB3aWxsIHJlc3RvcmUgdGhlIHdpbmRvdyB0aXRsZS5cclxuICBkb2N1bWVudC50aXRsZSA9IHN0ci5sZW5ndGggPyBgJHtzdHJ9ICgke2luaXRpYWxUaXRsZX0pYCA6IGluaXRpYWxUaXRsZTtcclxufVxyXG4iLCJpbXBvcnQgY3NzIGZyb20gXCIuL2pveXN0aWNrRGlhbG9nLmNzc1wiO1xyXG5cclxubGV0IGM2NDtcclxubGV0IHN0YXRlO1xyXG5cclxuY29uc3QgY3JzcnNCaW5kaW5ncyA9IFtcclxuICBbXCJjcnNyc19rZXlcIiwgXCJjdXJzb3JzVG9LZXlzXCJdLFxyXG4gIFtcImNyc3JzX2NwMVwiLCBcImN1cnNvcnNUb0NwMVwiXSxcclxuICBbXCJjcnNyc19jcDJcIiwgXCJjdXJzb3JzVG9DcDJcIl0sXHJcbl07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaW5pdEpveXN0aWNrRGlhbG9nKG5hc2NlbnRDNjQpIHtcclxuICBjNjQgPSBuYXNjZW50QzY0O1xyXG5cclxuICBzdGF0ZSA9IHtcclxuICAgIC8vIFRoZXNlIG1heWJlIGJlbG9uZyBpbiBzb21lIHNldHRpbmdzIHN0cnVjdCBvbiBjNjRcclxuICAgIGN1cnNvcnNUb0tleXM6IHRydWUsXHJcbiAgICBjdXJzb3JzVG9DcDE6IGZhbHNlLFxyXG4gICAgY3Vyc29yc1RvQ3AyOiB0cnVlLFxyXG4gIH07XHJcblxyXG4gIGZvciAobGV0IFtpZCwgc3RhdGVLZXldIG9mIGNyc3JzQmluZGluZ3MpIHtcclxuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xyXG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcclxuICAgICAgXCJjbGlja1wiLFxyXG4gICAgICAoKSA9PiB7XHJcbiAgICAgICAgc3RhdGVbc3RhdGVLZXldID0gIXN0YXRlW3N0YXRlS2V5XTtcclxuICAgICAgICB1cGRhdGVDdXJzb3JFbGVtZW50cygpO1xyXG5cclxuICAgICAgICBjNjQua2V5Ym9hcmQuY3Vyc29yc1RvS2V5cyAgPSBzdGF0ZS5jdXJzb3JzVG9LZXlzO1xyXG4gICAgICAgIGM2NC5qb3lzdGljay50b0NvbnRyb2xQb3J0MSA9IHN0YXRlLmN1cnNvcnNUb0NwMTtcclxuICAgICAgICBjNjQuam95c3RpY2sudG9Db250cm9sUG9ydDIgPSBzdGF0ZS5jdXJzb3JzVG9DcDI7XHJcblxyXG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG4gICAgICB9XHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlQ3Vyc29yRWxlbWVudHMoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlQ3Vyc29yRWxlbWVudHMoKSB7XHJcbiAgZm9yIChsZXQgW2lkLCBzdGF0ZUtleV0gb2YgY3JzcnNCaW5kaW5ncykge1xyXG4gICAgY29uc3QgeyBjbGFzc0xpc3QgfSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcclxuXHJcbiAgICBpZiAoc3RhdGVbc3RhdGVLZXldKSBjbGFzc0xpc3QuYWRkICAgKFwic2VsZWN0ZWRcIik7XHJcbiAgICBlbHNlICAgICAgICAgICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRcIik7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBjc3MgZnJvbSBcIi4va2V5TWFwRGlhbG9nLmNzc1wiO1xyXG5cclxubGV0IGM2NDtcclxuXHJcbi8vIFNob3VsZCBnZXQvc2V0IHRoaXMgZnJvbS90byBhIGNvb2tpZSBpbiBmdXR1cmVcclxubGV0IG5hdHVyYWxNYXBwaW5nID0gdHJ1ZTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpbml0S2V5TWFwRGlhbG9nKG5hc2NlbnRDNjQpIHtcclxuICBjNjQgPSBuYXNjZW50QzY0O1xyXG5cclxuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm1hcF9uYXR1cmFsXCIpLmFkZEV2ZW50TGlzdGVuZXIoXHJcbiAgICBcImNsaWNrXCIsXHJcbiAgICAoKSA9PiB7XHJcbiAgICAgIG5hdHVyYWxNYXBwaW5nID0gdHJ1ZTtcclxuICAgICAgYzY0LmtleWJvYXJkLm5hdHVyYWxNYXBwaW5nID0gdHJ1ZTtcclxuICAgICAgdXBkYXRlTWFwcGluZ0VsZW1lbnRzKCk7XHJcbiAgICB9XHJcbiAgKTtcclxuXHJcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtYXBfZGlyZWN0XCIpLmFkZEV2ZW50TGlzdGVuZXIoXHJcbiAgICBcImNsaWNrXCIsXHJcbiAgICAoKSA9PiB7XHJcbiAgICAgIG5hdHVyYWxNYXBwaW5nID0gZmFsc2U7XHJcbiAgICAgIGM2NC5rZXlib2FyZC5uYXR1cmFsTWFwcGluZyA9IGZhbHNlO1xyXG4gICAgICB1cGRhdGVNYXBwaW5nRWxlbWVudHMoKTtcclxuICAgIH1cclxuICApO1xyXG5cclxuICB1cGRhdGVNYXBwaW5nRWxlbWVudHMoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlTWFwcGluZ0VsZW1lbnRzKCkge1xyXG4gIHNldFNlbGVjdGVkbmVzcyhcIm1hcF9uYXR1cmFsXCIsIG5hdHVyYWxNYXBwaW5nKTtcclxuICBzZXRTZWxlY3RlZG5lc3MoXCJtYXBfZGlyZWN0XCIsICFuYXR1cmFsTWFwcGluZyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldFNlbGVjdGVkbmVzcyhpZCwgc2VsZWN0ZWQpIHtcclxuICBjb25zdCB7IGNsYXNzTGlzdCB9ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xyXG4gIGlmIChzZWxlY3RlZCkgY2xhc3NMaXN0LmFkZCAgIChcInNlbGVjdGVkXCIpO1xyXG4gIGVsc2UgICAgICAgICAgY2xhc3NMaXN0LnJlbW92ZShcInNlbGVjdGVkXCIpO1xyXG59XHJcbiIsImltcG9ydCBob3ZlckJvdnZlclByZyBmcm9tIFwiLi9kZW1vcy9ob3ZlcmJvdnZlcl9wcmdcIjtcclxuaW1wb3J0IGZpcnN0UHJnICAgICAgIGZyb20gXCIuL2RlbW9zL2ZpcnN0X3ByZ1wiO1xyXG5cclxuaW1wb3J0IHsgY2xvc2VBbGxEaWFsb2dzIH0gZnJvbSBcIi4vZGlhbG9nc1wiO1xyXG5pbXBvcnQgeyBpbmdlc3QgfSBmcm9tIFwiLi4vaW5nZXN0XCI7XHJcbmltcG9ydCBjc3MgZnJvbSBcIi4vbG9hZGVyRGlhbG9nLmNzc1wiO1xyXG5cclxubGV0IGM2NDtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpbml0TG9hZGVyRGlhbG9nKG5hc2NlbnRDNjQpIHtcclxuICBjNjQgPSBuYXNjZW50QzY0O1xyXG5cclxuICBkb2N1bWVudFxyXG4gICAgLmdldEVsZW1lbnRCeUlkKFwiaG92ZXJCb3Z2ZXJCdXR0b25cIilcclxuICAgIC5hZGRFdmVudExpc3RlbmVyKFxyXG4gICAgICBcImNsaWNrXCIsXHJcbiAgICAgIC8vIFRPRE86IHJlYXNzaWduIGpveXN0aWNrIHRvIHBvcnQgMSBhdXRvbWF0aWNhbGx5XHJcbiAgICAgICgpID0+IGxhdW5jaChcIkhvdmVyIEJvdnZlci5wcmdcIiwgaG92ZXJCb3Z2ZXJQcmcpXHJcbiAgICApXHJcbiAgO1xyXG5cclxuICBkb2N1bWVudFxyXG4gICAgLmdldEVsZW1lbnRCeUlkKFwiZmlyc3RCdXR0b25cIilcclxuICAgIC5hZGRFdmVudExpc3RlbmVyKFxyXG4gICAgICBcImNsaWNrXCIsXHJcbiAgICAgICgpID0+IGxhdW5jaChcIkZpcnN0LnByZ1wiLCBmaXJzdFByZylcclxuICAgIClcclxuICA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxhdW5jaChmaWxlbmFtZSwgYnl0ZXMpIHtcclxuICBpbmdlc3QoYzY0LCBmaWxlbmFtZSwgYnl0ZXMpO1xyXG4gIGNsb3NlQWxsRGlhbG9ncygpO1xyXG59XHJcbiIsImltcG9ydCB7IERpYWxvZyB9IGZyb20gXCIuL2RpYWxvZ3NcIjtcclxuaW1wb3J0IHsgdG9nZ2xlU2NvcGVzIH0gZnJvbSBcIi4vc2NvcGVzXCI7XHJcbmltcG9ydCB7IHRha2VTbmFwc2hvdCB9IGZyb20gXCIuL3NuYXBzaG90XCI7XHJcblxyXG5sZXQgYzY0O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGluaXRMb3dlclRyYXkobmFzY2VudEM2NCkge1xyXG4gIGM2NCA9IG5hc2NlbnRDNjQ7XHJcblxyXG4gIGZvciAobGV0IFtidXR0b25JZCwgZGlhbG9nSWRdIG9mIFtcclxuICAgIFtcImpveXN0aWNrQnV0dG9uXCIsIFwiY3Vyc29yS2V5c0RpYWxvZ1wiXSxcclxuICAgIFtcImtleW1hcEJ1dHRvblwiLCAgIFwia2V5bWFwRGlhbG9nXCJdLFxyXG4gICAgW1wibG9hZEJ1dHRvblwiLCAgICAgXCJsb2FkRGlhbG9nXCJdLFxyXG4gICAgW1wiYWJvdXRCdXR0b25cIiwgICAgXCJhYm91dERpYWxvZ1wiXSxcclxuICBdKSB7XHJcbiAgICBjb25zdCBkaWFsb2cgPSBuZXcgRGlhbG9nKGRpYWxvZ0lkKTtcclxuXHJcbiAgICBoYW5kbGVyRm9yRXZlbnRGb3JJZChcclxuICAgICAgYnV0dG9uSWQsIFxyXG4gICAgICBcImNsaWNrXCIsXHJcbiAgICAgICgpID0+IGRpYWxvZy5vcGVuKClcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBoYW5kbGVyRm9yRXZlbnRGb3JJZChcclxuICAgIFwicGF1c2VCdXR0b25cIiwgXHJcbiAgICBcImNsaWNrXCIsXHJcbiAgICAoKSA9PiBjNjQucnVubG9vcC5zdG9wKClcclxuICApO1xyXG5cclxuICBoYW5kbGVyRm9yRXZlbnRGb3JJZChcclxuICAgIFwicGxheUJ1dHRvblwiLCBcclxuICAgIFwiY2xpY2tcIixcclxuICAgICgpID0+IGM2NC5ydW5sb29wLnJ1bigpXHJcbiAgKTtcclxuXHJcbiAgaGFuZGxlckZvckV2ZW50Rm9ySWQoXHJcbiAgICBcInJlY29yZEJ1dHRvblwiLCBcclxuICAgIFwiY2xpY2tcIixcclxuICAgICgpID0+IHRha2VTbmFwc2hvdChjNjQpXHJcbiAgKTtcclxuXHJcbiAgaGFuZGxlckZvckV2ZW50Rm9ySWQoXHJcbiAgICBcIm11dGVCdXR0b25cIiwgXHJcbiAgICBcImNsaWNrXCIsXHJcbiAgICAoKSA9PiBtdXRlKClcclxuICApO1xyXG5cclxuICBoYW5kbGVyRm9yRXZlbnRGb3JJZChcclxuICAgIFwidW5tdXRlQnV0dG9uXCIsIFxyXG4gICAgXCJjbGlja1wiLFxyXG4gICAgKCkgPT4gdW5tdXRlKClcclxuICApO1xyXG5cclxuICBoYW5kbGVyRm9yRXZlbnRGb3JJZChcclxuICAgIFwic2NvcGVCdXR0b25cIiwgXHJcbiAgICBcImNsaWNrXCIsXHJcbiAgICAoKSA9PiB0b2dnbGVTY29wZXMoKVxyXG4gICk7XHJcblxyXG4gIC8vIFRPRE86IHdlJ3JlIGNob29zaW5nIGFuIGluaXRpYWwgc3RhdGUgaGVyZSwgYnV0IHdoYXQgd2Ugc2hvdWxkIGRvIGlzIHN0YXJ0XHJcbiAgLy8gd2l0aCBpdCBtdXRlZCwgYW5kIGNoYW5nZSBpdCB0byB1bm11dGVkIHdoZW4gdGhlIGF1ZGlvIEFQSSByZXN1bWVzIGl0c2VsZlxyXG4gIC8vIGFmdGVyIHRoZSBmaXJzdCBpbnRlcmFjdGlvbi5cclxuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInVubXV0ZUJ1dHRvblwiKS5jbGFzc0xpc3QuYWRkKFwiaGlkZGVuXCIpO1xyXG5cclxuICAvLyBUT0RPOiBUaGlzIGlzIGEgYmFkIHBhdHRlcm4sIHRoZSB0cmF5IHRha2luZyB0aGUgaG9vayBmb3IgaXRzZWxmLiBPdGhlclxyXG4gIC8vIGNvbXBvbmVudHMgYXJlIHF1aXRlIGxpa2VseSB0byB3YW50IGFjY2VzcyB0byB0aGUgc3RhcnQvc3RvcCBvbmUuIElkZWFsbHlcclxuICAvLyBoYXZlIGFuIEV2ZW50VGFyZ2V0IG9iamVjdCBpbiB0aGUgZnJvbnRlbmQgcm9vdCwgdG8gd2hpY2ggdGhlc2VcclxuICAvLyBjb21wb25lbnRzIHNob3VsZCBjYWxsIGFuIGFkZEV2ZW50TGlzdGVuZXIuXHJcblxyXG4gIGM2NC5ob29rcy5kaWRTdGFydCA9ICgpID0+IHtcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGF1c2VCdXR0b25cIikuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGxheUJ1dHRvblwiKSAuY2xhc3NMaXN0LmFkZCAgIChcImhpZGRlblwiKTtcclxuICAgIHVwZGF0ZUZwc01lc3NhZ2UoXCIuLi5IelwiKTtcclxuICB9O1xyXG5cclxuICBjNjQuaG9va3MuZGlkU3RvcCA9ICgpID0+IHtcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGF1c2VCdXR0b25cIikuY2xhc3NMaXN0LmFkZCAgIChcImhpZGRlblwiKTtcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGxheUJ1dHRvblwiKSAuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcclxuICAgIHVwZGF0ZUZwc01lc3NhZ2UoXCJcIik7XHJcbiAgfTtcclxuXHJcbiAgbmFzY2VudEM2NC5ob29rcy51cGRhdGVGcHMgPSAoZnBzKSA9PiB7XHJcbiAgICB1cGRhdGVGcHNNZXNzYWdlKGAke2Zwc31IemApO1xyXG4gIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVGcHNNZXNzYWdlKG1lc3NhZ2UpIHtcclxuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZwc1wiKS5pbm5lclRleHQgPSBtZXNzYWdlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBoYW5kbGVyRm9yRXZlbnRGb3JJZChpZCwgZXZlbnROYW1lLCBmbikge1xyXG4gIGRvY3VtZW50XHJcbiAgICAuZ2V0RWxlbWVudEJ5SWQoaWQpXHJcbiAgICAuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZuKVxyXG4gIDtcclxufVxyXG5cclxuZnVuY3Rpb24gbXV0ZSgpIHtcclxuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm11dGVCdXR0b25cIikgIC5jbGFzc0xpc3QuYWRkICAgKFwiaGlkZGVuXCIpO1xyXG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidW5tdXRlQnV0dG9uXCIpLmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIik7XHJcbiAgYzY0LmF1ZGlvLnNldFVpR2FpbigwKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdW5tdXRlKCkge1xyXG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibXV0ZUJ1dHRvblwiKSAgLmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIik7XHJcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ1bm11dGVCdXR0b25cIikuY2xhc3NMaXN0LmFkZCAgIChcImhpZGRlblwiKTtcclxuICBjNjQuYXVkaW8uc2V0VWlHYWluKDEpO1xyXG59XHJcbiIsIi8vIGJvdW5kIGJ5IGF0dGFjaFxyXG5sZXQgYzY0O1xyXG5cclxubGV0IGNhbnZhcztcclxubGV0IGNvbnRleHQ7XHJcbmxldCBpbWFnZURhdGE7XHJcbmxldCBiaXRtYXA7XHJcblxyXG5mdW5jdGlvbiBhdHRhY2gobmFzY2VudEM2NCkge1xyXG4gIGM2NCA9IG5hc2NlbnRDNjQ7XHJcblxyXG4gIGNhbnZhcyAgICA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmFtQWNjZXNzQ2FudmFzXCIpO1xyXG4gIGNvbnRleHQgICA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgMjU2LCAyNTYpO1xyXG4gIGJpdG1hcCAgICA9IGltYWdlRGF0YS5kYXRhOyAgXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9uRW50ZXIoKSB7XHJcbiAgY2xlYXJDYW52YXMoKTtcclxuICBibGl0Q2FudmFzKCk7XHJcblxyXG4gIGM2NC5ob29rcy5vblJhbVJlYWQgPSAoYWRkcikgPT4ge1xyXG4gICAgLy8gKzEgPSBncmVlblxyXG4gICAgYml0bWFwWyhhZGRyICogNCkgKyAxXSA9IDI1NTtcclxuICB9O1xyXG5cclxuICBjNjQuaG9va3Mub25SYW1Xcml0ZSA9IChhZGRyKSA9PiB7XHJcbiAgICAvLyArMCA9IHJlZFxyXG4gICAgYml0bWFwWyhhZGRyICogNCkgKyAwXSA9IDI1NTtcclxuICB9O1xyXG5cclxuICBjNjQuaG9va3Mub25WaWNSZWFkID0gKGFkZHIpID0+IHtcclxuICAgIC8vICsyID0gYmx1ZVxyXG4gICAgYml0bWFwWyhhZGRyICogNCkgKyAyXSA9IDI1NTtcclxuICB9O1xyXG5cclxuICBjNjQuaG9va3Mub25GcmFtZUVuZCA9ICgpID0+IHtcclxuICAgIGJsaXRDYW52YXMoKTtcclxuICAgIGNsZWFyQ2FudmFzKCk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gb25FeGl0KCkge1xyXG4gIGM2NC5ob29rcy5vblJhbVJlYWQgID0gdW5kZWZpbmVkO1xyXG4gIGM2NC5ob29rcy5vblJhbVdyaXRlID0gdW5kZWZpbmVkO1xyXG4gIGM2NC5ob29rcy5vblZpY1JlYWQgID0gdW5kZWZpbmVkO1xyXG4gIGM2NC5ob29rcy5vbkZyYW1lRW5kID0gdW5kZWZpbmVkO1xyXG59XHJcblxyXG5mdW5jdGlvbiBibGl0Q2FudmFzKCkge1xyXG4gIGNvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNsZWFyQ2FudmFzKCkge1xyXG4gIGxldCBpbmRleCA9IDA7XHJcblxyXG4gIGZvciAobGV0IHkgPSAwOyB5IDwgMjU2OyB5KyspIHtcclxuICAgIGZvciAobGV0IHggPSAwOyB4IDwgMjU2OyB4KyspIHtcclxuICAgICAgYml0bWFwW2luZGV4KytdID0gMDtcclxuICAgICAgYml0bWFwW2luZGV4KytdID0gMDtcclxuICAgICAgYml0bWFwW2luZGV4KytdID0gMDsgXHJcbiAgICAgIGJpdG1hcFtpbmRleCsrXSA9IDI1NTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCByYW1BY2Nlc3MgPSB7XHJcbiAgZG9tSWQ6IFwicmFtQWNjZXNzU2NvcGVcIixcclxuICBvbkVudGVyLFxyXG4gIG9uRXhpdCxcclxuICBhdHRhY2gsXHJcbn07XHJcbiIsImltcG9ydCB7IHNldEhhc1Njb3BlIH0gZnJvbSBcIi4uL3ZpZGVvLWNhbnZhc1wiO1xyXG5pbXBvcnQgeyBjb2xsaXNpb24gfSBmcm9tIFwiLi9jb2xsaXNpb25TY29wZVwiO1xyXG5pbXBvcnQgeyByYW1BY2Nlc3MgfSBmcm9tIFwiLi9yYW1BY2Nlc3NTY29wZVwiO1xyXG5pbXBvcnQgY3NzIGZyb20gXCIuL3Njb3Blcy5jc3NcIjtcclxuXHJcbmxldCBjNjQ7XHJcbmxldCBpc1Nob3dpbmcgPSBmYWxzZTtcclxuLy8gYHNlbGVjdGVkU2NvcGVgOiBzZWxlY3RlZCwgYnV0IG5vdCBuZWNlc3NhcmlseSBhY3RpdmVcclxubGV0IHNlbGVjdGVkU2NvcGUgPSBcInNwcml0ZXNcIjtcclxuXHJcbmNvbnN0IHNjb3BlcyA9IHtcclxuICAvLyBLZXlzIHNob3VsZCBtYXRjaCB0aGUgPG9wdGlvbj4gdGFnJ3MgYHZhbHVlYC5cclxuICBzcHJpdGVzOiB7XHJcbiAgICBkb21JZDogICAgICAgXCJzcHJpdGVTY29wZVwiLFxyXG4gICAgb25FbnRlcjogICAgICgpID0+IGM2NC52aWMuc2V0U2NvcGUoXCJzY29wZVNwcml0ZXNcIiksXHJcbiAgICBvbkV4aXQ6ICAgICAgKCkgPT4gYzY0LnZpYy5zZXRTY29wZShudWxsKSxcclxuICB9LFxyXG4gIGJhY2tncm91bmQ6IHtcclxuICAgIGRvbUlkOiAgICAgICBcImJhY2tncm91bmRTY29wZVwiLFxyXG4gICAgb25FbnRlcjogICAgICgpID0+IGM2NC52aWMuc2V0U2NvcGUoXCJzY29wZUJhY2tncm91bmRcIiksXHJcbiAgICBvbkV4aXQ6ICAgICAgKCkgPT4gYzY0LnZpYy5zZXRTY29wZShudWxsKSxcclxuICB9LFxyXG4gIGNvbGxpc2lvbixcclxuICBjb2xvclJhbToge1xyXG4gICAgb25FbnRlcjogICAgICgpID0+IGM2NC52aWMuc2V0U2NvcGUoXCJzY29wZUNvbG9yUmFtXCIpLFxyXG4gICAgb25FeGl0OiAgICAgICgpID0+IGM2NC52aWMuc2V0U2NvcGUobnVsbCksXHJcbiAgfSxcclxuICByYW1BY2Nlc3MsXHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaW5pdFNjb3BlcyhuYXNjZW50QzY0KSB7XHJcbiAgYzY0ID0gbmFzY2VudEM2NDtcclxuXHJcbiAgY29uc3Qgc2VsZWN0RWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNjb3BlU2VsZWN0XCIpO1xyXG5cclxuICBzZWxlY3RFbFxyXG4gICAgLmFkZEV2ZW50TGlzdGVuZXIoXHJcbiAgICAgIFwiY2hhbmdlXCIsXHJcbiAgICAgIChldmVudCkgPT4ge1xyXG4gICAgICAgIHN0b3BTY29wZSgpO1xyXG4gICAgICAgIGhpZGVTY29wZSgpO1xyXG4gICAgICAgIHNlbGVjdGVkU2NvcGUgPSBzZWxlY3RFbC52YWx1ZTtcclxuICAgICAgICBzaG93U2NvcGUoKTtcclxuICAgICAgICBzdGFydFNjb3BlKCk7XHJcbiAgICAgIH1cclxuICAgIClcclxuICA7XHJcblxyXG4gIGZvciAoY29uc3QgWyx7IGF0dGFjaCwgZG9tSWQgfV0gb2YgT2JqZWN0LmVudHJpZXMoc2NvcGVzKSkge1xyXG4gICAgaWYgKGRvbUlkKSB7XHJcbiAgICAgIGRvY3VtZW50XHJcbiAgICAgICAgLmdldEVsZW1lbnRCeUlkKGRvbUlkKVxyXG4gICAgICAgIC5jbGFzc0xpc3RcclxuICAgICAgICAuYWRkKFwiaGlkZGVuXCIpXHJcbiAgICAgIDtcclxuICAgIH1cclxuICAgIGlmIChhdHRhY2gpIGF0dGFjaChuYXNjZW50QzY0KTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b2dnbGVTY29wZXMoKSB7XHJcbiAgaXNTaG93aW5nID0gIWlzU2hvd2luZztcclxuXHJcbiAgLy8gVGVsbCB0aGUgbGF5b3V0IG1hbmFnZXIgdGhlIHNpZGUgcGFuZWwncyBtb3ZpbmdcclxuICBzZXRIYXNTY29wZShpc1Nob3dpbmcpO1xyXG5cclxuICAvLyBPcGVuIG9yIGNsb3NlIHRoZSBzaWRlIHBhbmVsLCBhbmQgc3RhcnQvc3RvcCB0aGUgc2VsZWN0ZWQgc2NvcGVcclxuICBjb25zdCBzY29wZVJhaWwgICAgICAgID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzY29wZVJhaWxcIik7XHJcbiAgY29uc3Qgc2NvcGVSYWlsQmxhbmtldCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2NvcGVSYWlsLWJsYW5rZXRcIik7XHJcblxyXG4gIGlmIChpc1Nob3dpbmcpIHtcclxuICAgIHNjb3BlUmFpbC5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpO1xyXG4gICAgc2NvcGVSYWlsQmxhbmtldC5jbGFzc0xpc3QuYWRkKFwiaGlkZGVuXCIpO1xyXG4gICAgc3RhcnRTY29wZSgpO1xyXG4gIH1cclxuICBlbHNlIHtcclxuICAgIHNjb3BlUmFpbC5jbGFzc0xpc3QuYWRkKFwiaGlkZGVuXCIpO1xyXG4gICAgc2NvcGVSYWlsQmxhbmtldC5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpO1xyXG4gICAgc3RvcFNjb3BlKCk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzdGFydFNjb3BlKCkge1xyXG4gIGNvbnN0IHsgZG9tSWQsIG9uRW50ZXIgfSA9IHNjb3Blc1tzZWxlY3RlZFNjb3BlXTtcclxuICBpZiAoZG9tSWQpIHtcclxuICAgIGRvY3VtZW50XHJcbiAgICAgIC5nZXRFbGVtZW50QnlJZChkb21JZClcclxuICAgICAgLmNsYXNzTGlzdFxyXG4gICAgICAucmVtb3ZlKFwiaGlkZGVuXCIpXHJcbiAgICA7XHJcbiAgfVxyXG4gIG9uRW50ZXIoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc3RvcFNjb3BlKCkge1xyXG4gIGNvbnN0IHsgb25FeGl0IH0gPSBzY29wZXNbc2VsZWN0ZWRTY29wZV07XHJcbiAgb25FeGl0KCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhpZGVTY29wZSgpIHtcclxuICBjb25zdCB7IGRvbUlkIH0gPSBzY29wZXNbc2VsZWN0ZWRTY29wZV07XHJcbiAgaWYgKGRvbUlkKSB7XHJcbiAgICBkb2N1bWVudFxyXG4gICAgICAuZ2V0RWxlbWVudEJ5SWQoZG9tSWQpXHJcbiAgICAgIC5jbGFzc0xpc3RcclxuICAgICAgLmFkZChcImhpZGRlblwiKVxyXG4gICAgO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc2hvd1Njb3BlKCkge1xyXG4gIGNvbnN0IHsgZG9tSWQgfSA9IHNjb3Blc1tzZWxlY3RlZFNjb3BlXTtcclxuICBpZiAoZG9tSWQpIHtcclxuICAgIGRvY3VtZW50XHJcbiAgICAgIC5nZXRFbGVtZW50QnlJZChkb21JZClcclxuICAgICAgLmNsYXNzTGlzdFxyXG4gICAgICAucmVtb3ZlKFwiaGlkZGVuXCIpXHJcbiAgICA7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IHNldEhhc1NuYXBzaG90cyB9IGZyb20gXCIuLi92aWRlby1jYW52YXNcIjtcclxuaW1wb3J0IGNzcyBmcm9tIFwiLi9zbmFwc2hvdHMuY3NzXCI7XHJcblxyXG5sZXQgbnVtU25hcHNob3RzU2hvd2luZyA9IDA7XHJcbmxldCBsYXN0U25hcHNob3ROdW0gPSAwO1xyXG5cclxubGV0IG1hc2tDYW52YXM7XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVTbmFwc2hvdENhbnZhcygpIHtcclxuXHJcbiAgLy8gV291bGQgcHJvYi4gYmUgYmV0dGVyIHRvIGFzayB2aWRlby1jYW52YXMgZm9yIGl0cyBlbGVtZW50IGluc3RlYWRcclxuICBjb25zdCBtYWluQ2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjYW52YXNcIik7XHJcblxyXG4gIC8vIENyZWF0ZSB0aGUgMTcwMS1tb25pdG9yLWJlemVsIG1hc2sgY2FudmFzIGlmIHdlIGhhdmVuJ3QgYWxyZWFkeVxyXG4gIGlmICghbWFza0NhbnZhcykge1xyXG4gICAgbWFza0NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XHJcblxyXG4gICAgbWFza0NhbnZhcy53aWR0aCAgPSBtYWluQ2FudmFzLndpZHRoO1xyXG4gICAgbWFza0NhbnZhcy5oZWlnaHQgPSBtYWluQ2FudmFzLmhlaWdodDtcclxuXHJcbiAgICBjb25zdCBjb250ZXh0ID0gbWFza0NhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcblxyXG4gICAgLy8gRmlsbCBjb2xvciBpcyBpcnJlbGV2YW50OyB3ZSdyZSBqdXN0IHJlbHlpbmcgb24gYWxwaGEgY2hhbm5lbFxyXG4gICAgY29udGV4dC5maWxsKFxyXG4gICAgICBuZXcgUGF0aDJEKFxyXG4gICAgICAgIFwiTTM4Ni43OSwxNDFzLjEsMjkuODktMSw1OS4yNmMtMSwyNi42NS0zLjMsNTIuODYtNC4yMSw1Ni4wNy0yLjIyLDcuOC0zLjc1LDE3Ljg3LTE4LjgzLDIwLjQ2LTguMzgsMS40NC0zNC41MywyLjg0LTYyLjk1LDMuNjVDMjUzLjgsMjgxLjc1LDIwMSwyODIsMjAxLDI4MnMtNTIuOC0uMjUtOTguNzYtMS41NmMtMjguNDItLjgxLTU0LjU3LTIuMjEtNjIuOTUtMy42NS0xNS4wOC0yLjU5LTE2LjYxLTEyLjY2LTE4LjgzLTIwLjQ2LS45MS0zLjIxLTMuMTctMjkuNDItNC4yMS01Ni4wNy0xLjE0LTI5LjM3LTEtNTkuMjYtMS01OS4yNnMtLjEtMjkuODksMS01OS4yNmMxLTI2LjY1LDMuMy01Mi44Niw0LjIxLTU2LjA3LDIuMjItNy44LDMuNzUtMTcuODcsMTguODMtMjAuNDYsOC4zOC0xLjQ0LDM0LjUzLTIuODQsNjMtMy42NUMxNDguMi4yNSwyMDEsMCwyMDEsMHM1Mi44LjI1LDk4Ljc2LDEuNTZjMjguNDIuODEsNTQuNTcsMi4yMSw2Mi45NSwzLjY1LDE1LjA4LDIuNTksMTYuNjEsMTIuNjYsMTguODMsMjAuNDYuOTEsMy4yMSwzLjE3LDI5LjQyLDQuMjEsNTYuMDdDMzg2Ljg5LDExMS4xMSwzODYuNzksMTQxLDM4Ni43OSwxNDFaXCJcclxuICAgICAgKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XHJcblxyXG4gIGNhbnZhcy53aWR0aCAgPSBtYWluQ2FudmFzLndpZHRoO1xyXG4gIGNhbnZhcy5oZWlnaHQgPSBtYWluQ2FudmFzLmhlaWdodDtcclxuXHJcbiAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcblxyXG4gIGNvbnRleHQuZHJhd0ltYWdlKG1hc2tDYW52YXMsIDAsIDApO1xyXG4gIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJzb3VyY2UtaW5cIjtcclxuICBjb250ZXh0LmRyYXdJbWFnZShtYWluQ2FudmFzLCAwLCAwKTtcclxuXHJcbiAgcmV0dXJuIGNhbnZhcztcclxufVxyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0YWtlU25hcHNob3QoYzY0KSB7XHJcblxyXG4gIGxldCBhbGl2ZSA9IHRydWU7XHJcblxyXG4gIC8vIFRPRE86IGluYXBwcm9wcmlhdGUgbmFtZSBub3dcclxuICBjb25zdCBidWJibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG5cclxuICBjb25zdCBpbm5lckZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICBidWJibGUuYXBwZW5kKGlubmVyRnJhbWUpO1xyXG4gIGlubmVyRnJhbWUuY2xhc3NMaXN0LmFkZChcImlubmVyRnJhbWVcIik7XHJcblxyXG4gIGNvbnN0IHsgY2xhc3NMaXN0IH0gPSBidWJibGU7XHJcblxyXG4gIGNsYXNzTGlzdC5hZGQoXCJzbmFwc2hvdFwiKTtcclxuICBjbGFzc0xpc3QuYWRkKFwiY29sbGFwc2VkXCIpO1xyXG5cclxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoXHJcbiAgICAoKSA9PiB7XHJcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShcclxuICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKFwiY29sbGFwc2VkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgKTtcclxuICAgIH1cclxuICApO1xyXG5cclxuXHJcbiAgY29uc3QgY2xvc2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xyXG4gIGNsb3NlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiY2xvc2VcIik7XHJcblxyXG4gIGNsb3NlLmFkZEV2ZW50TGlzdGVuZXIoXHJcbiAgICBcImNsaWNrXCIsXHJcbiAgICAoZXZlbnQpID0+IHtcclxuICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbiAgICAgIGlmIChhbGl2ZSkge1xyXG4gICAgICAgIG9uQ2xvc2UoY2xhc3NMaXN0KTtcclxuICAgICAgICBhbGl2ZSA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgKTtcclxuXHJcbiAgaW5uZXJGcmFtZS5hcHBlbmQoY2xvc2UpO1xyXG5cclxuICBjb25zdCBidXR0b24gPSAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcclxuXHJcbiAgY29uc3QgY2FudmFzID0gY3JlYXRlU25hcHNob3RDYW52YXMoKTtcclxuXHJcbiAgZG9jdW1lbnRcclxuICAgIC5nZXRFbGVtZW50QnlJZChcInNuYXBzaG90c1JhaWxcIilcclxuICAgIC5wcmVwZW5kKGJ1YmJsZSlcclxuICA7XHJcblxyXG4gIGNvbnN0IHNlcmlhbCA9IGM2NC5ydW5sb29wLnNlcmlhbGl6ZSgpO1xyXG4gIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihcclxuICAgIEFycmF5LmZyb20oXHJcbiAgICAgIC8vIGBzZXJpYWxgIGlzIHNlcmlhbGl6ZWQsIGJ1dCB3ZSdsbCBKU09OIGVuY29kZSBpdCBmb3IgdGVzdGluZyBpbiBzb3VyY2VcclxuICAgICAgLy8gZm9yIG5vdy4gV2Ugd29uJ3QgbmVlZCB0aGF0IGxhdGVyLlxyXG4gICAgICBKU09OLnN0cmluZ2lmeShzZXJpYWwpXHJcbiAgICApLFxyXG4gICAgeyB0eXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9XHJcbiAgKTtcclxuXHJcbiAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xyXG4gIGxpbmsuaW5uZXJUZXh0ID0gYCR7KytsYXN0U25hcHNob3ROdW19Lmpzb25gO1xyXG4gIGxpbmsuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcblxyXG4gIGxpbmsuYWRkRXZlbnRMaXN0ZW5lcihcclxuICAgIFwiY2xpY2tcIixcclxuICAgIChldmVudCkgPT4ge1xyXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgICAgb25DbGlja1NuYXBzaG90KGM2NCwgc2VyaWFsKVxyXG4gICAgfVxyXG4gICk7XHJcblxyXG4gIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFxyXG4gICAgXCJjbGlja1wiLFxyXG4gICAgKCkgPT4gb25DbGlja1NuYXBzaG90KGM2NCwgc2VyaWFsKVxyXG4gICk7XHJcblxyXG4gIGJ1YmJsZS5hZGRFdmVudExpc3RlbmVyKFxyXG4gICAgXCJ0cmFuc2l0aW9uZW5kXCIsXHJcbiAgICAoZXZlbnQpID0+IHtcclxuICAgICAgb25UcmFuc2l0aW9uRW5kKGV2ZW50LCBidWJibGUsIGFsaXZlKTtcclxuICAgIH1cclxuICApO1xyXG5cclxuICBidXR0b24uYXBwZW5kKGNhbnZhcyk7XHJcblxyXG4gIGlubmVyRnJhbWUuYXBwZW5kKGJ1dHRvbik7XHJcbiAgaW5uZXJGcmFtZS5hcHBlbmQobGluayk7XHJcblxyXG4gIG51bVNuYXBzaG90c1Nob3dpbmcrKztcclxuICByZWNvbnNpZGVyU25hcHNob3RSYWlsKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9uQ2xpY2tTbmFwc2hvdChjNjQsIHNlcmlhbCkge1xyXG4gIGM2NC5ydW5sb29wLnN0b3AoKTtcclxuICBjNjQucnVubG9vcC5yZXNldCgpO1xyXG4gIGM2NC5ydW5sb29wLmRlc2VyaWFsaXplKHNlcmlhbCk7XHJcbiAgYzY0LnJ1bmxvb3AucnVuKCk7IFxyXG59XHJcblxyXG5mdW5jdGlvbiByZWNvbnNpZGVyU25hcHNob3RSYWlsKCkge1xyXG4gIC8vIFVubGlrZSB0aGUgc2NvcGVSYWlsLCB0aGUgc25hcHNob3RzIHJhaWwgZG9lc24ndCBuZWVkIGEgYmxhbmtldC4gVGhlIG9ubHlcclxuICAvLyB3ZSBmb3IgaXQgdG8gYmUgaGlkZGVuIGlzIGlmIGFsbCB0aGUgc25hcHNob3RzIGhhdmUgYmVlbiBkZWxldGVkOyBoZW5jZSB3ZVxyXG4gIC8vIGRvbid0IG5lZWQgdG8gd29ycnkgYWJvdXQgY2xpY2tpbmcgb24gb25lIHRoYXQgd2Fzbid0IHRoZXJlLlxyXG5cclxuICBjb25zdCBzaG91bGRTaG93ID0gbnVtU25hcHNob3RzU2hvd2luZyA+IDA7XHJcbiAgc2V0SGFzU25hcHNob3RzKHNob3VsZFNob3cpO1xyXG5cclxuICBjb25zdCB7IGNsYXNzTGlzdCB9ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzbmFwc2hvdHNSYWlsXCIpO1xyXG5cclxuICBpZiAoc2hvdWxkU2hvdykgY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcclxuICBlbHNlICAgICAgICAgICAgY2xhc3NMaXN0LmFkZCAgIChcImhpZGRlblwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gb25UcmFuc2l0aW9uRW5kKGV2ZW50LCBidWJibGUsIGFsaXZlKSB7XHJcbiAgaWYgKGV2ZW50LnRhcmdldCAhPT0gYnViYmxlKSByZXR1cm47XHJcblxyXG4gIGlmICghYWxpdmUpIHtcclxuICAgIGNvbnNvbGUubG9nKFwib25UcmFuc2l0aW9uRW5kXCIpO1xyXG4gICAgYnViYmxlLnJlbW92ZSgpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gb25DbG9zZShjbGFzc0xpc3QpIHtcclxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoXHJcbiAgICAoKSA9PiB7XHJcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShcclxuICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKFwiY29sbGFwc2VkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgKTtcclxuICAgIH1cclxuICApO1xyXG5cclxuICAvLyB0cmFuc2l0aW9uZW5kIGhhbmRsZXIgd2lsbCByZW1vdmUgdGhlIGJ1YmJsZSBmcm9tIHRoZSBET00sIGJ1dCBmb3IgdGhlXHJcbiAgLy8gcHVycG9zZXMgb2Ygc2hvd2luZy9oaWRpbmcgdGhlIHJhaWwsIHdlJ2xsIGNvbnNpZGVyIGl0IHRvIGhhdmUgZ29uZVxyXG4gIC8vIGFscmVhZHkuXHJcbiAgbnVtU25hcHNob3RzU2hvd2luZy0tO1xyXG4gIHJlY29uc2lkZXJTbmFwc2hvdFJhaWwoKTtcclxufVxyXG4iLCJpbXBvcnQgeyBpbml0VXBwZXJUcmF5IH0gZnJvbSBcIi4vdXBwZXJUcmF5XCI7XHJcbmltcG9ydCB7IGluaXRMb3dlclRyYXkgfSBmcm9tIFwiLi9sb3dlclRyYXlcIjtcclxuaW1wb3J0IHsgc2V0SGFzVHJheXMgfSAgIGZyb20gXCIuLi92aWRlby1jYW52YXNcIjtcclxuaW1wb3J0IGNzcyAgICAgICAgICAgICAgIGZyb20gXCIuL3RyYXlzLmNzc1wiO1xyXG5cclxubGV0IGlzU2hvd2luZyA9IGZhbHNlO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvZ2dsZVRyYXlzKCkge1xyXG4gIGlzU2hvd2luZyA9ICFpc1Nob3dpbmc7XHJcblxyXG4gIGNvbnN0IHVwcGVyVHJheSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidXBwZXJUcmF5XCIpO1xyXG4gIGNvbnN0IHVwcGVyVHJheUJsYW5rZXQgPSB1cHBlclRyYXkuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcInRyYXktYmxhbmtldFwiKVswXTtcclxuXHJcbiAgY29uc3QgdHJheUNsYXNzTGlzdCAgICA9IHVwcGVyVHJheSAgICAgICAuY2xhc3NMaXN0O1xyXG4gIGNvbnN0IGJsYW5rZXRDbGFzc0xpc3QgPSB1cHBlclRyYXlCbGFua2V0LmNsYXNzTGlzdDtcclxuXHJcbiAgaWYgKGlzU2hvd2luZykge1xyXG4gICAgdHJheUNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIik7XHJcbiAgICBibGFua2V0Q2xhc3NMaXN0LmFkZChcImhpZGRlblwiKTtcclxuICB9XHJcbiAgZWxzZSB7XHJcbiAgICB0cmF5Q2xhc3NMaXN0LmFkZChcImhpZGRlblwiKTtcclxuICAgIGJsYW5rZXRDbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpO1xyXG4gIH1cclxuXHJcbiAgLy8gQXMgYWJvdmUsIHNvIGJlbG93XHJcbiAgY29uc3QgbG93ZXJUcmF5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsb3dlclRyYXlcIik7XHJcbiAgY29uc3QgbG93ZXJUcmF5QmxhbmtldCA9IGxvd2VyVHJheS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwidHJheS1ibGFua2V0XCIpWzBdO1xyXG5cclxuICBsb3dlclRyYXkuY2xhc3NMaXN0ID0gdHJheUNsYXNzTGlzdDtcclxuICBsb3dlclRyYXlCbGFua2V0LmNsYXNzTGlzdCA9IGJsYW5rZXRDbGFzc0xpc3Q7XHJcblxyXG4gIHNldEhhc1RyYXlzKGlzU2hvd2luZyk7XHJcbiAgcmV0dXJuIGlzU2hvd2luZztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGluaXRUcmF5cyhuYXNjZW50QzY0KSB7XHJcbiAgaW5pdFVwcGVyVHJheShuYXNjZW50QzY0KTtcclxuICBpbml0TG93ZXJUcmF5KG5hc2NlbnRDNjQpO1xyXG59XHJcbiIsImxldCBjNjQ7XHJcbmxldCBzZXJpYWwgPSBudWxsO1xyXG5sZXQgY291bnRkb3duSW50ZXJ2YWwgPSBudWxsO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGluaXRVcHBlclRyYXkobmFzY2VudEM2NCkge1xyXG4gIGM2NCA9IG5hc2NlbnRDNjQ7XHJcblxyXG4gIGhhbmRsZXJGb3JFdmVudEZvcklkKFxyXG4gICAgXCJyZXNldEJ1dHRvblwiLCBcclxuICAgIFwiY2xpY2tcIixcclxuICAgICgpID0+IHVuZG9hYmxlUmVzZXQoKVxyXG4gICk7XHJcblxyXG4gIGhhbmRsZXJGb3JFdmVudEZvcklkKFxyXG4gICAgXCJ1bmRvUmVzZXRCdXR0b25cIiwgXHJcbiAgICBcImNsaWNrXCIsXHJcbiAgICAoKSA9PiB7XHJcbiAgICAgIGlmIChzZXJpYWwpIHtcclxuICAgICAgICBjNjQucnVubG9vcC5kZXNlcmlhbGl6ZShzZXJpYWwpO1xyXG4gICAgICAgIGM2NC5ydW5sb29wLnJ1bigpO1xyXG4gICAgICAgIHJlbW92ZVVuZG9SZXNldEJ1dHRvbigpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaGFuZGxlckZvckV2ZW50Rm9ySWQoaWQsIGV2ZW50TmFtZSwgZm4pIHtcclxuICBkb2N1bWVudFxyXG4gICAgLmdldEVsZW1lbnRCeUlkKGlkKVxyXG4gICAgLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBmbilcclxuICA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVuZG9hYmxlUmVzZXQoKSB7XHJcbiAgc2VyaWFsID0gYzY0LnJ1bmxvb3Auc2VyaWFsaXplKCk7XHJcbiAgYzY0LnJ1bmxvb3AucmVzZXQoKTtcclxuICBjNjQucnVubG9vcC5ydW4oKTtcclxuXHJcbiAgcmVtb3ZlVW5kb1Jlc2V0QnV0dG9uKCk7XHJcbiAgYWRkVW5kb1Jlc2V0QnV0dG9uKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZVVuZG9SZXNldEJ1dHRvbigpIHtcclxuXHJcbiAgY29uc3QgWyByZXNldEJ1dHRvbiwgdW5kb1Jlc2V0QnV0dG9uLCBsYWJlbCBdID0gW1xyXG4gICAgXCJyZXNldEJ1dHRvblwiLFxyXG4gICAgXCJ1bmRvUmVzZXRCdXR0b25cIixcclxuICAgIFwidW5kb1Jlc2V0QnV0dG9uLWxhYmVsXCJcclxuICBdLm1hcCgoaWQpID0+IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSk7XHJcblxyXG4gIHJlc2V0QnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIik7XHJcbiAgdW5kb1Jlc2V0QnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIik7XHJcbiAgbGFiZWwuaW5uZXJUZXh0ID0gXCJcIjtcclxuXHJcbiAgaWYgKGNvdW50ZG93bkludGVydmFsKSB7XHJcbiAgICBjbGVhckludGVydmFsKGNvdW50ZG93bkludGVydmFsKTtcclxuICAgIGNvdW50ZG93bkludGVydmFsID0gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFVuZG9SZXNldEJ1dHRvbigpIHtcclxuXHJcbiAgY29uc3QgW1xyXG4gICAgcmVzZXRCdXR0b24sXHJcbiAgICB1bmRvUmVzZXRCdXR0b24sXHJcbiAgICBsYWJlbFxyXG4gIF0gPSBbXHJcbiAgICBcInJlc2V0QnV0dG9uXCIsXHJcbiAgICBcInVuZG9SZXNldEJ1dHRvblwiLFxyXG4gICAgXCJ1bmRvUmVzZXRCdXR0b24tbGFiZWxcIlxyXG4gIF0ubWFwKChpZCkgPT4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpKTtcclxuXHJcbiAgcmVzZXRCdXR0b24uY2xhc3NMaXN0LmFkZChcImhpZGRlblwiKTtcclxuICB1bmRvUmVzZXRCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcclxuXHJcbiAgY29uc3QgdXBkYXRlTGFiZWxDb3VudGRvd24gPSAoKSA9PiB7XHJcbiAgICBsYWJlbC5pbm5lclRleHQgPSBgVW5kbyAoJHtjb3VudGRvd259KWA7XHJcbiAgfTtcclxuICBcclxuICBsZXQgY291bnRkb3duID0gNjtcclxuICB1cGRhdGVMYWJlbENvdW50ZG93bigpO1xyXG5cclxuICBpZiAoY291bnRkb3duSW50ZXJ2YWwpIGNsZWFySW50ZXJ2YWwoY291bnRkb3duSW50ZXJ2YWwpO1xyXG5cclxuICBjb3VudGRvd25JbnRlcnZhbCA9IHNldEludGVydmFsKFxyXG4gICAgKCkgPT4ge1xyXG4gICAgICBpZiAoLS1jb3VudGRvd24gPT09IDApIHtcclxuICAgICAgICByZW1vdmVVbmRvUmVzZXRCdXR0b24oKTtcclxuICAgICAgICBzZXJpYWwgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgdXBkYXRlTGFiZWxDb3VudGRvd24oKTtcclxuICAgIH0sXHJcbiAgICAxMDAwXHJcbiAgKTtcclxufVxyXG4iLCJpbXBvcnQgeyBkaXNhc20gfSBmcm9tIFwiLi90b29scy9kaXNhc21cIjtcclxuaW1wb3J0IHsgcGV0c2NpaVRvQ2hhciwgeHgsICR4eCwgJHh4eHggfSBmcm9tIFwiLi9kZWJ1Z1wiO1xyXG5cclxuLy8gQm91bmQgYnkgYXR0YWNoXHJcbmxldCBjNjQ7XHJcbmxldCBydW5sb29wO1xyXG5sZXQgY2xpOyAgICAgICAgLy8gVE9ETzogdWdseVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGF0dGFjaChuYXNjZW50QzY0KSB7XHJcbiAgYzY0ID0gbmFzY2VudEM2NDtcclxuICBydW5sb29wID0gYzY0LnJ1bmxvb3A7XHJcbiAgaW5zdGFsbENsaSgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBoZWxwKCkge1xyXG4gIGNvbnNvbGUubG9nKFwiTW9uaXRvciBjb21tYW5kczpcIik7XHJcbiAgY29uc29sZS5sb2coXCItLS0tLS0tLS0tLS0tLS0tLVwiKTtcclxuICBjbGkuZm9yRWFjaChpID0+IGkuaGVscC5mb3JFYWNoKGogPT4gY29uc29sZS5sb2coaikpKTtcclxuICBjb25zb2xlLmxvZyhcIi0tLVwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaW5zdGFsbENsaSgpIHtcclxuICBjbGkgPSBbXHJcbiAgICB7XHJcbiAgICAgIG5hbWU6IFwiaFwiLFxyXG4gICAgICBoZWxwOiBbXHJcbiAgICAgICAgXCJoKCkgICAgICAgLSBoZWxwXCIsXHJcbiAgICAgIF0sXHJcbiAgICAgIGZuOiBoZWxwXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICBuYW1lOiBcImJcIixcclxuICAgICAgaGVscDogW1xyXG4gICAgICAgIFwiYigpICAgICAgIC0gc3RvcFwiXHJcbiAgICAgIF0sXHJcbiAgICAgIGZuOiBydW5sb29wLnN0b3AsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICBuYW1lOiBcImNcIixcclxuICAgICAgaGVscDogW1xyXG4gICAgICAgIFwiYygpICAgICAgIC0gY29udGludWUgZXhlY3V0aW9uICAgICAgICAgICBjKDB4ZmNlMikgICAgICAgICAtIGV4ZWN1dGUgZnJvbSAkZmNlMlwiLFxyXG4gICAgICBdLFxyXG4gICAgICBmbjogKGZyb20pID0+IHtcclxuICAgICAgICBpZiAoZnJvbSAhPT0gdW5kZWZpbmVkKSBjNjQuY3B1LmdldFN0YXRlKCkucGMgPSBmcm9tO1xyXG4gICAgICAgIHJ1bmxvb3AucnVuKCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIG5hbWU6IFwic1wiLFxyXG4gICAgICBoZWxwOiBbXHJcbiAgICAgICAgXCJzKCkgICAgICAgLSBzaW5nbGUtc3RlcCBpbnN0cnVjdGlvbiAgICAgIHMoNSkgICAgICAgICAgICAgIC0gc3RlcCA1IGluc3RydWN0aW9uc1wiLFxyXG5cclxuICAgICAgXSxcclxuICAgICAgZm46ICguLi5hcmdzKSA9PiB2b2lkIHNpbmdsZVN0ZXAoLi4uYXJncykgLy8gZG9uJ3QgcmV0dXJuIHRoZSBwcm9taXNlXHJcbiAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgIG5hbWU6IFwidVwiLFxyXG4gICAgICBoZWxwOiBbXHJcbiAgICAgICAgXCJ1KDB4ZTNhMCkgLSBydW4gdW50aWwgUEMgPSAkZTNhMCAgICAgICAgIHUoMHhlM2EwLCB0cnVlKSAgIC0gc2FtZSwgYXMgZmFzdCBhcyBwb3NzaWJsZVwiLFxyXG4gICAgICBdLFxyXG4gICAgICBmbjogdW50aWxQY1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgbmFtZTogXCJ3XCIsXHJcbiAgICAgIGhlbHA6IFtcclxuICAgICAgICBcIncoMHg0MDAsIDB4ZmYpIC0gd3JpdGUgJGZmIHRvICQwNDAwXCIsXHJcbiAgICAgIF0sXHJcbiAgICAgIGZuOiAoYWRkciwgYnl0ZSkgPT4gYzY0LndpcmVzLmNwdVdyaXRlKGFkZHIsIGJ5dGUpXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICBuYW1lOiBcInhcIixcclxuICAgICAgaGVscDogW1xyXG4gICAgICAgIFwieCgweDA0MDApIC0gc2hvdyBoZXggZnJvbSAkNDAwICAgICAgICAgICB4KDB4MDQwMCwgMHgxMDAwKSAtIHNob3cgZnJvbSAkMDQwMCB0byAkMTAwMFwiLFxyXG4gICAgICBdLFxyXG4gICAgICBmbjogKGZyb20sIHRvKSA9PiB7XHJcbiAgICAgICAgYnVzRHVtcChmcm9tLCBNYXRoLm1pbih0byA9PT0gdW5kZWZpbmVkID8gZnJvbSArIDB4N2YgOiB0byksIDB4ZmZmZik7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICAgIHtcclxuICAgICAgbmFtZTogXCJkXCIsXHJcbiAgICAgIGhlbHA6IFtcclxuICAgICAgICBcImQoMHg2MDAwKSAtIGRpc2Fzc2VtYmxlIGZyb20gJDYwMDAgICAgICAgZChyKCkucGMpICAgICAgICAgLSBkaXNhc3NlbWJsZSBmcm9tIFBDXCIsXHJcbiAgICAgIF0sXHJcbiAgICAgIGZuOiAoZnJvbSwgdG89MHgyMCArIGZyb20pID0+IGNvbnNvbGUubG9nKGRpc2FzbShjNjQud2lyZXMuY3B1UmVhZCwgZnJvbSwgdG8pKVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgbmFtZTogXCJyXCIsXHJcbiAgICAgIGhlbHA6IFtcclxuICAgICAgICBcInIoKSAgICAgICAtIHNob3cgcmVnaXN0ZXJzICAgICAgICAgICAgICAgcigpLmE9MHhhYiAgICAgICAgLSBzZXQgdGhlIGFjYyB0byAkYWJcIixcclxuICAgICAgXSxcclxuICAgICAgZm46ICgpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgYzY0LmNwdS5zaG93U3RhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKHIpIHt9XHJcbiAgICAgICAgcmV0dXJuIGM2NC5jcHUuZ2V0U3RhdGUoKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgbmFtZTogXCJ5XCIsXHJcbiAgICAgIGhlbHA6IFtcclxuICAgICAgICBcInkoMzcwMDAwKSAtIHJ1biB1bnRpbCBjeWNsZSAzNzAwMDBcIixcclxuICAgICAgXSxcclxuICAgICAgZm46IHVudGlsQ3ljbGVcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIG5hbWU6IFwiZlwiLFxyXG4gICAgICBoZWxwOiBbXHJcbiAgICAgICAgXCJmKDUpICAgICAgLSBydW4gYXQgNSBmcmFtZXMvc2Vjb25kXCIsXHJcbiAgICAgIF0sXHJcbiAgICAgIGZuOiBmcHMgPT4gcnVubG9vcC5ydW4oeyBmcHMgfSlcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIG5hbWU6IFwielwiLFxyXG4gICAgICBoZWxwOiBbXHJcbiAgICAgICAgXCJ6KCkgICAgICAgLSByZXNldFwiLFxyXG4gICAgICBdLFxyXG4gICAgICBmbjogKCkgPT4ge1xyXG4gICAgICAgIHJ1bmxvb3AucmVzZXQoKTtcclxuICAgICAgICBydW5sb29wLnJ1bigpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gIF07XHJcblxyXG4gIGNsaS5mb3JFYWNoKFxyXG4gICAgaSA9PiB7XHJcbiAgICAgIGdsb2JhbFRoaXNbaS5uYW1lXSA9IGkuZm47XHJcbiAgICB9XHJcbiAgKTtcclxuXHJcbiAgaGVscCgpO1xyXG5cclxuICAvLyBTdHJpY3RseSBmb3IgdGhlIHVzZXIgdG8gdXNlLCB0aHJvdWdoIHRoZSBKYXZhU2NyaXB0IGNvbnNvbGVcclxuICBnbG9iYWxUaGlzLmM2NCA9IGM2NDtcclxufVxyXG5cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIHNpbmdsZVN0ZXAoc3RlcHMgPSAxKSB7XHJcbiAgd2hpbGUgKHN0ZXBzLS0pIHtcclxuICAgIGNvbnN0IGluaXRpYWxQYyA9IGM2NC5jcHUuZ2V0U3RhdGUoKS5wYztcclxuICAgIGF3YWl0IHJ1bmxvb3AucnVuKHtcclxuICAgICAgdGljazogKCkgPT4gYzY0LmNwdS5nZXRTdGF0ZSgpLnBjICE9PSBpbml0aWFsUGNcclxuICAgIH0pO1xyXG4gICAgYzY0LmNwdS5zaG93U3RhdGUoKTtcclxuICB9XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIHVudGlsUGMocGMsIGZhc3QpIHtcclxuICBpZiAocGMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgY29uc29sZS5lcnJvcihcIk1pc3NpbmcgYXJndW1lbnQ6IFBDIGFkZHJlc3NcIik7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBhd2FpdCBydW5sb29wLnVudGlsUGMocGMsIGZhc3QpO1xyXG4gIGM2NC5jcHUuc2hvd1N0YXRlKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVudGlsQ3ljbGUoY3ljbGUpIHtcclxuICBjb25zdCBydW5sb29wU3RhdGUgPSBydW5sb29wLmdldFN0YXRlKCk7XHJcbiAgcnVubG9vcC5ydW4oe1xyXG4gICAgdGljazogKCkgPT4gcnVubG9vcFN0YXRlLmN5Y2xlID49IGN5Y2xlLFxyXG4gICAgZnBzOiBJbmZpbml0eSxcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gYnVzRHVtcChmcm9tLCB0bykge1xyXG4gIGNvbnN0IHsgY3B1UmVhZCB9ID0gYzY0LndpcmVzO1xyXG4gIGNvbnN0IGRpc3BsYXlGcm9tID0gTWF0aC5mbG9vcihmcm9tIC8gMTYpICogMTY7XHJcbiAgY29uc3QgZGlzcGxheVRvICAgPSBNYXRoLmZsb29yKCAgdG8gLyAxNikgKiAxNjtcclxuXHJcbiAgZm9yIChsZXQgYWRkciA9IGRpc3BsYXlGcm9tOyBhZGRyIDw9IGRpc3BsYXlUbzsgYWRkciArPSAxNikge1xyXG5cclxuICAgIGxldCBsaW5lID0gXCJcIjtcclxuICAgIGxldCByYXcgPSBcIlwiO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xyXG5cclxuICAgICAgY29uc3QgYSA9IGFkZHIgKyBpO1xyXG4gICAgICBsZXQgaGV4ID0gXCIgIFwiO1xyXG4gICAgICBsZXQgY2hhciA9IFwiIFwiO1xyXG5cclxuICAgICAgaWYgKChhID49IGZyb20pICYmIChhIDw9IHRvKSkge1xyXG4gICAgICAgIGNvbnN0IGJ5dGUgPSBjcHVSZWFkKGEpO1xyXG4gICAgICAgIGhleCA9IHh4KGJ5dGUpO1xyXG4gICAgICAgIGNoYXIgPSBwZXRzY2lpVG9DaGFyW2J5dGVdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsaW5lICs9IGAgJHtoZXh9YDtcclxuICAgICAgaWYgKGkgPT09IDcpIGxpbmUgKz0gXCIgXCI7XHJcblxyXG4gICAgICByYXcgKz0gY2hhcjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhgJHskeHh4eChhZGRyKX06ICR7bGluZX0gICAke3Jhd31gKTtcclxuICB9XHJcbn1cclxuIiwiLypcclxuICAgYnJpbmd1cDogYSBib290c3RyYXBwaW5nIHNlcXVlbmNlciBmb3IgaW5pdGlhbGl6aW5nIHRoZSB2aXJ0dWFsIG1hY2hpbmUuXHJcbiAgXHJcbiAgIFRoZSBDNjQgaXMgYSBzeXN0ZW0gb2YgbXV0dWFsbHkgZGVwZW5kZW50IGNvbXBvbmVudHMuIFdlIGhhdmUgdG8gYmUgY2FyZWZ1bCxcclxuICAgaW4gc3RydWN0dXJpbmcgdGhlIGVtdWxhdG9yIHNvdXJjZXMsIHRoYXQgd2UgZG9uJ3QgaW50cm9kdWNlIGN5Y2xpY1xyXG4gICBkZXBlbmRlbmNpZXMgYmV0d2VlbiBtb2R1bGVzLCBhbmQgd2hlbiBpbml0aWFsaXppbmcgYSBjb21wb25lbnQsIHdlIGhhdmUgdG9cclxuICAgZ3VhcmFudGVlIHRoYXQgaXQgZG9lc24ndCB0cnkgaW50ZXJhY3Rpbmcgd2l0aCBhbm90aGVyIGNvbXBvbmVudCB0aGF0IGhhc24ndFxyXG4gICBpdHNlbGYgeWV0IGluaXRpYWxpemVkLlxyXG4gIFxyXG4gICBUaGlzIG1vZHVsZSBvcmNoZXN0cmF0ZXMgdGhpcyBicmluZ3VwLiBTdXBwbHkgaXQgd2l0aCBhIHN0cnVjdHVyZSBvZlxyXG4gICBjb21wb25lbnRzIHJlcHJlc2VudGluZyB0aGUgd2hvbGUgbWFjaGluZSwgYW5kIGl0J2xsIGdldCBpdCBzdGFydGVkLlxyXG4qL1xyXG5cclxuaW1wb3J0IHsgYXR0YWNoIGFzIHJ1bmxvb3AgfSBmcm9tIFwiLi9ydW5sb29wXCI7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYnJpbmd1cCh7XHJcbiAgaG9zdDogICB7IGF1ZGlvLCB2aWRlbywga2V5Ym9hcmQsIGpveXN0aWNrIH0sXHJcbiAgdGFyZ2V0OiB7IHdpcmVzLCByYW0sIHZpYywgc2lkLCBjcHUsIGNpYXMsIHRhcGUsIGJhc2ljLCBrZXJuYWwsIGNoYXJhY3RlciB9LFxyXG4gIGF0dGFjaG1lbnRzXHJcbn0pIHtcclxuXHJcbiAgY29uc3QgYzY0ID0ge1xyXG4gICAgLy8gJ2hvb2tzJyBpcyBhIHdheSBmb3IgdGhlIHRhcmdldCBtYWNoaW5lIHRvIHRyaWdnZXIgYSBob3N0LXNpZGUgYWN0aW9uLFxyXG4gICAgLy8gZm9yIGV4YW1wbGUsIHVwZGF0aW5nIHRoZSBGUFMgY291bnQgb24gdGhlIFVJLCBpZiB0aGVyZSBpcyBvbmUuXHJcbiAgICAvLyBUYXJnZXQgc2hvdWxkbid0IGFzc3VtZSBhbnkgcGFydGljdWxhciBob29rIGlzIHByZXNlbnQsIGJ1dCB0aGUgcHJlc2VuY2VcclxuICAgIC8vIG9mIHRoZSBgaG9va3NgIG9iamVjdCBpcyBhdCBsZWFzdCBndWFyYW50ZWVkLlxyXG4gICAgaG9va3M6IHt9LFxyXG4gIH07XHJcblxyXG4gIC8vIEZpcnN0IHRoZSBST01zLCB3aGljaCwgYmVpbmcganVzdCBkYXRhLCBhcmUgdHJ1bHkgYXQgdGhlIGVuZCBvZiB0aGUgY2hhaW4uXHJcbiAgYzY0LnJvbSA9IHtcclxuICAgIGJhc2ljLFxyXG4gICAga2VybmFsLFxyXG4gICAgY2hhcmFjdGVyLFxyXG4gIH07XHJcblxyXG4gIC8vIC4uLmZvbGxvd2VkIGJ5IHRoZSBSQU0sIHdoaWNoIGxpa2V3aXNlIHdvbid0IGJlIGNhbGxpbmcgYW55b25lIGVsc2VcclxuICByYW0oYzY0KTtcclxuXHJcbiAgLy8gd2lyZXMgaGFzIHRvIGdvIG5leHQuIFRoZSBvbmUgZ3VhcmFudGVlIHRoYXQgb3RoZXIgbW9kdWxlcyBoYXZlIHdoaWxlXHJcbiAgLy8gaW5pdGlhbGl6aW5nIGlzIHRoYXQgaXRzIGZ1bmN0aW9ucyBhbmQgc3RhdGUgc3RydWN0dXJlIGFyZSBwcmVzZW50LlxyXG4gIC8vIChCdXQgbXVzdCBub3QgYmUgY2FsbGVkIHVudGlsIGFmdGVyIGluaXRpYWxpemF0aW9uLilcclxuICB3aXJlcyhjNjQpO1xyXG5cclxuICAvLyBIb3N0IGludGVyZmFjZXMgaGF2ZSB0byBhdHRhY2ggbmV4dCAoaW4gYW55IG9yZGVyKS5cclxuICAvLyBUaGUgdGFyZ2V0IGRldmljZXMgY2FuIGFzc3VtZSwgd2hlbiB0aGV5IGF0dGFjaCwgdGhhdCB0aGUgZnVuY3Rpb25zIGFuZFxyXG4gIC8vIG9iamVjdHMgZm9yIHRoZSBpbnRlcmZhY2VzIGFyZSBmaW5hbC5cclxuICBhdWRpbyhjNjQpO1xyXG4gIHZpZGVvKGM2NCk7XHJcbiAgam95c3RpY2soYzY0KTtcclxuICBrZXlib2FyZChjNjQpO1xyXG5cclxuICAvLyBOb3cgYWxsIHRoZSBkZXZpY2VzIChpbiBhbnkgb3JkZXIpLlxyXG4gIC8vIEVhY2ggc2hvdWxkIGFkZCBhIHN0cnVjdHVyZSB0byB0aGUgYzY0IGZvciB0aGVpclxyXG4gIC8vIHN0YXRlIGFuZCBhY2Nlc3NvcnMsIGFuZCB0aGUgZGV2aWNlIHNob3VsZCBiZSBpbiBhIHZhbGlkIHJlc2V0IHN0YXRlLCBidXRcclxuICAvLyBtdXN0IG5vdCBjYWxsIG90aGVyIGRldmljZXMgaW4gcmVzZXR0aW5nLCBzaW5jZSB0aGVyZSdzIG5vIGd1YXJhbnRlZSB0aGF0XHJcbiAgLy8gb3RoZXIgZGV2aWNlcyBhcmUgeWV0IGF0dGFjaGVkLlxyXG4gIC8vXHJcbiAgLy8gRm9yIGV4YW1wbGUsIENJQTIsIHdoZW4gYXNzaWduaW5nIGEgZGVmYXVsdCB2YWx1ZSBmb3IgaXRzIFZpYyBiYW5rLCBtdXN0XHJcbiAgLy8gbm90IHRoZW4gY2FsbCB3aXJlcyB0byBhbm5vdW5jZSB0aGUgY2hhbmdlIGluIG1lbW9yeSBtYXBwaW5nLiBSYXRoZXIsIHdlXHJcbiAgLy8gaGF2ZSB0byBjby1vcmRpbmF0ZSBvdXIgcmVzZXQgc3RhdGVzIHN1Y2ggdGhhdCB0aGUgZGV2aWNlcycgZGVmYXVsdCB2YWx1ZXNcclxuICAvLyBoYXBwZW4gdG8gYmUgY29uc2lzdGVudCB3aXRoIGVhY2ggb3RoZXIuXHJcbiAgdmljKGM2NCk7XHJcbiAgc2lkKGM2NCk7XHJcbiAgY2lhcyhjNjQpO1xyXG4gIGNwdShjNjQpO1xyXG4gIHRhcGUoYzY0KTtcclxuXHJcbiAgLy8gQnkgdGhpcyBwb2ludCB3ZSdyZSBkb25lLCBhbmQgbm8gbG9uZ2VyIGhhdmUgdG8gYmUgY2FyZWZ1bCBhYm91dCBvcmRlciBvZlxyXG4gIC8vIGV4ZWN1dGlvbi5cclxuICBydW5sb29wKGM2NCk7XHJcblxyXG4gIC8vIEFkZCBhbnkgYWRkaXRpb25hbCBhdHRhY2htZW50cyBmb3IgdGhpcyBjb25maWd1cmF0aW9uXHJcbiAgZm9yIChsZXQgYXR0YWNobWVudCBvZiBhdHRhY2htZW50cykgYXR0YWNobWVudChjNjQpO1xyXG5cclxuICByZXR1cm4gYzY0O1xyXG59XHJcbiIsIi8qXHJcbiAgIGNpYXM6IGVtdWxhdGVzIGJvdGggb2YgdGhlIDY1MjYgY29tcGxleCBpbnRlcmZhY2UgYWRhcHRvcnNcclxuXHJcbiAgIEFzIHdlbGwgYXMgZW11bGF0aW5nIHRoZSBDSUFzIHRoZW1zZWx2ZXMsIHRoaXMgbW9kdWxlIHByb3ZpZGVzIGludGVyZmFjaW5nXHJcbiAgIGZvciB0aGUgZGV2aWNlcyB0aGF0IHdvdWxkIGJlIGF0dGFjaGVkIHRvIHRoZW0uIEZvciBleGFtcGxlLCB3aGVuIGl0IHNlZXNcclxuICAgdGhhdCBhIG5ldyB2YWx1ZSB3aWxsIGJlIGVtaXR0ZWQgb24gQ0lBMiBwb3J0IEEsIGl0IHdpbGwgaW5zdHJ1Y3QgdGhlIFZpY1xyXG4gICBiYW5rLW1hcHBlciAoaW4gd2lyZXMpIHRoYXQgdGhlIFZpYyBiYW5rIGp1c3QgY2hhbmdlZC4gXHJcblxyXG4gICBUaGUgY29kZSBiZWxvdyByZXByZXNlbnRzIGEgZmFpbGVkIGF0dGVtcHQgYXQgbWFraW5nIHRoZSBDSUEgZW11bGF0aW9uXHJcbiAgIGN5Y2xlLWFjY3VyYXRlLiBJdHMgbmV4dFRpY2tGbiBhdHRlbXB0cyB0byBtb2RlbCB3aGF0IHRoZSBMb3JlbnogdGVzdHNcclxuICAgZXhwZWN0IHRvIHNlZSBoYXBwZW4gYXQgdmFyaW91cyBjeWNsZXMgYWZ0ZXIgZXZlbnRzLCBidXQgaXRzIG1vZGVsXHJcbiAgIG1pc3VuZGVyc3RhbmRzIHdoYXQncyByZWFsbHkgZ29pbmcgb24sIGFuZCBjYW4ndCBiZSBhZGp1c3RlZCB0byBwYXNzIHRoZVxyXG4gICB0ZXN0cy5cclxuXHJcbiAgIEZvciBhbiBhY2N1cmF0ZSBtb2RlbCwgc2VlIExvcmVueidzIG93biwgYXQ6XHJcbiAgICAgIGh0dHBzOi8vaXN0LnV3YXRlcmxvby5jYS9+c2NoZXBlcnMvTUpLL2NpYTY1MjYuaHRtbFxyXG5cclxuICAgU29tZSBhZGRpdGlvbmFsIGNhdmVhdHM6XHJcblxyXG4gICAtIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01PU19UZWNobm9sb2d5X0NJQVxyXG5cclxuICAgICAgXCJEdWUgdG8gYSBidWcgaW4gbWFueSA2NTI2cyAoc2VlIGFsc28gZXJyYXRhIGJlbG93KSwgdGhlIGFsYXJtIElSUSB3b3VsZFxyXG4gICAgICBub3QgYWx3YXlzIG9jY3VyIHdoZW4gdGhlIHNlY29uZHMgY29tcG9uZW50IG9mIHRoZSBhbGFybSB0aW1lIGlzIGV4YWN0bHlcclxuICAgICAgemVyby4gVGhlIHdvcmthcm91bmQgaXMgdG8gc2V0IHRoZSBhbGFybSdzIHRlbnRocyB2YWx1ZSB0byAwLjEgc2Vjb25kcy5cclxuXHJcbiAgICAgIEluIGFkZGl0aW9uIHRvIHRoZSBhZm9yZW1lbnRpb25lZCBhbGFybSBjbG9jayBpbnRlcnJ1cHQgYnVnLCBtYW55IENJQXNcclxuICAgICAgZXhoaWJpdGVkIGEgZGVmZWN0IGluIHdoaWNoIHRoZSBwYXJ0IHdvdWxkIGZhaWwgdG8gZ2VuZXJhdGUgYSB0aW1lciBCIFxyXG4gICAgICBoYXJkd2FyZSBpbnRlcnJ1cHQgaWYgdGhlIGludGVycnVwdCBjb250cm9sIHJlZ2lzdGVyIChJQ1IpIHdhcyByZWFkIG9uZVxyXG4gICAgICBvciB0d28gY2xvY2sgY3ljbGVzIGJlZm9yZSB0aGUgdGltZSB3aGVuIHRoZSBpbnRlcnJ1cHQgc2hvdWxkIGhhdmVcclxuICAgICAgYWN0dWFsbHkgb2NjdXJyZWQuIFRoaXMgZGVmZWN0LCBhcyB3ZWxsIGFzIGxvZ2ljIGVycm9ycyBpbiB0aGUgQ29tbW9kb3JlXHJcbiAgICAgIHByb3ZpZGVkICg4IGJpdCkgb3BlcmF0aW5nIHN5c3RlbSwgY2F1c2VkIGZyZXF1ZW50IHBzZXVkby1SUy0yMzIgZXJyb3JzXHJcbiAgICAgIGluIHRoZSBDb21tb2RvcmUgNjQgYW5kIENvbW1vZG9yZSAxMjggY29tcHV0ZXJzIHdoZW4gcnVubmluZyBhdCBoaWdoZXIgXHJcbiAgICAgIGJhdWQgcmF0ZXMuXCJcclxuXHJcbiAgIC0gaHR0cHM6Ly9jb2RlYmFzZTY0Lm9yZy9kb2t1LnBocD9pZD1iYXNlOmRldGVjdGluZ182NTI2X3ZzXzY1MjZhX2NpYV9jaGlwc1xyXG5cclxuICAgICAgXCJUaGlzIHNldHMgb2ZmIGEgc2luZ2xlLXNob3QgTk1JIHRvIGludGVycnVwdCBpbW1lZGlhdGVseSBiZWZvcmUgYW4gSU5DXHJcbiAgICAgIHN0YXRlbWVudC4gVGhlIG9sZGVyIDY1MjYgdHJpZ2dlcnMgb25lIGN5Y2xlIGxhdGVyLCBzbyBpdCB3aWxsIHJ1biB0aGVcclxuICAgICAgSU5DIHdoaWxlIHRoZSBuZXdlciBvbmUgd29uJ3QuXHJcbiovXHJcblxyXG4vLyBUT0RPOiBJIHJlYWxseSBuZWVkIHRvIHJlbmFtZSBpcnFfc3RhdHVzIGFuZCBpcnFfY29udHJvbCB0byBiZSBzb21ldGhpbmdcclxuLy8gbGlrZSAnaW50X3N0YXR1cycsIGV0Yy4gYXMgaXQgbWlnaHQgYmUgTk1JIHRoYXQgdGhleSByZWxhdGUgdG8uXHJcblxyXG5pbXBvcnQgeyAkeHgsICR4eHh4LCB1bmltcGxlbWVudGVkV2FybmluZyB9IGZyb20gXCIuLi9kZWJ1Z1wiO1xyXG5pbXBvcnQge1xyXG4gIGFkZFRvU2VyaWFsaXplclJlZ2lzdHJ5LFxyXG4gIGZ1bmN0aW9uVG9SZWZlcmVuY2UsXHJcbiAgcmVmZXJlbmNlVG9GdW5jdGlvbixcclxufSBmcm9tIFwiLi4vdG9vbHMvc2VyaWFsaXplclN1cHBvcnRcIjtcclxuXHJcbi8vIEJvdW5kIGJ5IGF0dGFjaFxyXG5sZXQgYzY0O1xyXG5sZXQgc2V0Q2lhMUlycTtcclxubGV0IHNldENpYTJObWk7XHJcbmxldCBzZXRWaWNCYW5rO1xyXG5cclxuY29uc3QgQ0xPQ0tfU1BFRUQgPSA5ODUyNDg7ICAgICAgICAgICAgICAgICAvLyBjeWNsZXMvc2Vjb25kIChQQUwgNTBIeilcclxuY29uc3QgdG9kT2Zmc2V0ICAgPSAxMCAqIDYwICogQ0xPQ0tfU1BFRUQ7ICAvLyAxMCBtaW51dGVzIGluIGN5Y2xlc1xyXG5cclxubGV0IHN0YXRlID0ge307XHJcblxyXG5jb25zdCBkZWZhdWx0VGltZXJSZWdzID0ge1xyXG4gIHZhbHVlX2xvOiAgICAgICAwLFxyXG4gIHZhbHVlX2hpOiAgICAgICAwLFxyXG4gIHN0YXJ0VmFsdWVfbG86ICAwLFxyXG4gIHN0YXJ0VmFsdWVfaGk6ICAwLFxyXG4gIGNvbnRyb2w6ICAgICAgICAwLFxyXG4gIHN0YXR1czogICAgICAgICAwLFxyXG4gIG5leHRUaWNrRm46ICAgICB0aWNrX3RpbWVyX3N0b3BwZWQsXHJcbn07XHJcblxyXG5jb25zdCBkZWZhdWx0UG9ydFJlZ3MgPSB7XHJcbiAgdmFsdWU6ICAgICAgICAgIDAsXHJcbiAgZGlyZWN0aW9uOiAgICAgIDAsXHJcbn07XHJcblxyXG5jb25zdCBtYWtlRGVmYXVsdENpYVJlZ3MgPSAoaXMxKSA9PiAoe1xyXG4gIGlzMSxcclxuICBwb3J0X2E6ICAgICAgICAgeyAuLi5kZWZhdWx0UG9ydFJlZ3MgfSxcclxuICBwb3J0X2I6ICAgICAgICAgeyAuLi5kZWZhdWx0UG9ydFJlZ3MgfSxcclxuICBzaGlmdDogICAgICAgICAgMCxcclxuICBpcnFfc3RhdHVzOiAgICAgMCxcclxuICBpcnFfY29udHJvbDogICAgMCxcclxuICB0b2RfMTB0aHM6ICAgICAgMCxcclxuICB0b2Rfc2Vjb25kczogICAgMCxcclxuICB0b2RfbWludXRlczogICAgMCxcclxuICB0b2RfaG91cnM6ICAgICAgMCxcclxuICB0aW1lcl9hOiAgICAgICAgeyBpc0E6IHRydWUsICAuLi5kZWZhdWx0VGltZXJSZWdzIH0sXHJcbiAgdGltZXJfYjogICAgICAgIHsgaXNBOiBmYWxzZSwgLi4uZGVmYXVsdFRpbWVyUmVncyB9LFxyXG59KTtcclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYXR0YWNoKG5hc2NlbnRDNjQpIHtcclxuICBjNjQgPSBuYXNjZW50QzY0O1xyXG5cclxuICBzZXRDaWExSXJxID0gYzY0LndpcmVzLnNldENpYTFJcnE7XHJcbiAgc2V0Q2lhMk5taSA9IGM2NC53aXJlcy5zZXRDaWEyTm1pO1xyXG4gIHNldFZpY0JhbmsgPSBjNjQud2lyZXMuc2V0VmljQmFuaztcclxuXHJcbiAgYzY0LmtleWJvYXJkLnNldFNldEtleU1hdHJpeChcclxuICAgIChrZXlNYXRyaXgpID0+IHtcclxuICAgICAgc3RhdGUua2V5TWF0cml4ID0ga2V5TWF0cml4O1xyXG4gICAgfVxyXG4gICk7XHJcblxyXG4gIGM2NC5qb3lzdGljay5zZXRTZXRKb3lzdGljazEoKHZhbHVlKSA9PiB7IHN0YXRlLmpveXN0aWNrMSA9IHZhbHVlOyB9KTtcclxuICBjNjQuam95c3RpY2suc2V0U2V0Sm95c3RpY2syKCh2YWx1ZSkgPT4geyBzdGF0ZS5qb3lzdGljazIgPSB2YWx1ZTsgfSk7XHJcblxyXG4gIGM2NC5jaWFzID0ge1xyXG4gICAgLy8gQ29udHJvbFxyXG4gICAgdGljayxcclxuICAgIHJlc2V0LFxyXG4gICAgc2VyaWFsaXplLFxyXG4gICAgZGVzZXJpYWxpemUsXHJcbiAgICAvLyBNTUlPXHJcbiAgICByZWFkX2RjMDBfZGNmZixcclxuICAgIHJlYWRfZGQwMF9kZGZmLFxyXG4gICAgd3JpdGVfZGMwMF9kY2ZmLFxyXG4gICAgd3JpdGVfZGQwMF9kZGZmLFxyXG4gICAgLy8gT3RoZXIgd2lyZXNcclxuICAgIHJhaXNlVGFwZUludGVycnVwdCxcclxuICB9O1xyXG5cclxuICByZXNldCgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXNldCgpIHtcclxuICBzdGF0ZSA9IHtcclxuICAgIGNpYTE6IG1ha2VEZWZhdWx0Q2lhUmVncyh0cnVlKSxcclxuICAgIGNpYTI6IG1ha2VEZWZhdWx0Q2lhUmVncyhmYWxzZSksXHJcblxyXG4gICAgLy8gam95c3RpY2sxL2pveXN0aWNrMiByZXByZXNlbnQgd2hhdCB0aGUgcmVzcGVjdGl2ZSBwb3J0IHZhbHVlcyB3b3VsZCBiZVxyXG4gICAgLy8gaW4gaXNvbGF0aW9uIChpZiBqb3lzdGljayBwb3J0IDEgd2Fzbid0IHNoYXJlZCB3aXRoIHRoZSBrZXlib2FyZCkuIExpbmVzXHJcbiAgICAvLyBmbG9hdCBoaWdoLlxyXG4gICAgam95c3RpY2sxOiAweGZmLFxyXG4gICAgam95c3RpY2syOiAweGZmLFxyXG5cclxuICAgIC8vIGtleU1hdHJpeDogd2hhdCB2YWx1ZXMgc2hvdWxkIGFwcGVhciBvbiBDSUExIHBvcnQgQiBmb3IgZWFjaCBvZiB0aGVcclxuICAgIC8vIGVpZ2h0IGJpdHMgdGhhdCBtaWdodCBiZSBzZWxlY3RlZCBvbiBpdHMgcG9ydCBBIHdyaXRlLCAqZXhjZXB0IHRoYXQqXHJcbiAgICAvLyAtIHRoZXkgYXBwZWFyIGludmVydGVkIGhlcmUgKHRoZXknbGwgYmUgZmxpcHBlZCBiYWNrIG9uIHJlYWQpLCBhbmQgXHJcbiAgICAvLyAtIHRoZSBqb3lzdGljayBwb3J0IDEgY29udHJpYnV0aW9uIGlzIHN0cmlwcGVkIG91dC5cclxuICAgIGtleU1hdHJpeDogWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdLFxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG51bWJlclRvQmNkKG51bSkge1xyXG4gIC8vIENvbnZlcnRzIDU5IC0+IDB4NTksIHJvdW5kaW5nIGRvd24gaWYgbnVtIGlzIGZsb2F0aW5nLXBvaW50LlxyXG4gIHJldHVybiBwYXJzZUludChNYXRoLmZsb29yKG51bSksIDE2KTtcclxufVxyXG5cclxuZnVuY3Rpb24gdW5kZXJmbG93KHRpbWVyLCBjaWEpIHtcclxuICAvLyBUaW1lciByZWxvYWRzIGZyb20gdGhlIGxhdGNoLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyB3YXMgb25lLXNob3Qgb3JcclxuICAvLyBjb250aW51b3VzLlxyXG4gIHRpbWVyLnZhbHVlX2xvID0gdGltZXIuc3RhcnRWYWx1ZV9sbztcclxuICB0aW1lci52YWx1ZV9oaSA9IHRpbWVyLnN0YXJ0VmFsdWVfaGk7XHJcblxyXG4gIC8vIERlbGF5IHRoZSBhY3Rpb25pbmcgb2YgdGhpcyB1bnRpbCB0aGUgbmV4dCBjeWNsZS5cclxuICB0aW1lci5uZXh0VGlja0ZuID0gdGlja190aW1lcl9wb3N0VW5kZXJmbG93XzA7XHJcbn1cclxuXHJcbi8qXHJcbiAgIzEgIzIgIEREMDYgc2VxdWVuY2UgMS8yLzMgKDQpXHJcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgMDAgMDEgIGtlZXAgICBrZWVwICAgY291bnQgIGNvdW50ICAgICB0aWNrX3RpbWVyX3N0YXJ0dXBfMCAgICAgLT4gdGlja190aW1lcl9ydW5uaW5nXHJcbiAgMDAgMTAgIGtlZXAgICBsb2FkICAga2VlcCAgIGtlZXAgICAgICB0aWNrX3RpbWVyX3N0b3BwZWRMb2FkXzAgLT4gdGlja190aW1lcl9zdG9wcGVkXHJcbiAgMDAgMTEgIGtlZXAgICBsb2FkICAga2VlcCAgIGNvdW50ICAgICB0aWNrX3RpbWVyX3N0YXJ0dXBfMCAgICAgLT4gdGlja190aW1lcl9ydW5uaW5nXHJcbiAgMDEgMTEgIGNvdW50ICBsb2FkICAga2VlcCAgIGNvdW50ICAgICB0aWNrX3RpbWVyX3J1bm5pbmdMb2FkXzAgLT4gdGlja190aW1lcl9ydW5uaW5nXHJcbiAgMDEgMTAgIGNvdW50ICBsb2FkICAga2VlcCAgIGtlZXAgICAgICB0aWNrX3RpbWVyX3NodXRkb3duXzAgICAgLT4gdGlja190aW1lcl9zdG9wcGVkXHJcbiAgMDEgMDAgIGNvdW50ICBjb3VudCAga2VlcCAgIGtlZXAgICAgICB0aWNrX3RpbWVyX3NodXRkb3duXzAgICAgLT4gdGlja190aW1lcl9zdG9wcGVkXHJcbiovXHJcblxyXG5mdW5jdGlvbiB0aWNrX3RpbWVyX3N0YXJ0dXBfMCh0aW1lciwgY2lhKSB7XHJcbiAgLy8gRmlyc3QgY3ljbGUgaXMgYWx3YXlzIGEgY29udGludWF0aW9uXHJcbiAgdGltZXIubmV4dFRpY2tGbiA9IHRpY2tfdGltZXJfc3RhcnR1cF8xO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0aWNrX3RpbWVyX3N0YXJ0dXBfMSh0aW1lciwgY2lhKSB7XHJcbiAgaWYgKHRpbWVyLmNvbnRyb2wgJiAweDEwKSB7XHJcbiAgICBsb2FkKHRpbWVyKTtcclxuICAgIHRpbWVyLm5leHRUaWNrRm4gPSB0aWNrX3RpbWVyX3N0YXJ0dXBfMjtcclxuICB9XHJcbiAgZWxzZSB0aW1lci5uZXh0VGlja0ZuID0gdGlja190aW1lcl9ydW5uaW5nO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0aWNrX3RpbWVyX3N0YXJ0dXBfMih0aW1lciwgY2lhKSB7XHJcbiAgLy8gV2UgZGlkIGEgbG9hZCwgYW5kIHRoYXQgc3RhbGxzIHRoZSBjb3VudCBmb3IgYSBjeWNsZVxyXG4gIHRpbWVyLm5leHRUaWNrRm4gPSB0aWNrX3RpbWVyX3J1bm5pbmc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRpY2tfdGltZXJfc2h1dGRvd25fMCh0aW1lciwgY2lhKSB7XHJcbiAgLy8gRmlyc3QgY3ljbGUgaXMgYWx3YXlzIGEgY29udGludWF0aW9uXHJcbiAgLy8gZGVjcmVtZW50KHRpbWVyLCBjaWEpO1xyXG4gIC8vIHRpbWVyLm5leHRUaWNrRm4gPSB0aWNrX3RpbWVyX3NodXRkb3duXzE7XHJcblxyXG4gIC8vIHNob3J0LWNpcmN1aXQgd2hhdCBJIHRob3VnaHQgaXQgd2FzIGRvaW5nOyBpdCBkb2Vzbid0IGxvb2sgbGlrZSBpdCBuZWVkcyB0d28gY3ljbGVzIHRvIHN0b3BcclxuICB0aWNrX3RpbWVyX3NodXRkb3duXzEodGltZXIsIGNpYSk7ICBcclxufVxyXG5cclxuZnVuY3Rpb24gdGlja190aW1lcl9zaHV0ZG93bl8xKHRpbWVyLCBjaWEpIHtcclxuICBpZiAodGltZXIuY29udHJvbCAmIDB4MTApIHtcclxuICAgIGxvYWQodGltZXIpO1xyXG4gIH1cclxuICBlbHNlIGRlY3JlbWVudCh0aW1lciwgY2lhKTtcclxuICB0aW1lci5uZXh0VGlja0ZuID0gdGlja190aW1lcl9zdG9wcGVkO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0aWNrX3RpbWVyX3N0b3BwZWRMb2FkXzAodGltZXIsIGNpYSkge1xyXG4gIC8vIEZpcnN0IGN5Y2xlIGlzIGFsd2F5cyBhIGNvbnRpbnVhdGlvblxyXG4gIHRpbWVyLm5leHRUaWNrRm4gPSB0aWNrX3RpbWVyX3N0b3BwZWRMb2FkXzE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRpY2tfdGltZXJfc3RvcHBlZExvYWRfMSh0aW1lciwgY2lhKSB7XHJcbiAgbG9hZCh0aW1lcik7XHJcbiAgdGltZXIubmV4dFRpY2tGbiA9IHRpY2tfdGltZXJfc3RvcHBlZDtcclxufVxyXG5cclxuZnVuY3Rpb24gdGlja190aW1lcl9ydW5uaW5nTG9hZF8wKHRpbWVyLCBjaWEpIHtcclxuICAvLyBGaXJzdCBjeWNsZSBpcyBhbHdheXMgYSBjb250aW51YXRpb25cclxuICBkZWNyZW1lbnQodGltZXIsIGNpYSk7XHJcbiAgdGltZXIubmV4dFRpY2tGbiA9IHRpY2tfdGltZXJfcnVubmluZ0xvYWRfMTtcclxufVxyXG5cclxuZnVuY3Rpb24gdGlja190aW1lcl9ydW5uaW5nTG9hZF8xKHRpbWVyLCBjaWEpIHtcclxuICBsb2FkKHRpbWVyKTtcclxuICB0aW1lci5uZXh0VGlja0ZuID0gdGlja190aW1lcl9ydW5uaW5nTG9hZF8yO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0aWNrX3RpbWVyX3J1bm5pbmdMb2FkXzIodGltZXIsIGNpYSkge1xyXG4gIC8vIFdlIGRpZCBhIGxvYWQsIGFuZCB0aGF0IHN0YWxscyB0aGUgY291bnQgZm9yIGEgY3ljbGVcclxuICB0aW1lci5uZXh0VGlja0ZuID0gdGlja190aW1lcl9ydW5uaW5nO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0aWNrX3RpbWVyX3J1bm5pbmdOb25Mb2FkXzAodGltZXIsIGNpYSkge1xyXG4gIC8vIFN0YXJ0aW5nIHdoaWxlIGFscmVhZHkgc3RhcnRlZCBzZWVtcyB0byBjYXVzZSBhIG9uZS1jeWNsZSBwYXVzZVxyXG4gIHRpbWVyLm5leHRUaWNrRm4gPSB0aWNrX3RpbWVyX3J1bm5pbmc7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiB0aWNrX3RpbWVyX3J1bm5pbmcodGltZXIsIGNpYSkge1xyXG4gIGRlY3JlbWVudCh0aW1lciwgY2lhKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdGlja190aW1lcl9zdG9wcGVkKHRpbWVyLCBjaWEpIHtcclxufVxyXG5cclxuZnVuY3Rpb24gdGlja190aW1lcl9wb3N0VW5kZXJmbG93XzAodGltZXIsIGNpYSkge1xyXG5cclxuICBpZiAodGltZXIuaXNBKSB7XHJcbiAgICAvLyBNYXJrIFRpbWVyIEEgaW50ZXJydXB0IGFzIGhhdmluZyBoYXBwZW5lZFxyXG4gICAgY2lhLmlycV9zdGF0dXMgfD0gMGIwMTtcclxuXHJcbiAgICAvLyBJcyBUaW1lciBCIGNvbmZpZ3VyZWQgdG8gY291bnQgd2hlbiB3ZSB1bmRlcmZsb3c/IChhbmQgbm90IGluXHJcbiAgICAvLyBjb25qdW5jdGlvbiB3aXRoIHRoZSBDTlQgcGluKVxyXG4gICAgaWYgKChjaWEudGltZXJfYi5jb250cm9sICYgMGIwMTEwMDAwMCkgPT09IDBiMDEwMDAwMDApIHtcclxuICAgICAgZGVjcmVtZW50KGNpYS50aW1lcl9iLCBjaWEpO1xyXG4gICAgfVxyXG4gIH1cclxuICBlbHNlIHtcclxuICAgIC8vIE1hcmsgVGltZXIgQiBpbnRlcnJ1cHQgYXMgaGF2aW5nIGhhcHBlbmVkXHJcbiAgICBjaWEuaXJxX3N0YXR1cyB8PSAwYjEwO1xyXG4gIH1cclxuXHJcbiAgcmVjb25zaWRlckludGVycnVwdChjaWEpO1xyXG5cclxuICAvLyBiaXQgMzogMSA9IHRpbWVyIHN0b3BzIG9uIHVuZGVyZmxvd1xyXG4gIGlmICh0aW1lci5jb250cm9sICYgMGIxMDAwKSB7XHJcbiAgICB0aW1lci5uZXh0VGlja0ZuID0gdGlja190aW1lcl9wb3N0VW5kZXJmbG93XzE7XHJcbiAgfVxyXG4gIGVsc2Uge1xyXG4gICAgLy8gVGltZXIgcmVzdGFydHMgb24gdW5kZXJmbG93IChidXQgd2Ugc3RpbGwgZmlyZSB0aGUgaW50ZXJydXB0KVxyXG4gICAgLy8gSW4gdGhpcyBjYXNlLCB3ZSBoYXZlIGEgb25lLWN5Y2xlIGRlbGF5IGJlZm9yZSByZXN0YXJ0aW5nIHRoZSBjb3VudCxcclxuICAgIC8vIHByZXN1bWFibHkgdG8gY29tcGVuc2F0ZSBmb3IgdGhlIHRpbWVyIHJlbG9hZGluZyBpbnN0ZWFkIG9mIHNob3dpbmdcclxuICAgIC8vIGEgemVybyBjb3VudC5cclxuICAgIHRpbWVyLm5leHRUaWNrRm4gPSB0aWNrX3RpbWVyX3J1bm5pbmc7XHJcbiAgfVxyXG5cclxuICAvLyBDSUExVEFCIHRlc3Qgc2hvd3MgdGhlcmUncyBhIG9uZS1jeWNsZSBkZWxheSBoZXJlXHJcbiAgLy8gdGltZXIubmV4dFRpY2tGbiA9IHRpY2tfdGltZXJfcnVubmluZztcclxufVxyXG5cclxuZnVuY3Rpb24gdGlja190aW1lcl9wb3N0VW5kZXJmbG93XzEodGltZXIsIGNpYSkge1xyXG4gIC8vIFdlJ3JlIG9uIHRoZSBvbmUtc2hvdCBmbG93IGhlcmUuIEZpbmFsbHkgbWFyayB0aGUgdGltZXIgYXMgaGF2aW5nIHN0b3BwZWQuXHJcbiAgdGltZXIuY29udHJvbCAmPSAweGZlO1xyXG4gIHRpbWVyLm5leHRUaWNrRm4gPSB0aWNrX3RpbWVyX3N0b3BwZWQ7XHJcbn1cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gbG9hZCh0aW1lcikge1xyXG4gIHRpbWVyLnZhbHVlX2xvID0gdGltZXIuc3RhcnRWYWx1ZV9sbztcclxuICB0aW1lci52YWx1ZV9oaSA9IHRpbWVyLnN0YXJ0VmFsdWVfaGk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBkZWNyZW1lbnQodGltZXIsIGNpYSkge1xyXG4gIHRpbWVyLnZhbHVlX2xvLS07XHJcblxyXG4gIC8vIFRoZSAndW5kZXJmbG93JyBpbnRlcnJ1cHQsIHRpbWVyIHN0b3AgYW5kIHJlbG9hZCBoYXBwZW4gaWYgdGhlIHRpbWVyXHJcbiAgLy8gcmVhY2hlcyB6ZXJvLCBub3QgaWYgaXQgYWN0dWFsbHkgdW5kZXJmbG93cy5cclxuICBpZiAoIXRpbWVyLnZhbHVlX2xvICYmICF0aW1lci52YWx1ZV9oaSkge1xyXG4gICAgdW5kZXJmbG93KHRpbWVyLCBjaWEpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKHRpbWVyLnZhbHVlX2xvIDwgMCkge1xyXG4gICAgdGltZXIudmFsdWVfbG8gPSAweGZmO1xyXG4gICAgdGltZXIudmFsdWVfaGkgPSAtLXRpbWVyLnZhbHVlX2hpICYgMHhmZjtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlY29uc2lkZXJJbnRlcnJ1cHQoY2lhKSB7XHJcbiAgaWYgKGNpYS5pcnFfc3RhdHVzICYgY2lhLmlycV9jb250cm9sKSB7XHJcbiAgICBpZiAoY2lhLmlzMSkgc2V0Q2lhMUlycSh0cnVlKTtcclxuICAgIGVsc2UgICAgICAgICBzZXRDaWEyTm1pKHRydWUpO1xyXG4gIH1cclxuXHJcbiAgLy8gT3RoZXJ3aXNlLi4uIGRvbid0IHNldENpYVhYeHgoZmFsc2UpOiBub3RoaW5nIGNhbiB1bi1zZXQgdGhlIGludGVycnVwdFxyXG4gIC8vIHN0YXRlIGV4Y2VwdCBmb3IgcmVhZGluZyB0aGUgaW50ZXJydXB0IGNvbnRyb2wvc3RhdHVzIHJlZ2lzdGVyLCBoYW5kbGVkIGJ5XHJcbiAgLy8gdGhlIHJlYWQgbG9naWNcclxuXHJcbiAgLy8gXCJPbmNlIHRoZSBpbnRlcnJ1cHQgZmxpcC1mbG9wIGhhcyBiZWVuIHNldCwgY2hhbmdpbmcgdGhlIGNvbmRpdGlvbiBpbiB0aGVcclxuICAvLyBJTVIgaGFzIG5vIGVmZmVjdC4gT25seSByZWFkaW5nIHRoZSBJQ1Igd2lsbCBjbGVhciBpdC5cIlxyXG4gIC8vIC0gTG9yZW56IChodHRwczovL2lzdC51d2F0ZXJsb28uY2EvfnNjaGVwZXJzL01KSy9jaWE2NTI2Lmh0bWwpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRpY2tfY2lhKGNpYSkge1xyXG5cclxuICAvLyBTZXQgYml0IDcgb2YgdGhlIGlycV9zdGF0dXNcclxuICBjb25zdCBpbnRfc3RhdGUgPSBCb29sZWFuKGNpYS5pcnFfc3RhdHVzICYgY2lhLmlycV9jb250cm9sKTtcclxuICBjaWEuaXJxX3N0YXR1cyA9IChjaWEuaXJxX3N0YXR1cyAmIDB4N2YpIHwgKGludF9zdGF0ZSA/IDB4ODAgOiAwKTtcclxuICAvLyBtYXliZSB0aGlzIGlzIHdoZXJlIHdlIGFjdHVhbGx5IHB1bGwgdGhlIGludGVycnVwdCBsaW5lIGxvd1xyXG5cclxuICBjaWEudGltZXJfYS5uZXh0VGlja0ZuKGNpYS50aW1lcl9hLCBjaWEpO1xyXG4gIGNpYS50aW1lcl9iLm5leHRUaWNrRm4oY2lhLnRpbWVyX2IsIGNpYSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRpY2soKSB7XHJcbiAgdGlja19jaWEoc3RhdGUuY2lhMSwgc2V0Q2lhMUlycSk7XHJcbiAgdGlja19jaWEoc3RhdGUuY2lhMiwgc2V0Q2lhMk5taSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWQoY2lhLCByZWcpIHtcclxuXHJcbiAgc3dpdGNoIChyZWcpIHtcclxuXHJcbiAgICAvLyBjYXNlcyAweDAgYW5kIDB4MTogcGlja2VkIHVwIGJ5IHRoZSByZWFkIGhhbmRsZXJzIHNwZWNpZmljIHRvIHRoYXQgQ0lBLFxyXG4gICAgLy8gYnV0IHRoaXMgZGVmaW5lcyBkZWZhdWx0IGJlaGF2aW9yIGlmIHRoZXkgZG8gbm90aGluZy5cclxuXHJcbiAgICBjYXNlIDB4MDogICAgIC8vICRkYzAyIC8gJGRkMDI6IHBvcnQgQSB2YWx1ZVxyXG4gICAgICAvLyBUT0RPOiBob25vciBwb3J0IGRpcmVjdGlvblxyXG4gICAgICByZXR1cm4gY2lhLnBvcnRfYS52YWx1ZTtcclxuXHJcbiAgICBjYXNlIDB4MTogICAgIC8vICRkYzAyIC8gJGRkMDI6IHBvcnQgQSB2YWx1ZVxyXG4gICAgICAvLyBUT0RPOiBob25vciBwb3J0IGRpcmVjdGlvblxyXG4gICAgICByZXR1cm4gY2lhLnBvcnRfYi52YWx1ZTtcclxuXHJcbiAgICBjYXNlIDB4MjogICAgIC8vICRkYzAyIC8gJGRkMDI6IHBvcnQgQSBkYXRhIGRpcmVjdGlvblxyXG4gICAgICAvLyBUT0RPOiBob25vciBwb3J0IGRpcmVjdGlvblxyXG4gICAgICByZXR1cm4gY2lhLnBvcnRfYS5kaXJlY3Rpb247XHJcblxyXG4gICAgY2FzZSAweDM6ICAgICAvLyAkZGMwMyAvICRkZDAzOiBwb3J0IEIgZGF0YSBkaXJlY3Rpb25cclxuICAgICAgLy8gVE9ETzogaG9ub3IgcG9ydCBkaXJlY3Rpb25cclxuICAgICAgcmV0dXJuIGNpYS5wb3J0X2IuZGlyZWN0aW9uO1xyXG5cclxuICAgIGNhc2UgMHg0OiAgICAgLy8gJGRjMDQgLyAkZGQwNDogdGltZXIgQSB2YWx1ZSwgbG93IGJ5dGVcclxuICAgICAgcmV0dXJuIGNpYS50aW1lcl9hLnZhbHVlX2xvO1xyXG5cclxuICAgIGNhc2UgMHg1OiAgICAgLy8gJGRjMDUgLyAkZGQwNTogdGltZXIgQSB2YWx1ZSwgaGlnaCBieXRlXHJcbiAgICAgIHJldHVybiBjaWEudGltZXJfYS52YWx1ZV9oaTtcclxuXHJcbiAgICBjYXNlIDB4NjogICAgIC8vICRkYzA2IC8gJGRkMDY6IHRpbWVyIEIgdmFsdWUsIGxvdyBieXRlXHJcbiAgICAgIHJldHVybiBjaWEudGltZXJfYi52YWx1ZV9sbztcclxuXHJcbiAgICBjYXNlIDB4NzogICAgIC8vICRkYzA3IC8gJGRkMDc6IHRpbWVyIEIgdmFsdWUsIGhpZ2ggYnl0ZVxyXG4gICAgICByZXR1cm4gY2lhLnRpbWVyX2IudmFsdWVfaGk7XHJcblxyXG4gICAgY2FzZSAweDg6ICAgICAvLyAkZGMwOCAvICRkZDA4OiB0aW1lIG9mIGRheSwgdGVudGhzXHJcbiAgICAgIHtcclxuICAgICAgICBsZXQgdCA9IChjNjQucnVubG9vcC5nZXRTdGF0ZSgpLmN5Y2xlICsgdG9kT2Zmc2V0KSAvIENMT0NLX1NQRUVEO1xyXG4gICAgICAgIHQgKj0gMTA7ICAvLyB0ZW50aHNcclxuICAgICAgICB0ICU9IDEwOyAgLy8gLi4uYW5kIGp1c3QgdGhlIHRlbnRoc1xyXG4gICAgICAgIHJldHVybiBudW1iZXJUb0JjZCh0KTtcclxuICAgICAgfVxyXG5cclxuICAgIGNhc2UgMHg5OiAgICAgLy8gJGRjMDkgLyAkZGQwOTogdGltZSBvZiBkYXksIHNlY29uZHNcclxuICAgICAge1xyXG4gICAgICAgIGxldCB0ID0gKGM2NC5ydW5sb29wLmdldFN0YXRlKCkuY3ljbGUgKyB0b2RPZmZzZXQpIC8gQ0xPQ0tfU1BFRUQ7XHJcbiAgICAgICAgdCAlPSA2MDsgIC8vIC4uLmFuZCBqdXN0IHRoZSBzZWNvbmRzXHJcbiAgICAgICAgcmV0dXJuIG51bWJlclRvQmNkKHQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgY2FzZSAweGE6ICAgICAvLyAkZGMwYSAvICRkZDBhOiB0aW1lIG9mIGRheSwgbWludXRlc1xyXG4gICAgICB7XHJcbiAgICAgICAgbGV0IHQgPSAoYzY0LnJ1bmxvb3AuZ2V0U3RhdGUoKS5jeWNsZSArIHRvZE9mZnNldCkgLyBDTE9DS19TUEVFRDtcclxuICAgICAgICB0IC89IDYwOyAgLy8gbWludXRlc1xyXG4gICAgICAgIHQgJT0gNjA7ICAvLyAuLi5hbmQganVzdCB0aGUgbWludXRlc1xyXG4gICAgICAgIHJldHVybiBudW1iZXJUb0JjZCh0KTtcclxuICAgICAgfVxyXG5cclxuICAgIGNhc2UgMHhiOiAgICAgLy8gJGRjMGIgLyAkZGQwYjogdGltZSBvZiBkYXksIGhvdXJzXHJcbiAgICAgIHtcclxuICAgICAgICBsZXQgdCA9IChjNjQucnVubG9vcC5nZXRTdGF0ZSgpLmN5Y2xlICsgdG9kT2Zmc2V0KSAvIENMT0NLX1NQRUVEO1xyXG4gICAgICAgIHQgLz0gNjA7ICAvLyBtaW51dGVzXHJcbiAgICAgICAgdCAvPSA2MDsgIC8vIGhvdXJzXHJcbiAgICAgICAgdCAlPSAyNDsgIC8vIC4uLmFuZCBqdXN0IHRoZSBob3Vyc1xyXG5cclxuICAgICAgICAvLyBSZXN1bHQgbXVzdCBiZSAxMiBob3VyLCB3aXRoIE1TQiBiZWluZyB0aGUgbWVyaWRpZW1cclxuICAgICAgICBsZXQgcmV0ID0gbnVtYmVyVG9CY2QodCAlIDEyKTtcclxuICAgICAgICByZXQgfD0gKHQgPiAxMikgPyAweDgwIDogMDtcclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICB9XHJcblxyXG4gICAgY2FzZSAweGM6ICAgICAvLyAkZGMwYyAvICRkZDBjOiBzZXJpYWwgc2hpZnRcclxuICAgICAgLy8gVE9ETzogU2VyaWFsIHNoaWZ0ZXIgbm90IGltcGxlbWVudGVkXHJcbiAgICAgIHVuaW1wbGVtZW50ZWRXYXJuaW5nKFwic2VyaWFsIHNoaWZ0ZXIgcmVhZFwiKTtcclxuICAgICAgcmV0dXJuIDA7XHJcblxyXG4gICAgY2FzZSAweGQ6ICAgICAvLyAkZGMwZCAvICRkZDBkOiBpbnRlcnJ1cHQgc3RhdHVzL2NvbnRyb2xcclxuICAgICAge1xyXG4gICAgICAgIC8vIFJlYWRpbmcgdGhlIGludGVycnVwdCBzdGF0dXMgY2xlYXJzIGl0XHJcbiAgICAgICAgY29uc3QgcmV0ID0gY2lhLmlycV9zdGF0dXM7XHJcbiAgICAgICAgY2lhLmlycV9zdGF0dXMgPSAwO1xyXG5cclxuICAgICAgICBpZiAoY2lhLmlzMSkgc2V0Q2lhMUlycShmYWxzZSk7XHJcbiAgICAgICAgZWxzZSAgICAgICAgIHNldENpYTJObWkoZmFsc2UpO1xyXG5cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICB9XHJcblxyXG4gICAgLy8gVGhpcyBpcyBrbHVkZ2V5LiBUaGUgbG9hZCBkb2Vzbid0IGdldCBzdG9yZWQgcGVybWFuZW50bHk7IEkgYW1cclxuICAgIC8vIHN0b3JpbmcgaXQgKHRoZSBjeWNsZSBzZXF1ZW5jZSBuZWVkcyBpdCByZW1lbWJlcmVkKSwgc28gSSdtIGp1c3QgemVyb2luZ1xyXG4gICAgLy8gaXQgb3V0IG9uIHJlYWQuIERvIG5vdCBsaWtlLlxyXG5cclxuICAgIGNhc2UgMHhlOiAgICAgLy8gJGRjMGUgLyAkZGQwZTogdGltZXIgQSBjb250cm9sXHJcbiAgICAgIHJldHVybiBjaWEudGltZXJfYS5jb250cm9sICYgMGIxMTEwMTExMTtcclxuXHJcbiAgICBjYXNlIDB4ZjogICAgIC8vICRkYzBmIC8gJGRkMGY6IHRpbWVyIEIgY29udHJvbFxyXG4gICAgICByZXR1cm4gY2lhLnRpbWVyX2IuY29udHJvbCAmIDBiMTExMDExMTE7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiB3cml0ZV90aW1lckNvbnRyb2wodGltZXIsIGJ5dGUpIHtcclxuXHJcbiAgLypcclxuICAgICMxICMyICBERDA2IHNlcXVlbmNlIDEvMi8zICg0KVxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAwMCAwMSAga2VlcCAgIGtlZXAgICBjb3VudCAgY291bnQgICAgIHRpY2tfdGltZXJfc3RhcnR1cF8wICAgICAtPiB0aWNrX3RpbWVyX3J1bm5pbmdcclxuICAgIDAwIDEwICBrZWVwICAgbG9hZCAgIGtlZXAgICBrZWVwICAgICAgdGlja190aW1lcl9zdG9wcGVkTG9hZF8wIC0+IHRpY2tfdGltZXJfc3RvcHBlZFxyXG4gICAgMDAgMTEgIGtlZXAgICBsb2FkICAga2VlcCAgIGNvdW50ICAgICB0aWNrX3RpbWVyX3N0YXJ0dXBfMCAgICAgLT4gdGlja190aW1lcl9ydW5uaW5nXHJcbiAgICAwMSAxMSAgY291bnQgIGxvYWQgICBrZWVwICAgY291bnQgICAgIHRpY2tfdGltZXJfcnVubmluZ0xvYWRfMCAtPiB0aWNrX3RpbWVyX3J1bm5pbmdcclxuICAgIDAxIDEwICBjb3VudCAgbG9hZCAgIGtlZXAgICBrZWVwICAgICAgdGlja190aW1lcl9zaHV0ZG93bl8wICAgIC0+IHRpY2tfdGltZXJfc3RvcHBlZFxyXG4gICAgMDEgMDAgIGNvdW50ICBjb3VudCAga2VlcCAgIGtlZXAgICAgICB0aWNrX3RpbWVyX3NodXRkb3duXzAgICAgLT4gdGlja190aW1lcl9zdG9wcGVkXHJcbiAgKi9cclxuXHJcbiAgLy8gSWYgd2UncmUgbm90IGNvdW50aW5nIGN5Y2xlcyBDUFUgY3ljbGVzLi4uXHJcbiAgaWYgKGJ5dGUgJiAwYjAxMTAwMDAwKSB7XHJcbiAgICAvLyBNYXliZSwgbGlrZSB0aGUgY3ljbGUgY291bnRlciwgaXQgaGFzIGEgY3ljbGUgZm9yIHRoaXMgdG8gZ2V0IG5vdGljZWQuXHJcbiAgICAvLyBJIGhhdmVuJ3QgbG9va2VkLlxyXG4gICAgdGltZXIubmV4dFRpY2tGbiA9IHRpY2tfdGltZXJfc3RvcHBlZDtcclxuXHJcbiAgICAvLyAoVGhlcmUncyBhbiBlZGdlIGNhc2UgaGVyZSBhYm91dCBpZiBpdCB3YXMgcnVubmluZyBidXQgbm90IGNvdW50aW5nIGN5Y2xlcylcclxuICB9XHJcbiAgLy8gV2UgYXJlIGNvdW50aW5nIGN5Y2xlcyBDUFUgY3ljbGVzLi4uXHJcbiAgZWxzZSB7XHJcblxyXG4gICAgLy8gSWYgdGltZXIgd2FzIHJ1bm5pbmcuLi5cclxuICAgIGlmICh0aW1lci5jb250cm9sICYgMSkge1xyXG4gICAgICAvLyAuLi5hbmQgd2UncmUga2VlcGluZyBpdCBydW5uaW5nLi4uXHJcbiAgICAgIGlmIChieXRlICYgMSkge1xyXG4gICAgICAgIC8vIC4uLmJ1dCB3ZSdyZSBkb2luZyBhIGxvYWRcclxuICAgICAgICBpZiAoYnl0ZSAmIDB4MTApIHtcclxuICAgICAgICAgIHRpbWVyLm5leHRUaWNrRm4gPSB0aWNrX3RpbWVyX3J1bm5pbmdMb2FkXzA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIC4uLm9yIG5vdCBkb2luZyBhIGxvYWRcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHRpbWVyLm5leHRUaWNrRm4gPSB0aWNrX3RpbWVyX3J1bm5pbmdOb25Mb2FkXzA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIC8vIC4uLmFuZCB3ZSdyZSBzdG9wcGluZyBpdC4uLlxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICB0aW1lci5uZXh0VGlja0ZuID0gdGlja190aW1lcl9zaHV0ZG93bl8wO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBJZiB0aW1lciB3YXMgc3RvcHBlZC4uLlxyXG4gICAgZWxzZSB7XHJcbiAgICAgIC8vIC4uLmJ1dCB3ZSdyZSBzdGFydGluZyBpdC4uLlxyXG4gICAgICBpZiAoYnl0ZSAmIDEpIHtcclxuICAgICAgICB0aW1lci5uZXh0VGlja0ZuID0gdGlja190aW1lcl9zdGFydHVwXzA7XHJcbiAgICAgIH1cclxuICAgICAgLy8gLi4uYW5kIHdlJ3JlIGtlZXBpbmcgaXQgc3RvcHBlZC4uLlxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAvLyAuLi5idXQgd2UncmUgZG9pbmcgYSBsb2FkXHJcbiAgICAgICAgaWYgKGJ5dGUgJiAweDEwKSB7XHJcbiAgICAgICAgICB0aW1lci5uZXh0VGlja0ZuID0gdGlja190aW1lcl9zdG9wcGVkTG9hZF8wO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gVE9ETzogd2UncmUgbm90IGRvaW5nIGFueXRoaW5nIGFib3V0IGJpdHMgMSBvciAyLCBvbiBzZXR0aW5nIGJpdHMgb2YgdGhlXHJcbiAgLy8gcG9ydCB3aGVuIGFuIHVuZGVyZmxvdy9vdmVyZmxvdyBvY2N1cnMuIChIb3cgZG9lcyBhbiBvdmVyZmxvdyBldmVuIGhhcHBlbj9cclxuICAvLyBXaGVuIHVzZWQgZm9yIHRoZSBzZXJpYWwgc2hpZnQgcmVnaXN0ZXI/KVxyXG4gIC8vIEFuZCBhcyBmb3IgdGhlIG90aGVyIGJpdHMuLi4gbm9uLUNQVS1jbG9jayBzb3VyY2UsIHNoaWZ0IHJlZ2lzdGVyXHJcbiAgLy8gZGlyZWN0aW9uLCA1MC82MEh6IGNsb2NrIHNlbGVjdC4uLiB3ZSBkb24ndCBkbyBhbnkgb2YgdGhhdC5cclxuXHJcbiAgaWYgKGJ5dGUgJiAxKSB1bmltcGxlbWVudGVkV2FybmluZyhcImluZGljYXRlIHRpbWVyIHVuZGVyZmxvdyBvbiBwb3J0IEJcIik7XHJcblxyXG4gIHRpbWVyLmNvbnRyb2wgPSBieXRlO1xyXG59XHJcblxyXG5mdW5jdGlvbiB3cml0ZV90aW1lckxvdyh0aW1lciwgYnl0ZSkge1xyXG4gIHRpbWVyLnN0YXJ0VmFsdWVfbG8gPSBieXRlO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gd3JpdGVfdGltZXJIaWdoKHRpbWVyLCBieXRlKSB7XHJcbiAgdGltZXIuc3RhcnRWYWx1ZV9oaSA9IGJ5dGU7XHJcblxyXG4gIC8vIExvYWQgdGhlIHRpbWVyIHZhbHVlIGltbWVkaWF0ZWx5IGlmIHRoZSB0aW1lcidzIG5vdCBydW5uaW5nXHJcbiAgaWYgKCEodGltZXIuY29udHJvbCAmIDEpKSB7XHJcbiAgICBsb2FkKHRpbWVyKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJhaXNlVGFwZUludGVycnVwdCgpIHtcclxuICBzdGF0ZS5jaWExLmlycV9zdGF0dXMgfD0gMHgxMDtcclxuICByZWNvbnNpZGVySW50ZXJydXB0KHN0YXRlLmNpYTEpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB3cml0ZShjaWEsIHJlZywgYnl0ZSkge1xyXG4gIHN3aXRjaCAocmVnKSB7XHJcblxyXG4gICAgY2FzZSAweDA6XHJcbiAgICAgIC8vIFRPRE86IGhvbm9yIHBvcnQgZGlyZWN0aW9uXHJcbiAgICAgIGNpYS5wb3J0X2EudmFsdWUgPSBieXRlO1xyXG4gICAgICBicmVhaztcclxuXHJcbiAgICBjYXNlIDB4MTpcclxuICAgICAgLy8gVE9ETzogaG9ub3IgcG9ydCBkaXJlY3Rpb25cclxuICAgICAgY2lhLnBvcnRfYi52YWx1ZSA9IGJ5dGU7XHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgMHgyOiAgICAgLy8gJGRjMDIgLyAkZGQwMjogcG9ydCBBIGRhdGEgZGlyZWN0aW9uXHJcbiAgICAgIGNpYS5wb3J0X2EuZGlyZWN0aW9uID0gYnl0ZTtcclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgY2FzZSAweDM6ICAgICAvLyAkZGMwMyAvICRkZDAzOiBwb3J0IEIgZGF0YSBkaXJlY3Rpb25cclxuICAgICAgY2lhLnBvcnRfYi5kaXJlY3Rpb24gPSBieXRlO1xyXG4gICAgICBicmVhaztcclxuXHJcbiAgICBjYXNlIDB4NDogICAgIC8vICRkYzA0IC8gJGRkMDQ6IHRpbWVyIEEgdmFsdWUsIGxvdyBieXRlXHJcbiAgICAgIHdyaXRlX3RpbWVyTG93KGNpYS50aW1lcl9hLCBieXRlKTtcclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgY2FzZSAweDU6ICAgICAvLyAkZGMwNSAvICRkZDA1OiB0aW1lciBBIHZhbHVlLCBoaWdoIGJ5dGVcclxuICAgICAgd3JpdGVfdGltZXJIaWdoKGNpYS50aW1lcl9hLCBieXRlKTtcclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgY2FzZSAweDY6ICAgICAvLyAkZGMwNiAvICRkZDA2OiB0aW1lciBCIHZhbHVlLCBsb3cgYnl0ZVxyXG4gICAgICB3cml0ZV90aW1lckxvdyhjaWEudGltZXJfYiwgYnl0ZSk7XHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgMHg3OiAgICAgLy8gJGRjMDcgLyAkZGQwNzogdGltZXIgQiB2YWx1ZSwgaGlnaCBieXRlXHJcbiAgICAgIHdyaXRlX3RpbWVySGlnaChjaWEudGltZXJfYiwgYnl0ZSk7XHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgMHg4OiAgICAgLy8gJGRjMDggLyAkZGQwODogdGltZSBvZiBkYXlcclxuICAgICAgdW5pbXBsZW1lbnRlZFdhcm5pbmcoXCJ0aW1lIG9mIGRheSBjbG9jayB3cml0ZVwiKTtcclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgY2FzZSAweDk6ICAgICAvLyAkZGMwOSAvICRkZDA5OiB0aW1lIG9mIGRheVxyXG4gICAgICB1bmltcGxlbWVudGVkV2FybmluZyhcInRpbWUgb2YgZGF5IGNsb2NrIHdyaXRlXCIpO1xyXG4gICAgICBicmVhaztcclxuXHJcbiAgICBjYXNlIDB4YTogICAgIC8vICRkYzBhIC8gJGRkMGE6IHRpbWUgb2YgZGF5XHJcbiAgICAgIHVuaW1wbGVtZW50ZWRXYXJuaW5nKFwidGltZSBvZiBkYXkgY2xvY2sgd3JpdGVcIik7XHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgMHhiOiAgICAgLy8gJGRjMGIgLyAkZGQwYjogdGltZSBvZiBkYXlcclxuICAgICAgdW5pbXBsZW1lbnRlZFdhcm5pbmcoXCJ0aW1lIG9mIGRheSBjbG9jayB3cml0ZVwiKTtcclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgY2FzZSAweGM6ICAgICAvLyAkZGMwYyAvICRkZDBjOiBzZXJpYWwgc2hpZnRcclxuICAgICAgdW5pbXBsZW1lbnRlZFdhcm5pbmcoXCJzZXJpYWwgc2hpZnRlciB3cml0ZVwiKTtcclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgY2FzZSAweGQ6ICAgICAvLyAkZGMwZCAvICRkZDBkOiBpbnRlcnJ1cHQgY29udHJvbFxyXG5cclxuICAgICAgaWYgKGJ5dGUgJiAweDgwKSB7XHJcbiAgICAgICAgLy8gYnl0ZSBpcyBzcGVjaWZ5aW5nIHdoaWNoIGJpdHMgb2YgdGhlIGNvbnRyb2wgcmVnaXN0ZXIgdG8gc2V0XHJcbiAgICAgICAgY2lhLmlycV9jb250cm9sIHw9IChieXRlICYgMHg3Zik7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgLy8gYnl0ZSBpcyBzcGVjaWZ5aW5nIHdoaWNoIGJpdHMgb2YgdGhlIGNvbnRyb2wgcmVnaXN0ZXIgdG8gY2xlYXJcclxuICAgICAgICBjaWEuaXJxX2NvbnRyb2wgJj0gfmJ5dGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlY29uc2lkZXJJbnRlcnJ1cHQoY2lhKTtcclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgY2FzZSAweGU6ICAgICAvLyAkZGMwZSAvICRkZDBlOiB0aW1lciBBIGNvbnRyb2xcclxuICAgICAgd3JpdGVfdGltZXJDb250cm9sKGNpYS50aW1lcl9hLCBieXRlKTtcclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgY2FzZSAweGY6ICAgICAvLyAkZGMwZiAvICRkZDBmOiB0aW1lciBCIGNvbnRyb2xcclxuICAgICAgd3JpdGVfdGltZXJDb250cm9sKGNpYS50aW1lcl9iLCBieXRlKTtcclxuICAgICAgYnJlYWs7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkX2RjMDBfZGNmZihhZGRyKSB7XHJcbiAgXHJcbiAgLy8gQ0lBMSByZWdzIGFyZSBmcm9tICRkYzAwLSRkYzBmLCB3aXRoIGRlZ2VuZXJhdGUgY29waWVzIHRocm91Z2ggJGRjZmZcclxuICBjb25zdCByZWcgPSBhZGRyICYgMHhmO1xyXG5cclxuICBzd2l0Y2ggKHJlZykge1xyXG4gICAgY2FzZSAweDA6ICAgICAvLyAkZGMwMDogam95c3RpY2sgMlxyXG5cclxuICAgICAgLy8gVGhlIGRvY3MgSSByZWFkIHNheSB0aGF0IGJpdHMgMC00IGFyZSB0aGUgam95c3RpY2sgc3dpdGNoZXMgYnV0IGRvbid0XHJcbiAgICAgIC8vIG1lbnRpb24gdGhlIG90aGVycy4gSW4gcHJhY3RpY2UsIGJpdCA3IGlzIHRpZWQgbG93LCBhbmQgNiBhbmQgNSBhcmVcclxuICAgICAgLy8gaGlnaC4gU29tZSBnYW1lcyAoQ29tbWFuZG8sIEJvbWIgSmFjay4uLikgZGVwZW5kIG9uIHRoaXMgYnkgdGVzdGluZ1xyXG4gICAgICAvLyBmb3IgdGhlIHZhbHVlICQ2ZiB0byB3YWl0IGZvciB0aGUgZmlyZSBidXR0b24uXHJcblxyXG4gICAgICByZXR1cm4gc3RhdGUuam95c3RpY2syICYgMGIwMTExMTExMTtcclxuXHJcbiAgICBjYXNlIDB4MTogICAgIC8vICRkYzAxOiBrZXlib2FyZCBhbmQgam95c3RpY2sgMVxyXG4gICAgICB7XHJcbiAgICAgICAgLy8gZXZlcnl0aGluZydzIGludmVydGVkLCB1bmhlbHBmdWxseVxyXG5cclxuICAgICAgICBjb25zdCBjb2x1bW4gPSAofnN0YXRlLmNpYTEucG9ydF9hLnZhbHVlKSAmIDB4ZmY7XHJcbiAgICAgICAgLy8gY29uc3QgY29sdW1uID0gKH5zdGF0ZS5yZWdzXzFbMF0pICYgMHhmZjtcclxuXHJcbiAgICAgICAgbGV0IHJldCA9IDA7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgODsgYysrKSB7XHJcbiAgICAgICAgICBpZiAoY29sdW1uICYgKDEgPDwgYykpIHJldCB8PSBzdGF0ZS5rZXlNYXRyaXhbY107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyByZXR1cm4gKH5yZXQpICYgMHhmZjtcclxuICAgICAgICByZXR1cm4gKH4ocmV0IHwgfnN0YXRlLmpveXN0aWNrMSkpICYgMHhmZjtcclxuICAgICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlYWQoc3RhdGUuY2lhMSwgcmVnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZF9kZDAwX2RkZmYoYWRkcikge1xyXG5cclxuICAvLyBDSUEyIHJlZ3MgYXJlIGZyb20gJGRkMDAtJGRkMGYsIHdpdGggZGVnZW5lcmF0ZSBjb3BpZXMgdGhyb3VnaCAkZGRmZlxyXG4gIGNvbnN0IHJlZyA9IGFkZHIgJiAweGY7XHJcblxyXG4gIHN3aXRjaCAocmVnKSB7XHJcbiAgICBjYXNlIDB4MDogICAgIC8vICRkZDAwOiBzZXJpYWwgYnVzXHJcbiAgICAgIC8vIFRPRE9cclxuICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZhbGwgdGhyb3VnaFxyXG4gICAgICBicmVhaztcclxuXHJcbiAgICBjYXNlIDB4MTogICAgIC8vICRkZDAxOiBSUzIzMlxyXG4gICAgICAvLyBUT0RPXHJcbiAgICAgIC8vIERlbGliZXJhdGVseSBmYWxsIHRocm91Z2hcclxuICAgICAgYnJlYWs7ICAgICAgXHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVhZChzdGF0ZS5jaWEyLCByZWcpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB3cml0ZV9kYzAwX2RjZmYoYWRkciwgYnl0ZSkge1xyXG5cclxuICAvLyBDSUExIHJlZ3MgYXJlIGZyb20gJGRjMDAtJGRjMGYsIHdpdGggZGVnZW5lcmF0ZSBjb3BpZXMgdGhyb3VnaCAkZGNmZlxyXG4gIGNvbnN0IHJlZyA9IGFkZHIgJiAweGY7XHJcblxyXG4gIC8vIENJQTEtc3BlY2lmaWMgY29uZmlndXJhdGlvblxyXG4gIHN3aXRjaCAocmVnKSB7XHJcbiAgICBjYXNlIDB4MDogICAgIC8vICRkYzAwOiBrZXlib2FyZCBjb2x1bW5cclxuICAgIGNhc2UgMHgxOiAgICAgLy8gJGNkMDE6IFJTMjMyXHJcbiAgICAgIC8vIGRlbGliZXJhdGVseSBmYWxsIHRocm91Z2hcclxuICAgICAgYnJlYWs7XHJcbiAgfVxyXG5cclxuICAvLyBDSUEtZ2VuZXJhbCBmdW5jdGlvbmFsaXR5XHJcbiAgcmV0dXJuIHdyaXRlKHN0YXRlLmNpYTEsIHJlZywgYnl0ZSwgc2V0Q2lhMUlycSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdyaXRlX2RkMDBfZGRmZihhZGRyLCBieXRlKSB7XHJcblxyXG4gIC8vIENJQTIgcmVncyBhcmUgZnJvbSAkZGQwMC0kZGQwZiwgd2l0aCBkZWdlbmVyYXRlIGNvcGllcyB0aHJvdWdoICRkZGZmXHJcbiAgY29uc3QgcmVnID0gYWRkciAmIDB4ZjtcclxuXHJcbiAgLy8gQ0lBMi1zcGVjaWZpYyBjb25maWd1cmF0aW9uXHJcbiAgc3dpdGNoIChyZWcpIHtcclxuICAgIGNhc2UgMHgwOiAgICAgLy8gJGRkMDA6IFZJQyBiYW5rIHNlbGVjdCwgc2VyaWFsIGJ1c1xyXG5cclxuICAgICAgLy8gVGhlICdiYW5rIG51bWJlcicgdGhhdCB3ZSdyZSBzZXR0aW5nIGlzIHRoZSBiaXR3aXNlIGludmVyc2Ugb2YgdGhlXHJcbiAgICAgIC8vIHRoYXQncyBiZWluZyB3cml0dGVuIGhlcmU7IHByZXN1bWFibHkgYmVjYXVzZSBsaW5lcyBhcmUgdGllZCBoaWdoLFxyXG4gICAgICAvLyBzbyBzZXR0aW5nIHRoZSBiaXQgbWVhbnMgcHVsbGluZyBpdCBsb3cuIEl0J3MganVzdCBhIG1hdHRlciBvZlxyXG4gICAgICAvLyBjb252ZW50aW9uLCBidXQgdG8gc3RheSBjb25zaXN0ZW50IHdpdGggdGhlIGRvY3VtZW50YXRpb24nc1xyXG4gICAgICAvLyBjb25jZXB0IG9mIHRoZSBWSUMgYmFuayBudW1iZXIsIHdlJ2xsIHRyYW5zbGF0ZSBoZXJlLlxyXG4gICAgICBzZXRWaWNCYW5rKDMgLSAoYnl0ZSAmIDBiMTEpKTtcclxuXHJcbiAgICAgIC8vIFRPRE86IGFuZCB0aGVyZSdzIG90aGVyIGJpdHMgaGVyZSBmb3IgdGhlIHNlcmlhbCBidXNcclxuICAgICAgc3RhdGUuY2lhMi5wb3J0X2EudmFsdWUgPSBieXRlO1xyXG4gICAgICAvLyBkZWxpYmVyYXRlbHkgZmFsbCB0aHJvdWdoXHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgMHgxOiAgICAgLy8gJGRkMDE6IHVzZXIgcG9ydFxyXG4gICAgICAvLyBUT0RPXHJcbiAgICAgIC8vIGRlbGliZXJhdGVseSBmYWxsIHRocm91Z2hcclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgLy8gZGlyZWN0aW9uXHJcbiAgICBjYXNlIDB4MjpcclxuICAgICAgLy8gZGVidWdnZXI7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAweDM6XHJcbiAgICAgIC8vIGRlYnVnZ2VyO1xyXG4gICAgICBicmVhaztcclxuICB9XHJcblxyXG4gIC8vIENJQS1nZW5lcmFsIGZ1bmN0aW9uYWxpdHlcclxuICByZXR1cm4gd3JpdGUoc3RhdGUuY2lhMiwgcmVnLCBieXRlLCBzZXRDaWEyTm1pKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2VyaWFsaXplKCkge1xyXG4gIGNvbnN0IG9iaiA9IHtcclxuICAgIC4uLnN0YXRlLFxyXG4gICAgY2lhMToge1xyXG4gICAgICAuLi5zdGF0ZS5jaWExLFxyXG4gICAgICB0aW1lcl9hOiB7XHJcbiAgICAgICAgLi4uc3RhdGUuY2lhMS50aW1lcl9hLFxyXG4gICAgICAgIG5leHRUaWNrRm46IGZ1bmN0aW9uVG9SZWZlcmVuY2Uoc3RhdGUuY2lhMS50aW1lcl9hLm5leHRUaWNrRm4pLFxyXG4gICAgICB9LFxyXG4gICAgICB0aW1lcl9iOiB7XHJcbiAgICAgIC4uLnN0YXRlLmNpYTEudGltZXJfYixcclxuICAgICAgICBuZXh0VGlja0ZuOiBmdW5jdGlvblRvUmVmZXJlbmNlKHN0YXRlLmNpYTEudGltZXJfYi5uZXh0VGlja0ZuKSxcclxuICAgICAgfSxcclxuICAgIH0sXHJcbiAgICBjaWEyOiB7XHJcbiAgICAgIC4uLnN0YXRlLmNpYTIsXHJcbiAgICAgIHRpbWVyX2E6IHtcclxuICAgICAgICAuLi5zdGF0ZS5jaWEyLnRpbWVyX2EsXHJcbiAgICAgICAgbmV4dFRpY2tGbjogZnVuY3Rpb25Ub1JlZmVyZW5jZShzdGF0ZS5jaWEyLnRpbWVyX2EubmV4dFRpY2tGbiksXHJcbiAgICAgIH0sXHJcbiAgICAgIHRpbWVyX2I6IHtcclxuICAgICAgLi4uc3RhdGUuY2lhMi50aW1lcl9iLFxyXG4gICAgICAgIG5leHRUaWNrRm46IGZ1bmN0aW9uVG9SZWZlcmVuY2Uoc3RhdGUuY2lhMi50aW1lcl9iLm5leHRUaWNrRm4pLFxyXG4gICAgICB9LFxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZShqc29uKSB7XHJcbiAgc3RhdGUgPSBKU09OLnBhcnNlKGpzb24pO1xyXG5cclxuICBzdGF0ZS5jaWExLnRpbWVyX2EubmV4dFRpY2tGbiA9IHJlZmVyZW5jZVRvRnVuY3Rpb24oc3RhdGUuY2lhMS50aW1lcl9hLm5leHRUaWNrRm4pO1xyXG4gIHN0YXRlLmNpYTEudGltZXJfYi5uZXh0VGlja0ZuID0gcmVmZXJlbmNlVG9GdW5jdGlvbihzdGF0ZS5jaWExLnRpbWVyX2IubmV4dFRpY2tGbik7XHJcbiAgc3RhdGUuY2lhMi50aW1lcl9hLm5leHRUaWNrRm4gPSByZWZlcmVuY2VUb0Z1bmN0aW9uKHN0YXRlLmNpYTIudGltZXJfYS5uZXh0VGlja0ZuKTtcclxuICBzdGF0ZS5jaWEyLnRpbWVyX2IubmV4dFRpY2tGbiA9IHJlZmVyZW5jZVRvRnVuY3Rpb24oc3RhdGUuY2lhMi50aW1lcl9iLm5leHRUaWNrRm4pO1xyXG59XHJcblxyXG5hZGRUb1NlcmlhbGl6ZXJSZWdpc3RyeSh7XHJcbiAgdGlja190aW1lcl9zdGFydHVwXzAsXHJcbiAgdGlja190aW1lcl9zdGFydHVwXzEsXHJcbiAgdGlja190aW1lcl9zdGFydHVwXzIsXHJcbiAgdGlja190aW1lcl9zaHV0ZG93bl8wLFxyXG4gIHRpY2tfdGltZXJfc2h1dGRvd25fMSxcclxuICB0aWNrX3RpbWVyX3N0b3BwZWRMb2FkXzAsXHJcbiAgdGlja190aW1lcl9zdG9wcGVkTG9hZF8xLFxyXG4gIHRpY2tfdGltZXJfcnVubmluZ0xvYWRfMCxcclxuICB0aWNrX3RpbWVyX3J1bm5pbmdMb2FkXzEsXHJcbiAgdGlja190aW1lcl9ydW5uaW5nTG9hZF8yLFxyXG4gIHRpY2tfdGltZXJfcnVubmluZ05vbkxvYWRfMCxcclxuICB0aWNrX3RpbWVyX3J1bm5pbmcsXHJcbiAgdGlja190aW1lcl9zdG9wcGVkLFxyXG4gIHRpY2tfdGltZXJfcG9zdFVuZGVyZmxvd18wLFxyXG4gIHRpY2tfdGltZXJfcG9zdFVuZGVyZmxvd18xLFxyXG59KTtcclxuIiwiLypcclxuICAgY3B1OiBlbXVsYXRlcyB0aGUgNjUxMCBtaWNyb3Byb2Nlc3NvciwgaW5jbHVkaW5nIHF1YXNpLW9wc1xyXG5cclxuICAgUmVmZXJlbmNlczpcclxuXHJcbiAgIOKAoDE6IGh0dHA6Ly93d3cuemltbWVycy5uZXQvYW5vbmZ0cC9wdWIvY2JtL2RvY3VtZW50cy9jaGlwZGF0YS82NGRvY1xyXG4gICDigKAyOiBMb25nIGRpc2N1c3Npb24gb24gaW50ZXJydXB0cyBhbmQgYnJhbmNoZXM6XHJcbiAgICAgICBodHRwOi8vZm9ydW0uNjUwMi5vcmcvdmlld3RvcGljLnBocD9mPTQmdD0xNjM0XHJcbiAgIOKAoDM6IGh0dHA6Ly9hcmNoaXZlLjY1MDIub3JnL2Jvb2tzL21jczY1MDBfZmFtaWx5X2hhcmR3YXJlX21hbnVhbC5wZGZcclxuICAg4oCgNDogaHR0cDovL3d3dy56aW1tZXJzLm5ldC9hbm9uZnRwL3B1Yi9jYm0vZG9jdW1lbnRzL2NoaXBkYXRhLzY1MDItTk1PUy5leHRyYS5vcGNvZGVzXHJcblxyXG4gICBUT0RPczpcclxuXHJcbiAgICAgLSBhbGxvdyBidXMgdGFrZW92ZXIgYnkgVklDIChSRFkgcGluKVxyXG4gICAgIC0gYXQgbGVhc3QgbWFrZSBhIG5vdGUgb2YgUEMgd2hlbiBhbiBvcGNvZGUgc3RhcnRzIChTWU5DIHBpbiksIGZvclxyXG4gICAgICAgZGVidWdnaW5nXHJcbiovXHJcblxyXG5pbXBvcnQgeyAkeHgsICR4eHh4LCB1bmltcGxlbWVudGVkV2FybmluZyB9IGZyb20gXCIuLi9kZWJ1Z1wiO1xyXG5pbXBvcnQgeyBkaXNhc20gfSBmcm9tIFwiLi4vdG9vbHMvZGlzYXNtXCI7XHJcbmltcG9ydCB7XHJcbiAgYWRkVG9TZXJpYWxpemVyUmVnaXN0cnksXHJcbiAgZnVuY3Rpb25Ub1JlZmVyZW5jZSxcclxuICByZWZlcmVuY2VUb0Z1bmN0aW9uLFxyXG59IGZyb20gXCIuLi90b29scy9zZXJpYWxpemVyU3VwcG9ydFwiO1xyXG5cclxubGV0IHN0YXRlO1xyXG5cclxuLy8gQm91bmQgYnkgYXR0YWNoXHJcbmxldCBjNjQ7XHJcbmxldCBjcHVSZWFkO1xyXG5sZXQgY3B1V3JpdGU7XHJcbmxldCBnZXRJcnE7XHJcbmxldCBnZXRObWk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYXR0YWNoKG5hc2NlbnRDNjQpIHtcclxuICBjNjQgPSBuYXNjZW50QzY0O1xyXG5cclxuICBjcHVSZWFkICA9IGM2NC53aXJlcy5jcHVSZWFkO1xyXG4gIGNwdVdyaXRlID0gYzY0LndpcmVzLmNwdVdyaXRlO1xyXG4gIGdldElycSAgID0gYzY0LndpcmVzLmdldElycTtcclxuICBnZXRObWkgICA9IGM2NC53aXJlcy5nZXRObWk7XHJcblxyXG4gIHJlc2V0KCk7XHJcblxyXG4gIGM2NC5jcHUgPSB7XHJcbiAgICAvLyBDb250cm9sXHJcbiAgICB0aWNrLFxyXG4gICAgcmVzZXQsXHJcbiAgICBzZXJpYWxpemUsXHJcbiAgICBkZXNlcmlhbGl6ZSxcclxuICAgIC8vIERlYnVnXHJcbiAgICBnZXRTdGF0ZSxcclxuICAgIHNob3dTdGF0ZSxcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXNldCgpIHtcclxuICBzdGF0ZSA9IHtcclxuICAgIGE6ICAwLCAgLy8gYWNjdW11bGF0b3JcclxuICAgIHg6ICAwLCAgLy8gWCByZWdpc3RlclxyXG4gICAgeTogIDAsICAvLyBZIHJlZ2lzdGVyXHJcbiAgICBzOiAgMCwgIC8vIHN0YWNrIHBvaW50ZXJcclxuICAgIHBjOiAwLCAgLy8gcHJvZ3JhbSBjb3VudGVyXHJcbiAgICBuOiAgMCwgIC8vIHN0YXR1cyByZWdpc3RlciAoUCkgbmVnYXRpdmUgZmxhZyAoYml0IDcpXHJcbiAgICB2OiAgMCwgIC8vIHN0YXR1cyByZWdpc3RlciAoUCkgb3ZlcmZsb3cgZmxhZyAoYml0IDYpXHJcbiAgICBkOiAgMCwgIC8vIHN0YXR1cyByZWdpc3RlciAoUCkgZGVjaW1hbCBtb2RlIChiaXQgMylcclxuICAgIGk6ICAxLCAgLy8gc3RhdHVzIHJlZ2lzdGVyIChQKSBpbnRlcnJ1cHQgZGlzYWJsZSAoYml0IDIpXHJcbiAgICB6OiAgMCwgIC8vIHN0YXR1cyByZWdpc3RlciAoUCkgemVybyBmbGFnIChiaXQgMSlcclxuICAgIGM6ICAwLCAgLy8gc3RhdHVzIHJlZ2lzdGVyIChQKSBjYXJyeSBmbGFnIChiaXQgMClcclxuXHJcbiAgICBpcjogMCwgICAgICAgLy8gaW5zdHJ1Y3Rpb24gcmVnaXN0ZXJcclxuICAgIG9wRm46IG51bGwsICAvLyBvcGVyYXRpb24gaGFuZGxlciwgY2FsbGVkIGZyb20gdGhlIGFkZHJlc3NpbmcgbW9kZVxyXG5cclxuICAgIGxhc3RObWk6IGZhbHNlLCAvLyB3YXMgTk1JIGxvdyBsYXN0IHRpbWUgd2UgbG9va2VkP1xyXG5cclxuICAgIGFkbDogMCwgICAgICAvLyB0ZW1wb3JhcnkgbG93IGFkZHJlc3MgYnl0ZSBmcm9tIGZldGNoXHJcbiAgICBhZGg6IDAsICAgICAgLy8gdGVtcG9yYXJ5IGhpZ2ggYWRkcmVzcyBieXRlIGZyb20gZmV0Y2hcclxuICAgIHRtcDogMCwgICAgICAvLyBhIHdvcmtpbmcgdmFyaWFibGUgZm9yIHJlYWQtbW9kLXdyaXRlIGluc25zXHJcblxyXG4gICAgcGVuZGluZ0ludDogMywgIC8vICgwID0gbm90aGluZyAsIDEgPSBJUlEsIDIgPSBOTUksIDMgPSBSRVNFVClcclxuXHJcbiAgICAvLyBUd28gcGFyYWxsZWwgc3RhdGUgbWFjaGluZXMgdG8gYWNoaWV2ZSB0aGUgcGlwZWxpbmluZ1xyXG4gICAgZmRUaWNrOiBudWxsLCAgICAgICAgICAgICAgLy8gZmV0Y2gvZGVjb2RlXHJcbiAgICBhbVRpY2s6IGFtX2ludGVycnVwdF9UMiwgICAvLyBhZGRyZXNzaW5nIG1vZGVcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRTdGF0ZSgpIHtcclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuXHJcbi8vIChUT0RPOiBtYXliZSB1c2UgYSBNYXAgZm9yIHRoZXNlLiBXb3VsZCBpdCBhY3R1YWxseSBiZSBmYXN0ZXI/KVxyXG5jb25zdCAgb3BGbl9mb3JPcGNvZGUgPSB7fTsgLy8gZWcuIDB4NDkgLT4gbG9naWNfZW9yXHJcbmNvbnN0IGFtX1QxX2Zvck9wY29kZSA9IHt9OyAvLyBlZy4gMHg0OSAtPiBhbV9pZW9tZF9pbW1fVDFcclxuXHJcbltcclxuICAvLyBTaW5nbGUtYnl0ZSBvcGVyYXRpb25zIChpbXBsaWNpdClcclxuICBbIDB4ZWEsIG9wX05PUF92b2lkX3ZvaWQsIGFtX3NpbmdsZUJ5dGVfaW1wX1QxIF0sXHJcbiAgWyAweDE4LCBvcF9DTENfdm9pZF92b2lkLCBhbV9zaW5nbGVCeXRlX2ltcF9UMSBdLFxyXG4gIFsgMHhkOCwgb3BfQ0xEX3ZvaWRfdm9pZCwgYW1fc2luZ2xlQnl0ZV9pbXBfVDEgXSxcclxuICBbIDB4NTgsIG9wX0NMSV92b2lkX3ZvaWQsIGFtX3NpbmdsZUJ5dGVfaW1wX1QxIF0sXHJcbiAgWyAweGI4LCBvcF9DTFZfdm9pZF92b2lkLCBhbV9zaW5nbGVCeXRlX2ltcF9UMSBdLFxyXG4gIFsgMHgzOCwgb3BfU0VDX3ZvaWRfdm9pZCwgYW1fc2luZ2xlQnl0ZV9pbXBfVDEgXSxcclxuICBbIDB4ZjgsIG9wX1NFRF92b2lkX3ZvaWQsIGFtX3NpbmdsZUJ5dGVfaW1wX1QxIF0sXHJcbiAgWyAweDc4LCBvcF9TRUlfdm9pZF92b2lkLCBhbV9zaW5nbGVCeXRlX2ltcF9UMSBdLFxyXG4gIFsgMHhhYSwgb3BfVEFYX3ZvaWRfdm9pZCwgYW1fc2luZ2xlQnl0ZV9pbXBfVDEgXSxcclxuICBbIDB4YTgsIG9wX1RBWV92b2lkX3ZvaWQsIGFtX3NpbmdsZUJ5dGVfaW1wX1QxIF0sXHJcbiAgWyAweDhhLCBvcF9UWEFfdm9pZF92b2lkLCBhbV9zaW5nbGVCeXRlX2ltcF9UMSBdLFxyXG4gIFsgMHg5OCwgb3BfVFlBX3ZvaWRfdm9pZCwgYW1fc2luZ2xlQnl0ZV9pbXBfVDEgXSxcclxuICBbIDB4YmEsIG9wX1RTWF92b2lkX3ZvaWQsIGFtX3NpbmdsZUJ5dGVfaW1wX1QxIF0sXHJcbiAgWyAweDlhLCBvcF9UWFNfdm9pZF92b2lkLCBhbV9zaW5nbGVCeXRlX2ltcF9UMSBdLFxyXG4gIFsgMHhjYSwgb3BfREVYX3ZvaWRfdm9pZCwgYW1fc2luZ2xlQnl0ZV9pbXBfVDEgXSxcclxuICBbIDB4ODgsIG9wX0RFWV92b2lkX3ZvaWQsIGFtX3NpbmdsZUJ5dGVfaW1wX1QxIF0sXHJcbiAgWyAweGU4LCBvcF9JTlhfdm9pZF92b2lkLCBhbV9zaW5nbGVCeXRlX2ltcF9UMSBdLFxyXG4gIFsgMHhjOCwgb3BfSU5ZX3ZvaWRfdm9pZCwgYW1fc2luZ2xlQnl0ZV9pbXBfVDEgXSxcclxuICBbIDB4MWEsIG9wX05PUF92b2lkX3ZvaWQsIGFtX3NpbmdsZUJ5dGVfaW1wX1QxIF0sICAgLy8gUXVhc2ktb3BcclxuICBbIDB4M2EsIG9wX05PUF92b2lkX3ZvaWQsIGFtX3NpbmdsZUJ5dGVfaW1wX1QxIF0sICAgLy8gUXVhc2ktb3BcclxuICBbIDB4NWEsIG9wX05PUF92b2lkX3ZvaWQsIGFtX3NpbmdsZUJ5dGVfaW1wX1QxIF0sICAgLy8gUXVhc2ktb3BcclxuICBbIDB4N2EsIG9wX05PUF92b2lkX3ZvaWQsIGFtX3NpbmdsZUJ5dGVfaW1wX1QxIF0sICAgLy8gUXVhc2ktb3BcclxuICBbIDB4ZGEsIG9wX05PUF92b2lkX3ZvaWQsIGFtX3NpbmdsZUJ5dGVfaW1wX1QxIF0sICAgLy8gUXVhc2ktb3BcclxuICBbIDB4ZmEsIG9wX05PUF92b2lkX3ZvaWQsIGFtX3NpbmdsZUJ5dGVfaW1wX1QxIF0sICAgLy8gUXVhc2ktb3BcclxuXHJcbiAgLy8gU2luZ2xlLWJ5dGUgb3BlcmF0aW9ucyAoYWNjdW11bGF0b3IpXHJcbiAgWyAweDBhLCBvcF9BU0xfYXJnX3JldCwgICBhbV9zaW5nbGVCeXRlX2FjY19UMSBdLFxyXG4gIFsgMHg0YSwgb3BfTFNSX2FyZ19yZXQsICAgYW1fc2luZ2xlQnl0ZV9hY2NfVDEgXSxcclxuICBbIDB4MmEsIG9wX1JPTF9hcmdfcmV0LCAgIGFtX3NpbmdsZUJ5dGVfYWNjX1QxIF0sXHJcbiAgWyAweDZhLCBvcF9ST1JfYXJnX3JldCwgICBhbV9zaW5nbGVCeXRlX2FjY19UMSBdLFxyXG5cclxuICAvLyBJbnRlcm5hbCBleGVjdXRpb24gb24gbWVtb3J5IGRhdGEgKGltbWVkaWF0ZSlcclxuICBbIDB4MjksIG9wX0FORF90bXBfdm9pZCwgIGFtX2llb21kX2ltbV9UMSBdLFxyXG4gIFsgMHg0OSwgb3BfRU9SX3RtcF92b2lkLCAgYW1faWVvbWRfaW1tX1QxIF0sXHJcbiAgWyAweDA5LCBvcF9PUkFfdG1wX3ZvaWQsICBhbV9pZW9tZF9pbW1fVDEgXSxcclxuICBbIDB4YzksIG9wX0NNUF90bXBfdm9pZCwgIGFtX2llb21kX2ltbV9UMSBdLFxyXG4gIFsgMHhlMCwgb3BfQ1BYX3RtcF92b2lkLCAgYW1faWVvbWRfaW1tX1QxIF0sXHJcbiAgWyAweGMwLCBvcF9DUFlfdG1wX3ZvaWQsICBhbV9pZW9tZF9pbW1fVDEgXSxcclxuICBbIDB4YTksIG9wX0xEQV90bXBfdm9pZCwgIGFtX2llb21kX2ltbV9UMSBdLFxyXG4gIFsgMHhhMiwgb3BfTERYX3RtcF92b2lkLCAgYW1faWVvbWRfaW1tX1QxIF0sXHJcbiAgWyAweGEwLCBvcF9MRFlfdG1wX3ZvaWQsICBhbV9pZW9tZF9pbW1fVDEgXSxcclxuICBbIDB4NjksIG9wX0FEQ190bXBfdm9pZCwgIGFtX2llb21kX2ltbV9UMSBdLFxyXG4gIFsgMHhlOSwgb3BfU0JDX3RtcF92b2lkLCAgYW1faWVvbWRfaW1tX1QxIF0sXHJcbiAgWyAweDgwLCBvcF9OT1Bfdm9pZF92b2lkLCBhbV9pZW9tZF9pbW1fVDEgXSwgICAgICAgIC8vIFF1YXNpLW9wXHJcbiAgWyAweDgyLCBvcF9OT1Bfdm9pZF92b2lkLCBhbV9pZW9tZF9pbW1fVDEgXSwgICAgICAgIC8vIFF1YXNpLW9wXHJcbiAgWyAweDg5LCBvcF9OT1Bfdm9pZF92b2lkLCBhbV9pZW9tZF9pbW1fVDEgXSwgICAgICAgIC8vIFF1YXNpLW9wXHJcbiAgWyAweGMyLCBvcF9OT1Bfdm9pZF92b2lkLCBhbV9pZW9tZF9pbW1fVDEgXSwgICAgICAgIC8vIFF1YXNpLW9wXHJcbiAgWyAweGUyLCBvcF9OT1Bfdm9pZF92b2lkLCBhbV9pZW9tZF9pbW1fVDEgXSwgICAgICAgIC8vIFF1YXNpLW9wXHJcbiAgWyAweGViLCBvcF9TQkNfdG1wX3ZvaWQsICBhbV9pZW9tZF9pbW1fVDEgXSwgICAgICAgIC8vIFF1YXNpLW9wXHJcbiAgWyAweDBiLCBvcF9BTkNfdG1wX3ZvaWQsICBhbV9pZW9tZF9pbW1fVDEgXSwgICAgICAgIC8vIFF1YXNpLW9wXHJcbiAgWyAweDJiLCBvcF9BTkNfdG1wX3ZvaWQsICBhbV9pZW9tZF9pbW1fVDEgXSwgICAgICAgIC8vIFF1YXNpLW9wXHJcbiAgWyAweDRiLCBvcF9BTFJfdG1wX3ZvaWQsICBhbV9pZW9tZF9pbW1fVDEgXSwgICAgICAgIC8vIFF1YXNpLW9wXHJcbiAgWyAweDZiLCBvcF9BUlJfdG1wX3ZvaWQsICBhbV9pZW9tZF9pbW1fVDEgXSwgICAgICAgIC8vIFF1YXNpLW9wXHJcbiAgWyAweDhiLCBvcF9BTkVfdG1wX3ZvaWQsICBhbV9pZW9tZF9pbW1fVDEgXSwgICAgICAgIC8vIFF1YXNpLW9wXHJcbiAgWyAweGFiLCBvcF9MWEFfdG1wX3ZvaWQsICBhbV9pZW9tZF9pbW1fVDEgXSwgICAgICAgIC8vIFF1YXNpLW9wXHJcbiAgWyAweGNiLCBvcF9TQlhfdG1wX3ZvaWQsICBhbV9pZW9tZF9pbW1fVDEgXSwgICAgICAgIC8vIFF1YXNpLW9wXHJcblxyXG4gIC8vIEludGVybmFsIGV4ZWN1dGlvbiBvbiBtZW1vcnkgZGF0YSAoemVybyBwYWdlKVxyXG4gIFsgMHgyNSwgb3BfQU5EX3RtcF92b2lkLCAgYW1faWVvbWRfenBfVDEgXSxcclxuICBbIDB4MjQsIG9wX0JJVF90bXBfdm9pZCwgIGFtX2llb21kX3pwX1QxIF0sXHJcbiAgWyAweDQ1LCBvcF9FT1JfdG1wX3ZvaWQsICBhbV9pZW9tZF96cF9UMSBdLFxyXG4gIFsgMHgwNSwgb3BfT1JBX3RtcF92b2lkLCAgYW1faWVvbWRfenBfVDEgXSxcclxuICBbIDB4YzUsIG9wX0NNUF90bXBfdm9pZCwgIGFtX2llb21kX3pwX1QxIF0sXHJcbiAgWyAweGU0LCBvcF9DUFhfdG1wX3ZvaWQsICBhbV9pZW9tZF96cF9UMSBdLFxyXG4gIFsgMHhjNCwgb3BfQ1BZX3RtcF92b2lkLCAgYW1faWVvbWRfenBfVDEgXSxcclxuICBbIDB4YTUsIG9wX0xEQV90bXBfdm9pZCwgIGFtX2llb21kX3pwX1QxIF0sXHJcbiAgWyAweGE2LCBvcF9MRFhfdG1wX3ZvaWQsICBhbV9pZW9tZF96cF9UMSBdLFxyXG4gIFsgMHhhNCwgb3BfTERZX3RtcF92b2lkLCAgYW1faWVvbWRfenBfVDEgXSxcclxuICBbIDB4NjUsIG9wX0FEQ190bXBfdm9pZCwgIGFtX2llb21kX3pwX1QxIF0sXHJcbiAgWyAweGU1LCBvcF9TQkNfdG1wX3ZvaWQsICBhbV9pZW9tZF96cF9UMSBdLFxyXG4gIFsgMHgwNCwgb3BfTk9QX3ZvaWRfdm9pZCwgYW1faWVvbWRfenBfVDEgXSwgICAgICAgICAvLyBRdWFzaS1vcFxyXG4gIFsgMHg0NCwgb3BfTk9QX3ZvaWRfdm9pZCwgYW1faWVvbWRfenBfVDEgXSwgICAgICAgICAvLyBRdWFzaS1vcFxyXG4gIFsgMHg2NCwgb3BfTk9QX3ZvaWRfdm9pZCwgYW1faWVvbWRfenBfVDEgXSwgICAgICAgICAvLyBRdWFzaS1vcFxyXG4gIFsgMHhhNywgb3BfTEFYX3RtcF92b2lkLCAgYW1faWVvbWRfenBfVDEgXSwgICAgICAgICAvLyBRdWFzaS1vcFxyXG5cclxuICAvLyBJbnRlcm5hbCBleGVjdXRpb24gb24gbWVtb3J5IGRhdGEgKGFic29sdXRlKVxyXG4gIFsgMHgyZCwgb3BfQU5EX3RtcF92b2lkLCAgYW1faWVvbWRfYWJzX1QxIF0sXHJcbiAgWyAweDJjLCBvcF9CSVRfdG1wX3ZvaWQsICBhbV9pZW9tZF9hYnNfVDEgXSxcclxuICBbIDB4NGQsIG9wX0VPUl90bXBfdm9pZCwgIGFtX2llb21kX2Fic19UMSBdLFxyXG4gIFsgMHgwZCwgb3BfT1JBX3RtcF92b2lkLCAgYW1faWVvbWRfYWJzX1QxIF0sXHJcbiAgWyAweGNkLCBvcF9DTVBfdG1wX3ZvaWQsICBhbV9pZW9tZF9hYnNfVDEgXSxcclxuICBbIDB4ZWMsIG9wX0NQWF90bXBfdm9pZCwgIGFtX2llb21kX2Fic19UMSBdLFxyXG4gIFsgMHhjYywgb3BfQ1BZX3RtcF92b2lkLCAgYW1faWVvbWRfYWJzX1QxIF0sXHJcbiAgWyAweGFkLCBvcF9MREFfdG1wX3ZvaWQsICBhbV9pZW9tZF9hYnNfVDEgXSxcclxuICBbIDB4YWUsIG9wX0xEWF90bXBfdm9pZCwgIGFtX2llb21kX2Fic19UMSBdLFxyXG4gIFsgMHhhYywgb3BfTERZX3RtcF92b2lkLCAgYW1faWVvbWRfYWJzX1QxIF0sXHJcbiAgWyAweDZkLCBvcF9BRENfdG1wX3ZvaWQsICBhbV9pZW9tZF9hYnNfVDEgXSxcclxuICBbIDB4ZWQsIG9wX1NCQ190bXBfdm9pZCwgIGFtX2llb21kX2Fic19UMSBdLFxyXG4gIFsgMHhhZiwgb3BfTEFYX3RtcF92b2lkLCAgYW1faWVvbWRfYWJzX1QxIF0sICAgICAgICAvLyBRdWFzaS1vcFxyXG5cclxuICAvLyBJbnRlcm5hbCBleGVjdXRpb24gb24gbWVtb3J5IGRhdGEgKGluZGlyZWN0LFgpXHJcbiAgWyAweDIxLCBvcF9BTkRfdG1wX3ZvaWQsICBhbV9pZW9tZF9pbnhfVDEgXSxcclxuICBbIDB4NDEsIG9wX0VPUl90bXBfdm9pZCwgIGFtX2llb21kX2lueF9UMSBdLFxyXG4gIFsgMHgwMSwgb3BfT1JBX3RtcF92b2lkLCAgYW1faWVvbWRfaW54X1QxIF0sXHJcbiAgWyAweGMxLCBvcF9DTVBfdG1wX3ZvaWQsICBhbV9pZW9tZF9pbnhfVDEgXSxcclxuICBbIDB4YTEsIG9wX0xEQV90bXBfdm9pZCwgIGFtX2llb21kX2lueF9UMSBdLFxyXG4gIFsgMHg2MSwgb3BfQURDX3RtcF92b2lkLCAgYW1faWVvbWRfaW54X1QxIF0sXHJcbiAgWyAweGUxLCBvcF9TQkNfdG1wX3ZvaWQsICBhbV9pZW9tZF9pbnhfVDEgXSxcclxuICBbIDB4YTMsIG9wX0xBWF90bXBfdm9pZCwgIGFtX2llb21kX2lueF9UMSBdLCAgICAgICAgLy8gUXVhc2ktb3BcclxuXHJcbiAgLy8gSW50ZXJuYWwgZXhlY3V0aW9uIG9uIG1lbW9yeSBkYXRhIChhYnNvbHV0ZSxYKVxyXG4gIFsgMHgzZCwgb3BfQU5EX3RtcF92b2lkLCAgYW1faWVvbWRfYWJ4X1QxIF0sXHJcbiAgWyAweDVkLCBvcF9FT1JfdG1wX3ZvaWQsICBhbV9pZW9tZF9hYnhfVDEgXSxcclxuICBbIDB4MWQsIG9wX09SQV90bXBfdm9pZCwgIGFtX2llb21kX2FieF9UMSBdLFxyXG4gIFsgMHhkZCwgb3BfQ01QX3RtcF92b2lkLCAgYW1faWVvbWRfYWJ4X1QxIF0sXHJcbiAgWyAweGJkLCBvcF9MREFfdG1wX3ZvaWQsICBhbV9pZW9tZF9hYnhfVDEgXSxcclxuICBbIDB4YmMsIG9wX0xEWV90bXBfdm9pZCwgIGFtX2llb21kX2FieF9UMSBdLFxyXG4gIFsgMHg3ZCwgb3BfQURDX3RtcF92b2lkLCAgYW1faWVvbWRfYWJ4X1QxIF0sXHJcbiAgWyAweGZkLCBvcF9TQkNfdG1wX3ZvaWQsICBhbV9pZW9tZF9hYnhfVDEgXSxcclxuICBbIDB4MGMsIG9wX05PUF92b2lkX3ZvaWQsIGFtX2llb21kX2FieF9UMSBdLCAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4MWMsIG9wX05PUF92b2lkX3ZvaWQsIGFtX2llb21kX2FieF9UMSBdLCAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4M2MsIG9wX05PUF92b2lkX3ZvaWQsIGFtX2llb21kX2FieF9UMSBdLCAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4NWMsIG9wX05PUF92b2lkX3ZvaWQsIGFtX2llb21kX2FieF9UMSBdLCAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4N2MsIG9wX05PUF92b2lkX3ZvaWQsIGFtX2llb21kX2FieF9UMSBdLCAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4ZGMsIG9wX05PUF92b2lkX3ZvaWQsIGFtX2llb21kX2FieF9UMSBdLCAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4ZmMsIG9wX05PUF92b2lkX3ZvaWQsIGFtX2llb21kX2FieF9UMSBdLCAgICAgICAgLy8gUXVhc2ktb3BcclxuXHJcbiAgLy8gSW50ZXJuYWwgZXhlY3V0aW9uIG9uIG1lbW9yeSBkYXRhIChhYnNvbHV0ZSxZKVxyXG4gIFsgMHgzOSwgb3BfQU5EX3RtcF92b2lkLCAgYW1faWVvbWRfYWJ5X1QxIF0sXHJcbiAgWyAweDU5LCBvcF9FT1JfdG1wX3ZvaWQsICBhbV9pZW9tZF9hYnlfVDEgXSxcclxuICBbIDB4MTksIG9wX09SQV90bXBfdm9pZCwgIGFtX2llb21kX2FieV9UMSBdLFxyXG4gIFsgMHhkOSwgb3BfQ01QX3RtcF92b2lkLCAgYW1faWVvbWRfYWJ5X1QxIF0sXHJcbiAgWyAweGI5LCBvcF9MREFfdG1wX3ZvaWQsICBhbV9pZW9tZF9hYnlfVDEgXSxcclxuICBbIDB4YmUsIG9wX0xEWF90bXBfdm9pZCwgIGFtX2llb21kX2FieV9UMSBdLFxyXG4gIFsgMHg3OSwgb3BfQURDX3RtcF92b2lkLCAgYW1faWVvbWRfYWJ5X1QxIF0sXHJcbiAgWyAweGY5LCBvcF9TQkNfdG1wX3ZvaWQsICBhbV9pZW9tZF9hYnlfVDEgXSxcclxuICBbIDB4YmYsIG9wX0xBWF90bXBfdm9pZCwgIGFtX2llb21kX2FieV9UMSBdLCAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4YmIsIG9wX0xBU190bXBfdm9pZCwgIGFtX2llb21kX2FieV9UMSBdLCAgICAgICAgLy8gUXVhc2ktb3BcclxuXHJcbiAgLy8gSW50ZXJuYWwgZXhlY3V0aW9uIG9uIG1lbW9yeSBkYXRhICh6ZXJvIHBhZ2UsWClcclxuICBbIDB4MzUsIG9wX0FORF90bXBfdm9pZCwgIGFtX2llb21kX3pweF9UMSBdLFxyXG4gIFsgMHg1NSwgb3BfRU9SX3RtcF92b2lkLCAgYW1faWVvbWRfenB4X1QxIF0sXHJcbiAgWyAweDE1LCBvcF9PUkFfdG1wX3ZvaWQsICBhbV9pZW9tZF96cHhfVDEgXSxcclxuICBbIDB4ZDUsIG9wX0NNUF90bXBfdm9pZCwgIGFtX2llb21kX3pweF9UMSBdLFxyXG4gIFsgMHhiNSwgb3BfTERBX3RtcF92b2lkLCAgYW1faWVvbWRfenB4X1QxIF0sXHJcbiAgWyAweGI0LCBvcF9MRFlfdG1wX3ZvaWQsICBhbV9pZW9tZF96cHhfVDEgXSxcclxuICBbIDB4NzUsIG9wX0FEQ190bXBfdm9pZCwgIGFtX2llb21kX3pweF9UMSBdLFxyXG4gIFsgMHhmNSwgb3BfU0JDX3RtcF92b2lkLCAgYW1faWVvbWRfenB4X1QxIF0sXHJcblxyXG4gIC8vIEludGVybmFsIGV4ZWN1dGlvbiBvbiBtZW1vcnkgZGF0YSAoemVybyBwYWdlLFkpXHJcbiAgWyAweGI2LCBvcF9MRFhfdG1wX3ZvaWQsICBhbV9pZW9tZF96cHlfVDEgXSxcclxuICBbIDB4YjcsIG9wX0xBWF90bXBfdm9pZCwgIGFtX2llb21kX3pweV9UMSBdLCAgICAgICAgLy8gUXVhc2ktb3BcclxuXHJcbiAgLy8gSW50ZXJuYWwgZXhlY3V0aW9uIG9uIG1lbW9yeSBkYXRhIChpbmRpcmVjdCxZKVxyXG4gIFsgMHgzMSwgb3BfQU5EX3RtcF92b2lkLCAgYW1faWVvbWRfaW55X1QxIF0sXHJcbiAgWyAweDUxLCBvcF9FT1JfdG1wX3ZvaWQsICBhbV9pZW9tZF9pbnlfVDEgXSxcclxuICBbIDB4MTEsIG9wX09SQV90bXBfdm9pZCwgIGFtX2llb21kX2lueV9UMSBdLFxyXG4gIFsgMHhkMSwgb3BfQ01QX3RtcF92b2lkLCAgYW1faWVvbWRfaW55X1QxIF0sXHJcbiAgWyAweGIxLCBvcF9MREFfdG1wX3ZvaWQsICBhbV9pZW9tZF9pbnlfVDEgXSxcclxuICBbIDB4NzEsIG9wX0FEQ190bXBfdm9pZCwgIGFtX2llb21kX2lueV9UMSBdLFxyXG4gIFsgMHhmMSwgb3BfU0JDX3RtcF92b2lkLCAgYW1faWVvbWRfaW55X1QxIF0sXHJcbiAgWyAweGIzLCBvcF9MQVhfdG1wX3ZvaWQsICBhbV9pZW9tZF9pbnlfVDEgXSwgICAgICAgIC8vIFF1YXNpLW9wXHJcblxyXG4gIC8vIFN0b3JlIG9wZXJhdGlvbnMgKHplcm8gcGFnZSlcclxuICBbIDB4ODUsIG9wX1NUQV92b2lkX3JldCwgIGFtX3N0b3JlX3pwX1QxIF0sXHJcbiAgWyAweDg2LCBvcF9TVFhfdm9pZF9yZXQsICBhbV9zdG9yZV96cF9UMSBdLFxyXG4gIFsgMHg4NCwgb3BfU1RZX3ZvaWRfcmV0LCAgYW1fc3RvcmVfenBfVDEgXSxcclxuICBbIDB4ODcsIG9wX0FYU192b2lkX3JldCwgIGFtX3N0b3JlX3pwX1QxIF0sICAgICAgICAgLy8gUXVhc2ktb3BcclxuXHJcbiAgLy8gU3RvcmUgb3BlcmF0aW9ucyAoYWJzb2x1dGUpXHJcbiAgWyAweDhkLCBvcF9TVEFfdm9pZF9yZXQsICBhbV9zdG9yZV9hYnNfVDEgXSxcclxuICBbIDB4OGUsIG9wX1NUWF92b2lkX3JldCwgIGFtX3N0b3JlX2Fic19UMSBdLFxyXG4gIFsgMHg4Yywgb3BfU1RZX3ZvaWRfcmV0LCAgYW1fc3RvcmVfYWJzX1QxIF0sXHJcbiAgWyAweDhmLCBvcF9BWFNfdm9pZF9yZXQsICBhbV9zdG9yZV9hYnNfVDEgXSwgICAgICAgIC8vIFF1YXNpLW9wXHJcblxyXG4gIC8vIFN0b3JlIG9wZXJhdGlvbnMgKGluZGlyZWN0LFgpXHJcbiAgWyAweDgxLCBvcF9TVEFfdm9pZF9yZXQsICBhbV9zdG9yZV9pbnhfVDEgXSxcclxuICBbIDB4ODMsIG9wX0FYU192b2lkX3JldCwgIGFtX3N0b3JlX2lueF9UMSBdLCAgICAgICAgLy8gUXVhc2ktb3BcclxuXHJcbiAgLy8gU3RvcmUgb3BlcmF0aW9ucyAoYWJzb2x1dGUsWClcclxuICBbIDB4OWQsIG9wX1NUQV92b2lkX3JldCwgIGFtX3N0b3JlX2FieF9UMSBdLFxyXG4gIFsgMHg5Yywgb3BfU0hZX3ZvaWRfcmV0LCAgYW1fc3RvcmVfYWJ4X1QxIF0sICAgICAgICAvLyBRdWFzaS1vcFxyXG5cclxuICAvLyBTdG9yZSBvcGVyYXRpb25zIChhYnNvbHV0ZSxZKVxyXG4gIFsgMHg5OSwgb3BfU1RBX3ZvaWRfcmV0LCAgYW1fc3RvcmVfYWJ5X1QxIF0sXHJcbiAgWyAweDlmLCBvcF9TSEFfdm9pZF9yZXQsICBhbV9zdG9yZV9hYnlfVDEgXSwgICAgICAgIC8vIFF1YXNpLW9wXHJcbiAgWyAweDliLCBvcF9TSFNfdm9pZF9yZXQsICBhbV9zdG9yZV9hYnlfVDEgXSwgICAgICAgIC8vIFF1YXNpLW9wXHJcbiAgWyAweDllLCBvcF9TSFhfdm9pZF9yZXQsICBhbV9zdG9yZV9hYnlfVDEgXSwgICAgICAgIC8vIFF1YXNpLW9wXHJcblxyXG4gIC8vIFN0b3JlIG9wZXJhdGlvbnMgKHplcm8gcGFnZSxYKVxyXG4gIFsgMHg5NSwgb3BfU1RBX3ZvaWRfcmV0LCAgYW1fc3RvcmVfenB4X1QxIF0sXHJcbiAgWyAweDk0LCBvcF9TVFlfdm9pZF9yZXQsICBhbV9zdG9yZV96cHhfVDEgXSxcclxuXHJcbiAgLy8gU3RvcmUgb3BlcmF0aW9ucyAoemVybyBwYWdlLFkpXHJcbiAgWyAweDk2LCBvcF9TVFhfdm9pZF9yZXQsICBhbV9zdG9yZV96cHlfVDEgXSxcclxuICBbIDB4OTcsIG9wX0FYU192b2lkX3JldCwgIGFtX3N0b3JlX3pweV9UMSBdLCAgICAgICAgLy8gUXVhc2ktb3BcclxuXHJcbiAgLy8gU3RvcmUgb3BlcmF0aW9ucyAoaW5kaXJlY3QsWSlcclxuICBbIDB4OTEsIG9wX1NUQV92b2lkX3JldCwgIGFtX3N0b3JlX2lueV9UMSBdLFxyXG4gIFsgMHg5Mywgb3BfU0hBX3ZvaWRfcmV0LCAgYW1fc3RvcmVfaW55X1QxIF0sICAgICAgICAvLyBRdWFzaS1vcFxyXG5cclxuICAvLyBSZWFkLW1vZGlmeS13cml0ZSBvcGVyYXRpb25zICh6ZXJvIHBhZ2UpXHJcbiAgWyAweDA2LCBvcF9BU0xfYXJnX3JldCwgICBhbV9ybXdfenBfVDEgXSxcclxuICBbIDB4NDYsIG9wX0xTUl9hcmdfcmV0LCAgIGFtX3Jtd196cF9UMSBdLFxyXG4gIFsgMHgyNiwgb3BfUk9MX2FyZ19yZXQsICAgYW1fcm13X3pwX1QxIF0sXHJcbiAgWyAweDY2LCBvcF9ST1JfYXJnX3JldCwgICBhbV9ybXdfenBfVDEgXSxcclxuICBbIDB4ZTYsIG9wX0lOQ19hcmdfcmV0LCAgIGFtX3Jtd196cF9UMSBdLFxyXG4gIFsgMHhjNiwgb3BfREVDX2FyZ19yZXQsICAgYW1fcm13X3pwX1QxIF0sXHJcbiAgWyAweDQ3LCBvcF9MU0VfYXJnX3JldCwgICBhbV9ybXdfenBfVDEgXSwgICAgICAgICAgIC8vIFF1YXNpLW9wXHJcbiAgWyAweGM3LCBvcF9EQ01fYXJnX3JldCwgICBhbV9ybXdfenBfVDEgXSwgICAgICAgICAgIC8vIFF1YXNpLW9wXHJcbiAgWyAweDA3LCBvcF9BU09fYXJnX3JldCwgICBhbV9ybXdfenBfVDEgXSwgICAgICAgICAgIC8vIFF1YXNpLW9wXHJcbiAgWyAweDI3LCBvcF9STEFfYXJnX3JldCwgICBhbV9ybXdfenBfVDEgXSwgICAgICAgICAgIC8vIFF1YXNpLW9wXHJcbiAgWyAweDY3LCBvcF9SUkFfYXJnX3JldCwgICBhbV9ybXdfenBfVDEgXSwgICAgICAgICAgIC8vIFF1YXNpLW9wXHJcbiAgWyAweGU3LCBvcF9JTlNfYXJnX3JldCwgICBhbV9ybXdfenBfVDEgXSwgICAgICAgICAgIC8vIFF1YXNpLW9wXHJcblxyXG4gIC8vIFJlYWQtbW9kaWZ5LXdyaXRlIG9wZXJhdGlvbnMgKGFic29sdXRlKVxyXG4gIFsgMHgwZSwgb3BfQVNMX2FyZ19yZXQsICAgYW1fcm13X2Fic19UMSBdLFxyXG4gIFsgMHgyZSwgb3BfUk9MX2FyZ19yZXQsICAgYW1fcm13X2Fic19UMSBdLFxyXG4gIFsgMHg2ZSwgb3BfUk9SX2FyZ19yZXQsICAgYW1fcm13X2Fic19UMSBdLFxyXG4gIFsgMHg0ZSwgb3BfTFNSX2FyZ19yZXQsICAgYW1fcm13X2Fic19UMSBdLFxyXG4gIFsgMHhlZSwgb3BfSU5DX2FyZ19yZXQsICAgYW1fcm13X2Fic19UMSBdLFxyXG4gIFsgMHhjZSwgb3BfREVDX2FyZ19yZXQsICAgYW1fcm13X2Fic19UMSBdLFxyXG4gIFsgMHg0Ziwgb3BfTFNFX2FyZ19yZXQsICAgYW1fcm13X2Fic19UMSBdLCAgICAgICAgICAvLyBRdWFzaS1vcFxyXG4gIFsgMHhjZiwgb3BfRENNX2FyZ19yZXQsICAgYW1fcm13X2Fic19UMSBdLCAgICAgICAgICAvLyBRdWFzaS1vcFxyXG4gIFsgMHgwZiwgb3BfQVNPX2FyZ19yZXQsICAgYW1fcm13X2Fic19UMSBdLCAgICAgICAgICAvLyBRdWFzaS1vcFxyXG4gIFsgMHgyZiwgb3BfUkxBX2FyZ19yZXQsICAgYW1fcm13X2Fic19UMSBdLCAgICAgICAgICAvLyBRdWFzaS1vcFxyXG4gIFsgMHg2Ziwgb3BfUlJBX2FyZ19yZXQsICAgYW1fcm13X2Fic19UMSBdLCAgICAgICAgICAvLyBRdWFzaS1vcFxyXG4gIFsgMHhlZiwgb3BfSU5TX2FyZ19yZXQsICAgYW1fcm13X2Fic19UMSBdLCAgICAgICAgICAvLyBRdWFzaS1vcFxyXG5cclxuICAvLyBSZWFkLW1vZGlmeS13cml0ZSBvcGVyYXRpb25zICh6ZXJvIHBhZ2UsWClcclxuICBbIDB4MTYsIG9wX0FTTF9hcmdfcmV0LCAgIGFtX3Jtd196cHhfVDEgXSxcclxuICBbIDB4MzYsIG9wX1JPTF9hcmdfcmV0LCAgIGFtX3Jtd196cHhfVDEgXSxcclxuICBbIDB4NzYsIG9wX1JPUl9hcmdfcmV0LCAgIGFtX3Jtd196cHhfVDEgXSxcclxuICBbIDB4NTYsIG9wX0xTUl9hcmdfcmV0LCAgIGFtX3Jtd196cHhfVDEgXSxcclxuICBbIDB4ZjYsIG9wX0lOQ19hcmdfcmV0LCAgIGFtX3Jtd196cHhfVDEgXSxcclxuICBbIDB4ZDYsIG9wX0RFQ19hcmdfcmV0LCAgIGFtX3Jtd196cHhfVDEgXSxcclxuICBbIDB4MTQsIG9wX05PUF9hcmdfcmV0LCAgIGFtX3Jtd196cHhfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4MzQsIG9wX05PUF9hcmdfcmV0LCAgIGFtX3Jtd196cHhfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4NTQsIG9wX05PUF9hcmdfcmV0LCAgIGFtX3Jtd196cHhfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4NzQsIG9wX05PUF9hcmdfcmV0LCAgIGFtX3Jtd196cHhfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4ZDQsIG9wX05PUF9hcmdfcmV0LCAgIGFtX3Jtd196cHhfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4ZjQsIG9wX05PUF9hcmdfcmV0LCAgIGFtX3Jtd196cHhfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4NTcsIG9wX0xTRV9hcmdfcmV0LCAgIGFtX3Jtd196cHhfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4ZDcsIG9wX0RDTV9hcmdfcmV0LCAgIGFtX3Jtd196cHhfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4MTcsIG9wX0FTT19hcmdfcmV0LCAgIGFtX3Jtd196cHhfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4MzcsIG9wX1JMQV9hcmdfcmV0LCAgIGFtX3Jtd196cHhfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4NzcsIG9wX1JSQV9hcmdfcmV0LCAgIGFtX3Jtd196cHhfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4ZjcsIG9wX0lOU19hcmdfcmV0LCAgIGFtX3Jtd196cHhfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuXHJcbiAgLy8gUmVhZC1tb2RpZnktd3JpdGUgb3BlcmF0aW9ucyAoYWJzb2x1dGUsWClcclxuICBbIDB4MWUsIG9wX0FTTF9hcmdfcmV0LCAgIGFtX3Jtd19hYnhfVDEgXSxcclxuICBbIDB4M2UsIG9wX1JPTF9hcmdfcmV0LCAgIGFtX3Jtd19hYnhfVDEgXSxcclxuICBbIDB4N2UsIG9wX1JPUl9hcmdfcmV0LCAgIGFtX3Jtd19hYnhfVDEgXSxcclxuICBbIDB4NWUsIG9wX0xTUl9hcmdfcmV0LCAgIGFtX3Jtd19hYnhfVDEgXSxcclxuICBbIDB4ZmUsIG9wX0lOQ19hcmdfcmV0LCAgIGFtX3Jtd19hYnhfVDEgXSxcclxuICBbIDB4ZGUsIG9wX0RFQ19hcmdfcmV0LCAgIGFtX3Jtd19hYnhfVDEgXSxcclxuICBbIDB4NWYsIG9wX0xTRV9hcmdfcmV0LCAgIGFtX3Jtd19hYnhfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4ZGYsIG9wX0RDTV9hcmdfcmV0LCAgIGFtX3Jtd19hYnhfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4MWYsIG9wX0FTT19hcmdfcmV0LCAgIGFtX3Jtd19hYnhfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4M2YsIG9wX1JMQV9hcmdfcmV0LCAgIGFtX3Jtd19hYnhfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4M2YsIG9wX1JMQV9hcmdfcmV0LCAgIGFtX3Jtd19hYnhfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4N2YsIG9wX1JSQV9hcmdfcmV0LCAgIGFtX3Jtd19hYnhfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4ZmYsIG9wX0lOU19hcmdfcmV0LCAgIGFtX3Jtd19hYnhfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuXHJcbiAgLy8gUmVhZC1tb2RpZnktd3JpdGUgb3BlcmF0aW9ucyAoYWJzb2x1dGUsWSlcclxuICBbIDB4NWIsIG9wX0xTRV9hcmdfcmV0LCAgIGFtX3Jtd19hYnlfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4ZGIsIG9wX0RDTV9hcmdfcmV0LCAgIGFtX3Jtd19hYnlfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4MWIsIG9wX0FTT19hcmdfcmV0LCAgIGFtX3Jtd19hYnlfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4M2IsIG9wX1JMQV9hcmdfcmV0LCAgIGFtX3Jtd19hYnlfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4N2IsIG9wX1JSQV9hcmdfcmV0LCAgIGFtX3Jtd19hYnlfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4ZmIsIG9wX0lOU19hcmdfcmV0LCAgIGFtX3Jtd19hYnlfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuXHJcbiAgLy8gUmVhZC1tb2RpZnktd3JpdGUgb3BlcmF0aW9ucyAoaW5kaXJlY3QsWClcclxuICBbIDB4NDMsIG9wX0xTRV9hcmdfcmV0LCAgIGFtX3Jtd19pbnhfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4YzMsIG9wX0RDTV9hcmdfcmV0LCAgIGFtX3Jtd19pbnhfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4MDMsIG9wX0FTT19hcmdfcmV0LCAgIGFtX3Jtd19pbnhfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4MjMsIG9wX1JMQV9hcmdfcmV0LCAgIGFtX3Jtd19pbnhfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4NjMsIG9wX1JSQV9hcmdfcmV0LCAgIGFtX3Jtd19pbnhfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4ZTMsIG9wX0lOU19hcmdfcmV0LCAgIGFtX3Jtd19pbnhfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuXHJcbiAgLy8gUmVhZC1tb2RpZnktd3JpdGUgb3BlcmF0aW9ucyAoaW5kaXJlY3QsWSlcclxuICBbIDB4NTMsIG9wX0xTRV9hcmdfcmV0LCAgIGFtX3Jtd19pbnlfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4ZDMsIG9wX0RDTV9hcmdfcmV0LCAgIGFtX3Jtd19pbnlfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4MTMsIG9wX0FTT19hcmdfcmV0LCAgIGFtX3Jtd19pbnlfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4MzMsIG9wX1JMQV9hcmdfcmV0LCAgIGFtX3Jtd19pbnlfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4NzMsIG9wX1JSQV9hcmdfcmV0LCAgIGFtX3Jtd19pbnlfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuICBbIDB4ZjMsIG9wX0lOU19hcmdfcmV0LCAgIGFtX3Jtd19pbnlfVDEgXSwgICAgICAgICAgLy8gUXVhc2ktb3BcclxuXHJcbiAgLy8gTWlzY2VsbGFuZW91cyBvcGVyYXRpb25zIChwdXNoKVxyXG4gIFsgMHg0OCwgb3BfUEhBX3ZvaWRfcmV0LCAgYW1fcHVzaF9UMSBdLFxyXG4gIFsgMHgwOCwgb3BfUEhQX3ZvaWRfcmV0LCAgYW1fcHVzaF9UMSBdLFxyXG5cclxuICAvLyBNaXNjZWxsYW5lb3VzIG9wZXJhdGlvbnMgKHB1bGwpXHJcbiAgWyAweDY4LCBvcF9QTEFfYXJnX3ZvaWQsICBhbV9wdWxsX1QxIF0sXHJcbiAgWyAweDI4LCBvcF9QTFBfYXJnX3ZvaWQsICBhbV9wdWxsX1QxIF0sXHJcblxyXG4gIC8vIE1pc2NlbGxhbmVvdXMgb3BlcmF0aW9ucyAoanVtcCB0byBzdWJyb3V0aW5lKVxyXG4gIFsgMHgyMCwgb3BfSlNSX3ZvaWRfdm9pZCwgYW1fanNyX1QxIF0sXHJcblxyXG4gIC8vIE1pc2NlbGxhbmVvdXMgb3BlcmF0aW9ucyAoYnJlYWspXHJcbiAgWyAweDAwLCBvcF9CUktfdm9pZF92b2lkLCBhbV9pbnRlcnJ1cHRfVDEgXSxcclxuXHJcbiAgLy8gTWlzY2VsbGFuZW91cyBvcGVyYXRpb25zIChyZXR1cm4gZnJvbSBpbnRlcnJ1cHQpXHJcbiAgWyAweDQwLCBvcF9SVElfdm9pZF92b2lkLCBhbV9ydGlfVDEgXSxcclxuXHJcbiAgLy8gSnVtcCBvcGVyYXRpb24gKGFic29sdXRlKVxyXG4gIFsgMHg0Yywgb3BfSk1QX3ZvaWRfdm9pZCwgYW1fam1wX2Fic19UMSBdLFxyXG5cclxuICAvLyBKdW1wIG9wZXJhdGlvbiAoaW5kaXJlY3QpXHJcbiAgWyAweDZjLCBvcF9KTVBfdm9pZF92b2lkLCBhbV9qbXBfaW5kX1QxIF0sXHJcblxyXG4gIC8vIE1pc2NlbGxhbmVvdXMgb3BlcmF0aW9ucyAocmV0dXJuIGZyb20gc3Vicm91dGluZSlcclxuICBbIDB4NjAsIG9wX1JUU192b2lkX3ZvaWQsIGFtX3J0c19UMSBdLFxyXG5cclxuICAvLyBNaXNjZWxsYW5lb3VzIG9wZXJhdGlvbnMgKGJyYW5jaClcclxuICBbIDB4OTAsIG9wX0JDQ192b2lkX3JldCwgIGFtX3JlbF9UMSBdLFxyXG4gIFsgMHhiMCwgb3BfQkNTX3ZvaWRfcmV0LCAgYW1fcmVsX1QxIF0sXHJcbiAgWyAweGYwLCBvcF9CRVFfdm9pZF9yZXQsICBhbV9yZWxfVDEgXSxcclxuICBbIDB4MzAsIG9wX0JNSV92b2lkX3JldCwgIGFtX3JlbF9UMSBdLFxyXG4gIFsgMHhkMCwgb3BfQk5FX3ZvaWRfcmV0LCAgYW1fcmVsX1QxIF0sXHJcbiAgWyAweDEwLCBvcF9CUExfdm9pZF9yZXQsICBhbV9yZWxfVDEgXSxcclxuICBbIDB4NTAsIG9wX0JWQ192b2lkX3JldCwgIGFtX3JlbF9UMSBdLFxyXG4gIFsgMHg3MCwgb3BfQlZTX3ZvaWRfcmV0LCAgYW1fcmVsX1QxIF0sXHJcblxyXG4gIC8vIElycmVjb3ZlcmFibGUgZmFpbHVyZVxyXG4gIFsgMHgwMiwgb3BfSExUX3ZvaWRfdm9pZCwgYW1faGFsdF9UMSBdLFxyXG4gIFsgMHgxMiwgb3BfSExUX3ZvaWRfdm9pZCwgYW1faGFsdF9UMSBdLFxyXG4gIFsgMHgyMiwgb3BfSExUX3ZvaWRfdm9pZCwgYW1faGFsdF9UMSBdLFxyXG4gIFsgMHgzMiwgb3BfSExUX3ZvaWRfdm9pZCwgYW1faGFsdF9UMSBdLFxyXG4gIFsgMHg0Miwgb3BfSExUX3ZvaWRfdm9pZCwgYW1faGFsdF9UMSBdLFxyXG4gIFsgMHg1Miwgb3BfSExUX3ZvaWRfdm9pZCwgYW1faGFsdF9UMSBdLFxyXG4gIFsgMHg2Miwgb3BfSExUX3ZvaWRfdm9pZCwgYW1faGFsdF9UMSBdLFxyXG4gIFsgMHg3Miwgb3BfSExUX3ZvaWRfdm9pZCwgYW1faGFsdF9UMSBdLFxyXG4gIFsgMHg5Miwgb3BfSExUX3ZvaWRfdm9pZCwgYW1faGFsdF9UMSBdLFxyXG4gIFsgMHhiMiwgb3BfSExUX3ZvaWRfdm9pZCwgYW1faGFsdF9UMSBdLFxyXG4gIFsgMHhkMiwgb3BfSExUX3ZvaWRfdm9pZCwgYW1faGFsdF9UMSBdLFxyXG4gIFsgMHhmMiwgb3BfSExUX3ZvaWRfdm9pZCwgYW1faGFsdF9UMSBdLFxyXG5cclxuXS5mb3JFYWNoKFxyXG4gIChbIG9wY29kZSwgb3BGbiwgdDEgXSkgPT4ge1xyXG4gICAgYW1fVDFfZm9yT3Bjb2RlW29wY29kZV0gPSB0MTtcclxuICAgICBvcEZuX2Zvck9wY29kZVtvcGNvZGVdID0gb3BGbjtcclxuICB9XHJcbik7XHJcblxyXG5mdW5jdGlvbiBmZF9mZXRjaF9UMCgpIHtcclxuXHJcbiAgLy8gQmVhcmluZyBpbiBtaW5kIHRoYXQgdGhpcyBjeWNsZSB1c3VhbGx5IHJ1bnMgY29uY3VycmVudGx5IHdpdGggYW4gYW1fIFxyXG4gIC8vIGN5Y2xlLCB3ZSBoYXZlIHRvIGJlIHZlcnkgY2FyZWZ1bCB3aGljaCByZWdpc3RlcnMgd2UgdXNlIGhlcmUuXHJcblxyXG4gIHN0YXRlLmlyID0gY3B1UmVhZChzdGF0ZS5wYyk7XHJcblxyXG4gIC8vIFRPRE86IEkgZ2F0aGVyIHRoaXMgZG9lc24ndCBoYXBwZW4gaGVyZSwgYnV0IG9uIHRoZSBsYXN0IFRuIG9mIGFueSBtb2RlXHJcbiAgcG9sbEZvckludGVycnVwdHMoKTtcclxuXHJcbiAgLy8gTGF0Y2ggdGhlIGluc3RydWN0aW9uIHJlZ2lzdGVyIGZyb20gemVybyAoQlJLKSBpZiB0aGVyZSBhcmUgaW50ZXJydXB0c1xyXG4gIGlmIChzdGF0ZS5wZW5kaW5nSW50KSB7XHJcbiAgICBzdGF0ZS5pciA9IDA7XHJcbiAgfVxyXG4gIGVsc2Uge1xyXG4gICAgc3RhdGUucGMgPSArK3N0YXRlLnBjICYgMHhmZmZmO1xyXG4gIH1cclxuXHJcbiAgc3RhdGUuZmRUaWNrID0gZmRfZGVjb2RlX1QxO1xyXG59XHJcblxyXG5jb25zdCB2aXNpdGVkUGNzID0gbmV3IFNldCgpO1xyXG5cclxuZnVuY3Rpb24gZmRfZGVjb2RlX1QxKCkge1xyXG5cclxuICAvLyB7XHJcbiAgLy8gICBzdGF0ZS5wYy0tO1xyXG4gIC8vICAgaWYgKCF2aXNpdGVkUGNzLmhhcyhzdGF0ZS5wYykpIHtcclxuICAvLyAgICAgdmlzaXRlZFBjcy5hZGQoc3RhdGUucGMpO1xyXG4gIC8vICAgICBzaG93U3RhdGUoKTtcclxuICAvLyAgIH1cclxuICAvLyAgIHN0YXRlLnBjKys7XHJcbiAgLy8gfVxyXG5cclxuICBjb25zdCAgb3BGbiA9ICBvcEZuX2Zvck9wY29kZVtzdGF0ZS5pcl07XHJcbiAgY29uc3QgYW1fVDEgPSBhbV9UMV9mb3JPcGNvZGVbc3RhdGUuaXJdO1xyXG5cclxuICBzdGF0ZS50bXAgPSBjcHVSZWFkKHN0YXRlLnBjKTtcclxuXHJcbiAgLy8gTm93IHJ1biB0aGUgVDEgc3RhZ2UgZm9yIHRoZSBhZGRyZXNzaW5nIG1vZGUgc2VxdWVuY2UuIFVzdWFsbHkgdGhlXHJcbiAgLy8gQ1BVIHRpY2sgZnVuY3Rpb24gd291bGQgY2FsbCB0aGlzIGF0IHRoZSBzdGFydCBvZiB0aGUgY3ljbGUsIGJ1dCBoYXZpbmdcclxuICAvLyBkZWNvZGVkIHRoZSBvcGNvZGUsIHRoZXJlJ3Mgc3RpbGwgYSBzbWFsbCBiaXQgb2YgdGltZSBsZWZ0IGluIHRoaXMgY3ljbGUsXHJcbiAgLy8gYW5kIHRoZSBDUFUgc2VlbXMgdG8gdXNlIGl0IHRvIGluY3JlbWVudCB0aGUgUEMgaWYgdGhlIHNlcXVlbmNlIGNhbGxzIGZvclxyXG4gIC8vIGl0LiBUaGUgVDEgaGFuZGxlciBjYW4gYXNzaWduIHRoZSBuZXh0IGFtVGljayB0aWNrIGhhbmRsZXIgZnVuY3Rpb24sIGFzIGl0XHJcbiAgLy8gd291bGQgZm9yIGFueSBvdGhlciBzdGFnZSwgYnV0IGl0ICptdXN0KiByZWFzc2lnbiBmZFRpY2ssIG90aGVyd2lzZSB0aGVcclxuICAvLyBDUFUgd2lsbCBiZSBkZWNvZGluZyBpbnN0cnVjdGlvbnMgZXZlcnkgY3ljbGUuXHJcblxyXG4gIHN0YXRlLm9wRm4gPSBvcEZuO1xyXG4gIGFtX1QxKCk7XHJcbn1cclxuXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIFNpbmdsZSBieXRlIGluc3RydWN0aW9ucyAoaW1wbGljaXQpXHJcbi8vICjigKAzOiBBLiAxKVxyXG5cclxuZnVuY3Rpb24gYW1fc2luZ2xlQnl0ZV9pbXBfVDEoKSB7XHJcbiAgc3RhdGUuZmRUaWNrID0gZmRfZmV0Y2hfVDA7XHJcbiAgc3RhdGUuYW1UaWNrID0gYW1fc2luZ2xlQnl0ZV9pbXBfVDI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX3NpbmdsZUJ5dGVfaW1wX1QyKCkge1xyXG4gIHN0YXRlLm9wRm4oKTtcclxuICBzdGF0ZS5hbVRpY2sgPSBudWxsO1xyXG59XHJcblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBTaW5nbGUgYnl0ZSBpbnN0cnVjdGlvbnMgKGFjY3VtdWxhdG9yKVxyXG4vLyAo4oCgMzogQS4gMSlcclxuXHJcbmZ1bmN0aW9uIGFtX3NpbmdsZUJ5dGVfYWNjX1QxKCkge1xyXG4gIHN0YXRlLmZkVGljayA9IGZkX2ZldGNoX1QwO1xyXG4gIHN0YXRlLmFtVGljayA9IGFtX3NpbmdsZUJ5dGVfYWNjX1QyO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbV9zaW5nbGVCeXRlX2FjY19UMigpIHtcclxuICAvLyBUaGUgcmVhZC1tb2RpZnktd3JpdGUgb3BGbidzIHRha2UgYSBwYXJhbWV0ZXIgYW5kIHJldHVybiBhIHZhbHVlXHJcbiAgc3RhdGUuYSA9IHN0YXRlLm9wRm4oc3RhdGUuYSk7XHJcbiAgc3RhdGUuYW1UaWNrID0gbnVsbDtcclxufVxyXG5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gSW50ZXJuYWwgZXhlY3V0aW9uIG9uIG1lbW9yeSBkYXRhOiBpbW1lZGlhdGUgYWRkcmVzc2luZ1xyXG4vLyAo4oCgMzogQS4gMi4xKVxyXG5cclxuZnVuY3Rpb24gYW1faWVvbWRfaW1tX1QxKCkge1xyXG4gIHN0YXRlLnBjICAgICA9ICsrc3RhdGUucGMgJiAweGZmZmY7XHJcbiAgc3RhdGUuZmRUaWNrID0gZmRfZmV0Y2hfVDA7XHJcbiAgc3RhdGUuYW1UaWNrID0gYW1faWVvbWRfaW1tX1QyO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbV9pZW9tZF9pbW1fVDIoKSB7XHJcbiAgc3RhdGUub3BGbigpO1xyXG4gIHN0YXRlLmFtVGljayA9IG51bGw7XHJcbn1cclxuXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIEludGVybmFsIGV4ZWN1dGlvbiBvbiBtZW1vcnkgZGF0YTogemVybyBwYWdlIGFkZHJlc3NpbmdcclxuLy8gKOKAoDM6IEEuIDIuMilcclxuXHJcbmZ1bmN0aW9uIGFtX2llb21kX3pwX1QxKCkge1xyXG4gIHN0YXRlLnBjICAgICA9ICsrc3RhdGUucGMgJiAweGZmZmY7XHJcbiAgc3RhdGUuYW1UaWNrID0gYW1faWVvbWRfenBfVDI7XHJcbiAgc3RhdGUuZmRUaWNrID0gbnVsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gYW1faWVvbWRfenBfVDIoKSB7XHJcbiAgLy8gRGVjb2RlIHBoYXNlIGxlZnQgdGhlIG9wZXJhbmQgKHplcm8gcGFnZSBhZGRyZXNzKSBpbiBzdGF0ZS50bXAuXHJcbiAgLy8gb3BGbiBleHBlY3RzIGl0cyBvcGVyYW5kIHRvIGJlIGluIHN0YXRlLnRtcC5cclxuICBzdGF0ZS50bXAgICAgPSBjcHVSZWFkKHN0YXRlLnRtcCk7XHJcbiAgc3RhdGUuYW1UaWNrID0gYW1faWVvbWRfenBfVDM7XHJcbiAgc3RhdGUuZmRUaWNrID0gZmRfZmV0Y2hfVDA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX2llb21kX3pwX1QzKCkge1xyXG4gIHN0YXRlLm9wRm4oKTtcclxuICBzdGF0ZS5hbVRpY2sgPSBudWxsO1xyXG59XHJcblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBJbnRlcm5hbCBleGVjdXRpb24gb24gbWVtb3J5IGRhdGE6IGFic29sdXRlIGFkZHJlc3NpbmdcclxuLy8gKOKAoDM6IEEuIDIuMylcclxuXHJcbmZ1bmN0aW9uIGFtX2llb21kX2Fic19UMSgpIHtcclxuICBzdGF0ZS5wYyAgICAgPSArK3N0YXRlLnBjICYgMHhmZmZmO1xyXG4gIHN0YXRlLmFtVGljayA9IGFtX2llb21kX2Fic19UMjtcclxuICBzdGF0ZS5mZFRpY2sgPSBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbV9pZW9tZF9hYnNfVDIoKSB7XHJcbiAgLy8gRGVjb2RlIHBoYXNlIGxlZnQgdGhlIG9wZXJhbmQgKEFETCkgaW4gc3RhdGUudG1wLlxyXG4gIC8vIG9wRm4gZXhwZWN0cyBpdHMgb3BlcmFuZCB0byBiZSBpbiBzdGF0ZS50bXAuXHJcbiAgc3RhdGUuYWRsICAgID0gc3RhdGUudG1wO1xyXG4gIHN0YXRlLmFkaCAgICA9IGNwdVJlYWQoc3RhdGUucGMpO1xyXG4gIHN0YXRlLnBjICAgICA9ICsrc3RhdGUucGMgJiAweGZmZmY7XHJcbiAgc3RhdGUuYW1UaWNrID0gYW1faWVvbWRfYWJzX1QzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbV9pZW9tZF9hYnNfVDMoKSB7XHJcbiAgc3RhdGUudG1wICAgID0gY3B1UmVhZCgoc3RhdGUuYWRoIDw8IDgpIHwgc3RhdGUuYWRsKTtcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9pZW9tZF9hYnNfVDQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX2llb21kX2Fic19UNCgpIHtcclxuICBzdGF0ZS5vcEZuKCk7XHJcbiAgc3RhdGUuYW1UaWNrID0gbnVsbDtcclxuICBzdGF0ZS5mZFRpY2sgPSBmZF9mZXRjaF9UMDtcclxufVxyXG5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gSW50ZXJuYWwgZXhlY3V0aW9uIG9uIG1lbW9yeSBkYXRhOiBpbmRpcmVjdCxYIGFkZHJlc3NpbmdcclxuLy8gKOKAoDM6IEEuIDIuNClcclxuXHJcbmZ1bmN0aW9uIGFtX2llb21kX2lueF9UMSgpIHtcclxuICBzdGF0ZS5wYyAgICAgPSArK3N0YXRlLnBjICYgMHhmZmZmO1xyXG4gIHN0YXRlLmFtVGljayA9IGFtX2llb21kX2lueF9UMjtcclxuICBzdGF0ZS5mZFRpY2sgPSBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbV9pZW9tZF9pbnhfVDIoKSB7XHJcbiAgLy8gRGVjb2RlIHBoYXNlIGxlZnQgdGhlIG9wZXJhbmQgKHplcm8gcGFnZSBhZGRyZXNzKSBpbiBzdGF0ZS50bXAuXHJcbiAgLy8gb3BGbiBleHBlY3RzIGl0cyBvcGVyYW5kIHRvIGJlIGluIHN0YXRlLnRtcC5cclxuICBjcHVSZWFkKHN0YXRlLnRtcCk7XHJcbiAgc3RhdGUudG1wICAgID0gKHN0YXRlLnRtcCArIHN0YXRlLngpICYgMHhmZjtcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9pZW9tZF9pbnhfVDM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX2llb21kX2lueF9UMygpIHtcclxuICBzdGF0ZS5hZGwgICAgPSBjcHVSZWFkKHN0YXRlLnRtcCk7XHJcbiAgc3RhdGUudG1wICAgID0gKytzdGF0ZS50bXAgJiAweGZmO1xyXG4gIHN0YXRlLmFtVGljayA9IGFtX2llb21kX2lueF9UNDtcclxufVxyXG5cclxuZnVuY3Rpb24gYW1faWVvbWRfaW54X1Q0KCkge1xyXG4gIHN0YXRlLmFkaCAgICA9IGNwdVJlYWQoc3RhdGUudG1wKTtcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9pZW9tZF9pbnhfVDU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX2llb21kX2lueF9UNSgpIHtcclxuICBzdGF0ZS50bXAgICAgPSBjcHVSZWFkKChzdGF0ZS5hZGggPDwgOCkgfCBzdGF0ZS5hZGwpO1xyXG4gIHN0YXRlLmFtVGljayA9IGFtX2llb21kX2lueF9UNjtcclxuICBzdGF0ZS5mZFRpY2sgPSBmZF9mZXRjaF9UMDtcclxufVxyXG5cclxuZnVuY3Rpb24gYW1faWVvbWRfaW54X1Q2KCkge1xyXG4gIHN0YXRlLm9wRm4oKTtcclxuICBzdGF0ZS5hbVRpY2sgPSBudWxsO1xyXG59XHJcblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBJbnRlcm5hbCBleGVjdXRpb24gb24gbWVtb3J5IGRhdGE6IGFic29sdXRlLFggLyBhYnNvbHV0ZSxZIGFkZHJlc3NpbmdcclxuLy8gKOKAoDM6IEEuIDIuNSlcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIEFic29sdXRlLFggb25seVxyXG5cclxuZnVuY3Rpb24gYW1faWVvbWRfYWJ4X1QxKCkge1xyXG4gIHN0YXRlLnBjICAgICA9ICsrc3RhdGUucGMgJiAweGZmZmY7XHJcbiAgc3RhdGUuYW1UaWNrID0gYW1faWVvbWRfYWJ4X1QyO1xyXG4gIHN0YXRlLmZkVGljayA9IG51bGw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX2llb21kX2FieF9UMigpIHtcclxuICAvLyBEZWNvZGUgcGhhc2UgbGVmdCB0aGUgYmFzZSBhZGRyZXNzIGxvdyBieXRlIGluIHN0YXRlLnRtcC5cclxuICAvLyBvcEZuIGV4cGVjdHMgaXRzIG9wZXJhbmQgdG8gYmUgaW4gc3RhdGUudG1wLlxyXG4gIHN0YXRlLmFkaCAgICA9IGNwdVJlYWQoc3RhdGUucGMpO1xyXG4gIHN0YXRlLnBjICAgICA9ICsrc3RhdGUucGMgJiAweGZmZmY7XHJcbiAgc3RhdGUuYWRsICAgID0gKHN0YXRlLnRtcCArIHN0YXRlLngpOyAgLy8gOSBiaXRzIGhlcmVhZnRlclxyXG4gIHN0YXRlLmFtVGljayA9IGFtX2llb21kX2FieHlfVDM7ICAgICAgIC8vIGZsb3cgaW50byBjb21tb24gY29kZVxyXG59XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBBYnNvbHV0ZSxZIG9ubHlcclxuXHJcbmZ1bmN0aW9uIGFtX2llb21kX2FieV9UMSgpIHtcclxuICBzdGF0ZS5wYyAgICAgPSArK3N0YXRlLnBjICYgMHhmZmZmO1xyXG4gIHN0YXRlLmFtVGljayA9IGFtX2llb21kX2FieV9UMjtcclxuICBzdGF0ZS5mZFRpY2sgPSBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbV9pZW9tZF9hYnlfVDIoKSB7XHJcbiAgLy8gRGVjb2RlIHBoYXNlIGxlZnQgdGhlIGJhc2UgYWRkcmVzcyBsb3cgYnl0ZSBpbiBzdGF0ZS50bXAuXHJcbiAgLy8gb3BGbiBleHBlY3RzIGl0cyBvcGVyYW5kIHRvIGJlIGluIHN0YXRlLnRtcC5cclxuICBzdGF0ZS5hZGggICAgPSBjcHVSZWFkKHN0YXRlLnBjKTtcclxuICBzdGF0ZS5wYyAgICAgPSArK3N0YXRlLnBjICYgMHhmZmZmO1xyXG4gIHN0YXRlLmFkbCAgICA9IChzdGF0ZS50bXAgKyBzdGF0ZS55KTsgIC8vIHRoZSBvbmUgZGlmZmVyZW5jZSBmcm9tIGFtX2llb21kX2FieF9UMlxyXG4gIHN0YXRlLmFtVGljayA9IGFtX2llb21kX2FieHlfVDM7ICAgICAgIC8vIGZsb3cgaW50byBjb21tb24gY29kZVxyXG59XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBDb21tb24gY3ljbGVzIGZvciBib3RoIGFic29sdXRlLFggYW5kIGFic29sdXRlLFlcclxuXHJcbmZ1bmN0aW9uIGFtX2llb21kX2FieHlfVDMoKSB7XHJcbiAgLy8gUmVhZCBmcm9tIHRoZSBwb3RlbnRpYWxseSBicm9rZW4gYWRkcmVzc1xyXG4gIHN0YXRlLnRtcCA9IGNwdVJlYWQoKHN0YXRlLmFkaCA8PCA4KSB8IChzdGF0ZS5hZGwgJiAweGZmKSk7XHJcblxyXG4gIGlmIChzdGF0ZS5hZGwgPCAweDEwMCkge1xyXG4gICAgLy8gTm8gYWRkcmVzcyBmaXh1cCBuZWVkZWQ7IGFkdmFuY2UgdG8gb3AgYW5kIG5leHQgaW5zdHJ1Y3Rpb25cclxuICAgIHN0YXRlLmZkVGljayA9IGZkX2ZldGNoX1QwO1xyXG4gICAgc3RhdGUuYW1UaWNrID0gYW1faWVvbWRfYWJ4eV9UNTtcclxuICB9XHJcblxyXG4gIGVsc2Uge1xyXG4gICAgLy8gRml4IGFkZHJlc3MgYW5kLCBuZXh0IGN5Y2xlLCByZWZldGNoXHJcbiAgICBzdGF0ZS5hZGggICAgPSArK3N0YXRlLmFkaCAmIDB4ZmY7XHJcbiAgICBzdGF0ZS5hZGwgICAmPSAweGZmO1xyXG4gICAgc3RhdGUuYW1UaWNrID0gYW1faWVvbWRfYWJ4eV9UNDtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX2llb21kX2FieHlfVDQoKSB7XHJcbiAgc3RhdGUudG1wICAgID0gY3B1UmVhZCgoc3RhdGUuYWRoIDw8IDgpIHwgc3RhdGUuYWRsKTtcclxuICBzdGF0ZS5mZFRpY2sgPSBmZF9mZXRjaF9UMDtcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9pZW9tZF9hYnh5X1Q1O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbV9pZW9tZF9hYnh5X1Q1KCkge1xyXG4gIHN0YXRlLm9wRm4oKTtcclxuICBzdGF0ZS5hbVRpY2sgPSBudWxsO1xyXG59XHJcblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBJbnRlcm5hbCBleGVjdXRpb24gb24gbWVtb3J5IGRhdGE6IHplcm8gcGFnZSxYIC8gemVybyBwYWdlLFkgYWRkcmVzc2luZ1xyXG4vLyAo4oCgMzogQS4gMi42KVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gWmVybyBwYWdlLFggb25seVxyXG5cclxuZnVuY3Rpb24gYW1faWVvbWRfenB4X1QxKCkge1xyXG4gIHN0YXRlLnBjICAgICA9ICsrc3RhdGUucGMgJiAweGZmZmY7XHJcbiAgc3RhdGUuYW1UaWNrID0gYW1faWVvbWRfenB4X1QyO1xyXG4gIHN0YXRlLmZkVGljayA9IG51bGw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX2llb21kX3pweF9UMigpIHtcclxuICAvLyBEZWNvZGUgcGhhc2UgbGVmdCB0aGUgb3BlcmFuZCAoemVybyBwYWdlIGFkZHJlc3MpIGluIHN0YXRlLnRtcC5cclxuICAvLyBvcEZuIGV4cGVjdHMgaXRzIG9wZXJhbmQgdG8gYmUgaW4gc3RhdGUudG1wLlxyXG4gIGNwdVJlYWQoc3RhdGUudG1wKTtcclxuICBzdGF0ZS5hZGwgICAgPSAoc3RhdGUudG1wICsgc3RhdGUueCkgJiAweGZmO1xyXG4gIHN0YXRlLmFtVGljayA9IGFtX2llb21kX3pweHlfVDM7XHJcbn1cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIFplcm8gcGFnZSxZIG9ubHlcclxuXHJcbmZ1bmN0aW9uIGFtX2llb21kX3pweV9UMSgpIHtcclxuICBzdGF0ZS5wYyAgICAgPSArK3N0YXRlLnBjICYgMHhmZmZmO1xyXG4gIHN0YXRlLmFtVGljayA9IGFtX2llb21kX3pweV9UMjtcclxuICBzdGF0ZS5mZFRpY2sgPSBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbV9pZW9tZF96cHlfVDIoKSB7XHJcbiAgLy8gRGVjb2RlIHBoYXNlIGxlZnQgdGhlIG9wZXJhbmQgKHplcm8gcGFnZSBhZGRyZXNzKSBpbiBzdGF0ZS50bXAuXHJcbiAgLy8gb3BGbiBleHBlY3RzIGl0cyBvcGVyYW5kIHRvIGJlIGluIHN0YXRlLnRtcC5cclxuICBjcHVSZWFkKHN0YXRlLnRtcCk7XHJcbiAgc3RhdGUuYWRsICAgID0gKHN0YXRlLnRtcCArIHN0YXRlLnkpICYgMHhmZjtcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9pZW9tZF96cHh5X1QzO1xyXG59XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBDb21tb24gY3ljbGVzIGZvciBib3RoIHplcm8gcGFnZSxYIGFuZCB6ZXJvIHBhZ2UsWVxyXG5cclxuZnVuY3Rpb24gYW1faWVvbWRfenB4eV9UMygpIHtcclxuICBzdGF0ZS50bXAgICAgPSBjcHVSZWFkKHN0YXRlLmFkbCk7XHJcbiAgc3RhdGUuZmRUaWNrID0gZmRfZmV0Y2hfVDA7XHJcbiAgc3RhdGUuYW1UaWNrID0gYW1faWVvbWRfenB4eV9UNDtcclxufVxyXG5cclxuZnVuY3Rpb24gYW1faWVvbWRfenB4eV9UNCgpIHtcclxuICBzdGF0ZS5vcEZuKCk7XHJcbiAgc3RhdGUuYW1UaWNrID0gbnVsbDtcclxufVxyXG5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gSW50ZXJuYWwgZXhlY3V0aW9uIG9uIG1lbW9yeSBkYXRhOiBpbmRpcmVjdCxZIGFkZHJlc3NpbmdcclxuLy8gKOKAoDM6IEEuIDIuNylcclxuXHJcbmZ1bmN0aW9uIGFtX2llb21kX2lueV9UMSgpIHtcclxuICBzdGF0ZS5wYyAgICAgPSArK3N0YXRlLnBjICYgMHhmZmZmO1xyXG4gIHN0YXRlLmFtVGljayA9IGFtX2llb21kX2lueV9UMjtcclxuICBzdGF0ZS5mZFRpY2sgPSBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbV9pZW9tZF9pbnlfVDIoKSB7XHJcbiAgLy8gRGVjb2RlIHBoYXNlIGxlZnQgdGhlIG9wZXJhbmQgKHplcm8gcGFnZSBhZGRyZXNzKSBpbiBzdGF0ZS50bXAuXHJcbiAgLy8gb3BGbiBleHBlY3RzIGl0cyBvcGVyYW5kIHRvIGJlIGluIHN0YXRlLnRtcC5cclxuICBzdGF0ZS5hZGwgICAgPSBjcHVSZWFkKHN0YXRlLnRtcCk7XHJcbiAgc3RhdGUudG1wICAgID0gKytzdGF0ZS50bXAgJiAweGZmO1xyXG4gIHN0YXRlLmFtVGljayA9IGFtX2llb21kX2lueV9UMztcclxufVxyXG5cclxuZnVuY3Rpb24gYW1faWVvbWRfaW55X1QzKCkge1xyXG4gIHN0YXRlLmFkaCAgICA9IGNwdVJlYWQoc3RhdGUudG1wKTtcclxuICBzdGF0ZS5hZGwgICAgPSBzdGF0ZS5hZGwgKyBzdGF0ZS55OyAgLy8gOSBiaXRzIGhlcmVhZnRlclxyXG4gIHN0YXRlLmFtVGljayA9IGFtX2llb21kX2lueV9UNDtcclxufVxyXG5cclxuZnVuY3Rpb24gYW1faWVvbWRfaW55X1Q0KCkge1xyXG4gIHN0YXRlLnRtcCA9IGNwdVJlYWQoKHN0YXRlLmFkaCA8PCA4KSB8IChzdGF0ZS5hZGwgJiAweGZmKSk7XHJcblxyXG4gIGlmIChzdGF0ZS5hZGwgPiAweGZmKSB7XHJcbiAgICAvLyBBZGRyZXNzIG5lZWRzIGZpeGluZ1xyXG4gICAgc3RhdGUuYWRoICAgID0gKytzdGF0ZS5hZGggJiAweGZmO1xyXG4gICAgc3RhdGUuYWRsICAgID0gc3RhdGUuYWRsICYgMHhmZjsgICAvLyA4IGJpdHMgaGVyZWFmdGVyXHJcbiAgICBzdGF0ZS5hbVRpY2sgPSBhbV9pZW9tZF9pbnlfVDU7XHJcbiAgfVxyXG4gIGVsc2Uge1xyXG4gICAgLy8gQWRkcmVzcyBkaWRuJ3QgbmVlZCBmaXhpbmcuIFNraXAgdG8gbGFzdCBzdGFnZSBhbmQgZmV0Y2ggbmV4dCBpbnN0cnVjdGlvbi5cclxuICAgIHN0YXRlLmFtVGljayA9IGFtX2llb21kX2lueV9UNjtcclxuICAgIHN0YXRlLmZkVGljayA9IGZkX2ZldGNoX1QwO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gYW1faWVvbWRfaW55X1Q1KCkge1xyXG4gIHN0YXRlLnRtcCAgICA9IGNwdVJlYWQoKHN0YXRlLmFkaCA8PCA4KSB8IHN0YXRlLmFkbCk7XHJcbiAgc3RhdGUuYW1UaWNrID0gYW1faWVvbWRfaW55X1Q2O1xyXG4gIHN0YXRlLmZkVGljayA9IGZkX2ZldGNoX1QwO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbV9pZW9tZF9pbnlfVDYoKSB7XHJcbiAgc3RhdGUub3BGbigpO1xyXG4gIHN0YXRlLmFtVGljayA9IG51bGw7XHJcbn1cclxuXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIFN0b3JlIG9wZXJhdGlvbnM6IHplcm8gcGFnZSBhZGRyZXNzaW5nXHJcbi8vICjigKAzOiBBLiAzLjEpXHJcblxyXG5mdW5jdGlvbiBhbV9zdG9yZV96cF9UMSgpIHtcclxuICBzdGF0ZS5wYyAgICAgPSArK3N0YXRlLnBjICYgMHhmZmZmO1xyXG4gIHN0YXRlLmFtVGljayA9IGFtX3N0b3JlX3pwX1QyO1xyXG4gIHN0YXRlLmZkVGljayA9IG51bGw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX3N0b3JlX3pwX1QyKCkge1xyXG4gIC8vIERlY29kZSBwaGFzZSBsZWZ0IHRoZSBvcGVyYW5kICh6ZXJvIHBhZ2UgYWRkcmVzcykgaW4gc3RhdGUudG1wLlxyXG4gIGNvbnN0IGFkbCA9IHN0YXRlLnRtcDtcclxuXHJcbiAgY3B1V3JpdGUoYWRsLCBzdGF0ZS5vcEZuKCkpO1xyXG5cclxuICBzdGF0ZS5hbVRpY2sgPSBudWxsO1xyXG4gIHN0YXRlLmZkVGljayA9IGZkX2ZldGNoX1QwO1xyXG59XHJcblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBTdG9yZSBvcGVyYXRpb25zOiBhYnNvbHV0ZSBhZGRyZXNzaW5nXHJcbi8vICjigKAzOiBBLiAzLjIpXHJcblxyXG5mdW5jdGlvbiBhbV9zdG9yZV9hYnNfVDEoKSB7XHJcbiAgc3RhdGUucGMgICAgID0gKytzdGF0ZS5wYyAmIDB4ZmZmZjtcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9zdG9yZV9hYnNfVDI7XHJcbiAgc3RhdGUuZmRUaWNrID0gbnVsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gYW1fc3RvcmVfYWJzX1QyKCkge1xyXG4gIC8vIERlY29kZSBwaGFzZSBsZWZ0IHRoZSBhZGRyZXNzIGxvdy1ieXRlIGluIHN0YXRlLnRtcC5cclxuICBzdGF0ZS5hZGwgPSBzdGF0ZS50bXA7XHJcbiAgc3RhdGUuYWRoID0gY3B1UmVhZChzdGF0ZS5wYyk7XHJcbiAgc3RhdGUucGMgID0gKytzdGF0ZS5wYyAmIDB4ZmZmZjtcclxuXHJcbiAgc3RhdGUuYW1UaWNrID0gYW1fc3RvcmVfYWJzX1QzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbV9zdG9yZV9hYnNfVDMoKSB7XHJcbiAgY3B1V3JpdGUoKHN0YXRlLmFkaCA8PCA4KSB8IHN0YXRlLmFkbCwgc3RhdGUub3BGbigpKTtcclxuXHJcbiAgc3RhdGUuYW1UaWNrID0gbnVsbDtcclxuICBzdGF0ZS5mZFRpY2sgPSBmZF9mZXRjaF9UMDtcclxufVxyXG5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gU3RvcmUgb3BlcmF0aW9uczogaW5kaXJlY3QsWCBhZGRyZXNzaW5nXHJcbi8vICjigKAzOiBBLiAzLjMpXHJcblxyXG5mdW5jdGlvbiBhbV9zdG9yZV9pbnhfVDEoKSB7XHJcbiAgc3RhdGUucGMgICAgID0gKytzdGF0ZS5wYyAmIDB4ZmZmZjtcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9zdG9yZV9pbnhfVDI7XHJcbiAgc3RhdGUuZmRUaWNrID0gbnVsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gYW1fc3RvcmVfaW54X1QyKCkge1xyXG4gIC8vIERlY29kZSBwaGFzZSBsZWZ0IHRoZSB6ZXJvIHBhZ2UgYWRkcmVzcyBpbiBzdGF0ZS50bXAuXHJcbiAgY3B1UmVhZChzdGF0ZS50bXApO1xyXG4gIFxyXG4gIHN0YXRlLnRtcCAgICA9IChzdGF0ZS50bXAgKyBzdGF0ZS54KSAmIDB4ZmY7XHJcbiAgc3RhdGUuYW1UaWNrID0gYW1fc3RvcmVfaW54X1QzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbV9zdG9yZV9pbnhfVDMoKSB7XHJcbiAgc3RhdGUuYWRsICAgID0gY3B1UmVhZChzdGF0ZS50bXApO1xyXG4gIHN0YXRlLnRtcCAgICA9ICsrc3RhdGUudG1wICYgMHhmZjtcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9zdG9yZV9pbnhfVDQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX3N0b3JlX2lueF9UNCgpIHtcclxuICBzdGF0ZS5hZGggICAgPSBjcHVSZWFkKHN0YXRlLnRtcCk7XHJcbiAgc3RhdGUuYW1UaWNrID0gYW1fc3RvcmVfaW54X1Q1O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbV9zdG9yZV9pbnhfVDUoKSB7XHJcbiAgY3B1V3JpdGUoKHN0YXRlLmFkaCA8PCA4KSB8IHN0YXRlLmFkbCwgc3RhdGUub3BGbigpKTtcclxuXHJcbiAgc3RhdGUuYW1UaWNrID0gbnVsbDtcclxuICBzdGF0ZS5mZFRpY2sgPSBmZF9mZXRjaF9UMDtcclxufVxyXG5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gU3RvcmUgb3BlcmF0aW9uczogYWJzb2x1dGUsWCAvIGFic29sdXRlLFkgYWRkcmVzc2luZ1xyXG4vLyAo4oCgMzogQS4gMy40KVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gQWJzb2x1dGUsWCBvbmx5XHJcblxyXG5mdW5jdGlvbiBhbV9zdG9yZV9hYnhfVDEoKSB7XHJcbiAgc3RhdGUucGMgICAgID0gKytzdGF0ZS5wYyAmIDB4ZmZmZjtcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9zdG9yZV9hYnhfVDI7XHJcbiAgc3RhdGUuZmRUaWNrID0gbnVsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gYW1fc3RvcmVfYWJ4X1QyKCkge1xyXG4gIC8vIERlY29kZSBwaGFzZSBsZWZ0IHRoZSBiYXNlIGFkZHJlc3MgbG93IGJ5dGUgaW4gc3RhdGUudG1wLlxyXG4gIHN0YXRlLmFkaCAgICA9IGNwdVJlYWQoc3RhdGUucGMpO1xyXG4gIHN0YXRlLnBjICAgICA9ICsrc3RhdGUucGMgJiAweGZmZmY7XHJcbiAgc3RhdGUuYWRsICAgID0gKHN0YXRlLnRtcCArIHN0YXRlLngpOyAgLy8gOSBiaXRzIGhlcmVhZnRlclxyXG4gIHN0YXRlLmFtVGljayA9IGFtX3N0b3JlX2FieHlfVDM7ICAgICAvLyBmbG93IGludG8gY29tbW9uIGNvZGVcclxufVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gQWJzb2x1dGUsWSBvbmx5XHJcblxyXG5mdW5jdGlvbiBhbV9zdG9yZV9hYnlfVDEoKSB7XHJcbiAgc3RhdGUucGMgICAgID0gKytzdGF0ZS5wYyAmIDB4ZmZmZjtcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9zdG9yZV9hYnlfVDI7XHJcbiAgc3RhdGUuZmRUaWNrID0gbnVsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gYW1fc3RvcmVfYWJ5X1QyKCkge1xyXG4gIC8vIERlY29kZSBwaGFzZSBsZWZ0IHRoZSBiYXNlIGFkZHJlc3MgbG93IGJ5dGUgaW4gc3RhdGUudG1wLlxyXG4gIC8vIG9wRm4gZXhwZWN0cyBpdHMgb3BlcmFuZCB0byBiZSBpbiBzdGF0ZS50bXAuXHJcbiAgc3RhdGUuYWRoICAgID0gY3B1UmVhZChzdGF0ZS5wYyk7XHJcbiAgc3RhdGUucGMgICAgID0gKytzdGF0ZS5wYyAmIDB4ZmZmZjtcclxuICBzdGF0ZS5hZGwgICAgPSAoc3RhdGUudG1wICsgc3RhdGUueSk7ICAvLyB0aGUgb25lIGRpZmZlcmVuY2UgZnJvbSBhbV9zdG9yZV9hYnhfVDJcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9zdG9yZV9hYnh5X1QzOyAgICAgICAvLyBmbG93IGludG8gY29tbW9uIGNvZGVcclxufVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gQ29tbW9uIGN5Y2xlcyBmb3IgYm90aCBhYnNvbHV0ZSxYIGFuZCBhYnNvbHV0ZSxZXHJcblxyXG5mdW5jdGlvbiBhbV9zdG9yZV9hYnh5X1QzKCkge1xyXG4gIC8vIER1bW15IHJlYWQgZnJvbSB0aGUgcG90ZW50aWFsbHkgYnJva2VuIGFkZHJlc3NcclxuICBzdGF0ZS50bXAgPSBjcHVSZWFkKChzdGF0ZS5hZGggPDwgOCkgfCAoc3RhdGUuYWRsICYgMHhmZikpO1xyXG5cclxuICBpZiAoc3RhdGUuYWRsID4gMHhmZikge1xyXG4gICAgLy8gRml4IHVwIGFkZHJlc3NcclxuICAgIHN0YXRlLmFkaCAgICA9ICsrc3RhdGUuYWRoICYgMHhmZjtcclxuICAgIHN0YXRlLmFkbCAgICY9IDB4ZmY7XHJcbiAgfVxyXG5cclxuICAvLyBzdGF0ZS5hZGwgaXMgOCBiaXRzIGhlcmVhZnRlclxyXG4gIHN0YXRlLmFtVGljayA9IGFtX3N0b3JlX2FieHlfVDQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX3N0b3JlX2FieHlfVDQoKSB7XHJcbiAgY3B1V3JpdGUoKHN0YXRlLmFkaCA8PCA4KSB8IHN0YXRlLmFkbCwgc3RhdGUub3BGbigpKTtcclxuICBzdGF0ZS5mZFRpY2sgPSBmZF9mZXRjaF9UMDtcclxuICBzdGF0ZS5hbVRpY2sgPSBudWxsO1xyXG59XHJcblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBTdG9yZSBvcGVyYXRpb25zOiB6ZXJvIHBhZ2UsWCAvIHplcm8gcGFnZSxZIGFkZHJlc3NpbmdcclxuLy8gKOKAoDM6IEEuIDMuNSlcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIFplcm8gcGFnZSxYIG9ubHlcclxuXHJcbmZ1bmN0aW9uIGFtX3N0b3JlX3pweF9UMSgpIHtcclxuICBzdGF0ZS5wYyAgICAgPSArK3N0YXRlLnBjICYgMHhmZmZmO1xyXG4gIHN0YXRlLmFtVGljayA9IGFtX3N0b3JlX3pweF9UMjtcclxuICBzdGF0ZS5mZFRpY2sgPSBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbV9zdG9yZV96cHhfVDIoKSB7XHJcbiAgLy8gRGVjb2RlIHBoYXNlIGxlZnQgdGhlIG9wZXJhbmQgKHplcm8gcGFnZSBhZGRyZXNzKSBpbiBzdGF0ZS50bXAuXHJcbiAgY3B1UmVhZChzdGF0ZS50bXApO1xyXG4gIHN0YXRlLmFkbCAgICA9IChzdGF0ZS50bXAgKyBzdGF0ZS54KSAmIDB4ZmY7XHJcbiAgc3RhdGUuYW1UaWNrID0gYW1fc3RvcmVfenB4eV9UMztcclxufVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gWmVybyBwYWdlLFkgb25seVxyXG5cclxuZnVuY3Rpb24gYW1fc3RvcmVfenB5X1QxKCkge1xyXG4gIHN0YXRlLnBjICAgICA9ICsrc3RhdGUucGMgJiAweGZmZmY7XHJcbiAgc3RhdGUuYW1UaWNrID0gYW1fc3RvcmVfenB5X1QyO1xyXG4gIHN0YXRlLmZkVGljayA9IG51bGw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX3N0b3JlX3pweV9UMigpIHtcclxuICAvLyBEZWNvZGUgcGhhc2UgbGVmdCB0aGUgb3BlcmFuZCAoemVybyBwYWdlIGFkZHJlc3MpIGluIHN0YXRlLnRtcC5cclxuICBjcHVSZWFkKHN0YXRlLnRtcCk7XHJcbiAgc3RhdGUuYWRsICAgID0gKHN0YXRlLnRtcCArIHN0YXRlLnkpICYgMHhmZjtcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9zdG9yZV96cHh5X1QzO1xyXG59XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBDb21tb24gY3ljbGVzIGZvciBib3RoIHplcm8gcGFnZSxYIGFuZCB6ZXJvIHBhZ2UsWVxyXG5cclxuZnVuY3Rpb24gYW1fc3RvcmVfenB4eV9UMygpIHtcclxuICBjcHVXcml0ZShzdGF0ZS5hZGwsIHN0YXRlLm9wRm4oKSk7XHJcblxyXG4gIHN0YXRlLmZkVGljayA9IGZkX2ZldGNoX1QwO1xyXG4gIHN0YXRlLmFtVGljayA9IG51bGw7XHJcbn1cclxuXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIFN0b3JlIG9wZXJhdGlvbnM6IGluZGlyZWN0LFkgYWRkcmVzc2luZ1xyXG4vLyAo4oCgMzogQS4gMy42KVxyXG5cclxuZnVuY3Rpb24gYW1fc3RvcmVfaW55X1QxKCkge1xyXG4gIHN0YXRlLnBjICAgICA9ICsrc3RhdGUucGMgJiAweGZmZmY7XHJcbiAgc3RhdGUuYW1UaWNrID0gYW1fc3RvcmVfaW55X1QyO1xyXG4gIHN0YXRlLmZkVGljayA9IG51bGw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX3N0b3JlX2lueV9UMigpIHtcclxuICAvLyBEZWNvZGUgcGhhc2UgbGVmdCB0aGUgb3BlcmFuZCAoemVybyBwYWdlIGFkZHJlc3MpIGluIHN0YXRlLnRtcC5cclxuICBzdGF0ZS5hZGwgICAgPSBjcHVSZWFkKHN0YXRlLnRtcCk7XHJcbiAgc3RhdGUudG1wICAgID0gKytzdGF0ZS50bXAgJiAweGZmO1xyXG4gIHN0YXRlLmFtVGljayA9IGFtX3N0b3JlX2lueV9UMztcclxufVxyXG5cclxuZnVuY3Rpb24gYW1fc3RvcmVfaW55X1QzKCkge1xyXG4gIHN0YXRlLmFkaCAgICA9IGNwdVJlYWQoc3RhdGUudG1wKTtcclxuICBzdGF0ZS5hZGwgICAgPSBzdGF0ZS5hZGwgKyBzdGF0ZS55OyAgLy8gOSBiaXRzIGhlcmVhZnRlclxyXG4gIHN0YXRlLmFtVGljayA9IGFtX3N0b3JlX2lueV9UNDtcclxufVxyXG5cclxuZnVuY3Rpb24gYW1fc3RvcmVfaW55X1Q0KCkge1xyXG4gIHN0YXRlLnRtcCAgICA9IGNwdVJlYWQoKHN0YXRlLmFkaCA8PCA4KSB8IChzdGF0ZS5hZGwgJiAweGZmKSk7XHJcblxyXG4gIGlmIChzdGF0ZS5hZGwgPiAweGZmKSB7XHJcbiAgICAvLyBBZGRyZXNzIG5lZWRzIGZpeGluZ1xyXG4gICAgc3RhdGUuYWRoICAgID0gKytzdGF0ZS5hZGggJiAweGZmO1xyXG4gICAgc3RhdGUuYWRsICAgID0gc3RhdGUuYWRsICYgMHhmZjtcclxuICB9XHJcblxyXG4gIC8vIHN0YXRlLmFkbCBpcyA4IGJpdHMgaGVyZWFmdGVyXHJcbiAgc3RhdGUuYW1UaWNrID0gYW1fc3RvcmVfaW55X1Q1O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbV9zdG9yZV9pbnlfVDUoKSB7XHJcbiAgY3B1V3JpdGUoKHN0YXRlLmFkaCA8PCA4KSB8IHN0YXRlLmFkbCwgc3RhdGUub3BGbigpKTtcclxuICBzdGF0ZS5hbVRpY2sgPSBudWxsO1xyXG4gIHN0YXRlLmZkVGljayA9IGZkX2ZldGNoX1QwO1xyXG59XHJcblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBSZWFkLW1vZGlmeS13cml0ZSBvcGVyYXRpb25zOiB6ZXJvIHBhZ2UgYWRkcmVzc2luZ1xyXG4vLyAo4oCgMzogQS4gNC4xKVxyXG5cclxuZnVuY3Rpb24gYW1fcm13X3pwX1QxKCkge1xyXG4gIHN0YXRlLnBjICAgICA9ICsrc3RhdGUucGMgJiAweGZmZmY7XHJcbiAgc3RhdGUuYW1UaWNrID0gYW1fcm13X3pwX1QyO1xyXG4gIHN0YXRlLmZkVGljayA9IG51bGw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX3Jtd196cF9UMigpIHtcclxuICAvLyBEZWNvZGUgcGhhc2UgbGVmdCB0aGUgb3BlcmFuZCAoemVybyBwYWdlIGFkZHJlc3MpIGluIHN0YXRlLnRtcC5cclxuICAvLyBvcEZuIHRha2VzIGFuIGFyZ3VtZW50IGFuZCByZXR1cm5zIGEgdmFsdWUuXHJcbiAgc3RhdGUuYWRsICAgID0gc3RhdGUudG1wO1xyXG4gIHN0YXRlLnRtcCAgICA9IGNwdVJlYWQoc3RhdGUuYWRsKTtcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9ybXdfenBfVDM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX3Jtd196cF9UMygpIHtcclxuICAvLyBEdW1teSB3cml0ZSBvZiB0aGUgZmV0Y2hlZCBkYXRhIGJhY2sgdG8gaXRzZWxmXHJcbiAgY3B1V3JpdGUoc3RhdGUuYWRsLCBzdGF0ZS50bXApO1xyXG5cclxuICBzdGF0ZS50bXAgPSBzdGF0ZS5vcEZuKHN0YXRlLnRtcCk7XHJcbiAgc3RhdGUuYW1UaWNrID0gYW1fcm13X3pwX1Q0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbV9ybXdfenBfVDQoKSB7XHJcbiAgLy8gQWN0dWFsIHdyaXRlIG9mIHRoZSBwcm9jZXNzZWQgZGF0YVxyXG4gIGNwdVdyaXRlKHN0YXRlLmFkbCwgc3RhdGUudG1wKTtcclxuXHJcbiAgc3RhdGUuYW1UaWNrID0gbnVsbDtcclxuICBzdGF0ZS5mZFRpY2sgPSBmZF9mZXRjaF9UMDtcclxufVxyXG5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gUmVhZC1tb2RpZnktd3JpdGUgb3BlcmF0aW9uczogYWJzb2x1dGUgYWRkcmVzc2luZ1xyXG4vLyAo4oCgMzogQS4gNC4yKVxyXG5cclxuZnVuY3Rpb24gYW1fcm13X2Fic19UMSgpIHtcclxuICBzdGF0ZS5wYyAgICAgPSArK3N0YXRlLnBjICYgMHhmZmZmO1xyXG4gIHN0YXRlLmFtVGljayA9IGFtX3Jtd19hYnNfVDI7XHJcbiAgc3RhdGUuZmRUaWNrID0gbnVsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gYW1fcm13X2Fic19UMigpIHtcclxuICAvLyBEZWNvZGUgcGhhc2UgbGVmdCB0aGUgb3BlcmFuZCAoQURMKSBpbiBzdGF0ZS50bXAuXHJcbiAgLy8gb3BGbiB0YWtlcyBhbiBhcmd1bWVudCBhbmQgcmV0dXJucyBhIHZhbHVlLlxyXG4gIHN0YXRlLmFkbCAgICA9IHN0YXRlLnRtcDtcclxuICBzdGF0ZS5hZGggICAgPSBjcHVSZWFkKHN0YXRlLnBjKTtcclxuICBzdGF0ZS5wYyAgICAgPSArK3N0YXRlLnBjICYgMHhmZmZmO1xyXG4gIHN0YXRlLmFtVGljayA9IGFtX3Jtd19hYnNfVDM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX3Jtd19hYnNfVDMoKSB7XHJcbiAgc3RhdGUudG1wICAgID0gY3B1UmVhZCgoc3RhdGUuYWRoIDw8IDgpIHwgc3RhdGUuYWRsKTtcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9ybXdfYWJzX1Q0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbV9ybXdfYWJzX1Q0KCkge1xyXG4gIC8vIER1bW15IHdyaXRlIG9mIHRoZSBmZXRjaGVkIGRhdGEgYmFjayB0byBpdHNlbGZcclxuICBjcHVXcml0ZSgoc3RhdGUuYWRoIDw8IDgpIHwgc3RhdGUuYWRsLCBzdGF0ZS50bXApO1xyXG5cclxuICBzdGF0ZS50bXAgICAgPSBzdGF0ZS5vcEZuKHN0YXRlLnRtcCk7XHJcbiAgc3RhdGUuYW1UaWNrID0gYW1fcm13X2Fic19UNTtcclxufVxyXG5cclxuZnVuY3Rpb24gYW1fcm13X2Fic19UNSgpIHtcclxuICAvLyBBY3R1YWwgd3JpdGUgb2YgdGhlIHByb2Nlc3NlZCBkYXRhXHJcbiAgY3B1V3JpdGUoKHN0YXRlLmFkaCA8PCA4KSB8IHN0YXRlLmFkbCwgc3RhdGUudG1wKTtcclxuXHJcbiAgc3RhdGUuYW1UaWNrID0gbnVsbDtcclxuICBzdGF0ZS5mZFRpY2sgPSBmZF9mZXRjaF9UMDtcclxufVxyXG5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gUmVhZC1tb2RpZnktd3JpdGUgb3BlcmF0aW9uczogemVybyBwYWdlLFggYWRkcmVzc2luZ1xyXG4vLyAo4oCgMzogQS4gNC4zKVxyXG5cclxuZnVuY3Rpb24gYW1fcm13X3pweF9UMSgpIHtcclxuICBzdGF0ZS5wYyAgICAgPSArK3N0YXRlLnBjICYgMHhmZmZmO1xyXG4gIHN0YXRlLmFtVGljayA9IGFtX3Jtd196cHhfVDI7XHJcbiAgc3RhdGUuZmRUaWNrID0gbnVsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gYW1fcm13X3pweF9UMigpIHtcclxuICAvLyBEZWNvZGUgcGhhc2UgbGVmdCB0aGUgb3BlcmFuZCAoemVybyBwYWdlIGFkZHJlc3MpIGluIHN0YXRlLnRtcC5cclxuICAvLyBvcEZuIHRha2VzIGFuIGFyZ3VtZW50IGFuZCByZXR1cm5zIGEgdmFsdWUuXHJcbiAgY3B1UmVhZChzdGF0ZS50bXApO1xyXG4gIHN0YXRlLmFkbCAgICA9IChzdGF0ZS50bXAgKyBzdGF0ZS54KSAmIDB4ZmY7XHJcbiAgc3RhdGUuYW1UaWNrID0gYW1fcm13X3pweF9UMztcclxufVxyXG5cclxuZnVuY3Rpb24gYW1fcm13X3pweF9UMygpIHtcclxuICBzdGF0ZS50bXAgICAgPSBjcHVSZWFkKHN0YXRlLmFkbCk7XHJcbiAgc3RhdGUuYW1UaWNrID0gYW1fcm13X3pweF9UNDtcclxufVxyXG5cclxuZnVuY3Rpb24gYW1fcm13X3pweF9UNCgpIHtcclxuICAvLyBEdW1teSB3cml0ZSBvZiB0aGUgZmV0Y2hlZCBkYXRhIGJhY2sgdG8gaXRzZWxmXHJcbiAgY3B1V3JpdGUoc3RhdGUuYWRsLCBzdGF0ZS50bXApO1xyXG4gIHN0YXRlLnRtcCAgICA9IHN0YXRlLm9wRm4oc3RhdGUudG1wKTtcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9ybXdfenB4X1Q1O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbV9ybXdfenB4X1Q1KCkge1xyXG4gIC8vIEFjdHVhbCB3cml0ZSBvZiB0aGUgcHJvY2Vzc2VkIGRhdGFcclxuICBjcHVXcml0ZShzdGF0ZS5hZGwsIHN0YXRlLnRtcCk7XHJcbiAgc3RhdGUuYW1UaWNrID0gbnVsbDtcclxuICBzdGF0ZS5mZFRpY2sgPSBmZF9mZXRjaF9UMDtcclxufVxyXG5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gUmVhZC1tb2RpZnktd3JpdGUgb3BlcmF0aW9uczogYWJzb2x1dGUsWCAvIGFic29sdXRlLFkgYWRkcmVzc2luZ1xyXG4vLyAo4oCgMzogQS4gNC40KVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gQWJzb2x1dGUsWCBvbmx5XHJcblxyXG5mdW5jdGlvbiBhbV9ybXdfYWJ4X1QxKCkge1xyXG4gIHN0YXRlLnBjICAgICA9ICsrc3RhdGUucGMgJiAweGZmZmY7XHJcbiAgc3RhdGUuYW1UaWNrID0gYW1fcm13X2FieF9UMjtcclxuICBzdGF0ZS5mZFRpY2sgPSBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbV9ybXdfYWJ4X1QyKCkge1xyXG4gIC8vIERlY29kZSBwaGFzZSBsZWZ0IHRoZSBiYXNlIGFkZHJlc3MgbG93IGJ5dGUgaW4gc3RhdGUudG1wLlxyXG4gIC8vIG9wRm4gdGFrZXMgYW4gYXJndW1lbnQgYW5kIHJldHVybnMgYSB2YWx1ZS5cclxuICBzdGF0ZS5hZGggICAgPSBjcHVSZWFkKHN0YXRlLnBjKTtcclxuICBzdGF0ZS5wYyAgICAgPSArK3N0YXRlLnBjICYgMHhmZmZmO1xyXG4gIHN0YXRlLmFkbCAgICA9IChzdGF0ZS50bXAgKyBzdGF0ZS54KTsgIC8vIDkgYml0cyBoZXJlYWZ0ZXJcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9ybXdfYWJ4eV9UMztcclxufVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gQWJzb2x1dGUsWSBvbmx5ICh1c2VkIG9ubHkgYnkgcXVhc2ktb3BzKVxyXG5cclxuZnVuY3Rpb24gYW1fcm13X2FieV9UMSgpIHtcclxuICBzdGF0ZS5wYyAgICAgPSArK3N0YXRlLnBjICYgMHhmZmZmO1xyXG4gIHN0YXRlLmFtVGljayA9IGFtX3Jtd19hYnlfVDI7XHJcbiAgc3RhdGUuZmRUaWNrID0gbnVsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gYW1fcm13X2FieV9UMigpIHtcclxuICAvLyBEZWNvZGUgcGhhc2UgbGVmdCB0aGUgYmFzZSBhZGRyZXNzIGxvdyBieXRlIGluIHN0YXRlLnRtcC5cclxuICAvLyBvcEZuIHRha2VzIGFuIGFyZ3VtZW50IGFuZCByZXR1cm5zIGEgdmFsdWUuXHJcbiAgc3RhdGUuYWRoICAgID0gY3B1UmVhZChzdGF0ZS5wYyk7XHJcbiAgc3RhdGUucGMgICAgID0gKytzdGF0ZS5wYyAmIDB4ZmZmZjtcclxuICBzdGF0ZS5hZGwgICAgPSAoc3RhdGUudG1wICsgc3RhdGUueSk7ICAvLyA5IGJpdHMgaGVyZWFmdGVyXHJcbiAgc3RhdGUuYW1UaWNrID0gYW1fcm13X2FieHlfVDM7XHJcbn1cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIENvbW1vbiBjeWNsZXMgZm9yIGJvdGggYWJzb2x1dGUsWCBhbmQgYWJzb2x1dGUsWVxyXG5cclxuZnVuY3Rpb24gYW1fcm13X2FieHlfVDMoKSB7XHJcbiAgLy8gRHVtbXkgcmVhZCBmcm9tIHRoZSBwb3RlbnRpYWxseSBicm9rZW4gYWRkcmVzc1xyXG4gIHN0YXRlLnRtcCA9IGNwdVJlYWQoKHN0YXRlLmFkaCA8PCA4KSB8IChzdGF0ZS5hZGwgJiAweGZmKSk7XHJcblxyXG4gIGlmIChzdGF0ZS5hZGwgPiAweGZmKSB7XHJcbiAgICAvLyBGaXggYWRkcmVzc1xyXG4gICAgc3RhdGUuYWRoICA9ICsrc3RhdGUuYWRoICYgMHhmZjtcclxuICAgIHN0YXRlLmFkbCAmPSAweGZmO1xyXG4gIH1cclxuXHJcbiAgLy8gc3RhdGUuYWRsIGlzIDggYml0cyBoZXJlYWZ0ZXJcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9ybXdfYWJ4eV9UNDtcclxufVxyXG5cclxuZnVuY3Rpb24gYW1fcm13X2FieHlfVDQoKSB7XHJcbiAgc3RhdGUudG1wICAgID0gY3B1UmVhZCgoc3RhdGUuYWRoIDw8IDgpIHwgc3RhdGUuYWRsKTtcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9ybXdfYWJ4eV9UNTtcclxufVxyXG5cclxuZnVuY3Rpb24gYW1fcm13X2FieHlfVDUoKSB7XHJcbiAgLy8gRHVtbXkgd3JpdGUgb2YgdGhlIGZldGNoZWQgZGF0YSBiYWNrIHRvIGl0c2VsZlxyXG4gIGNwdVdyaXRlKChzdGF0ZS5hZGggPDwgOCkgfCBzdGF0ZS5hZGwsIHN0YXRlLnRtcCk7XHJcblxyXG4gIHN0YXRlLnRtcCAgICA9IHN0YXRlLm9wRm4oc3RhdGUudG1wKTtcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9ybXdfYWJ4eV9UNjtcclxufVxyXG5cclxuZnVuY3Rpb24gYW1fcm13X2FieHlfVDYoKSB7XHJcbiAgLy8gQWN0dWFsIHdyaXRlIG9mIHRoZSBwcm9jZXNzZWQgZGF0YVxyXG4gIGNwdVdyaXRlKChzdGF0ZS5hZGggPDwgOCkgfCBzdGF0ZS5hZGwsIHN0YXRlLnRtcCk7XHJcblxyXG4gIHN0YXRlLmFtVGljayA9IG51bGw7XHJcbiAgc3RhdGUuZmRUaWNrID0gZmRfZmV0Y2hfVDA7XHJcbn1cclxuXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIFJlYWQtbW9kaWZ5LXdyaXRlIG9wZXJhdGlvbnM6IGluZGlyZWN0LFggYWRkcmVzc2luZ1xyXG4vLyAoTm90IHJlZmVyZW5jZWQgaW4g4oCgMywgYXMgb25seSB1c2VkIGJ5IHF1YXNpLW9wcy4gQ3ljbGUgc2VxdWVuY2UgaXMgdGh1c1xyXG4vLyBndWVzc3dvcmssIGluZm9ybWVkIG9ubHkgYnkgdGhlIElFT01EIGluZGlyZWN0LFggc2VxdWVuY2UgKOKAoDM6IEEuIDIuNCkgYW5kXHJcbi8vIGtub3dpbmcgdGhhdCB0aGUgaW5zdHJ1Y3Rpb25zIHRha2UgOCBjeWNsZXMgKOKAoDQpLilcclxuXHJcbmZ1bmN0aW9uIGFtX3Jtd19pbnhfVDEoKSB7XHJcbiAgc3RhdGUucGMgICAgID0gKytzdGF0ZS5wYyAmIDB4ZmZmZjtcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9ybXdfaW54X1QyO1xyXG4gIHN0YXRlLmZkVGljayA9IG51bGw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX3Jtd19pbnhfVDIoKSB7XHJcbiAgLy8gRGVjb2RlIHBoYXNlIGxlZnQgdGhlIG9wZXJhbmQgKHplcm8gcGFnZSBhZGRyZXNzKSBpbiBzdGF0ZS50bXAuXHJcbiAgLy8gb3BGbiBleHBlY3RzIGl0cyBvcGVyYW5kIHRvIGJlIGluIHN0YXRlLnRtcC5cclxuICBjcHVSZWFkKHN0YXRlLnRtcCk7XHJcbiAgc3RhdGUudG1wICAgID0gKHN0YXRlLnRtcCArIHN0YXRlLngpICYgMHhmZjtcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9ybXdfaW54X1QzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbV9ybXdfaW54X1QzKCkge1xyXG4gIHN0YXRlLmFkbCAgICA9IGNwdVJlYWQoc3RhdGUudG1wKTtcclxuICBzdGF0ZS50bXAgICAgPSArK3N0YXRlLnRtcCAmIDB4ZmY7XHJcbiAgc3RhdGUuYW1UaWNrID0gYW1fcm13X2lueF9UNDtcclxufVxyXG5cclxuZnVuY3Rpb24gYW1fcm13X2lueF9UNCgpIHtcclxuICBzdGF0ZS5hZGggICAgPSBjcHVSZWFkKHN0YXRlLnRtcCk7XHJcbiAgc3RhdGUuYW1UaWNrID0gYW1fcm13X2lueF9UNTtcclxufVxyXG5cclxuZnVuY3Rpb24gYW1fcm13X2lueF9UNSgpIHtcclxuICBzdGF0ZS50bXAgICAgPSBjcHVSZWFkKChzdGF0ZS5hZGggPDwgOCkgfCBzdGF0ZS5hZGwpO1xyXG4gIHN0YXRlLmFtVGljayA9IGFtX3Jtd19pbnhfVDY7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX3Jtd19pbnhfVDYoKSB7XHJcbiAgLy8gQWxsIHRoZSBvdGhlciByZWFkLW1vZGlmeS13cml0ZSdzIGRvIGEgZHVtbXkgd3JpdGUgYWZ0ZXIgcmVhZGluZywgd2hpbGVcclxuICAvLyB0aGUgQUxVJ3MgY2FsY3VsYXRpbmcsIHNvIHRoaXMgc2VlbXMgYSBzYWZlIGJldC5cclxuICBjcHVXcml0ZSgoc3RhdGUuYWRoIDw8IDgpIHwgc3RhdGUuYWRsLCBzdGF0ZS50bXApO1xyXG4gIHN0YXRlLnRtcCAgICA9IHN0YXRlLm9wRm4oc3RhdGUudG1wKTtcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9ybXdfaW54X1Q3O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbV9ybXdfaW54X1Q3KCkge1xyXG4gIGNwdVdyaXRlKChzdGF0ZS5hZGggPDwgOCkgfCBzdGF0ZS5hZGwsIHN0YXRlLnRtcCk7XHJcbiAgc3RhdGUuYW1UaWNrID0gbnVsbDtcclxuICBzdGF0ZS5mZFRpY2sgPSBmZF9mZXRjaF9UMDtcclxufVxyXG5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gUmVhZC1tb2RpZnktd3JpdGUgb3BlcmF0aW9uczogaW5kaXJlY3QsWSBhZGRyZXNzaW5nXHJcbi8vIChOb3QgcmVmZXJlbmNlZCBpbiDigKAzLCBhcyBvbmx5IHVzZWQgYnkgcXVhc2ktb3BzLiBDeWNsZSBzZXF1ZW5jZSBpcyB0aHVzXHJcbi8vIGd1ZXNzd29yaywgaW5mb3JtZWQgb25seSBieSB0aGUgSUVPTUQgaW5kaXJlY3QsWSBzZXF1ZW5jZSAo4oCgMzogQS4gMi43KSBhbmRcclxuLy8ga25vd2luZyB0aGF0IHRoZSBpbnN0cnVjdGlvbnMgdGFrZSA4IGN5Y2xlcyAo4oCgNCkuKVxyXG5cclxuZnVuY3Rpb24gYW1fcm13X2lueV9UMSgpIHtcclxuICBzdGF0ZS5wYyAgICAgPSArK3N0YXRlLnBjICYgMHhmZmZmO1xyXG4gIHN0YXRlLmFtVGljayA9IGFtX3Jtd19pbnlfVDI7XHJcbiAgc3RhdGUuZmRUaWNrID0gbnVsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gYW1fcm13X2lueV9UMigpIHtcclxuICAvLyBEZWNvZGUgcGhhc2UgbGVmdCB0aGUgb3BlcmFuZCAoemVybyBwYWdlIGFkZHJlc3MpIGluIHN0YXRlLnRtcC5cclxuICAvLyBvcEZuIGV4cGVjdHMgaXRzIG9wZXJhbmQgdG8gYmUgaW4gc3RhdGUudG1wLlxyXG4gIHN0YXRlLmFkbCAgICA9IGNwdVJlYWQoc3RhdGUudG1wKTtcclxuICBzdGF0ZS50bXAgICAgPSArK3N0YXRlLnRtcCAmIDB4ZmY7XHJcbiAgc3RhdGUuYW1UaWNrID0gYW1fcm13X2lueV9UMztcclxufVxyXG5cclxuZnVuY3Rpb24gYW1fcm13X2lueV9UMygpIHtcclxuICBzdGF0ZS5hZGggICAgPSBjcHVSZWFkKHN0YXRlLnRtcCk7XHJcbiAgc3RhdGUuYWRsICAgID0gc3RhdGUuYWRsICsgc3RhdGUueTsgIC8vIDkgYml0cyBoZXJlYWZ0ZXJcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9ybXdfaW55X1Q0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbV9ybXdfaW55X1Q0KCkge1xyXG4gIHN0YXRlLnRtcCAgICA9IGNwdVJlYWQoKHN0YXRlLmFkaCA8PCA4KSB8IChzdGF0ZS5hZGwgJiAweGZmKSk7XHJcblxyXG4gIGlmIChzdGF0ZS5hZGwgPiAweGZmKSB7XHJcbiAgICAvLyBBZGRyZXNzIG5lZWRzIGZpeGluZ1xyXG4gICAgc3RhdGUuYWRoICAgID0gKytzdGF0ZS5hZGggJiAweGZmO1xyXG4gICAgc3RhdGUuYWRsICAgID0gc3RhdGUuYWRsICYgMHhmZjsgICAvLyA4IGJpdHMgaGVyZWFmdGVyXHJcbiAgfVxyXG5cclxuICAvLyBzdGF0ZS5hZGwgaXMgOCBiaXRzIGhlcmVhZnRlclxyXG4gIHN0YXRlLmFtVGljayA9IGFtX3Jtd19pbnlfVDU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX3Jtd19pbnlfVDUoKSB7XHJcbiAgc3RhdGUudG1wICAgID0gY3B1UmVhZCgoc3RhdGUuYWRoIDw8IDgpIHwgc3RhdGUuYWRsKTtcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9ybXdfaW55X1Q2O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbV9ybXdfaW55X1Q2KCkge1xyXG4gIC8vIEFsbCB0aGUgb3RoZXIgcmVhZC1tb2RpZnktd3JpdGUncyBkbyBhIGR1bW15IHdyaXRlIGFmdGVyIHJlYWRpbmcsIHdoaWxlXHJcbiAgLy8gdGhlIEFMVSdzIGNhbGN1bGF0aW5nLCBzbyB0aGlzIHNlZW1zIGEgc2FmZSBiZXQuXHJcbiAgY3B1V3JpdGUoKHN0YXRlLmFkaCA8PCA4KSB8IHN0YXRlLmFkbCwgc3RhdGUudG1wKTtcclxuICBzdGF0ZS50bXAgICAgPSBzdGF0ZS5vcEZuKHN0YXRlLnRtcCk7XHJcbiAgc3RhdGUuYW1UaWNrID0gYW1fcm13X2lueV9UNztcclxufVxyXG5cclxuZnVuY3Rpb24gYW1fcm13X2lueV9UNygpIHtcclxuICBjcHVXcml0ZSgoc3RhdGUuYWRoIDw8IDgpIHwgc3RhdGUuYWRsLCBzdGF0ZS50bXApO1xyXG4gIHN0YXRlLmFtVGljayA9IG51bGw7XHJcbiAgc3RhdGUuZmRUaWNrID0gZmRfZmV0Y2hfVDA7XHJcbn1cclxuXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIE1pc2NlbGxhbmVvdXMgb3BlcmF0aW9uczogcHVzaCBvcGVyYXRpb25zXHJcbi8vICjigKAzOiBBLiA1LjEpXHJcblxyXG5mdW5jdGlvbiBhbV9wdXNoX1QxKCkge1xyXG4gIHN0YXRlLmFtVGljayA9IGFtX3B1c2hfVDI7XHJcbiAgc3RhdGUuZmRUaWNrID0gbnVsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gYW1fcHVzaF9UMigpIHtcclxuICAvLyBvcEZuIHJldHVybnMgdGhlIHRoaW5nIHRvIGJlIHB1c2hlZC5cclxuICBjcHVXcml0ZSgweDEwMCArIHN0YXRlLnMsIHN0YXRlLm9wRm4oKSk7XHJcbiAgc3RhdGUucyAgICAgID0gLS1zdGF0ZS5zICYgMHhmZjtcclxuICBzdGF0ZS5hbVRpY2sgPSBudWxsO1xyXG4gIHN0YXRlLmZkVGljayA9IGZkX2ZldGNoX1QwO1xyXG59XHJcblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBNaXNjZWxsYW5lb3VzIG9wZXJhdGlvbnM6IHB1bGwgb3BlcmF0aW9uc1xyXG4vLyAo4oCgMzogQS4gNS4yKVxyXG5cclxuZnVuY3Rpb24gYW1fcHVsbF9UMSgpIHtcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9wdWxsX1QyO1xyXG4gIHN0YXRlLmZkVGljayA9IG51bGw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX3B1bGxfVDIoKSB7XHJcbiAgLy8gb3BGbiBhc3NpZ25zIGl0cyBhcmd1bWVudCB0byB0aGUgbmVjZXNzYXJ5IHJlZ2lzdGVyXHJcbiAgY3B1UmVhZCgweDEwMCArIHN0YXRlLnMpO1xyXG4gIHN0YXRlLnMgICAgICA9ICsrc3RhdGUucyAmIDB4ZmY7XHJcbiAgc3RhdGUuYW1UaWNrID0gYW1fcHVsbF9UMztcclxufVxyXG5cclxuZnVuY3Rpb24gYW1fcHVsbF9UMygpIHtcclxuICBzdGF0ZS50bXAgICAgPSBjcHVSZWFkKDB4MTAwICsgc3RhdGUucyk7XHJcbiAgc3RhdGUuYW1UaWNrID0gYW1fcHVsbF9UNDtcclxuICBzdGF0ZS5mZFRpY2sgPSBmZF9mZXRjaF9UMDtcclxufVxyXG5cclxuZnVuY3Rpb24gYW1fcHVsbF9UNCgpIHtcclxuICBzdGF0ZS5vcEZuKHN0YXRlLnRtcCk7XHJcbiAgc3RhdGUuYW1UaWNrID0gbnVsbDtcclxufVxyXG5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gTWlzY2VsbGFuZW91cyBvcGVyYXRpb25zOiBqdW1wIHRvIHN1YnJvdXRpbmVcclxuLy8gKOKAoDM6IEEuIDUuMylcclxuXHJcbmZ1bmN0aW9uIGFtX2pzcl9UMSgpIHtcclxuICBzdGF0ZS5wYyAgICAgPSArK3N0YXRlLnBjICYgMHhmZmZmO1xyXG4gIHN0YXRlLmFtVGljayA9IGFtX2pzcl9UMjtcclxuICBzdGF0ZS5mZFRpY2sgPSBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbV9qc3JfVDIoKSB7XHJcbiAgLy8gRGVjb2RlIHBoYXNlIGxlZnQgdGhlIHN1YnJvdXRpbmUgYWRkcmVzcydzIGxvdyBieXRlIGluIHN0YXRlLnRtcC5cclxuICAvLyBJdCdzIG5vdCBjbGVhciB0byBtZSB3aHkgdGhpcyBjeWNsZSBleGlzdHMuIEl0IGRvZXMgbm90aGluZyB1c2VmdWwuXHJcbiAgY3B1UmVhZCgweDEwMCArIHN0YXRlLnMpO1xyXG4gIHN0YXRlLmFtVGljayA9IGFtX2pzcl9UMztcclxufVxyXG5cclxuZnVuY3Rpb24gYW1fanNyX1QzKCkge1xyXG4gIGNwdVdyaXRlKDB4MTAwICsgc3RhdGUucywgc3RhdGUucGMgPj4gOCk7XHJcbiAgc3RhdGUucyAgICAgID0gLS1zdGF0ZS5zICYgMHhmZjtcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9qc3JfVDQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX2pzcl9UNCgpIHtcclxuICBjcHVXcml0ZSgweDEwMCArIHN0YXRlLnMsIHN0YXRlLnBjICYgMHhmZik7XHJcbiAgc3RhdGUucyAgICAgID0gLS1zdGF0ZS5zICYgMHhmZjtcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9qc3JfVDU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX2pzcl9UNSgpIHtcclxuICBzdGF0ZS5hZGggICAgPSBjcHVSZWFkKHN0YXRlLnBjKTtcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9qc3JfVDY7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX2pzcl9UNigpIHtcclxuICBzdGF0ZS5wYyAgICAgPSAoc3RhdGUuYWRoIDw8IDgpIHwgc3RhdGUudG1wO1xyXG4gIHN0YXRlLmFtVGljayA9IG51bGw7XHJcbiAgc3RhdGUuZmRUaWNrID0gZmRfZmV0Y2hfVDA7XHJcbn1cclxuXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIE1pc2NlbGxhbmVvdXMgb3BlcmF0aW9uczogYnJlYWsgb3BlcmF0aW9uIChoYXJkd2FyZSBpbnRlcnJ1cHQvQlJLKVxyXG4vLyAo4oCgMzogQS4gNS40KVxyXG5cclxuZnVuY3Rpb24gYW1faW50ZXJydXB0X1QxKCkge1xyXG5cclxuICAvLyBPbmx5IGluY3JlbWVudCB0aGUgUEMgaWYgdGhpcyBpcyBhIEJSS1xyXG4gIC8vIChUaG91Z2ggZXZlbiBzdGlsbCwgdGhhdCdzIG5vdCB2ZXJ5IHVzZWZ1bClcclxuICBpZiAoc3RhdGUucGVuZGluZ0ludCA9PT0gMCkge1xyXG4gICAgc3RhdGUucGMgPSArK3N0YXRlLnBjICYgMHhmZmZmO1xyXG4gIH1cclxuXHJcbiAgc3RhdGUuZmRUaWNrID0gbnVsbDtcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9pbnRlcnJ1cHRfVDI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX2ludGVycnVwdF9UMigpIHtcclxuXHJcbiAgLy8gUHVzaCBQQ0ggb250byBzdGFja1xyXG4gIGNwdVdyaXRlKDB4MTAwICsgc3RhdGUucywgc3RhdGUucGMgPj4gOCk7XHJcbiAgc3RhdGUucyA9IC0tc3RhdGUucyAmIDB4ZmY7XHJcblxyXG4gIHN0YXRlLmFtVGljayA9IGFtX2ludGVycnVwdF9UMztcclxufVxyXG5cclxuZnVuY3Rpb24gYW1faW50ZXJydXB0X1QzKCkge1xyXG5cclxuICAvLyBQdXNoIFBDTCBvbnRvIHN0YWNrXHJcbiAgY3B1V3JpdGUoMHgxMDAgKyBzdGF0ZS5zLCBzdGF0ZS5wYyAmIDB4ZmYpO1xyXG4gIHN0YXRlLnMgPSAtLXN0YXRlLnMgJiAweGZmO1xyXG5cclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9pbnRlcnJ1cHRfVDQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX2ludGVycnVwdF9UNCgpIHtcclxuXHJcbiAgLy8gUHVzaCBQIG9udG8gc3RhY2tcclxuICBjcHVXcml0ZSgweDEwMCArIHN0YXRlLnMsIHN0YXR1c1RvUCgoc3RhdGUucGVuZGluZ0ludCA9PT0gMCkgPyAxIDogMCkpO1xyXG4gIHN0YXRlLnMgPSAtLXN0YXRlLnMgJiAweGZmO1xyXG5cclxuICAvLyBOb3cgdGhhdCB0aGUgc3RhdHVzIHJlZ2lzdGVyIGhhcyBiZWVuIHB1c2hlZCwgd2UgY2FuIGNoYW5nZSBpdFxyXG4gIHN0YXRlLmkgPSAxO1xyXG5cclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9pbnRlcnJ1cHRfVDU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX2ludGVycnVwdF9UNSgpIHtcclxuXHJcbiAgLy8gR2V0IGludGVycnVwdCB2ZWN0b3IgbG93Ynl0ZVxyXG4gIGxldCBsb3dieXRlO1xyXG5cclxuICBpZiAgICAgIChzdGF0ZS5wZW5kaW5nSW50ID09PSAwKSBsb3dieXRlID0gMHhmZmZlOyAgLy8gQlJLXHJcbiAgZWxzZSBpZiAoc3RhdGUucGVuZGluZ0ludCA9PT0gMSkgbG93Ynl0ZSA9IDB4ZmZmZTsgIC8vIElSUSAoc2FtZSB2ZWN0b3IpXHJcbiAgZWxzZSBpZiAoc3RhdGUucGVuZGluZ0ludCA9PT0gMikgbG93Ynl0ZSA9IDB4ZmZmYTsgIC8vIE5NSVxyXG4gIGVsc2UgaWYgKHN0YXRlLnBlbmRpbmdJbnQgPT09IDMpIGxvd2J5dGUgPSAweGZmZmM7ICAvLyBSRVNFVFxyXG5cclxuICBzdGF0ZS5wYyA9IGNwdVJlYWQobG93Ynl0ZSk7XHJcblxyXG4gIHN0YXRlLmFtVGljayA9IGFtX2ludGVycnVwdF9UNjtcclxufVxyXG5cclxuZnVuY3Rpb24gYW1faW50ZXJydXB0X1Q2KCkge1xyXG5cclxuICAvLyBHZXQgaW50ZXJydXB0IHZlY3RvciBoaWdoYnl0ZVxyXG4gIGxldCBoaWdoYnl0ZTtcclxuXHJcbiAgaWYgICAgICAoc3RhdGUucGVuZGluZ0ludCA9PT0gMCkgaGlnaGJ5dGUgPSAweGZmZmY7ICAvLyBCUktcclxuICBlbHNlIGlmIChzdGF0ZS5wZW5kaW5nSW50ID09PSAxKSBoaWdoYnl0ZSA9IDB4ZmZmZjsgIC8vIElSUSAoc2FtZSB2ZWN0b3IpXHJcbiAgZWxzZSBpZiAoc3RhdGUucGVuZGluZ0ludCA9PT0gMikgaGlnaGJ5dGUgPSAweGZmZmI7ICAvLyBOTUlcclxuICBlbHNlIGlmIChzdGF0ZS5wZW5kaW5nSW50ID09PSAzKSBoaWdoYnl0ZSA9IDB4ZmZmZDsgIC8vIFJFU0VUXHJcblxyXG4gIHN0YXRlLnBjIHw9IGNwdVJlYWQoaGlnaGJ5dGUpIDw8IDg7XHJcblxyXG4gIC8vIENsZWFyIHBlbmRpbmdJbnQsIHNvIHRoZSBuZXh0IHRpbWUgd2UgY29tZSB0byB0aGlzIHNlcXVlbmNlIHdlJ2xsIGFzc3VtZVxyXG4gIC8vIGl0J3MgYSBCUksgdW5sZXNzIHRoZSBpbnRlcnJ1cHQgcG9sbGVyIHdhbnRzIHRvIHRlbGwgdXMgb3RoZXJ3aXNlLlxyXG4gIHN0YXRlLnBlbmRpbmdJbnQgPSAwO1xyXG5cclxuICBzdGF0ZS5hbVRpY2sgPSBudWxsO1xyXG4gIHN0YXRlLmZkVGljayA9IGZkX2ZldGNoX1QwO1xyXG59XHJcblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBNaXNjZWxsYW5lb3VzIG9wZXJhdGlvbnM6IHJldHVybiBmcm9tIGludGVycnVwdCAoUlRJKVxyXG4vLyAo4oCgMzogQS4gNS41KVxyXG5cclxuZnVuY3Rpb24gYW1fcnRpX1QxKCkge1xyXG4gIHN0YXRlLmFtVGljayA9IGFtX3J0aV9UMjtcclxuICBzdGF0ZS5mZFRpY2sgPSBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbV9ydGlfVDIoKSB7XHJcbiAgY3B1UmVhZCgweDEwMCArIHN0YXRlLnMpO1xyXG4gIHN0YXRlLnMgICAgICA9ICsrc3RhdGUucyAmIDB4ZmY7XHJcbiAgc3RhdGUuYW1UaWNrID0gYW1fcnRpX1QzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbV9ydGlfVDMoKSB7XHJcbiAgcFRvU3RhdHVzKGNwdVJlYWQoMHgxMDAgKyBzdGF0ZS5zKSk7XHJcbiAgc3RhdGUucyAgICAgID0gKytzdGF0ZS5zICYgMHhmZjtcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9ydGlfVDQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX3J0aV9UNCgpIHtcclxuICBzdGF0ZS5wYyAgICAgPSBjcHVSZWFkKDB4MTAwICsgc3RhdGUucyk7XHJcbiAgc3RhdGUucyAgICAgID0gKytzdGF0ZS5zICYgMHhmZjtcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9ydGlfVDU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX3J0aV9UNSgpIHtcclxuICBzdGF0ZS5wYyAgICB8PSBjcHVSZWFkKDB4MTAwICsgc3RhdGUucykgPDwgODtcclxuICBzdGF0ZS5hbVRpY2sgPSBudWxsO1xyXG4gIHN0YXRlLmZkVGljayA9IGZkX2ZldGNoX1QwO1xyXG59XHJcblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBKdW1wIG9wZXJhdGlvbjogYWJzb2x1dGUgYWRkcmVzc2luZ1xyXG4vLyAo4oCgMzogQS4gNS42LjEpXHJcblxyXG5mdW5jdGlvbiBhbV9qbXBfYWJzX1QxKCkge1xyXG4gIHN0YXRlLnBjICAgICA9ICsrc3RhdGUucGMgJiAweGZmZmY7XHJcbiAgc3RhdGUuYW1UaWNrID0gYW1fam1wX2Fic19UMjtcclxuICBzdGF0ZS5mZFRpY2sgPSBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbV9qbXBfYWJzX1QyKCkge1xyXG4gIC8vIERlY29kZSBwaGFzZSBsZWZ0IHRoZSB0YXJnZXQgYWRkcmVzcydzIGxvdyBieXRlIGluIHN0YXRlLnRtcC5cclxuICBzdGF0ZS5wYyAgICAgPSAoY3B1UmVhZChzdGF0ZS5wYykgPDwgOCkgfCBzdGF0ZS50bXA7XHJcbiAgc3RhdGUuYW1UaWNrID0gbnVsbDtcclxuICBzdGF0ZS5mZFRpY2sgPSBmZF9mZXRjaF9UMDtcclxufVxyXG5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gSnVtcCBvcGVyYXRpb246IGluZGlyZWN0IGFkZHJlc3NpbmdcclxuLy8gKOKAoDM6IEEuIDUuNi4yKVxyXG5cclxuZnVuY3Rpb24gYW1fam1wX2luZF9UMSgpIHtcclxuICBzdGF0ZS5wYyAgICAgPSArK3N0YXRlLnBjICYgMHhmZmZmO1xyXG4gIHN0YXRlLmFtVGljayA9IGFtX2ptcF9pbmRfVDI7XHJcbiAgc3RhdGUuZmRUaWNrID0gbnVsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gYW1fam1wX2luZF9UMigpIHtcclxuICAvLyBEZWNvZGUgcGhhc2UgbGVmdCB0aGUgcG9pbnRlciBhZGRyZXNzJ3MgbG93IGJ5dGUgaW4gc3RhdGUudG1wLlxyXG4gIHN0YXRlLmFkaCAgICA9IGNwdVJlYWQoc3RhdGUucGMpO1xyXG4gIHN0YXRlLmFtVGljayA9IGFtX2ptcF9pbmRfVDM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX2ptcF9pbmRfVDMoKSB7XHJcbiAgc3RhdGUucGMgICAgID0gY3B1UmVhZCgoc3RhdGUuYWRoIDw8IDgpIHwgc3RhdGUudG1wKTtcclxuICBzdGF0ZS50bXAgICAgPSArK3N0YXRlLnRtcCAmIDB4ZmY7XHJcbiAgc3RhdGUuYW1UaWNrID0gYW1fam1wX2luZF9UNDtcclxufVxyXG5cclxuZnVuY3Rpb24gYW1fam1wX2luZF9UNCgpIHtcclxuICBzdGF0ZS5wYyAgICB8PSBjcHVSZWFkKChzdGF0ZS5hZGggPDwgOCkgfCBzdGF0ZS50bXApIDw8IDg7XHJcbiAgc3RhdGUuYW1UaWNrID0gbnVsbDtcclxuICBzdGF0ZS5mZFRpY2sgPSBmZF9mZXRjaF9UMDtcclxufVxyXG5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gTWlzY2VsbGFuZW91cyBvcGVyYXRpb25zOiByZXR1cm4gZnJvbSBzdWJyb3V0aW5lIChSVFMpXHJcbi8vICjigKAzOiBBLiA1LjcpXHJcblxyXG5mdW5jdGlvbiBhbV9ydHNfVDEoKSB7XHJcbiAgc3RhdGUuYW1UaWNrID0gYW1fcnRzX1QyO1xyXG4gIHN0YXRlLmZkVGljayA9IG51bGw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX3J0c19UMigpIHtcclxuICBjcHVSZWFkKDB4MTAwICsgc3RhdGUucyk7XHJcbiAgc3RhdGUucyAgICAgID0gKytzdGF0ZS5zICYgMHhmZjtcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9ydHNfVDM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX3J0c19UMygpIHtcclxuICBzdGF0ZS5wYyAgICAgPSBjcHVSZWFkKDB4MTAwICsgc3RhdGUucyk7XHJcbiAgc3RhdGUucyAgICAgID0gKytzdGF0ZS5zICYgMHhmZjtcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9ydHNfVDQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX3J0c19UNCgpIHtcclxuICBzdGF0ZS5wYyAgICB8PSBjcHVSZWFkKDB4MTAwICsgc3RhdGUucykgPDwgODtcclxuICBzdGF0ZS5hbVRpY2sgPSBhbV9ydHNfVDU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFtX3J0c19UNSgpIHtcclxuICBjcHVSZWFkKHN0YXRlLnBjKTtcclxuICBzdGF0ZS5wYyAgICAgPSArK3N0YXRlLnBjICYgMHhmZmZmO1xyXG4gIHN0YXRlLmFtVGljayA9IG51bGw7XHJcbiAgc3RhdGUuZmRUaWNrID0gZmRfZmV0Y2hfVDA7XHJcbn1cclxuXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIE1pc2NlbGxhbmVvdXMgb3BlcmF0aW9uczogYnJhbmNoIG9wZXJhaW9uXHJcbi8vICjigKAzOiBBLiA1LjggaGFzIHRvIGJlIHdyb25nOyBzZWUgcHJlc3VtZWQgZml4IGluIOKAoDIpXHJcblxyXG5mdW5jdGlvbiBhbV9yZWxfVDEoKSB7XHJcbiAgc3RhdGUucGMgICAgID0gKytzdGF0ZS5wYyAmIDB4ZmZmZjtcclxuICBzdGF0ZS5mZFRpY2sgPSBudWxsO1xyXG4gIHN0YXRlLmFtVGljayA9IGFtX3JlbF9UMjtcclxufVxyXG5cclxuZnVuY3Rpb24gYW1fcmVsX1QyKCkge1xyXG4gIC8vIEluc3RydWN0aW9uIGRlY29kZSB3aWxsIGhhdmUgbGVmdCB0aGUgaW5zdHJ1Y3Rpb24gb3BlcmFuZCAodGhlIGJyYW5jaCBvZmZzZXQpXHJcbiAgLy8gaW4gc3RhdGUudG1wIGZvciB1c1xyXG5cclxuICAvLyBSZWFkIG5leHQgb3Bjb2RlLCBpZiB0aGF0J3Mgd2hhdCBpdCB0dXJucyBvdXQgdG8gYmVcclxuICBzdGF0ZS5pciA9IGNwdVJlYWQoc3RhdGUucGMpO1xyXG5cclxuICAvLyBUaGlzIHN0YWdlIHdvdWxkIGJlIFQyIG9mIGEgYnJhbmNoIGluc3RydWN0aW9uLCB3aGljaCBzZWVtcyB0byBiZSAo4oCgMilcclxuICAvLyB3aGVyZSB0aGUgcmVsYXRpdmUgbW9kZSBpbnRlcnJ1cHQgcG9sbCBzZWVtcyB0byBiZS5cclxuICBwb2xsRm9ySW50ZXJydXB0cygpO1xyXG5cclxuICAvLyBFdmFsdWF0ZSB0aGUgYnJhbmNoIGNyaXRlcmlvblxyXG4gIGlmIChzdGF0ZS5vcEZuKCkpIHtcclxuXHJcbiAgICAvLyBUYWtpbmcgYnJhbmNoXHJcbiAgICBjb25zdCBvZmZzZXQgPSBzdGF0ZS50bXA7IC8vIG9wZXJhbmQsIGZyb20gcHJldmlvdXMgY3ljbGVcclxuXHJcbiAgICAvLyA5LWJpdCBBREwsIGVmZmVjdGl2ZWx5XHJcbiAgICBzdGF0ZS5hZGwgPSAoc3RhdGUucGMgJiAweGZmKSArIChvZmZzZXQgPCAweDgwID8gb2Zmc2V0IDogLSgyNTYgLSBvZmZzZXQpKTtcclxuXHJcbiAgICAvLyBDb2JibGUgdG9nZXRoZXIgYW4gdW4tZml4ZWQgUEMgYnkgYWRkaW5nIHRoZSBsb3cgYnl0ZXMgd2l0aG91dCBjYXJyeVxyXG4gICAgc3RhdGUucGMgPSAoc3RhdGUucGMgJiAweGZmMDApIHwgKHN0YXRlLmFkbCAmIDB4ZmYpO1xyXG5cclxuICAgIHN0YXRlLmFtVGljayA9IGFtX3JlbF9UMztcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgXHJcbiAgLy8gQnJhbmNoIG5vdCB0YWtlbi4gU2tpcCBzdHJhaWdodCB0byB0aGUgZGVjb2RlIHN0YWdlIGFzIHdlJ3ZlIGFscmVhZHlcclxuICAvLyBwZXJmb3JtZWQgdGhlIGluc3RydWN0aW9uIGZldGNoLlxyXG5cclxuICAvLyBMYXRjaCB0aGUgaW5zdHJ1Y3Rpb24gcmVnaXN0ZXIgZnJvbSB6ZXJvIChCUkspIGlmIHRoZXJlIGFyZSBpbnRlcnJ1cHRzXHJcbiAgaWYgKHN0YXRlLnBlbmRpbmdJbnQpIHtcclxuICAgIHN0YXRlLmlyID0gMDtcclxuICB9XHJcbiAgZWxzZSB7XHJcbiAgICBzdGF0ZS5wYyA9ICsrc3RhdGUucGMgJiAweGZmZmY7XHJcbiAgfVxyXG5cclxuICBzdGF0ZS5hbVRpY2sgPSBudWxsO1xyXG4gIHN0YXRlLmZkVGljayA9IGZkX2RlY29kZV9UMTtcclxufVxyXG5cclxuZnVuY3Rpb24gYW1fcmVsX1QzKCkge1xyXG5cclxuICAvLyBSZWFkIG5leHQgb3Bjb2RlIGZyb20gdW4tZml4ZWQgUEMsIHRoZW4gZmlndXJlIG91dCBpZiBpdCBuZWVkZWQgZml4aW5nXHJcbiAgc3RhdGUuaXIgPSBjcHVSZWFkKHN0YXRlLnBjKTtcclxuXHJcbiAgaWYgKHN0YXRlLmFkbCAmIDB4MTAwKSB7ICAvLyAoc3RhdGUuYWRsIDwgMCkgfHwgKHN0YXRlLmFkbCA+IDB4ZmYpXHJcblxyXG4gICAgc3RhdGUucGMgPSAoc3RhdGUuYWRsIDwgMClcclxuICAgICAgPyAoKHN0YXRlLnBjIC0gMHgxMDApICYgMHhmZmZmKVxyXG4gICAgICA6ICgoc3RhdGUucGMgKyAweDEwMCkgJiAweGZmZmYpXHJcbiAgICA7XHJcbiAgICBcclxuICAgIC8vIEVuZCB0aGUgYWRkcmVzc2luZyBtb2RlIHByb2Nlc3NpbmcgYW5kIHVzZSB0aGUgcmVndWxhciBmZXRjaC9kZWNvZGVcclxuICAgIC8vIGZldGNoIHN0YWdlIHRvIGV4ZWN1dGUgZnJvbSB0aGUgbmV4dCBpbnN0cnVjdGlvbi4gVGhpcyB3b3VsZCBiZSB3aHksXHJcbiAgICAvLyBJJ20gdGhpbmtpbmcsIHJlYWwgaGFyZHdhcmUgaG9ub3JzIGludGVycnVwdHMgYW4gaW5zdHJ1Y3Rpb24gc29vbmVyIHdoZW5cclxuICAgIC8vIHRoZSBQQyBuZWVkZWQgZml4dXAgdGhhbiB3aGVuIGl0IGRvZXNuJ3QuIChTZWUg4oCgMilcclxuXHJcbiAgICBzdGF0ZS5hbVRpY2sgPSBudWxsO1xyXG4gICAgc3RhdGUuZmRUaWNrID0gZmRfZmV0Y2hfVDA7XHJcbiAgfVxyXG5cclxuICBlbHNlIHtcclxuICAgIC8vIEl0IGRpZG4ndCBuZWVkIGZpeGluZy4gU2luY2Ugd2UgYWxyZWFkeSBoYXZlIHRoZSBmZXRjaGVkIGluc3RydWN0aW9uLFxyXG4gICAgLy8gYWR2YW5jZSBzdHJhaWdodCB0byBmZF9kZWNvZGVfVDFcclxuXHJcbiAgICAvLyBMYXRjaCB0aGUgaW5zdHJ1Y3Rpb24gcmVnaXN0ZXIgZnJvbSB6ZXJvIChCUkspIGlmIHRoZXJlIGFyZSBpbnRlcnJ1cHRzXHJcbiAgICBpZiAoc3RhdGUucGVuZGluZ0ludCkge1xyXG4gICAgICBzdGF0ZS5pciA9IDA7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgc3RhdGUucGMgPSArK3N0YXRlLnBjICYgMHhmZmZmO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRlLmFtVGljayA9IG51bGw7XHJcbiAgICBzdGF0ZS5mZFRpY2sgPSBmZF9kZWNvZGVfVDE7XHJcbiAgfVxyXG59XHJcblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBITFQgb3Bjb2RlXHJcbi8vIE5vdCBkb2N1bWVudGVkLCBzaW5jZSBpdCdzIGEgcXVhc2ktb3AgbW9kZSwgYW5kIGl0IGNhdXNlcyBhbiBpcnJlY292ZXJhYmxlXHJcbi8vIGZhaWx1cmUsIHNvIGNhcHR1cmluZyB0aGUgbnVhbmNlcyBvZiB3aGF0IHNwZWNpZmljYWxseSBoYXBwZW5zIGVhY2ggY3ljbGVcclxuLy8gaXMgaXJyZWxldmFudC5cclxuXHJcbmZ1bmN0aW9uIGFtX2hhbHRfVDEoKSB7XHJcbiAgLy8gJ3VuaW1wbGVtZW50ZWQnIGRvZXNuJ3QgYWNjdXJhdGVseSBkZXNjcmliZSB0aGlzLiBXZSBuZWVkIGFuIGFsdGVybmF0aXZlXHJcbiAgLy8gZXJyb3IgcmVwb3J0aW5nIGhvb2suXHJcbiAgdW5pbXBsZW1lbnRlZFdhcm5pbmcoYEhMVCBvcGNvZGUgYXQgUEM9JHskeHh4eChzdGF0ZS5wYyl9YCk7XHJcbiAgc3RhdGUuYW1UaWNrID0gbnVsbDtcclxuICBzdGF0ZS5mZFRpY2sgPSBudWxsO1xyXG59XHJcblxyXG5cclxuLy8gT3Bjb2RlIG9wZXJhdGlvbnNcclxuLy9cclxuLy8gVGhlc2UgZnVuY3Rpb25zIGFyZSBzdXBwbGllZCB0byB0aGUgYWRkcmVzc2luZyBtb2RlIGhhbmRsZXIgYW5kIHBlcmZvcm0gdGhlXHJcbi8vIGtleSBmdW5jdGlvbmFsaXR5IG9mIHRoZSBvcGNvZGUuIERpZmZlcmVudCBhZGRyZXNzaW5nIG1vZGUgaGFuZGxlcnMgaGF2ZVxyXG4vLyBkaWZmZXJlbnQgZXhwZWN0YXRpb25zIG9mIGhvdyB0aGV5IGV4cGVjdCB0aGVpciBvcCBmdW5jdGlvbnMgdG8gdGFrZSBpbnB1dHNcclxuLy8gYW5kIGdpdmUgb3V0cHV0cy4gSGVuY2UsIHRvIGNsYXJpZnkgdXNhZ2UsIHRoZWlyIG5hbWVzIHRha2UgdGhlIGZvcm1hdDpcclxuLy9cclxuLy8gICAgICBvcF9YWFhfaW5fb3V0XHJcbi8vXHJcbi8vIC4uLndoZXJlIGluID0gdm9pZCAgICAgdGFrZXMgbm8gZXhwbGljaXQgaW5wdXQgKG1heWJlIGZyb20gcmVncylcclxuLy8gICAgICAgICAgaW4gPSB0bXAgICAgICB0YWtlcyBpbnB1dCBmcm9tIHN0YXRlLnRtcFxyXG4vLyAgICAgICAgICBpbiA9IGFyZyAgICAgIHRha2VzIGlucHV0IGZyb20gc29sZSBmdW5jdGlvbiBhcmd1bWVudFxyXG4vL1xyXG4vLyAgICAgICAgIG91dCA9IHZvaWQgICAgIHJldHVybnMgbm90aGluZyAob3IgaXMgaW1wbGljaXQsIG9yIHRvIHJlZ3MpXHJcbi8vICAgICAgICAgb3V0ID0gcmV0ICAgICAgcmV0dXJucyB2YWx1ZSBmcm9tIGZ1bmN0aW9uIHJldHVybiB2YWx1ZVxyXG5cclxuXHJcbi8vIEZsb3cgY29udHJvbCBvcGVyYXRpb25zXHJcbi8vIC4uLmRvbid0IG5lZWQgdG8gZXhpc3Q6IHRoZXkncmUgbmV2ZXIgY2FsbGVkLiBUaGV5IG9ubHkgZXhpc3QgdG8gaGVscFxyXG4vLyBleHBsYWluIHRoZSBvcGNvZGVzIG9mIHRoZSB0YWJsZSB3aGVyZSB0aGV5J3JlIHVzZWQuXHJcblxyXG5mdW5jdGlvbiBvcF9CUktfdm9pZF92b2lkKCkgeyB9XHJcbmZ1bmN0aW9uIG9wX0pTUl92b2lkX3ZvaWQoKSB7IH1cclxuZnVuY3Rpb24gb3BfUlRJX3ZvaWRfdm9pZCgpIHsgfVxyXG5mdW5jdGlvbiBvcF9KTVBfdm9pZF92b2lkKCkgeyB9XHJcbmZ1bmN0aW9uIG9wX1JUU192b2lkX3ZvaWQoKSB7IH1cclxuZnVuY3Rpb24gb3BfSExUX3ZvaWRfdm9pZCgpIHsgfSAgLy8gUXVhc2ktb3BcclxuXHJcbi8vIFNpbmdsZS1ieXRlIG9wZXJhdGlvbnNcclxuLy8gLi4ub3BlcmF0ZSBlbnRpcmVseSBvbiByZWdpc3RlcnNcclxuXHJcbmZ1bmN0aW9uIG9wX05PUF92b2lkX3ZvaWQoKSB7IH1cclxuZnVuY3Rpb24gb3BfQ0xDX3ZvaWRfdm9pZCgpIHsgc3RhdGUuYyA9IDA7IH1cclxuZnVuY3Rpb24gb3BfQ0xEX3ZvaWRfdm9pZCgpIHsgc3RhdGUuZCA9IDA7IH1cclxuZnVuY3Rpb24gb3BfQ0xJX3ZvaWRfdm9pZCgpIHsgc3RhdGUuaSA9IDA7IH1cclxuZnVuY3Rpb24gb3BfQ0xWX3ZvaWRfdm9pZCgpIHsgc3RhdGUudiA9IDA7IH1cclxuXHJcbmZ1bmN0aW9uIG9wX1NFQ192b2lkX3ZvaWQoKSB7IHN0YXRlLmMgPSAxOyB9XHJcbmZ1bmN0aW9uIG9wX1NFRF92b2lkX3ZvaWQoKSB7IHN0YXRlLmQgPSAxOyB9XHJcbmZ1bmN0aW9uIG9wX1NFSV92b2lkX3ZvaWQoKSB7IHN0YXRlLmkgPSAxOyB9XHJcblxyXG5mdW5jdGlvbiBvcF9UQVhfdm9pZF92b2lkKCkgeyBzdGF0ZS54ID0gc3RhdGUuYTsgc3RhdGUueiA9IHN0YXRlLnggPyAwIDogMTsgc3RhdGUubiA9IChzdGF0ZS54ICYgMHg4MCkgPyAxIDogMDsgfVxyXG5mdW5jdGlvbiBvcF9UQVlfdm9pZF92b2lkKCkgeyBzdGF0ZS55ID0gc3RhdGUuYTsgc3RhdGUueiA9IHN0YXRlLnkgPyAwIDogMTsgc3RhdGUubiA9IChzdGF0ZS55ICYgMHg4MCkgPyAxIDogMDsgfVxyXG5mdW5jdGlvbiBvcF9UWEFfdm9pZF92b2lkKCkgeyBzdGF0ZS5hID0gc3RhdGUueDsgc3RhdGUueiA9IHN0YXRlLmEgPyAwIDogMTsgc3RhdGUubiA9IChzdGF0ZS5hICYgMHg4MCkgPyAxIDogMDsgfVxyXG5mdW5jdGlvbiBvcF9UWUFfdm9pZF92b2lkKCkgeyBzdGF0ZS5hID0gc3RhdGUueTsgc3RhdGUueiA9IHN0YXRlLmEgPyAwIDogMTsgc3RhdGUubiA9IChzdGF0ZS5hICYgMHg4MCkgPyAxIDogMDsgfVxyXG5mdW5jdGlvbiBvcF9UU1hfdm9pZF92b2lkKCkgeyBzdGF0ZS54ID0gc3RhdGUuczsgc3RhdGUueiA9IHN0YXRlLnggPyAwIDogMTsgc3RhdGUubiA9IChzdGF0ZS54ICYgMHg4MCkgPyAxIDogMDsgfVxyXG5mdW5jdGlvbiBvcF9UWFNfdm9pZF92b2lkKCkgeyBzdGF0ZS5zID0gc3RhdGUueDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5mdW5jdGlvbiBvcF9ERVhfdm9pZF92b2lkKCkgeyBzdGF0ZS54ID0gLS1zdGF0ZS54ICYgMHhmZjsgc3RhdGUueiA9IHN0YXRlLnggPyAwIDogMTsgc3RhdGUubiA9IChzdGF0ZS54ICYgMHg4MCkgPyAxIDogMDsgfVxyXG5mdW5jdGlvbiBvcF9ERVlfdm9pZF92b2lkKCkgeyBzdGF0ZS55ID0gLS1zdGF0ZS55ICYgMHhmZjsgc3RhdGUueiA9IHN0YXRlLnkgPyAwIDogMTsgc3RhdGUubiA9IChzdGF0ZS55ICYgMHg4MCkgPyAxIDogMDsgfVxyXG5mdW5jdGlvbiBvcF9JTlhfdm9pZF92b2lkKCkgeyBzdGF0ZS54ID0gKytzdGF0ZS54ICYgMHhmZjsgc3RhdGUueiA9IHN0YXRlLnggPyAwIDogMTsgc3RhdGUubiA9IChzdGF0ZS54ICYgMHg4MCkgPyAxIDogMDsgfVxyXG5mdW5jdGlvbiBvcF9JTllfdm9pZF92b2lkKCkgeyBzdGF0ZS55ID0gKytzdGF0ZS55ICYgMHhmZjsgc3RhdGUueiA9IHN0YXRlLnkgPyAwIDogMTsgc3RhdGUubiA9IChzdGF0ZS55ICYgMHg4MCkgPyAxIDogMDsgfVxyXG5cclxuLy8gUmVhZC1tb2RpZnktd3JpdGUgb3BlcmF0aW9uc1xyXG4vLyAuLi50YWtlIGEgcGFyYW1ldGVyIGFuZCByZXR1cm4gYSBuZXcgdmFsdWUgZm9yIGl0LlxyXG5cclxuZnVuY3Rpb24gb3BfQVNMX2FyZ19yZXQoYXJnKSB7XHJcbiAgYXJnIDw8PSAxO1xyXG4gIHN0YXRlLmMgPSAoYXJnICYgMHgxMDApID8gMSA6IDA7XHJcbiAgYXJnICY9IDB4ZmY7XHJcbiAgc3RhdGUueiA9IGFyZyA/IDAgOiAxO1xyXG4gIHN0YXRlLm4gPSAoYXJnICYgMHg4MCkgPyAxIDogMDtcclxuICByZXR1cm4gYXJnO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvcF9MU1JfYXJnX3JldChhcmcpIHtcclxuICBzdGF0ZS5jID0gYXJnICYgMTtcclxuICBhcmcgPj49IDE7XHJcbiAgc3RhdGUueiA9IGFyZyA/IDAgOiAxO1xyXG4gIHN0YXRlLm4gPSAwO1xyXG4gIHJldHVybiBhcmc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9wX1JPTF9hcmdfcmV0KGFyZykge1xyXG4gIGFyZyA8PD0gMTtcclxuICBhcmcgfD0gc3RhdGUuYztcclxuICBzdGF0ZS5jID0gKGFyZyAmIDB4MTAwKSA/IDEgOiAwO1xyXG4gIGFyZyAmPSAweGZmO1xyXG4gIHN0YXRlLnogPSBhcmcgPyAwIDogMTtcclxuICBzdGF0ZS5uID0gKGFyZyAmIDB4ODApID8gMSA6IDA7XHJcbiAgcmV0dXJuIGFyZztcclxufVxyXG5cclxuZnVuY3Rpb24gb3BfUk9SX2FyZ19yZXQoYXJnKSB7XHJcbiAgY29uc3QgdG1wID0gc3RhdGUuYztcclxuICBzdGF0ZS5jID0gYXJnICYgMTtcclxuICBhcmcgPj49IDE7XHJcbiAgYXJnIHw9ICh0bXAgPDwgNyk7XHJcbiAgc3RhdGUueiA9IGFyZyA/IDAgOiAxO1xyXG4gIHN0YXRlLm4gPSAoYXJnICYgMHg4MCkgPyAxIDogMDtcclxuICByZXR1cm4gYXJnO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvcF9MU0VfYXJnX3JldChhcmcpIHtcclxuICAvLyBRdWFzaS1vcDogXCJMU0VcIiAo4oCgNCksIFwiU1JFXCIgKOKAoDEpXHJcbiAgc3RhdGUudG1wID0gb3BfTFNSX2FyZ19yZXQoYXJnKTtcclxuICBvcF9FT1JfdG1wX3ZvaWQoKTtcclxuICByZXR1cm4gc3RhdGUudG1wO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvcF9EQ01fYXJnX3JldChhcmcpIHtcclxuICAvLyBRdWFzaS1vcDogXCJEQ01cIiAo4oCgNCksIFwiRENQXCIgKOKAoDEpXHJcbiAgc3RhdGUudG1wID0gb3BfREVDX2FyZ19yZXQoYXJnKTtcclxuICBvcF9DTVBfdG1wX3ZvaWQoKTtcclxuICByZXR1cm4gc3RhdGUudG1wO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvcF9BU09fYXJnX3JldChhcmcpIHtcclxuICAvLyBRdWFzaS1vcDogXCJBU09cIiAo4oCgNCksIFwiU0xPXCIgKOKAoDEpXHJcbiAgc3RhdGUudG1wID0gb3BfQVNMX2FyZ19yZXQoYXJnKTtcclxuICBvcF9PUkFfdG1wX3ZvaWQoKTtcclxuICByZXR1cm4gc3RhdGUudG1wO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvcF9STEFfYXJnX3JldChhcmcpIHtcclxuICAvLyBRdWFzaS1vcDogXCJSTEFcIiAo4oCgNCBhbmQg4oCgMSlcclxuICBzdGF0ZS50bXAgPSBvcF9ST0xfYXJnX3JldChhcmcpO1xyXG4gIG9wX0FORF90bXBfdm9pZCgpO1xyXG4gIHJldHVybiBzdGF0ZS50bXA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9wX1JSQV9hcmdfcmV0KGFyZykge1xyXG4gIC8vIFF1YXNpLW9wOiBcIlJSQVwiICjigKA0IGFuZCDigKAxKVxyXG4gIHN0YXRlLnRtcCA9IG9wX1JPUl9hcmdfcmV0KGFyZyk7XHJcbiAgb3BfQURDX3RtcF92b2lkKCk7XHJcbiAgcmV0dXJuIHN0YXRlLnRtcDtcclxufVxyXG5cclxuZnVuY3Rpb24gb3BfSU5TX2FyZ19yZXQoYXJnKSB7XHJcbiAgLy8gUXVhc2ktb3A6IFwiSU5TXCIgKOKAoDQpLCBcIklTQlwiICjigKAxKSwgYW5kIGFsc28gXCJJU0JcIiAo4oCgNClcclxuICBzdGF0ZS50bXAgPSBvcF9JTkNfYXJnX3JldChhcmcpO1xyXG4gIG9wX1NCQ190bXBfdm9pZCgpO1xyXG4gIHJldHVybiBzdGF0ZS50bXA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9wX0lOQ19hcmdfcmV0KGFyZykgeyBhcmcgPSArK2FyZyAmIDB4ZmY7IHN0YXRlLnogPSBhcmcgPyAwIDogMTsgc3RhdGUubiA9IChhcmcgJiAweDgwKSA/IDEgOiAwOyByZXR1cm4gYXJnOyB9XHJcbmZ1bmN0aW9uIG9wX0RFQ19hcmdfcmV0KGFyZykgeyBhcmcgPSAtLWFyZyAmIDB4ZmY7IHN0YXRlLnogPSBhcmcgPyAwIDogMTsgc3RhdGUubiA9IChhcmcgJiAweDgwKSA/IDEgOiAwOyByZXR1cm4gYXJnOyB9XHJcbmZ1bmN0aW9uIG9wX05PUF9hcmdfcmV0KGFyZykgeyAvKiBRdWFzaS1vcCAqLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnOyB9XHJcblxyXG4vLyBCb29sZWFuIGZ1bmN0aW9uc1xyXG4vLyAuLi50YWtlIGEgcGFyYW1ldGVyIGFuZCBtdXRhdGUgdGhlIGFjY3VtdWxhdG9yIHdpdGggaXQuXHJcblxyXG5mdW5jdGlvbiBvcF9FT1JfdG1wX3ZvaWQoKSB7IHN0YXRlLmEgXj0gc3RhdGUudG1wOyBzdGF0ZS56ID0gc3RhdGUuYSA/IDAgOiAxOyAgICAgICAgICAgc3RhdGUubiA9IChzdGF0ZS5hICYgMHg4MCkgPyAxIDogMDsgfVxyXG5mdW5jdGlvbiBvcF9PUkFfdG1wX3ZvaWQoKSB7IHN0YXRlLmEgfD0gc3RhdGUudG1wOyBzdGF0ZS56ID0gc3RhdGUuYSA/IDAgOiAxOyAgICAgICAgICAgc3RhdGUubiA9IChzdGF0ZS5hICYgMHg4MCkgPyAxIDogMDsgfVxyXG5mdW5jdGlvbiBvcF9BTkRfdG1wX3ZvaWQoKSB7IHN0YXRlLmEgJj0gc3RhdGUudG1wOyBzdGF0ZS56ID0gc3RhdGUuYSA/IDAgOiAxOyAgICAgICAgICAgc3RhdGUubiA9IChzdGF0ZS5hICYgMHg4MCkgPyAxIDogMDsgfVxyXG5mdW5jdGlvbiBvcF9BTkNfdG1wX3ZvaWQoKSB7IHN0YXRlLmEgJj0gc3RhdGUudG1wOyBzdGF0ZS56ID0gc3RhdGUuYSA/IDAgOiAxOyBzdGF0ZS5jID0gc3RhdGUubiA9IChzdGF0ZS5hICYgMHg4MCkgPyAxIDogMDsgfSAgLy8gUXVhc2ktb3BcclxuXHJcbmZ1bmN0aW9uIG9wX0JJVF90bXBfdm9pZCgpIHtcclxuICBzdGF0ZS56ID0gKHN0YXRlLmEgJiBzdGF0ZS50bXApID8gMCA6IDE7XHJcbiAgc3RhdGUubiA9IChzdGF0ZS50bXAgJiAweDgwKSA/IDEgOiAwO1xyXG4gIHN0YXRlLnYgPSAoc3RhdGUudG1wICYgMHg0MCkgPyAxIDogMDtcclxufVxyXG5cclxuZnVuY3Rpb24gb3BfQU5FX3RtcF92b2lkKCkge1xyXG4gIC8vIFF1YXNpLW9wOiBcIlhBQVwiICjigKA0LCB3aGljaCBpcyBpbmFjY3VyYXRlKSwgXCJBTkVcIiAo4oCgMSlcclxuXHJcbiAgLy8g4oCgMSBkZXNjcmliZXMgaG93IHRoaXMgMHgxMSBjb25zdGFudCBjYW4gYWx0ZXJuYXRpdmVseSBiZSAweDEwLCAweDAxLFxyXG4gIC8vIG9yIDB4MDAgZGVwZW5kaW5nIG9uIHJlc2lkdWFsIGNoYXJnZSBvbiB0aGUgb3BlbiBidXMuIFRoZSAweDExIHVzZWQgaGVyZVxyXG4gIC8vIGlzIHRoZSB2YWx1ZSBleHBlY3RlZCBieSB0aGUgTG9yZW56IGFuZWIgdGVzdC5cclxuICBzdGF0ZS5hID0gKChzdGF0ZS5hICYgMHgxMSAmIHN0YXRlLngpIHwgKCAweGVlICYgc3RhdGUueCkpICYgc3RhdGUudG1wO1xyXG4gIHN0YXRlLnogPSBzdGF0ZS5hID8gMCA6IDE7XHJcbiAgc3RhdGUubiA9IChzdGF0ZS5hICYgMHg4MCkgPyAxIDogMDtcclxufVxyXG5cclxuZnVuY3Rpb24gb3BfTFhBX3RtcF92b2lkKCkge1xyXG4gIC8vIFF1YXNpLW9wOiBcIk9BTFwiICjigKA0KSwgXCJMWEFcIiAo4oCgMSlcclxuXHJcbiAgLy8gVGhlIDB4ZWUgaGVyZSBtYWtlcyBtZSB0aGluayBvZiB0aGUgMHhlZSBpbiBBTkUgYW5kIGhvdyBpdHMgMHgxMSBjYW4gYmVcclxuICAvLyB1bnN0YWJsZS4gVGhpcyBxdWFzaS1vcCBzb3VuZHMgc2ltaWxhcmx5IHVuc3RhYmxlLCBzbyBsaWtld2lzZSwgdGhlXHJcbiAgLy8gYmVoYXZpb3IgaGVyZSBpcyB3aGF0ZXZlciB0aGUgTG9yZW56IGx4YWIgdGVzdCBleHBlY3RzIGl0IHRvIGJlLlxyXG4gIHN0YXRlLmEgPSBzdGF0ZS54ID0gKHN0YXRlLmEgfCAweGVlKSAmIHN0YXRlLnRtcDtcclxuICBzdGF0ZS56ID0gc3RhdGUuYSA/IDAgOiAxO1xyXG4gIHN0YXRlLm4gPSAoc3RhdGUuYSAmIDB4ODApID8gMSA6IDA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9wX1NCWF90bXBfdm9pZCgpIHtcclxuICAvLyBRdWFzaS1vcDogXCJTQVhcIiAo4oCgNCksIFwiU0JYXCIgKOKAoDEpXHJcbiAgY29uc3QgdG1wID0gKHN0YXRlLmEgJiBzdGF0ZS54KSAtIHN0YXRlLnRtcDtcclxuXHJcbiAgc3RhdGUueCA9IHRtcCAmIDB4ZmY7XHJcbiAgc3RhdGUuYyA9ICh0bXAgPj0gMCkgPyAxIDogMDtcclxuICBzdGF0ZS56ID0gc3RhdGUueCA/IDAgOiAxO1xyXG4gIHN0YXRlLm4gPSAoc3RhdGUueCAmIDB4ODApID8gMSA6IDA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9wX0FMUl90bXBfdm9pZCgpIHtcclxuLy8gUXVhc2ktb3A6IFwiQUxSXCIgKOKAoDQpLCBcIkFTUlwiICjigKAxKVxyXG4gIHN0YXRlLmEgPSBvcF9MU1JfYXJnX3JldChzdGF0ZS5hICYgc3RhdGUudG1wKTtcclxufVxyXG5cclxuZnVuY3Rpb24gb3BfQVJSX3RtcF92b2lkKCkge1xyXG4gIC8vIFF1YXNpLW9wOiBcIkFSUlwiICjigKA0ICh3aGljaCBpcyBpbmFjY3VyYXRlKSBhbmQg4oCgMSlcclxuXHJcbiAgaWYgKHN0YXRlLmQpIHtcclxuICAgIC8vIFRyYW5zbGF0ZWQgZnJvbSDigKAxLiBJJ3ZlIHNraXBwZWQgdGhlIGFubm90YXRpb25zIGJlY2F1c2UgdGhpcyBpcyByZWFsbHlcclxuICAgIC8vIGp1c3QgYW4gYXJiaXRyYXJ5IG11ZGRsZSBvZiBhY2NpZGVudGFsIGxvZ2ljLCBvZiBubyB1c2UgdG8gYW55b25lLlxyXG4gICAgbGV0IHQgPSBzdGF0ZS5hICYgc3RhdGUudG1wO1xyXG5cclxuICAgIGxldCBhaCA9IHQgPj4gNDtcclxuICAgIGxldCBhbCA9IHQgJiAxNTtcclxuXHJcbiAgICBzdGF0ZS5uID0gc3RhdGUuYztcclxuICAgIHN0YXRlLmEgPSAodCA+PiAxKSB8IChzdGF0ZS5jIDw8IDcpO1xyXG5cclxuICAgIHN0YXRlLnogPSBzdGF0ZS5hID8gMCA6IDE7XHJcbiAgICBzdGF0ZS52ID0gKCh0IF4gc3RhdGUuYSkgJiA2NCkgPyAxIDogMDtcclxuXHJcbiAgICBpZiAoYWwgKyAoYWwgJiAxKSA+IDUpIHtcclxuICAgICAgc3RhdGUuYSA9IChzdGF0ZS5hICYgMHhmMCkgfCAoKHN0YXRlLmEgKyA2KSAmIDB4Zik7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGUuYyA9ICgoYWggKyAoYWggJiAxKSkgPiA1KSA/IDEgOiAwO1xyXG5cclxuICAgIGlmIChzdGF0ZS5jKSB7XHJcbiAgICAgIHN0YXRlLmEgPSAoc3RhdGUuYSArIDB4NjApICYgMHhmZjtcclxuICAgIH1cclxuICB9XHJcbiAgZWxzZSB7XHJcbiAgICBzdGF0ZS5hID0gb3BfUk9SX2FyZ19yZXQoc3RhdGUuYSAmIHN0YXRlLnRtcCk7XHJcblxyXG4gICAgc3RhdGUuYyA9ICgoc3RhdGUuYSA+PiA2KSAgICAgICAgICAgICAgICAgKSAmIDE7XHJcbiAgICBzdGF0ZS52ID0gKChzdGF0ZS5hID4+IDYpIF4gKHN0YXRlLmEgPj4gNSkpICYgMTtcclxuICB9XHJcbn1cclxuXHJcbi8vIExvYWRzXHJcbi8vIC4uLmNvbW1pdCBhIHBhcmFtZXRlciB0byBhIHJlZ2lzdGVyLlxyXG5cclxuZnVuY3Rpb24gb3BfTERBX3RtcF92b2lkKCkgeyAgICAgICAgICAgc3RhdGUuYSA9IHN0YXRlLnRtcDsgc3RhdGUueiA9IHN0YXRlLmEgPyAwIDogMTsgc3RhdGUubiA9IChzdGF0ZS5hICYgMHg4MCkgPyAxIDogMDsgfVxyXG5mdW5jdGlvbiBvcF9MRFhfdG1wX3ZvaWQoKSB7ICAgICAgICAgICBzdGF0ZS54ID0gc3RhdGUudG1wOyBzdGF0ZS56ID0gc3RhdGUueCA/IDAgOiAxOyBzdGF0ZS5uID0gKHN0YXRlLnggJiAweDgwKSA/IDEgOiAwOyB9XHJcbmZ1bmN0aW9uIG9wX0xEWV90bXBfdm9pZCgpIHsgICAgICAgICAgIHN0YXRlLnkgPSBzdGF0ZS50bXA7IHN0YXRlLnogPSBzdGF0ZS55ID8gMCA6IDE7IHN0YXRlLm4gPSAoc3RhdGUueSAmIDB4ODApID8gMSA6IDA7IH1cclxuZnVuY3Rpb24gb3BfTEFYX3RtcF92b2lkKCkgeyBzdGF0ZS54ID0gc3RhdGUuYSA9IHN0YXRlLnRtcDsgc3RhdGUueiA9IHN0YXRlLmEgPyAwIDogMTsgc3RhdGUubiA9IChzdGF0ZS5hICYgMHg4MCkgPyAxIDogMDsgfSAgLy8gUXVhc2ktb3BcclxuXHJcbmZ1bmN0aW9uIG9wX0xBU190bXBfdm9pZCgpIHtcclxuICAvLyBRdWFzaS1vcDogXCJMQVNcIiAo4oCgNCBhbmQg4oCgMSlcclxuICBzdGF0ZS5hID0gc3RhdGUueCA9IHN0YXRlLnMgPSBzdGF0ZS50bXAgJiBzdGF0ZS5zO1xyXG4gIHN0YXRlLnogPSBzdGF0ZS5hID8gMCA6IDE7XHJcbiAgc3RhdGUubiA9IChzdGF0ZS5hICYgMHg4MCkgPyAxIDogMDtcclxufVxyXG5cclxuLy8gU3RvcmVzXHJcbi8vIC4uLnN1cHBseSBhIHZhbHVlIGZvciB0aGUgYWRkcmVzc2luZyBtb2RlIHRvIGNvbW1pdCB0byBtZW1vcnkuXHJcblxyXG5mdW5jdGlvbiBvcF9TVEFfdm9pZF9yZXQoKSB7IHJldHVybiBzdGF0ZS5hOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5mdW5jdGlvbiBvcF9TVFhfdm9pZF9yZXQoKSB7IHJldHVybiBzdGF0ZS54OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5mdW5jdGlvbiBvcF9TVFlfdm9pZF9yZXQoKSB7IHJldHVybiBzdGF0ZS55OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5mdW5jdGlvbiBvcF9BWFNfdm9pZF9yZXQoKSB7IHJldHVybiBzdGF0ZS5hICYgc3RhdGUueDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSAgLy8gUXVhc2ktb3A6IFwiQVhTXCIgKOKAoDQpLCBcIlNBWFwiICjigKAxKVxyXG5mdW5jdGlvbiBvcF9TSEFfdm9pZF9yZXQoKSB7IHJldHVybiBzdGF0ZS5hICYgc3RhdGUueCAmICgoc3RhdGUuYWRoICsgMSkgJiAweGZmKTsgfSAgLy8gUXVhc2ktb3A6IFwiQVhBXCIgKOKAoDQpLCBcIlNIQVwiICjigKAxKVxyXG5mdW5jdGlvbiBvcF9TSFhfdm9pZF9yZXQoKSB7IHJldHVybiAgICAgICAgICAgc3RhdGUueCAmICgoc3RhdGUuYWRoICsgMSkgJiAweGZmKTsgfSAgLy8gUXVhc2ktb3A6IFwiWEFTXCIgKOKAoDQpLCBcIlNIWFwiICjigKAxKVxyXG5mdW5jdGlvbiBvcF9TSFlfdm9pZF9yZXQoKSB7IHJldHVybiAgICAgICAgICAgc3RhdGUueSAmICgoc3RhdGUuYWRoICsgMSkgJiAweGZmKTsgfSAgLy8gUXVhc2ktb3A6IFwiU0FZXCIgKOKAoDQpLCBcIlNIWVwiICjigKAxKVxyXG5cclxuZnVuY3Rpb24gb3BfU0hTX3ZvaWRfcmV0KCkge1xyXG4gIC8vIFF1YXNpLW9wOiBcIlRBU1wiICjigKA0KSwgXCJTSFNcIiAo4oCgMSlcclxuICBzdGF0ZS5zID0gc3RhdGUuYSAmIHN0YXRlLng7XHJcbiAgcmV0dXJuIHN0YXRlLnMgJiAoKHN0YXRlLmFkaCArIDEpICYgMHhmZik7XHJcbn1cclxuXHJcbi8vIENvbXBhcmVzXHJcbi8vIC4uLmNvbXBhcmUgYSByZWdpc3RlciB0byBhIHBhcmFtZXRlciB2YWx1ZS5cclxuXHJcbmZ1bmN0aW9uIG9wX0NNUF90bXBfdm9pZCgpIHsgY29uc3QgdG1wID0gc3RhdGUuYSAtIHN0YXRlLnRtcDsgc3RhdGUuYyA9ICh0bXAgPj0gMCkgPyAxIDogMDsgc3RhdGUueiA9IHRtcCA/IDAgOiAxOyBzdGF0ZS5uID0gKHRtcCAmIDB4ODApID8gMSA6IDA7IH1cclxuZnVuY3Rpb24gb3BfQ1BYX3RtcF92b2lkKCkgeyBjb25zdCB0bXAgPSBzdGF0ZS54IC0gc3RhdGUudG1wOyBzdGF0ZS5jID0gKHRtcCA+PSAwKSA/IDEgOiAwOyBzdGF0ZS56ID0gdG1wID8gMCA6IDE7IHN0YXRlLm4gPSAodG1wICYgMHg4MCkgPyAxIDogMDsgfVxyXG5mdW5jdGlvbiBvcF9DUFlfdG1wX3ZvaWQoKSB7IGNvbnN0IHRtcCA9IHN0YXRlLnkgLSBzdGF0ZS50bXA7IHN0YXRlLmMgPSAodG1wID49IDApID8gMSA6IDA7IHN0YXRlLnogPSB0bXAgPyAwIDogMTsgc3RhdGUubiA9ICh0bXAgJiAweDgwKSA/IDEgOiAwOyB9XHJcblxyXG4vLyBBZGQtc3VidHJhY3RcclxuLy8gLi4udGFrZSBhIHBhcmFtZXRlciBhbmQgb3BlcmF0ZSBvbiB0aGUgYWNjdW11bGF0b3IuXHJcblxyXG5mdW5jdGlvbiBvcF9BRENfdG1wX3ZvaWQoKSB7IEFEQ19oZWxwZXIoc3RhdGUudG1wKTsgfVxyXG5mdW5jdGlvbiBvcF9TQkNfdG1wX3ZvaWQoKSB7IFNCQ19oZWxwZXIoc3RhdGUudG1wKTsgfVxyXG5cclxuLy8gQnJhbmNoZXNcclxuLy8gLi4uc3VwcGx5IGEgYm9vbGVhbiB0byBpbmZvcm0gdGhlIGFkZHJlc3NpbmcgbW9kZSB3aGV0aGVyIHRvIGJyYW5jaC5cclxuXHJcbmZ1bmN0aW9uIG9wX0JDQ192b2lkX3JldCgpIHsgcmV0dXJuIHN0YXRlLmMgPT09IDA7IH1cclxuZnVuY3Rpb24gb3BfQkNTX3ZvaWRfcmV0KCkgeyByZXR1cm4gc3RhdGUuYyA9PT0gMTsgfVxyXG5mdW5jdGlvbiBvcF9CRVFfdm9pZF9yZXQoKSB7IHJldHVybiBzdGF0ZS56ID09PSAxOyB9XHJcbmZ1bmN0aW9uIG9wX0JNSV92b2lkX3JldCgpIHsgcmV0dXJuIHN0YXRlLm4gPT09IDE7IH1cclxuZnVuY3Rpb24gb3BfQk5FX3ZvaWRfcmV0KCkgeyByZXR1cm4gc3RhdGUueiA9PT0gMDsgfVxyXG5mdW5jdGlvbiBvcF9CUExfdm9pZF9yZXQoKSB7IHJldHVybiBzdGF0ZS5uID09PSAwOyB9XHJcbmZ1bmN0aW9uIG9wX0JWQ192b2lkX3JldCgpIHsgcmV0dXJuIHN0YXRlLnYgPT09IDA7IH1cclxuZnVuY3Rpb24gb3BfQlZTX3ZvaWRfcmV0KCkgeyByZXR1cm4gc3RhdGUudiA9PT0gMTsgfVxyXG5cclxuLy8gUHVzaGVzXHJcbi8vIC4uLnN1cHBseSBhIHZhbHVlIGZvciB0aGUgYWRkcmVzc2luZyBtb2RlIHRvIHB1c2ggb24gdGhlIHN0YWNrLlxyXG5cclxuZnVuY3Rpb24gb3BfUEhBX3ZvaWRfcmV0KCkgeyByZXR1cm4gc3RhdGUuYTsgICAgICB9XHJcbmZ1bmN0aW9uIG9wX1BIUF92b2lkX3JldCgpIHsgcmV0dXJuIHN0YXR1c1RvUCgxKTsgfVxyXG5cclxuLy8gUHVsbHNcclxuLy8gLi4uY29tbWl0IGEgdmFsdWUgdGhhdCB0aGUgYWRkcmVzc2luZyBtb2RlIGhhcyBwb3BwZWQgZnJvbSB0aGUgc3RhY2suXHJcblxyXG5mdW5jdGlvbiBvcF9QTEFfYXJnX3ZvaWQoYXJnKSB7IHN0YXRlLmEgPSBhcmc7IHN0YXRlLnogPSBhcmcgPyAwIDogMTsgc3RhdGUubiA9IChhcmcgJiAweDgwKSA/IDEgOiAwOyB9XHJcbmZ1bmN0aW9uIG9wX1BMUF9hcmdfdm9pZChhcmcpIHsgcFRvU3RhdHVzKGFyZyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBBRENfaGVscGVyKHNyYykge1xyXG4gIC8vIFRPRE86IFRoaXMgcmVhbGx5IHdhbnRzIGNsZWFuaW5nIHVwXHJcblxyXG4gIGlmIChzdGF0ZS5kKSB7XHJcbiAgICBcclxuICAgIHN0YXRlLnogPSAoKHN0YXRlLmEgKyBzcmMgKyBzdGF0ZS5jKSAmIDB4ZmYpID8gMCA6IDE7XHJcbiAgICBsZXQgYWwgPSAoc3RhdGUuYSAmIDB4ZikgKyAoc3JjICYgMHhmKSArIHN0YXRlLmM7XHJcbiAgICBzdGF0ZS5jID0gMDtcclxuICAgIGlmIChhbCA+IDkpIGFsID0gKChhbCAtIDEwKSAmIDB4ZikgKyAweDEwO1xyXG5cclxuICAgIGxldCBzZWFobiA9IChzdGF0ZS5hICYgMHhmMCk7XHJcbiAgICBsZXQgc2ViaG4gPSAoICAgIHNyYyAmIDB4ZjApO1xyXG5cclxuICAgIHNlYWhuID0gKHNlYWhuID49IDB4ODApID8gKC0xICYgfjB4ZmYpIHwgKHNlYWhuICYgMHhmZikgOiBzZWFobjtcclxuICAgIHNlYmhuID0gKHNlYmhuID49IDB4ODApID8gKC0xICYgfjB4ZmYpIHwgKHNlYmhuICYgMHhmZikgOiBzZWJobjtcclxuXHJcbiAgICBsZXQgdGVtcCA9IHNlYWhuICsgc2ViaG4gKyBhbDtcclxuXHJcbiAgICBzdGF0ZS5uID0gKHRlbXAgJiAxMjgpID8gMSA6IDA7XHJcbiAgICBzdGF0ZS52ID0gKCh0ZW1wIDwgLTEyOCkgfHwgKHRlbXAgPiAxMjcpKSA/IDEgOiAwO1xyXG4gICAgc3RhdGUuYSA9IChzdGF0ZS5hICYgMHhmMCkgKyAoc3JjICYgMHhmMCkgKyBhbDtcclxuXHJcbiAgICBpZiAoc3RhdGUuYSA+PSAweGEwKSB7XHJcbiAgICAgIHN0YXRlLmEgLT0gMHhhMDtcclxuICAgICAgc3RhdGUuYyA9IDE7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGUuYSAmPSAweGZmO1xyXG4gIH1cclxuICBlbHNlIHtcclxuICAgIGNvbnN0IGluaXRpYWxBY2MgPSBzdGF0ZS5hO1xyXG4gICAgc3RhdGUuYSArPSBzcmM7XHJcbiAgICBzdGF0ZS5hICs9IHN0YXRlLmM7XHJcbiAgICBcclxuICAgIHN0YXRlLmMgPSAoc3RhdGUuYSAmIDB4MTAwKSA/IDEgOiAwO1xyXG4gICAgc3RhdGUuYSAmPSAweGZmO1xyXG4gICAgc3RhdGUueiA9IHN0YXRlLmEgPyAwIDogMTtcclxuICAgIHN0YXRlLm4gPSAoc3RhdGUuYSAmIDB4ODApID8gMSA6IDA7XHJcbiAgICBcclxuICAgIHN0YXRlLnYgPSB+KGluaXRpYWxBY2MgXiBzcmMpICYgKGluaXRpYWxBY2MgXiBzdGF0ZS5hKSAmIDB4ODA7XHJcbiAgICBzdGF0ZS52ID0gc3RhdGUudiA/IDEgOiAwO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gU0JDX2hlbHBlcihzcmMpIHtcclxuICBpZiAoc3RhdGUuZCkge1xyXG5cclxuICAgIC8vIFRPRE86IFRoaXMgYWxzbyByZWFsbHkgd2FudHMgY2xlYW5pbmcgdXBcclxuXHJcbiAgICBjb25zdCBhaW4gPSBzdGF0ZS5hO1xyXG4gICAgY29uc3QgY2luID0gc3RhdGUuYztcclxuICAgIGNvbnN0IHNpbiA9IHNyYztcclxuXHJcbiAgICAvLyBDTlZaIGZsYWdzIGNvbWUgZnJvbSB0aGUgYmluYXJ5IGltcGxlbWVudGF0aW9uLCBzby4uLlxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIHNyYyA9ICh+c3JjKSAmIDB4ZmY7XHJcbiAgICBzdGF0ZS5kID0gMDtcclxuICAgIEFEQ19oZWxwZXIoc3JjKTtcclxuICAgIHN0YXRlLmQgPSAxO1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIGxldCBhbCA9IChhaW4gJiAweGYpIC0gKHNpbiAmIDB4ZikgKyBjaW4gLSAxO1xyXG4gICAgaWYgKGFsIDwgMCkgYWwgPSAoKGFsIC0gNikgJiAweGYpIC0gMHgxMDtcclxuICAgIHN0YXRlLmEgPSAoYWluICYgMHhmMCkgLSAoc2luICYgMHhmMCkgKyBhbDtcclxuICAgIGlmIChzdGF0ZS5hIDwgMCkgc3RhdGUuYSAtPSAweDYwO1xyXG4gICAgc3RhdGUuYSAmPSAweGZmO1xyXG4gIH1cclxuICBlbHNlIHtcclxuICAgIHNyYyA9ICh+c3JjKSAmIDB4ZmY7XHJcbiAgICBBRENfaGVscGVyKHNyYyk7XHJcbiAgfVxyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gc3RhdHVzVG9QKGIpIHtcclxuICByZXR1cm4gKFxyXG4gICAgKHN0YXRlLm4gPyAoMSA8PCA3KSA6IDApXHJcbiAgfCAoc3RhdGUudiA/ICgxIDw8IDYpIDogMClcclxuICB8ICggICAgICAgICAgKDEgPDwgNSkgICAgKVxyXG4gIHwgKCAgICAgIGIgPyAoMSA8PCA0KSA6IDApXHJcbiAgfCAoc3RhdGUuZCA/ICgxIDw8IDMpIDogMClcclxuICB8IChzdGF0ZS5pID8gKDEgPDwgMikgOiAwKVxyXG4gIHwgKHN0YXRlLnogPyAoMSA8PCAxKSA6IDApXHJcbiAgfCAoc3RhdGUuYyA/ICgxIDw8IDApIDogMClcclxuICApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwVG9TdGF0dXMoYnl0ZSkge1xyXG4gIHN0YXRlLm4gPSAoYnl0ZSA+PiA3KSAmIDE7XHJcbiAgc3RhdGUudiA9IChieXRlID4+IDYpICYgMTtcclxuXHJcbiAgc3RhdGUuZCA9IChieXRlID4+IDMpICYgMTtcclxuICBzdGF0ZS5pID0gKGJ5dGUgPj4gMikgJiAxO1xyXG4gIHN0YXRlLnogPSAoYnl0ZSA+PiAxKSAmIDE7XHJcbiAgc3RhdGUuYyA9IChieXRlID4+IDApICYgMTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2hvd1N0YXRlKCkge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zb2xlLmxvZyhcclxuICAgICAgYFBDPSR7JHh4eHgoc3RhdGUucGMpfWAgK1xyXG4gICAgICBgIEE9JHskeHgoc3RhdGUuYSl9YCArXHJcbiAgICAgIGAgWD0keyR4eChzdGF0ZS54KX1gICtcclxuICAgICAgYCBZPSR7JHh4KHN0YXRlLnkpfWAgK1xyXG4gICAgICBgIFNSPSR7JHh4KHN0YXR1c1RvUCgwKSl9YCArXHJcbiAgICAgIGAgKGAgK1xyXG4gICAgICAgICgoc3RhdGUubikgPyBcIk5cIiA6IFwiX1wiKSArXHJcbiAgICAgICAgKChzdGF0ZS52KSA/IFwiVlwiIDogXCJfXCIpICtcclxuICAgICAgICAoICAgICAgICAgICAgXCItXCIgICAgICApICtcclxuICAgICAgICAoICAgICAgICAgICAgXCItXCIgICAgICApICtcclxuICAgICAgICAoKHN0YXRlLmQpID8gXCJEXCIgOiBcIl9cIikgK1xyXG4gICAgICAgICgoc3RhdGUuaSkgPyBcIklcIiA6IFwiX1wiKSArXHJcbiAgICAgICAgKChzdGF0ZS56KSA/IFwiWlwiIDogXCJfXCIpICtcclxuICAgICAgICAoKHN0YXRlLmMpID8gXCJDXCIgOiBcIl9cIikgK1xyXG4gICAgICBgKWAgK1xyXG4gICAgICBgIFNQPSR7JHh4eHgoc3RhdGUucyl9YCArXHJcbiAgICAgIGAgfCBgICtcclxuICAgICAgYzY0LnJ1bmxvb3AuZ2V0U3RhdGUoKS5jeWNsZSArXHJcbiAgICAgIGAgfCBgICtcclxuICAgICAgZGlzYXNtKGNwdVJlYWQsIHN0YXRlLnBjLCBzdGF0ZS5wYyArIDEpXHJcbiAgICApO1xyXG4gIH1cclxuICBjYXRjaCAoZSkge1xyXG4gICAgY29uc29sZS5sb2coXCJSZWdzIGFyZTpcIiwgc3RhdGUpO1xyXG4gICAgY29uc29sZS5sb2coXCJFcnJvcjpcIiwgZSk7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWdzIGFyZSBjb3JydXB0ZWRcIik7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBhc3NlcnRSZWdzKCkge1xyXG4gIGlmICh0eXBlb2Ygc3RhdGUuYSAhPT0gXCJudW1iZXJcIikgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYWQgc3RhdGUuYTogXCIgKyBzdGF0ZS5hKTtcclxuICBpZiAoKHN0YXRlLmEgPCAwKSB8fCAoc3RhdGUuYSA+IDI1NSkpIHRocm93IG5ldyBFcnJvcihcIkJhZCBzdGF0ZS5hOiBcIiArIHN0YXRlLmEpO1xyXG5cclxuICBpZiAodHlwZW9mIHN0YXRlLnMgIT09IFwibnVtYmVyXCIpICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmFkIHN0YXRlLnM6IFwiICsgc3RhdGUucyk7XHJcbiAgaWYgKChzdGF0ZS5zIDwgMCkgfHwgKHN0YXRlLnMgPiAyNTUpKSB0aHJvdyBuZXcgRXJyb3IoXCJCYWQgc3RhdGUuczogXCIgKyBzdGF0ZS5zKTtcclxuXHJcbiAgaWYgKHR5cGVvZiBzdGF0ZS54ICE9PSBcIm51bWJlclwiKSAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhZCBzdGF0ZS54OiBcIiArIHN0YXRlLngpO1xyXG4gIGlmICgoc3RhdGUueCA8IDApIHx8IChzdGF0ZS54ID4gMjU1KSkgdGhyb3cgbmV3IEVycm9yKFwiQmFkIHN0YXRlLng6IFwiICsgc3RhdGUueCk7XHJcblxyXG4gIGlmICh0eXBlb2Ygc3RhdGUueSAhPT0gXCJudW1iZXJcIikgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYWQgc3RhdGUueTogXCIgKyBzdGF0ZS55KTtcclxuICBpZiAoKHN0YXRlLnkgPCAwKSB8fCAoc3RhdGUueSA+IDI1NSkpIHRocm93IG5ldyBFcnJvcihcIkJhZCBzdGF0ZS55OiBcIiArIHN0YXRlLnkpO1xyXG5cclxuICBpZiAoKHN0YXRlLmMgIT09IDApICYmIChzdGF0ZS5jICE9PSAxKSkgdGhyb3cgbmV3IEVycm9yKFwiQmFkIHN0YXRlLmM6IFwiICsgc3RhdGUuYyk7XHJcbiAgaWYgKChzdGF0ZS52ICE9PSAwKSAmJiAoc3RhdGUudiAhPT0gMSkpIHRocm93IG5ldyBFcnJvcihcIkJhZCBzdGF0ZS52OiBcIiArIHN0YXRlLnYpO1xyXG4gIGlmICgoc3RhdGUubiAhPT0gMCkgJiYgKHN0YXRlLm4gIT09IDEpKSB0aHJvdyBuZXcgRXJyb3IoXCJCYWQgc3RhdGUubjogXCIgKyBzdGF0ZS5uKTtcclxuICBpZiAoKHN0YXRlLnogIT09IDApICYmIChzdGF0ZS56ICE9PSAxKSkgdGhyb3cgbmV3IEVycm9yKFwiQmFkIHN0YXRlLno6IFwiICsgc3RhdGUueik7XHJcbiAgaWYgKChzdGF0ZS5kICE9PSAwKSAmJiAoc3RhdGUuZCAhPT0gMSkpIHRocm93IG5ldyBFcnJvcihcIkJhZCBzdGF0ZS5kOiBcIiArIHN0YXRlLmQpO1xyXG4gIGlmICgoc3RhdGUuaSAhPT0gMCkgJiYgKHN0YXRlLmkgIT09IDEpKSB0aHJvdyBuZXcgRXJyb3IoXCJCYWQgc3RhdGUuaTogXCIgKyBzdGF0ZS5pKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcG9sbEZvckludGVycnVwdHMoKSB7XHJcblxyXG4gIC8vIExvb2sgdG8gc2VlIGlmIGFueSBpbnRlcnJ1cHRzIHNob3VsZCBkaXZlcnQgZXhlY3V0aW9uLiBJZiB0aGV5IHNob3VsZCwgd2VcclxuICAvLyByZWNvcmQgdGhhdCBpbiB0aGUgc3RhdGUgaW4gYSB2YXJpYWJsZSB3aGljaCBtdXN0IGJlIGxvb2tlZCBhdCB3aGVuZXZlclxyXG4gIC8vIGFuIG9wY29kZSBpcyBsb2FkZWQgaW50byB0aGUgaW5zdHJ1Y3Rpb24gcmVnaXN0ZXIgKGJlY2F1c2Ugd2UnZCBiZSBwdXR0aW5nXHJcbiAgLy8gemVybyB0aGVyZSBpbnN0ZWFkKVxyXG5cclxuICBjb25zdCBubWkgPSBnZXRObWkoKTtcclxuXHJcbiAgLy8gTk1JIHRha2VzIHByZWNlZGVuY2Ugb3ZlciBhbiBJUlEsIGFuZCBpZ25vcmVzIHRoZSBJIGZsYWcuIE9yIHNvIOKAoDMgd291bGRcclxuICAvLyBoYXZlIHlvdSBiZWxpZXZlLiBUZXN0IFN1aXRlIDIuMTUudHh0IHN1Z2dlc3RzIHRoZSA2NTEwIF9kb2VzXyB0dXJuIG9uXHJcbiAgLy8gSS1kaXNhYmxlIGZvciB0aGUgTk1JLiBUcnkgaXQgYW5kIHNlZS4uLlxyXG5cclxuICAvLyBOTUkgaXMgZWRnZS10cmlnZ2VyZWQsIHdoZXJlYXMgSVJRIGlzIGxldmVsLXRyaWdnZXJlZFxyXG4gIC8vIFRPRE86IGZvcnVtcyBzdWdnZXN0IHRoYXQgTk1JIGVkZ2UgZGV0ZWN0aW9uIGlzIHBlci1jeWNsZSwgYnV0IHRoaXNcclxuICAvLyBpcyBkb2luZyBpdCBwZXIgcG9sbFxyXG4gIGlmIChubWkgIT09IHN0YXRlLmxhc3RObWkpIHtcclxuICAgIHN0YXRlLmxhc3RObWkgPSBubWk7XHJcbiAgICBpZiAobm1pKSB7XHJcbiAgICAgIC8vIEknbSBoZWFyaW5nIGRpc2FncmVlbWVudCBvbiB3aGV0aGVyIHN0YXRlLmkgaW5oaWJpdHMgTk1JcyBvbiBhIDY1MTAuXHJcbiAgICAgIC8vIE5lZWQgdG8ganVzdCB0cnkgaXQgb3V0IG9uIHJlYWwgaGFyZHdhcmUuXHJcbiAgICAgIC8vIEZyYW50aWMgRnJlZGRpZSBnZXRzIHN0dWNrIHVubGVzcyBpdCdzIGluaGliaXRlZC4gQnV0IHRoZW4gaWZcclxuICAgICAgLy8gYWxsb3dlZCB0aHJvdWdoIGl0IGp1c3QgZ2V0cyBzdHVjayBpbiBnYW1lcGxheS5cclxuICAgICAgLy8gaWYgKCFzdGF0ZS5pKSB7XHJcbiAgICAgICAgc3RhdGUucGVuZGluZ0ludCA9IDI7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICAvLyB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBpcnEgPSBnZXRJcnEoKTtcclxuXHJcbiAgaWYgKGlycSkge1xyXG4gICAgaWYgKCFzdGF0ZS5pKSB7XHJcbiAgICAgIHN0YXRlLnBlbmRpbmdJbnQgPSAxO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gdGljaygpIHtcclxuICAvLyBXZSBzaG91bGQgcHJvYmFibHkgb25seSBkbyB0aGlzIGluIGRldiBidWlsZHNcclxuICBhc3NlcnRSZWdzKCk7XHJcblxyXG4gIC8vIE1ha2UgYSBjb3B5IG9mIHRoZSBzdGF0ZSBtYWNoaW5lIGZ1bmN0aW9ucyBzbyB0aGF0IGlmIG9uZSBjaGFuZ2VzIGFub3RoZXIsXHJcbiAgLy8gaXQgd29uJ3QgdGFrZSBlZmZlY3QgdW50aWwgdGhlIG5leHQgY3ljbGUuXHJcbiAgY29uc3QgeyBmZFRpY2ssIGFtVGljayB9ID0gc3RhdGU7XHJcblxyXG4gIGlmIChmZFRpY2spIGZkVGljaygpO1xyXG4gIGlmIChhbVRpY2spIGFtVGljaygpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXJpYWxpemUoKSB7XHJcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcclxuICAgIC4uLnN0YXRlLFxyXG4gICAgYW1UaWNrOiBmdW5jdGlvblRvUmVmZXJlbmNlKHN0YXRlLmFtVGljayksXHJcbiAgICBmZFRpY2s6IGZ1bmN0aW9uVG9SZWZlcmVuY2Uoc3RhdGUuZmRUaWNrKSxcclxuICAgIG9wRm46ICAgZnVuY3Rpb25Ub1JlZmVyZW5jZShzdGF0ZS5vcEZuKSxcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVzZXJpYWxpemUoanNvbikge1xyXG4gIHN0YXRlID0gSlNPTi5wYXJzZShqc29uKTtcclxuXHJcbiAgc3RhdGUuYW1UaWNrID0gcmVmZXJlbmNlVG9GdW5jdGlvbihzdGF0ZS5hbVRpY2spO1xyXG4gIHN0YXRlLmZkVGljayA9IHJlZmVyZW5jZVRvRnVuY3Rpb24oc3RhdGUuZmRUaWNrKTtcclxuICBzdGF0ZS5vcEZuICAgPSByZWZlcmVuY2VUb0Z1bmN0aW9uKHN0YXRlLm9wRm4pO1xyXG59XHJcblxyXG5hZGRUb1NlcmlhbGl6ZXJSZWdpc3RyeSh7XHJcbiAgZmRfZmV0Y2hfVDAsXHJcbiAgZmRfZGVjb2RlX1QxLFxyXG4gIGFtX3NpbmdsZUJ5dGVfaW1wX1QxLFxyXG4gIGFtX3NpbmdsZUJ5dGVfaW1wX1QyLFxyXG4gIGFtX3NpbmdsZUJ5dGVfYWNjX1QxLFxyXG4gIGFtX3NpbmdsZUJ5dGVfYWNjX1QyLFxyXG4gIGFtX2llb21kX2ltbV9UMSxcclxuICBhbV9pZW9tZF9pbW1fVDIsXHJcbiAgYW1faWVvbWRfenBfVDEsXHJcbiAgYW1faWVvbWRfenBfVDIsXHJcbiAgYW1faWVvbWRfenBfVDMsXHJcbiAgYW1faWVvbWRfYWJzX1QxLFxyXG4gIGFtX2llb21kX2Fic19UMixcclxuICBhbV9pZW9tZF9hYnNfVDMsXHJcbiAgYW1faWVvbWRfYWJzX1Q0LFxyXG4gIGFtX2llb21kX2lueF9UMSxcclxuICBhbV9pZW9tZF9pbnhfVDIsXHJcbiAgYW1faWVvbWRfaW54X1QzLFxyXG4gIGFtX2llb21kX2lueF9UNCxcclxuICBhbV9pZW9tZF9pbnhfVDUsXHJcbiAgYW1faWVvbWRfaW54X1Q2LFxyXG4gIGFtX2llb21kX2FieF9UMSxcclxuICBhbV9pZW9tZF9hYnhfVDIsXHJcbiAgYW1faWVvbWRfYWJ5X1QxLFxyXG4gIGFtX2llb21kX2FieV9UMixcclxuICBhbV9pZW9tZF9hYnh5X1QzLFxyXG4gIGFtX2llb21kX2FieHlfVDQsXHJcbiAgYW1faWVvbWRfYWJ4eV9UNSxcclxuICBhbV9pZW9tZF96cHhfVDEsXHJcbiAgYW1faWVvbWRfenB4X1QyLFxyXG4gIGFtX2llb21kX3pweV9UMSxcclxuICBhbV9pZW9tZF96cHlfVDIsXHJcbiAgYW1faWVvbWRfenB4eV9UMyxcclxuICBhbV9pZW9tZF96cHh5X1Q0LFxyXG4gIGFtX2llb21kX2lueV9UMSxcclxuICBhbV9pZW9tZF9pbnlfVDIsXHJcbiAgYW1faWVvbWRfaW55X1QzLFxyXG4gIGFtX2llb21kX2lueV9UNCxcclxuICBhbV9pZW9tZF9pbnlfVDUsXHJcbiAgYW1faWVvbWRfaW55X1Q2LFxyXG4gIGFtX3N0b3JlX3pwX1QxLFxyXG4gIGFtX3N0b3JlX3pwX1QyLFxyXG4gIGFtX3N0b3JlX2Fic19UMSxcclxuICBhbV9zdG9yZV9hYnNfVDIsXHJcbiAgYW1fc3RvcmVfYWJzX1QzLFxyXG4gIGFtX3N0b3JlX2lueF9UMSxcclxuICBhbV9zdG9yZV9pbnhfVDIsXHJcbiAgYW1fc3RvcmVfaW54X1QzLFxyXG4gIGFtX3N0b3JlX2lueF9UNCxcclxuICBhbV9zdG9yZV9pbnhfVDUsXHJcbiAgYW1fc3RvcmVfYWJ4X1QxLFxyXG4gIGFtX3N0b3JlX2FieF9UMixcclxuICBhbV9zdG9yZV9hYnlfVDEsXHJcbiAgYW1fc3RvcmVfYWJ5X1QyLFxyXG4gIGFtX3N0b3JlX2FieHlfVDMsXHJcbiAgYW1fc3RvcmVfYWJ4eV9UNCxcclxuICBhbV9zdG9yZV96cHhfVDEsXHJcbiAgYW1fc3RvcmVfenB4X1QyLFxyXG4gIGFtX3N0b3JlX3pweV9UMSxcclxuICBhbV9zdG9yZV96cHlfVDIsXHJcbiAgYW1fc3RvcmVfenB4eV9UMyxcclxuICBhbV9zdG9yZV9pbnlfVDEsXHJcbiAgYW1fc3RvcmVfaW55X1QyLFxyXG4gIGFtX3N0b3JlX2lueV9UMyxcclxuICBhbV9zdG9yZV9pbnlfVDQsXHJcbiAgYW1fc3RvcmVfaW55X1Q1LFxyXG4gIGFtX3Jtd196cF9UMSxcclxuICBhbV9ybXdfenBfVDIsXHJcbiAgYW1fcm13X3pwX1QzLFxyXG4gIGFtX3Jtd196cF9UNCxcclxuICBhbV9ybXdfYWJzX1QxLFxyXG4gIGFtX3Jtd19hYnNfVDIsXHJcbiAgYW1fcm13X2Fic19UMyxcclxuICBhbV9ybXdfYWJzX1Q0LFxyXG4gIGFtX3Jtd19hYnNfVDUsXHJcbiAgYW1fcm13X3pweF9UMSxcclxuICBhbV9ybXdfenB4X1QyLFxyXG4gIGFtX3Jtd196cHhfVDMsXHJcbiAgYW1fcm13X3pweF9UNCxcclxuICBhbV9ybXdfenB4X1Q1LFxyXG4gIGFtX3Jtd19hYnhfVDEsXHJcbiAgYW1fcm13X2FieF9UMixcclxuICBhbV9ybXdfYWJ5X1QxLFxyXG4gIGFtX3Jtd19hYnlfVDIsXHJcbiAgYW1fcm13X2FieHlfVDMsXHJcbiAgYW1fcm13X2FieHlfVDQsXHJcbiAgYW1fcm13X2FieHlfVDUsXHJcbiAgYW1fcm13X2FieHlfVDYsXHJcbiAgYW1fcm13X2lueF9UMSxcclxuICBhbV9ybXdfaW54X1QyLFxyXG4gIGFtX3Jtd19pbnhfVDMsXHJcbiAgYW1fcm13X2lueF9UNCxcclxuICBhbV9ybXdfaW54X1Q1LFxyXG4gIGFtX3Jtd19pbnhfVDYsXHJcbiAgYW1fcm13X2lueF9UNyxcclxuICBhbV9ybXdfaW55X1QxLFxyXG4gIGFtX3Jtd19pbnlfVDIsXHJcbiAgYW1fcm13X2lueV9UMyxcclxuICBhbV9ybXdfaW55X1Q0LFxyXG4gIGFtX3Jtd19pbnlfVDUsXHJcbiAgYW1fcm13X2lueV9UNixcclxuICBhbV9ybXdfaW55X1Q3LFxyXG4gIGFtX3B1c2hfVDEsXHJcbiAgYW1fcHVzaF9UMixcclxuICBhbV9wdWxsX1QxLFxyXG4gIGFtX3B1bGxfVDIsXHJcbiAgYW1fcHVsbF9UMyxcclxuICBhbV9wdWxsX1Q0LFxyXG4gIGFtX2pzcl9UMSxcclxuICBhbV9qc3JfVDIsXHJcbiAgYW1fanNyX1QzLFxyXG4gIGFtX2pzcl9UNCxcclxuICBhbV9qc3JfVDUsXHJcbiAgYW1fanNyX1Q2LFxyXG4gIGFtX2ludGVycnVwdF9UMSxcclxuICBhbV9pbnRlcnJ1cHRfVDIsXHJcbiAgYW1faW50ZXJydXB0X1QzLFxyXG4gIGFtX2ludGVycnVwdF9UNCxcclxuICBhbV9pbnRlcnJ1cHRfVDUsXHJcbiAgYW1faW50ZXJydXB0X1Q2LFxyXG4gIGFtX3J0aV9UMSxcclxuICBhbV9ydGlfVDIsXHJcbiAgYW1fcnRpX1QzLFxyXG4gIGFtX3J0aV9UNCxcclxuICBhbV9ydGlfVDUsXHJcbiAgYW1fam1wX2Fic19UMSxcclxuICBhbV9qbXBfYWJzX1QyLFxyXG4gIGFtX2ptcF9pbmRfVDEsXHJcbiAgYW1fam1wX2luZF9UMixcclxuICBhbV9qbXBfaW5kX1QzLFxyXG4gIGFtX2ptcF9pbmRfVDQsXHJcbiAgYW1fcnRzX1QxLFxyXG4gIGFtX3J0c19UMixcclxuICBhbV9ydHNfVDMsXHJcbiAgYW1fcnRzX1Q0LFxyXG4gIGFtX3J0c19UNSxcclxuICBhbV9yZWxfVDEsXHJcbiAgYW1fcmVsX1QyLFxyXG4gIGFtX3JlbF9UMyxcclxuICBhbV9oYWx0X1QxLFxyXG4gIG9wX0JSS192b2lkX3ZvaWQsXHJcbiAgb3BfSlNSX3ZvaWRfdm9pZCxcclxuICBvcF9SVElfdm9pZF92b2lkLFxyXG4gIG9wX0pNUF92b2lkX3ZvaWQsXHJcbiAgb3BfUlRTX3ZvaWRfdm9pZCxcclxuICBvcF9ITFRfdm9pZF92b2lkLFxyXG4gIG9wX05PUF92b2lkX3ZvaWQsXHJcbiAgb3BfQ0xDX3ZvaWRfdm9pZCxcclxuICBvcF9DTERfdm9pZF92b2lkLFxyXG4gIG9wX0NMSV92b2lkX3ZvaWQsXHJcbiAgb3BfQ0xWX3ZvaWRfdm9pZCxcclxuICBvcF9TRUNfdm9pZF92b2lkLFxyXG4gIG9wX1NFRF92b2lkX3ZvaWQsXHJcbiAgb3BfU0VJX3ZvaWRfdm9pZCxcclxuICBvcF9UQVhfdm9pZF92b2lkLFxyXG4gIG9wX1RBWV92b2lkX3ZvaWQsXHJcbiAgb3BfVFhBX3ZvaWRfdm9pZCxcclxuICBvcF9UWUFfdm9pZF92b2lkLFxyXG4gIG9wX1RTWF92b2lkX3ZvaWQsXHJcbiAgb3BfVFhTX3ZvaWRfdm9pZCxcclxuICBvcF9ERVhfdm9pZF92b2lkLFxyXG4gIG9wX0RFWV92b2lkX3ZvaWQsXHJcbiAgb3BfSU5YX3ZvaWRfdm9pZCxcclxuICBvcF9JTllfdm9pZF92b2lkLFxyXG4gIG9wX0FTTF9hcmdfcmV0LFxyXG4gIG9wX0xTUl9hcmdfcmV0LFxyXG4gIG9wX1JPTF9hcmdfcmV0LFxyXG4gIG9wX1JPUl9hcmdfcmV0LFxyXG4gIG9wX0xTRV9hcmdfcmV0LFxyXG4gIG9wX0RDTV9hcmdfcmV0LFxyXG4gIG9wX0FTT19hcmdfcmV0LFxyXG4gIG9wX1JMQV9hcmdfcmV0LFxyXG4gIG9wX1JSQV9hcmdfcmV0LFxyXG4gIG9wX0lOU19hcmdfcmV0LFxyXG4gIG9wX0lOQ19hcmdfcmV0LFxyXG4gIG9wX0RFQ19hcmdfcmV0LFxyXG4gIG9wX05PUF9hcmdfcmV0LFxyXG4gIG9wX0VPUl90bXBfdm9pZCxcclxuICBvcF9PUkFfdG1wX3ZvaWQsXHJcbiAgb3BfQU5EX3RtcF92b2lkLFxyXG4gIG9wX0FOQ190bXBfdm9pZCxcclxuICBvcF9CSVRfdG1wX3ZvaWQsXHJcbiAgb3BfQU5FX3RtcF92b2lkLFxyXG4gIG9wX0xYQV90bXBfdm9pZCxcclxuICBvcF9TQlhfdG1wX3ZvaWQsXHJcbiAgb3BfQUxSX3RtcF92b2lkLFxyXG4gIG9wX0FSUl90bXBfdm9pZCxcclxuICBvcF9MREFfdG1wX3ZvaWQsXHJcbiAgb3BfTERYX3RtcF92b2lkLFxyXG4gIG9wX0xEWV90bXBfdm9pZCxcclxuICBvcF9MQVhfdG1wX3ZvaWQsXHJcbiAgb3BfTEFTX3RtcF92b2lkLFxyXG4gIG9wX1NUQV92b2lkX3JldCxcclxuICBvcF9TVFhfdm9pZF9yZXQsXHJcbiAgb3BfU1RZX3ZvaWRfcmV0LFxyXG4gIG9wX0FYU192b2lkX3JldCxcclxuICBvcF9TSEFfdm9pZF9yZXQsXHJcbiAgb3BfU0hYX3ZvaWRfcmV0LFxyXG4gIG9wX1NIWV92b2lkX3JldCxcclxuICBvcF9TSFNfdm9pZF9yZXQsXHJcbiAgb3BfQ01QX3RtcF92b2lkLFxyXG4gIG9wX0NQWF90bXBfdm9pZCxcclxuICBvcF9DUFlfdG1wX3ZvaWQsXHJcbiAgb3BfQURDX3RtcF92b2lkLFxyXG4gIG9wX1NCQ190bXBfdm9pZCxcclxuICBvcF9CQ0Nfdm9pZF9yZXQsXHJcbiAgb3BfQkNTX3ZvaWRfcmV0LFxyXG4gIG9wX0JFUV92b2lkX3JldCxcclxuICBvcF9CTUlfdm9pZF9yZXQsXHJcbiAgb3BfQk5FX3ZvaWRfcmV0LFxyXG4gIG9wX0JQTF92b2lkX3JldCxcclxuICBvcF9CVkNfdm9pZF9yZXQsXHJcbiAgb3BfQlZTX3ZvaWRfcmV0LFxyXG4gIG9wX1BIQV92b2lkX3JldCxcclxuICBvcF9QSFBfdm9pZF9yZXQsXHJcbiAgb3BfUExBX2FyZ192b2lkLFxyXG4gIG9wX1BMUF9hcmdfdm9pZCxcclxufSk7XHJcbiIsIi8qXHJcbiAgIHJhbTogZW11bGF0ZXMgNjRLaUIgb2YgYnl0ZS1hZGRyZXNzZWQgUkFNXHJcbiovXHJcblxyXG5pbXBvcnQgeyBiYXNlNjRFbmNvZGUsIGJhc2U2NERlY29kZSB9IGZyb20gXCIuLi90b29scy9iYXNlNjRcIjtcclxuXHJcbi8vIGJvdW5kIGJ5IGF0dGFjaFxyXG5sZXQgYzY0O1xyXG5cclxuY29uc3Qgc3RhdGUgPSBuZXcgVWludDhBcnJheSg2NTUzNik7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYXR0YWNoKG5hc2NlbnRDNjQpIHtcclxuICBjNjQgPSBuYXNjZW50QzY0O1xyXG5cclxuICBuYXNjZW50QzY0LnJhbSA9IHtcclxuICAgIC8vIENvbnRyb2xcclxuICAgIHJlc2V0LFxyXG4gICAgc2VyaWFsaXplLFxyXG4gICAgZGVzZXJpYWxpemUsXHJcbiAgICAvLyBBY2Nlc3NvcnNcclxuICAgIHJlYWRSYW0sXHJcbiAgICB3cml0ZVJhbSxcclxuICAgIHZpY1JlYWRSYW0sXHJcbiAgfTtcclxuXHJcbiAgcmVzZXQoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVzZXQoKSB7XHJcbiAgLy8gSW5pdGlhbGl6ZSBSQU0gd2l0aCAweGRlYWRiZWVmLiBOb3QgdG8gaGVscCBvdXIgb3duIGRlYnVnZ2luZywgYnV0IHRvXHJcbiAgLy8gc2ltdWxhdGUgc3RhdGljIG5vaXNlLiBTb21lIGdhbWVzLCBsaWtlIERvbWluYXRvcidzIHRhcGUgbG9hZGVyLCBsb29rIGZvclxyXG4gIC8vIGEgY29uc3RhbnQgdmFsdWUgaW4gbWVtb3J5IGFzIGEgc2lnbiB0aGF0IHlvdSdyZSB0cnlpbmcgdG8gaGFjayB0aGVtLCBhbmRcclxuICAvLyB3aWxsIGNyYXNoIGlmIHRoZXkgZGV0ZWN0IG9uZS5cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IDY1NTM2OyBpICs9IDQpIHtcclxuICAgIHN0YXRlW2kgKyAwXSA9IDB4ZGU7XHJcbiAgICBzdGF0ZVtpICsgMV0gPSAweGFkO1xyXG4gICAgc3RhdGVbaSArIDJdID0gMHhiZTtcclxuICAgIHN0YXRlW2kgKyAzXSA9IDB4ZWY7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzZXJpYWxpemUoKSB7XHJcbiAgcmV0dXJuIGJhc2U2NEVuY29kZShzdGF0ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlc2VyaWFsaXplKGJhc2U2NCkge1xyXG4gIGNvbnN0IGJ5dGVzID0gYmFzZTY0RGVjb2RlKGJhc2U2NCk7XHJcbiAgZm9yIChsZXQgaSBpbiBieXRlcykge1xyXG4gICAgc3RhdGVbaV0gPSBieXRlc1tpXTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWRSYW0oYWRkcikge1xyXG4gIGlmIChjNjQuaG9va3Mub25SYW1SZWFkKSBjNjQuaG9va3Mub25SYW1SZWFkKGFkZHIpO1xyXG4gIHJldHVybiBzdGF0ZVthZGRyXTtcclxufVxyXG5cclxuZnVuY3Rpb24gdmljUmVhZFJhbShhZGRyKSB7XHJcbiAgaWYgKGM2NC5ob29rcy5vblZpY1JlYWQpIGM2NC5ob29rcy5vblZpY1JlYWQoYWRkcik7XHJcbiAgcmV0dXJuIHN0YXRlW2FkZHJdO1xyXG59XHJcblxyXG5mdW5jdGlvbiB3cml0ZVJhbShhZGRyLCBieXRlKSB7XHJcbiAgaWYgKGM2NC5ob29rcy5vblJhbVdyaXRlKSBjNjQuaG9va3Mub25SYW1Xcml0ZShhZGRyLCBieXRlKTtcclxuICBzdGF0ZVthZGRyXSA9IGJ5dGU7XHJcbn1cclxuIiwiLypcclxuICAgQmFzaWMgKCRhMDAwIOKAkyAkYmZmZilcclxuXHJcbiAgIFRoZSBzb3VyY2UgYmVsb3cgYXNzZW1ibGVzIGludG8gYSBieXRlc3RyZWFtIGZ1bGx5IGNvbXBhdGlibGUgd2l0aCB0aGUgQzY0J3NcclxuICAgQmFzaWMgUk9NLiBJdCdzIGFkYXB0ZWQgZnJvbSBNaWNoYWVsIFN0ZWlsJ3MgYWRhcHRhdGlvbijigKAxKSBvZiBMZWUgRGF2aXNvbidzXHJcbiAgIGludmVzdGlnYXRpb24gaW50byB0aGUgb3JpZ2luYWwgZmlybXdhcmUuIEFsbCBjb21tZW50cyBiZWxvdyBhcmUgTGVlJ3MuXHJcblxyXG4gICBUaGUgbGFiZWxzIGFyZSBpbmZvcm1lZCBieSBQcm9qZWN0NjQncyBjb2xsZWN0aW9uIG9mIG1lbW9yeSBtYXBzKOKAoDIpIGFuZFxyXG4gICB0aG9zZSB1c2VkIGluIE1hcHBpbmcgVGhlIENvbW1vZG9yZSA2NCjigKAzKS4gV2hlcmUgc291cmNlcyBkaXNhZ3JlZSBvbiBuYW1lcy9cclxuICAgbG9jYXRpb25zLCBJJ3ZlIGJhc2VkIG15IGNob2ljZXMgb24gd2hpY2ggaGFkIHRoZSBtb3N0IGNvbnNlbnN1cyBhbmQgd2hpY2hcclxuICAgYmVzdCBjb3JyZXNwb25kcyB0byB0aGUgaW5zdHJ1Y3Rpb25zIG9yIGRhdGEgdG8gd2hpY2ggdGhleSByZWxhdGUuXHJcblxyXG4gICDigKAxIGh0dHBzOi8vZ2l0aHViLmNvbS9taXN0NjQvYzY0ZGlzYXNtXHJcbiAgIOKAoDIgaHR0cHM6Ly9naXRodWIuY29tL1Byb2plY3QtNjQvcmVsb2FkZWQvYmxvYi9tYXN0ZXIvYzY0LzY0TUFQMTEuVFhUXHJcbiAgIOKAoDMgaHR0cHM6Ly9naXRodWIuY29tL1Byb2plY3QtNjQvcmVsb2FkZWQvYmxvYi9tYXN0ZXIvYzY0L21hcGM2NC9NQVBDNjQxMi5UWFRcclxuXHJcbiAgIElmIHlvdSB3YW50IHRvIHN1YnN0aXR1dGUgeW91ciBvd24gUk9NLCBqdXN0IGV4cG9ydCBhIGJ5dGUgYXJyYXkgaW5zdGVhZDpcclxuICAgICAgIGV4cG9ydCBkZWZhdWx0IFsgMHguLiwgLi4uIF07XHJcblxyXG4gICBVbmxpa2UgdGhlIHJlc3Qgb2YgdGhlIFZpY2lpb3VzIHByb2plY3QsIHdoaWNoIHdhcyBhdXRob3JlZCBmcm9tIHNjcmF0Y2ggYW5kXHJcbiAgIGVudGVyZWQgaW50byB0aGUgcHVibGljIGRvbWFpbiwgdGhlIHNvdXJjZSBiZWxvdyBpcyBkZXJpdmVkIGZyb20gd29ya3MgYnlcclxuICAgbXVsdGlwbGUgb3RoZXIgYXV0aG9ycyBhbmQgSSBtYWtlIG5vIHJlcHJlc2VudGF0aW9ucyBhcyB0byBpdHMgb3duZXJzaGlwIG9yXHJcbiAgIHRlcm1zIG9mIHVzZS5cclxuXHJcbiAgIE5vdGUgdGhhdCB0aGUgQmFzaWMgaW50ZXJwcmV0ZXIgc3BpbGxzIG92ZXIgaW50byB0aGUgS2VybmFsIFJPTS5cclxuKi9cclxuXHJcbmltcG9ydCB7IGFzc2VtYmxlIH0gZnJvbSBcIi4uLy4uL3Rvb2xzL2Fzc2VtYmxlclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgYXNzZW1ibGUoXHJcbiAgMHhhMDAwLFxyXG4gICh7XHJcbiAgICBOT1AsIExEQSwgTERYLCBMRFksIFNUQSwgU1RYLCBTVFksIENMQywgQ0xELCBDTEksIENMViwgU0VDLCBTRUQsIFNFSSxcclxuICAgIFRBWCwgVEFZLCBUU1gsIFRYQSwgVFhTLCBUWUEsIENNUCwgQ1BYLCBDUFksIEJDUywgQkNDLCBCRVEsIEJORSwgQk1JLFxyXG4gICAgQlBMLCBCVlMsIEJWQywgQklULCBKU1IsIFJUUywgUlRJLCBCUkssIEpNUCwgSU5DLCBERUMsIERFWCwgREVZLCBJTlgsXHJcbiAgICBJTlksIEFEQywgU0JDLCBBTkQsIEVPUiwgT1JBLCBBU0wsIFJPTCwgTFNSLCBST1IsIFBIQSwgUEhQLCBQTEEsIFBMUCxcclxuICAgIF9cclxuICB9KSA9PiB7XHJcbiAgICAgICAgICAgIC8vIEV4dGVybmFsIGxhYmVscyAoUkFNKVxyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDAwMiwgXCJfMDAwMlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwMDMsIFwiYWRyYXkxKzBfMDAwM1wiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwMDQsIFwiYWRyYXkxKzFfMDAwNFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwMDcsIFwiY2hhcmFjXzAwMDdcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDA4LCBcImVuZGNocl8wMDA4XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDAwOSwgXCJ0cm1wb3NfMDAwOVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwMGIsIFwiY291bnRfMDAwYlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwMGMsIFwiZGltZmxnXzAwMGNcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDBkLCBcInZhbHR5cF8wMDBkXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDAwZSwgXCJpbnRmbGdfMDAwZVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwMGYsIFwiZ2FyYmZsXzAwMGZcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDEwLCBcInN1YmZsZ18wMDEwXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDAxMSwgXCJpbnBmbGdfMDAxMVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwMTIsIFwidGFuc2duXzAwMTJcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDEzLCBcImNoYW5ubF8wMDEzXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDAxNCwgXCJsaW5udW0rMF8wMDE0XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDAxNSwgXCJsaW5udW0rMV8wMDE1XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDAxNiwgXCJ0ZW1wcHRfMDAxNlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwMTcsIFwibGFzdHB0KzBfMDAxN1wiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwMTgsIFwibGFzdHB0KzFfMDAxOFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwMjIsIFwiaW5kZXgrMF8wMDIyXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDAyMywgXCJpbmRleCsxXzAwMjNcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDI0LCBcImluZGV4KzJfMDAyNFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwMjUsIFwiaW5kZXgrM18wMDI1XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDAyNiwgXCJyZXNobyswXzAwMjZcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDI3LCBcInJlc2hvKzFfMDAyN1wiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwMjgsIFwicmVzaG8rMl8wMDI4XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDAyOSwgXCJyZXNobyszXzAwMjlcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDJiLCBcInR4dHRhYiswXzAwMmJcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDJjLCBcInR4dHRhYisxXzAwMmNcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDJkLCBcInZhcnRhYiswXzAwMmRcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDJlLCBcInZhcnRhYisxXzAwMmVcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDJmLCBcImFyeXRhYiswXzAwMmZcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDMwLCBcImFyeXRhYisxXzAwMzBcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDMxLCBcInN0cmVuZCswXzAwMzFcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDMyLCBcInN0cmVuZCsxXzAwMzJcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDMzLCBcImZyZXRvcCswXzAwMzNcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDM0LCBcImZyZXRvcCsxXzAwMzRcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDM1LCBcImZyZXNwYyswXzAwMzVcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDM2LCBcImZyZXNwYysxXzAwMzZcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDM3LCBcIm1lbXNpeiswXzAwMzdcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDM4LCBcIm1lbXNpeisxXzAwMzhcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDM5LCBcImN1cmxpbiswXzAwMzlcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDNhLCBcImN1cmxpbisxXzAwM2FcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDNiLCBcIm9sZGxpbiswXzAwM2JcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDNjLCBcIm9sZGxpbisxXzAwM2NcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDNkLCBcIm9sZHR4dCswXzAwM2RcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDNlLCBcIm9sZHR4dCsxXzAwM2VcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDNmLCBcImRhdGxpbiswXzAwM2ZcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDQwLCBcImRhdGxpbisxXzAwNDBcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDQxLCBcImRhdHB0ciswXzAwNDFcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDQyLCBcImRhdHB0cisxXzAwNDJcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDQzLCBcImlucHB0ciswXzAwNDNcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDQ0LCBcImlucHB0cisxXzAwNDRcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDQ1LCBcInZhcm5hbSswXzAwNDVcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDQ2LCBcInZhcm5hbSsxXzAwNDZcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDQ3LCBcInZhcnBudCswXzAwNDdcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDQ4LCBcInZhcnBudCsxXzAwNDhcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDQ5LCBcImZvcnBudCswXzAwNDlcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDRhLCBcImZvcnBudCsxXzAwNGFcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDRiLCBcIm9wcHRyKzBfMDA0YlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwNGMsIFwib3BwdHIrMV8wMDRjXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDA0ZCwgXCJvcG1hc2tfMDA0ZFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwNGUsIFwiZGVmcG50KzBfMDA0ZVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwNGYsIFwiZGVmcG50KzFfMDA0ZlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwNTAsIFwiZHNjcG50KzBfMDA1MFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwNTEsIFwiZHNjcG50KzFfMDA1MVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwNTMsIFwiZm91cjZfMDA1M1wiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwNTQsIFwiam1wZXIrMF8wMDU0XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDA1NSwgXCJqbXBlcisxXzAwNTVcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDU2LCBcImptcGVyKzJfMDA1NlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwNTgsIFwidGVtcGYxKzFfMDA1OFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwNTksIFwidGVtcGYxKzJfMDA1OVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwNWEsIFwidGVtcGYxKzNfMDA1YVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwNWIsIFwidGVtcGYxKzRfMDA1YlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwNWQsIFwidGVtcGYyKzFfMDA1ZFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwNWUsIFwidGVtcGYyKzJfMDA1ZVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwNWYsIFwidGVtcGYyKzNfMDA1ZlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwNjAsIFwidGVtcGYyKzRfMDA2MFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwNjEsIFwiZmFjZXhwXzAwNjFcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDYyLCBcImZhY2hvKzBfMDA2MlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwNjMsIFwiZmFjaG8rMV8wMDYzXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDA2NCwgXCJmYWNobysyXzAwNjRcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDY1LCBcImZhY2hvKzNfMDA2NVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwNjYsIFwiZmFjc2duXzAwNjZcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDY3LCBcInNnbmZsZ18wMDY3XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDA2OCwgXCJiaXRzXzAwNjhcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDY5LCBcImFyZ2V4cF8wMDY5XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDA2YSwgXCJhcmdobyswXzAwNmFcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDZiLCBcImFyZ2hvKzFfMDA2YlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwNmMsIFwiYXJnaG8rMl8wMDZjXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDA2ZCwgXCJhcmdobyszXzAwNmRcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDZlLCBcImFyZ3Nnbl8wMDZlXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDA2ZiwgXCJhcmlzZ25fMDA2ZlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwNzAsIFwiZmFjb3ZfMDA3MFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwNzEsIFwiZmJ1ZnB0KzBfMDA3MVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwNzIsIFwiZmJ1ZnB0KzFfMDA3MlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwNzMsIFwiY2hyZ2V0KzBfMDA3M1wiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwNzksIFwiY2hyZ290XzAwNzlcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDdhLCBcInR4dHB0ciswXzAwN2FcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDdiLCBcInR4dHB0cisxXzAwN2JcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDgwLCBcImNocmdldCsxM18wMDgwXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDBmZiwgXCJiYXN6cHRfMDBmZlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAxMDAsIFwiYmFkKzBfMDEwMFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAxMDEsIFwiYmFkKzFfMDEwMVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAxMDIsIFwiYmFkKzJfMDEwMlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAxMDMsIFwiYmFkKzNfMDEwM1wiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAxMDQsIFwiYmFkKzRfMDEwNFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAxMDksIFwiYmFkKzlfMDEwOVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAxMGYsIFwiYmFkKzE1XzAxMGZcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMTEwLCBcImJhZCsxNl8wMTEwXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDExMSwgXCJiYWQrMTdfMDExMVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAxMTIsIFwiYmFkKzE4XzAxMTJcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMWZiLCBcImJzdGFjaysxODhfMDFmYlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAxZmMsIFwiYnN0YWNrKzE4OV8wMWZjXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDFmZCwgXCJic3RhY2srMTkwXzAxZmRcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMWZlLCBcImJzdGFjaysxOTFfMDFmZVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAxZmYsIFwiYnN0YWNrKzE5Ml8wMWZmXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDIwMCwgXCJidWYrMF8wMjAwXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDIwMSwgXCJidWYrMV8wMjAxXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDMwMCwgXCJpZXJyb3IrMF8wMzAwXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDMwMiwgXCJpbWFpbiswXzAzMDJcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMzA0LCBcImljcm5jaCswXzAzMDRcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMzA2LCBcImlxcGxvcCswXzAzMDZcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMzA4LCBcImlnb25lKzBfMDMwOFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAzMGEsIFwiaWV2YWwrMF8wMzBhXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4OWZlYSwgXCJfOWZlYVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDlmZWIsIFwiXzlmZWJcIik7XHJcblxyXG4gICAgICAgICAgICAvLyBFeHRlcm5hbCBsYWJlbHMgKE1lbW9yeS1tYXBwZWQgSU8pXHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDAxLCBcInI2NTEwXzAwMDFcIik7XHJcblxyXG4gICAgICAgICAgICAvLyBFeHRlcm5hbCBsYWJlbHMgKEtlcm5hbCBST00pXHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHhlMDAwLCBcIihleHBfZTAwMFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweGUwNDMsIFwicG9seXhfZTA0M1wiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweGUxMGMsIFwiYmNob3V0X2UxMGNcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHhlMTEyLCBcImJjaGluX2UxMTJcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHhlMTE4LCBcImJja291dF9lMTE4XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4ZTExZSwgXCJiY2tpbl9lMTFlXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4ZTEyNCwgXCJiZ2V0aW5fZTEyNFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweGUzODYsIFwiX2UzODZcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHhmZjkwLCBcInNldG1zZ19mZjkwXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4ZmZiNywgXCJyZWFkc3RfZmZiN1wiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweGZmY2MsIFwiY2xyY2huX2ZmY2NcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHhmZmRiLCBcInNldHRpbV9mZmRiXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4ZmZkZSwgXCJyZHRpbV9mZmRlXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4ZmZlMSwgXCJzdG9wX2ZmZTFcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHhmZmU3LCBcImNsYWxsX2ZmZTdcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHhmZmYwLCBcInBsb3RfZmZmMFwiKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gc3RhcnQgb2YgdGhlIEJBU0lDIFJPTVxyXG4vKiBhMDAwICovIF9gcmVzdGFydF9hMDAwYDsgIF8uYnl0ZXMoMHg5NCwgMHhlMyk7ICAgICAgICAgIC8vIEJBU0lDIGNvbGQgc3RhcnQgZW50cnkgcG9pbnRcclxuLyogYTAwMiAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4N2IsIDB4ZTMpOyAgICAgICAgICAvLyBCQVNJQyB3YXJtIHN0YXJ0IGVudHJ5IHBvaW50XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICdjYm1iYXNpYycsIFJPTSBuYW1lLCB1bnJlZmVyZW5jZWRcclxuLyogYTAwNCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NDMsIDB4NDIsIDB4NGQsIDB4NDIsIDB4NDEsIDB4NTMsIDB4NDksIDB4NDMpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBhY3Rpb24gYWRkcmVzc2VzIGZvciBwcmltYXJ5IGNvbW1hbmRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlc2UgYXJlIGNhbGxlZCBieSBwdXNoaW5nIHRoZSBhZGRyZXNzIG9udG8gdGhlIHN0YWNrIGFuZCBkb2luZyBhbiBSVFMgc28gdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWN0dWFsIGFkZHJlc3MgLTEgbmVlZHMgdG8gYmUgcHVzaGVkXHJcbi8qIGEwMGMgKi8gIF9gc3RtZHNwX2EwMGNgOyAgXy5ieXRlcygweDMwLCAweGE4KTsgICAgICAgICAgLy8gcGVyZm9ybSBFTkQgICAgICQ4MFxyXG4vKiBhMDBlICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg0MSwgMHhhNyk7ICAgICAgICAgIC8vIHBlcmZvcm0gRk9SICAgICAkODFcclxuLyogYTAxMCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MWQsIDB4YWQpOyAgICAgICAgICAvLyBwZXJmb3JtIE5FWFQgICAgJDgyXHJcbi8qIGEwMTIgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweGY3LCAweGE4KTsgICAgICAgICAgLy8gcGVyZm9ybSBEQVRBICAgICQ4M1xyXG4vKiBhMDE0ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHhhNCwgMHhhYik7ICAgICAgICAgIC8vIHBlcmZvcm0gSU5QVVQjICAkODRcclxuLyogYTAxNiAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4YmUsIDB4YWIpOyAgICAgICAgICAvLyBwZXJmb3JtIElOUFVUICAgJDg1XHJcbi8qIGEwMTggKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDgwLCAweGIwKTsgICAgICAgICAgLy8gcGVyZm9ybSBESU0gICAgICQ4NlxyXG4vKiBhMDFhICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgwNSwgMHhhYyk7ICAgICAgICAgIC8vIHBlcmZvcm0gUkVBRCAgICAkODdcclxuLyogYTAxYyAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4YTQsIDB4YTkpOyAgICAgICAgICAvLyBwZXJmb3JtIExFVCAgICAgJDg4XHJcbi8qIGEwMWUgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDlmLCAweGE4KTsgICAgICAgICAgLy8gcGVyZm9ybSBHT1RPICAgICQ4OVxyXG4vKiBhMDIwICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg3MCwgMHhhOCk7ICAgICAgICAgIC8vIHBlcmZvcm0gUlVOICAgICAkOEFcclxuLyogYTAyMiAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MjcsIDB4YTkpOyAgICAgICAgICAvLyBwZXJmb3JtIElGICAgICAgJDhCXHJcbi8qIGEwMjQgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDFjLCAweGE4KTsgICAgICAgICAgLy8gcGVyZm9ybSBSRVNUT1JFICQ4Q1xyXG4vKiBhMDI2ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg4MiwgMHhhOCk7ICAgICAgICAgIC8vIHBlcmZvcm0gR09TVUIgICAkOERcclxuLyogYTAyOCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4ZDEsIDB4YTgpOyAgICAgICAgICAvLyBwZXJmb3JtIFJFVFVSTiAgJDhFXHJcbi8qIGEwMmEgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDNhLCAweGE5KTsgICAgICAgICAgLy8gcGVyZm9ybSBSRU0gICAgICQ4RlxyXG4vKiBhMDJjICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgyZSwgMHhhOCk7ICAgICAgICAgIC8vIHBlcmZvcm0gU1RPUCAgICAkOTBcclxuLyogYTAyZSAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NGEsIDB4YTkpOyAgICAgICAgICAvLyBwZXJmb3JtIE9OICAgICAgJDkxXHJcbi8qIGEwMzAgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDJjLCAweGI4KTsgICAgICAgICAgLy8gcGVyZm9ybSBXQUlUICAgICQ5MlxyXG4vKiBhMDMyICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg2NywgMHhlMSk7ICAgICAgICAgIC8vIHBlcmZvcm0gTE9BRCAgICAkOTNcclxuLyogYTAzNCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NTUsIDB4ZTEpOyAgICAgICAgICAvLyBwZXJmb3JtIFNBVkUgICAgJDk0XHJcbi8qIGEwMzYgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDY0LCAweGUxKTsgICAgICAgICAgLy8gcGVyZm9ybSBWRVJJRlkgICQ5NVxyXG4vKiBhMDM4ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHhiMiwgMHhiMyk7ICAgICAgICAgIC8vIHBlcmZvcm0gREVGICAgICAkOTZcclxuLyogYTAzYSAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MjMsIDB4YjgpOyAgICAgICAgICAvLyBwZXJmb3JtIFBPS0UgICAgJDk3XHJcbi8qIGEwM2MgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDdmLCAweGFhKTsgICAgICAgICAgLy8gcGVyZm9ybSBQUklOVCMgICQ5OFxyXG4vKiBhMDNlICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg5ZiwgMHhhYSk7ICAgICAgICAgIC8vIHBlcmZvcm0gUFJJTlQgICAkOTlcclxuLyogYTA0MCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NTYsIDB4YTgpOyAgICAgICAgICAvLyBwZXJmb3JtIENPTlQgICAgJDlBXHJcbi8qIGEwNDIgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDliLCAweGE2KTsgICAgICAgICAgLy8gcGVyZm9ybSBMSVNUICAgICQ5QlxyXG4vKiBhMDQ0ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg1ZCwgMHhhNik7ICAgICAgICAgIC8vIHBlcmZvcm0gQ0xSICAgICAkOUNcclxuLyogYTA0NiAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4ODUsIDB4YWEpOyAgICAgICAgICAvLyBwZXJmb3JtIENNRCAgICAgJDlEXHJcbi8qIGEwNDggKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDI5LCAweGUxKTsgICAgICAgICAgLy8gcGVyZm9ybSBTWVMgICAgICQ5RVxyXG4vKiBhMDRhICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHhiZCwgMHhlMSk7ICAgICAgICAgIC8vIHBlcmZvcm0gT1BFTiAgICAkOUZcclxuLyogYTA0YyAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4YzYsIDB4ZTEpOyAgICAgICAgICAvLyBwZXJmb3JtIENMT1NFICAgJEEwXHJcbi8qIGEwNGUgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDdhLCAweGFiKTsgICAgICAgICAgLy8gcGVyZm9ybSBHRVQgICAgICRBMVxyXG4vKiBhMDUwICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg0MSwgMHhhNik7ICAgICAgICAgIC8vIHBlcmZvcm0gTkVXICAgICAkQTJcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gYWN0aW9uIGFkZHJlc3NlcyBmb3IgZnVuY3Rpb25zXHJcbi8qIGEwNTIgKi8gIF9gZnVuZHNwX2EwNTJgOyAgXy5ieXRlcygweDM5LCAweGJjKTsgICAgICAgICAgLy8gcGVyZm9ybSBTR04gICAgICRCNFxyXG4vKiBhMDU0ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHhjYywgMHhiYyk7ICAgICAgICAgIC8vIHBlcmZvcm0gSU5UICAgICAkQjVcclxuLyogYTA1NiAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NTgsIDB4YmMpOyAgICAgICAgICAvLyBwZXJmb3JtIEFCUyAgICAgJEI2XHJcbi8qIGEwNTggKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDEwLCAweDAzKTsgICAgICAgICAgLy8gcGVyZm9ybSBVU1IgICAgICRCN1xyXG4vKiBhMDVhICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg3ZCwgMHhiMyk7ICAgICAgICAgIC8vIHBlcmZvcm0gRlJFICAgICAkQjhcclxuLyogYTA1YyAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4OWUsIDB4YjMpOyAgICAgICAgICAvLyBwZXJmb3JtIFBPUyAgICAgJEI5XHJcbi8qIGEwNWUgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDcxLCAweGJmKTsgICAgICAgICAgLy8gcGVyZm9ybSBTUVIgICAgICRCQVxyXG4vKiBhMDYwICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg5NywgMHhlMCk7ICAgICAgICAgIC8vIHBlcmZvcm0gUk5EICAgICAkQkJcclxuLyogYTA2MiAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4ZWEsIDB4YjkpOyAgICAgICAgICAvLyBwZXJmb3JtIExPRyAgICAgJEJDXHJcbi8qIGEwNjQgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweGVkLCAweGJmKTsgICAgICAgICAgLy8gcGVyZm9ybSBFWFAgICAgICRCRFxyXG4vKiBhMDY2ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg2NCwgMHhlMik7ICAgICAgICAgIC8vIHBlcmZvcm0gQ09TICAgICAkQkVcclxuLyogYTA2OCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NmIsIDB4ZTIpOyAgICAgICAgICAvLyBwZXJmb3JtIFNJTiAgICAgJEJGXHJcbi8qIGEwNmEgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweGI0LCAweGUyKTsgICAgICAgICAgLy8gcGVyZm9ybSBUQU4gICAgICRDMFxyXG4vKiBhMDZjICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgwZSwgMHhlMyk7ICAgICAgICAgIC8vIHBlcmZvcm0gQVROICAgICAkQzFcclxuLyogYTA2ZSAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MGQsIDB4YjgpOyAgICAgICAgICAvLyBwZXJmb3JtIFBFRUsgICAgJEMyXHJcbi8qIGEwNzAgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDdjLCAweGI3KTsgICAgICAgICAgLy8gcGVyZm9ybSBMRU4gICAgICRDM1xyXG4vKiBhMDcyICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg2NSwgMHhiNCk7ICAgICAgICAgIC8vIHBlcmZvcm0gU1RSJCAgICAkQzRcclxuLyogYTA3NCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4YWQsIDB4YjcpOyAgICAgICAgICAvLyBwZXJmb3JtIFZBTCAgICAgJEM1XHJcbi8qIGEwNzYgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDhiLCAweGI3KTsgICAgICAgICAgLy8gcGVyZm9ybSBBU0MgICAgICRDNlxyXG4vKiBhMDc4ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHhlYywgMHhiNik7ICAgICAgICAgIC8vIHBlcmZvcm0gQ0hSJCAgICAkQzdcclxuLyogYTA3YSAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MDAsIDB4YjcpOyAgICAgICAgICAvLyBwZXJmb3JtIExFRlQkICAgJEM4XHJcbi8qIGEwN2MgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDJjLCAweGI3KTsgICAgICAgICAgLy8gcGVyZm9ybSBSSUdIVCQgICRDOVxyXG4vKiBhMDdlICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgzNywgMHhiNyk7ICAgICAgICAgIC8vIHBlcmZvcm0gTUlEJCAgICAkQ0FcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcHJlY2VkZW5jZSBieXRlIGFuZCBhY3Rpb24gYWRkcmVzc2VzIGZvciBvcGVyYXRvcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsaWtlIHRoZSBwcmltYXJ5IGNvbW1hbmRzIHRoZXNlIGFyZSBjYWxsZWQgYnkgcHVzaGluZyB0aGUgYWRkcmVzcyBvbnRvIHRoZSBzdGFja1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBkb2luZyBhbiBSVFMsIHNvIGFnYWluIHRoZSBhY3R1YWwgYWRkcmVzcyAtMSBuZWVkcyB0byBiZSBwdXNoZWRcclxuLyogYTA4MCAqLyAgIF9gb3B0YWJfYTA4MGA7ICBfLmJ5dGVzKDB4NzksIDB4NjksIDB4YjgpOyAgICAvLyArXHJcbi8qIGEwODMgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDc5LCAweDUyLCAweGI4KTsgICAgLy8gLVxyXG4vKiBhMDg2ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg3YiwgMHgyYSwgMHhiYSk7ICAgIC8vICpcclxuLyogYTA4OSAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4N2IsIDB4MTEsIDB4YmIpOyAgICAvLyAvXHJcbi8qIGEwOGMgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDdmLCAweDdhLCAweGJmKTsgICAgLy8gXlxyXG4vKiBhMDhmICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg1MCwgMHhlOCwgMHhhZik7ICAgIC8vIEFORFxyXG4vKiBhMDkyICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg0NiwgMHhlNSwgMHhhZik7ICAgIC8vIE9SXHJcbi8qIGEwOTUgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDdkLCAweGIzLCAweGJmKTsgICAgLy8gPlxyXG4vKiBhMDk4ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg1YSwgMHhkMywgMHhhZSk7ICAgIC8vID1cclxuLyogYTA5YiAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NjQsIDB4MTUsIDB4YjApOyAgICAvLyA8XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIEJBU0lDIGtleXdvcmRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWFjaCB3b3JkIGhhcyBiNyBzZXQgaW4gaXQncyBsYXN0IGNoYXJhY3RlciBhcyBhbiBlbmQgbWFya2VyLCBldmVuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG9uZSBjaGFyYWN0ZXIga2V5d29yZHMgc3VjaCBhcyBcIjxcIiBvciBcIj1cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpcnN0IGFyZSB0aGUgcHJpbWFyeSBjb21tYW5kIGtleXdvcmRzLCBvbmx5IHRoZXNlIGNhbiBzdGFydCBhIHN0YXRlbWVudFxyXG4vKiBhMDllICovICBfYHJlc2xzdF9hMDllYDsgIF8uYnl0ZXMoMHg0NSwgMHg0ZSk7ICAgICAgICAgIC8vIGVuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBuZXh0XHJcbi8qIGEwYTAgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweGM0LCAweDQ2LCAweDRmLCAweGQyLCAweDRlLCAweDQ1LCAweDU4LCAweGQ0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkYXRhIGlucHV0I1xyXG4vKiBhMGE4ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg0NCwgMHg0MSwgMHg1NCwgMHhjMSwgMHg0OSwgMHg0ZSwgMHg1MCwgMHg1NSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5wdXQgZGltXHJcbi8qIGEwYjAgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDU0LCAweGEzLCAweDQ5LCAweDRlLCAweDUwLCAweDU1LCAweGQ0LCAweDQ0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWFkIGxldFxyXG4vKiBhMGI4ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg0OSwgMHhjZCwgMHg1MiwgMHg0NSwgMHg0MSwgMHhjNCwgMHg0YywgMHg0NSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ290byBydW5cclxuLyogYTBjMCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4ZDQsIDB4NDcsIDB4NGYsIDB4NTQsIDB4Y2YsIDB4NTIsIDB4NTUsIDB4Y2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHJlc3RvcmVcclxuLyogYTBjOCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NDksIDB4YzYsIDB4NTIsIDB4NDUsIDB4NTMsIDB4NTQsIDB4NGYsIDB4NTIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdvc3ViIHJldHVyblxyXG4vKiBhMGQwICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHhjNSwgMHg0NywgMHg0ZiwgMHg1MywgMHg1NSwgMHhjMiwgMHg1MiwgMHg0NSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtIHN0b3BcclxuLyogYTBkOCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NTQsIDB4NTUsIDB4NTIsIDB4Y2UsIDB4NTIsIDB4NDUsIDB4Y2QsIDB4NTMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9uIHdhaXRcclxuLyogYTBlMCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NTQsIDB4NGYsIDB4ZDAsIDB4NGYsIDB4Y2UsIDB4NTcsIDB4NDEsIDB4NDkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvYWQgc2F2ZVxyXG4vKiBhMGU4ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHhkNCwgMHg0YywgMHg0ZiwgMHg0MSwgMHhjNCwgMHg1MywgMHg0MSwgMHg1Nik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmVyaWZ5IGRlZlxyXG4vKiBhMGYwICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHhjNSwgMHg1NiwgMHg0NSwgMHg1MiwgMHg0OSwgMHg0NiwgMHhkOSwgMHg0NCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcG9rZSBwcmludCNcclxuLyogYTBmOCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NDUsIDB4YzYsIDB4NTAsIDB4NGYsIDB4NGIsIDB4YzUsIDB4NTAsIDB4NTIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByaW50XHJcbi8qIGExMDAgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDQ5LCAweDRlLCAweDU0LCAweGEzLCAweDUwLCAweDUyLCAweDQ5LCAweDRlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb250IGxpc3RcclxuLyogYTEwOCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4ZDQsIDB4NDMsIDB4NGYsIDB4NGUsIDB4ZDQsIDB4NGMsIDB4NDksIDB4NTMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNsciBjbWQgc3lzXHJcbi8qIGExMTAgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweGQ0LCAweDQzLCAweDRjLCAweGQyLCAweDQzLCAweDRkLCAweGM0LCAweDUzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvcGVuIGNsb3NlXHJcbi8qIGExMTggKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDU5LCAweGQzLCAweDRmLCAweDUwLCAweDQ1LCAweGNlLCAweDQzLCAweDRjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXQgbmV3XHJcbi8qIGExMjAgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDRmLCAweDUzLCAweGM1LCAweDQ3LCAweDQ1LCAweGQ0LCAweDRlLCAweDQ1KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBhcmUgdGhlIHNlY29uZGFyeSBjb21tYW5kIGtleXdvcmRzLCB0aGVzZSBjYW4gbm90IHN0YXJ0IGEgc3RhdGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGFiKCB0b1xyXG4vKiBhMTI4ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHhkNywgMHg1NCwgMHg0MSwgMHg0MiwgMHhhOCwgMHg1NCwgMHhjZiwgMHg0Nik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BjKCB0aGVuXHJcbi8qIGExMzAgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweGNlLCAweDUzLCAweDUwLCAweDQzLCAweGE4LCAweDU0LCAweDQ4LCAweDQ1KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3Qgc3RlcFxyXG4vKiBhMTM4ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHhjZSwgMHg0ZSwgMHg0ZiwgMHhkNCwgMHg1MywgMHg1NCwgMHg0NSwgMHhkMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBhcmUgdGhlIG9wZXJhdG9yc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICsgLSAqIC8gJyBhbmRcclxuLyogYTE0MCAqLyAgX2BvcGxpc3RfYTE0MGA7ICBfLmJ5dGVzKDB4YWIsIDB4YWQsIDB4YWEsIDB4YWYsIDB4ZGUsIDB4NDEsIDB4NGUsIDB4YzQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIDw9PlxyXG4vKiBhMTQ4ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg0ZiwgMHhkMiwgMHhiZSwgMHhiZCwgMHhiYyk7XHJcbi8qIGExNGQgKi8gIF9gZnVubHN0X2ExNGRgOyAgXy5ieXRlcygweDUzLCAweDQ3LCAweGNlKTsgICAgLy8gc2duXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBmaW5hbGx5IHRoZSBmdW5jdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnQgYWJzIHVzclxyXG4vKiBhMTUwICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg0OSwgMHg0ZSwgMHhkNCwgMHg0MSwgMHg0MiwgMHhkMywgMHg1NSwgMHg1Myk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJlIHBvcyBzcXJcclxuLyogYTE1OCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4ZDIsIDB4NDYsIDB4NTIsIDB4YzUsIDB4NTAsIDB4NGYsIDB4ZDMsIDB4NTMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJuZCBsb2dcclxuLyogYTE2MCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NTEsIDB4ZDIsIDB4NTIsIDB4NGUsIDB4YzQsIDB4NGMsIDB4NGYsIDB4YzcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4cCBjb3Mgc2luXHJcbi8qIGExNjggKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDQ1LCAweDU4LCAweGQwLCAweDQzLCAweDRmLCAweGQzLCAweDUzLCAweDQ5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0YW4gYXRuIHBlZWtcclxuLyogYTE3MCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4Y2UsIDB4NTQsIDB4NDEsIDB4Y2UsIDB4NDEsIDB4NTQsIDB4Y2UsIDB4NTApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxlbiBzdHIkXHJcbi8qIGExNzggKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDQ1LCAweDQ1LCAweGNiLCAweDRjLCAweDQ1LCAweGNlLCAweDUzLCAweDU0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB2YWwgYXNjXHJcbi8qIGExODAgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDUyLCAweGE0LCAweDU2LCAweDQxLCAweGNjLCAweDQxLCAweDUzLCAweGMzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaHIkIGxlZnQkXHJcbi8qIGExODggKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDQzLCAweDQ4LCAweDUyLCAweGE0LCAweDRjLCAweDQ1LCAweDQ2LCAweDU0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByaWdodCQgbWlkJFxyXG4vKiBhMTkwICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHhhNCwgMHg1MiwgMHg0OSwgMHg0NywgMHg0OCwgMHg1NCwgMHhhNCwgMHg0ZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxhc3RseSBpcyBHTywgdGhpcyBpcyBhbiBhZGQgb24gc28gdGhhdCBHTyBUTywgYXMgd2VsbCBhcyBHT1RPLCB3aWxsIHdvcmtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnb1xyXG4vKiBhMTk4ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg0OSwgMHg0NCwgMHhhNCwgMHg0NywgMHhjZik7XHJcbi8qIGExOWQgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDAwKTsgICAgICAgICAgICAgICAgLy8gZW5kIG1hcmtlclxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBCQVNJQyBlcnJvciBtZXNzYWdlc1xyXG4vKiBhMTllICovICBfYGVycnRhYl9hMTllYDsgIF8uYnl0ZXMoMHg1NCwgMHg0Zik7ICAgICAgICAgIC8vIDEgdG9vIG1hbnkgZmlsZXNcclxuLyogYTFhMCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NGYsIDB4MjAsIDB4NGQsIDB4NDEsIDB4NGUsIDB4NTksIDB4MjAsIDB4NDYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDIgZmlsZSBvcGVuXHJcbi8qIGExYTggKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDQ5LCAweDRjLCAweDQ1LCAweGQzLCAweDQ2LCAweDQ5LCAweDRjLCAweDQ1KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAzIGZpbGUgbm90IG9wZW5cclxuLyogYTFiMCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MjAsIDB4NGYsIDB4NTAsIDB4NDUsIDB4Y2UsIDB4NDYsIDB4NDksIDB4NGMpO1xyXG4vKiBhMWI4ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg0NSwgMHgyMCwgMHg0ZSwgMHg0ZiwgMHg1NCwgMHgyMCwgMHg0ZiwgMHg1MCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gNCBmaWxlIG5vdCBmb3VuZFxyXG4vKiBhMWMwICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg0NSwgMHhjZSwgMHg0NiwgMHg0OSwgMHg0YywgMHg0NSwgMHgyMCwgMHg0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gNSBkZXZpY2Ugbm90IHByZXNlbnRcclxuLyogYTFjOCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NGYsIDB4NTQsIDB4MjAsIDB4NDYsIDB4NGYsIDB4NTUsIDB4NGUsIDB4YzQpO1xyXG4vKiBhMWQwICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg0NCwgMHg0NSwgMHg1NiwgMHg0OSwgMHg0MywgMHg0NSwgMHgyMCwgMHg0ZSk7XHJcbi8qIGExZDggKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDRmLCAweDU0LCAweDIwLCAweDUwLCAweDUyLCAweDQ1LCAweDUzLCAweDQ1KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA2IG5vdCBpbnB1dCBmaWxlXHJcbi8qIGExZTAgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDRlLCAweGQ0LCAweDRlLCAweDRmLCAweDU0LCAweDIwLCAweDQ5LCAweDRlKTtcclxuLyogYTFlOCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NTAsIDB4NTUsIDB4NTQsIDB4MjAsIDB4NDYsIDB4NDksIDB4NGMsIDB4YzUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDcgbm90IG91dHB1dCBmaWxlXHJcbi8qIGExZjAgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDRlLCAweDRmLCAweDU0LCAweDIwLCAweDRmLCAweDU1LCAweDU0LCAweDUwKTtcclxuLyogYTFmOCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NTUsIDB4NTQsIDB4MjAsIDB4NDYsIDB4NDksIDB4NGMsIDB4YzUsIDB4NGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDggbWlzc2luZyBmaWxlbmFtZVxyXG4vKiBhMjAwICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg0OSwgMHg1MywgMHg1MywgMHg0OSwgMHg0ZSwgMHg0NywgMHgyMCwgMHg0Nik7XHJcbi8qIGEyMDggKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDQ5LCAweDRjLCAweDQ1LCAweDIwLCAweDRlLCAweDQxLCAweDRkLCAweGM1KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA5IGlsbGVnYWwgZGV2aWNlIG51bWJlclxyXG4vKiBhMjEwICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg0OSwgMHg0YywgMHg0YywgMHg0NSwgMHg0NywgMHg0MSwgMHg0YywgMHgyMCk7XHJcbi8qIGEyMTggKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDQ0LCAweDQ1LCAweDU2LCAweDQ5LCAweDQzLCAweDQ1LCAweDIwLCAweDRlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxMCBuZXh0IHdpdGhvdXQgZm9yXHJcbi8qIGEyMjAgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDU1LCAweDRkLCAweDQyLCAweDQ1LCAweGQyLCAweDRlLCAweDQ1LCAweDU4KTtcclxuLyogYTIyOCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NTQsIDB4MjAsIDB4NTcsIDB4NDksIDB4NTQsIDB4NDgsIDB4NGYsIDB4NTUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDExIHN5bnRheFxyXG4vKiBhMjMwICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg1NCwgMHgyMCwgMHg0NiwgMHg0ZiwgMHhkMiwgMHg1MywgMHg1OSwgMHg0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMTIgcmV0dXJuIHdpdGhvdXQgZ29zdWJcclxuLyogYTIzOCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NTQsIDB4NDEsIDB4ZDgsIDB4NTIsIDB4NDUsIDB4NTQsIDB4NTUsIDB4NTIpO1xyXG4vKiBhMjQwICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg0ZSwgMHgyMCwgMHg1NywgMHg0OSwgMHg1NCwgMHg0OCwgMHg0ZiwgMHg1NSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMTMgb3V0IG9mIGRhdGFcclxuLyogYTI0OCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NTQsIDB4MjAsIDB4NDcsIDB4NGYsIDB4NTMsIDB4NTUsIDB4YzIsIDB4NGYpO1xyXG4vKiBhMjUwICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg1NSwgMHg1NCwgMHgyMCwgMHg0ZiwgMHg0NiwgMHgyMCwgMHg0NCwgMHg0MSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMTQgaWxsZWdhbCBxdWFudGl0eVxyXG4vKiBhMjU4ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg1NCwgMHhjMSwgMHg0OSwgMHg0YywgMHg0YywgMHg0NSwgMHg0NywgMHg0MSk7XHJcbi8qIGEyNjAgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDRjLCAweDIwLCAweDUxLCAweDU1LCAweDQxLCAweDRlLCAweDU0LCAweDQ5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxNSBvdmVyZmxvd1xyXG4vKiBhMjY4ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg1NCwgMHhkOSwgMHg0ZiwgMHg1NiwgMHg0NSwgMHg1MiwgMHg0NiwgMHg0Yyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMTYgb3V0IG9mIG1lbW9yeVxyXG4vKiBhMjcwICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg0ZiwgMHhkNywgMHg0ZiwgMHg1NSwgMHg1NCwgMHgyMCwgMHg0ZiwgMHg0Nik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMTcgdW5kZWYnZCBzdGF0ZW1lbnRcclxuLyogYTI3OCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MjAsIDB4NGQsIDB4NDUsIDB4NGQsIDB4NGYsIDB4NTIsIDB4ZDksIDB4NTUpO1xyXG4vKiBhMjgwICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg0ZSwgMHg0NCwgMHg0NSwgMHg0NiwgMHgyNywgMHg0NCwgMHgyMCwgMHg1Myk7XHJcbi8qIGEyODggKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDU0LCAweDQxLCAweDU0LCAweDQ1LCAweDRkLCAweDQ1LCAweDRlLCAweGQ0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxOCBiYWQgc3Vic2NyaXB0XHJcbi8qIGEyOTAgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDQyLCAweDQxLCAweDQ0LCAweDIwLCAweDUzLCAweDU1LCAweDQyLCAweDUzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxOSByZWRpbSdkIGFycmF5XHJcbi8qIGEyOTggKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDQzLCAweDUyLCAweDQ5LCAweDUwLCAweGQ0LCAweDUyLCAweDQ1LCAweDQ0KTtcclxuLyogYTJhMCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NDksIDB4NGQsIDB4MjcsIDB4NDQsIDB4MjAsIDB4NDEsIDB4NTIsIDB4NTIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDIwIGRpdmlzaW9uIGJ5IHplcm9cclxuLyogYTJhOCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NDEsIDB4ZDksIDB4NDQsIDB4NDksIDB4NTYsIDB4NDksIDB4NTMsIDB4NDkpO1xyXG4vKiBhMmIwICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg0ZiwgMHg0ZSwgMHgyMCwgMHg0MiwgMHg1OSwgMHgyMCwgMHg1YSwgMHg0NSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMjEgaWxsZWdhbCBkaXJlY3RcclxuLyogYTJiOCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NTIsIDB4Y2YsIDB4NDksIDB4NGMsIDB4NGMsIDB4NDUsIDB4NDcsIDB4NDEpO1xyXG4vKiBhMmMwICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg0YywgMHgyMCwgMHg0NCwgMHg0OSwgMHg1MiwgMHg0NSwgMHg0MywgMHhkNCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMjIgdHlwZSBtaXNtYXRjaFxyXG4vKiBhMmM4ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg1NCwgMHg1OSwgMHg1MCwgMHg0NSwgMHgyMCwgMHg0ZCwgMHg0OSwgMHg1Myk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMjMgc3RyaW5nIHRvbyBsb25nXHJcbi8qIGEyZDAgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDRkLCAweDQxLCAweDU0LCAweDQzLCAweGM4LCAweDUzLCAweDU0LCAweDUyKTtcclxuLyogYTJkOCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NDksIDB4NGUsIDB4NDcsIDB4MjAsIDB4NTQsIDB4NGYsIDB4NGYsIDB4MjApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDI0IGZpbGUgZGF0YVxyXG4vKiBhMmUwICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg0YywgMHg0ZiwgMHg0ZSwgMHhjNywgMHg0NiwgMHg0OSwgMHg0YywgMHg0NSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMjUgZm9ybXVsYSB0b28gY29tcGxleFxyXG4vKiBhMmU4ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgyMCwgMHg0NCwgMHg0MSwgMHg1NCwgMHhjMSwgMHg0NiwgMHg0ZiwgMHg1Mik7XHJcbi8qIGEyZjAgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDRkLCAweDU1LCAweDRjLCAweDQxLCAweDIwLCAweDU0LCAweDRmLCAweDRmKTtcclxuLyogYTJmOCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MjAsIDB4NDMsIDB4NGYsIDB4NGQsIDB4NTAsIDB4NGMsIDB4NDUsIDB4ZDgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDI2IGNhbid0IGNvbnRpbnVlXHJcbi8qIGEzMDAgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDQzLCAweDQxLCAweDRlLCAweDI3LCAweDU0LCAweDIwLCAweDQzLCAweDRmKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAyNyB1bmRlZidkIGZ1bmN0aW9uXHJcbi8qIGEzMDggKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDRlLCAweDU0LCAweDQ5LCAweDRlLCAweDU1LCAweGM1LCAweDU1LCAweDRlKTtcclxuLyogYTMxMCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NDQsIDB4NDUsIDB4NDYsIDB4MjcsIDB4NDQsIDB4MjAsIDB4NDYsIDB4NTUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDI4IHZlcmlmeVxyXG4vKiBhMzE4ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg0ZSwgMHg0MywgMHg1NCwgMHg0OSwgMHg0ZiwgMHhjZSwgMHg1NiwgMHg0NSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMjkgbG9hZFxyXG4vKiBhMzIwICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg1MiwgMHg0OSwgMHg0NiwgMHhkOSwgMHg0YywgMHg0ZiwgMHg0MSwgMHhjNCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGVycm9yIG1lc3NhZ2UgcG9pbnRlciB0YWJsZVxyXG4vKiBhMzI4ICovICBfYGVycnB0cl9hMzI4YDsgIF8uYnl0ZXMoMHg5ZSwgMHhhMSwgMHhhYywgMHhhMSwgMHhiNSwgMHhhMSwgMHhjMiwgMHhhMSk7XHJcbi8qIGEzMzAgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweGQwLCAweGExLCAweGUyLCAweGExLCAweGYwLCAweGExLCAweGZmLCAweGExKTtcclxuLyogYTMzOCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MTAsIDB4YTIsIDB4MjUsIDB4YTIsIDB4MzUsIDB4YTIsIDB4M2IsIDB4YTIpO1xyXG4vKiBhMzQwICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg0ZiwgMHhhMiwgMHg1YSwgMHhhMiwgMHg2YSwgMHhhMiwgMHg3MiwgMHhhMik7XHJcbi8qIGEzNDggKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDdmLCAweGEyLCAweDkwLCAweGEyLCAweDlkLCAweGEyLCAweGFhLCAweGEyKTtcclxuLyogYTM1MCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4YmEsIDB4YTIsIDB4YzgsIDB4YTIsIDB4ZDUsIDB4YTIsIDB4ZTQsIDB4YTIpO1xyXG4vKiBhMzU4ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHhlZCwgMHhhMiwgMHgwMCwgMHhhMywgMHgwZSwgMHhhMywgMHgxZSwgMHhhMyk7XHJcbi8qIGEzNjAgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDI0LCAweGEzLCAweDgzLCAweGEzKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gQkFTSUMgbWVzc2FnZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPS1xyXG4vKiBhMzY0ICovICAgICBfYG9ra19hMzY0YDsgIF8uYnl0ZXMoMHgwZCwgMHg0ZiwgMHg0YiwgMHgwZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRVJST1JcclxuLyogYTM2OCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MDAsIDB4MjAsIDB4MjAsIDB4NDUsIDB4NTIsIDB4NTIsIDB4NGYsIDB4NTIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElOXHJcbi8qIGEzNzAgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDAwLCAweDIwLCAweDQ5LCAweDRlLCAweDIwLCAweDAwLCAweDBkLCAweDBhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSRUFEWS5cclxuLyogYTM3OCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NTIsIDB4NDUsIDB4NDEsIDB4NDQsIDB4NTksIDB4MmUsIDB4MGQsIDB4MGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJSRUFLXHJcbi8qIGEzODAgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDAwLCAweDBkLCAweDBhLCAweDQyLCAweDUyLCAweDQ1LCAweDQxLCAweDRiKTtcclxuLyogYTM4OCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MDApO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzcGFyZSBieXRlLCBub3QgcmVmZXJlbmNlZFxyXG4vKiBhMzg5ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHhhMCk7ICAgICAgICAgICAgICAgIC8vIHVudXNlZFxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzZWFyY2ggdGhlIHN0YWNrIGZvciBGT1Igb3IgR09TVUIgYWN0aXZpdHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gWmI9MSBpZiBGT1IgdmFyaWFibGUgZm91bmRcclxuLyogYTM4YSAqLyAgX2BmbmRmb3JfYTM4YWA7ICBUU1guaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IHN0YWNrIHBvaW50ZXJcclxuLyogYTM4YiAqLyAgICAgICAgICAgICAgICAgICBJTlguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyArMSBwYXNzIHJldHVybiBhZGRyZXNzXHJcbi8qIGEzOGMgKi8gICAgICAgICAgICAgICAgICAgSU5YLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gKzIgcGFzcyByZXR1cm4gYWRkcmVzc1xyXG4vKiBhMzhkICovICAgICAgICAgICAgICAgICAgIElOWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vICszIHBhc3MgY2FsbGluZyByb3V0aW5lIHJldHVybiBhZGRyZXNzXHJcbi8qIGEzOGUgKi8gICAgICAgICAgICAgICAgICAgSU5YLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gKzQgcGFzcyBjYWxsaW5nIHJvdXRpbmUgcmV0dXJuIGFkZHJlc3NcclxuLyogYTM4ZiAqLyAgICAgICAgX2BfYTM4ZmA7ICBMREEuYWJ4IChcImJhZCsxXzAxMDFcIik7ICAgICAgIC8vIGdldCB0aGUgdG9rZW4gYnl0ZSBmcm9tIHRoZSBzdGFja1xyXG4vKiBhMzkyICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4ODEpOyAgICAgICAgICAgICAgIC8vIGlzIGl0IHRoZSBGT1IgdG9rZW5cclxuLyogYTM5NCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9hM2I3XCIpOyAgICAgICAgICAgIC8vIGlmIG5vdCBGT1IgdG9rZW4ganVzdCBleGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgd2FzIHRoZSBGT1IgdG9rZW5cclxuLyogYTM5NiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZvcnBudCsxXzAwNGFcIik7ICAgIC8vIGdldCBGT1IvTkVYVCB2YXJpYWJsZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBhMzk4ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2EzYTRcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vdCBudWxsXHJcbi8qIGEzOWEgKi8gICAgICAgICAgICAgICAgICAgTERBLmFieCAoXCJiYWQrMl8wMTAyXCIpOyAgICAgICAvLyBnZXQgRk9SIHZhcmlhYmxlIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYTM5ZCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZvcnBudCswXzAwNDlcIik7ICAgIC8vIHNhdmUgRk9SL05FWFQgdmFyaWFibGUgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBhMzlmICovICAgICAgICAgICAgICAgICAgIExEQS5hYnggKFwiYmFkKzNfMDEwM1wiKTsgICAgICAgLy8gZ2V0IEZPUiB2YXJpYWJsZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBhM2EyICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZm9ycG50KzFfMDA0YVwiKTsgICAgLy8gc2F2ZSBGT1IvTkVYVCB2YXJpYWJsZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBhM2E0ICovICAgICAgICBfYF9hM2E0YDsgIENNUC5hYnggKFwiYmFkKzNfMDEwM1wiKTsgICAgICAgLy8gY29tcGFyZSB2YXJpYWJsZSBwb2ludGVyIHdpdGggc3RhY2tlZCB2YXJpYWJsZSBwb2ludGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGlnaCBieXRlXHJcbi8qIGEzYTcgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYTNiMFwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbm8gbWF0Y2hcclxuLyogYTNhOSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZvcnBudCswXzAwNDlcIik7ICAgIC8vIGdldCBGT1IvTkVYVCB2YXJpYWJsZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGEzYWIgKi8gICAgICAgICAgICAgICAgICAgQ01QLmFieCAoXCJiYWQrMl8wMTAyXCIpOyAgICAgICAvLyBjb21wYXJlIHZhcmlhYmxlIHBvaW50ZXIgd2l0aCBzdGFja2VkIHZhcmlhYmxlIHBvaW50ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsb3cgYnl0ZVxyXG4vKiBhM2FlICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2EzYjdcIik7ICAgICAgICAgICAgLy8gZXhpdCBpZiBtYXRjaCBmb3VuZFxyXG4vKiBhM2IwICovICAgICAgICBfYF9hM2IwYDsgIFRYQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgaW5kZXhcclxuLyogYTNiMSAqLyAgICAgICAgICAgICAgICAgICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBjYXJyeSBmb3IgYWRkXHJcbi8qIGEzYjIgKi8gICAgICAgICAgICAgICAgICAgQURDLmltbSAoMHgxMik7ICAgICAgICAgICAgICAgLy8gYWRkIEZPUiBzdGFjayB1c2Ugc2l6ZVxyXG4vKiBhM2I0ICovICAgICAgICAgICAgICAgICAgIFRBWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgYmFjayB0byBpbmRleFxyXG4vKiBhM2I1ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2EzOGZcIik7ICAgICAgICAgICAgLy8gbG9vcCBpZiBub3QgYXQgc3RhcnQgb2Ygc3RhY2tcclxuLyogYTNiNyAqLyAgICAgICAgX2BfYTNiN2A7ICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBvcGVuIHVwIGEgc3BhY2UgaW4gdGhlIG1lbW9yeSwgc2V0IHRoZSBlbmQgb2YgYXJyYXlzXHJcbi8qIGEzYjggKi8gICAgX2BibHR1X2EzYjhgOyAgSlNSLmFicyAoXCJyZWFzb25fYTQwOFwiKTsgICAgICAvLyBjaGVjayBhdmFpbGFibGUgbWVtb3J5LCBkbyBvdXQgb2YgbWVtb3J5IGVycm9yIGlmIG5vIHJvb21cclxuLyogYTNiYiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInN0cmVuZCswXzAwMzFcIik7ICAgIC8vIHNldCBlbmQgb2YgYXJyYXlzIGxvdyBieXRlXHJcbi8qIGEzYmQgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJzdHJlbmQrMV8wMDMyXCIpOyAgICAvLyBzZXQgZW5kIG9mIGFycmF5cyBoaWdoIGJ5dGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvcGVuIHVwIGEgc3BhY2UgaW4gdGhlIG1lbW9yeSwgZG9uJ3Qgc2V0IHRoZSBhcnJheSBlbmRcclxuLyogYTNiZiAqLyAgICAgICAgX2BfYTNiZmA7ICBTRUMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzZXQgY2FycnkgZm9yIHN1YnRyYWN0XHJcbi8qIGEzYzAgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ0ZW1wZjErM18wMDVhXCIpOyAgICAvLyBnZXQgYmxvY2sgZW5kIGxvdyBieXRlXHJcbi8qIGEzYzIgKi8gICAgICAgICAgICAgICAgICAgU0JDLnpwZyAoXCJ0ZW1wZjIrM18wMDVmXCIpOyAgICAvLyBzdWJ0cmFjdCBibG9jayBzdGFydCBsb3cgYnl0ZVxyXG4vKiBhM2M0ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiaW5kZXgrMF8wMDIyXCIpOyAgICAgLy8gc2F2ZSBNT0QoYmxvY2sgbGVuZ3RoLyQxMDApIGJ5dGVcclxuLyogYTNjNiAqLyAgICAgICAgICAgICAgICAgICBUQVkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IE1PRChibG9jayBsZW5ndGgvJDEwMCkgYnl0ZSB0byBZXHJcbi8qIGEzYzcgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ0ZW1wZjErNF8wMDViXCIpOyAgICAvLyBnZXQgYmxvY2sgZW5kIGhpZ2ggYnl0ZVxyXG4vKiBhM2M5ICovICAgICAgICAgICAgICAgICAgIFNCQy56cGcgKFwidGVtcGYyKzRfMDA2MFwiKTsgICAgLy8gc3VidHJhY3QgYmxvY2sgc3RhcnQgaGlnaCBieXRlXHJcbi8qIGEzY2IgKi8gICAgICAgICAgICAgICAgICAgVEFYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBibG9jayBsZW5ndGggaGlnaCBieXRlIHRvIFhcclxuLyogYTNjYyAqLyAgICAgICAgICAgICAgICAgICBJTlguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyArMSB0byBhbGxvdyBmb3IgY291bnQ9MCBleGl0XHJcbi8qIGEzY2QgKi8gICAgICAgICAgICAgICAgICAgVFlBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBibG9jayBsZW5ndGggbG93IGJ5dGUgdG8gQVxyXG4vKiBhM2NlICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2EzZjNcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIGxlbmd0aCBsb3cgYnl0ZT0wXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmxvY2sgaXMgKFgtMSkqMjU2K1kgYnl0ZXMsIGRvIHRoZSBZIGJ5dGVzIGZpcnN0XHJcbi8qIGEzZDAgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ0ZW1wZjErM18wMDVhXCIpOyAgICAvLyBnZXQgYmxvY2sgZW5kIGxvdyBieXRlXHJcbi8qIGEzZDIgKi8gICAgICAgICAgICAgICAgICAgU0VDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2V0IGNhcnJ5IGZvciBzdWJ0cmFjdFxyXG4vKiBhM2QzICovICAgICAgICAgICAgICAgICAgIFNCQy56cGcgKFwiaW5kZXgrMF8wMDIyXCIpOyAgICAgLy8gc3VidHJhY3QgTU9EKGJsb2NrIGxlbmd0aC8kMTAwKSBieXRlXHJcbi8qIGEzZDUgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJ0ZW1wZjErM18wMDVhXCIpOyAgICAvLyBzYXZlIGNvcnJlY3RlZCBvbGQgYmxvY2sgZW5kIGxvdyBieXRlXHJcbi8qIGEzZDcgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfYTNkY1wiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbm8gdW5kZXJmbG93XHJcbi8qIGEzZDkgKi8gICAgICAgICAgICAgICAgICAgREVDLnpwZyAoXCJ0ZW1wZjErNF8wMDViXCIpOyAgICAvLyBlbHNlIGRlY3JlbWVudCBibG9jayBlbmQgaGlnaCBieXRlXHJcbi8qIGEzZGIgKi8gICAgICAgICAgICAgICAgICAgU0VDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2V0IGNhcnJ5IGZvciBzdWJ0cmFjdFxyXG4vKiBhM2RjICovICAgICAgICBfYF9hM2RjYDsgIExEQS56cGcgKFwidGVtcGYxKzFfMDA1OFwiKTsgICAgLy8gZ2V0IGRlc3RpbmF0aW9uIGVuZCBsb3cgYnl0ZVxyXG4vKiBhM2RlICovICAgICAgICAgICAgICAgICAgIFNCQy56cGcgKFwiaW5kZXgrMF8wMDIyXCIpOyAgICAgLy8gc3VidHJhY3QgTU9EKGJsb2NrIGxlbmd0aC8kMTAwKSBieXRlXHJcbi8qIGEzZTAgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJ0ZW1wZjErMV8wMDU4XCIpOyAgICAvLyBzYXZlIG1vZGlmaWVkIG5ldyBibG9jayBlbmQgbG93IGJ5dGVcclxuLyogYTNlMiAqLyAgICAgICAgICAgICAgICAgICBCQ1MucmVsIChcIl9hM2VjXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBubyB1bmRlcmZsb3dcclxuLyogYTNlNCAqLyAgICAgICAgICAgICAgICAgICBERUMuenBnIChcInRlbXBmMSsyXzAwNTlcIik7ICAgIC8vIGVsc2UgZGVjcmVtZW50IGJsb2NrIGVuZCBoaWdoIGJ5dGVcclxuLyogYTNlNiAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9hM2VjXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBhbHdheXNcclxuLyogYTNlOCAqLyAgICAgICAgX2BfYTNlOGA7ICBMREEuaW55IChcInRlbXBmMSszXzAwNWFcIik7ICAgIC8vIGdldCBieXRlIGZyb20gc291cmNlXHJcbi8qIGEzZWEgKi8gICAgICAgICAgICAgICAgICAgU1RBLmlueSAoXCJ0ZW1wZjErMV8wMDU4XCIpOyAgICAvLyBjb3B5IGJ5dGUgdG8gZGVzdGluYXRpb25cclxuLyogYTNlYyAqLyAgICAgICAgX2BfYTNlY2A7ICBERVkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBkZWNyZW1lbnQgaW5kZXhcclxuLyogYTNlZCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9hM2U4XCIpOyAgICAgICAgICAgIC8vIGxvb3AgdW50aWwgWT0wXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm93IGRvIFk9MCBpbmRleGVkIGJ5dGVcclxuLyogYTNlZiAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcInRlbXBmMSszXzAwNWFcIik7ICAgIC8vIGdldCBieXRlIGZyb20gc291cmNlXHJcbi8qIGEzZjEgKi8gICAgICAgICAgICAgICAgICAgU1RBLmlueSAoXCJ0ZW1wZjErMV8wMDU4XCIpOyAgICAvLyBzYXZlIGJ5dGUgdG8gZGVzdGluYXRpb25cclxuLyogYTNmMyAqLyAgICAgICAgX2BfYTNmM2A7ICBERUMuenBnIChcInRlbXBmMSs0XzAwNWJcIik7ICAgIC8vIGRlY3JlbWVudCBzb3VyY2UgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYTNmNSAqLyAgICAgICAgICAgICAgICAgICBERUMuenBnIChcInRlbXBmMSsyXzAwNTlcIik7ICAgIC8vIGRlY3JlbWVudCBkZXN0aW5hdGlvbiBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBhM2Y3ICovICAgICAgICAgICAgICAgICAgIERFWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCBibG9jayBjb3VudFxyXG4vKiBhM2Y4ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2EzZWNcIik7ICAgICAgICAgICAgLy8gbG9vcCB1bnRpbCBjb3VudCA9ICQwXHJcbi8qIGEzZmEgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY2hlY2sgcm9vbSBvbiBzdGFjayBmb3IgQSBieXRlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHN0YWNrIHRvbyBkZWVwIGRvIG91dCBvZiBtZW1vcnkgZXJyb3JcclxuLyogYTNmYiAqLyAgX2BnZXRzdGtfYTNmYmA7ICBBU0wuYWNjICgpOyAgICAgICAgICAgICAgICAgICAvLyAqMlxyXG4vKiBhM2ZjICovICAgICAgICAgICAgICAgICAgIEFEQy5pbW0gKDB4M2UpOyAgICAgICAgICAgICAgIC8vIG5lZWQgYXQgbGVhc3QgJDNFIGJ5dGVzIGZyZWVcclxuLyogYTNmZSAqLyAgICAgICAgICAgICAgICAgICBCQ1MucmVsIChcIm9tZXJyX2E0MzVcIik7ICAgICAgIC8vIGlmIG92ZXJmbG93IGdvIGRvIG91dCBvZiBtZW1vcnkgZXJyb3IgdGhlbiB3YXJtIHN0YXJ0XHJcbi8qIGE0MDAgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJpbmRleCswXzAwMjJcIik7ICAgICAvLyBzYXZlIHJlc3VsdCBpbiB0ZW1wIGJ5dGVcclxuLyogYTQwMiAqLyAgICAgICAgICAgICAgICAgICBUU1guaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IHN0YWNrXHJcbi8qIGE0MDMgKi8gICAgICAgICAgICAgICAgICAgQ1BYLnpwZyAoXCJpbmRleCswXzAwMjJcIik7ICAgICAvLyBjb21wYXJlIG5ldyBsaW1pdCB3aXRoIHN0YWNrXHJcbi8qIGE0MDUgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJvbWVycl9hNDM1XCIpOyAgICAgICAvLyBpZiBzdGFjayA8IGxpbWl0IGRvIG91dCBvZiBtZW1vcnkgZXJyb3IgdGhlbiB3YXJtIHN0YXJ0XHJcbi8qIGE0MDcgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY2hlY2sgYXZhaWxhYmxlIG1lbW9yeSwgZG8gb3V0IG9mIG1lbW9yeSBlcnJvciBpZiBubyByb29tXHJcbi8qIGE0MDggKi8gIF9gcmVhc29uX2E0MDhgOyAgQ1BZLnpwZyAoXCJmcmV0b3ArMV8wMDM0XCIpOyAgICAvLyBjb21wYXJlIHdpdGggYm90dG9tIG9mIHN0cmluZyBzcGFjZSBoaWdoIGJ5dGVcclxuLyogYTQwYSAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9hNDM0XCIpOyAgICAgICAgICAgIC8vIGlmIGxlc3MgdGhlbiBleGl0IChpcyBvaylcclxuLyogYTQwYyAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9hNDEyXCIpOyAgICAgICAgICAgIC8vIHNraXAgbmV4dCB0ZXN0IGlmIGdyZWF0ZXIgKHRlc3RlZCA8KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhpZ2ggYnl0ZSB3YXMgPSwgbm93IGRvIGxvdyBieXRlXHJcbi8qIGE0MGUgKi8gICAgICAgICAgICAgICAgICAgQ01QLnpwZyAoXCJmcmV0b3ArMF8wMDMzXCIpOyAgICAvLyBjb21wYXJlIHdpdGggYm90dG9tIG9mIHN0cmluZyBzcGFjZSBsb3cgYnl0ZVxyXG4vKiBhNDEwICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2E0MzRcIik7ICAgICAgICAgICAgLy8gaWYgbGVzcyB0aGVuIGV4aXQgKGlzIG9rKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZHJlc3MgaXMgPiBzdHJpbmcgc3RvcmFnZSBwdHIgKG9vcHMhKVxyXG4vKiBhNDEyICovICAgICAgICBfYF9hNDEyYDsgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggYWRkcmVzcyBsb3cgYnl0ZVxyXG4vKiBhNDEzICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4MDkpOyAgICAgICAgICAgICAgIC8vIHNldCBpbmRleCB0byBzYXZlICQ1NyB0byAkNjAgaW5jbHVzaXZlXHJcbi8qIGE0MTUgKi8gICAgICAgICAgICAgICAgICAgVFlBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBhZGRyZXNzIGhpZ2ggYnl0ZSAodG8gcHVzaCBvbiBzdGFjaylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzYXZlIG1pc2MgbnVtZXJpYyB3b3JrIGFyZWFcclxuLyogYTQxNiAqLyAgICAgICAgX2BfYTQxNmA7ICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdXNoIGJ5dGVcclxuLyogYTQxNyAqLyAgICAgICAgICAgICAgICAgICBMREEuenB4ICgweDU3KTsgICAgICAgICAgICAgICAvLyBnZXQgYnl0ZSBmcm9tICQ1NyB0byAkNjBcclxuLyogYTQxOSAqLyAgICAgICAgICAgICAgICAgICBERVguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBkZWNyZW1lbnQgaW5kZXhcclxuLyogYTQxYSAqLyAgICAgICAgICAgICAgICAgICBCUEwucmVsIChcIl9hNDE2XCIpOyAgICAgICAgICAgIC8vIGxvb3AgdW50aWwgYWxsIGRvbmVcclxuLyogYTQxYyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImdhcmJhZ19iNTI2XCIpOyAgICAgIC8vIGRvIGdhcmJhZ2UgY29sbGVjdGlvbiByb3V0aW5lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBtaXNjIG51bWVyaWMgd29yayBhcmVhXHJcbi8qIGE0MWYgKi8gICAgICAgICAgICAgICAgICAgTERYLmltbSAoMHhmNyk7ICAgICAgICAgICAgICAgLy8gc2V0IGluZGV4IHRvIHJlc3RvcmUgYnl0ZXNcclxuLyogYTQyMSAqLyAgICAgICAgX2BfYTQyMWA7ICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwb3AgYnl0ZVxyXG4vKiBhNDIyICovICAgICAgICAgICAgICAgICAgIFNUQS56cHggKDB4NjEpOyAgICAgICAgICAgICAgIC8vIHNhdmUgYnl0ZSB0byAkNTcgdG8gJDYwXHJcbi8qIGE0MjQgKi8gICAgICAgICAgICAgICAgICAgSU5YLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGluZGV4XHJcbi8qIGE0MjUgKi8gICAgICAgICAgICAgICAgICAgQk1JLnJlbCAoXCJfYTQyMVwiKTsgICAgICAgICAgICAvLyBsb29wIHdoaWxlIC12ZVxyXG4vKiBhNDI3ICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHBvcCBhZGRyZXNzIGhpZ2ggYnl0ZVxyXG4vKiBhNDI4ICovICAgICAgICAgICAgICAgICAgIFRBWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgYmFjayB0byBZXHJcbi8qIGE0MjkgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcG9wIGFkZHJlc3MgbG93IGJ5dGVcclxuLyogYTQyYSAqLyAgICAgICAgICAgICAgICAgICBDUFkuenBnIChcImZyZXRvcCsxXzAwMzRcIik7ICAgIC8vIGNvbXBhcmUgd2l0aCBib3R0b20gb2Ygc3RyaW5nIHNwYWNlIGhpZ2ggYnl0ZVxyXG4vKiBhNDJjICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2E0MzRcIik7ICAgICAgICAgICAgLy8gaWYgbGVzcyB0aGVuIGV4aXQgKGlzIG9rKVxyXG4vKiBhNDJlICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwib21lcnJfYTQzNVwiKTsgICAgICAgLy8gaWYgZ3JlYXRlciBkbyBvdXQgb2YgbWVtb3J5IGVycm9yIHRoZW4gd2FybSBzdGFydFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhpZ2ggYnl0ZSB3YXMgPSwgbm93IGRvIGxvdyBieXRlXHJcbi8qIGE0MzAgKi8gICAgICAgICAgICAgICAgICAgQ01QLnpwZyAoXCJmcmV0b3ArMF8wMDMzXCIpOyAgICAvLyBjb21wYXJlIHdpdGggYm90dG9tIG9mIHN0cmluZyBzcGFjZSBsb3cgYnl0ZVxyXG4vKiBhNDMyICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwib21lcnJfYTQzNVwiKTsgICAgICAgLy8gaWYgPj0gZG8gb3V0IG9mIG1lbW9yeSBlcnJvciB0aGVuIHdhcm0gc3RhcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvayBleGl0LCBjYXJyeSBjbGVhclxyXG4vKiBhNDM0ICovICAgICAgICBfYF9hNDM0YDsgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGRvIG91dCBvZiBtZW1vcnkgZXJyb3IgdGhlbiB3YXJtIHN0YXJ0XHJcbi8qIGE0MzUgKi8gICBfYG9tZXJyX2E0MzVgOyAgTERYLmltbSAoMHgxMCk7ICAgICAgICAgICAgICAgLy8gZXJyb3IgY29kZSAkMTAsIG91dCBvZiBtZW1vcnkgZXJyb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyBlcnJvciAjWCB0aGVuIHdhcm0gc3RhcnRcclxuLyogYTQzNyAqLyAgIF9gZXJyb3JfYTQzN2A7ICBKTVAuaW5kIChcImllcnJvciswXzAzMDBcIik7ICAgIC8vIGRvIGVycm9yIG1lc3NhZ2VcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gZG8gZXJyb3IgI1ggdGhlbiB3YXJtIHN0YXJ0LCB0aGUgZXJyb3IgbWVzc2FnZSB2ZWN0b3IgaXMgaW5pdGlhbGlzZWQgdG8gcG9pbnQgaGVyZVxyXG4vKiBhNDNhICovICAgICAgICAgICAgICAgICAgIFRYQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgZXJyb3IgbnVtYmVyXHJcbi8qIGE0M2IgKi8gICAgICAgICAgICAgICAgICAgQVNMLmFjYyAoKTsgICAgICAgICAgICAgICAgICAgLy8gKjJcclxuLyogYTQzYyAqLyAgICAgICAgICAgICAgICAgICBUQVguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IHRvIGluZGV4XHJcbi8qIGE0M2QgKi8gICAgICAgICAgICAgICAgICAgTERBLmFieCAoMHhhMzI2KTsgICAgICAgICAgICAgLy8gZ2V0IGVycm9yIG1lc3NhZ2UgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBhNDQwICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiaW5kZXgrMF8wMDIyXCIpOyAgICAgLy8gc2F2ZSBpdFxyXG4vKiBhNDQyICovICAgICAgICAgICAgICAgICAgIExEQS5hYnggKDB4YTMyNyk7ICAgICAgICAgICAgIC8vIGdldCBlcnJvciBtZXNzYWdlIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGE0NDUgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJpbmRleCsxXzAwMjNcIik7ICAgICAvLyBzYXZlIGl0XHJcbi8qIGE0NDcgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJjbHJjaG5fZmZjY1wiKTsgICAgICAvLyBjbG9zZSBpbnB1dCBhbmQgb3V0cHV0IGNoYW5uZWxzXHJcbi8qIGE0NGEgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgQVxyXG4vKiBhNDRjICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiY2hhbm5sXzAwMTNcIik7ICAgICAgLy8gY2xlYXIgY3VycmVudCBJL08gY2hhbm5lbCwgZmxhZyBkZWZhdWx0XHJcbi8qIGE0NGUgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJjcmRvX2FhZDdcIik7ICAgICAgICAvLyBwcmludCBDUi9MRlxyXG4vKiBhNDUxICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2FiNDVcIik7ICAgICAgICAgICAgLy8gcHJpbnQgXCI/XCJcclxuLyogYTQ1NCAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBpbmRleFxyXG4vKiBhNDU2ICovICAgICAgICBfYF9hNDU2YDsgIExEQS5pbnkgKFwiaW5kZXgrMF8wMDIyXCIpOyAgICAgLy8gZ2V0IGJ5dGUgZnJvbSBtZXNzYWdlXHJcbi8qIGE0NTggKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBzdGF0dXNcclxuLyogYTQ1OSAqLyAgICAgICAgICAgICAgICAgICBBTkQuaW1tICgweDdmKTsgICAgICAgICAgICAgICAvLyBtYXNrIDB4eHggeHh4eCwgY2xlYXIgYjdcclxuLyogYTQ1YiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9hYjQ3XCIpOyAgICAgICAgICAgIC8vIG91dHB1dCBjaGFyYWN0ZXJcclxuLyogYTQ1ZSAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgaW5kZXhcclxuLyogYTQ1ZiAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIHN0YXR1c1xyXG4vKiBhNDYwICovICAgICAgICAgICAgICAgICAgIEJQTC5yZWwgKFwiX2E0NTZcIik7ICAgICAgICAgICAgLy8gbG9vcCBpZiBjaGFyYWN0ZXIgd2FzIG5vdCBlbmQgbWFya2VyXHJcbi8qIGE0NjIgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfYTY3YVwiKTsgICAgICAgICAgICAvLyBmbHVzaCBCQVNJQyBzdGFjayBhbmQgY2xlYXIgY29udGludWUgcG9pbnRlclxyXG4vKiBhNDY1ICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4NjkpOyAgICAgICAgICAgICAgIC8vIHNldCBcIiBFUlJPUlwiIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYTQ2NyAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweGEzKTsgICAgICAgICAgICAgICAvLyBzZXQgXCIgRVJST1JcIiBwb2ludGVyIGhpZ2ggYnl0ZVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBwcmludCBzdHJpbmcgYW5kIGRvIHdhcm0gc3RhcnQsIGJyZWFrIGVudHJ5XHJcbi8qIGE0NjkgKi8gIF9gZXJyZmluX2E0NjlgOyAgSlNSLmFicyAoXCJzdHJvdXRfYWIxZVwiKTsgICAgICAvLyBwcmludCBudWxsIHRlcm1pbmF0ZWQgc3RyaW5nXHJcbi8qIGE0NmMgKi8gICAgICAgICAgICAgICAgICAgTERZLnpwZyAoXCJjdXJsaW4rMV8wMDNhXCIpOyAgICAvLyBnZXQgY3VycmVudCBsaW5lIG51bWJlciBoaWdoIGJ5dGVcclxuLyogYTQ2ZSAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgaXRcclxuLyogYTQ2ZiAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcInJlYWR5X2E0NzRcIik7ICAgICAgIC8vIGJyYW5jaCBpZiB3YXMgaW4gaW1tZWRpYXRlIG1vZGVcclxuLyogYTQ3MSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImlucHJ0X2JkYzJcIik7ICAgICAgIC8vIGRvIFwiIElOIFwiIGxpbmUgbnVtYmVyIG1lc3NhZ2VcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gZG8gd2FybSBzdGFydFxyXG4vKiBhNDc0ICovICAgX2ByZWFkeV9hNDc0YDsgIExEQS5pbW0gKDB4NzYpOyAgICAgICAgICAgICAgIC8vIHNldCBcIlJFQURZLlwiIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYTQ3NiAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweGEzKTsgICAgICAgICAgICAgICAvLyBzZXQgXCJSRUFEWS5cIiBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBhNDc4ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwic3Ryb3V0X2FiMWVcIik7ICAgICAgLy8gcHJpbnQgbnVsbCB0ZXJtaW5hdGVkIHN0cmluZ1xyXG4vKiBhNDdiICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4ODApOyAgICAgICAgICAgICAgIC8vIHNldCBmb3IgY29udHJvbCBtZXNzYWdlcyBvbmx5XHJcbi8qIGE0N2QgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJzZXRtc2dfZmY5MFwiKTsgICAgICAvLyBjb250cm9sIGtlcm5hbCBtZXNzYWdlc1xyXG4vKiBhNDgwICovICAgIF9gbWFpbl9hNDgwYDsgIEpNUC5pbmQgKFwiaW1haW4rMF8wMzAyXCIpOyAgICAgLy8gZG8gQkFTSUMgd2FybSBzdGFydFxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBCQVNJQyB3YXJtIHN0YXJ0LCB0aGUgd2FybSBzdGFydCB2ZWN0b3IgaXMgaW5pdGlhbGlzZWQgdG8gcG9pbnQgaGVyZVxyXG4vKiBhNDgzICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiaW5saW5fYTU2MFwiKTsgICAgICAgLy8gY2FsbCBmb3IgQkFTSUMgaW5wdXRcclxuLyogYTQ4NiAqLyAgICAgICAgICAgICAgICAgICBTVFguenBnIChcInR4dHB0ciswXzAwN2FcIik7ICAgIC8vIHNhdmUgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGE0ODggKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJ0eHRwdHIrMV8wMDdiXCIpOyAgICAvLyBzYXZlIEJBU0lDIGV4ZWN1dGUgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYTQ4YSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImNocmdldCswXzAwNzNcIik7ICAgIC8vIGluY3JlbWVudCBhbmQgc2NhbiBtZW1vcnlcclxuLyogYTQ4ZCAqLyAgICAgICAgICAgICAgICAgICBUQVguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IGJ5dGUgdG8gc2V0IGZsYWdzXHJcbi8qIGE0OGUgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJtYWluX2E0ODBcIik7ICAgICAgICAvLyBsb29wIGlmIG5vIGlucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ290IHRvIGludGVycHJldCB0aGUgaW5wdXQgbGluZSBub3cgLi4uLlxyXG4vKiBhNDkwICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4ZmYpOyAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgbGluZSBoaWdoIGJ5dGUgdG8gLTEsIGluZGljYXRlcyBpbW1lZGlhdGUgbW9kZVxyXG4vKiBhNDkyICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwiY3VybGluKzFfMDAzYVwiKTsgICAgLy8gc2V0IGN1cnJlbnQgbGluZSBudW1iZXIgaGlnaCBieXRlXHJcbi8qIGE0OTQgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJtYWluMV9hNDljXCIpOyAgICAgICAvLyBpZiBudW1lcmljIGNoYXJhY3RlciBnbyBoYW5kbGUgbmV3IEJBU0lDIGxpbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBubyBsaW5lIG51bWJlciAuLiBpbW1lZGlhdGUgbW9kZVxyXG4vKiBhNDk2ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiY3J1bmNoX2E1NzlcIik7ICAgICAgLy8gY3J1bmNoIGtleXdvcmRzIGludG8gQkFTSUMgdG9rZW5zXHJcbi8qIGE0OTkgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfYTdlMVwiKTsgICAgICAgICAgICAvLyBnbyBzY2FuIGFuZCBpbnRlcnByZXQgY29kZVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBoYW5kbGUgbmV3IEJBU0lDIGxpbmVcclxuLyogYTQ5YyAqLyAgIF9gbWFpbjFfYTQ5Y2A7ICBKU1IuYWJzIChcImxpbmdldF9hOTZiXCIpOyAgICAgIC8vIGdldCBmaXhlZC1wb2ludCBudW1iZXIgaW50byB0ZW1wb3JhcnkgaW50ZWdlclxyXG4vKiBhNDlmICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiY3J1bmNoX2E1NzlcIik7ICAgICAgLy8gY3J1bmNoIGtleXdvcmRzIGludG8gQkFTSUMgdG9rZW5zXHJcbi8qIGE0YTIgKi8gIF9gaW5zbGluX2E0YTJgOyAgU1RZLnpwZyAoXCJjb3VudF8wMDBiXCIpOyAgICAgICAvLyBzYXZlIGluZGV4IHBvaW50ZXIgdG8gZW5kIG9mIGNydW5jaGVkIGxpbmVcclxuLyogYTRhNCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImZuZGxpbl9hNjEzXCIpOyAgICAgIC8vIHNlYXJjaCBCQVNJQyBmb3IgdGVtcG9yYXJ5IGludGVnZXIgbGluZSBudW1iZXJcclxuLyogYTRhNyAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9hNGVkXCIpOyAgICAgICAgICAgIC8vIGlmIG5vdCBmb3VuZCBza2lwIHRoZSBsaW5lIGRlbGV0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxpbmUgIyBhbHJlYWR5IGV4aXN0cyBzbyBkZWxldGUgaXRcclxuLyogYTRhOSAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAxKTsgICAgICAgICAgICAgICAvLyBzZXQgaW5kZXggdG8gbmV4dCBsaW5lIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGE0YWIgKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJ0ZW1wZjIrM18wMDVmXCIpOyAgICAvLyBnZXQgbmV4dCBsaW5lIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGE0YWQgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJpbmRleCsxXzAwMjNcIik7ICAgICAvLyBzYXZlIGl0XHJcbi8qIGE0YWYgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ2YXJ0YWIrMF8wMDJkXCIpOyAgICAvLyBnZXQgc3RhcnQgb2YgdmFyaWFibGVzIGxvdyBieXRlXHJcbi8qIGE0YjEgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJpbmRleCswXzAwMjJcIik7ICAgICAvLyBzYXZlIGl0XHJcbi8qIGE0YjMgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ0ZW1wZjIrNF8wMDYwXCIpOyAgICAvLyBnZXQgZm91bmQgbGluZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBhNGI1ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiaW5kZXgrM18wMDI1XCIpOyAgICAgLy8gc2F2ZSBpdFxyXG4vKiBhNGI3ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwidGVtcGYyKzNfMDA1ZlwiKTsgICAgLy8gZ2V0IGZvdW5kIGxpbmUgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBhNGI5ICovICAgICAgICAgICAgICAgICAgIERFWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCBpbmRleFxyXG4vKiBhNGJhICovICAgICAgICAgICAgICAgICAgIFNCQy5pbnkgKFwidGVtcGYyKzNfMDA1ZlwiKTsgICAgLy8gc3VidHJhY3QgbmV4dCBsaW5lIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYTRiYyAqLyAgICAgICAgICAgICAgICAgICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBjYXJyeSBmb3IgYWRkXHJcbi8qIGE0YmQgKi8gICAgICAgICAgICAgICAgICAgQURDLnpwZyAoXCJ2YXJ0YWIrMF8wMDJkXCIpOyAgICAvLyBhZGQgc3RhcnQgb2YgdmFyaWFibGVzIGxvdyBieXRlXHJcbi8qIGE0YmYgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJ2YXJ0YWIrMF8wMDJkXCIpOyAgICAvLyBzZXQgc3RhcnQgb2YgdmFyaWFibGVzIGxvdyBieXRlXHJcbi8qIGE0YzEgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJpbmRleCsyXzAwMjRcIik7ICAgICAvLyBzYXZlIGRlc3RpbmF0aW9uIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYTRjMyAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInZhcnRhYisxXzAwMmVcIik7ICAgIC8vIGdldCBzdGFydCBvZiB2YXJpYWJsZXMgaGlnaCBieXRlXHJcbi8qIGE0YzUgKi8gICAgICAgICAgICAgICAgICAgQURDLmltbSAoMHhmZik7ICAgICAgICAgICAgICAgLy8gLTEgKyBjYXJyeVxyXG4vKiBhNGM3ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwidmFydGFiKzFfMDAyZVwiKTsgICAgLy8gc2V0IHN0YXJ0IG9mIHZhcmlhYmxlcyBoaWdoIGJ5dGVcclxuLyogYTRjOSAqLyAgICAgICAgICAgICAgICAgICBTQkMuenBnIChcInRlbXBmMis0XzAwNjBcIik7ICAgIC8vIHN1YnRyYWN0IGZvdW5kIGxpbmUgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYTRjYiAqLyAgICAgICAgICAgICAgICAgICBUQVguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IHRvIGJsb2NrIGNvdW50XHJcbi8qIGE0Y2MgKi8gICAgICAgICAgICAgICAgICAgU0VDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2V0IGNhcnJ5IGZvciBzdWJ0cmFjdFxyXG4vKiBhNGNkICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwidGVtcGYyKzNfMDA1ZlwiKTsgICAgLy8gZ2V0IGZvdW5kIGxpbmUgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBhNGNmICovICAgICAgICAgICAgICAgICAgIFNCQy56cGcgKFwidmFydGFiKzBfMDAyZFwiKTsgICAgLy8gc3VidHJhY3Qgc3RhcnQgb2YgdmFyaWFibGVzIGxvdyBieXRlXHJcbi8qIGE0ZDEgKi8gICAgICAgICAgICAgICAgICAgVEFZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSB0byBieXRlcyBpbiBmaXJzdCBibG9jayBjb3VudFxyXG4vKiBhNGQyICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2E0ZDdcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vIHVuZGVyZmxvd1xyXG4vKiBhNGQ0ICovICAgICAgICAgICAgICAgICAgIElOWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBibG9jayBjb3VudCwgY29ycmVjdCBmb3IgPSAwIGxvb3AgZXhpdFxyXG4vKiBhNGQ1ICovICAgICAgICAgICAgICAgICAgIERFQy56cGcgKFwiaW5kZXgrM18wMDI1XCIpOyAgICAgLy8gZGVjcmVtZW50IGRlc3RpbmF0aW9uIGhpZ2ggYnl0ZVxyXG4vKiBhNGQ3ICovICAgICAgICBfYF9hNGQ3YDsgIENMQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIGNhcnJ5IGZvciBhZGRcclxuLyogYTRkOCAqLyAgICAgICAgICAgICAgICAgICBBREMuenBnIChcImluZGV4KzBfMDAyMlwiKTsgICAgIC8vIGFkZCBzb3VyY2UgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBhNGRhICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2E0ZGZcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vIG92ZXJmbG93XHJcbi8qIGE0ZGMgKi8gICAgICAgICAgICAgICAgICAgREVDLnpwZyAoXCJpbmRleCsxXzAwMjNcIik7ICAgICAvLyBlbHNlIGRlY3JlbWVudCBzb3VyY2UgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYTRkZSAqLyAgICAgICAgICAgICAgICAgICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBjYXJyeVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNsb3NlIHVwIG1lbW9yeSB0byBkZWxldGUgb2xkIGxpbmVcclxuLyogYTRkZiAqLyAgICAgICAgX2BfYTRkZmA7ICBMREEuaW55IChcImluZGV4KzBfMDAyMlwiKTsgICAgIC8vIGdldCBieXRlIGZyb20gc291cmNlXHJcbi8qIGE0ZTEgKi8gICAgICAgICAgICAgICAgICAgU1RBLmlueSAoXCJpbmRleCsyXzAwMjRcIik7ICAgICAvLyBjb3B5IHRvIGRlc3RpbmF0aW9uXHJcbi8qIGE0ZTMgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGluZGV4XHJcbi8qIGE0ZTQgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYTRkZlwiKTsgICAgICAgICAgICAvLyB3aGlsZSA8PiAwIGRvIHRoaXMgYmxvY2tcclxuLyogYTRlNiAqLyAgICAgICAgICAgICAgICAgICBJTkMuenBnIChcImluZGV4KzFfMDAyM1wiKTsgICAgIC8vIGluY3JlbWVudCBzb3VyY2UgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYTRlOCAqLyAgICAgICAgICAgICAgICAgICBJTkMuenBnIChcImluZGV4KzNfMDAyNVwiKTsgICAgIC8vIGluY3JlbWVudCBkZXN0aW5hdGlvbiBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBhNGVhICovICAgICAgICAgICAgICAgICAgIERFWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCBibG9jayBjb3VudFxyXG4vKiBhNGViICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2E0ZGZcIik7ICAgICAgICAgICAgLy8gbG9vcCB1bnRpbCBhbGwgZG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdvdCBuZXcgbGluZSBpbiBidWZmZXIgYW5kIG5vIGV4aXN0aW5nIHNhbWUgI1xyXG4vKiBhNGVkICovICAgICAgICBfYF9hNGVkYDsgIEpTUi5hYnMgKFwiX2E2NTlcIik7ICAgICAgICAgICAgLy8gcmVzZXQgZXhlY3V0aW9uIHRvIHN0YXJ0LCBjbGVhciB2YXJpYWJsZXMsIGZsdXNoIHN0YWNrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHJldHVyblxyXG4vKiBhNGYwICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwibGlua3ByZ19hNTMzXCIpOyAgICAgLy8gcmVidWlsZCBCQVNJQyBsaW5lIGNoYWluaW5nXHJcbi8qIGE0ZjMgKi8gICAgICAgICAgICAgICAgICAgTERBLmFicyAoXCJidWYrMF8wMjAwXCIpOyAgICAgICAvLyBnZXQgZmlyc3QgYnl0ZSBmcm9tIGJ1ZmZlclxyXG4vKiBhNGY2ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwibWFpbl9hNDgwXCIpOyAgICAgICAgLy8gaWYgbm8gbGluZSBnbyBkbyBCQVNJQyB3YXJtIHN0YXJ0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBpbnNlcnQgbGluZSBpbnRvIG1lbW9yeVxyXG4vKiBhNGY4ICovICAgICAgICAgICAgICAgICAgIENMQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIGNhcnJ5IGZvciBhZGRcclxuLyogYTRmOSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInZhcnRhYiswXzAwMmRcIik7ICAgIC8vIGdldCBzdGFydCBvZiB2YXJpYWJsZXMgbG93IGJ5dGVcclxuLyogYTRmYiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInRlbXBmMSszXzAwNWFcIik7ICAgIC8vIHNhdmUgYXMgc291cmNlIGVuZCBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGE0ZmQgKi8gICAgICAgICAgICAgICAgICAgQURDLnpwZyAoXCJjb3VudF8wMDBiXCIpOyAgICAgICAvLyBhZGQgaW5kZXggcG9pbnRlciB0byBlbmQgb2YgY3J1bmNoZWQgbGluZVxyXG4vKiBhNGZmICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwidGVtcGYxKzFfMDA1OFwiKTsgICAgLy8gc2F2ZSBhcyBkZXN0aW5hdGlvbiBlbmQgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBhNTAxICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwidmFydGFiKzFfMDAyZVwiKTsgICAgLy8gZ2V0IHN0YXJ0IG9mIHZhcmlhYmxlcyBoaWdoIGJ5dGVcclxuLyogYTUwMyAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcInRlbXBmMSs0XzAwNWJcIik7ICAgIC8vIHNhdmUgYXMgc291cmNlIGVuZCBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBhNTA1ICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2E1MDhcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vIGNhcnJ5IHRvIGhpZ2ggYnl0ZVxyXG4vKiBhNTA3ICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgaW5jcmVtZW50IGhpZ2ggYnl0ZVxyXG4vKiBhNTA4ICovICAgICAgICBfYF9hNTA4YDsgIFNUWS56cGcgKFwidGVtcGYxKzJfMDA1OVwiKTsgICAgLy8gc2F2ZSBhcyBkZXN0aW5hdGlvbiBlbmQgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYTUwYSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImJsdHVfYTNiOFwiKTsgICAgICAgIC8vIG9wZW4gdXAgc3BhY2UgaW4gbWVtb3J5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW9zdCBvZiB3aGF0IHJlbWFpbnMgdG8gZG8gaXMgY29weSB0aGUgY3J1bmNoZWQgbGluZSBpbnRvIHRoZSBzcGFjZSBvcGVuZWQgdXAgaW4gbWVtb3J5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhvd2V2ZXIsIGJlZm9yZSB0aGUgY3J1bmNoZWQgbGluZSBjb21lcyB0aGUgbmV4dCBsaW5lIHBvaW50ZXIgYW5kIHRoZSBsaW5lIG51bWJlci4gdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGluZSBudW1iZXIgaXMgcmV0cmlldmVkIGZyb20gdGhlIHRlbXBvcmFyeSBpbnRlZ2VyIGFuZCBzdG9yZWQgaW4gbWVtb3J5LCB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3ZlcndyaXRlcyB0aGUgYm90dG9tIHR3byBieXRlcyBvbiB0aGUgc3RhY2suIG5leHQgdGhlIGxpbmUgaXMgY29waWVkIGFuZCB0aGUgbmV4dCBsaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnRlciBpcyBmaWxsZWQgd2l0aCB3aGF0ZXZlciB3YXMgaW4gdHdvIGJ5dGVzIGFib3ZlIHRoZSBsaW5lIG51bWJlciBpbiB0aGUgc3RhY2suXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBvayBiZWNhdXNlIHRoZSBsaW5lIHBvaW50ZXIgZ2V0cyBmaXhlZCBpbiB0aGUgbGluZSBjaGFpbiByZS1idWlsZC5cclxuLyogYTUwZCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImxpbm51bSswXzAwMTRcIik7ICAgIC8vIGdldCBsaW5lIG51bWJlciBsb3cgYnl0ZVxyXG4vKiBhNTBmICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwibGlubnVtKzFfMDAxNVwiKTsgICAgLy8gZ2V0IGxpbmUgbnVtYmVyIGhpZ2ggYnl0ZVxyXG4vKiBhNTExICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiYnN0YWNrKzE5MV8wMWZlXCIpOyAgLy8gc2F2ZSBsaW5lIG51bWJlciBsb3cgYnl0ZSBiZWZvcmUgY3J1bmNoZWQgbGluZVxyXG4vKiBhNTE0ICovICAgICAgICAgICAgICAgICAgIFNUWS5hYnMgKFwiYnN0YWNrKzE5Ml8wMWZmXCIpOyAgLy8gc2F2ZSBsaW5lIG51bWJlciBoaWdoIGJ5dGUgYmVmb3JlIGNydW5jaGVkIGxpbmVcclxuLyogYTUxNyAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInN0cmVuZCswXzAwMzFcIik7ICAgIC8vIGdldCBlbmQgb2YgYXJyYXlzIGxvdyBieXRlXHJcbi8qIGE1MTkgKi8gICAgICAgICAgICAgICAgICAgTERZLnpwZyAoXCJzdHJlbmQrMV8wMDMyXCIpOyAgICAvLyBnZXQgZW5kIG9mIGFycmF5cyBoaWdoIGJ5dGVcclxuLyogYTUxYiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInZhcnRhYiswXzAwMmRcIik7ICAgIC8vIHNldCBzdGFydCBvZiB2YXJpYWJsZXMgbG93IGJ5dGVcclxuLyogYTUxZCAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcInZhcnRhYisxXzAwMmVcIik7ICAgIC8vIHNldCBzdGFydCBvZiB2YXJpYWJsZXMgaGlnaCBieXRlXHJcbi8qIGE1MWYgKi8gICAgICAgICAgICAgICAgICAgTERZLnpwZyAoXCJjb3VudF8wMDBiXCIpOyAgICAgICAvLyBnZXQgaW5kZXggdG8gZW5kIG9mIGNydW5jaGVkIGxpbmVcclxuLyogYTUyMSAqLyAgICAgICAgICAgICAgICAgICBERVkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyAtMVxyXG4vKiBhNTIyICovICAgICAgICBfYF9hNTIyYDsgIExEQS5hYnkgKFwiYnN0YWNrKzE4OV8wMWZjXCIpOyAgLy8gZ2V0IGJ5dGUgZnJvbSBjcnVuY2hlZCBsaW5lXHJcbi8qIGE1MjUgKi8gICAgICAgICAgICAgICAgICAgU1RBLmlueSAoXCJ0ZW1wZjIrM18wMDVmXCIpOyAgICAvLyBzYXZlIGJ5dGUgdG8gbWVtb3J5XHJcbi8qIGE1MjcgKi8gICAgICAgICAgICAgICAgICAgREVZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZGVjcmVtZW50IGluZGV4XHJcbi8qIGE1MjggKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfYTUyMlwiKTsgICAgICAgICAgICAvLyBsb29wIHdoaWxlIG1vcmUgdG8gZG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXNldCBleGVjdXRpb24sIGNsZWFyIHZhcmlhYmxlcywgZmx1c2ggc3RhY2ssIHJlYnVpbGQgQkFTSUMgY2hhaW4gYW5kIGRvIHdhcm0gc3RhcnRcclxuLyogYTUyYSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9hNjU5XCIpOyAgICAgICAgICAgIC8vIHJlc2V0IGV4ZWN1dGlvbiB0byBzdGFydCwgY2xlYXIgdmFyaWFibGVzIGFuZCBmbHVzaCBzdGFja1xyXG4vKiBhNTJkICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwibGlua3ByZ19hNTMzXCIpOyAgICAgLy8gcmVidWlsZCBCQVNJQyBsaW5lIGNoYWluaW5nXHJcbi8qIGE1MzAgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJtYWluX2E0ODBcIik7ICAgICAgICAvLyBnbyBkbyBCQVNJQyB3YXJtIHN0YXJ0XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHJlYnVpbGQgQkFTSUMgbGluZSBjaGFpbmluZ1xyXG4vKiBhNTMzICovIF9gbGlua3ByZ19hNTMzYDsgIExEQS56cGcgKFwidHh0dGFiKzBfMDAyYlwiKTsgICAgLy8gZ2V0IHN0YXJ0IG9mIG1lbW9yeSBsb3cgYnl0ZVxyXG4vKiBhNTM1ICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwidHh0dGFiKzFfMDAyY1wiKTsgICAgLy8gZ2V0IHN0YXJ0IG9mIG1lbW9yeSBoaWdoIGJ5dGVcclxuLyogYTUzNyAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImluZGV4KzBfMDAyMlwiKTsgICAgIC8vIHNldCBsaW5lIHN0YXJ0IHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYTUzOSAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcImluZGV4KzFfMDAyM1wiKTsgICAgIC8vIHNldCBsaW5lIHN0YXJ0IHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGE1M2IgKi8gICAgICAgICAgICAgICAgICAgQ0xDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgY2FycnkgZm9yIGFkZFxyXG4vKiBhNTNjICovICAgICAgICBfYF9hNTNjYDsgIExEWS5pbW0gKDB4MDEpOyAgICAgICAgICAgICAgIC8vIHNldCBpbmRleCB0byBwb2ludGVyIHRvIG5leHQgbGluZSBoaWdoIGJ5dGVcclxuLyogYTUzZSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcImluZGV4KzBfMDAyMlwiKTsgICAgIC8vIGdldCBwb2ludGVyIHRvIG5leHQgbGluZSBoaWdoIGJ5dGVcclxuLyogYTU0MCAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9hNTVmXCIpOyAgICAgICAgICAgIC8vIGV4aXQgaWYgbnVsbCwgW0VPVF1cclxuLyogYTU0MiAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDA0KTsgICAgICAgICAgICAgICAvLyBwb2ludCB0byBmaXJzdCBjb2RlIGJ5dGUgb2YgbGluZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIGFsd2F5cyAxIGJ5dGUgKyBbRU9MXSBhcyBudWxsIGVudHJpZXMgYXJlIGRlbGV0ZWRcclxuLyogYTU0NCAqLyAgICAgICAgX2BfYTU0NGA7ICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGNvZGUgYnl0ZVxyXG4vKiBhNTQ1ICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwiaW5kZXgrMF8wMDIyXCIpOyAgICAgLy8gZ2V0IGJ5dGVcclxuLyogYTU0NyAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9hNTQ0XCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgbm90IFtFT0xdXHJcbi8qIGE1NDkgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcG9pbnQgdG8gYnl0ZSBwYXN0IFtFT0xdLCBzdGFydCBvZiBuZXh0IGxpbmVcclxuLyogYTU0YSAqLyAgICAgICAgICAgICAgICAgICBUWUEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IGl0XHJcbi8qIGE1NGIgKi8gICAgICAgICAgICAgICAgICAgQURDLnpwZyAoXCJpbmRleCswXzAwMjJcIik7ICAgICAvLyBhZGQgbGluZSBzdGFydCBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGE1NGQgKi8gICAgICAgICAgICAgICAgICAgVEFYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSB0byBYXHJcbi8qIGE1NGUgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgaW5kZXgsIHBvaW50IHRvIHRoaXMgbGluZSdzIG5leHQgbGluZSBwb2ludGVyXHJcbi8qIGE1NTAgKi8gICAgICAgICAgICAgICAgICAgU1RBLmlueSAoXCJpbmRleCswXzAwMjJcIik7ICAgICAvLyBzZXQgbmV4dCBsaW5lIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYTU1MiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImluZGV4KzFfMDAyM1wiKTsgICAgIC8vIGdldCBsaW5lIHN0YXJ0IHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGE1NTQgKi8gICAgICAgICAgICAgICAgICAgQURDLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gYWRkIGFueSBvdmVyZmxvd1xyXG4vKiBhNTU2ICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBpbmRleCB0byBoaWdoIGJ5dGVcclxuLyogYTU1NyAqLyAgICAgICAgICAgICAgICAgICBTVEEuaW55IChcImluZGV4KzBfMDAyMlwiKTsgICAgIC8vIHNldCBuZXh0IGxpbmUgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYTU1OSAqLyAgICAgICAgICAgICAgICAgICBTVFguenBnIChcImluZGV4KzBfMDAyMlwiKTsgICAgIC8vIHNldCBsaW5lIHN0YXJ0IHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYTU1YiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImluZGV4KzFfMDAyM1wiKTsgICAgIC8vIHNldCBsaW5lIHN0YXJ0IHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGE1NWQgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYTUzY1wiKTsgICAgICAgICAgICAvLyBnbyBkbyBuZXh0IGxpbmUsIGJyYW5jaCBhbHdheXNcclxuLyogYTU1ZiAqLyAgICAgICAgX2BfYTU1ZmA7ICBSVFMuaW1wICgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGwgZm9yIEJBU0lDIGlucHV0XHJcbi8qIGE1NjAgKi8gICBfYGlubGluX2E1NjBgOyAgTERYLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gc2V0IGNoYW5uZWwgJDAwLCBrZXlib2FyZFxyXG4vKiBhNTYyICovICAgICAgICBfYF9hNTYyYDsgIEpTUi5hYnMgKFwiYmNoaW5fZTExMlwiKTsgICAgICAgLy8gaW5wdXQgY2hhcmFjdGVyIGZyb20gY2hhbm5lbCB3aXRoIGVycm9yIGNoZWNrXHJcbi8qIGE1NjUgKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHgwZCk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIFtDUl1cclxuLyogYTU2NyAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9hNTc2XCIpOyAgICAgICAgICAgIC8vIGlmIFtDUl0gc2V0IFhZIHRvICQyMDAgLSAxLCBwcmludCBbQ1JdIGFuZCBleGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyIHdhcyBub3QgW0NSXVxyXG4vKiBhNTY5ICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnggKFwiYnVmKzBfMDIwMFwiKTsgICAgICAgLy8gc2F2ZSBjaGFyYWN0ZXIgdG8gYnVmZmVyXHJcbi8qIGE1NmMgKi8gICAgICAgICAgICAgICAgICAgSU5YLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGJ1ZmZlciBpbmRleFxyXG4vKiBhNTZkICovICAgICAgICAgICAgICAgICAgIENQWC5pbW0gKDB4NTkpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCBtYXgrMVxyXG4vKiBhNTZmICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2E1NjJcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIDwgbWF4KzFcclxuLyogYTU3MSAqLyAgICAgICAgICAgICAgICAgICBMRFguaW1tICgweDE3KTsgICAgICAgICAgICAgICAvLyBlcnJvciAkMTcsIHN0cmluZyB0b28gbG9uZyBlcnJvclxyXG4vKiBhNTczICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiZXJyb3JfYTQzN1wiKTsgICAgICAgLy8gZG8gZXJyb3IgI1ggdGhlbiB3YXJtIHN0YXJ0XHJcbi8qIGE1NzYgKi8gICAgICAgIF9gX2E1NzZgOyAgSk1QLmFicyAoXCJfYWFjYVwiKTsgICAgICAgICAgICAvLyBzZXQgWFkgdG8gJDIwMCAtIDEgYW5kIHByaW50IFtDUl1cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY3J1bmNoIEJBU0lDIHRva2VucyB2ZWN0b3JcclxuLyogYTU3OSAqLyAgX2BjcnVuY2hfYTU3OWA7ICBKTVAuaW5kIChcImljcm5jaCswXzAzMDRcIik7ICAgIC8vIGRvIGNydW5jaCBCQVNJQyB0b2tlbnNcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY3J1bmNoIEJBU0lDIHRva2VucywgdGhlIGNydW5jaCBCQVNJQyB0b2tlbnMgdmVjdG9yIGlzIGluaXRpYWxpc2VkIHRvIHBvaW50IGhlcmVcclxuLyogYTU3YyAqLyAgICAgICAgICAgICAgICAgICBMRFguenBnIChcInR4dHB0ciswXzAwN2FcIik7ICAgIC8vIGdldCBCQVNJQyBleGVjdXRlIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYTU3ZSAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDA0KTsgICAgICAgICAgICAgICAvLyBzZXQgc2F2ZSBpbmRleFxyXG4vKiBhNTgwICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwiZ2FyYmZsXzAwMGZcIik7ICAgICAgLy8gY2xlYXIgb3BlbiBxdW90ZS9EQVRBIGZsYWdcclxuLyogYTU4MiAqLyAgICAgICAgX2BfYTU4MmA7ICBMREEuYWJ4IChcImJ1ZiswXzAyMDBcIik7ICAgICAgIC8vIGdldCBhIGJ5dGUgZnJvbSB0aGUgaW5wdXQgYnVmZmVyXHJcbi8qIGE1ODUgKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfYTU4ZVwiKTsgICAgICAgICAgICAvLyBpZiBiNyBjbGVhciBnbyBkbyBjcnVuY2hpbmdcclxuLyogYTU4NyAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW1tICgweGZmKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggdGhlIHRva2VuIGZvciBQSSwgdGhpcyB0b2tlIGlzIGlucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlyZWN0bHkgZnJvbSB0aGUga2V5Ym9hcmQgYXMgdGhlIFBJIGNoYXJhY3RlclxyXG4vKiBhNTg5ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2E1YzlcIik7ICAgICAgICAgICAgLy8gaWYgUEkgc2F2ZSBieXRlIHRoZW4gY29udGludWUgY3J1bmNoaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgYml0IG9mIGNvZGUgdGhhdCBzdG9wcyB5b3UgYmVpbmcgYWJsZSB0byBlbnRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvbWUga2V5d29yZHMgYXMganVzdCBzaW5nbGUgc2hpZnRlZCBjaGFyYWN0ZXJzLiBJZiB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZHJvcHBlZCB0aHJvdWdoIHlvdSB3b3VsZCBiZSBhYmxlIHRvIGVudGVyIEdPVE8gYXMganVzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFtTSElGVF1HXHJcbi8qIGE1OGIgKi8gICAgICAgICAgICAgICAgICAgSU5YLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IHJlYWQgaW5kZXhcclxuLyogYTU4YyAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9hNTgyXCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgbW9yZSB0byBkbywgYnJhbmNoIGFsd2F5c1xyXG4vKiBhNThlICovICAgICAgICBfYF9hNThlYDsgIENNUC5pbW0gKDB4MjApOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCBbU1BBQ0VdXHJcbi8qIGE1OTAgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYTVjOVwiKTsgICAgICAgICAgICAvLyBpZiBbU1BBQ0VdIHNhdmUgYnl0ZSB0aGVuIGNvbnRpbnVlIGNydW5jaGluZ1xyXG4vKiBhNTkyICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZW5kY2hyXzAwMDhcIik7ICAgICAgLy8gc2F2ZSBidWZmZXIgYnl0ZSBhcyBzZWFyY2ggY2hhcmFjdGVyXHJcbi8qIGE1OTQgKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHgyMik7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIHF1b3RlIGNoYXJhY3RlclxyXG4vKiBhNTk2ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2E1ZWVcIik7ICAgICAgICAgICAgLy8gaWYgcXVvdGUgZ28gY29weSBxdW90ZWQgc3RyaW5nXHJcbi8qIGE1OTggKi8gICAgICAgICAgICAgICAgICAgQklULnpwZyAoXCJnYXJiZmxfMDAwZlwiKTsgICAgICAvLyBnZXQgb3BlbiBxdW90ZS9EQVRBIHRva2VuIGZsYWdcclxuLyogYTU5YSAqLyAgICAgICAgICAgICAgICAgICBCVlMucmVsIChcIl9hNWM5XCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBiNiBvZiBPcXVvdGUgc2V0LCB3YXMgREFUQVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdvIHNhdmUgYnl0ZSB0aGVuIGNvbnRpbnVlIGNydW5jaGluZ1xyXG4vKiBhNTljICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4M2YpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCBcIj9cIiBjaGFyYWN0ZXJcclxuLyogYTU5ZSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9hNWE0XCIpOyAgICAgICAgICAgIC8vIGlmIG5vdCBcIj9cIiBjb250aW51ZSBjcnVuY2hpbmdcclxuLyogYTVhMCAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDk5KTsgICAgICAgICAgICAgICAvLyBlbHNlIHRoZSBrZXl3b3JkIHRva2VuIGlzICQ5OSwgUFJJTlRcclxuLyogYTVhMiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9hNWM5XCIpOyAgICAgICAgICAgIC8vIGdvIHNhdmUgYnl0ZSB0aGVuIGNvbnRpbnVlIGNydW5jaGluZywgYnJhbmNoIGFsd2F5c1xyXG4vKiBhNWE0ICovICAgICAgICBfYF9hNWE0YDsgIENNUC5pbW0gKDB4MzApOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCBcIjBcIlxyXG4vKiBhNWE2ICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2E1YWNcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIDwsIGNvbnRpbnVlIGNydW5jaGluZ1xyXG4vKiBhNWE4ICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4M2MpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCBcIjxcIlxyXG4vKiBhNWFhICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2E1YzlcIik7ICAgICAgICAgICAgLy8gaWYgPCwgMDEyMzQ1Njc4OTo7IGdvIHNhdmUgYnl0ZSB0aGVuIGNvbnRpbnVlIGNydW5jaGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldHMgaGVyZSB3aXRoIG5leHQgY2hhcmFjdGVyIG5vdCBudW1lcmljLCBcIjtcIiBvciBcIjpcIlxyXG4vKiBhNWFjICovICAgICAgICBfYF9hNWFjYDsgIFNUWS56cGcgKFwiZmJ1ZnB0KzBfMDA3MVwiKTsgICAgLy8gY29weSBzYXZlIGluZGV4XHJcbi8qIGE1YWUgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgdGFibGUgcG9pbnRlclxyXG4vKiBhNWIwICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwiY291bnRfMDAwYlwiKTsgICAgICAgLy8gY2xlYXIgd29yZCBpbmRleFxyXG4vKiBhNWIyICovICAgICAgICAgICAgICAgICAgIERFWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGFkanVzdCBmb3IgcHJlIGluY3JlbWVudCBsb29wXHJcbi8qIGE1YjMgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJ0eHRwdHIrMF8wMDdhXCIpOyAgICAvLyBzYXZlIEJBU0lDIGV4ZWN1dGUgcG9pbnRlciBsb3cgYnl0ZSwgYnVmZmVyIGluZGV4XHJcbi8qIGE1YjUgKi8gICAgICAgICAgICAgICAgICAgREVYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gYWRqdXN0IGZvciBwcmUgaW5jcmVtZW50IGxvb3BcclxuLyogYTViNiAqLyAgICAgICAgX2BfYTViNmA7ICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IHRhYmxlIGJ5dGVcclxuLyogYTViNyAqLyAgICAgICAgICAgICAgICAgICBJTlguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGJ1ZmZlciBieXRlXHJcbi8qIGE1YjggKi8gICAgICAgIF9gX2E1YjhgOyAgTERBLmFieCAoXCJidWYrMF8wMjAwXCIpOyAgICAgICAvLyBnZXQgYnl0ZSBmcm9tIGlucHV0IGJ1ZmZlclxyXG4vKiBhNWJiICovICAgICAgICAgICAgICAgICAgIFNFQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNldCBjYXJyeSBmb3Igc3VidHJhY3RcclxuLyogYTViYyAqLyAgICAgICAgICAgICAgICAgICBTQkMuYWJ5IChcInJlc2xzdF9hMDllXCIpOyAgICAgIC8vIHN1YnRyYWN0IHRhYmxlIGJ5dGVcclxuLyogYTViZiAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9hNWI2XCIpOyAgICAgICAgICAgIC8vIGdvIGNvbXBhcmUgbmV4dCBpZiBtYXRjaFxyXG4vKiBhNWMxICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4ODApOyAgICAgICAgICAgICAgIC8vIHdhcyBpdCBlbmQgbWFya2VyIG1hdGNoID9cclxuLyogYTVjMyAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9hNWY1XCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBub3QsIG5vdCBmb3VuZCBrZXl3b3JkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWN0dWFsbHkgdGhpcyB3b3JrcyBldmVuIGlmIHRoZSBpbnB1dCBidWZmZXIgYnl0ZSBpcyB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbmQgbWFya2VyLCBpLmUuIGEgc2hpZnRlZCBjaGFyYWN0ZXIuIEFzIHlvdSBjYW4ndCBlbnRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFueSBrZXl3b3JkcyBhcyBhIHNpbmdsZSBzaGlmdGVkIGNoYXJhY3Rlciwgc2VlIGFib3ZlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHlvdSBjYW4gZW50ZXIga2V5d29yZHMgaW4gc2hvcnRoYW5kIGJ5IHNoaWZ0aW5nIGFueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoYXJhY3RlciBhZnRlciB0aGUgZmlyc3QuIHNvIFJFVFVSTiBjYW4gYmUgZW50ZXJlZCBhc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJbU0hJRlRdRSwgUkVbU0hJRlRdVCwgUkVUW1NISUZUXVUgb3IgUkVUVVtTSElGVF1SLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJFVFVSW1NISUZUXU4gaG93ZXZlciB3aWxsIG5vdCB3b3JrIGJlY2F1c2UgdGhlIFtTSElGVF1OXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgUkVUVVJOIGVuZCBtYXJrZXIgc28gdGhlIHJvdXRpbmUgd2lsbCB0cnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBtYXRjaCB0aGUgbmV4dCBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBmb3VuZCBrZXl3b3JkXHJcbi8qIGE1YzUgKi8gICAgICAgICAgICAgICAgICAgT1JBLnpwZyAoXCJjb3VudF8wMDBiXCIpOyAgICAgICAvLyBPUiB3aXRoIHdvcmQgaW5kZXgsICskODAgaW4gQSBtYWtlcyB0b2tlblxyXG4vKiBhNWM3ICovICAgICAgICBfYF9hNWM3YDsgIExEWS56cGcgKFwiZmJ1ZnB0KzBfMDA3MVwiKTsgICAgLy8gcmVzdG9yZSBzYXZlIGluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBieXRlIHRoZW4gY29udGludWUgY3J1bmNoaW5nXHJcbi8qIGE1YzkgKi8gICAgICAgIF9gX2E1YzlgOyAgSU5YLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGJ1ZmZlciByZWFkIGluZGV4XHJcbi8qIGE1Y2EgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IHNhdmUgaW5kZXhcclxuLyogYTVjYiAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJ5IChcImJzdGFjaysxODhfMDFmYlwiKTsgIC8vIHNhdmUgYnl0ZSB0byBvdXRwdXRcclxuLyogYTVjZSAqLyAgICAgICAgICAgICAgICAgICBMREEuYWJ5IChcImJzdGFjaysxODhfMDFmYlwiKTsgIC8vIGdldCBieXRlIGZyb20gb3V0cHV0LCBzZXQgZmxhZ3NcclxuLyogYTVkMSAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9hNjA5XCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiB3YXMgbnVsbCBbRU9MXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgaG9sZHMgdGhlIHRva2VuIGhlcmVcclxuLyogYTVkMyAqLyAgICAgICAgICAgICAgICAgICBTRUMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzZXQgY2FycnkgZm9yIHN1YnRyYWN0XHJcbi8qIGE1ZDQgKi8gICAgICAgICAgICAgICAgICAgU0JDLmltbSAoMHgzYSk7ICAgICAgICAgICAgICAgLy8gc3VidHJhY3QgXCI6XCJcclxuLyogYTVkNiAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9hNWRjXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBpdCB3YXMgKGlzIG5vdyAkMDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSBub3cgaG9sZHMgdG9rZW4tJzonXHJcbi8qIGE1ZDggKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHg0OSk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIHRoZSB0b2tlbiBmb3IgREFUQS0nOidcclxuLyogYTVkYSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9hNWRlXCIpOyAgICAgICAgICAgIC8vIGlmIG5vdCBEQVRBIGdvIHRyeSBSRU1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0b2tlbiB3YXMgOiBvciBEQVRBXHJcbi8qIGE1ZGMgKi8gICAgICAgIF9gX2E1ZGNgOyAgU1RBLnpwZyAoXCJnYXJiZmxfMDAwZlwiKTsgICAgICAvLyBzYXZlIHRoZSB0b2tlbi0kM0FcclxuLyogYTVkZSAqLyAgICAgICAgX2BfYTVkZWA7ICBTRUMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzZXQgY2FycnkgZm9yIHN1YnRyYWN0XHJcbi8qIGE1ZGYgKi8gICAgICAgICAgICAgICAgICAgU0JDLmltbSAoMHg1NSk7ICAgICAgICAgICAgICAgLy8gc3VidHJhY3QgdGhlIHRva2VuIGZvciBSRU0tJzonXHJcbi8qIGE1ZTEgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYTU4MlwiKTsgICAgICAgICAgICAvLyBpZiB3YXNuJ3QgUkVNIGNydW5jaCBuZXh0IGJpdCBvZiBsaW5lXHJcbi8qIGE1ZTMgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJlbmRjaHJfMDAwOFwiKTsgICAgICAvLyBlbHNlIHdhcyBSRU0gc28gc2V0IHNlYXJjaCBmb3IgW0VPTF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsb29wIGZvciBcIi4uLlwiIGV0Yy5cclxuLyogYTVlNSAqLyAgICAgICAgX2BfYTVlNWA7ICBMREEuYWJ4IChcImJ1ZiswXzAyMDBcIik7ICAgICAgIC8vIGdldCBieXRlIGZyb20gaW5wdXQgYnVmZmVyXHJcbi8qIGE1ZTggKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYTVjOVwiKTsgICAgICAgICAgICAvLyBpZiBudWxsIFtFT0xdIHNhdmUgYnl0ZSB0aGVuIGNvbnRpbnVlIGNydW5jaGluZ1xyXG4vKiBhNWVhICovICAgICAgICAgICAgICAgICAgIENNUC56cGcgKFwiZW5kY2hyXzAwMDhcIik7ICAgICAgLy8gY29tcGFyZSB3aXRoIHN0b3JlZCBjaGFyYWN0ZXJcclxuLyogYTVlYyAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9hNWM5XCIpOyAgICAgICAgICAgIC8vIGlmIG1hdGNoIHNhdmUgYnl0ZSB0aGVuIGNvbnRpbnVlIGNydW5jaGluZ1xyXG4vKiBhNWVlICovICAgICAgICBfYF9hNWVlYDsgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBzYXZlIGluZGV4XHJcbi8qIGE1ZWYgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFieSAoXCJic3RhY2srMTg4XzAxZmJcIik7ICAvLyBzYXZlIGJ5dGUgdG8gb3V0cHV0XHJcbi8qIGE1ZjIgKi8gICAgICAgICAgICAgICAgICAgSU5YLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGJ1ZmZlciBpbmRleFxyXG4vKiBhNWYzICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2E1ZTVcIik7ICAgICAgICAgICAgLy8gbG9vcCB3aGlsZSA8PiAwLCBzaG91bGQgbmV2ZXIgcmVhY2ggMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBmb3VuZCBrZXl3b3JkIHRoaXMgZ29cclxuLyogYTVmNSAqLyAgICAgICAgX2BfYTVmNWA7ICBMRFguenBnIChcInR4dHB0ciswXzAwN2FcIik7ICAgIC8vIHJlc3RvcmUgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGE1ZjcgKi8gICAgICAgICAgICAgICAgICAgSU5DLnpwZyAoXCJjb3VudF8wMDBiXCIpOyAgICAgICAvLyBpbmNyZW1lbnQgd29yZCBpbmRleCAobmV4dCB3b3JkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdyBmaW5kIGVuZCBvZiB0aGlzIHdvcmQgaW4gdGhlIHRhYmxlXHJcbi8qIGE1ZjkgKi8gICAgICAgIF9gX2E1ZjlgOyAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IHRhYmxlIGluZGV4XHJcbi8qIGE1ZmEgKi8gICAgICAgICAgICAgICAgICAgTERBLmFieSAoMHhhMDlkKTsgICAgICAgICAgICAgLy8gZ2V0IHRhYmxlIGJ5dGVcclxuLyogYTVmZCAqLyAgICAgICAgICAgICAgICAgICBCUEwucmVsIChcIl9hNWY5XCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgbm90IGVuZCBvZiB3b3JkIHlldFxyXG4vKiBhNWZmICovICAgICAgICAgICAgICAgICAgIExEQS5hYnkgKFwicmVzbHN0X2EwOWVcIik7ICAgICAgLy8gZ2V0IGJ5dGUgZnJvbSBrZXl3b3JkIHRhYmxlXHJcbi8qIGE2MDIgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYTViOFwiKTsgICAgICAgICAgICAvLyBnbyB0ZXN0IG5leHQgd29yZCBpZiBub3QgemVybyBieXRlLCBlbmQgb2YgdGFibGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWFjaGVkIGVuZCBvZiB0YWJsZSB3aXRoIG5vIG1hdGNoXHJcbi8qIGE2MDQgKi8gICAgICAgICAgICAgICAgICAgTERBLmFieCAoXCJidWYrMF8wMjAwXCIpOyAgICAgICAvLyByZXN0b3JlIGJ5dGUgZnJvbSBpbnB1dCBidWZmZXJcclxuLyogYTYwNyAqLyAgICAgICAgICAgICAgICAgICBCUEwucmVsIChcIl9hNWM3XCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBhbHdheXMsIGFsbCB1bm1hdGNoZWQgYnl0ZXMgaW4gdGhlIGJ1ZmZlciBhcmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAkMDAgdG8gJDdGLCBnbyBzYXZlIGJ5dGUgaW4gb3V0cHV0IGFuZCBjb250aW51ZSBjcnVuY2hpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWFjaGVkIFtFT0xdXHJcbi8qIGE2MDkgKi8gICAgICAgIF9gX2E2MDlgOyAgU1RBLmFieSAoXCJic3RhY2srMTkwXzAxZmRcIik7ICAvLyBzYXZlIFtFT0xdXHJcbi8qIGE2MGMgKi8gICAgICAgICAgICAgICAgICAgREVDLnpwZyAoXCJ0eHRwdHIrMV8wMDdiXCIpOyAgICAvLyBkZWNyZW1lbnQgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBhNjBlICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4ZmYpOyAgICAgICAgICAgICAgIC8vIHBvaW50IHRvIHN0YXJ0IG9mIGJ1ZmZlci0xXHJcbi8qIGE2MTAgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJ0eHRwdHIrMF8wMDdhXCIpOyAgICAvLyBzZXQgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGE2MTIgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gc2VhcmNoIEJBU0lDIGZvciB0ZW1wb3JhcnkgaW50ZWdlciBsaW5lIG51bWJlclxyXG4vKiBhNjEzICovICBfYGZuZGxpbl9hNjEzYDsgIExEQS56cGcgKFwidHh0dGFiKzBfMDAyYlwiKTsgICAgLy8gZ2V0IHN0YXJ0IG9mIG1lbW9yeSBsb3cgYnl0ZVxyXG4vKiBhNjE1ICovICAgICAgICAgICAgICAgICAgIExEWC56cGcgKFwidHh0dGFiKzFfMDAyY1wiKTsgICAgLy8gZ2V0IHN0YXJ0IG9mIG1lbW9yeSBoaWdoIGJ5dGVcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gc2VhcmNoIEJhc2ljIGZvciB0ZW1wIGludGVnZXIgbGluZSBudW1iZXIgZnJvbSBBWFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgY2Fycnkgc2V0IGlmIGZvdW5kXHJcbi8qIGE2MTcgKi8gICAgICAgIF9gX2E2MTdgOyAgTERZLmltbSAoMHgwMSk7ICAgICAgICAgICAgICAgLy8gc2V0IGluZGV4IHRvIG5leHQgbGluZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBhNjE5ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwidGVtcGYyKzNfMDA1ZlwiKTsgICAgLy8gc2F2ZSBsb3cgYnl0ZSBhcyBjdXJyZW50XHJcbi8qIGE2MWIgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJ0ZW1wZjIrNF8wMDYwXCIpOyAgICAvLyBzYXZlIGhpZ2ggYnl0ZSBhcyBjdXJyZW50XHJcbi8qIGE2MWQgKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJ0ZW1wZjIrM18wMDVmXCIpOyAgICAvLyBnZXQgbmV4dCBsaW5lIHBvaW50ZXIgaGlnaCBieXRlIGZyb20gYWRkcmVzc1xyXG4vKiBhNjFmICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2E2NDBcIik7ICAgICAgICAgICAgLy8gcG9pbnRlciB3YXMgemVybyBzbyBkb25lLCBleGl0XHJcbi8qIGE2MjEgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGluZGV4IC4uLlxyXG4vKiBhNjIyICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIC4uLiB0byBsaW5lICMgaGlnaCBieXRlXHJcbi8qIGE2MjMgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJsaW5udW0rMV8wMDE1XCIpOyAgICAvLyBnZXQgdGVtcG9yYXJ5IGludGVnZXIgaGlnaCBieXRlXHJcbi8qIGE2MjUgKi8gICAgICAgICAgICAgICAgICAgQ01QLmlueSAoXCJ0ZW1wZjIrM18wMDVmXCIpOyAgICAvLyBjb21wYXJlIHdpdGggbGluZSAjIGhpZ2ggYnl0ZVxyXG4vKiBhNjI3ICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2E2NDFcIik7ICAgICAgICAgICAgLy8gZXhpdCBpZiB0ZW1wIDwgdGhpcyBsaW5lLCB0YXJnZXQgbGluZSBwYXNzZWRcclxuLyogYTYyOSAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9hNjJlXCIpOyAgICAgICAgICAgIC8vIGdvIGNoZWNrIGxvdyBieXRlIGlmID1cclxuLyogYTYyYiAqLyAgICAgICAgICAgICAgICAgICBERVkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBlbHNlIGRlY3JlbWVudCBpbmRleFxyXG4vKiBhNjJjICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2E2MzdcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGFsd2F5c1xyXG4vKiBhNjJlICovICAgICAgICBfYF9hNjJlYDsgIExEQS56cGcgKFwibGlubnVtKzBfMDAxNFwiKTsgICAgLy8gZ2V0IHRlbXBvcmFyeSBpbnRlZ2VyIGxvdyBieXRlXHJcbi8qIGE2MzAgKi8gICAgICAgICAgICAgICAgICAgREVZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZGVjcmVtZW50IGluZGV4IHRvIGxpbmUgIyBsb3cgYnl0ZVxyXG4vKiBhNjMxICovICAgICAgICAgICAgICAgICAgIENNUC5pbnkgKFwidGVtcGYyKzNfMDA1ZlwiKTsgICAgLy8gY29tcGFyZSB3aXRoIGxpbmUgIyBsb3cgYnl0ZVxyXG4vKiBhNjMzICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2E2NDFcIik7ICAgICAgICAgICAgLy8gZXhpdCBpZiB0ZW1wIDwgdGhpcyBsaW5lLCB0YXJnZXQgbGluZSBwYXNzZWRcclxuLyogYTYzNSAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9hNjQxXCIpOyAgICAgICAgICAgIC8vIGV4aXQgaWYgdGVtcCA9IChmb3VuZCBsaW5lIylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3QgcXVpdGUgdGhlcmUgeWV0XHJcbi8qIGE2MzcgKi8gICAgICAgIF9gX2E2MzdgOyAgREVZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZGVjcmVtZW50IGluZGV4IHRvIG5leHQgbGluZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBhNjM4ICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwidGVtcGYyKzNfMDA1ZlwiKTsgICAgLy8gZ2V0IG5leHQgbGluZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBhNjNhICovICAgICAgICAgICAgICAgICAgIFRBWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgdG8gWFxyXG4vKiBhNjNiICovICAgICAgICAgICAgICAgICAgIERFWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCBpbmRleCB0byBuZXh0IGxpbmUgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBhNjNjICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwidGVtcGYyKzNfMDA1ZlwiKTsgICAgLy8gZ2V0IG5leHQgbGluZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGE2M2UgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfYTYxN1wiKTsgICAgICAgICAgICAvLyBnbyBzZWFyY2ggZm9yIGxpbmUgIyBpbiB0ZW1wb3JhcnkgaW50ZWdlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZyb20gQVgsIGNhcnJ5IGFsd2F5cyBzZXRcclxuLyogYTY0MCAqLyAgICAgICAgX2BfYTY0MGA7ICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBmb3VuZCBmbGFnXHJcbi8qIGE2NDEgKi8gICAgICAgIF9gX2E2NDFgOyAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcGVyZm9ybSBORVdcclxuLyogYTY0MiAqLyAgX2BzY3J0Y2hfYTY0MmA7ICBCTkUucmVsIChcIl9hNjQxXCIpOyAgICAgICAgICAgIC8vIGV4aXQgaWYgZm9sbG93aW5nIGJ5dGUgdG8gYWxsb3cgc3ludGF4IGVycm9yXHJcbi8qIGE2NDQgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgQVxyXG4vKiBhNjQ2ICovICAgICAgICAgICAgICAgICAgIFRBWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIGluZGV4XHJcbi8qIGE2NDcgKi8gICAgICAgICAgICAgICAgICAgU1RBLmlueSAoXCJ0eHR0YWIrMF8wMDJiXCIpOyAgICAvLyBjbGVhciBwb2ludGVyIHRvIG5leHQgbGluZSBsb3cgYnl0ZVxyXG4vKiBhNjQ5ICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBpbmRleFxyXG4vKiBhNjRhICovICAgICAgICAgICAgICAgICAgIFNUQS5pbnkgKFwidHh0dGFiKzBfMDAyYlwiKTsgICAgLy8gY2xlYXIgcG9pbnRlciB0byBuZXh0IGxpbmUgaGlnaCBieXRlLCBlcmFzZSBwcm9ncmFtXHJcbi8qIGE2NGMgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ0eHR0YWIrMF8wMDJiXCIpOyAgICAvLyBnZXQgc3RhcnQgb2YgbWVtb3J5IGxvdyBieXRlXHJcbi8qIGE2NGUgKi8gICAgICAgICAgICAgICAgICAgQ0xDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgY2FycnkgZm9yIGFkZFxyXG4vKiBhNjRmICovICAgICAgICAgICAgICAgICAgIEFEQy5pbW0gKDB4MDIpOyAgICAgICAgICAgICAgIC8vIGFkZCBudWxsIHByb2dyYW0gbGVuZ3RoXHJcbi8qIGE2NTEgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJ2YXJ0YWIrMF8wMDJkXCIpOyAgICAvLyBzZXQgc3RhcnQgb2YgdmFyaWFibGVzIGxvdyBieXRlXHJcbi8qIGE2NTMgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ0eHR0YWIrMV8wMDJjXCIpOyAgICAvLyBnZXQgc3RhcnQgb2YgbWVtb3J5IGhpZ2ggYnl0ZVxyXG4vKiBhNjU1ICovICAgICAgICAgICAgICAgICAgIEFEQy5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGFkZCBjYXJyeVxyXG4vKiBhNjU3ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwidmFydGFiKzFfMDAyZVwiKTsgICAgLy8gc2V0IHN0YXJ0IG9mIHZhcmlhYmxlcyBoaWdoIGJ5dGVcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcmVzZXQgZXhlY3V0ZSBwb2ludGVyIGFuZCBkbyBDTFJcclxuLyogYTY1OSAqLyAgICAgICAgX2BfYTY1OWA7ICBKU1IuYWJzIChcInN0eHB0X2E2OGVcIik7ICAgICAgIC8vIHNldCBCQVNJQyBleGVjdXRlIHBvaW50ZXIgdG8gc3RhcnQgb2YgbWVtb3J5IC0gMVxyXG4vKiBhNjVjICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIHNldCBaYiBmb3IgQ0xSIGVudHJ5XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHBlcmZvcm0gQ0xSXHJcbi8qIGE2NWUgKi8gICBfYGNsZWFyX2E2NWVgOyAgQk5FLnJlbCAoXCJfYTY4ZFwiKTsgICAgICAgICAgICAvLyBleGl0IGlmIGZvbGxvd2luZyBieXRlIHRvIGFsbG93IHN5bnRheCBlcnJvclxyXG4vKiBhNjYwICovICAgICAgICBfYF9hNjYwYDsgIEpTUi5hYnMgKFwiY2xhbGxfZmZlN1wiKTsgICAgICAgLy8gY2xvc2UgYWxsIGNoYW5uZWxzIGFuZCBmaWxlc1xyXG4vKiBhNjYzICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwibWVtc2l6KzBfMDAzN1wiKTsgICAgLy8gZ2V0IGVuZCBvZiBtZW1vcnkgbG93IGJ5dGVcclxuLyogYTY2NSAqLyAgICAgICAgICAgICAgICAgICBMRFkuenBnIChcIm1lbXNpeisxXzAwMzhcIik7ICAgIC8vIGdldCBlbmQgb2YgbWVtb3J5IGhpZ2ggYnl0ZVxyXG4vKiBhNjY3ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZnJldG9wKzBfMDAzM1wiKTsgICAgLy8gc2V0IGJvdHRvbSBvZiBzdHJpbmcgc3BhY2UgbG93IGJ5dGUsIGNsZWFyIHN0cmluZ3NcclxuLyogYTY2OSAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcImZyZXRvcCsxXzAwMzRcIik7ICAgIC8vIHNldCBib3R0b20gb2Ygc3RyaW5nIHNwYWNlIGhpZ2ggYnl0ZVxyXG4vKiBhNjZiICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwidmFydGFiKzBfMDAyZFwiKTsgICAgLy8gZ2V0IHN0YXJ0IG9mIHZhcmlhYmxlcyBsb3cgYnl0ZVxyXG4vKiBhNjZkICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwidmFydGFiKzFfMDAyZVwiKTsgICAgLy8gZ2V0IHN0YXJ0IG9mIHZhcmlhYmxlcyBoaWdoIGJ5dGVcclxuLyogYTY2ZiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImFyeXRhYiswXzAwMmZcIik7ICAgIC8vIHNldCBlbmQgb2YgdmFyaWFibGVzIGxvdyBieXRlLCBjbGVhciB2YXJpYWJsZXNcclxuLyogYTY3MSAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcImFyeXRhYisxXzAwMzBcIik7ICAgIC8vIHNldCBlbmQgb2YgdmFyaWFibGVzIGhpZ2ggYnl0ZVxyXG4vKiBhNjczICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwic3RyZW5kKzBfMDAzMVwiKTsgICAgLy8gc2V0IGVuZCBvZiBhcnJheXMgbG93IGJ5dGUsIGNsZWFyIGFycmF5c1xyXG4vKiBhNjc1ICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwic3RyZW5kKzFfMDAzMlwiKTsgICAgLy8gc2V0IGVuZCBvZiBhcnJheXMgaGlnaCBieXRlXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGRvIFJFU1RPUkUgYW5kIGNsZWFyIHN0YWNrXHJcbi8qIGE2NzcgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJyZXN0b3JfYTgxZFwiKTsgICAgICAvLyBwZXJmb3JtIFJFU1RPUkVcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gZmx1c2ggQkFTSUMgc3RhY2sgYW5kIGNsZWFyIHRoZSBjb250aW51ZSBwb2ludGVyXHJcbi8qIGE2N2EgKi8gICAgICAgIF9gX2E2N2FgOyAgTERYLmltbSAoMHgxOSk7ICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBkZXNjcmlwdG9yIHN0YWNrIHN0YXJ0XHJcbi8qIGE2N2MgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJ0ZW1wcHRfMDAxNlwiKTsgICAgICAvLyBzZXQgdGhlIGRlc2NyaXB0b3Igc3RhY2sgcG9pbnRlclxyXG4vKiBhNjdlICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHB1bGwgdGhlIHJldHVybiBhZGRyZXNzIGxvdyBieXRlXHJcbi8qIGE2N2YgKi8gICAgICAgICAgICAgICAgICAgVEFZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBpdFxyXG4vKiBhNjgwICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHB1bGwgdGhlIHJldHVybiBhZGRyZXNzIGhpZ2ggYnl0ZVxyXG4vKiBhNjgxICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4ZmEpOyAgICAgICAgICAgICAgIC8vIHNldCB0aGUgY2xlYXJlZCBzdGFjayBwb2ludGVyXHJcbi8qIGE2ODMgKi8gICAgICAgICAgICAgICAgICAgVFhTLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2V0IHRoZSBzdGFja1xyXG4vKiBhNjg0ICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggdGhlIHJldHVybiBhZGRyZXNzIGhpZ2ggYnl0ZVxyXG4vKiBhNjg1ICovICAgICAgICAgICAgICAgICAgIFRZQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgdGhlIHJldHVybiBhZGRyZXNzIGxvdyBieXRlXHJcbi8qIGE2ODYgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVzaCB0aGUgcmV0dXJuIGFkZHJlc3MgbG93IGJ5dGVcclxuLyogYTY4NyAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBBXHJcbi8qIGE2ODkgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJvbGR0eHQrMV8wMDNlXCIpOyAgICAvLyBjbGVhciB0aGUgY29udGludWUgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYTY4YiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInN1YmZsZ18wMDEwXCIpOyAgICAgIC8vIGNsZWFyIHRoZSBzdWJzY3JpcHQvRk5YIGZsYWdcclxuLyogYTY4ZCAqLyAgICAgICAgX2BfYTY4ZGA7ICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzZXQgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIHRvIHN0YXJ0IG9mIG1lbW9yeSAtIDFcclxuLyogYTY4ZSAqLyAgIF9gc3R4cHRfYTY4ZWA7ICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBjYXJyeSBmb3IgYWRkXHJcbi8qIGE2OGYgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ0eHR0YWIrMF8wMDJiXCIpOyAgICAvLyBnZXQgc3RhcnQgb2YgbWVtb3J5IGxvdyBieXRlXHJcbi8qIGE2OTEgKi8gICAgICAgICAgICAgICAgICAgQURDLmltbSAoMHhmZik7ICAgICAgICAgICAgICAgLy8gYWRkIC0xIGxvdyBieXRlXHJcbi8qIGE2OTMgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJ0eHRwdHIrMF8wMDdhXCIpOyAgICAvLyBzZXQgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGE2OTUgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ0eHR0YWIrMV8wMDJjXCIpOyAgICAvLyBnZXQgc3RhcnQgb2YgbWVtb3J5IGhpZ2ggYnl0ZVxyXG4vKiBhNjk3ICovICAgICAgICAgICAgICAgICAgIEFEQy5pbW0gKDB4ZmYpOyAgICAgICAgICAgICAgIC8vIGFkZCAtMSBoaWdoIGJ5dGVcclxuLyogYTY5OSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInR4dHB0cisxXzAwN2JcIik7ICAgIC8vIHNhdmUgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBhNjliICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHBlcmZvcm0gTElTVFxyXG4vKiBhNjljICovICAgIF9gbGlzdF9hNjljYDsgIEJDQy5yZWwgKFwiX2E2YTRcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5leHQgY2hhcmFjdGVyIG5vdCB0b2tlbiAoTElTVCBuLi4uKVxyXG4vKiBhNjllICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2E2YTRcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5leHQgY2hhcmFjdGVyIFtOVUxMXSAoTElTVClcclxuLyogYTZhMCAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW1tICgweGFiKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggdG9rZW4gZm9yIC1cclxuLyogYTZhMiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9hNjhkXCIpOyAgICAgICAgICAgIC8vIGV4aXQgaWYgbm90IC0gKExJU1QgLW0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTElTVCBbW25dWy1tXV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGJpdCBzZXRzIHRoZSBuICwgaWYgcHJlc2VudCwgYXMgdGhlIHN0YXJ0IGFuZCBlbmRcclxuLyogYTZhNCAqLyAgICAgICAgX2BfYTZhNGA7ICBKU1IuYWJzIChcImxpbmdldF9hOTZiXCIpOyAgICAgIC8vIGdldCBmaXhlZC1wb2ludCBudW1iZXIgaW50byB0ZW1wb3JhcnkgaW50ZWdlclxyXG4vKiBhNmE3ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiZm5kbGluX2E2MTNcIik7ICAgICAgLy8gc2VhcmNoIEJBU0lDIGZvciB0ZW1wb3JhcnkgaW50ZWdlciBsaW5lIG51bWJlclxyXG4vKiBhNmFhICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiY2hyZ290XzAwNzlcIik7ICAgICAgLy8gc2NhbiBtZW1vcnlcclxuLyogYTZhZCAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9hNmJiXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBubyBtb3JlIGNocnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGJpdCBjaGVja3MgdGhlIC0gaXMgcHJlc2VudFxyXG4vKiBhNmFmICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4YWIpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCB0b2tlbiBmb3IgLVxyXG4vKiBhNmIxICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2E2NDFcIik7ICAgICAgICAgICAgLy8gcmV0dXJuIGlmIG5vdCBcIi1cIiAod2lsbCBiZSBTTiBlcnJvcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMSVNUIFtuXS1tXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIC0gd2FzIHRoZXJlIHNvIHNldCBtIGFzIHRoZSBlbmQgdmFsdWVcclxuLyogYTZiMyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImNocmdldCswXzAwNzNcIik7ICAgIC8vIGluY3JlbWVudCBhbmQgc2NhbiBtZW1vcnlcclxuLyogYTZiNiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImxpbmdldF9hOTZiXCIpOyAgICAgIC8vIGdldCBmaXhlZC1wb2ludCBudW1iZXIgaW50byB0ZW1wb3JhcnkgaW50ZWdlclxyXG4vKiBhNmI5ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2E2NDFcIik7ICAgICAgICAgICAgLy8gZXhpdCBpZiBub3Qgb2tcclxuLyogYTZiYiAqLyAgICAgICAgX2BfYTZiYmA7ICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBkdW1wIHJldHVybiBhZGRyZXNzIGxvdyBieXRlLCBleGl0IHZpYSB3YXJtIHN0YXJ0XHJcbi8qIGE2YmMgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZHVtcCByZXR1cm4gYWRkcmVzcyBoaWdoIGJ5dGVcclxuLyogYTZiZCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImxpbm51bSswXzAwMTRcIik7ICAgIC8vIGdldCB0ZW1wb3JhcnkgaW50ZWdlciBsb3cgYnl0ZVxyXG4vKiBhNmJmICovICAgICAgICAgICAgICAgICAgIE9SQS56cGcgKFwibGlubnVtKzFfMDAxNVwiKTsgICAgLy8gT1IgdGVtcG9yYXJ5IGludGVnZXIgaGlnaCBieXRlXHJcbi8qIGE2YzEgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYTZjOVwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgc3RhcnQgc2V0XHJcbi8qIGE2YzMgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHhmZik7ICAgICAgICAgICAgICAgLy8gc2V0IGZvciAtMVxyXG4vKiBhNmM1ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwibGlubnVtKzBfMDAxNFwiKTsgICAgLy8gc2V0IHRlbXBvcmFyeSBpbnRlZ2VyIGxvdyBieXRlXHJcbi8qIGE2YzcgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJsaW5udW0rMV8wMDE1XCIpOyAgICAvLyBzZXQgdGVtcG9yYXJ5IGludGVnZXIgaGlnaCBieXRlXHJcbi8qIGE2YzkgKi8gICAgICAgIF9gX2E2YzlgOyAgTERZLmltbSAoMHgwMSk7ICAgICAgICAgICAgICAgLy8gc2V0IGluZGV4IGZvciBsaW5lXHJcbi8qIGE2Y2IgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJnYXJiZmxfMDAwZlwiKTsgICAgICAvLyBjbGVhciBvcGVuIHF1b3RlIGZsYWdcclxuLyogYTZjZCAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcInRlbXBmMiszXzAwNWZcIik7ICAgIC8vIGdldCBuZXh0IGxpbmUgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYTZjZiAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9hNzE0XCIpOyAgICAgICAgICAgIC8vIGlmIG51bGwgYWxsIGRvbmUgc28gZXhpdFxyXG4vKiBhNmQxICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwic3RvcF9hODJjXCIpOyAgICAgICAgLy8gZG8gQ1JUTC1DIGNoZWNrIHZlY3RvclxyXG4vKiBhNmQ0ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiY3Jkb19hYWQ3XCIpOyAgICAgICAgLy8gcHJpbnQgQ1IvTEZcclxuLyogYTZkNyAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgaW5kZXggZm9yIGxpbmVcclxuLyogYTZkOCAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcInRlbXBmMiszXzAwNWZcIik7ICAgIC8vIGdldCBsaW5lIG51bWJlciBsb3cgYnl0ZVxyXG4vKiBhNmRhICovICAgICAgICAgICAgICAgICAgIFRBWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgdG8gWFxyXG4vKiBhNmRiICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBpbmRleFxyXG4vKiBhNmRjICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwidGVtcGYyKzNfMDA1ZlwiKTsgICAgLy8gZ2V0IGxpbmUgbnVtYmVyIGhpZ2ggYnl0ZVxyXG4vKiBhNmRlICovICAgICAgICAgICAgICAgICAgIENNUC56cGcgKFwibGlubnVtKzFfMDAxNVwiKTsgICAgLy8gY29tcGFyZSB3aXRoIHRlbXBvcmFyeSBpbnRlZ2VyIGhpZ2ggYnl0ZVxyXG4vKiBhNmUwICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2E2ZTZcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vIGhpZ2ggYnl0ZSBtYXRjaFxyXG4vKiBhNmUyICovICAgICAgICAgICAgICAgICAgIENQWC56cGcgKFwibGlubnVtKzBfMDAxNFwiKTsgICAgLy8gY29tcGFyZSB3aXRoIHRlbXBvcmFyeSBpbnRlZ2VyIGxvdyBieXRlXHJcbi8qIGE2ZTQgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYTZlOFwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgPSBsYXN0IGxpbmUgdG8gZG8sIDwgd2lsbCBwYXNzIG5leHQgYnJhbmNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZVxyXG4vKiBhNmU2ICovICAgICAgICBfYF9hNmU2YDsgIEJDUy5yZWwgKFwiX2E3MTRcIik7ICAgICAgICAgICAgLy8gaWYgZ3JlYXRlciBhbGwgZG9uZSBzbyBleGl0XHJcbi8qIGE2ZTggKi8gICAgICAgIF9gX2E2ZThgOyAgU1RZLnpwZyAoXCJmb3JwbnQrMF8wMDQ5XCIpOyAgICAvLyBzYXZlIGluZGV4IGZvciBsaW5lXHJcbi8qIGE2ZWEgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJsaW5wcnRfYmRjZFwiKTsgICAgICAvLyBwcmludCBYQSBhcyB1bnNpZ25lZCBpbnRlZ2VyXHJcbi8qIGE2ZWQgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgyMCk7ICAgICAgICAgICAgICAgLy8gc3BhY2UgaXMgdGhlIG5leHQgY2hhcmFjdGVyXHJcbi8qIGE2ZWYgKi8gICAgICAgIF9gX2E2ZWZgOyAgTERZLnpwZyAoXCJmb3JwbnQrMF8wMDQ5XCIpOyAgICAvLyBnZXQgaW5kZXggZm9yIGxpbmVcclxuLyogYTZmMSAqLyAgICAgICAgICAgICAgICAgICBBTkQuaW1tICgweDdmKTsgICAgICAgICAgICAgICAvLyBtYXNrIHRvcCBvdXQgYml0IG9mIGNoYXJhY3RlclxyXG4vKiBhNmYzICovICAgICAgICBfYF9hNmYzYDsgIEpTUi5hYnMgKFwiX2FiNDdcIik7ICAgICAgICAgICAgLy8gZ28gcHJpbnQgdGhlIGNoYXJhY3RlclxyXG4vKiBhNmY2ICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4MjIpOyAgICAgICAgICAgICAgIC8vIHdhcyBpdCBcIiBjaGFyYWN0ZXJcclxuLyogYTZmOCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9hNzAwXCIpOyAgICAgICAgICAgIC8vIGlmIG5vdCBza2lwIHRoZSBxdW90ZSBoYW5kbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBhcmUgZWl0aGVyIGVudGVyaW5nIG9yIGxlYXZpbmcgYSBwYWlyIG9mIHF1b3Rlc1xyXG4vKiBhNmZhICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZ2FyYmZsXzAwMGZcIik7ICAgICAgLy8gZ2V0IG9wZW4gcXVvdGUgZmxhZ1xyXG4vKiBhNmZjICovICAgICAgICAgICAgICAgICAgIEVPUi5pbW0gKDB4ZmYpOyAgICAgICAgICAgICAgIC8vIHRvZ2dsZSBpdFxyXG4vKiBhNmZlICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZ2FyYmZsXzAwMGZcIik7ICAgICAgLy8gc2F2ZSBpdCBiYWNrXHJcbi8qIGE3MDAgKi8gICAgICAgIF9gX2E3MDBgOyAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGluZGV4XHJcbi8qIGE3MDEgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYTcxNFwiKTsgICAgICAgICAgICAvLyBsaW5lIHRvbyBsb25nIHNvIGp1c3QgYmFpbCBvdXQgYW5kIGRvIGEgd2FybSBzdGFydFxyXG4vKiBhNzAzICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwidGVtcGYyKzNfMDA1ZlwiKTsgICAgLy8gZ2V0IG5leHQgYnl0ZVxyXG4vKiBhNzA1ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwicXBsb3BfYTcxN1wiKTsgICAgICAgLy8gaWYgbm90IFtFT0xdIChnbyBwcmludCBjaGFyYWN0ZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2FzIFtFT0xdXHJcbi8qIGE3MDcgKi8gICAgICAgICAgICAgICAgICAgVEFZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBjbGVhciBpbmRleFxyXG4vKiBhNzA4ICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwidGVtcGYyKzNfMDA1ZlwiKTsgICAgLy8gZ2V0IG5leHQgbGluZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGE3MGEgKi8gICAgICAgICAgICAgICAgICAgVEFYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSB0byBYXHJcbi8qIGE3MGIgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGluZGV4XHJcbi8qIGE3MGMgKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJ0ZW1wZjIrM18wMDVmXCIpOyAgICAvLyBnZXQgbmV4dCBsaW5lIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGE3MGUgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJ0ZW1wZjIrM18wMDVmXCIpOyAgICAvLyBzZXQgcG9pbnRlciB0byBsaW5lIGxvdyBieXRlXHJcbi8qIGE3MTAgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJ0ZW1wZjIrNF8wMDYwXCIpOyAgICAvLyBzZXQgcG9pbnRlciB0byBsaW5lIGhpZ2ggYnl0ZVxyXG4vKiBhNzEyICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2E2YzlcIik7ICAgICAgICAgICAgLy8gZ28gZG8gbmV4dCBsaW5lIGlmIG5vdCBbRU9UXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgLi4uXHJcbi8qIGE3MTQgKi8gICAgICAgIF9gX2E3MTRgOyAgSk1QLmFicyAoXCJfZTM4NlwiKTsgICAgICAgICAgICAvLyBkbyB3YXJtIHN0YXJ0XHJcbi8qIGE3MTcgKi8gICBfYHFwbG9wX2E3MTdgOyAgSk1QLmluZCAoXCJpcXBsb3ArMF8wMzA2XCIpOyAgICAvLyBkbyB1bmNydW5jaCBCQVNJQyB0b2tlbnNcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gdW5jcnVuY2ggQkFTSUMgdG9rZW5zLCB0aGUgdW5jcnVuY2ggQkFTSUMgdG9rZW5zIHZlY3RvciBpcyBpbml0aWFsaXNlZCB0byBwb2ludCBoZXJlXHJcbi8qIGE3MWEgKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfYTZmM1wiKTsgICAgICAgICAgICAvLyBqdXN0IGdvIHByaW50IGl0IGlmIG5vdCB0b2tlbiBieXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSB3YXMgdG9rZW4gYnl0ZSBzbyB1bmNydW5jaCBpdFxyXG4vKiBhNzFjICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4ZmYpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCB0aGUgdG9rZW4gZm9yIFBJLiBpbiB0aGlzIGNhc2UgdGhlIHRva2VuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgdGhlIHNhbWUgYXMgdGhlIFBJIGNoYXJhY3RlciBzbyBpdCBqdXN0IG5lZWRzIHByaW50aW5nXHJcbi8qIGE3MWUgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYTZmM1wiKTsgICAgICAgICAgICAvLyBqdXN0IHByaW50IGl0IGlmIHNvXHJcbi8qIGE3MjAgKi8gICAgICAgICAgICAgICAgICAgQklULnpwZyAoXCJnYXJiZmxfMDAwZlwiKTsgICAgICAvLyB0ZXN0IHRoZSBvcGVuIHF1b3RlIGZsYWdcclxuLyogYTcyMiAqLyAgICAgICAgICAgICAgICAgICBCTUkucmVsIChcIl9hNmYzXCIpOyAgICAgICAgICAgIC8vIGp1c3QgZ28gcHJpbnQgY2hhcmFjdGVyIGlmIG9wZW4gcXVvdGUgc2V0XHJcbi8qIGE3MjQgKi8gICAgICAgICAgICAgICAgICAgU0VDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBzZXQgY2FycnkgZm9yIHN1YnRyYWN0XHJcbi8qIGE3MjUgKi8gICAgICAgICAgICAgICAgICAgU0JDLmltbSAoMHg3Zik7ICAgICAgICAgICAgICAgLy8gcmVkdWNlIHRva2VuIHJhbmdlIHRvIDEgdG8gd2hhdGV2ZXJcclxuLyogYTcyNyAqLyAgICAgICAgICAgICAgICAgICBUQVguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IHRva2VuICMgdG8gWFxyXG4vKiBhNzI4ICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwiZm9ycG50KzBfMDA0OVwiKTsgICAgLy8gc2F2ZSBpbmRleCBmb3IgbGluZVxyXG4vKiBhNzJhICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4ZmYpOyAgICAgICAgICAgICAgIC8vIHN0YXJ0IGZyb20gLTEsIGFkanVzdCBmb3IgcHJlIGluY3JlbWVudFxyXG4vKiBhNzJjICovICAgICAgICBfYF9hNzJjYDsgIERFWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCB0b2tlbiAjXHJcbi8qIGE3MmQgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYTczN1wiKTsgICAgICAgICAgICAvLyBpZiBub3cgZm91bmQgZ28gZG8gcHJpbnRpbmdcclxuLyogYTcyZiAqLyAgICAgICAgX2BfYTcyZmA7ICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBlbHNlIGluY3JlbWVudCBpbmRleFxyXG4vKiBhNzMwICovICAgICAgICAgICAgICAgICAgIExEQS5hYnkgKFwicmVzbHN0X2EwOWVcIik7ICAgICAgLy8gZ2V0IGJ5dGUgZnJvbSBrZXl3b3JkIHRhYmxlXHJcbi8qIGE3MzMgKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfYTcyZlwiKTsgICAgICAgICAgICAvLyBsb29wIHVudGlsIGtleXdvcmQgZW5kIG1hcmtlclxyXG4vKiBhNzM1ICovICAgICAgICAgICAgICAgICAgIEJNSS5yZWwgKFwiX2E3MmNcIik7ICAgICAgICAgICAgLy8gZ28gdGVzdCBpZiB0aGlzIGlzIHJlcXVpcmVkIGtleXdvcmQsIGJyYW5jaCBhbHdheXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3VuZCBrZXl3b3JkLCBpdCdzIHRoZSBuZXh0IG9uZVxyXG4vKiBhNzM3ICovICAgICAgICBfYF9hNzM3YDsgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBrZXl3b3JkIHRhYmxlIGluZGV4XHJcbi8qIGE3MzggKi8gICAgICAgICAgICAgICAgICAgTERBLmFieSAoXCJyZXNsc3RfYTA5ZVwiKTsgICAgICAvLyBnZXQgYnl0ZSBmcm9tIHRhYmxlXHJcbi8qIGE3M2IgKi8gICAgICAgICAgICAgICAgICAgQk1JLnJlbCAoXCJfYTZlZlwiKTsgICAgICAgICAgICAvLyBnbyByZXN0b3JlIGluZGV4LCBtYXNrIGJ5dGUgYW5kIHByaW50IGlmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnl0ZSB3YXMgZW5kIG1hcmtlclxyXG4vKiBhNzNkICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2FiNDdcIik7ICAgICAgICAgICAgLy8gZWxzZSBnbyBwcmludCB0aGUgY2hhcmFjdGVyXHJcbi8qIGE3NDAgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYTczN1wiKTsgICAgICAgICAgICAvLyBnbyBnZXQgbmV4dCBjaGFyYWN0ZXIsIGJyYW5jaCBhbHdheXNcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcGVyZm9ybSBGT1JcclxuLyogYTc0MiAqLyAgICAgX2Bmb3JfYTc0MmA7ICBMREEuaW1tICgweDgwKTsgICAgICAgICAgICAgICAvLyBzZXQgRk5YXHJcbi8qIGE3NDQgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJzdWJmbGdfMDAxMFwiKTsgICAgICAvLyBzZXQgc3Vic2NyaXB0L0ZOWCBmbGFnXHJcbi8qIGE3NDYgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJsZXRfYTlhNVwiKTsgICAgICAgICAvLyBwZXJmb3JtIExFVFxyXG4vKiBhNzQ5ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiZm5kZm9yX2EzOGFcIik7ICAgICAgLy8gc2VhcmNoIHRoZSBzdGFjayBmb3IgRk9SIG9yIEdPU1VCIGFjdGl2aXR5XHJcbi8qIGE3NGMgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYTc1M1wiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgRk9SLCB0aGlzIHZhcmlhYmxlLCBub3QgZm91bmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGT1IsIHRoaXMgdmFyaWFibGUsIHdhcyBmb3VuZCBzbyBmaXJzdCB3ZSBkdW1wIHRoZSBvbGQgb25lXHJcbi8qIGE3NGUgKi8gICAgICAgICAgICAgICAgICAgVFhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBpbmRleFxyXG4vKiBhNzRmICovICAgICAgICAgICAgICAgICAgIEFEQy5pbW0gKDB4MGYpOyAgICAgICAgICAgICAgIC8vIGFkZCBGT1Igc3RydWN0dXJlIHNpemUtMlxyXG4vKiBhNzUxICovICAgICAgICAgICAgICAgICAgIFRBWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgdG8gaW5kZXhcclxuLyogYTc1MiAqLyAgICAgICAgICAgICAgICAgICBUWFMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzZXQgc3RhY2sgKGR1bXAgRk9SIHN0cnVjdHVyZSAoLTIgYnl0ZXMpKVxyXG4vKiBhNzUzICovICAgICAgICBfYF9hNzUzYDsgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHB1bGwgcmV0dXJuIGFkZHJlc3NcclxuLyogYTc1NCAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdWxsIHJldHVybiBhZGRyZXNzXHJcbi8qIGE3NTUgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwOSk7ICAgICAgICAgICAgICAgLy8gd2UgbmVlZCAxOGQgYnl0ZXMgIVxyXG4vKiBhNzU3ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiZ2V0c3RrX2EzZmJcIik7ICAgICAgLy8gY2hlY2sgcm9vbSBvbiBzdGFjayBmb3IgMipBIGJ5dGVzXHJcbi8qIGE3NWEgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJkYXRhbl9hOTA2XCIpOyAgICAgICAvLyBzY2FuIGZvciBuZXh0IEJBU0lDIHN0YXRlbWVudCAoWzpdIG9yIFtFT0xdKVxyXG4vKiBhNzVkICovICAgICAgICAgICAgICAgICAgIENMQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIGNhcnJ5IGZvciBhZGRcclxuLyogYTc1ZSAqLyAgICAgICAgICAgICAgICAgICBUWUEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IGluZGV4IHRvIEFcclxuLyogYTc1ZiAqLyAgICAgICAgICAgICAgICAgICBBREMuenBnIChcInR4dHB0ciswXzAwN2FcIik7ICAgIC8vIGFkZCBCQVNJQyBleGVjdXRlIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYTc2MSAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdXNoIG9udG8gc3RhY2tcclxuLyogYTc2MiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInR4dHB0cisxXzAwN2JcIik7ICAgIC8vIGdldCBCQVNJQyBleGVjdXRlIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGE3NjQgKi8gICAgICAgICAgICAgICAgICAgQURDLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gYWRkIGNhcnJ5XHJcbi8qIGE3NjYgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVzaCBvbnRvIHN0YWNrXHJcbi8qIGE3NjcgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJjdXJsaW4rMV8wMDNhXCIpOyAgICAvLyBnZXQgY3VycmVudCBsaW5lIG51bWJlciBoaWdoIGJ5dGVcclxuLyogYTc2OSAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdXNoIG9udG8gc3RhY2tcclxuLyogYTc2YSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImN1cmxpbiswXzAwMzlcIik7ICAgIC8vIGdldCBjdXJyZW50IGxpbmUgbnVtYmVyIGxvdyBieXRlXHJcbi8qIGE3NmMgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVzaCBvbnRvIHN0YWNrXHJcbi8qIGE3NmQgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHhhNCk7ICAgICAgICAgICAgICAgLy8gc2V0IFwiVE9cIiB0b2tlblxyXG4vKiBhNzZmICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiY2hrY29tX2FlZmZcIik7ICAgICAgLy8gc2NhbiBmb3IgQ0hSJChBKSwgZWxzZSBkbyBzeW50YXggZXJyb3IgdGhlbiB3YXJtIHN0YXJ0XHJcbi8qIGE3NzIgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfYWQ4ZFwiKTsgICAgICAgICAgICAvLyBjaGVjayBpZiBzb3VyY2UgaXMgbnVtZXJpYywgZWxzZSBkbyB0eXBlIG1pc21hdGNoXHJcbi8qIGE3NzUgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJmcm1udW1fYWQ4YVwiKTsgICAgICAvLyBldmFsdWF0ZSBleHByZXNzaW9uIGFuZCBjaGVjayBpcyBudW1lcmljLCBlbHNlIGRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHlwZSBtaXNtYXRjaFxyXG4vKiBhNzc4ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZmFjc2duXzAwNjZcIik7ICAgICAgLy8gZ2V0IEZBQzEgc2lnbiAoYjcpXHJcbi8qIGE3N2EgKi8gICAgICAgICAgICAgICAgICAgT1JBLmltbSAoMHg3Zik7ICAgICAgICAgICAgICAgLy8gc2V0IGFsbCBub24gc2lnbiBiaXRzXHJcbi8qIGE3N2MgKi8gICAgICAgICAgICAgICAgICAgQU5ELnpwZyAoXCJmYWNobyswXzAwNjJcIik7ICAgICAvLyBhbmQgRkFDMSBtYW50aXNzYSAxXHJcbi8qIGE3N2UgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmYWNobyswXzAwNjJcIik7ICAgICAvLyBzYXZlIEZBQzEgbWFudGlzc2EgMVxyXG4vKiBhNzgwICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4OGIpOyAgICAgICAgICAgICAgIC8vIHNldCByZXR1cm4gYWRkcmVzcyBsb3cgYnl0ZVxyXG4vKiBhNzgyICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4YTcpOyAgICAgICAgICAgICAgIC8vIHNldCByZXR1cm4gYWRkcmVzcyBoaWdoIGJ5dGVcclxuLyogYTc4NCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImluZGV4KzBfMDAyMlwiKTsgICAgIC8vIHNhdmUgcmV0dXJuIGFkZHJlc3MgbG93IGJ5dGVcclxuLyogYTc4NiAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcImluZGV4KzFfMDAyM1wiKTsgICAgIC8vIHNhdmUgcmV0dXJuIGFkZHJlc3MgaGlnaCBieXRlXHJcbi8qIGE3ODggKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfYWU0M1wiKTsgICAgICAgICAgICAvLyByb3VuZCBGQUMxIGFuZCBwdXQgb24gc3RhY2ssIHJldHVybnMgdG8gbmV4dCBpbnN0cnVjdGlvblxyXG4vKiBhNzhiICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4YmMpOyAgICAgICAgICAgICAgIC8vIHNldCAxIHBvaW50ZXIgbG93IGFkZHJlc3MsIGRlZmF1bHQgc3RlcCBzaXplXHJcbi8qIGE3OGQgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHhiOSk7ICAgICAgICAgICAgICAgLy8gc2V0IDEgcG9pbnRlciBoaWdoIGFkZHJlc3NcclxuLyogYTc4ZiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIm1vdmZtX2JiYTJcIik7ICAgICAgIC8vIHVucGFjayBtZW1vcnkgKEFZKSBpbnRvIEZBQzFcclxuLyogYTc5MiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImNocmdvdF8wMDc5XCIpOyAgICAgIC8vIHNjYW4gbWVtb3J5XHJcbi8qIGE3OTUgKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHhhOSk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIFNURVAgdG9rZW5cclxuLyogYTc5NyAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9hNzlmXCIpOyAgICAgICAgICAgIC8vIGlmIG5vdCBcIlNURVBcIiBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdhcyBzdGVwIHNvIC4uLi5cclxuLyogYTc5OSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImNocmdldCswXzAwNzNcIik7ICAgIC8vIGluY3JlbWVudCBhbmQgc2NhbiBtZW1vcnlcclxuLyogYTc5YyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImZybW51bV9hZDhhXCIpOyAgICAgIC8vIGV2YWx1YXRlIGV4cHJlc3Npb24gYW5kIGNoZWNrIGlzIG51bWVyaWMsIGVsc2UgZG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0eXBlIG1pc21hdGNoXHJcbi8qIGE3OWYgKi8gICAgICAgIF9gX2E3OWZgOyAgSlNSLmFicyAoXCJzaWduX2JjMmJcIik7ICAgICAgICAvLyBnZXQgRkFDMSBzaWduLCByZXR1cm4gQSA9ICRGRiAtdmUsIEEgPSAkMDEgK3ZlXHJcbi8qIGE3YTIgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfYWUzOFwiKTsgICAgICAgICAgICAvLyBwdXNoIHNpZ24sIHJvdW5kIEZBQzEgYW5kIHB1dCBvbiBzdGFja1xyXG4vKiBhN2E1ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZm9ycG50KzFfMDA0YVwiKTsgICAgLy8gZ2V0IEZPUi9ORVhUIHZhcmlhYmxlIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGE3YTcgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVzaCBvbiBzdGFja1xyXG4vKiBhN2E4ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZm9ycG50KzBfMDA0OVwiKTsgICAgLy8gZ2V0IEZPUi9ORVhUIHZhcmlhYmxlIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYTdhYSAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdXNoIG9uIHN0YWNrXHJcbi8qIGE3YWIgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHg4MSk7ICAgICAgICAgICAgICAgLy8gZ2V0IEZPUiB0b2tlblxyXG4vKiBhN2FkICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggb24gc3RhY2tcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gaW50ZXJwcmV0ZXIgaW5uZXIgbG9vcFxyXG4vKiBhN2FlICovICBfYG5ld3N0dF9hN2FlYDsgIEpTUi5hYnMgKFwic3RvcF9hODJjXCIpOyAgICAgICAgLy8gZG8gQ1JUTC1DIGNoZWNrIHZlY3RvclxyXG4vKiBhN2IxICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwidHh0cHRyKzBfMDA3YVwiKTsgICAgLy8gZ2V0IHRoZSBCQVNJQyBleGVjdXRlIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYTdiMyAqLyAgICAgICAgICAgICAgICAgICBMRFkuenBnIChcInR4dHB0cisxXzAwN2JcIik7ICAgIC8vIGdldCB0aGUgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBhN2I1ICovICAgICAgICAgICAgICAgICAgIENQWS5pbW0gKDB4MDIpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgdGhlIGhpZ2ggYnl0ZSB3aXRoICQwMnh4XHJcbi8qIGE3YjcgKi8gICAgICAgICAgICAgICAgICAgTk9QLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gdW51c2VkIGJ5dGVcclxuLyogYTdiOCAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9hN2JlXCIpOyAgICAgICAgICAgIC8vIGlmIGltbWVkaWF0ZSBtb2RlIHNraXAgdGhlIGNvbnRpbnVlIHBvaW50ZXIgc2F2ZVxyXG4vKiBhN2JhICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwib2xkdHh0KzBfMDAzZFwiKTsgICAgLy8gc2F2ZSB0aGUgY29udGludWUgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBhN2JjICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwib2xkdHh0KzFfMDAzZVwiKTsgICAgLy8gc2F2ZSB0aGUgY29udGludWUgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYTdiZSAqLyAgICAgICAgX2BfYTdiZWA7ICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciB0aGUgaW5kZXhcclxuLyogYTdjMCAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcInR4dHB0ciswXzAwN2FcIik7ICAgIC8vIGdldCBhIEJBU0lDIGJ5dGVcclxuLyogYTdjMiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9hODA3XCIpOyAgICAgICAgICAgIC8vIGlmIG5vdCBbRU9MXSBnbyB0ZXN0IGZvciBcIjpcIlxyXG4vKiBhN2M0ICovICAgX2Bja2VvbF9hN2M0YDsgIExEWS5pbW0gKDB4MDIpOyAgICAgICAgICAgICAgIC8vIGVsc2Ugc2V0IHRoZSBpbmRleFxyXG4vKiBhN2M2ICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwidHh0cHRyKzBfMDA3YVwiKTsgICAgLy8gZ2V0IG5leHQgbGluZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBhN2M4ICovICAgICAgICAgICAgICAgICAgIENMQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIGNhcnJ5IGZvciBubyBcIkJSRUFLXCIgbWVzc2FnZVxyXG4vKiBhN2M5ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2E3Y2VcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vdCBlbmQgb2YgcHJvZ3JhbVxyXG4vKiBhN2NiICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2E4NGJcIik7ICAgICAgICAgICAgLy8gZWxzZSBnbyB0byBpbW1lZGlhdGUgbW9kZSx3YXMgaW1tZWRpYXRlIG9yIFtFT1RdIG1hcmtlclxyXG4vKiBhN2NlICovICAgICAgICBfYF9hN2NlYDsgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBpbmRleFxyXG4vKiBhN2NmICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwidHh0cHRyKzBfMDA3YVwiKTsgICAgLy8gZ2V0IGxpbmUgbnVtYmVyIGxvdyBieXRlXHJcbi8qIGE3ZDEgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJjdXJsaW4rMF8wMDM5XCIpOyAgICAvLyBzYXZlIGN1cnJlbnQgbGluZSBudW1iZXIgbG93IGJ5dGVcclxuLyogYTdkMyAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgaW5kZXhcclxuLyogYTdkNCAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcInR4dHB0ciswXzAwN2FcIik7ICAgIC8vIGdldCBsaW5lICMgaGlnaCBieXRlXHJcbi8qIGE3ZDYgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJjdXJsaW4rMV8wMDNhXCIpOyAgICAvLyBzYXZlIGN1cnJlbnQgbGluZSBudW1iZXIgaGlnaCBieXRlXHJcbi8qIGE3ZDggKi8gICAgICAgICAgICAgICAgICAgVFlBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gQSBub3cgPSA0XHJcbi8qIGE3ZDkgKi8gICAgICAgICAgICAgICAgICAgQURDLnpwZyAoXCJ0eHRwdHIrMF8wMDdhXCIpOyAgICAvLyBhZGQgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGxvdyBieXRlLCBub3cgcG9pbnRzIHRvIGNvZGVcclxuLyogYTdkYiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInR4dHB0ciswXzAwN2FcIik7ICAgIC8vIHNhdmUgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGE3ZGQgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYTdlMVwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbm8gb3ZlcmZsb3dcclxuLyogYTdkZiAqLyAgICAgICAgICAgICAgICAgICBJTkMuenBnIChcInR4dHB0cisxXzAwN2JcIik7ICAgIC8vIGVsc2UgaW5jcmVtZW50IEJBU0lDIGV4ZWN1dGUgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYTdlMSAqLyAgICAgICAgX2BfYTdlMWA7ICBKTVAuaW5kIChcImlnb25lKzBfMDMwOFwiKTsgICAgIC8vIGRvIHN0YXJ0IG5ldyBCQVNJQyBjb2RlXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHN0YXJ0IG5ldyBCQVNJQyBjb2RlLCB0aGUgc3RhcnQgbmV3IEJBU0lDIGNvZGUgdmVjdG9yIGlzIGluaXRpYWxpc2VkIHRvIHBvaW50IGhlcmVcclxuLyogYTdlNCAqLyAgICBfYGdvbmVfYTdlNGA7ICBKU1IuYWJzIChcImNocmdldCswXzAwNzNcIik7ICAgIC8vIGluY3JlbWVudCBhbmQgc2NhbiBtZW1vcnlcclxuLyogYTdlNyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImdvbmUzX2E3ZWRcIik7ICAgICAgIC8vIGdvIGludGVycHJldCBCQVNJQyBjb2RlIGZyb20gQkFTSUMgZXhlY3V0ZSBwb2ludGVyXHJcbi8qIGE3ZWEgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJuZXdzdHRfYTdhZVwiKTsgICAgICAvLyBsb29wXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGdvIGludGVycHJldCBCQVNJQyBjb2RlIGZyb20gQkFTSUMgZXhlY3V0ZSBwb2ludGVyXHJcbi8qIGE3ZWQgKi8gICBfYGdvbmUzX2E3ZWRgOyAgQkVRLnJlbCAoXCJfYTgyYlwiKTsgICAgICAgICAgICAvLyBpZiB0aGUgZmlyc3QgYnl0ZSBpcyBudWxsIGp1c3QgZXhpdFxyXG4vKiBhN2VmICovICAgICAgICBfYF9hN2VmYDsgIFNCQy5pbW0gKDB4ODApOyAgICAgICAgICAgICAgIC8vIG5vcm1hbGlzZSB0aGUgdG9rZW5cclxuLyogYTdmMSAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9hODA0XCIpOyAgICAgICAgICAgIC8vIGlmIHdhc24ndCB0b2tlbiBnbyBkbyBMRVRcclxuLyogYTdmMyAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW1tICgweDIzKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggdG9rZW4gZm9yIFRBQigtJDgwXHJcbi8qIGE3ZjUgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfYTgwZVwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgPj0gVEFCKFxyXG4vKiBhN2Y3ICovICAgICAgICAgICAgICAgICAgIEFTTC5hY2MgKCk7ICAgICAgICAgICAgICAgICAgIC8vICoyIGJ5dGVzIHBlciB2ZWN0b3JcclxuLyogYTdmOCAqLyAgICAgICAgICAgICAgICAgICBUQVkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IHRvIGluZGV4XHJcbi8qIGE3ZjkgKi8gICAgICAgICAgICAgICAgICAgTERBLmFieSAoMHhhMDBkKTsgICAgICAgICAgICAgLy8gZ2V0IHZlY3RvciBoaWdoIGJ5dGVcclxuLyogYTdmYyAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdXNoIG9uIHN0YWNrXHJcbi8qIGE3ZmQgKi8gICAgICAgICAgICAgICAgICAgTERBLmFieSAoXCJzdG1kc3BfYTAwY1wiKTsgICAgICAvLyBnZXQgdmVjdG9yIGxvdyBieXRlXHJcbi8qIGE4MDAgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVzaCBvbiBzdGFja1xyXG4vKiBhODAxICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiY2hyZ2V0KzBfMDA3M1wiKTsgICAgLy8gaW5jcmVtZW50IGFuZCBzY2FuIG1lbW9yeSBhbmQgcmV0dXJuLiB0aGUgcmV0dXJuIGluXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjYXNlIGNhbGxzIHRoZSBjb21tYW5kIGNvZGUsIHRoZSByZXR1cm4gZnJvbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgd2lsbCBldmVudHVhbGx5IHJldHVybiB0byB0aGUgaW50ZXJwcmV0ZXIgaW5uZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsb29wIGFib3ZlXHJcbi8qIGE4MDQgKi8gICAgICAgIF9gX2E4MDRgOyAgSk1QLmFicyAoXCJsZXRfYTlhNVwiKTsgICAgICAgICAvLyBwZXJmb3JtIExFVFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdhcyBub3QgW0VPTF1cclxuLyogYTgwNyAqLyAgICAgICAgX2BfYTgwN2A7ICBDTVAuaW1tICgweDNhKTsgICAgICAgICAgICAgICAvLyBjb21hcHJlIHdpdGggXCI6XCJcclxuLyogYTgwOSAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9hN2UxXCIpOyAgICAgICAgICAgIC8vIGlmIFwiOlwiIGdvIGV4ZWN1dGUgbmV3IGNvZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIC4uLlxyXG4vKiBhODBiICovICAgICAgICBfYF9hODBiYDsgIEpNUC5hYnMgKFwic3luZXJyX2FmMDhcIik7ICAgICAgLy8gZG8gc3ludGF4IGVycm9yIHRoZW4gd2FybSBzdGFydFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRva2VuIHdhcyA+PSBUQUIoXHJcbi8qIGE4MGUgKi8gICAgICAgIF9gX2E4MGVgOyAgQ01QLmltbSAoMHg0Yik7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIHRoZSB0b2tlbiBmb3IgR09cclxuLyogYTgxMCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9hODBiXCIpOyAgICAgICAgICAgIC8vIGlmIG5vdCBcIkdPXCIgZG8gc3ludGF4IGVycm9yIHRoZW4gd2FybSBzdGFydFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2Ugd2FzIFwiR09cIlxyXG4vKiBhODEyICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiY2hyZ2V0KzBfMDA3M1wiKTsgICAgLy8gaW5jcmVtZW50IGFuZCBzY2FuIG1lbW9yeVxyXG4vKiBhODE1ICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4YTQpOyAgICAgICAgICAgICAgIC8vIHNldCBcIlRPXCIgdG9rZW5cclxuLyogYTgxNyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImNoa2NvbV9hZWZmXCIpOyAgICAgIC8vIHNjYW4gZm9yIENIUiQoQSksIGVsc2UgZG8gc3ludGF4IGVycm9yIHRoZW4gd2FybSBzdGFydFxyXG4vKiBhODFhICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiZ290b19hOGEwXCIpOyAgICAgICAgLy8gcGVyZm9ybSBHT1RPXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHBlcmZvcm0gUkVTVE9SRVxyXG4vKiBhODFkICovICBfYHJlc3Rvcl9hODFkYDsgIFNFQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNldCBjYXJyeSBmb3Igc3VidHJhY3RcclxuLyogYTgxZSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInR4dHRhYiswXzAwMmJcIik7ICAgIC8vIGdldCBzdGFydCBvZiBtZW1vcnkgbG93IGJ5dGVcclxuLyogYTgyMCAqLyAgICAgICAgICAgICAgICAgICBTQkMuaW1tICgweDAxKTsgICAgICAgICAgICAgICAvLyAtMVxyXG4vKiBhODIyICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwidHh0dGFiKzFfMDAyY1wiKTsgICAgLy8gZ2V0IHN0YXJ0IG9mIG1lbW9yeSBoaWdoIGJ5dGVcclxuLyogYTgyNCAqLyAgICAgICAgICAgICAgICAgICBCQ1MucmVsIChcIl9hODI3XCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBubyByb2xsdW5kZXJcclxuLyogYTgyNiAqLyAgICAgICAgICAgICAgICAgICBERVkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBlbHNlIGRlY3JlbWVudCBoaWdoIGJ5dGVcclxuLyogYTgyNyAqLyAgICAgICAgX2BfYTgyN2A7ICBTVEEuenBnIChcImRhdHB0ciswXzAwNDFcIik7ICAgIC8vIHNldCBEQVRBIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYTgyOSAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcImRhdHB0cisxXzAwNDJcIik7ICAgIC8vIHNldCBEQVRBIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGE4MmIgKi8gICAgICAgIF9gX2E4MmJgOyAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gZG8gQ1JUTC1DIGNoZWNrIHZlY3RvclxyXG4vKiBhODJjICovICAgIF9gc3RvcF9hODJjYDsgIEpTUi5hYnMgKFwic3RvcF9mZmUxXCIpOyAgICAgICAgLy8gc2NhbiBzdG9wIGtleVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBwZXJmb3JtIFNUT1BcclxuLyogYTgyZiAqLyAgICAgICAgICAgICAgICAgICBCQ1MucmVsIChcIl9hODMyXCIpOyAgICAgICAgICAgIC8vIGlmIGNhcnJ5IHNldCBkbyBCUkVBSyBpbnN0ZWFkIG9mIGp1c3QgRU5EXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHBlcmZvcm0gRU5EXHJcbi8qIGE4MzEgKi8gICAgIF9gZW5kX2E4MzFgOyAgQ0xDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgY2FycnlcclxuLyogYTgzMiAqLyAgICAgICAgX2BfYTgzMmA7ICBCTkUucmVsIChcIl9hODcwXCIpOyAgICAgICAgICAgIC8vIHJldHVybiBpZiB3YXNuJ3QgQ1RSTC1DXHJcbi8qIGE4MzQgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ0eHRwdHIrMF8wMDdhXCIpOyAgICAvLyBnZXQgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGE4MzYgKi8gICAgICAgICAgICAgICAgICAgTERZLnpwZyAoXCJ0eHRwdHIrMV8wMDdiXCIpOyAgICAvLyBnZXQgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBhODM4ICovICAgICAgICAgICAgICAgICAgIExEWC56cGcgKFwiY3VybGluKzFfMDAzYVwiKTsgICAgLy8gZ2V0IGN1cnJlbnQgbGluZSBudW1iZXIgaGlnaCBieXRlXHJcbi8qIGE4M2EgKi8gICAgICAgICAgICAgICAgICAgSU5YLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGl0XHJcbi8qIGE4M2IgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYTg0OVwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgd2FzIGltbWVkaWF0ZSBtb2RlXHJcbi8qIGE4M2QgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJvbGR0eHQrMF8wMDNkXCIpOyAgICAvLyBzYXZlIGNvbnRpbnVlIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYTgzZiAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcIm9sZHR4dCsxXzAwM2VcIik7ICAgIC8vIHNhdmUgY29udGludWUgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYTg0MSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImN1cmxpbiswXzAwMzlcIik7ICAgIC8vIGdldCBjdXJyZW50IGxpbmUgbnVtYmVyIGxvdyBieXRlXHJcbi8qIGE4NDMgKi8gICAgICAgICAgICAgICAgICAgTERZLnpwZyAoXCJjdXJsaW4rMV8wMDNhXCIpOyAgICAvLyBnZXQgY3VycmVudCBsaW5lIG51bWJlciBoaWdoIGJ5dGVcclxuLyogYTg0NSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcIm9sZGxpbiswXzAwM2JcIik7ICAgIC8vIHNhdmUgYnJlYWsgbGluZSBudW1iZXIgbG93IGJ5dGVcclxuLyogYTg0NyAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcIm9sZGxpbisxXzAwM2NcIik7ICAgIC8vIHNhdmUgYnJlYWsgbGluZSBudW1iZXIgaGlnaCBieXRlXHJcbi8qIGE4NDkgKi8gICAgICAgIF9gX2E4NDlgOyAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZHVtcCByZXR1cm4gYWRkcmVzcyBsb3cgYnl0ZVxyXG4vKiBhODRhICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGR1bXAgcmV0dXJuIGFkZHJlc3MgaGlnaCBieXRlXHJcbi8qIGE4NGIgKi8gICAgICAgIF9gX2E4NGJgOyAgTERBLmltbSAoMHg4MSk7ICAgICAgICAgICAgICAgLy8gc2V0IFtDUl1bTEZdXCJCUkVBS1wiIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYTg0ZCAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweGEzKTsgICAgICAgICAgICAgICAvLyBzZXQgW0NSXVtMRl1cIkJSRUFLXCIgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYTg0ZiAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9hODU0XCIpOyAgICAgICAgICAgIC8vIGlmIHdhcyBwcm9ncmFtIGVuZCBza2lwIHRoZSBwcmludCBzdHJpbmdcclxuLyogYTg1MSAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcImVycmZpbl9hNDY5XCIpOyAgICAgIC8vIHByaW50IHN0cmluZyBhbmQgZG8gd2FybSBzdGFydFxyXG4vKiBhODU0ICovICAgICAgICBfYF9hODU0YDsgIEpNUC5hYnMgKFwiX2UzODZcIik7ICAgICAgICAgICAgLy8gZG8gd2FybSBzdGFydFxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBwZXJmb3JtIENPTlRcclxuLyogYTg1NyAqLyAgICBfYGNvbnRfYTg1N2A7ICBCTkUucmVsIChcIl9hODcwXCIpOyAgICAgICAgICAgIC8vIGV4aXQgaWYgZm9sbG93aW5nIGJ5dGUgdG8gYWxsb3cgc3ludGF4IGVycm9yXHJcbi8qIGE4NTkgKi8gICAgICAgICAgICAgICAgICAgTERYLmltbSAoMHgxYSk7ICAgICAgICAgICAgICAgLy8gZXJyb3IgY29kZSAkMUEsIGNhbid0IGNvbnRpbnVlIGVycm9yXHJcbi8qIGE4NWIgKi8gICAgICAgICAgICAgICAgICAgTERZLnpwZyAoXCJvbGR0eHQrMV8wMDNlXCIpOyAgICAvLyBnZXQgY29udGludWUgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYTg1ZCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9hODYyXCIpOyAgICAgICAgICAgIC8vIGdvIGRvIGNvbnRpbnVlIGlmIHdlIGNhblxyXG4vKiBhODVmICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiZXJyb3JfYTQzN1wiKTsgICAgICAgLy8gZWxzZSBkbyBlcnJvciAjWCB0aGVuIHdhcm0gc3RhcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW4gY29udGludWUgc28gLi4uXHJcbi8qIGE4NjIgKi8gICAgICAgIF9gX2E4NjJgOyAgTERBLnpwZyAoXCJvbGR0eHQrMF8wMDNkXCIpOyAgICAvLyBnZXQgY29udGludWUgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBhODY0ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwidHh0cHRyKzBfMDA3YVwiKTsgICAgLy8gc2F2ZSBCQVNJQyBleGVjdXRlIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYTg2NiAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcInR4dHB0cisxXzAwN2JcIik7ICAgIC8vIHNhdmUgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBhODY4ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwib2xkbGluKzBfMDAzYlwiKTsgICAgLy8gZ2V0IGJyZWFrIGxpbmUgbG93IGJ5dGVcclxuLyogYTg2YSAqLyAgICAgICAgICAgICAgICAgICBMRFkuenBnIChcIm9sZGxpbisxXzAwM2NcIik7ICAgIC8vIGdldCBicmVhayBsaW5lIGhpZ2ggYnl0ZVxyXG4vKiBhODZjICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiY3VybGluKzBfMDAzOVwiKTsgICAgLy8gc2V0IGN1cnJlbnQgbGluZSBudW1iZXIgbG93IGJ5dGVcclxuLyogYTg2ZSAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcImN1cmxpbisxXzAwM2FcIik7ICAgIC8vIHNldCBjdXJyZW50IGxpbmUgbnVtYmVyIGhpZ2ggYnl0ZVxyXG4vKiBhODcwICovICAgICAgICBfYF9hODcwYDsgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHBlcmZvcm0gUlVOXHJcbi8qIGE4NzEgKi8gICAgIF9gcnVuX2E4NzFgOyAgUEhQLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBzdGF0dXNcclxuLyogYTg3MiAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBubyBjb250cm9sIG9yIGtlcm5hbCBtZXNzYWdlc1xyXG4vKiBhODc0ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwic2V0bXNnX2ZmOTBcIik7ICAgICAgLy8gY29udHJvbCBrZXJuYWwgbWVzc2FnZXNcclxuLyogYTg3NyAqLyAgICAgICAgICAgICAgICAgICBQTFAuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIHN0YXR1c1xyXG4vKiBhODc4ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2E4N2RcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIFJVTiBuXHJcbi8qIGE4N2EgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfYTY1OVwiKTsgICAgICAgICAgICAvLyByZXNldCBleGVjdXRpb24gdG8gc3RhcnQsIGNsZWFyIHZhcmlhYmxlcywgZmx1c2ggc3RhY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcmV0dXJuXHJcbi8qIGE4N2QgKi8gICAgICAgIF9gX2E4N2RgOyAgSlNSLmFicyAoXCJfYTY2MFwiKTsgICAgICAgICAgICAvLyBnbyBkbyBcIkNMRUFSXCJcclxuLyogYTg4MCAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9hODk3XCIpOyAgICAgICAgICAgIC8vIGdldCBuIGFuZCBkbyBHT1RPIG5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcGVyZm9ybSBHT1NVQlxyXG4vKiBhODgzICovICAgX2Bnb3N1Yl9hODgzYDsgIExEQS5pbW0gKDB4MDMpOyAgICAgICAgICAgICAgIC8vIG5lZWQgNiBieXRlcyBmb3IgR09TVUJcclxuLyogYTg4NSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImdldHN0a19hM2ZiXCIpOyAgICAgIC8vIGNoZWNrIHJvb20gb24gc3RhY2sgZm9yIDIqQSBieXRlc1xyXG4vKiBhODg4ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwidHh0cHRyKzFfMDA3YlwiKTsgICAgLy8gZ2V0IEJBU0lDIGV4ZWN1dGUgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYTg4YSAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzYXZlIGl0XHJcbi8qIGE4OGIgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ0eHRwdHIrMF8wMDdhXCIpOyAgICAvLyBnZXQgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGE4OGQgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBpdFxyXG4vKiBhODhlICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiY3VybGluKzFfMDAzYVwiKTsgICAgLy8gZ2V0IGN1cnJlbnQgbGluZSBudW1iZXIgaGlnaCBieXRlXHJcbi8qIGE4OTAgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBpdFxyXG4vKiBhODkxICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiY3VybGluKzBfMDAzOVwiKTsgICAgLy8gZ2V0IGN1cnJlbnQgbGluZSBudW1iZXIgbG93IGJ5dGVcclxuLyogYTg5MyAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzYXZlIGl0XHJcbi8qIGE4OTQgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHg4ZCk7ICAgICAgICAgICAgICAgLy8gdG9rZW4gZm9yIEdPU1VCXHJcbi8qIGE4OTYgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBpdFxyXG4vKiBhODk3ICovICAgICAgICBfYF9hODk3YDsgIEpTUi5hYnMgKFwiY2hyZ290XzAwNzlcIik7ICAgICAgLy8gc2NhbiBtZW1vcnlcclxuLyogYTg5YSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImdvdG9fYThhMFwiKTsgICAgICAgIC8vIHBlcmZvcm0gR09UT1xyXG4vKiBhODlkICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwibmV3c3R0X2E3YWVcIik7ICAgICAgLy8gZ28gZG8gaW50ZXJwcmV0ZXIgaW5uZXIgbG9vcFxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBwZXJmb3JtIEdPVE9cclxuLyogYThhMCAqLyAgICBfYGdvdG9fYThhMGA7ICBKU1IuYWJzIChcImxpbmdldF9hOTZiXCIpOyAgICAgIC8vIGdldCBmaXhlZC1wb2ludCBudW1iZXIgaW50byB0ZW1wb3JhcnkgaW50ZWdlclxyXG4vKiBhOGEzICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2E5MDlcIik7ICAgICAgICAgICAgLy8gc2NhbiBmb3IgbmV4dCBCQVNJQyBsaW5lXHJcbi8qIGE4YTYgKi8gICAgICAgICAgICAgICAgICAgU0VDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2V0IGNhcnJ5IGZvciBzdWJ0cmFjdFxyXG4vKiBhOGE3ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiY3VybGluKzBfMDAzOVwiKTsgICAgLy8gZ2V0IGN1cnJlbnQgbGluZSBudW1iZXIgbG93IGJ5dGVcclxuLyogYThhOSAqLyAgICAgICAgICAgICAgICAgICBTQkMuenBnIChcImxpbm51bSswXzAwMTRcIik7ICAgIC8vIHN1YnRyYWN0IHRlbXBvcmFyeSBpbnRlZ2VyIGxvdyBieXRlXHJcbi8qIGE4YWIgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJjdXJsaW4rMV8wMDNhXCIpOyAgICAvLyBnZXQgY3VycmVudCBsaW5lIG51bWJlciBoaWdoIGJ5dGVcclxuLyogYThhZCAqLyAgICAgICAgICAgICAgICAgICBTQkMuenBnIChcImxpbm51bSsxXzAwMTVcIik7ICAgIC8vIHN1YnRyYWN0IHRlbXBvcmFyeSBpbnRlZ2VyIGhpZ2ggYnl0ZVxyXG4vKiBhOGFmICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2E4YmNcIik7ICAgICAgICAgICAgLy8gaWYgY3VycmVudCBsaW5lIG51bWJlciA+PSB0ZW1wb3JhcnkgaW50ZWdlciwgZ28gc2VhcmNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSB0aGUgc3RhcnQgb2YgbWVtb3J5XHJcbi8qIGE4YjEgKi8gICAgICAgICAgICAgICAgICAgVFlBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBjb3B5IGxpbmUgaW5kZXggdG8gQVxyXG4vKiBhOGIyICovICAgICAgICAgICAgICAgICAgIFNFQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNldCBjYXJyeSAoKzEpXHJcbi8qIGE4YjMgKi8gICAgICAgICAgICAgICAgICAgQURDLnpwZyAoXCJ0eHRwdHIrMF8wMDdhXCIpOyAgICAvLyBhZGQgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGE4YjUgKi8gICAgICAgICAgICAgICAgICAgTERYLnpwZyAoXCJ0eHRwdHIrMV8wMDdiXCIpOyAgICAvLyBnZXQgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBhOGI3ICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2E4YzBcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vIG92ZXJmbG93IHRvIGhpZ2ggYnl0ZVxyXG4vKiBhOGI5ICovICAgICAgICAgICAgICAgICAgIElOWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBoaWdoIGJ5dGVcclxuLyogYThiYSAqLyAgICAgICAgICAgICAgICAgICBCQ1MucmVsIChcIl9hOGMwXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBhbHdheXMgKGNhbiBuZXZlciBiZSBjYXJyeSlcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gc2VhcmNoIGZvciBsaW5lIG51bWJlciBpbiB0ZW1wb3JhcnkgaW50ZWdlciBmcm9tIHN0YXJ0IG9mIG1lbW9yeSBwb2ludGVyXHJcbi8qIGE4YmMgKi8gICAgICAgIF9gX2E4YmNgOyAgTERBLnpwZyAoXCJ0eHR0YWIrMF8wMDJiXCIpOyAgICAvLyBnZXQgc3RhcnQgb2YgbWVtb3J5IGxvdyBieXRlXHJcbi8qIGE4YmUgKi8gICAgICAgICAgICAgICAgICAgTERYLnpwZyAoXCJ0eHR0YWIrMV8wMDJjXCIpOyAgICAvLyBnZXQgc3RhcnQgb2YgbWVtb3J5IGhpZ2ggYnl0ZVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzZWFyY2ggZm9yIGxpbmUgIyBpbiB0ZW1wb3JhcnkgaW50ZWdlciBmcm9tIChBWClcclxuLyogYThjMCAqLyAgICAgICAgX2BfYThjMGA7ICBKU1IuYWJzIChcIl9hNjE3XCIpOyAgICAgICAgICAgIC8vIHNlYXJjaCBCYXNpYyBmb3IgdGVtcCBpbnRlZ2VyIGxpbmUgbnVtYmVyIGZyb20gQVhcclxuLyogYThjMyAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9hOGUzXCIpOyAgICAgICAgICAgIC8vIGlmIGNhcnJ5IGNsZWFyIGdvIGRvIHVuc2RlZmluZWQgc3RhdGVtZW50IGVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FycnkgYWxsIHJlYWR5IHNldCBmb3Igc3VidHJhY3RcclxuLyogYThjNSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInRlbXBmMiszXzAwNWZcIik7ICAgIC8vIGdldCBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGE4YzcgKi8gICAgICAgICAgICAgICAgICAgU0JDLmltbSAoMHgwMSk7ICAgICAgICAgICAgICAgLy8gLTFcclxuLyogYThjOSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInR4dHB0ciswXzAwN2FcIik7ICAgIC8vIHNhdmUgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGE4Y2IgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ0ZW1wZjIrNF8wMDYwXCIpOyAgICAvLyBnZXQgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYThjZCAqLyAgICAgICAgICAgICAgICAgICBTQkMuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBzdWJ0cmFjdCBjYXJyeVxyXG4vKiBhOGNmICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwidHh0cHRyKzFfMDA3YlwiKTsgICAgLy8gc2F2ZSBCQVNJQyBleGVjdXRlIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGE4ZDEgKi8gICAgICAgIF9gX2E4ZDFgOyAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcGVyZm9ybSBSRVRVUk5cclxuLyogYThkMiAqLyAgX2ByZXR1cm5fYThkMmA7ICBCTkUucmVsIChcIl9hOGQxXCIpOyAgICAgICAgICAgIC8vIGV4aXQgaWYgZm9sbG93aW5nIHRva2VuIHRvIGFsbG93IHN5bnRheCBlcnJvclxyXG4vKiBhOGQ0ICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4ZmYpOyAgICAgICAgICAgICAgIC8vIHNldCBieXRlIHNvIG5vIG1hdGNoIHBvc3NpYmxlXHJcbi8qIGE4ZDYgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmb3JwbnQrMV8wMDRhXCIpOyAgICAvLyBzYXZlIEZPUi9ORVhUIHZhcmlhYmxlIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGE4ZDggKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJmbmRmb3JfYTM4YVwiKTsgICAgICAvLyBzZWFyY2ggdGhlIHN0YWNrIGZvciBGT1Igb3IgR09TVUIgYWN0aXZpdHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRva2VuIG9mZiBzdGFja1xyXG4vKiBhOGRiICovICAgICAgICAgICAgICAgICAgIFRYUy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcnJlY3QgdGhlIHN0YWNrXHJcbi8qIGE4ZGMgKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHg4ZCk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIEdPU1VCIHRva2VuXHJcbi8qIGE4ZGUgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYThlYlwiKTsgICAgICAgICAgICAvLyBpZiBtYXRjaGluZyBHT1NVQiBnbyBjb250aW51ZSBSRVRVUk5cclxuLyogYThlMCAqLyAgICAgICAgICAgICAgICAgICBMRFguaW1tICgweDBjKTsgICAgICAgICAgICAgICAvLyBlbHNlIGVycm9yIGNvZGUgJDA0LCByZXR1cm4gd2l0aG91dCBnb3N1YiBlcnJvclxyXG4vKiBhOGUyICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgyYyk7ICAgICAgICAgICAgICAgIC8vIG1ha2VzIG5leHQgbGluZSBCSVQgJDExQTJcclxuLyogYThlMyAqLyAgICAgICAgX2BfYThlM2A7ICBMRFguaW1tICgweDExKTsgICAgICAgICAgICAgICAvLyBlcnJvciBjb2RlICQxMSwgdW5kZWZpbmVkIHN0YXRlbWVudCBlcnJvclxyXG4vKiBhOGU1ICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiZXJyb3JfYTQzN1wiKTsgICAgICAgLy8gZG8gZXJyb3IgI1ggdGhlbiB3YXJtIHN0YXJ0XHJcbi8qIGE4ZTggKi8gICAgICAgIF9gX2E4ZThgOyAgSk1QLmFicyAoXCJzeW5lcnJfYWYwOFwiKTsgICAgICAvLyBkbyBzeW50YXggZXJyb3IgdGhlbiB3YXJtIHN0YXJ0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2FzIG1hdGNoaW5nIEdPU1VCIHRva2VuXHJcbi8qIGE4ZWIgKi8gICAgICAgIF9gX2E4ZWJgOyAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZHVtcCB0b2tlbiBieXRlXHJcbi8qIGE4ZWMgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVsbCByZXR1cm4gbGluZSBsb3cgYnl0ZVxyXG4vKiBhOGVkICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiY3VybGluKzBfMDAzOVwiKTsgICAgLy8gc2F2ZSBjdXJyZW50IGxpbmUgbnVtYmVyIGxvdyBieXRlXHJcbi8qIGE4ZWYgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVsbCByZXR1cm4gbGluZSBoaWdoIGJ5dGVcclxuLyogYThmMCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImN1cmxpbisxXzAwM2FcIik7ICAgIC8vIHNhdmUgY3VycmVudCBsaW5lIG51bWJlciBoaWdoIGJ5dGVcclxuLyogYThmMiAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdWxsIHJldHVybiBhZGRyZXNzIGxvdyBieXRlXHJcbi8qIGE4ZjMgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJ0eHRwdHIrMF8wMDdhXCIpOyAgICAvLyBzYXZlIEJBU0lDIGV4ZWN1dGUgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBhOGY1ICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHB1bGwgcmV0dXJuIGFkZHJlc3MgaGlnaCBieXRlXHJcbi8qIGE4ZjYgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJ0eHRwdHIrMV8wMDdiXCIpOyAgICAvLyBzYXZlIEJBU0lDIGV4ZWN1dGUgcG9pbnRlciBoaWdoIGJ5dGVcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcGVyZm9ybSBEQVRBXHJcbi8qIGE4ZjggKi8gICAgX2BkYXRhX2E4ZjhgOyAgSlNSLmFicyAoXCJkYXRhbl9hOTA2XCIpOyAgICAgICAvLyBzY2FuIGZvciBuZXh0IEJBU0lDIHN0YXRlbWVudCAoWzpdIG9yIFtFT0xdKVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBhZGQgWSB0byB0aGUgQkFTSUMgZXhlY3V0ZSBwb2ludGVyXHJcbi8qIGE4ZmIgKi8gICAgICAgIF9gX2E4ZmJgOyAgVFlBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBpbmRleCB0byBBXHJcbi8qIGE4ZmMgKi8gICAgICAgICAgICAgICAgICAgQ0xDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgY2FycnkgZm9yIGFkZFxyXG4vKiBhOGZkICovICAgICAgICAgICAgICAgICAgIEFEQy56cGcgKFwidHh0cHRyKzBfMDA3YVwiKTsgICAgLy8gYWRkIEJBU0lDIGV4ZWN1dGUgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBhOGZmICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwidHh0cHRyKzBfMDA3YVwiKTsgICAgLy8gc2F2ZSBCQVNJQyBleGVjdXRlIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYTkwMSAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9hOTA1XCIpOyAgICAgICAgICAgIC8vIHNraXAgaW5jcmVtZW50IGlmIG5vIGNhcnJ5XHJcbi8qIGE5MDMgKi8gICAgICAgICAgICAgICAgICAgSU5DLnpwZyAoXCJ0eHRwdHIrMV8wMDdiXCIpOyAgICAvLyBlbHNlIGluY3JlbWVudCBCQVNJQyBleGVjdXRlIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGE5MDUgKi8gICAgICAgIF9gX2E5MDVgOyAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gc2NhbiBmb3IgbmV4dCBCQVNJQyBzdGF0ZW1lbnQgKFs6XSBvciBbRU9MXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIFkgYXMgaW5kZXggdG8gWzpdIG9yIFtFT0xdXHJcbi8qIGE5MDYgKi8gICBfYGRhdGFuX2E5MDZgOyAgTERYLmltbSAoMHgzYSk7ICAgICAgICAgICAgICAgLy8gc2V0IGxvb2sgZm9yIGNoYXJhY3RlciA9IFwiOlwiXHJcbi8qIGE5MDggKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDJjKTsgICAgICAgICAgICAgICAgLy8gbWFrZXMgbmV4dCBsaW5lIEJJVCAkMDBBMlxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzY2FuIGZvciBuZXh0IEJBU0lDIGxpbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIFkgYXMgaW5kZXggdG8gW0VPTF1cclxuLyogYTkwOSAqLyAgICAgICAgX2BfYTkwOWA7ICBMRFguaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBzZXQgYWx0ZXJuYXRlIHNlYXJjaCBjaGFyYWN0ZXIgPSBbRU9MXVxyXG4vKiBhOTBiICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwiY2hhcmFjXzAwMDdcIik7ICAgICAgLy8gc3RvcmUgYWx0ZXJuYXRlIHNlYXJjaCBjaGFyYWN0ZXJcclxuLyogYTkwZCAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBzZXQgc2VhcmNoIGNoYXJhY3RlciA9IFtFT0xdXHJcbi8qIGE5MGYgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJlbmRjaHJfMDAwOFwiKTsgICAgICAvLyBzYXZlIHRoZSBzZWFyY2ggY2hhcmFjdGVyXHJcbi8qIGE5MTEgKi8gICAgICAgIF9gX2E5MTFgOyAgTERBLnpwZyAoXCJlbmRjaHJfMDAwOFwiKTsgICAgICAvLyBnZXQgc2VhcmNoIGNoYXJhY3RlclxyXG4vKiBhOTEzICovICAgICAgICAgICAgICAgICAgIExEWC56cGcgKFwiY2hhcmFjXzAwMDdcIik7ICAgICAgLy8gZ2V0IGFsdGVybmF0ZSBzZWFyY2ggY2hhcmFjdGVyXHJcbi8qIGE5MTUgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJjaGFyYWNfMDAwN1wiKTsgICAgICAvLyBtYWtlIHNlYXJjaCBjaGFyYWN0ZXIgPSBhbHRlcm5hdGUgc2VhcmNoIGNoYXJhY3RlclxyXG4vKiBhOTE3ICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwiZW5kY2hyXzAwMDhcIik7ICAgICAgLy8gbWFrZSBhbHRlcm5hdGUgc2VhcmNoIGNoYXJhY3RlciA9IHNlYXJjaCBjaGFyYWN0ZXJcclxuLyogYTkxOSAqLyAgICAgICAgX2BfYTkxOWA7ICBMREEuaW55IChcInR4dHB0ciswXzAwN2FcIik7ICAgIC8vIGdldCBCQVNJQyBieXRlXHJcbi8qIGE5MWIgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYTkwNVwiKTsgICAgICAgICAgICAvLyBleGl0IGlmIG51bGwgW0VPTF1cclxuLyogYTkxZCAqLyAgICAgICAgICAgICAgICAgICBDTVAuenBnIChcImVuZGNocl8wMDA4XCIpOyAgICAgIC8vIGNvbXBhcmUgd2l0aCBzZWFyY2ggY2hhcmFjdGVyXHJcbi8qIGE5MWYgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYTkwNVwiKTsgICAgICAgICAgICAvLyBleGl0IGlmIGZvdW5kXHJcbi8qIGE5MjEgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBpbmNyZW1lbnQgaW5kZXhcclxuLyogYTkyMiAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW1tICgweDIyKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIGN1cnJlbnQgY2hhcmFjdGVyIHdpdGggb3BlbiBxdW90ZVxyXG4vKiBhOTI0ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2E5MTlcIik7ICAgICAgICAgICAgLy8gaWYgZm91bmQgZ28gc3dhcCBzZWFyY2ggY2hhcmFjdGVyIGZvciBhbHRlcm5hdGUgc2VhcmNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyXHJcbi8qIGE5MjYgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYTkxMVwiKTsgICAgICAgICAgICAvLyBsb29wIGZvciBuZXh0IGNoYXJhY3RlciwgYnJhbmNoIGFsd2F5c1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBwZXJmb3JtIElGXHJcbi8qIGE5MjggKi8gICAgICBfYGlmX2E5MjhgOyAgSlNSLmFicyAoXCJmcm1ldmxfYWQ5ZVwiKTsgICAgICAvLyBldmFsdWF0ZSBleHByZXNzaW9uXHJcbi8qIGE5MmIgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJjaHJnb3RfMDA3OVwiKTsgICAgICAvLyBzY2FuIG1lbW9yeVxyXG4vKiBhOTJlICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4ODkpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCBcIkdPVE9cIiB0b2tlblxyXG4vKiBhOTMwICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2E5MzdcIik7ICAgICAgICAgICAgLy8gaWYgaXQgd2FzICB0aGUgdG9rZW4gZm9yIEdPVE8gZ28gZG8gSUYgLi4uIEdPVE9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3YXNuJ3QgSUYgLi4uIEdPVE8gc28gbXVzdCBiZSBJRiAuLi4gVEhFTlxyXG4vKiBhOTMyICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4YTcpOyAgICAgICAgICAgICAgIC8vIHNldCBcIlRIRU5cIiB0b2tlblxyXG4vKiBhOTM0ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiY2hrY29tX2FlZmZcIik7ICAgICAgLy8gc2NhbiBmb3IgQ0hSJChBKSwgZWxzZSBkbyBzeW50YXggZXJyb3IgdGhlbiB3YXJtIHN0YXJ0XHJcbi8qIGE5MzcgKi8gICAgICAgIF9gX2E5MzdgOyAgTERBLnpwZyAoXCJmYWNleHBfMDA2MVwiKTsgICAgICAvLyBnZXQgRkFDMSBleHBvbmVudFxyXG4vKiBhOTM5ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2E5NDBcIik7ICAgICAgICAgICAgLy8gaWYgcmVzdWx0IHdhcyBub24gemVybyBjb250aW51ZSBleGVjdXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIFJFTSByZXN0IG9mIGxpbmVcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcGVyZm9ybSBSRU1cclxuLyogYTkzYiAqLyAgICAgX2ByZW1fYTkzYmA7ICBKU1IuYWJzIChcIl9hOTA5XCIpOyAgICAgICAgICAgIC8vIHNjYW4gZm9yIG5leHQgQkFTSUMgbGluZVxyXG4vKiBhOTNlICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2E4ZmJcIik7ICAgICAgICAgICAgLy8gYWRkIFkgdG8gdGhlIEJBU0lDIGV4ZWN1dGUgcG9pbnRlciBhbmQgcmV0dXJuLCBicmFuY2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbHdheXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXN1bHQgd2FzIG5vbiB6ZXJvIHNvIGRvIHJlc3Qgb2YgbGluZVxyXG4vKiBhOTQwICovICAgICAgICBfYF9hOTQwYDsgIEpTUi5hYnMgKFwiY2hyZ290XzAwNzlcIik7ICAgICAgLy8gc2NhbiBtZW1vcnlcclxuLyogYTk0MyAqLyAgICAgICAgICAgICAgICAgICBCQ1MucmVsIChcIl9hOTQ4XCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBub3QgbnVtZXJpYyBjaGFyYWN0ZXIsIGlzIHZhcmlhYmxlIG9yIGtleXdvcmRcclxuLyogYTk0NSAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcImdvdG9fYThhMFwiKTsgICAgICAgIC8vIGVsc2UgcGVyZm9ybSBHT1RPIG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyB2YXJpYWJsZSBvciBrZXl3b3JkXHJcbi8qIGE5NDggKi8gICAgICAgIF9gX2E5NDhgOyAgSk1QLmFicyAoXCJnb25lM19hN2VkXCIpOyAgICAgICAvLyBpbnRlcnByZXQgQkFTSUMgY29kZSBmcm9tIEJBU0lDIGV4ZWN1dGUgcG9pbnRlclxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBwZXJmb3JtIE9OXHJcbi8qIGE5NGIgKi8gIF9gb25nb3RvX2E5NGJgOyAgSlNSLmFicyAoXCJfYjc5ZVwiKTsgICAgICAgICAgICAvLyBnZXQgYnl0ZSBwYXJhbWV0ZXJcclxuLyogYTk0ZSAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdXNoIG5leHQgY2hhcmFjdGVyXHJcbi8qIGE5NGYgKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHg4ZCk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIEdPU1VCIHRva2VuXHJcbi8qIGE5NTEgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYTk1N1wiKTsgICAgICAgICAgICAvLyBpZiBHT1NVQiBnbyBzZWUgaWYgaXQgc2hvdWxkIGJlIGV4ZWN1dGVkXHJcbi8qIGE5NTMgKi8gICAgICAgIF9gX2E5NTNgOyAgQ01QLmltbSAoMHg4OSk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIEdPVE8gdG9rZW5cclxuLyogYTk1NSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9hOGU4XCIpOyAgICAgICAgICAgIC8vIGlmIG5vdCBHT1RPIGRvIHN5bnRheCBlcnJvciB0aGVuIHdhcm0gc3RhcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGNoYXJhY3RlciB3YXMgR09UTyBvciBHT1NVQiwgc2VlIGlmIGl0IHNob3VsZCBiZSBleGVjdXRlZFxyXG4vKiBhOTU3ICovICAgICAgICBfYF9hOTU3YDsgIERFQy56cGcgKFwiZmFjaG8rM18wMDY1XCIpOyAgICAgLy8gZGVjcmVtZW50IHRoZSBieXRlIHZhbHVlXHJcbi8qIGE5NTkgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYTk1ZlwiKTsgICAgICAgICAgICAvLyBpZiBub3QgemVybyBnbyBzZWUgaWYgYW5vdGhlciBsaW5lIG51bWJlciBleGlzdHNcclxuLyogYTk1YiAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdWxsIGtleXdvcmQgdG9rZW5cclxuLyogYTk1YyAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9hN2VmXCIpOyAgICAgICAgICAgIC8vIGdvIGV4ZWN1dGUgaXRcclxuLyogYTk1ZiAqLyAgICAgICAgX2BfYTk1ZmA7ICBKU1IuYWJzIChcImNocmdldCswXzAwNzNcIik7ICAgIC8vIGluY3JlbWVudCBhbmQgc2NhbiBtZW1vcnlcclxuLyogYTk2MiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImxpbmdldF9hOTZiXCIpOyAgICAgIC8vIGdldCBmaXhlZC1wb2ludCBudW1iZXIgaW50byB0ZW1wb3JhcnkgaW50ZWdlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNraXAgdGhpcyBuXHJcbi8qIGE5NjUgKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHgyYyk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSBuZXh0IGNoYXJhY3RlciB3aXRoIFwiLFwiXHJcbi8qIGE5NjcgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYTk1N1wiKTsgICAgICAgICAgICAvLyBsb29wIGlmIFwiLFwiXHJcbi8qIGE5NjkgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBwdWxsIGtleXdvcmQgdG9rZW4sIHJhbiBvdXQgb2Ygb3B0aW9uc1xyXG4vKiBhOTZhICovICAgICAgICBfYF9hOTZhYDsgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGdldCBmaXhlZC1wb2ludCBudW1iZXIgaW50byB0ZW1wb3JhcnkgaW50ZWdlclxyXG4vKiBhOTZiICovICBfYGxpbmdldF9hOTZiYDsgIExEWC5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIFhcclxuLyogYTk2ZCAqLyAgICAgICAgICAgICAgICAgICBTVFguenBnIChcImxpbm51bSswXzAwMTRcIik7ICAgIC8vIGNsZWFyIHRlbXBvcmFyeSBpbnRlZ2VyIGxvdyBieXRlXHJcbi8qIGE5NmYgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJsaW5udW0rMV8wMDE1XCIpOyAgICAvLyBjbGVhciB0ZW1wb3JhcnkgaW50ZWdlciBoaWdoIGJ5dGVcclxuLyogYTk3MSAqLyAgICAgICAgX2BfYTk3MWA7ICBCQ1MucmVsIChcIl9hOTZhXCIpOyAgICAgICAgICAgIC8vIHJldHVybiBpZiBjYXJyeSBzZXQsIGVuZCBvZiBzY2FuLCBjaGFyYWN0ZXIgd2FzIG5vdCAwLTlcclxuLyogYTk3MyAqLyAgICAgICAgICAgICAgICAgICBTQkMuaW1tICgweDJmKTsgICAgICAgICAgICAgICAvLyBzdWJ0cmFjdCAkMzAsICQyRitjYXJyeSwgZnJvbSBieXRlXHJcbi8qIGE5NzUgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJjaGFyYWNfMDAwN1wiKTsgICAgICAvLyBzdG9yZSAjXHJcbi8qIGE5NzcgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJsaW5udW0rMV8wMDE1XCIpOyAgICAvLyBnZXQgdGVtcG9yYXJ5IGludGVnZXIgaGlnaCBieXRlXHJcbi8qIGE5NzkgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJpbmRleCswXzAwMjJcIik7ICAgICAvLyBzYXZlIGl0IGZvciBub3dcclxuLyogYTk3YiAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW1tICgweDE5KTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggJDE5XHJcbi8qIGE5N2QgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfYTk1M1wiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgPj0gdGhpcyBtYWtlcyB0aGUgbWF4aW11bSBsaW5lIG51bWJlciA2Mzk5OVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhlIG5leHQgYml0IGRvZXMgJDE5MDAgKiAkMEEgPSAkRkEwMCA9IDY0MDAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVjaW1hbC4gdGhlIGJyYW5jaCB0YXJnZXQgaXMgcmVhbGx5IHRoZSBTWU5UQVggZXJyb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhdCAkQThFOCBidXQgdGhhdCBpcyB0b28gZmFyIHNvIGFuIGludGVybWVkaWF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgYW5kIGJyYW5jaCB0byB0aGF0IGxvY2F0aW9uIGlzIHVzZWQuIHRoZSBwcm9ibGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCB0aGlzIGlzIHRoYXQgbGluZSBudW1iZXIgdGhhdCBnaXZlcyBhIHBhcnRpYWwgcmVzdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSAkODkwMCB0byAkODlGRiwgMzUwNzJ4IHRvIDM1MzI3eCwgd2lsbCBwYXNzIHRoZSBuZXdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0YXJnZXQgY29tcGFyZSBhbmQgd2lsbCB0cnkgdG8gZXhlY3V0ZSB0aGUgcmVtYWluZGVyIG9mXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIE9OIG4gR09UTy9HT1NVQi4gYSBzb2x1dGlvbiB0byB0aGlzIGlzIHRvIGNvcHkgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnl0ZSBpbiBBIGJlZm9yZSB0aGUgYnJhbmNoIHRvIFggYW5kIHRoZW4gYnJhbmNoIHRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJEE5NTUgc2tpcHBpbmcgdGhlIHNlY29uZCBjb21wYXJlXHJcbi8qIGE5N2YgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJsaW5udW0rMF8wMDE0XCIpOyAgICAvLyBnZXQgdGVtcG9yYXJ5IGludGVnZXIgbG93IGJ5dGVcclxuLyogYTk4MSAqLyAgICAgICAgICAgICAgICAgICBBU0wuYWNjICgpOyAgICAgICAgICAgICAgICAgICAvLyAqMiBsb3cgYnl0ZVxyXG4vKiBhOTgyICovICAgICAgICAgICAgICAgICAgIFJPTC56cGcgKFwiaW5kZXgrMF8wMDIyXCIpOyAgICAgLy8gKjIgaGlnaCBieXRlXHJcbi8qIGE5ODQgKi8gICAgICAgICAgICAgICAgICAgQVNMLmFjYyAoKTsgICAgICAgICAgICAgICAgICAgLy8gKjIgbG93IGJ5dGVcclxuLyogYTk4NSAqLyAgICAgICAgICAgICAgICAgICBST0wuenBnIChcImluZGV4KzBfMDAyMlwiKTsgICAgIC8vICoyIGhpZ2ggYnl0ZSAoKjQpXHJcbi8qIGE5ODcgKi8gICAgICAgICAgICAgICAgICAgQURDLnpwZyAoXCJsaW5udW0rMF8wMDE0XCIpOyAgICAvLyArIGxvdyBieXRlICgqNSlcclxuLyogYTk4OSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImxpbm51bSswXzAwMTRcIik7ICAgIC8vIHNhdmUgaXRcclxuLyogYTk4YiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImluZGV4KzBfMDAyMlwiKTsgICAgIC8vIGdldCBoaWdoIGJ5dGUgdGVtcFxyXG4vKiBhOThkICovICAgICAgICAgICAgICAgICAgIEFEQy56cGcgKFwibGlubnVtKzFfMDAxNVwiKTsgICAgLy8gKyBoaWdoIGJ5dGUgKCo1KVxyXG4vKiBhOThmICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwibGlubnVtKzFfMDAxNVwiKTsgICAgLy8gc2F2ZSBpdFxyXG4vKiBhOTkxICovICAgICAgICAgICAgICAgICAgIEFTTC56cGcgKFwibGlubnVtKzBfMDAxNFwiKTsgICAgLy8gKjIgbG93IGJ5dGUgKCoxMGQpXHJcbi8qIGE5OTMgKi8gICAgICAgICAgICAgICAgICAgUk9MLnpwZyAoXCJsaW5udW0rMV8wMDE1XCIpOyAgICAvLyAqMiBoaWdoIGJ5dGUgKCoxMGQpXHJcbi8qIGE5OTUgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJsaW5udW0rMF8wMDE0XCIpOyAgICAvLyBnZXQgbG93IGJ5dGVcclxuLyogYTk5NyAqLyAgICAgICAgICAgICAgICAgICBBREMuenBnIChcImNoYXJhY18wMDA3XCIpOyAgICAgIC8vIGFkZCAjXHJcbi8qIGE5OTkgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJsaW5udW0rMF8wMDE0XCIpOyAgICAvLyBzYXZlIGxvdyBieXRlXHJcbi8qIGE5OWIgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYTk5ZlwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbm8gb3ZlcmZsb3cgdG8gaGlnaCBieXRlXHJcbi8qIGE5OWQgKi8gICAgICAgICAgICAgICAgICAgSU5DLnpwZyAoXCJsaW5udW0rMV8wMDE1XCIpOyAgICAvLyBlbHNlIGluY3JlbWVudCBoaWdoIGJ5dGVcclxuLyogYTk5ZiAqLyAgICAgICAgX2BfYTk5ZmA7ICBKU1IuYWJzIChcImNocmdldCswXzAwNzNcIik7ICAgIC8vIGluY3JlbWVudCBhbmQgc2NhbiBtZW1vcnlcclxuLyogYTlhMiAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9hOTcxXCIpOyAgICAgICAgICAgIC8vIGxvb3AgZm9yIG5leHQgY2hhcmFjdGVyXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHBlcmZvcm0gTEVUXHJcbi8qIGE5YTUgKi8gICAgIF9gbGV0X2E5YTVgOyAgSlNSLmFicyAoXCJwdHJnZXRfYjA4YlwiKTsgICAgICAvLyBnZXQgdmFyaWFibGUgYWRkcmVzc1xyXG4vKiBhOWE4ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZm9ycG50KzBfMDA0OVwiKTsgICAgLy8gc2F2ZSB2YXJpYWJsZSBhZGRyZXNzIGxvdyBieXRlXHJcbi8qIGE5YWEgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJmb3JwbnQrMV8wMDRhXCIpOyAgICAvLyBzYXZlIHZhcmlhYmxlIGFkZHJlc3MgaGlnaCBieXRlXHJcbi8qIGE5YWMgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHhiMik7ICAgICAgICAgICAgICAgLy8gJEIyIGlzIFwiPVwiIHRva2VuXHJcbi8qIGE5YWUgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJjaGtjb21fYWVmZlwiKTsgICAgICAvLyBzY2FuIGZvciBDSFIkKEEpLCBlbHNlIGRvIHN5bnRheCBlcnJvciB0aGVuIHdhcm0gc3RhcnRcclxuLyogYTliMSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImludGZsZ18wMDBlXCIpOyAgICAgIC8vIGdldCBkYXRhIHR5cGUgZmxhZywgJDgwID0gaW50ZWdlciwgJDAwID0gZmxvYXRcclxuLyogYTliMyAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdXNoIGRhdGEgdHlwZSBmbGFnXHJcbi8qIGE5YjQgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ2YWx0eXBfMDAwZFwiKTsgICAgICAvLyBnZXQgZGF0YSB0eXBlIGZsYWcsICRGRiA9IHN0cmluZywgJDAwID0gbnVtZXJpY1xyXG4vKiBhOWI2ICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggZGF0YSB0eXBlIGZsYWdcclxuLyogYTliNyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImZybWV2bF9hZDllXCIpOyAgICAgIC8vIGV2YWx1YXRlIGV4cHJlc3Npb25cclxuLyogYTliYSAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwb3AgZGF0YSB0eXBlIGZsYWdcclxuLyogYTliYiAqLyAgICAgICAgICAgICAgICAgICBST0wuYWNjICgpOyAgICAgICAgICAgICAgICAgICAvLyBzdHJpbmcgYml0IGludG8gY2FycnlcclxuLyogYTliYyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9hZDkwXCIpOyAgICAgICAgICAgIC8vIGRvIHR5cGUgbWF0Y2ggY2hlY2tcclxuLyogYTliZiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcInB1dHN0cl9hOWQ5XCIpOyAgICAgIC8vIGJyYW5jaCBpZiBzdHJpbmdcclxuLyogYTljMSAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwb3AgaW50ZWdlci9mbG9hdCBkYXRhIHR5cGUgZmxhZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzc2lnbiB2YWx1ZSB0byBudW1lcmljIHZhcmlhYmxlXHJcbi8qIGE5YzIgKi8gICAgICAgIF9gX2E5YzJgOyAgQlBMLnJlbCAoXCJwdGZscHRfYTlkNlwiKTsgICAgICAvLyBicmFuY2ggaWYgZmxvYXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBleHByZXNzaW9uIGlzIG51bWVyaWMgaW50ZWdlclxyXG4vKiBhOWM0ICovICBfYHB1dGludF9hOWM0YDsgIEpTUi5hYnMgKFwicm91bmRfYmMxYlwiKTsgICAgICAgLy8gcm91bmQgRkFDMVxyXG4vKiBhOWM3ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiYXlpbnRfYjFiZlwiKTsgICAgICAgLy8gZXZhbHVhdGUgaW50ZWdlciBleHByZXNzaW9uLCBubyBzaWduIGNoZWNrXHJcbi8qIGE5Y2EgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgaW5kZXhcclxuLyogYTljYyAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZhY2hvKzJfMDA2NFwiKTsgICAgIC8vIGdldCBGQUMxIG1hbnRpc3NhIDNcclxuLyogYTljZSAqLyAgICAgICAgICAgICAgICAgICBTVEEuaW55IChcImZvcnBudCswXzAwNDlcIik7ICAgIC8vIHNhdmUgYXMgaW50ZWdlciB2YXJpYWJsZSBsb3cgYnl0ZVxyXG4vKiBhOWQwICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBpbmRleFxyXG4vKiBhOWQxICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZmFjaG8rM18wMDY1XCIpOyAgICAgLy8gZ2V0IEZBQzEgbWFudGlzc2EgNFxyXG4vKiBhOWQzICovICAgICAgICAgICAgICAgICAgIFNUQS5pbnkgKFwiZm9ycG50KzBfMDA0OVwiKTsgICAgLy8gc2F2ZSBhcyBpbnRlZ2VyIHZhcmlhYmxlIGhpZ2ggYnl0ZVxyXG4vKiBhOWQ1ICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcbi8qIGE5ZDYgKi8gIF9gcHRmbHB0X2E5ZDZgOyAgSk1QLmFicyAoXCJfYmJkMFwiKTsgICAgICAgICAgICAvLyBwYWNrIEZBQzEgaW50byB2YXJpYWJsZSBwb2ludGVyIGFuZCByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhc3NpZ24gdmFsdWUgdG8gbnVtZXJpYyB2YXJpYWJsZVxyXG4vKiBhOWQ5ICovICBfYHB1dHN0cl9hOWQ5YDsgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGR1bXAgaW50ZWdlci9mbG9hdCBkYXRhIHR5cGUgZmxhZ1xyXG4vKiBhOWRhICovICAgICAgICBfYF9hOWRhYDsgIExEWS56cGcgKFwiZm9ycG50KzFfMDA0YVwiKTsgICAgLy8gZ2V0IHZhcmlhYmxlIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGE5ZGMgKi8gICAgICAgICAgICAgICAgICAgQ1BZLmltbSAoMHhiZik7ICAgICAgICAgICAgICAgLy8gd2FzIGl0IFRJJCBwb2ludGVyXHJcbi8qIGE5ZGUgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJnZXRzcHRfYWEyY1wiKTsgICAgICAvLyBicmFuY2ggaWYgbm90XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBpdCdzIFRJJCA9IDxleHByJD5cclxuLyogYTllMCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9iNmE2XCIpOyAgICAgICAgICAgIC8vIHBvcCBzdHJpbmcgb2ZmIGRlc2NyaXB0b3Igc3RhY2ssIG9yIGZyb20gdG9wIG9mIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwYWNlIHJldHVybnMgd2l0aCBBID0gbGVuZ3RoLCBYID0gcG9pbnRlciBsb3cgYnl0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBZID0gcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYTllMyAqLyAgX2BwdXR0aW1fYTllM2A7ICBDTVAuaW1tICgweDA2KTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIGxlbmd0aCB3aXRoIDZcclxuLyogYTllNSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9hYTI0XCIpOyAgICAgICAgICAgIC8vIGlmIGxlbmd0aCBub3QgNiBkbyBpbGxlZ2FsIHF1YW50aXR5IGVycm9yIHRoZW4gd2FybSBzdGFydFxyXG4vKiBhOWU3ICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIGluZGV4XHJcbi8qIGE5ZTkgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJmYWNleHBfMDA2MVwiKTsgICAgICAvLyBjbGVhciBGQUMxIGV4cG9uZW50XHJcbi8qIGE5ZWIgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJmYWNzZ25fMDA2NlwiKTsgICAgICAvLyBjbGVhciBGQUMxIHNpZ24gKGI3KVxyXG4vKiBhOWVkICovICAgICAgICBfYF9hOWVkYDsgIFNUWS56cGcgKFwiZmJ1ZnB0KzBfMDA3MVwiKTsgICAgLy8gc2F2ZSBpbmRleFxyXG4vKiBhOWVmICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2FhMWRcIik7ICAgICAgICAgICAgLy8gY2hlY2sgYW5kIGV2YWx1YXRlIG51bWVyaWMgZGlnaXRcclxuLyogYTlmMiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIm11bDEwX2JhZTJcIik7ICAgICAgIC8vIG11bHRpcGx5IEZBQzEgYnkgMTBcclxuLyogYTlmNSAqLyAgICAgICAgICAgICAgICAgICBJTkMuenBnIChcImZidWZwdCswXzAwNzFcIik7ICAgIC8vIGluY3JlbWVudCBpbmRleFxyXG4vKiBhOWY3ICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwiZmJ1ZnB0KzBfMDA3MVwiKTsgICAgLy8gcmVzdG9yZSBpbmRleFxyXG4vKiBhOWY5ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2FhMWRcIik7ICAgICAgICAgICAgLy8gY2hlY2sgYW5kIGV2YWx1YXRlIG51bWVyaWMgZGlnaXRcclxuLyogYTlmYyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIm1vdmFmX2JjMGNcIik7ICAgICAgIC8vIHJvdW5kIGFuZCBjb3B5IEZBQzEgdG8gRkFDMlxyXG4vKiBhOWZmICovICAgICAgICAgICAgICAgICAgIFRBWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgRkFDMSBleHBvbmVudFxyXG4vKiBhYTAwICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2FhMDdcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIEZBQzEgemVyb1xyXG4vKiBhYTAyICovICAgICAgICAgICAgICAgICAgIElOWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBpbmRleCwgKiAyXHJcbi8qIGFhMDMgKi8gICAgICAgICAgICAgICAgICAgVFhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBiYWNrIHRvIEFcclxuLyogYWEwNCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9iYWVkXCIpOyAgICAgICAgICAgIC8vIEZBQzEgPSAoRkFDMSArIChGQUMyICogMikpICogMiA9IEZBQzEgKiA2XHJcbi8qIGFhMDcgKi8gICAgICAgIF9gX2FhMDdgOyAgTERZLnpwZyAoXCJmYnVmcHQrMF8wMDcxXCIpOyAgICAvLyBnZXQgaW5kZXhcclxuLyogYWEwOSAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgaW5kZXhcclxuLyogYWEwYSAqLyAgICAgICAgICAgICAgICAgICBDUFkuaW1tICgweDA2KTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIGluZGV4IHdpdGggNlxyXG4vKiBhYTBjICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2E5ZWRcIik7ICAgICAgICAgICAgLy8gbG9vcCBpZiBub3QgNlxyXG4vKiBhYTBlICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwibXVsMTBfYmFlMlwiKTsgICAgICAgLy8gbXVsdGlwbHkgRkFDMSBieSAxMFxyXG4vKiBhYTExICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwicWludF9iYzliXCIpOyAgICAgICAgLy8gY29udmVydCBGQUMxIGZsb2F0aW5nIHRvIGZpeGVkXHJcbi8qIGFhMTQgKi8gICAgICAgICAgICAgICAgICAgTERYLnpwZyAoXCJmYWNobysyXzAwNjRcIik7ICAgICAvLyBnZXQgRkFDMSBtYW50aXNzYSAzXHJcbi8qIGFhMTYgKi8gICAgICAgICAgICAgICAgICAgTERZLnpwZyAoXCJmYWNobysxXzAwNjNcIik7ICAgICAvLyBnZXQgRkFDMSBtYW50aXNzYSAyXHJcbi8qIGFhMTggKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJmYWNobyszXzAwNjVcIik7ICAgICAvLyBnZXQgRkFDMSBtYW50aXNzYSA0XHJcbi8qIGFhMWEgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJzZXR0aW1fZmZkYlwiKTsgICAgICAvLyBzZXQgcmVhbCB0aW1lIGNsb2NrIGFuZCByZXR1cm5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY2hlY2sgYW5kIGV2YWx1YXRlIG51bWVyaWMgZGlnaXRcclxuLyogYWExZCAqLyAgICAgICAgX2BfYWExZGA7ICBMREEuaW55IChcImluZGV4KzBfMDAyMlwiKTsgICAgIC8vIGdldCBieXRlIGZyb20gc3RyaW5nXHJcbi8qIGFhMWYgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJjaHJnZXQrMTNfMDA4MFwiKTsgICAvLyBjbGVhciBDYiBpZiBudW1lcmljLiB0aGlzIGNhbGwgc2hvdWxkIGJlIHRvICQ4NFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzIHRoZSBjb2RlIGZyb20gJDgwIGZpcnN0IGNvbWFwcmVzIHRoZSBieXRlIHdpdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBbU1BBQ0VdIGFuZCBkb2VzIGEgQkFTSUMgaW5jcmVtZW50IGFuZCBnZXQgaWYgaXQgaXNcclxuLyogYWEyMiAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9hYTI3XCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBudW1lcmljXHJcbi8qIGFhMjQgKi8gICAgICAgIF9gX2FhMjRgOyAgSk1QLmFicyAoXCJmY2Vycl9iMjQ4XCIpOyAgICAgICAvLyBkbyBpbGxlZ2FsIHF1YW50aXR5IGVycm9yIHRoZW4gd2FybSBzdGFydFxyXG4vKiBhYTI3ICovICAgICAgICBfYF9hYTI3YDsgIFNCQy5pbW0gKDB4MmYpOyAgICAgICAgICAgICAgIC8vIHN1YnRyYWN0ICQyRiArIGNhcnJ5IHRvIGNvbnZlcnQgQVNDSUkgdG8gYmluYXJ5XHJcbi8qIGFhMjkgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJmaW5sb2dfYmQ3ZVwiKTsgICAgICAvLyBldmFsdWF0ZSBuZXcgQVNDSUkgZGlnaXQgYW5kIHJldHVyblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBhc3NpZ24gdmFsdWUgdG8gbnVtZXJpYyB2YXJpYWJsZSwgYnV0IG5vdCBUSSRcclxuLyogYWEyYyAqLyAgX2BnZXRzcHRfYWEyY2A7ICBMRFkuaW1tICgweDAyKTsgICAgICAgICAgICAgICAvLyBpbmRleCB0byBzdHJpbmcgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYWEyZSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcImZhY2hvKzJfMDA2NFwiKTsgICAgIC8vIGdldCBzdHJpbmcgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYWEzMCAqLyAgICAgICAgICAgICAgICAgICBDTVAuenBnIChcImZyZXRvcCsxXzAwMzRcIik7ICAgIC8vIGNvbXBhcmUgd2l0aCBib3R0b20gb2Ygc3RyaW5nIHNwYWNlIGhpZ2ggYnl0ZVxyXG4vKiBhYTMyICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2FhNGJcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIHN0cmluZyBwb2ludGVyIGhpZ2ggYnl0ZSBpcyBsZXNzIHRoYW4gYm90dG9tXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2Ygc3RyaW5nIHNwYWNlIGhpZ2ggYnl0ZVxyXG4vKiBhYTM0ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2FhM2RcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIHN0cmluZyBwb2ludGVyIGhpZ2ggYnl0ZSBpcyBncmVhdGVyIHRoYW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBib3R0b20gb2Ygc3RyaW5nIHNwYWNlIGhpZ2ggYnl0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgaGlnaCBieXRlcyB3ZXJlIGVxdWFsXHJcbi8qIGFhMzYgKi8gICAgICAgICAgICAgICAgICAgREVZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZGVjcmVtZW50IGluZGV4IHRvIHN0cmluZyBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGFhMzcgKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJmYWNobysyXzAwNjRcIik7ICAgICAvLyBnZXQgc3RyaW5nIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYWEzOSAqLyAgICAgICAgICAgICAgICAgICBDTVAuenBnIChcImZyZXRvcCswXzAwMzNcIik7ICAgIC8vIGNvbXBhcmUgd2l0aCBib3R0b20gb2Ygc3RyaW5nIHNwYWNlIGxvdyBieXRlXHJcbi8qIGFhM2IgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYWE0YlwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgc3RyaW5nIHBvaW50ZXIgbG93IGJ5dGUgaXMgbGVzcyB0aGFuIGJvdHRvbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIHN0cmluZyBzcGFjZSBsb3cgYnl0ZVxyXG4vKiBhYTNkICovICAgICAgICBfYF9hYTNkYDsgIExEWS56cGcgKFwiZmFjaG8rM18wMDY1XCIpOyAgICAgLy8gZ2V0IGRlc2NyaXB0b3IgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYWEzZiAqLyAgICAgICAgICAgICAgICAgICBDUFkuenBnIChcInZhcnRhYisxXzAwMmVcIik7ICAgIC8vIGNvbXBhcmUgd2l0aCBzdGFydCBvZiB2YXJpYWJsZXMgaGlnaCBieXRlXHJcbi8qIGFhNDEgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYWE0YlwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbGVzcywgaXMgb24gc3RyaW5nIHN0YWNrXHJcbi8qIGFhNDMgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYWE1MlwiKTsgICAgICAgICAgICAvLyBpZiBncmVhdGVyIG1ha2Ugc3BhY2UgYW5kIGNvcHkgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBoaWdoIGJ5dGVzIHdlcmUgZXF1YWxcclxuLyogYWE0NSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZhY2hvKzJfMDA2NFwiKTsgICAgIC8vIGdldCBkZXNjcmlwdG9yIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYWE0NyAqLyAgICAgICAgICAgICAgICAgICBDTVAuenBnIChcInZhcnRhYiswXzAwMmRcIik7ICAgIC8vIGNvbXBhcmUgd2l0aCBzdGFydCBvZiB2YXJpYWJsZXMgbG93IGJ5dGVcclxuLyogYWE0OSAqLyAgICAgICAgICAgICAgICAgICBCQ1MucmVsIChcIl9hYTUyXCIpOyAgICAgICAgICAgIC8vIGlmIGdyZWF0ZXIgb3IgZXF1YWwgbWFrZSBzcGFjZSBhbmQgY29weSBzdHJpbmdcclxuLyogYWE0YiAqLyAgICAgICAgX2BfYWE0YmA7ICBMREEuenBnIChcImZhY2hvKzJfMDA2NFwiKTsgICAgIC8vIGdldCBkZXNjcmlwdG9yIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYWE0ZCAqLyAgICAgICAgICAgICAgICAgICBMRFkuenBnIChcImZhY2hvKzNfMDA2NVwiKTsgICAgIC8vIGdldCBkZXNjcmlwdG9yIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGFhNGYgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfYWE2OFwiKTsgICAgICAgICAgICAvLyBnbyBjb3B5IGRlc2NyaXB0b3IgdG8gdmFyaWFibGVcclxuLyogYWE1MiAqLyAgICAgICAgX2BfYWE1MmA7ICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBpbmRleFxyXG4vKiBhYTU0ICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwiZmFjaG8rMl8wMDY0XCIpOyAgICAgLy8gZ2V0IHN0cmluZyBsZW5ndGhcclxuLyogYWE1NiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9iNDc1XCIpOyAgICAgICAgICAgIC8vIGNvcHkgZGVzY3JpcHRvciBwb2ludGVyIGFuZCBtYWtlIHN0cmluZyBzcGFjZSBBIGJ5dGVzIGxvbmdcclxuLyogYWE1OSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImRzY3BudCswXzAwNTBcIik7ICAgIC8vIGNvcHkgb2xkIGRlc2NyaXB0b3IgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBhYTViICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwiZHNjcG50KzFfMDA1MVwiKTsgICAgLy8gY29weSBvbGQgZGVzY3JpcHRvciBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBhYTVkICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiYXJpc2duXzAwNmZcIik7ICAgICAgLy8gc2F2ZSBvbGQgZGVzY3JpcHRvciBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGFhNWYgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJmYWNvdl8wMDcwXCIpOyAgICAgICAvLyBzYXZlIG9sZCBkZXNjcmlwdG9yIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGFhNjEgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJtb3ZpbnNfYjY3YVwiKTsgICAgICAvLyBjb3B5IHN0cmluZyBmcm9tIGRlc2NyaXB0b3IgdG8gdXRpbGl0eSBwb2ludGVyXHJcbi8qIGFhNjQgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHg2MSk7ICAgICAgICAgICAgICAgLy8gZ2V0IGRlc2NyaXB0b3IgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBhYTY2ICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGdldCBkZXNjcmlwdG9yIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGFhNjggKi8gICAgICAgIF9gX2FhNjhgOyAgU1RBLnpwZyAoXCJkc2NwbnQrMF8wMDUwXCIpOyAgICAvLyBzYXZlIGRlc2NyaXB0b3IgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBhYTZhICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwiZHNjcG50KzFfMDA1MVwiKTsgICAgLy8gc2F2ZSBkZXNjcmlwdG9yIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGFhNmMgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJmcmVmYWNfYjZkYlwiKTsgICAgICAvLyBjbGVhbiBkZXNjcmlwdG9yIHN0YWNrLCBZQSA9IHBvaW50ZXJcclxuLyogYWE2ZiAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBpbmRleFxyXG4vKiBhYTcxICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwiZHNjcG50KzBfMDA1MFwiKTsgICAgLy8gZ2V0IHN0cmluZyBsZW5ndGggZnJvbSBuZXcgZGVzY3JpcHRvclxyXG4vKiBhYTczICovICAgICAgICAgICAgICAgICAgIFNUQS5pbnkgKFwiZm9ycG50KzBfMDA0OVwiKTsgICAgLy8gY29weSBzdHJpbmcgbGVuZ3RoIHRvIHZhcmlhYmxlXHJcbi8qIGFhNzUgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGluZGV4XHJcbi8qIGFhNzYgKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJkc2NwbnQrMF8wMDUwXCIpOyAgICAvLyBnZXQgc3RyaW5nIHBvaW50ZXIgbG93IGJ5dGUgZnJvbSBuZXcgZGVzY3JpcHRvclxyXG4vKiBhYTc4ICovICAgICAgICAgICAgICAgICAgIFNUQS5pbnkgKFwiZm9ycG50KzBfMDA0OVwiKTsgICAgLy8gY29weSBzdHJpbmcgcG9pbnRlciBsb3cgYnl0ZSB0byB2YXJpYWJsZVxyXG4vKiBhYTdhICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBpbmRleFxyXG4vKiBhYTdiICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwiZHNjcG50KzBfMDA1MFwiKTsgICAgLy8gZ2V0IHN0cmluZyBwb2ludGVyIGhpZ2ggYnl0ZSBmcm9tIG5ldyBkZXNjcmlwdG9yXHJcbi8qIGFhN2QgKi8gICAgICAgICAgICAgICAgICAgU1RBLmlueSAoXCJmb3JwbnQrMF8wMDQ5XCIpOyAgICAvLyBjb3B5IHN0cmluZyBwb2ludGVyIGhpZ2ggYnl0ZSB0byB2YXJpYWJsZVxyXG4vKiBhYTdmICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHBlcmZvcm0gUFJJTlQjXHJcbi8qIGFhODAgKi8gIF9gcHJpbnRuX2FhODBgOyAgSlNSLmFicyAoXCJjbWRfYWE4NlwiKTsgICAgICAgICAvLyBwZXJmb3JtIENNRFxyXG4vKiBhYTgzICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2FiYjVcIik7ICAgICAgICAgICAgLy8gY2xvc2UgaW5wdXQgYW5kIG91dHB1dCBjaGFubmVscyBhbmQgcmV0dXJuXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHBlcmZvcm0gQ01EXHJcbi8qIGFhODYgKi8gICAgIF9gY21kX2FhODZgOyAgSlNSLmFicyAoXCJfYjc5ZVwiKTsgICAgICAgICAgICAvLyBnZXQgYnl0ZSBwYXJhbWV0ZXJcclxuLyogYWE4OSAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9hYTkwXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBmb2xsb3dpbmcgYnl0ZSBpcyBcIjpcIiBvciBbRU9UXVxyXG4vKiBhYThiICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MmMpOyAgICAgICAgICAgICAgIC8vIHNldCBcIixcIlxyXG4vKiBhYThkICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiY2hrY29tX2FlZmZcIik7ICAgICAgLy8gc2NhbiBmb3IgQ0hSJChBKSwgZWxzZSBkbyBzeW50YXggZXJyb3IgdGhlbiB3YXJtIHN0YXJ0XHJcbi8qIGFhOTAgKi8gICAgICAgIF9gX2FhOTBgOyAgUEhQLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBzdGF0dXNcclxuLyogYWE5MSAqLyAgICAgICAgICAgICAgICAgICBTVFguenBnIChcImNoYW5ubF8wMDEzXCIpOyAgICAgIC8vIHNldCBjdXJyZW50IEkvTyBjaGFubmVsXHJcbi8qIGFhOTMgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJiY2tvdXRfZTExOFwiKTsgICAgICAvLyBvcGVuIGNoYW5uZWwgZm9yIG91dHB1dCB3aXRoIGVycm9yIGNoZWNrXHJcbi8qIGFhOTYgKi8gICAgICAgICAgICAgICAgICAgUExQLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBzdGF0dXNcclxuLyogYWE5NyAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcInByaW50X2FhYTBcIik7ICAgICAgIC8vIHBlcmZvcm0gUFJJTlRcclxuLyogYWE5YSAqLyAgX2BzdHJkb25fYWE5YWA7ICBKU1IuYWJzIChcIl9hYjIxXCIpOyAgICAgICAgICAgIC8vIHByaW50IHN0cmluZyBmcm9tIHV0aWxpdHkgcG9pbnRlclxyXG4vKiBhYTlkICovICAgICAgICBfYF9hYTlkYDsgIEpTUi5hYnMgKFwiY2hyZ290XzAwNzlcIik7ICAgICAgLy8gc2NhbiBtZW1vcnlcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcGVyZm9ybSBQUklOVFxyXG4vKiBhYWEwICovICAgX2BwcmludF9hYWEwYDsgIEJFUS5yZWwgKFwiY3Jkb19hYWQ3XCIpOyAgICAgICAgLy8gaWYgbm90aGluZyBmb2xsb3dpbmcganVzdCBwcmludCBDUi9MRlxyXG4vKiBhYWEyICovICAgICAgICBfYF9hYWEyYDsgIEJFUS5yZWwgKFwiX2FhZTdcIik7ICAgICAgICAgICAgLy8gZXhpdCBpZiBub3RoaW5nIGZvbGxvd2luZywgZW5kIG9mIFBSSU5UIGJyYW5jaFxyXG4vKiBhYWE0ICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4YTMpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCB0b2tlbiBmb3IgVEFCKFxyXG4vKiBhYWE2ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2FhZjhcIik7ICAgICAgICAgICAgLy8gaWYgVEFCKCBnbyBoYW5kbGUgaXRcclxuLyogYWFhOCAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW1tICgweGE2KTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggdG9rZW4gZm9yIFNQQyhcclxuLyogYWFhYSAqLyAgICAgICAgICAgICAgICAgICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBmbGFnIFNQQyhcclxuLyogYWFhYiAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9hYWY4XCIpOyAgICAgICAgICAgIC8vIGlmIFNQQyggZ28gaGFuZGxlIGl0XHJcbi8qIGFhYWQgKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHgyYyk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIFwiLFwiXHJcbi8qIGFhYWYgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJjb21wcnRfYWFlOFwiKTsgICAgICAvLyBpZiBcIixcIiBnbyBza2lwIHRvIHRoZSBuZXh0IFRBQiBwb3NpdGlvblxyXG4vKiBhYWIxICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4M2IpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCBcIjtcIlxyXG4vKiBhYWIzICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2FiMTNcIik7ICAgICAgICAgICAgLy8gaWYgXCI7XCIgZ28gY29udGludWUgdGhlIHByaW50IGxvb3BcclxuLyogYWFiNSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImZybWV2bF9hZDllXCIpOyAgICAgIC8vIGV2YWx1YXRlIGV4cHJlc3Npb25cclxuLyogYWFiOCAqLyAgIF9gdmFyb3BfYWFiOGA7ICBCSVQuenBnIChcInZhbHR5cF8wMDBkXCIpOyAgICAgIC8vIHRlc3QgZGF0YSB0eXBlIGZsYWcsICRGRiA9IHN0cmluZywgJDAwID0gbnVtZXJpY1xyXG4vKiBhYWJhICovICAgICAgICAgICAgICAgICAgIEJNSS5yZWwgKFwic3RyZG9uX2FhOWFcIik7ICAgICAgLy8gaWYgc3RyaW5nIGdvIHByaW50IHN0cmluZywgc2NhbiBtZW1vcnkgYW5kIGNvbnRpbnVlIFBSSU5UXHJcbi8qIGFhYmMgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJmb3V0X2JkZGRcIik7ICAgICAgICAvLyBjb252ZXJ0IEZBQzEgdG8gQVNDSUkgc3RyaW5nIHJlc3VsdCBpbiAoQVkpXHJcbi8qIGFhYmYgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJzdHJsaXRfYjQ4N1wiKTsgICAgICAvLyBwcmludCBcIiB0ZXJtaW5hdGVkIHN0cmluZyB0byB1dGlsaXR5IHBvaW50ZXJcclxuLyogYWFjMiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9hYjIxXCIpOyAgICAgICAgICAgIC8vIHByaW50IHN0cmluZyBmcm9tIHV0aWxpdHkgcG9pbnRlclxyXG4vKiBhYWM1ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwib3V0c3BjX2FiM2JcIik7ICAgICAgLy8gcHJpbnQgW1NQQUNFXSBvciBbQ1VSU09SIFJJR0hUXVxyXG4vKiBhYWM4ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2FhOWRcIik7ICAgICAgICAgICAgLy8gZ28gc2NhbiBtZW1vcnkgYW5kIGNvbnRpbnVlIFBSSU5ULCBicmFuY2ggYWx3YXlzXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHNldCBYWSB0byAkMDIwMCAtIDEgYW5kIHByaW50IFtDUl1cclxuLyogYWFjYSAqLyAgICAgICAgX2BfYWFjYWA7ICBMREEuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBBXHJcbi8qIGFhY2MgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFieCAoXCJidWYrMF8wMjAwXCIpOyAgICAgICAvLyBjbGVhciBmaXJzdCBieXRlIG9mIGlucHV0IGJ1ZmZlclxyXG4vKiBhYWNmICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4ZmYpOyAgICAgICAgICAgICAgIC8vICQwMjAwIC0gMSBsb3cgYnl0ZVxyXG4vKiBhYWQxICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4MDEpOyAgICAgICAgICAgICAgIC8vICQwMjAwIC0gMSBoaWdoIGJ5dGVcclxuLyogYWFkMyAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImNoYW5ubF8wMDEzXCIpOyAgICAgIC8vIGdldCBjdXJyZW50IEkvTyBjaGFubmVsXHJcbi8qIGFhZDUgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYWFlN1wiKTsgICAgICAgICAgICAvLyBleGl0IGlmIG5vdCBkZWZhdWx0IGNoYW5uZWxcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcHJpbnQgQ1IvTEZcclxuLyogYWFkNyAqLyAgICBfYGNyZG9fYWFkN2A7ICBMREEuaW1tICgweDBkKTsgICAgICAgICAgICAgICAvLyBzZXQgW0NSXVxyXG4vKiBhYWQ5ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2FiNDdcIik7ICAgICAgICAgICAgLy8gcHJpbnQgdGhlIGNoYXJhY3RlclxyXG4vKiBhYWRjICovICAgICAgICAgICAgICAgICAgIEJJVC56cGcgKFwiY2hhbm5sXzAwMTNcIik7ICAgICAgLy8gdGVzdCBjdXJyZW50IEkvTyBjaGFubmVsXHJcbi8qIGFhZGUgKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfYWFlNVwiKTsgICAgICAgICAgICAvLyBpZiA/PyB0b2dnbGUgQSwgRU9SICMkRkYgYW5kIHJldHVyblxyXG4vKiBhYWUwICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MGEpOyAgICAgICAgICAgICAgIC8vIHNldCBbTEZdXHJcbi8qIGFhZTIgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfYWI0N1wiKTsgICAgICAgICAgICAvLyBwcmludCB0aGUgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG9nZ2xlIEFcclxuLyogYWFlNSAqLyAgICAgICAgX2BfYWFlNWA7ICBFT1IuaW1tICgweGZmKTsgICAgICAgICAgICAgICAvLyBpbnZlcnQgQVxyXG4vKiBhYWU3ICovICAgICAgICBfYF9hYWU3YDsgIFJUUy5pbXAgKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2FzIFwiLFwiXHJcbi8qIGFhZTggKi8gIF9gY29tcHJ0X2FhZThgOyAgU0VDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2V0IENiIGZvciByZWFkIGN1cnNvciBwb3NpdGlvblxyXG4vKiBhYWU5ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwicGxvdF9mZmYwXCIpOyAgICAgICAgLy8gcmVhZC9zZXQgWCxZIGN1cnNvciBwb3NpdGlvblxyXG4vKiBhYWVjICovICAgICAgICAgICAgICAgICAgIFRZQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgY3Vyc29yIFlcclxuLyogYWFlZCAqLyAgICAgICAgICAgICAgICAgICBTRUMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzZXQgY2FycnkgZm9yIHN1YnRyYWN0XHJcbi8qIGFhZWUgKi8gICAgICAgIF9gX2FhZWVgOyAgU0JDLmltbSAoMHgwYSk7ICAgICAgICAgICAgICAgLy8gc3VidHJhY3Qgb25lIFRBQiBsZW5ndGhcclxuLyogYWFmMCAqLyAgICAgICAgICAgICAgICAgICBCQ1MucmVsIChcIl9hYWVlXCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgcmVzdWx0IHdhcyArdmVcclxuLyogYWFmMiAqLyAgICAgICAgICAgICAgICAgICBFT1IuaW1tICgweGZmKTsgICAgICAgICAgICAgICAvLyBjb21wbGVtZW50IGl0XHJcbi8qIGFhZjQgKi8gICAgICAgICAgICAgICAgICAgQURDLmltbSAoMHgwMSk7ICAgICAgICAgICAgICAgLy8gKzEsIHR3b3MgY29tcGxlbWVudFxyXG4vKiBhYWY2ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2FiMGVcIik7ICAgICAgICAgICAgLy8gYWx3YXlzIHByaW50IEEgc3BhY2VzLCByZXN1bHQgaXMgbmV2ZXIgJDAwXHJcbi8qIGFhZjggKi8gICAgICAgIF9gX2FhZjhgOyAgUEhQLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBUQUIoIG9yIFNQQyggc3RhdHVzXHJcbi8qIGFhZjkgKi8gICAgICAgICAgICAgICAgICAgU0VDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2V0IENiIGZvciByZWFkIGN1cnNvciBwb3NpdGlvblxyXG4vKiBhYWZhICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwicGxvdF9mZmYwXCIpOyAgICAgICAgLy8gcmVhZC9zZXQgWCxZIGN1cnNvciBwb3NpdGlvblxyXG4vKiBhYWZkICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwidHJtcG9zXzAwMDlcIik7ICAgICAgLy8gc2F2ZSBjdXJyZW50IGN1cnNvciBwb3NpdGlvblxyXG4vKiBhYWZmICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiZ3RieXRjX2I3OWJcIik7ICAgICAgLy8gc2NhbiBhbmQgZ2V0IGJ5dGUgcGFyYW1ldGVyXHJcbi8qIGFiMDIgKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHgyOSk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIFwiKVwiXHJcbi8qIGFiMDQgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYWI1ZlwiKTsgICAgICAgICAgICAvLyBpZiBub3QgXCIpXCIgZG8gc3ludGF4IGVycm9yXHJcbi8qIGFiMDYgKi8gICAgICAgICAgICAgICAgICAgUExQLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBUQUIoIG9yIFNQQyggc3RhdHVzXHJcbi8qIGFiMDcgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYWIwZlwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgd2FzIFNQQyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIHdhcyBUQUIoXHJcbi8qIGFiMDkgKi8gICAgICAgICAgICAgICAgICAgVFhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBUQUIoKSBieXRlIHRvIEFcclxuLyogYWIwYSAqLyAgICAgICAgICAgICAgICAgICBTQkMuenBnIChcInRybXBvc18wMDA5XCIpOyAgICAgIC8vIHN1YnRyYWN0IGN1cnJlbnQgY3Vyc29yIHBvc2l0aW9uXHJcbi8qIGFiMGMgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYWIxM1wiKTsgICAgICAgICAgICAvLyBnbyBsb29wIGZvciBuZXh0IGlmIGFscmVhZHkgcGFzdCByZXF1aXRlZCBwb3NpdGlvblxyXG4vKiBhYjBlICovICAgICAgICBfYF9hYjBlYDsgIFRBWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgW1NQQUNFXSBjb3VudCB0byBYXHJcbi8qIGFiMGYgKi8gICAgICAgIF9gX2FiMGZgOyAgSU5YLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGNvdW50XHJcbi8qIGFiMTAgKi8gICAgICAgIF9gX2FiMTBgOyAgREVYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZGVjcmVtZW50IGNvdW50XHJcbi8qIGFiMTEgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYWIxOVwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgY291bnQgd2FzIG5vdCB6ZXJvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2FzIFwiO1wiIG9yIFtTUEFDRVNdIHByaW50ZWRcclxuLyogYWIxMyAqLyAgICAgICAgX2BfYWIxM2A7ICBKU1IuYWJzIChcImNocmdldCswXzAwNzNcIik7ICAgIC8vIGluY3JlbWVudCBhbmQgc2NhbiBtZW1vcnlcclxuLyogYWIxNiAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9hYWEyXCIpOyAgICAgICAgICAgIC8vIGNvbnRpbnVlIHByaW50IGxvb3BcclxuLyogYWIxOSAqLyAgICAgICAgX2BfYWIxOWA7ICBKU1IuYWJzIChcIm91dHNwY19hYjNiXCIpOyAgICAgIC8vIHByaW50IFtTUEFDRV0gb3IgW0NVUlNPUiBSSUdIVF1cclxuLyogYWIxYyAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9hYjEwXCIpOyAgICAgICAgICAgIC8vIGxvb3AsIGJyYW5jaCBhbHdheXNcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcHJpbnQgbnVsbCB0ZXJtaW5hdGVkIHN0cmluZ1xyXG4vKiBhYjFlICovICBfYHN0cm91dF9hYjFlYDsgIEpTUi5hYnMgKFwic3RybGl0X2I0ODdcIik7ICAgICAgLy8gcHJpbnQgXCIgdGVybWluYXRlZCBzdHJpbmcgdG8gdXRpbGl0eSBwb2ludGVyXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHByaW50IHN0cmluZyBmcm9tIHV0aWxpdHkgcG9pbnRlclxyXG4vKiBhYjIxICovICAgICAgICBfYF9hYjIxYDsgIEpTUi5hYnMgKFwiX2I2YTZcIik7ICAgICAgICAgICAgLy8gcG9wIHN0cmluZyBvZmYgZGVzY3JpcHRvciBzdGFjaywgb3IgZnJvbSB0b3Agb2Ygc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BhY2UgcmV0dXJucyB3aXRoIEEgPSBsZW5ndGgsIFggPSBwb2ludGVyIGxvdyBieXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFkgPSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBhYjI0ICovICAgICAgICAgICAgICAgICAgIFRBWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgbGVuZ3RoXHJcbi8qIGFiMjUgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgaW5kZXhcclxuLyogYWIyNyAqLyAgICAgICAgICAgICAgICAgICBJTlguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgbGVuZ3RoLCBmb3IgcHJlIGRlY3JlbWVudCBsb29wXHJcbi8qIGFiMjggKi8gICAgICAgIF9gX2FiMjhgOyAgREVYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZGVjcmVtZW50IGxlbmd0aFxyXG4vKiBhYjI5ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2FhZTdcIik7ICAgICAgICAgICAgLy8gZXhpdCBpZiBkb25lXHJcbi8qIGFiMmIgKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJpbmRleCswXzAwMjJcIik7ICAgICAvLyBnZXQgYnl0ZSBmcm9tIHN0cmluZ1xyXG4vKiBhYjJkICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2FiNDdcIik7ICAgICAgICAgICAgLy8gcHJpbnQgdGhlIGNoYXJhY3RlclxyXG4vKiBhYjMwICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBpbmRleFxyXG4vKiBhYjMxICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4MGQpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgYnl0ZSB3aXRoIFtDUl1cclxuLyogYWIzMyAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9hYjI4XCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgbm90IFtDUl1cclxuLyogYWIzNSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9hYWU1XCIpOyAgICAgICAgICAgIC8vIHRvZ2dsZSBBLCBFT1IgIyRGRi4gd2hhdCBpcyB0aGUgcG9pbnQgb2YgdGhpcyA/P1xyXG4vKiBhYjM4ICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2FiMjhcIik7ICAgICAgICAgICAgLy8gbG9vcFxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBwcmludCBbU1BBQ0VdIG9yIFtDVVJTT1IgUklHSFRdXHJcbi8qIGFiM2IgKi8gIF9gb3V0c3BjX2FiM2JgOyAgTERBLnpwZyAoXCJjaGFubmxfMDAxM1wiKTsgICAgICAvLyBnZXQgY3VycmVudCBJL08gY2hhbm5lbFxyXG4vKiBhYjNkICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2FiNDJcIik7ICAgICAgICAgICAgLy8gaWYgZGVmYXVsdCBjaGFubmVsIGdvIG91dHB1dCBbQ1VSU09SIFJJR0hUXVxyXG4vKiBhYjNmICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MjApOyAgICAgICAgICAgICAgIC8vIGVsc2Ugb3V0cHV0IFtTUEFDRV1cclxuLyogYWI0MSAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MmMpOyAgICAgICAgICAgICAgICAvLyBtYWtlcyBuZXh0IGxpbmUgQklUICQxREE5XHJcbi8qIGFiNDIgKi8gICAgICAgIF9gX2FiNDJgOyAgTERBLmltbSAoMHgxZCk7ICAgICAgICAgICAgICAgLy8gc2V0IFtDVVJTT1IgUklHSFRdXHJcbi8qIGFiNDQgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDJjKTsgICAgICAgICAgICAgICAgLy8gbWFrZXMgbmV4dCBsaW5lIEJJVCAkM0ZBOVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBwcmludCBcIj9cIlxyXG4vKiBhYjQ1ICovICAgICAgICBfYF9hYjQ1YDsgIExEQS5pbW0gKDB4M2YpOyAgICAgICAgICAgICAgIC8vIHNldCBcIj9cIlxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBwcmludCBjaGFyYWN0ZXJcclxuLyogYWI0NyAqLyAgICAgICAgX2BfYWI0N2A7ICBKU1IuYWJzIChcImJjaG91dF9lMTBjXCIpOyAgICAgIC8vIG91dHB1dCBjaGFyYWN0ZXIgdG8gY2hhbm5lbCB3aXRoIGVycm9yIGNoZWNrXHJcbi8qIGFiNGEgKi8gICAgICAgICAgICAgICAgICAgQU5ELmltbSAoMHhmZik7ICAgICAgICAgICAgICAgLy8gc2V0IHRoZSBmbGFncyBvbiBBXHJcbi8qIGFiNGMgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gYmFkIGlucHV0IHJvdXRpbmVcclxuLyogYWI0ZCAqLyAgX2Bkb2FnaW5fYWI0ZGA7ICBMREEuenBnIChcImlucGZsZ18wMDExXCIpOyAgICAgIC8vIGdldCBJTlBVVCBtb2RlIGZsYWcsICQwMCA9IElOUFVULCAkNDAgPSBHRVQsICQ5OCA9IFJFQURcclxuLyogYWI0ZiAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9hYjYyXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBJTlBVVFxyXG4vKiBhYjUxICovICAgICAgICAgICAgICAgICAgIEJNSS5yZWwgKFwiX2FiNTdcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIFJFQURcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIHdhcyBHRVRcclxuLyogYWI1MyAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweGZmKTsgICAgICAgICAgICAgICAvLyBzZXQgY3VycmVudCBsaW5lIGhpZ2ggYnl0ZSB0byAtMSwgaW5kaWNhdGUgaW1tZWRpYXRlIG1vZGVcclxuLyogYWI1NSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9hYjViXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBhbHdheXNcclxuLyogYWI1NyAqLyAgICAgICAgX2BfYWI1N2A7ICBMREEuenBnIChcImRhdGxpbiswXzAwM2ZcIik7ICAgIC8vIGdldCBjdXJyZW50IERBVEEgbGluZSBudW1iZXIgbG93IGJ5dGVcclxuLyogYWI1OSAqLyAgICAgICAgICAgICAgICAgICBMRFkuenBnIChcImRhdGxpbisxXzAwNDBcIik7ICAgIC8vIGdldCBjdXJyZW50IERBVEEgbGluZSBudW1iZXIgaGlnaCBieXRlXHJcbi8qIGFiNWIgKi8gICAgICAgIF9gX2FiNWJgOyAgU1RBLnpwZyAoXCJjdXJsaW4rMF8wMDM5XCIpOyAgICAvLyBzZXQgY3VycmVudCBsaW5lIG51bWJlciBsb3cgYnl0ZVxyXG4vKiBhYjVkICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwiY3VybGluKzFfMDAzYVwiKTsgICAgLy8gc2V0IGN1cnJlbnQgbGluZSBudW1iZXIgaGlnaCBieXRlXHJcbi8qIGFiNWYgKi8gICAgICAgIF9gX2FiNWZgOyAgSk1QLmFicyAoXCJzeW5lcnJfYWYwOFwiKTsgICAgICAvLyBkbyBzeW50YXggZXJyb3IgdGhlbiB3YXJtIHN0YXJ0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2FzIElOUFVUXHJcbi8qIGFiNjIgKi8gICAgICAgIF9gX2FiNjJgOyAgTERBLnpwZyAoXCJjaGFubmxfMDAxM1wiKTsgICAgICAvLyBnZXQgY3VycmVudCBJL08gY2hhbm5lbFxyXG4vKiBhYjY0ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2FiNmJcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIGRlZmF1bHQgY2hhbm5lbFxyXG4vKiBhYjY2ICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4MTgpOyAgICAgICAgICAgICAgIC8vIGVsc2UgZXJyb3IgJDE4LCBmaWxlIGRhdGEgZXJyb3JcclxuLyogYWI2OCAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcImVycm9yX2E0MzdcIik7ICAgICAgIC8vIGRvIGVycm9yICNYIHRoZW4gd2FybSBzdGFydFxyXG4vKiBhYjZiICovICAgICAgICBfYF9hYjZiYDsgIExEQS5pbW0gKDB4MGMpOyAgICAgICAgICAgICAgIC8vIHNldCBcIj9SRURPIEZST00gU1RBUlRcIiBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGFiNmQgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHhhZCk7ICAgICAgICAgICAgICAgLy8gc2V0IFwiP1JFRE8gRlJPTSBTVEFSVFwiIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGFiNmYgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJzdHJvdXRfYWIxZVwiKTsgICAgICAvLyBwcmludCBudWxsIHRlcm1pbmF0ZWQgc3RyaW5nXHJcbi8qIGFiNzIgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJvbGR0eHQrMF8wMDNkXCIpOyAgICAvLyBnZXQgY29udGludWUgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBhYjc0ICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwib2xkdHh0KzFfMDAzZVwiKTsgICAgLy8gZ2V0IGNvbnRpbnVlIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGFiNzYgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJ0eHRwdHIrMF8wMDdhXCIpOyAgICAvLyBzYXZlIEJBU0lDIGV4ZWN1dGUgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBhYjc4ICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwidHh0cHRyKzFfMDA3YlwiKTsgICAgLy8gc2F2ZSBCQVNJQyBleGVjdXRlIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGFiN2EgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcGVyZm9ybSBHRVRcclxuLyogYWI3YiAqLyAgICAgX2BnZXRfYWI3YmA7ICBKU1IuYWJzIChcImVycmRpcl9iM2E2XCIpOyAgICAgIC8vIGNoZWNrIG5vdCBEaXJlY3QsIGJhY2sgaGVyZSBpZiBva1xyXG4vKiBhYjdlICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4MjMpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCBcIiNcIlxyXG4vKiBhYjgwICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2FiOTJcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vdCBHRVQjXHJcbi8qIGFiODIgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJjaHJnZXQrMF8wMDczXCIpOyAgICAvLyBpbmNyZW1lbnQgYW5kIHNjYW4gbWVtb3J5XHJcbi8qIGFiODUgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfYjc5ZVwiKTsgICAgICAgICAgICAvLyBnZXQgYnl0ZSBwYXJhbWV0ZXJcclxuLyogYWI4OCAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDJjKTsgICAgICAgICAgICAgICAvLyBzZXQgXCIsXCJcclxuLyogYWI4YSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImNoa2NvbV9hZWZmXCIpOyAgICAgIC8vIHNjYW4gZm9yIENIUiQoQSksIGVsc2UgZG8gc3ludGF4IGVycm9yIHRoZW4gd2FybSBzdGFydFxyXG4vKiBhYjhkICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwiY2hhbm5sXzAwMTNcIik7ICAgICAgLy8gc2V0IGN1cnJlbnQgSS9PIGNoYW5uZWxcclxuLyogYWI4ZiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImJja2luX2UxMWVcIik7ICAgICAgIC8vIG9wZW4gY2hhbm5lbCBmb3IgaW5wdXQgd2l0aCBlcnJvciBjaGVja1xyXG4vKiBhYjkyICovICAgICAgICBfYF9hYjkyYDsgIExEWC5pbW0gKDB4MDEpOyAgICAgICAgICAgICAgIC8vIHNldCBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGFiOTQgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgwMik7ICAgICAgICAgICAgICAgLy8gc2V0IHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGFiOTYgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgQVxyXG4vKiBhYjk4ICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiYnVmKzFfMDIwMVwiKTsgICAgICAgLy8gZW5zdXJlIG51bGwgdGVybWluYXRvclxyXG4vKiBhYjliICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4NDApOyAgICAgICAgICAgICAgIC8vIGlucHV0IG1vZGUgPSBHRVRcclxuLyogYWI5ZCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9hYzBmXCIpOyAgICAgICAgICAgIC8vIHBlcmZvcm0gdGhlIEdFVCBwYXJ0IG9mIFJFQURcclxuLyogYWJhMCAqLyAgICAgICAgICAgICAgICAgICBMRFguenBnIChcImNoYW5ubF8wMDEzXCIpOyAgICAgIC8vIGdldCBjdXJyZW50IEkvTyBjaGFubmVsXHJcbi8qIGFiYTIgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYWJiN1wiKTsgICAgICAgICAgICAvLyBpZiBub3QgZGVmYXVsdCBjaGFubmVsIGdvIGRvIGNoYW5uZWwgY2xvc2UgYW5kIHJldHVyblxyXG4vKiBhYmE0ICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHBlcmZvcm0gSU5QVVQjXHJcbi8qIGFiYTUgKi8gIF9gaW5wdXRuX2FiYTVgOyAgSlNSLmFicyAoXCJfYjc5ZVwiKTsgICAgICAgICAgICAvLyBnZXQgYnl0ZSBwYXJhbWV0ZXJcclxuLyogYWJhOCAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDJjKTsgICAgICAgICAgICAgICAvLyBzZXQgXCIsXCJcclxuLyogYWJhYSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImNoa2NvbV9hZWZmXCIpOyAgICAgIC8vIHNjYW4gZm9yIENIUiQoQSksIGVsc2UgZG8gc3ludGF4IGVycm9yIHRoZW4gd2FybSBzdGFydFxyXG4vKiBhYmFkICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwiY2hhbm5sXzAwMTNcIik7ICAgICAgLy8gc2V0IGN1cnJlbnQgSS9PIGNoYW5uZWxcclxuLyogYWJhZiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImJja2luX2UxMWVcIik7ICAgICAgIC8vIG9wZW4gY2hhbm5lbCBmb3IgaW5wdXQgd2l0aCBlcnJvciBjaGVja1xyXG4vKiBhYmIyICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2FiY2VcIik7ICAgICAgICAgICAgLy8gcGVyZm9ybSBJTlBVVCB3aXRoIG5vIHByb21wdCBzdHJpbmdcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY2xvc2UgaW5wdXQgYW5kIG91dHB1dCBjaGFubmVsc1xyXG4vKiBhYmI1ICovICAgICAgICBfYF9hYmI1YDsgIExEQS56cGcgKFwiY2hhbm5sXzAwMTNcIik7ICAgICAgLy8gZ2V0IGN1cnJlbnQgSS9PIGNoYW5uZWxcclxuLyogYWJiNyAqLyAgICAgICAgX2BfYWJiN2A7ICBKU1IuYWJzIChcImNscmNobl9mZmNjXCIpOyAgICAgIC8vIGNsb3NlIGlucHV0IGFuZCBvdXRwdXQgY2hhbm5lbHNcclxuLyogYWJiYSAqLyAgICAgICAgICAgICAgICAgICBMRFguaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBYXHJcbi8qIGFiYmMgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJjaGFubmxfMDAxM1wiKTsgICAgICAvLyBjbGVhciBjdXJyZW50IEkvTyBjaGFubmVsLCBmbGFnIGRlZmF1bHRcclxuLyogYWJiZSAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBwZXJmb3JtIElOUFVUXHJcbi8qIGFiYmYgKi8gICBfYGlucHV0X2FiYmZgOyAgQ01QLmltbSAoMHgyMik7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSBuZXh0IGJ5dGUgd2l0aCBvcGVuIHF1b3RlXHJcbi8qIGFiYzEgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYWJjZVwiKTsgICAgICAgICAgICAvLyBpZiBubyBwcm9tcHQgc3RyaW5nIGp1c3QgZG8gSU5QVVRcclxuLyogYWJjMyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9hZWJkXCIpOyAgICAgICAgICAgIC8vIHByaW50IFwiLi4uXCIgc3RyaW5nXHJcbi8qIGFiYzYgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgzYik7ICAgICAgICAgICAgICAgLy8gbG9hZCBBIHdpdGggXCI7XCJcclxuLyogYWJjOCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImNoa2NvbV9hZWZmXCIpOyAgICAgIC8vIHNjYW4gZm9yIENIUiQoQSksIGVsc2UgZG8gc3ludGF4IGVycm9yIHRoZW4gd2FybSBzdGFydFxyXG4vKiBhYmNiICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2FiMjFcIik7ICAgICAgICAgICAgLy8gcHJpbnQgc3RyaW5nIGZyb20gdXRpbGl0eSBwb2ludGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uZSB3aXRoIHByb21wdCwgbm93IGdldCBkYXRhXHJcbi8qIGFiY2UgKi8gICAgICAgIF9gX2FiY2VgOyAgSlNSLmFicyAoXCJlcnJkaXJfYjNhNlwiKTsgICAgICAvLyBjaGVjayBub3QgRGlyZWN0LCBiYWNrIGhlcmUgaWYgb2tcclxuLyogYWJkMSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDJjKTsgICAgICAgICAgICAgICAvLyBzZXQgXCIsXCJcclxuLyogYWJkMyAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcImJzdGFjaysxOTJfMDFmZlwiKTsgIC8vIHNhdmUgdG8gc3RhcnQgb2YgYnVmZmVyIC0gMVxyXG4vKiBhYmQ2ICovICAgICAgICBfYF9hYmQ2YDsgIEpTUi5hYnMgKFwicWlubGluX2FiZjlcIik7ICAgICAgLy8gcHJpbnQgXCI/IFwiIGFuZCBnZXQgQkFTSUMgaW5wdXRcclxuLyogYWJkOSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImNoYW5ubF8wMDEzXCIpOyAgICAgIC8vIGdldCBjdXJyZW50IEkvTyBjaGFubmVsXHJcbi8qIGFiZGIgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJidWZmdWxfYWJlYVwiKTsgICAgICAvLyBicmFuY2ggaWYgZGVmYXVsdCBJL08gY2hhbm5lbFxyXG4vKiBhYmRkICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwicmVhZHN0X2ZmYjdcIik7ICAgICAgLy8gcmVhZCBJL08gc3RhdHVzIHdvcmRcclxuLyogYWJlMCAqLyAgICAgICAgICAgICAgICAgICBBTkQuaW1tICgweDAyKTsgICAgICAgICAgICAgICAvLyBtYXNrIG5vIERTUi90aW1lb3V0XHJcbi8qIGFiZTIgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJidWZmdWxfYWJlYVwiKTsgICAgICAvLyBicmFuY2ggaWYgbm90IGVycm9yXHJcbi8qIGFiZTQgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfYWJiNVwiKTsgICAgICAgICAgICAvLyBjbG9zZSBpbnB1dCBhbmQgb3V0cHV0IGNoYW5uZWxzXHJcbi8qIGFiZTcgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJkYXRhX2E4ZjhcIik7ICAgICAgICAvLyBwZXJmb3JtIERBVEFcclxuLyogYWJlYSAqLyAgX2BidWZmdWxfYWJlYWA7ICBMREEuYWJzIChcImJ1ZiswXzAyMDBcIik7ICAgICAgIC8vIGdldCBmaXJzdCBieXRlIGluIGlucHV0IGJ1ZmZlclxyXG4vKiBhYmVkICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2FjMGRcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vdCBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSAuLlxyXG4vKiBhYmVmICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiY2hhbm5sXzAwMTNcIik7ICAgICAgLy8gZ2V0IGN1cnJlbnQgSS9PIGNoYW5uZWxcclxuLyogYWJmMSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9hYmQ2XCIpOyAgICAgICAgICAgIC8vIGlmIG5vdCBkZWZhdWx0IGNoYW5uZWwgZ28gZ2V0IEJBU0lDIGlucHV0XHJcbi8qIGFiZjMgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJkYXRhbl9hOTA2XCIpOyAgICAgICAvLyBzY2FuIGZvciBuZXh0IEJBU0lDIHN0YXRlbWVudCAoWzpdIG9yIFtFT0xdKVxyXG4vKiBhYmY2ICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2E4ZmJcIik7ICAgICAgICAgICAgLy8gYWRkIFkgdG8gdGhlIEJBU0lDIGV4ZWN1dGUgcG9pbnRlciBhbmQgcmV0dXJuXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHByaW50IFwiPyBcIiBhbmQgZ2V0IEJBU0lDIGlucHV0XHJcbi8qIGFiZjkgKi8gIF9gcWlubGluX2FiZjlgOyAgTERBLnpwZyAoXCJjaGFubmxfMDAxM1wiKTsgICAgICAvLyBnZXQgY3VycmVudCBJL08gY2hhbm5lbFxyXG4vKiBhYmZiICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2FjMDNcIik7ICAgICAgICAgICAgLy8gc2tpcCBcIj9cIiBwcm9tcHQgaWYgbm90IGRlZmF1bHQgY2hhbm5lbFxyXG4vKiBhYmZkICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2FiNDVcIik7ICAgICAgICAgICAgLy8gcHJpbnQgXCI/XCJcclxuLyogYWMwMCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIm91dHNwY19hYjNiXCIpOyAgICAgIC8vIHByaW50IFtTUEFDRV0gb3IgW0NVUlNPUiBSSUdIVF1cclxuLyogYWMwMyAqLyAgICAgICAgX2BfYWMwM2A7ICBKTVAuYWJzIChcImlubGluX2E1NjBcIik7ICAgICAgIC8vIGNhbGwgZm9yIEJBU0lDIGlucHV0IGFuZCByZXR1cm5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcGVyZm9ybSBSRUFEXHJcbi8qIGFjMDYgKi8gICAgX2ByZWFkX2FjMDZgOyAgTERYLnpwZyAoXCJkYXRwdHIrMF8wMDQxXCIpOyAgICAvLyBnZXQgREFUQSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGFjMDggKi8gICAgICAgICAgICAgICAgICAgTERZLnpwZyAoXCJkYXRwdHIrMV8wMDQyXCIpOyAgICAvLyBnZXQgREFUQSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBhYzBhICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4OTgpOyAgICAgICAgICAgICAgIC8vIHNldCBpbnB1dCBtb2RlID0gUkVBRFxyXG4vKiBhYzBjICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgyYyk7ICAgICAgICAgICAgICAgIC8vIG1ha2VzIG5leHQgbGluZSBCSVQgJDAwQTlcclxuLyogYWMwZCAqLyAgICAgICAgX2BfYWMwZGA7ICBMREEuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBzZXQgaW5wdXQgbW9kZSA9IElOUFVUXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHBlcmZvcm0gR0VUXHJcbi8qIGFjMGYgKi8gICAgICAgIF9gX2FjMGZgOyAgU1RBLnpwZyAoXCJpbnBmbGdfMDAxMVwiKTsgICAgICAvLyBzZXQgaW5wdXQgbW9kZSBmbGFnLCAkMDAgPSBJTlBVVCwgJDQwID0gR0VULCAkOTggPSBSRUFEXHJcbi8qIGFjMTEgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJpbnBwdHIrMF8wMDQzXCIpOyAgICAvLyBzYXZlIFJFQUQgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBhYzEzICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwiaW5wcHRyKzFfMDA0NFwiKTsgICAgLy8gc2F2ZSBSRUFEIHBvaW50ZXIgaGlnaCBieXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUkVBRCwgR0VUIG9yIElOUFVUIG5leHQgdmFyaWFibGUgZnJvbSBsaXN0XHJcbi8qIGFjMTUgKi8gICAgICAgIF9gX2FjMTVgOyAgSlNSLmFicyAoXCJwdHJnZXRfYjA4YlwiKTsgICAgICAvLyBnZXQgdmFyaWFibGUgYWRkcmVzc1xyXG4vKiBhYzE4ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZm9ycG50KzBfMDA0OVwiKTsgICAgLy8gc2F2ZSBhZGRyZXNzIGxvdyBieXRlXHJcbi8qIGFjMWEgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJmb3JwbnQrMV8wMDRhXCIpOyAgICAvLyBzYXZlIGFkZHJlc3MgaGlnaCBieXRlXHJcbi8qIGFjMWMgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ0eHRwdHIrMF8wMDdhXCIpOyAgICAvLyBnZXQgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGFjMWUgKi8gICAgICAgICAgICAgICAgICAgTERZLnpwZyAoXCJ0eHRwdHIrMV8wMDdiXCIpOyAgICAvLyBnZXQgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBhYzIwICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwib3BwdHIrMF8wMDRiXCIpOyAgICAgLy8gc2F2ZSBCQVNJQyBleGVjdXRlIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYWMyMiAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcIm9wcHRyKzFfMDA0Y1wiKTsgICAgIC8vIHNhdmUgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBhYzI0ICovICAgICAgICAgICAgICAgICAgIExEWC56cGcgKFwiaW5wcHRyKzBfMDA0M1wiKTsgICAgLy8gZ2V0IFJFQUQgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBhYzI2ICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwiaW5wcHRyKzFfMDA0NFwiKTsgICAgLy8gZ2V0IFJFQUQgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYWMyOCAqLyAgICAgICAgICAgICAgICAgICBTVFguenBnIChcInR4dHB0ciswXzAwN2FcIik7ICAgIC8vIHNhdmUgYXMgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGFjMmEgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJ0eHRwdHIrMV8wMDdiXCIpOyAgICAvLyBzYXZlIGFzIEJBU0lDIGV4ZWN1dGUgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYWMyYyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImNocmdvdF8wMDc5XCIpOyAgICAgIC8vIHNjYW4gbWVtb3J5XHJcbi8qIGFjMmYgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYWM1MVwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbm90IG51bGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludGVyIHdhcyB0byBudWxsIGVudHJ5XHJcbi8qIGFjMzEgKi8gICAgICAgICAgICAgICAgICAgQklULnpwZyAoXCJpbnBmbGdfMDAxMVwiKTsgICAgICAvLyB0ZXN0IGlucHV0IG1vZGUgZmxhZywgJDAwID0gSU5QVVQsICQ0MCA9IEdFVCwgJDk4ID0gUkVBRFxyXG4vKiBhYzMzICovICAgICAgICAgICAgICAgICAgIEJWQy5yZWwgKFwiX2FjNDFcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vdCBHRVRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIHdhcyBHRVRcclxuLyogYWMzNSAqLyAgIF9gcmRnZXRfYWMzNWA7ICBKU1IuYWJzIChcImJnZXRpbl9lMTI0XCIpOyAgICAgIC8vIGdldCBjaGFyYWN0ZXIgZnJvbSBpbnB1dCBkZXZpY2Ugd2l0aCBlcnJvciBjaGVja1xyXG4vKiBhYzM4ICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiYnVmKzBfMDIwMFwiKTsgICAgICAgLy8gc2F2ZSB0byBidWZmZXJcclxuLyogYWMzYiAqLyAgICAgICAgICAgICAgICAgICBMRFguaW1tICgweGZmKTsgICAgICAgICAgICAgICAvLyBzZXQgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBhYzNkICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4MDEpOyAgICAgICAgICAgICAgIC8vIHNldCBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBhYzNmICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2FjNGRcIik7ICAgICAgICAgICAgLy8gZ28gaW50ZXJwcmV0IHNpbmdsZSBjaGFyYWN0ZXJcclxuLyogYWM0MSAqLyAgICAgICAgX2BfYWM0MWA7ICBCTUkucmVsIChcIl9hY2I4XCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBSRUFEXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSB3YXMgSU5QVVRcclxuLyogYWM0MyAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImNoYW5ubF8wMDEzXCIpOyAgICAgIC8vIGdldCBjdXJyZW50IEkvTyBjaGFubmVsXHJcbi8qIGFjNDUgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYWM0YVwiKTsgICAgICAgICAgICAvLyBza2lwIFwiP1wiIHByb21wdCBpZiBub3QgZGVmYXVsdCBjaGFubmVsXHJcbi8qIGFjNDcgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfYWI0NVwiKTsgICAgICAgICAgICAvLyBwcmludCBcIj9cIlxyXG4vKiBhYzRhICovICAgICAgICBfYF9hYzRhYDsgIEpTUi5hYnMgKFwicWlubGluX2FiZjlcIik7ICAgICAgLy8gcHJpbnQgXCI/IFwiIGFuZCBnZXQgQkFTSUMgaW5wdXRcclxuLyogYWM0ZCAqLyAgICAgICAgX2BfYWM0ZGA7ICBTVFguenBnIChcInR4dHB0ciswXzAwN2FcIik7ICAgIC8vIHNhdmUgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGFjNGYgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJ0eHRwdHIrMV8wMDdiXCIpOyAgICAvLyBzYXZlIEJBU0lDIGV4ZWN1dGUgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYWM1MSAqLyAgICAgICAgX2BfYWM1MWA7ICBKU1IuYWJzIChcImNocmdldCswXzAwNzNcIik7ICAgIC8vIGluY3JlbWVudCBhbmQgc2NhbiBtZW1vcnksIGV4ZWN1dGUgcG9pbnRlciBub3cgcG9pbnRzIHRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnQgb2YgbmV4dCBkYXRhIG9yIG51bGwgdGVybWluYXRvclxyXG4vKiBhYzU0ICovICAgICAgICAgICAgICAgICAgIEJJVC56cGcgKFwidmFsdHlwXzAwMGRcIik7ICAgICAgLy8gdGVzdCBkYXRhIHR5cGUgZmxhZywgJEZGID0gc3RyaW5nLCAkMDAgPSBudW1lcmljXHJcbi8qIGFjNTYgKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfYWM4OVwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbnVtZXJpY1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHR5cGUgaXMgc3RyaW5nXHJcbi8qIGFjNTggKi8gICAgICAgICAgICAgICAgICAgQklULnpwZyAoXCJpbnBmbGdfMDAxMVwiKTsgICAgICAvLyB0ZXN0IElOUFVUIG1vZGUgZmxhZywgJDAwID0gSU5QVVQsICQ0MCA9IEdFVCwgJDk4ID0gUkVBRFxyXG4vKiBhYzVhICovICAgICAgICAgICAgICAgICAgIEJWQy5yZWwgKFwiX2FjNjVcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vdCBHRVRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIGRvIHN0cmluZyBHRVRcclxuLyogYWM1YyAqLyAgICAgICAgICAgICAgICAgICBJTlguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBYID8/XHJcbi8qIGFjNWQgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJ0eHRwdHIrMF8wMDdhXCIpOyAgICAvLyBzYXZlIEJBU0lDIGV4ZWN1dGUgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBhYzVmICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIEFcclxuLyogYWM2MSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImNoYXJhY18wMDA3XCIpOyAgICAgIC8vIGNsZWFyIHNlYXJjaCBjaGFyYWN0ZXJcclxuLyogYWM2MyAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9hYzcxXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBhbHdheXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBzdHJpbmcgSU5QVVQgb3Igc3RyaW5nIFJFQURcclxuLyogYWM2NSAqLyAgICAgICAgX2BfYWM2NWA7ICBTVEEuenBnIChcImNoYXJhY18wMDA3XCIpOyAgICAgIC8vIHNhdmUgc2VhcmNoIGNoYXJhY3RlclxyXG4vKiBhYzY3ICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4MjIpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCBcIlxyXG4vKiBhYzY5ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2FjNzJcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIHF1b3RlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5nIGlzIG5vdCBpbiBxdW90ZXMgc28gXCI6XCIsIFwiLFwiIG9yICQwMCBhcmUgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGVybWluYXRpb24gY2hhcmFjdGVyc1xyXG4vKiBhYzZiICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4M2EpOyAgICAgICAgICAgICAgIC8vIHNldCBcIjpcIlxyXG4vKiBhYzZkICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiY2hhcmFjXzAwMDdcIik7ICAgICAgLy8gc2V0IHNlYXJjaCBjaGFyYWN0ZXJcclxuLyogYWM2ZiAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDJjKTsgICAgICAgICAgICAgICAvLyBzZXQgXCIsXCJcclxuLyogYWM3MSAqLyAgICAgICAgX2BfYWM3MWA7ICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBjYXJyeSBmb3IgYWRkXHJcbi8qIGFjNzIgKi8gICAgICAgIF9gX2FjNzJgOyAgU1RBLnpwZyAoXCJlbmRjaHJfMDAwOFwiKTsgICAgICAvLyBzZXQgc2NhbiBxdW90ZXMgZmxhZ1xyXG4vKiBhYzc0ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwidHh0cHRyKzBfMDA3YVwiKTsgICAgLy8gZ2V0IEJBU0lDIGV4ZWN1dGUgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBhYzc2ICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwidHh0cHRyKzFfMDA3YlwiKTsgICAgLy8gZ2V0IEJBU0lDIGV4ZWN1dGUgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYWM3OCAqLyAgICAgICAgICAgICAgICAgICBBREMuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBhZGQgdG8gcG9pbnRlciBsb3cgYnl0ZS4gdGhpcyBhZGQgaW5jcmVtZW50cyB0aGUgcG9pbnRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBtb2RlIGlzIElOUFVUIG9yIFJFQUQgYW5kIHRoZSBkYXRhIGlzIGEgXCIuLi5cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZ1xyXG4vKiBhYzdhICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2FjN2RcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vIHJvbGxvdmVyXHJcbi8qIGFjN2MgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBpbmNyZW1lbnQgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYWM3ZCAqLyAgICAgICAgX2BfYWM3ZGA7ICBKU1IuYWJzIChcIl9iNDhkXCIpOyAgICAgICAgICAgIC8vIHByaW50IHN0cmluZyB0byB1dGlsaXR5IHBvaW50ZXJcclxuLyogYWM4MCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9iN2UyXCIpOyAgICAgICAgICAgIC8vIHJlc3RvcmUgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGZyb20gdGVtcFxyXG4vKiBhYzgzICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2E5ZGFcIik7ICAgICAgICAgICAgLy8gcGVyZm9ybSBzdHJpbmcgTEVUXHJcbi8qIGFjODYgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfYWM5MVwiKTsgICAgICAgICAgICAvLyBjb250aW51ZSBwcm9jZXNzaW5nIGNvbW1hbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHRVQsIElOUFVUIG9yIFJFQUQgaXMgbnVtZXJpY1xyXG4vKiBhYzg5ICovICAgICAgICBfYF9hYzg5YDsgIEpTUi5hYnMgKFwiZmluX2JjZjNcIik7ICAgICAgICAgLy8gZ2V0IEZBQzEgZnJvbSBzdHJpbmdcclxuLyogYWM4YyAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImludGZsZ18wMDBlXCIpOyAgICAgIC8vIGdldCBkYXRhIHR5cGUgZmxhZywgJDgwID0gaW50ZWdlciwgJDAwID0gZmxvYXRcclxuLyogYWM4ZSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9hOWMyXCIpOyAgICAgICAgICAgIC8vIGFzc2lnbiB2YWx1ZSB0byBudW1lcmljIHZhcmlhYmxlXHJcbi8qIGFjOTEgKi8gICAgICAgIF9gX2FjOTFgOyAgSlNSLmFicyAoXCJjaHJnb3RfMDA3OVwiKTsgICAgICAvLyBzY2FuIG1lbW9yeVxyXG4vKiBhYzk0ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2FjOWRcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIFwiOlwiIG9yIFtFT0xdXHJcbi8qIGFjOTYgKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHgyYyk7ICAgICAgICAgICAgICAgLy8gY29tcGFydGUgd2l0aCBcIixcIlxyXG4vKiBhYzk4ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2FjOWRcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIFwiLFwiXHJcbi8qIGFjOWEgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJkb2FnaW5fYWI0ZFwiKTsgICAgICAvLyBlbHNlIGdvIGRvIGJhZCBpbnB1dCByb3V0aW5lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5nIHRlcm1pbmF0ZWQgd2l0aCBcIjpcIiwgXCIsXCIgb3IgJDAwXHJcbi8qIGFjOWQgKi8gICAgICAgIF9gX2FjOWRgOyAgTERBLnpwZyAoXCJ0eHRwdHIrMF8wMDdhXCIpOyAgICAvLyBnZXQgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGFjOWYgKi8gICAgICAgICAgICAgICAgICAgTERZLnpwZyAoXCJ0eHRwdHIrMV8wMDdiXCIpOyAgICAvLyBnZXQgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBhY2ExICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiaW5wcHRyKzBfMDA0M1wiKTsgICAgLy8gc2F2ZSBSRUFEIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYWNhMyAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcImlucHB0cisxXzAwNDRcIik7ICAgIC8vIHNhdmUgUkVBRCBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBhY2E1ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwib3BwdHIrMF8wMDRiXCIpOyAgICAgLy8gZ2V0IHNhdmVkIEJBU0lDIGV4ZWN1dGUgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBhY2E3ICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwib3BwdHIrMV8wMDRjXCIpOyAgICAgLy8gZ2V0IHNhdmVkIEJBU0lDIGV4ZWN1dGUgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYWNhOSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInR4dHB0ciswXzAwN2FcIik7ICAgIC8vIHJlc3RvcmUgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGFjYWIgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJ0eHRwdHIrMV8wMDdiXCIpOyAgICAvLyByZXN0b3JlIEJBU0lDIGV4ZWN1dGUgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYWNhZCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImNocmdvdF8wMDc5XCIpOyAgICAgIC8vIHNjYW4gbWVtb3J5XHJcbi8qIGFjYjAgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYWNkZlwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgXCI6XCIgb3IgW0VPTF1cclxuLyogYWNiMiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9hZWZkXCIpOyAgICAgICAgICAgIC8vIHNjYW4gZm9yIFwiLFwiLCBlbHNlIGRvIHN5bnRheCBlcnJvciB0aGVuIHdhcm0gc3RhcnRcclxuLyogYWNiNSAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9hYzE1XCIpOyAgICAgICAgICAgIC8vIGdvIFJFQUQgb3IgSU5QVVQgbmV4dCB2YXJpYWJsZSBmcm9tIGxpc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3YXMgUkVBRFxyXG4vKiBhY2I4ICovICAgICAgICBfYF9hY2I4YDsgIEpTUi5hYnMgKFwiZGF0YW5fYTkwNlwiKTsgICAgICAgLy8gc2NhbiBmb3IgbmV4dCBCQVNJQyBzdGF0ZW1lbnQgKFs6XSBvciBbRU9MXSlcclxuLyogYWNiYiAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgaW5kZXggdG8gbmV4dCBieXRlXHJcbi8qIGFjYmMgKi8gICAgICAgICAgICAgICAgICAgVEFYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBieXRlIHRvIFhcclxuLyogYWNiZCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9hY2QxXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBcIjpcIlxyXG4vKiBhY2JmICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4MGQpOyAgICAgICAgICAgICAgIC8vIGVsc2Ugc2V0IGVycm9yICQwRCwgb3V0IG9mIGRhdGEgZXJyb3JcclxuLyogYWNjMSAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgaW5kZXggdG8gbmV4dCBsaW5lIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGFjYzIgKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJ0eHRwdHIrMF8wMDdhXCIpOyAgICAvLyBnZXQgbmV4dCBsaW5lIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGFjYzQgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYWQzMlwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgcHJvZ3JhbSBlbmQsIGV2ZW50dWFsbHkgZG9lcyBlcnJvciBYXHJcbi8qIGFjYzYgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGluZGV4XHJcbi8qIGFjYzcgKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJ0eHRwdHIrMF8wMDdhXCIpOyAgICAvLyBnZXQgbmV4dCBsaW5lICMgbG93IGJ5dGVcclxuLyogYWNjOSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImRhdGxpbiswXzAwM2ZcIik7ICAgIC8vIHNhdmUgY3VycmVudCBEQVRBIGxpbmUgbG93IGJ5dGVcclxuLyogYWNjYiAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgaW5kZXhcclxuLyogYWNjYyAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcInR4dHB0ciswXzAwN2FcIik7ICAgIC8vIGdldCBuZXh0IGxpbmUgIyBoaWdoIGJ5dGVcclxuLyogYWNjZSAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgaW5kZXhcclxuLyogYWNjZiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImRhdGxpbisxXzAwNDBcIik7ICAgIC8vIHNhdmUgY3VycmVudCBEQVRBIGxpbmUgaGlnaCBieXRlXHJcbi8qIGFjZDEgKi8gICAgICAgIF9gX2FjZDFgOyAgSlNSLmFicyAoXCJfYThmYlwiKTsgICAgICAgICAgICAvLyBhZGQgWSB0byB0aGUgQkFTSUMgZXhlY3V0ZSBwb2ludGVyXHJcbi8qIGFjZDQgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJjaHJnb3RfMDA3OVwiKTsgICAgICAvLyBzY2FuIG1lbW9yeVxyXG4vKiBhY2Q3ICovICAgICAgICAgICAgICAgICAgIFRBWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgdGhlIGJ5dGVcclxuLyogYWNkOCAqLyAgICAgICAgICAgICAgICAgICBDUFguaW1tICgweDgzKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIGl0IHdpdGggdG9rZW4gZm9yIERBVEFcclxuLyogYWNkYSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9hY2I4XCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgbm90IERBVEFcclxuLyogYWNkYyAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9hYzUxXCIpOyAgICAgICAgICAgIC8vIGNvbnRpbnVlIGV2YWx1YXRpbmcgUkVBRFxyXG4vKiBhY2RmICovICAgICAgICBfYF9hY2RmYDsgIExEQS56cGcgKFwiaW5wcHRyKzBfMDA0M1wiKTsgICAgLy8gZ2V0IFJFQUQgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBhY2UxICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwiaW5wcHRyKzFfMDA0NFwiKTsgICAgLy8gZ2V0IFJFQUQgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYWNlMyAqLyAgICAgICAgICAgICAgICAgICBMRFguenBnIChcImlucGZsZ18wMDExXCIpOyAgICAgIC8vIGdldCBJTlBVVCBtb2RlIGZsYWcsICQwMCA9IElOUFVULCAkNDAgPSBHRVQsICQ5OCA9IFJFQURcclxuLyogYWNlNSAqLyAgICAgICAgICAgICAgICAgICBCUEwucmVsIChcIl9hY2VhXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBJTlBVVCBvciBHRVRcclxuLyogYWNlNyAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9hODI3XCIpOyAgICAgICAgICAgIC8vIGVsc2Ugc2V0IGRhdGEgcG9pbnRlciBhbmQgZXhpdFxyXG4vKiBhY2VhICovICAgICAgICBfYF9hY2VhYDsgIExEWS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIGluZGV4XHJcbi8qIGFjZWMgKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJpbnBwdHIrMF8wMDQzXCIpOyAgICAvLyBnZXQgUkVBRCBieXRlXHJcbi8qIGFjZWUgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYWNmYlwiKTsgICAgICAgICAgICAvLyBleGl0IGlmIFtFT0xdXHJcbi8qIGFjZjAgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJjaGFubmxfMDAxM1wiKTsgICAgICAvLyBnZXQgY3VycmVudCBJL08gY2hhbm5lbFxyXG4vKiBhY2YyICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2FjZmJcIik7ICAgICAgICAgICAgLy8gZXhpdCBpZiBub3QgZGVmYXVsdCBjaGFubmVsXHJcbi8qIGFjZjQgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHhmYyk7ICAgICAgICAgICAgICAgLy8gc2V0IFwiP0VYVFJBIElHTk9SRURcIiBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGFjZjYgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHhhYyk7ICAgICAgICAgICAgICAgLy8gc2V0IFwiP0VYVFJBIElHTk9SRURcIiBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBhY2Y4ICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwic3Ryb3V0X2FiMWVcIik7ICAgICAgLy8gcHJpbnQgbnVsbCB0ZXJtaW5hdGVkIHN0cmluZ1xyXG4vKiBhY2ZiICovICAgICAgICBfYF9hY2ZiYDsgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGlucHV0IGVycm9yIG1lc3NhZ2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJz9leHRyYSBpZ25vcmVkJ1xyXG4vKiBhY2ZjICovICAgX2BleGludF9hY2ZjYDsgIF8uYnl0ZXMoMHgzZiwgMHg0NSwgMHg1OCwgMHg1NCwgMHg1MiwgMHg0MSwgMHgyMCwgMHg0OSk7XHJcbi8qIGFkMDQgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDQ3LCAweDRlLCAweDRmLCAweDUyLCAweDQ1LCAweDQ0LCAweDBkLCAweDAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAnP3JlZG8gZnJvbSBzdGFydCdcclxuLyogYWQwYyAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4M2YsIDB4NTIsIDB4NDUsIDB4NDQsIDB4NGYsIDB4MjAsIDB4NDYsIDB4NTIpO1xyXG4vKiBhZDE0ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg0ZiwgMHg0ZCwgMHgyMCwgMHg1MywgMHg1NCwgMHg0MSwgMHg1MiwgMHg1NCk7XHJcbi8qIGFkMWMgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDBkLCAweDAwKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcGVyZm9ybSBORVhUXHJcbi8qIGFkMWUgKi8gICAgX2BuZXh0X2FkMWVgOyAgQk5FLnJlbCAoXCJfYWQyNFwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgTkVYVCB2YXJpYWJsZVxyXG4vKiBhZDIwICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGVsc2UgY2xlYXIgWVxyXG4vKiBhZDIyICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2FkMjdcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGFsd2F5c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5FWFQgdmFyaWFibGVcclxuLyogYWQyNCAqLyAgICAgICAgX2BfYWQyNGA7ICBKU1IuYWJzIChcInB0cmdldF9iMDhiXCIpOyAgICAgIC8vIGdldCB2YXJpYWJsZSBhZGRyZXNzXHJcbi8qIGFkMjcgKi8gICAgICAgIF9gX2FkMjdgOyAgU1RBLnpwZyAoXCJmb3JwbnQrMF8wMDQ5XCIpOyAgICAvLyBzYXZlIEZPUi9ORVhUIHZhcmlhYmxlIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYWQyOSAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcImZvcnBudCsxXzAwNGFcIik7ICAgIC8vIHNhdmUgRk9SL05FWFQgdmFyaWFibGUgcG9pbnRlciBoaWdoIGJ5dGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAoaGlnaCBieXRlIGNsZWFyZWQgaWYgbm8gdmFyaWFibGUgZGVmaW5lZClcclxuLyogYWQyYiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImZuZGZvcl9hMzhhXCIpOyAgICAgIC8vIHNlYXJjaCB0aGUgc3RhY2sgZm9yIEZPUiBvciBHT1NVQiBhY3Rpdml0eVxyXG4vKiBhZDJlICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2FkMzVcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIEZPUiwgdGhpcyB2YXJpYWJsZSwgZm91bmRcclxuLyogYWQzMCAqLyAgICAgICAgICAgICAgICAgICBMRFguaW1tICgweDBhKTsgICAgICAgICAgICAgICAvLyBlbHNlIHNldCBlcnJvciAkMEEsIG5leHQgd2l0aG91dCBmb3IgZXJyb3JcclxuLyogYWQzMiAqLyAgICAgICAgX2BfYWQzMmA7ICBKTVAuYWJzIChcImVycm9yX2E0MzdcIik7ICAgICAgIC8vIGRvIGVycm9yICNYIHRoZW4gd2FybSBzdGFydFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvdW5kIHRoaXMgRk9SIHZhcmlhYmxlXHJcbi8qIGFkMzUgKi8gICAgICAgIF9gX2FkMzVgOyAgVFhTLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHN0YWNrIHBvaW50ZXJcclxuLyogYWQzNiAqLyAgICAgICAgICAgICAgICAgICBUWEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IHN0YWNrIHBvaW50ZXJcclxuLyogYWQzNyAqLyAgICAgICAgICAgICAgICAgICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBjYXJyeSBmb3IgYWRkXHJcbi8qIGFkMzggKi8gICAgICAgICAgICAgICAgICAgQURDLmltbSAoMHgwNCk7ICAgICAgICAgICAgICAgLy8gcG9pbnQgdG8gU1RFUCB2YWx1ZVxyXG4vKiBhZDNhICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgaXRcclxuLyogYWQzYiAqLyAgICAgICAgICAgICAgICAgICBBREMuaW1tICgweDA2KTsgICAgICAgICAgICAgICAvLyBwb2ludCB0byBUTyB2YWx1ZVxyXG4vKiBhZDNkICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiaW5kZXgrMl8wMDI0XCIpOyAgICAgLy8gc2F2ZSBwb2ludGVyIHRvIFRPIHZhcmlhYmxlIGZvciBjb21wYXJlXHJcbi8qIGFkM2YgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBwb2ludGVyIHRvIFNURVAgdmFsdWVcclxuLyogYWQ0MCAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAxKTsgICAgICAgICAgICAgICAvLyBwb2ludCB0byBzdGFjayBwYWdlXHJcbi8qIGFkNDIgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJtb3ZmbV9iYmEyXCIpOyAgICAgICAvLyB1bnBhY2sgbWVtb3J5IChBWSkgaW50byBGQUMxXHJcbi8qIGFkNDUgKi8gICAgICAgICAgICAgICAgICAgVFNYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHN0YWNrIHBvaW50ZXIgYmFja1xyXG4vKiBhZDQ2ICovICAgICAgICAgICAgICAgICAgIExEQS5hYnggKFwiYmFkKzlfMDEwOVwiKTsgICAgICAgLy8gZ2V0IHN0ZXAgc2lnblxyXG4vKiBhZDQ5ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZmFjc2duXzAwNjZcIik7ICAgICAgLy8gc2F2ZSBGQUMxIHNpZ24gKGI3KVxyXG4vKiBhZDRiICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZm9ycG50KzBfMDA0OVwiKTsgICAgLy8gZ2V0IEZPUi9ORVhUIHZhcmlhYmxlIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYWQ0ZCAqLyAgICAgICAgICAgICAgICAgICBMRFkuenBnIChcImZvcnBudCsxXzAwNGFcIik7ICAgIC8vIGdldCBGT1IvTkVYVCB2YXJpYWJsZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBhZDRmICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiZmFkZF9iODY3XCIpOyAgICAgICAgLy8gYWRkIEZPUiB2YXJpYWJsZSB0byBGQUMxXHJcbi8qIGFkNTIgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfYmJkMFwiKTsgICAgICAgICAgICAvLyBwYWNrIEZBQzEgaW50byBGT1IgdmFyaWFibGVcclxuLyogYWQ1NSAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAxKTsgICAgICAgICAgICAgICAvLyBwb2ludCB0byBzdGFjayBwYWdlXHJcbi8qIGFkNTcgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfYmM1ZFwiKTsgICAgICAgICAgICAvLyBjb21wYXJlIEZBQzEgd2l0aCBUTyB2YWx1ZVxyXG4vKiBhZDVhICovICAgICAgICAgICAgICAgICAgIFRTWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGdldCBzdGFjayBwb2ludGVyIGJhY2tcclxuLyogYWQ1YiAqLyAgICAgICAgICAgICAgICAgICBTRUMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzZXQgY2FycnkgZm9yIHN1YnRyYWN0XHJcbi8qIGFkNWMgKi8gICAgICAgICAgICAgICAgICAgU0JDLmFieCAoXCJiYWQrOV8wMTA5XCIpOyAgICAgICAvLyBzdWJ0cmFjdCBzdGVwIHNpZ25cclxuLyogYWQ1ZiAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9hZDc4XCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiA9LCBsb29wIGNvbXBsZXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9vcCBiYWNrIGFuZCBkbyBpdCBhbGwgYWdhaW5cclxuLyogYWQ2MSAqLyAgX2Bkb25leHRfYWQ2MWA7ICBMREEuYWJ4IChcImJhZCsxNV8wMTBmXCIpOyAgICAgIC8vIGdldCBGT1IgbGluZSBsb3cgYnl0ZVxyXG4vKiBhZDY0ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiY3VybGluKzBfMDAzOVwiKTsgICAgLy8gc2F2ZSBjdXJyZW50IGxpbmUgbnVtYmVyIGxvdyBieXRlXHJcbi8qIGFkNjYgKi8gICAgICAgICAgICAgICAgICAgTERBLmFieCAoXCJiYWQrMTZfMDExMFwiKTsgICAgICAvLyBnZXQgRk9SIGxpbmUgaGlnaCBieXRlXHJcbi8qIGFkNjkgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJjdXJsaW4rMV8wMDNhXCIpOyAgICAvLyBzYXZlIGN1cnJlbnQgbGluZSBudW1iZXIgaGlnaCBieXRlXHJcbi8qIGFkNmIgKi8gICAgICAgICAgICAgICAgICAgTERBLmFieCAoXCJiYWQrMThfMDExMlwiKTsgICAgICAvLyBnZXQgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGFkNmUgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJ0eHRwdHIrMF8wMDdhXCIpOyAgICAvLyBzYXZlIEJBU0lDIGV4ZWN1dGUgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBhZDcwICovICAgICAgICAgICAgICAgICAgIExEQS5hYnggKFwiYmFkKzE3XzAxMTFcIik7ICAgICAgLy8gZ2V0IEJBU0lDIGV4ZWN1dGUgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYWQ3MyAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInR4dHB0cisxXzAwN2JcIik7ICAgIC8vIHNhdmUgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBhZDc1ICovICAgICAgICBfYF9hZDc1YDsgIEpNUC5hYnMgKFwibmV3c3R0X2E3YWVcIik7ICAgICAgLy8gZ28gZG8gaW50ZXJwcmV0ZXIgaW5uZXIgbG9vcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5FWFQgbG9vcCBjb21sZXRlXHJcbi8qIGFkNzggKi8gICAgICAgIF9gX2FkNzhgOyAgVFhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc3RhY2sgY29weSB0byBBXHJcbi8qIGFkNzkgKi8gICAgICAgICAgICAgICAgICAgQURDLmltbSAoMHgxMSk7ICAgICAgICAgICAgICAgLy8gYWRkICQxMiwgJDExICsgY2FycnksIHRvIGR1bXAgRk9SIHN0cnVjdHVyZVxyXG4vKiBhZDdiICovICAgICAgICAgICAgICAgICAgIFRBWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgYmFjayB0byBpbmRleFxyXG4vKiBhZDdjICovICAgICAgICAgICAgICAgICAgIFRYUy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgdG8gc3RhY2sgcG9pbnRlclxyXG4vKiBhZDdkICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiY2hyZ290XzAwNzlcIik7ICAgICAgLy8gc2NhbiBtZW1vcnlcclxuLyogYWQ4MCAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW1tICgweDJjKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggXCIsXCJcclxuLyogYWQ4MiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9hZDc1XCIpOyAgICAgICAgICAgIC8vIGlmIG5vdCBcIixcIiBnbyBkbyBpbnRlcnByZXRlciBpbm5lciBsb29wXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2FzIFwiLFwiIHNvIGFub3RoZXIgTkVYVCB2YXJpYWJsZSB0byBkb1xyXG4vKiBhZDg0ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiY2hyZ2V0KzBfMDA3M1wiKTsgICAgLy8gaW5jcmVtZW50IGFuZCBzY2FuIG1lbW9yeVxyXG4vKiBhZDg3ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2FkMjRcIik7ICAgICAgICAgICAgLy8gZG8gTkVYVCB2YXJpYWJsZVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBldmFsdWF0ZSBleHByZXNzaW9uIGFuZCBjaGVjayB0eXBlIG1pc21hdGNoXHJcbi8qIGFkOGEgKi8gIF9gZnJtbnVtX2FkOGFgOyAgSlNSLmFicyAoXCJmcm1ldmxfYWQ5ZVwiKTsgICAgICAvLyBldmFsdWF0ZSBleHByZXNzaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBhcmUgbnVtZXJpY1xyXG4vKiBhZDhkICovICAgICAgICBfYF9hZDhkYDsgIENMQy5pbXAgKCk7XHJcbi8qIGFkOGUgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDI0KTsgICAgICAgICAgICAgICAgLy8gbWFrZXMgbmV4dCBsaW5lIEJJVCAkMzhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGFyZSBzdHJpbmdcclxuLyogYWQ4ZiAqLyAgICAgICAgX2BfYWQ4ZmA7ICBTRUMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBkZXN0aW5hdGlvbiBpcyBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0eXBlIG1hdGNoIGNoZWNrLCBzZXQgQyBmb3Igc3RyaW5nLCBjbGVhciBDIGZvciBudW1lcmljXHJcbi8qIGFkOTAgKi8gICAgICAgIF9gX2FkOTBgOyAgQklULnpwZyAoXCJ2YWx0eXBfMDAwZFwiKTsgICAgICAvLyB0ZXN0IGRhdGEgdHlwZSBmbGFnLCAkRkYgPSBzdHJpbmcsICQwMCA9IG51bWVyaWNcclxuLyogYWQ5MiAqLyAgICAgICAgICAgICAgICAgICBCTUkucmVsIChcIl9hZDk3XCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBzdHJpbmdcclxuLyogYWQ5NCAqLyAgICAgICAgICAgICAgICAgICBCQ1MucmVsIChcIl9hZDk5XCIpOyAgICAgICAgICAgIC8vIGlmIGRlc3RpYW50aW9uIGlzIG51bWVyaWMgZG8gdHlwZSBtaXNzbWF0Y2ggZXJyb3JcclxuLyogYWQ5NiAqLyAgICAgICAgX2BfYWQ5NmA7ICBSVFMuaW1wICgpO1xyXG4vKiBhZDk3ICovICAgICAgICBfYF9hZDk3YDsgIEJDUy5yZWwgKFwiX2FkOTZcIik7ICAgICAgICAgICAgLy8gZXhpdCBpZiBkZXN0aW5hdGlvbiBpcyBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyB0eXBlIG1pc3NtYXRjaCBlcnJvclxyXG4vKiBhZDk5ICovICAgICAgICBfYF9hZDk5YDsgIExEWC5pbW0gKDB4MTYpOyAgICAgICAgICAgICAgIC8vIGVycm9yIGNvZGUgJDE2LCB0eXBlIG1pc3NtYXRjaCBlcnJvclxyXG4vKiBhZDliICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiZXJyb3JfYTQzN1wiKTsgICAgICAgLy8gZG8gZXJyb3IgI1ggdGhlbiB3YXJtIHN0YXJ0XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGV2YWx1YXRlIGV4cHJlc3Npb25cclxuLyogYWQ5ZSAqLyAgX2Bmcm1ldmxfYWQ5ZWA7ICBMRFguenBnIChcInR4dHB0ciswXzAwN2FcIik7ICAgIC8vIGdldCBCQVNJQyBleGVjdXRlIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYWRhMCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9hZGE0XCIpOyAgICAgICAgICAgIC8vIHNraXAgbmV4dCBpZiBub3QgemVyb1xyXG4vKiBhZGEyICovICAgICAgICAgICAgICAgICAgIERFQy56cGcgKFwidHh0cHRyKzFfMDA3YlwiKTsgICAgLy8gZWxzZSBkZWNyZW1lbnQgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBhZGE0ICovICAgICAgICBfYF9hZGE0YDsgIERFQy56cGcgKFwidHh0cHRyKzBfMDA3YVwiKTsgICAgLy8gZGVjcmVtZW50IEJBU0lDIGV4ZWN1dGUgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBhZGE2ICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIHNldCBudWxsIHByZWNlZGVuY2UsIGZsYWcgZG9uZVxyXG4vKiBhZGE4ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgyNCk7ICAgICAgICAgICAgICAgIC8vIG1ha2VzIG5leHQgbGluZSBCSVQgJDQ4XHJcbi8qIGFkYTkgKi8gICAgICAgIF9gX2FkYTlgOyAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVzaCBjb21wYXJlIGV2YWx1YXRpb24gYnl0ZSBpZiBicmFuY2ggdG8gaGVyZVxyXG4vKiBhZGFhICovICAgICAgICAgICAgICAgICAgIFRYQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgcHJlY2VkZW5jZSBieXRlXHJcbi8qIGFkYWIgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVzaCBwcmVjZWRlbmNlIGJ5dGVcclxuLyogYWRhYyAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDAxKTsgICAgICAgICAgICAgICAvLyAyIGJ5dGVzXHJcbi8qIGFkYWUgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJnZXRzdGtfYTNmYlwiKTsgICAgICAvLyBjaGVjayByb29tIG9uIHN0YWNrIGZvciBBKjIgYnl0ZXNcclxuLyogYWRiMSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImV2YWxfYWU4M1wiKTsgICAgICAgIC8vIGdldCB2YWx1ZSBmcm9tIGxpbmVcclxuLyogYWRiNCAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBBXHJcbi8qIGFkYjYgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJvcG1hc2tfMDA0ZFwiKTsgICAgICAvLyBjbGVhciBjb21wYXJyaXNvbiBldmFsdWF0aW9uIGZsYWdcclxuLyogYWRiOCAqLyAgICAgICAgX2BfYWRiOGA7ICBKU1IuYWJzIChcImNocmdvdF8wMDc5XCIpOyAgICAgIC8vIHNjYW4gbWVtb3J5XHJcbi8qIGFkYmIgKi8gICAgICAgIF9gX2FkYmJgOyAgU0VDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2V0IGNhcnJ5IGZvciBzdWJ0cmFjdFxyXG4vKiBhZGJjICovICAgICAgICAgICAgICAgICAgIFNCQy5pbW0gKDB4YjEpOyAgICAgICAgICAgICAgIC8vIHN1YnRyYWN0IHRoZSB0b2tlbiBmb3IgXCI+XCJcclxuLyogYWRiZSAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9hZGQ3XCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiA8IFwiPlwiXHJcbi8qIGFkYzAgKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHgwMyk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIFwiPlwiIHRvICszXHJcbi8qIGFkYzIgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfYWRkN1wiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgPj0gM1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdhcyB0b2tlbiBmb3IgXCI+XCIgXCI9XCIgb3IgXCI8XCJcclxuLyogYWRjNCAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW1tICgweDAxKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggdG9rZW4gZm9yID1cclxuLyogYWRjNiAqLyAgICAgICAgICAgICAgICAgICBST0wuYWNjICgpOyAgICAgICAgICAgICAgICAgICAvLyAqMiwgYjAgPSBjYXJyeSAoPTEgaWYgdG9rZW4gd2FzID0gb3IgPClcclxuLyogYWRjNyAqLyAgICAgICAgICAgICAgICAgICBFT1IuaW1tICgweDAxKTsgICAgICAgICAgICAgICAvLyB0b2dnbGUgYjBcclxuLyogYWRjOSAqLyAgICAgICAgICAgICAgICAgICBFT1IuenBnIChcIm9wbWFza18wMDRkXCIpOyAgICAgIC8vIEVPUiB3aXRoIGNvbXBhcnJpc29uIGV2YWx1YXRpb24gZmxhZ1xyXG4vKiBhZGNiICovICAgICAgICAgICAgICAgICAgIENNUC56cGcgKFwib3BtYXNrXzAwNGRcIik7ICAgICAgLy8gY29tcGFyZSB3aXRoIGNvbXBhcnJpc29uIGV2YWx1YXRpb24gZmxhZ1xyXG4vKiBhZGNkICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2FlMzBcIik7ICAgICAgICAgICAgLy8gaWYgPCBzYXZlZCBmbGFnIGRvIHN5bnRheCBlcnJvciB0aGVuIHdhcm0gc3RhcnRcclxuLyogYWRjZiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcIm9wbWFza18wMDRkXCIpOyAgICAgIC8vIHNhdmUgbmV3IGNvbXBhcnJpc29uIGV2YWx1YXRpb24gZmxhZ1xyXG4vKiBhZGQxICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiY2hyZ2V0KzBfMDA3M1wiKTsgICAgLy8gaW5jcmVtZW50IGFuZCBzY2FuIG1lbW9yeVxyXG4vKiBhZGQ0ICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2FkYmJcIik7ICAgICAgICAgICAgLy8gZ28gZG8gbmV4dCBjaGFyYWN0ZXJcclxuLyogYWRkNyAqLyAgICAgICAgX2BfYWRkN2A7ICBMRFguenBnIChcIm9wbWFza18wMDRkXCIpOyAgICAgIC8vIGdldCBjb21wYXJyaXNvbiBldmFsdWF0aW9uIGZsYWdcclxuLyogYWRkOSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9hZTA3XCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBjb21wYXJlIGZ1bmN0aW9uXHJcbi8qIGFkZGIgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfYWU1OFwiKTsgICAgICAgICAgICAvLyBnbyBkbyBmdW5jdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIHdhcyA8IFRLX0dUIHNvIGlzIG9wZXJhdG9yIG9yIGxvd2VyXHJcbi8qIGFkZGQgKi8gICAgICAgICAgICAgICAgICAgQURDLmltbSAoMHgwNyk7ICAgICAgICAgICAgICAgLy8gYWRkICMgb2Ygb3BlcmF0b3JzICgrLCAtLCAqLCAvLCBeLCBBTkQgb3IgT1IpXHJcbi8qIGFkZGYgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYWU1OFwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgPCArIG9wZXJhdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2Fycnkgd2FzIHNldCBzbyB0b2tlbiB3YXMgKywgLSwgKiwgLywgXiwgQU5EIG9yIE9SXHJcbi8qIGFkZTEgKi8gICAgICAgICAgICAgICAgICAgQURDLnpwZyAoXCJ2YWx0eXBfMDAwZFwiKTsgICAgICAvLyBhZGQgZGF0YSB0eXBlIGZsYWcsICRGRiA9IHN0cmluZywgJDAwID0gbnVtZXJpY1xyXG4vKiBhZGUzICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2FkZThcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vdCBzdHJpbmcgb3Igbm90ICsgdG9rZW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIG9ubHkgYmUgJDAwIGlmIHR5cGUgaXMgc3RyaW5nIGFuZCB0b2tlbiB3YXMgK1xyXG4vKiBhZGU1ICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiY2F0X2I2M2RcIik7ICAgICAgICAgLy8gYWRkIHN0cmluZ3MsIHN0cmluZyAxIGlzIGluIHRoZSBkZXNjcmlwdG9yLCBzdHJpbmcgMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIGluIGxpbmUsIGFuZCByZXR1cm5cclxuLyogYWRlOCAqLyAgICAgICAgX2BfYWRlOGA7ICBBREMuaW1tICgweGZmKTsgICAgICAgICAgICAgICAvLyAtMSAoY29ycmVjdHMgZm9yIGNhcnJ5IGFkZClcclxuLyogYWRlYSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImluZGV4KzBfMDAyMlwiKTsgICAgIC8vIHNhdmUgaXRcclxuLyogYWRlYyAqLyAgICAgICAgICAgICAgICAgICBBU0wuYWNjICgpOyAgICAgICAgICAgICAgICAgICAvLyAqMlxyXG4vKiBhZGVkICovICAgICAgICAgICAgICAgICAgIEFEQy56cGcgKFwiaW5kZXgrMF8wMDIyXCIpOyAgICAgLy8gKjNcclxuLyogYWRlZiAqLyAgICAgICAgICAgICAgICAgICBUQVkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IHRvIGluZGV4XHJcbi8qIGFkZjAgKi8gICAgICAgIF9gX2FkZjBgOyAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVsbCBwcmV2aW91cyBwcmVjZWRlbmNlXHJcbi8qIGFkZjEgKi8gICAgICAgICAgICAgICAgICAgQ01QLmFieSAoXCJvcHRhYl9hMDgwXCIpOyAgICAgICAvLyBjb21wYXJlIHdpdGggcHJlY2VkZW5jZSBieXRlXHJcbi8qIGFkZjQgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfYWU1ZFwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgQSA+PVxyXG4vKiBhZGY2ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2FkOGRcIik7ICAgICAgICAgICAgLy8gY2hlY2sgaWYgc291cmNlIGlzIG51bWVyaWMsIGVsc2UgZG8gdHlwZSBtaXNtYXRjaFxyXG4vKiBhZGY5ICovICAgICAgICBfYF9hZGY5YDsgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgcHJlY2VkZW5jZVxyXG4vKiBhZGZhICovICAgICAgICBfYF9hZGZhYDsgIEpTUi5hYnMgKFwiX2FlMjBcIik7ICAgICAgICAgICAgLy8gZ2V0IHZlY3RvciwgZXhlY3V0ZSBmdW5jdGlvbiB0aGVuIGNvbnRpbnVlIGV2YWx1YXRpb25cclxuLyogYWRmZCAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIHByZWNlZGVuY2VcclxuLyogYWRmZSAqLyAgICAgICAgICAgICAgICAgICBMRFkuenBnIChcIm9wcHRyKzBfMDA0YlwiKTsgICAgIC8vIGdldCBwcmVjZWRlbmNlIHN0YWNrZWQgZmxhZ1xyXG4vKiBhZTAwICovICAgICAgICAgICAgICAgICAgIEJQTC5yZWwgKFwiX2FlMTlcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIHN0YWNrZWQgdmFsdWVzXHJcbi8qIGFlMDIgKi8gICAgICAgICAgICAgICAgICAgVEFYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBwcmVjZWRlbmNlLCBzZXQgZmxhZ3NcclxuLyogYWUwMyAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9hZTViXCIpOyAgICAgICAgICAgIC8vIGV4aXQgaWYgZG9uZVxyXG4vKiBhZTA1ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2FlNjZcIik7ICAgICAgICAgICAgLy8gZWxzZSBwb3AgRkFDMiBhbmQgcmV0dXJuLCBicmFuY2ggYWx3YXlzXHJcbi8qIGFlMDcgKi8gICAgICAgIF9gX2FlMDdgOyAgTFNSLnpwZyAoXCJ2YWx0eXBfMDAwZFwiKTsgICAgICAvLyBjbGVhciBkYXRhIHR5cGUgZmxhZywgJEZGID0gc3RyaW5nLCAkMDAgPSBudW1lcmljXHJcbi8qIGFlMDkgKi8gICAgICAgICAgICAgICAgICAgVFhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBjb21wYXJlIGZ1bmN0aW9uIGZsYWdcclxuLyogYWUwYSAqLyAgICAgICAgICAgICAgICAgICBST0wuYWNjICgpOyAgICAgICAgICAgICAgICAgICAvLyA8PDEsIHNoaWZ0IGRhdGEgdHlwZSBmbGFnIGludG8gYjAsIDEgPSBzdHJpbmcsIDAgPSBudW1cclxuLyogYWUwYiAqLyAgICAgICAgICAgICAgICAgICBMRFguenBnIChcInR4dHB0ciswXzAwN2FcIik7ICAgIC8vIGdldCBCQVNJQyBleGVjdXRlIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYWUwZCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9hZTExXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBubyB1bmRlcmZsb3dcclxuLyogYWUwZiAqLyAgICAgICAgICAgICAgICAgICBERUMuenBnIChcInR4dHB0cisxXzAwN2JcIik7ICAgIC8vIGVsc2UgZGVjcmVtZW50IEJBU0lDIGV4ZWN1dGUgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYWUxMSAqLyAgICAgICAgX2BfYWUxMWA7ICBERUMuenBnIChcInR4dHB0ciswXzAwN2FcIik7ICAgIC8vIGRlY3JlbWVudCBCQVNJQyBleGVjdXRlIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYWUxMyAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDFiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgb2Zmc2V0IHRvID0gb3BlcmF0b3IgcHJlY2VkZW5jZSBlbnRyeVxyXG4vKiBhZTE1ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwib3BtYXNrXzAwNGRcIik7ICAgICAgLy8gc2F2ZSBuZXcgY29tcGFycmlzb24gZXZhbHVhdGlvbiBmbGFnXHJcbi8qIGFlMTcgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYWRmMFwiKTsgICAgICAgICAgICAvLyBicmFuY2ggYWx3YXlzXHJcbi8qIGFlMTkgKi8gICAgICAgIF9gX2FlMTlgOyAgQ01QLmFieSAoXCJvcHRhYl9hMDgwXCIpOyAgICAgICAvLyBjb21wYXJlIHdpdGggc3RhY2tlZCBmdW5jdGlvbiBwcmVjZWRlbmNlXHJcbi8qIGFlMWMgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfYWU2NlwiKTsgICAgICAgICAgICAvLyBpZiBBID49LCBwb3AgRkFDMiBhbmQgcmV0dXJuXHJcbi8qIGFlMWUgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYWRmOVwiKTsgICAgICAgICAgICAvLyBlbHNlIGdvIHN0YWNrIHRoaXMgb25lIGFuZCBjb250aW51ZSwgYnJhbmNoIGFsd2F5c1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBnZXQgdmVjdG9yLCBleGVjdXRlIGZ1bmN0aW9uIHRoZW4gY29udGludWUgZXZhbHVhdGlvblxyXG4vKiBhZTIwICovICAgICAgICBfYF9hZTIwYDsgIExEQS5hYnkgKDB4YTA4Mik7ICAgICAgICAgICAgIC8vIGdldCBmdW5jdGlvbiB2ZWN0b3IgaGlnaCBieXRlXHJcbi8qIGFlMjMgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gb250byBzdGFja1xyXG4vKiBhZTI0ICovICAgICAgICAgICAgICAgICAgIExEQS5hYnkgKDB4YTA4MSk7ICAgICAgICAgICAgIC8vIGdldCBmdW5jdGlvbiB2ZWN0b3IgbG93IGJ5dGVcclxuLyogYWUyNyAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBvbnRvIHN0YWNrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm93IHB1c2ggc2lnbiwgcm91bmQgRkFDMSBhbmQgcHV0IG9uIHN0YWNrXHJcbi8qIGFlMjggKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfYWUzM1wiKTsgICAgICAgICAgICAvLyBmdW5jdGlvbiB3aWxsIHJldHVybiBoZXJlLCB0aGVuIHRoZSBuZXh0IFJUUyB3aWxsIGNhbGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZnVuY3Rpb25cclxuLyogYWUyYiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcIm9wbWFza18wMDRkXCIpOyAgICAgIC8vIGdldCBjb21wYXJyaXNvbiBldmFsdWF0aW9uIGZsYWdcclxuLyogYWUyZCAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9hZGE5XCIpOyAgICAgICAgICAgIC8vIGNvbnRpbnVlIGV2YWx1YXRpbmcgZXhwcmVzc2lvblxyXG4vKiBhZTMwICovICAgICAgICBfYF9hZTMwYDsgIEpNUC5hYnMgKFwic3luZXJyX2FmMDhcIik7ICAgICAgLy8gZG8gc3ludGF4IGVycm9yIHRoZW4gd2FybSBzdGFydFxyXG4vKiBhZTMzICovICAgICAgICBfYF9hZTMzYDsgIExEQS56cGcgKFwiZmFjc2duXzAwNjZcIik7ICAgICAgLy8gZ2V0IEZBQzEgc2lnbiAoYjcpXHJcbi8qIGFlMzUgKi8gICAgICAgICAgICAgICAgICAgTERYLmFieSAoXCJvcHRhYl9hMDgwXCIpOyAgICAgICAvLyBnZXQgcHJlY2VkZW5jZSBieXRlXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHB1c2ggc2lnbiwgcm91bmQgRkFDMSBhbmQgcHV0IG9uIHN0YWNrXHJcbi8qIGFlMzggKi8gICAgICAgIF9gX2FlMzhgOyAgVEFZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBzaWduXHJcbi8qIGFlMzkgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHJldHVybiBhZGRyZXNzIGxvdyBieXRlXHJcbi8qIGFlM2EgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJpbmRleCswXzAwMjJcIik7ICAgICAvLyBzYXZlIGl0XHJcbi8qIGFlM2MgKi8gICAgICAgICAgICAgICAgICAgSU5DLnpwZyAoXCJpbmRleCswXzAwMjJcIik7ICAgICAvLyBpbmNyZW1lbnQgaXQgYXMgcmV0dXJuLTEgaXMgcHVzaGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90ZSwgbm8gY2hlY2sgaXMgbWFkZSBvbiB0aGUgaGlnaCBieXRlIHNvIGlmIHRoZSBjYWxsaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcm91dGluZSBldmVyIGFzc2VtYmxlcyB0byBhIHBhZ2UgZWRnZSB0aGVuIHRoaXMgYWxsIGdvZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBob3JyaWJseSB3cm9uZyFcclxuLyogYWUzZSAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBnZXQgcmV0dXJuIGFkZHJlc3MgaGlnaCBieXRlXHJcbi8qIGFlM2YgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJpbmRleCsxXzAwMjNcIik7ICAgICAvLyBzYXZlIGl0XHJcbi8qIGFlNDEgKi8gICAgICAgICAgICAgICAgICAgVFlBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBzaWduXHJcbi8qIGFlNDIgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVzaCBzaWduXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHJvdW5kIEZBQzEgYW5kIHB1dCBvbiBzdGFja1xyXG4vKiBhZTQzICovICAgICAgICBfYF9hZTQzYDsgIEpTUi5hYnMgKFwicm91bmRfYmMxYlwiKTsgICAgICAgLy8gcm91bmQgRkFDMVxyXG4vKiBhZTQ2ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZmFjaG8rM18wMDY1XCIpOyAgICAgLy8gZ2V0IEZBQzEgbWFudGlzc2EgNFxyXG4vKiBhZTQ4ICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgaXRcclxuLyogYWU0OSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZhY2hvKzJfMDA2NFwiKTsgICAgIC8vIGdldCBGQUMxIG1hbnRpc3NhIDNcclxuLyogYWU0YiAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzYXZlIGl0XHJcbi8qIGFlNGMgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJmYWNobysxXzAwNjNcIik7ICAgICAvLyBnZXQgRkFDMSBtYW50aXNzYSAyXHJcbi8qIGFlNGUgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBpdFxyXG4vKiBhZTRmICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZmFjaG8rMF8wMDYyXCIpOyAgICAgLy8gZ2V0IEZBQzEgbWFudGlzc2EgMVxyXG4vKiBhZTUxICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgaXRcclxuLyogYWU1MiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZhY2V4cF8wMDYxXCIpOyAgICAgIC8vIGdldCBGQUMxIGV4cG9uZW50XHJcbi8qIGFlNTQgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBpdFxyXG4vKiBhZTU1ICovICAgICAgICAgICAgICAgICAgIEpNUC5pbmQgKFwiaW5kZXgrMF8wMDIyXCIpOyAgICAgLy8gcmV0dXJuLCBzb3J0IG9mXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGRvIGZ1bmN0aW9uc1xyXG4vKiBhZTU4ICovICAgICAgICBfYF9hZTU4YDsgIExEWS5pbW0gKDB4ZmYpOyAgICAgICAgICAgICAgIC8vIGZsYWcgZnVuY3Rpb25cclxuLyogYWU1YSAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdWxsIHByZWNlZGVuY2UgYnl0ZVxyXG4vKiBhZTViICovICAgICAgICBfYF9hZTViYDsgIEJFUS5yZWwgKFwiX2FlODBcIik7ICAgICAgICAgICAgLy8gZXhpdCBpZiBkb25lXHJcbi8qIGFlNWQgKi8gICAgICAgIF9gX2FlNWRgOyAgQ01QLmltbSAoMHg2NCk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSBwcmV2aW91cyBwcmVjZWRlbmNlIHdpdGggJDY0XHJcbi8qIGFlNWYgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYWU2NFwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgd2FzICQ2NCAoPCBmdW5jdGlvbilcclxuLyogYWU2MSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9hZDhkXCIpOyAgICAgICAgICAgIC8vIGNoZWNrIGlmIHNvdXJjZSBpcyBudW1lcmljLCBlbHNlIGRvIHR5cGUgbWlzbWF0Y2hcclxuLyogYWU2NCAqLyAgICAgICAgX2BfYWU2NGA7ICBTVFkuenBnIChcIm9wcHRyKzBfMDA0YlwiKTsgICAgIC8vIHNhdmUgcHJlY2VkZW5jZSBzdGFja2VkIGZsYWdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwb3AgRkFDMiBhbmQgcmV0dXJuXHJcbi8qIGFlNjYgKi8gICAgICAgIF9gX2FlNjZgOyAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcG9wIGJ5dGVcclxuLyogYWU2NyAqLyAgICAgICAgICAgICAgICAgICBMU1IuYWNjICgpOyAgICAgICAgICAgICAgICAgICAvLyBzaGlmdCBvdXQgY29tcGFyaXNvbiBldmFsdWF0aW9uIGxvd2VzdCBiaXRcclxuLyogYWU2OCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInRhbnNnbl8wMDEyXCIpOyAgICAgIC8vIHNhdmUgdGhlIGNvbXBhcmlzb24gZXZhbHVhdGlvbiBmbGFnXHJcbi8qIGFlNmEgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcG9wIGV4cG9uZW50XHJcbi8qIGFlNmIgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJhcmdleHBfMDA2OVwiKTsgICAgICAvLyBzYXZlIEZBQzIgZXhwb25lbnRcclxuLyogYWU2ZCAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwb3AgbWFudGlzc2EgMVxyXG4vKiBhZTZlICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiYXJnaG8rMF8wMDZhXCIpOyAgICAgLy8gc2F2ZSBGQUMyIG1hbnRpc3NhIDFcclxuLyogYWU3MCAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwb3AgbWFudGlzc2EgMlxyXG4vKiBhZTcxICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiYXJnaG8rMV8wMDZiXCIpOyAgICAgLy8gc2F2ZSBGQUMyIG1hbnRpc3NhIDJcclxuLyogYWU3MyAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwb3AgbWFudGlzc2EgM1xyXG4vKiBhZTc0ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiYXJnaG8rMl8wMDZjXCIpOyAgICAgLy8gc2F2ZSBGQUMyIG1hbnRpc3NhIDNcclxuLyogYWU3NiAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwb3AgbWFudGlzc2EgNFxyXG4vKiBhZTc3ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiYXJnaG8rM18wMDZkXCIpOyAgICAgLy8gc2F2ZSBGQUMyIG1hbnRpc3NhIDRcclxuLyogYWU3OSAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwb3Agc2lnblxyXG4vKiBhZTdhICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiYXJnc2duXzAwNmVcIik7ICAgICAgLy8gc2F2ZSBGQUMyIHNpZ24gKGI3KVxyXG4vKiBhZTdjICovICAgICAgICAgICAgICAgICAgIEVPUi56cGcgKFwiZmFjc2duXzAwNjZcIik7ICAgICAgLy8gRU9SIEZBQzEgc2lnbiAoYjcpXHJcbi8qIGFlN2UgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJhcmlzZ25fMDA2ZlwiKTsgICAgICAvLyBzYXZlIHNpZ24gY29tcGFyZSAoRkFDMSBFT1IgRkFDMilcclxuLyogYWU4MCAqLyAgICAgICAgX2BfYWU4MGA7ICBMREEuenBnIChcImZhY2V4cF8wMDYxXCIpOyAgICAgIC8vIGdldCBGQUMxIGV4cG9uZW50XHJcbi8qIGFlODIgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gZ2V0IHZhbHVlIGZyb20gbGluZVxyXG4vKiBhZTgzICovICAgIF9gZXZhbF9hZTgzYDsgIEpNUC5pbmQgKFwiaWV2YWwrMF8wMzBhXCIpOyAgICAgLy8gZ2V0IGFyaXRobWV0aWMgZWxlbWVudFxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBnZXQgYXJpdGhtZXRpYyBlbGVtZW50LCB0aGUgZ2V0IGFyaXRobWV0aWMgZWxlbWVudCB2ZWN0b3IgaXMgaW5pdGlhbGlzZWQgdG8gcG9pbnQgaGVyZVxyXG4vKiBhZTg2ICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIGJ5dGVcclxuLyogYWU4OCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInZhbHR5cF8wMDBkXCIpOyAgICAgIC8vIGNsZWFyIGRhdGEgdHlwZSBmbGFnLCAkRkYgPSBzdHJpbmcsICQwMCA9IG51bWVyaWNcclxuLyogYWU4YSAqLyAgICAgICAgX2BfYWU4YWA7ICBKU1IuYWJzIChcImNocmdldCswXzAwNzNcIik7ICAgIC8vIGluY3JlbWVudCBhbmQgc2NhbiBtZW1vcnlcclxuLyogYWU4ZCAqLyAgICAgICAgICAgICAgICAgICBCQ1MucmVsIChcIl9hZTkyXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBub3QgbnVtZXJpYyBjaGFyYWN0ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIG51bWVyaWMgc3RyaW5nIGZvdW5kIChlLmcuIDEyMylcclxuLyogYWU4ZiAqLyAgICAgICAgX2BfYWU4ZmA7ICBKTVAuYWJzIChcImZpbl9iY2YzXCIpOyAgICAgICAgIC8vIGdldCBGQUMxIGZyb20gc3RyaW5nIGFuZCByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdmFsdWUgZnJvbSBsaW5lIC4uIGNvbnRpbnVlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdhc24ndCBhIG51bWJlciBzbyAuLi5cclxuLyogYWU5MiAqLyAgICAgICAgX2BfYWU5MmA7ICBKU1IuYWJzIChcImlzbGV0Y19iMTEzXCIpOyAgICAgIC8vIGNoZWNrIGJ5dGUsIHJldHVybiBDYiA9IDAgaWY8XCJBXCIgb3IgPlwiWlwiXHJcbi8qIGFlOTUgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYWU5YVwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbm90IHZhcmlhYmxlIG5hbWVcclxuLyogYWU5NyAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcImlzdmFyX2FmMjhcIik7ICAgICAgIC8vIHZhcmlhYmxlIG5hbWUgc2V0LXVwIGFuZCByZXR1cm5cclxuLyogYWU5YSAqLyAgICAgICAgX2BfYWU5YWA7ICBDTVAuaW1tICgweGZmKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggdG9rZW4gZm9yIFBJXHJcbi8qIGFlOWMgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJxZG90X2FlYWRcIik7ICAgICAgICAvLyBicmFuY2ggaWYgbm90IFBJXHJcbi8qIGFlOWUgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHhhOCk7ICAgICAgICAgICAgICAgLy8gZ2V0IFBJIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYWVhMCAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweGFlKTsgICAgICAgICAgICAgICAvLyBnZXQgUEkgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYWVhMiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIm1vdmZtX2JiYTJcIik7ICAgICAgIC8vIHVucGFjayBtZW1vcnkgKEFZKSBpbnRvIEZBQzFcclxuLyogYWVhNSAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcImNocmdldCswXzAwNzNcIik7ICAgIC8vIGluY3JlbWVudCBhbmQgc2NhbiBtZW1vcnkgYW5kIHJldHVyblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBQSSBhcyBmbG9hdGluZyBudW1iZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAzLjE0MTU5MjY1M1xyXG4vKiBhZWE4ICovICAgX2BwaXZhbF9hZWE4YDsgIF8uYnl0ZXMoMHg4MiwgMHg0OSwgMHgwZiwgMHhkYSwgMHhhMSk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGdldCB2YWx1ZSBmcm9tIGxpbmUgLi4gY29udGludWVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Fzbid0IHZhcmlhYmxlIG5hbWUgc28gLi4uXHJcbi8qIGFlYWQgKi8gICAgX2BxZG90X2FlYWRgOyAgQ01QLmltbSAoMHgyZSk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIFwiLlwiXHJcbi8qIGFlYWYgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYWU4ZlwiKTsgICAgICAgICAgICAvLyBpZiBzbyBnZXQgRkFDMSBmcm9tIHN0cmluZyBhbmQgcmV0dXJuLCBlLmcuIHdhcyAuMTIzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Fzbid0IC4xMjMgc28gLi4uXHJcbi8qIGFlYjEgKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHhhYik7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIHRva2VuIGZvciAtXHJcbi8qIGFlYjMgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJkb21pbl9hZjBkXCIpOyAgICAgICAvLyBicmFuY2ggaWYgLSB0b2tlbiwgZG8gc2V0LXVwIGZvciBmdW5jdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3YXNuJ3QgLTEyMyBzbyAuLi5cclxuLyogYWViNSAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW1tICgweGFhKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggdG9rZW4gZm9yICtcclxuLyogYWViNyAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9hZThhXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiArIHRva2VuLCArMSA9IDEgc28gaWdub3JlIGxlYWRpbmcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IHdhc24ndCBhbnkgc29ydCBvZiBudW1iZXIgc28gLi4uXHJcbi8qIGFlYjkgKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHgyMik7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIFwiXHJcbi8qIGFlYmIgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYWVjY1wiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbm90IG9wZW4gcXVvdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3YXMgb3BlbiBxdW90ZSBzbyBnZXQgdGhlIGVuY2xvc2VkIHN0cmluZ1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBwcmludCBcIi4uLlwiIHN0cmluZyB0byBzdHJpbmcgdXRpbGl0eSBhcmVhXHJcbi8qIGFlYmQgKi8gICAgICAgIF9gX2FlYmRgOyAgTERBLnpwZyAoXCJ0eHRwdHIrMF8wMDdhXCIpOyAgICAvLyBnZXQgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGFlYmYgKi8gICAgICAgICAgICAgICAgICAgTERZLnpwZyAoXCJ0eHRwdHIrMV8wMDdiXCIpOyAgICAvLyBnZXQgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBhZWMxICovICAgICAgICAgICAgICAgICAgIEFEQy5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGFkZCBjYXJyeSB0byBsb3cgYnl0ZVxyXG4vKiBhZWMzICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2FlYzZcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vIG92ZXJmbG93XHJcbi8qIGFlYzUgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGhpZ2ggYnl0ZVxyXG4vKiBhZWM2ICovICAgICAgICBfYF9hZWM2YDsgIEpTUi5hYnMgKFwic3RybGl0X2I0ODdcIik7ICAgICAgLy8gcHJpbnQgXCIgdGVybWluYXRlZCBzdHJpbmcgdG8gdXRpbGl0eSBwb2ludGVyXHJcbi8qIGFlYzkgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfYjdlMlwiKTsgICAgICAgICAgICAvLyByZXN0b3JlIEJBU0lDIGV4ZWN1dGUgcG9pbnRlciBmcm9tIHRlbXAgYW5kIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldCB2YWx1ZSBmcm9tIGxpbmUgLi4gY29udGludWVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Fzbid0IGEgc3RyaW5nIHNvIC4uLlxyXG4vKiBhZWNjICovICAgICAgICBfYF9hZWNjYDsgIENNUC5pbW0gKDB4YTgpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCB0b2tlbiBmb3IgTk9UXHJcbi8qIGFlY2UgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYWVlM1wiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbm90IHRva2VuIGZvciBOT1RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3YXMgTk9UIHRva2VuXHJcbi8qIGFlZDAgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgxOCk7ICAgICAgICAgICAgICAgLy8gb2Zmc2V0IHRvIE5PVCBmdW5jdGlvblxyXG4vKiBhZWQyICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2FmMGZcIik7ICAgICAgICAgICAgLy8gZG8gc2V0LXVwIGZvciBmdW5jdGlvbiB0aGVuIGV4ZWN1dGUsIGJyYW5jaCBhbHdheXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyA9IGNvbXBhcmVcclxuLyogYWVkNCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImF5aW50X2IxYmZcIik7ICAgICAgIC8vIGV2YWx1YXRlIGludGVnZXIgZXhwcmVzc2lvbiwgbm8gc2lnbiBjaGVja1xyXG4vKiBhZWQ3ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZmFjaG8rM18wMDY1XCIpOyAgICAgLy8gZ2V0IEZBQzEgbWFudGlzc2EgNFxyXG4vKiBhZWQ5ICovICAgICAgICAgICAgICAgICAgIEVPUi5pbW0gKDB4ZmYpOyAgICAgICAgICAgICAgIC8vIGludmVydCBpdFxyXG4vKiBhZWRiICovICAgICAgICAgICAgICAgICAgIFRBWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgaXRcclxuLyogYWVkYyAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZhY2hvKzJfMDA2NFwiKTsgICAgIC8vIGdldCBGQUMxIG1hbnRpc3NhIDNcclxuLyogYWVkZSAqLyAgICAgICAgICAgICAgICAgICBFT1IuaW1tICgweGZmKTsgICAgICAgICAgICAgICAvLyBpbnZlcnQgaXRcclxuLyogYWVlMCAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcImdpdmF5Zl9iMzkxXCIpOyAgICAgIC8vIGNvbnZlcnQgZml4ZWQgaW50ZWdlciBBWSB0byBmbG9hdCBGQUMxIGFuZCByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdmFsdWUgZnJvbSBsaW5lIC4uIGNvbnRpbnVlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdhc24ndCBhIHN0cmluZyBvciBOT1Qgc28gLi4uXHJcbi8qIGFlZTMgKi8gICAgICAgIF9gX2FlZTNgOyAgQ01QLmltbSAoMHhhNSk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIHRva2VuIGZvciBGTlxyXG4vKiBhZWU1ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2FlZWFcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vdCB0b2tlbiBmb3IgRk5cclxuLyogYWVlNyAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcImZuZG9lcl9iM2Y0XCIpOyAgICAgIC8vIGVsc2UgZ28gZXZhbHVhdGUgRk54XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHZhbHVlIGZyb20gbGluZSAuLiBjb250aW51ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3YXNuJ3QgYSBzdHJpbmcsIE5PVCBvciBGTiBzbyAuLi5cclxuLyogYWVlYSAqLyAgICAgICAgX2BfYWVlYWA7ICBDTVAuaW1tICgweGI0KTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggdG9rZW4gZm9yIFNHTlxyXG4vKiBhZWVjICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwicGFyY2hrX2FlZjFcIik7ICAgICAgLy8gaWYgbGVzcyB0aGFuIFNHTiB0b2tlbiBldmFsdWF0ZSBleHByZXNzaW9uIGluIHBhcmVudGhlc2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSB3YXMgYSBmdW5jdGlvbiB0b2tlblxyXG4vKiBhZWVlICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiaXNmdW5fYWZhN1wiKTsgICAgICAgLy8gZ28gc2V0IHVwIGZ1bmN0aW9uIHJlZmVyZW5jZXMsIGJyYW5jaCBhbHdheXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdmFsdWUgZnJvbSBsaW5lIC4uIGNvbnRpbnVlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGhlcmUgaXQgY2FuIG9ubHkgYmUgc29tZXRoaW5nIGluIGJyYWNrZXRzIHNvIC4uLi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBldmFsdWF0ZSBleHByZXNzaW9uIHdpdGhpbiBwYXJlbnRoZXNlc1xyXG4vKiBhZWYxICovICBfYHBhcmNoa19hZWYxYDsgIEpTUi5hYnMgKFwiY2hrb3BuX2FlZmFcIik7ICAgICAgLy8gc2NhbiBmb3IgXCIoXCIsIGVsc2UgZG8gc3ludGF4IGVycm9yIHRoZW4gd2FybSBzdGFydFxyXG4vKiBhZWY0ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiZnJtZXZsX2FkOWVcIik7ICAgICAgLy8gZXZhbHVhdGUgZXhwcmVzc2lvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCB0aGUgJ3NjYW4gZm9yJyByb3V0aW5lcyByZXR1cm4gdGhlIGNoYXJhY3RlciBhZnRlciB0aGUgc291Z2h0IGNoYXJhY3RlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNjYW4gZm9yIFwiKVwiLCBlbHNlIGRvIHN5bnRheCBlcnJvciB0aGVuIHdhcm0gc3RhcnRcclxuLyogYWVmNyAqLyAgX2BjaGtjbHNfYWVmN2A7ICBMREEuaW1tICgweDI5KTsgICAgICAgICAgICAgICAvLyBsb2FkIEEgd2l0aCBcIilcIlxyXG4vKiBhZWY5ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgyYyk7ICAgICAgICAgICAgICAgIC8vIG1ha2VzIG5leHQgbGluZSBCSVQgJDI4QTlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzY2FuIGZvciBcIihcIiwgZWxzZSBkbyBzeW50YXggZXJyb3IgdGhlbiB3YXJtIHN0YXJ0XHJcbi8qIGFlZmEgKi8gIF9gY2hrb3BuX2FlZmFgOyAgTERBLmltbSAoMHgyOCk7ICAgICAgICAgICAgICAgLy8gbG9hZCBBIHdpdGggXCIoXCJcclxuLyogYWVmYyAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MmMpOyAgICAgICAgICAgICAgICAvLyBtYWtlcyBuZXh0IGxpbmUgQklUICQyQ0E5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2NhbiBmb3IgXCIsXCIsIGVsc2UgZG8gc3ludGF4IGVycm9yIHRoZW4gd2FybSBzdGFydFxyXG4vKiBhZWZkICovICAgICAgICBfYF9hZWZkYDsgIExEQS5pbW0gKDB4MmMpOyAgICAgICAgICAgICAgIC8vIGxvYWQgQSB3aXRoIFwiLFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2NhbiBmb3IgQ0hSJChBKSwgZWxzZSBkbyBzeW50YXggZXJyb3IgdGhlbiB3YXJtIHN0YXJ0XHJcbi8qIGFlZmYgKi8gIF9gY2hrY29tX2FlZmZgOyAgTERZLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgaW5kZXhcclxuLyogYWYwMSAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW55IChcInR4dHB0ciswXzAwN2FcIik7ICAgIC8vIGNvbXBhcmUgd2l0aCBCQVNJQyBieXRlXHJcbi8qIGFmMDMgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJzeW5lcnJfYWYwOFwiKTsgICAgICAvLyBpZiBub3QgZXhwZWN0ZWQgYnl0ZSBkbyBzeW50YXggZXJyb3IgdGhlbiB3YXJtIHN0YXJ0XHJcbi8qIGFmMDUgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJjaHJnZXQrMF8wMDczXCIpOyAgICAvLyBlbHNlIGluY3JlbWVudCBhbmQgc2NhbiBtZW1vcnkgYW5kIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN5bnRheCBlcnJvciB0aGVuIHdhcm0gc3RhcnRcclxuLyogYWYwOCAqLyAgX2BzeW5lcnJfYWYwOGA7ICBMRFguaW1tICgweDBiKTsgICAgICAgICAgICAgICAvLyBlcnJvciBjb2RlICQwQiwgc3ludGF4IGVycm9yXHJcbi8qIGFmMGEgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJlcnJvcl9hNDM3XCIpOyAgICAgICAvLyBkbyBlcnJvciAjWCB0aGVuIHdhcm0gc3RhcnRcclxuLyogYWYwZCAqLyAgIF9gZG9taW5fYWYwZGA7ICBMRFkuaW1tICgweDE1KTsgICAgICAgICAgICAgICAvLyBzZXQgb2Zmc2V0IGZyb20gYmFzZSB0byA+IG9wZXJhdG9yXHJcbi8qIGFmMGYgKi8gICAgICAgIF9gX2FmMGZgOyAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZHVtcCByZXR1cm4gYWRkcmVzcyBsb3cgYnl0ZVxyXG4vKiBhZjEwICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGR1bXAgcmV0dXJuIGFkZHJlc3MgaGlnaCBieXRlXHJcbi8qIGFmMTEgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfYWRmYVwiKTsgICAgICAgICAgICAvLyBleGVjdXRlIGZ1bmN0aW9uIHRoZW4gY29udGludWUgZXZhbHVhdGlvblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBjaGVjayBhZGRyZXNzIHJhbmdlLCByZXR1cm4gQ2IgPSAxIGlmIGFkZHJlc3MgaW4gQkFTSUMgUk9NXHJcbi8qIGFmMTQgKi8gIF9gcnN2dmFyX2FmMTRgOyAgU0VDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2V0IGNhcnJ5IGZvciBzdWJ0cmFjdFxyXG4vKiBhZjE1ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZmFjaG8rMl8wMDY0XCIpOyAgICAgLy8gZ2V0IHZhcmlhYmxlIGFkZHJlc3MgbG93IGJ5dGVcclxuLyogYWYxNyAqLyAgICAgICAgICAgICAgICAgICBTQkMuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBzdWJ0cmFjdCAkQTAwMCBsb3cgYnl0ZVxyXG4vKiBhZjE5ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZmFjaG8rM18wMDY1XCIpOyAgICAgLy8gZ2V0IHZhcmlhYmxlIGFkZHJlc3MgaGlnaCBieXRlXHJcbi8qIGFmMWIgKi8gICAgICAgICAgICAgICAgICAgU0JDLmltbSAoMHhhMCk7ICAgICAgICAgICAgICAgLy8gc3VidHJhY3QgJEEwMDAgaGlnaCBieXRlXHJcbi8qIGFmMWQgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYWYyN1wiKTsgICAgICAgICAgICAvLyBleGl0IGlmIGFkZHJlc3MgPCAkQTAwMFxyXG4vKiBhZjFmICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4YTIpOyAgICAgICAgICAgICAgIC8vIGdldCBlbmQgb2YgQkFTSUMgbWFya2VyIGxvdyBieXRlXHJcbi8qIGFmMjEgKi8gICAgICAgICAgICAgICAgICAgU0JDLnpwZyAoXCJmYWNobysyXzAwNjRcIik7ICAgICAvLyBzdWJ0cmFjdCB2YXJpYWJsZSBhZGRyZXNzIGxvdyBieXRlXHJcbi8qIGFmMjMgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHhlMyk7ICAgICAgICAgICAgICAgLy8gZ2V0IGVuZCBvZiBCQVNJQyBtYXJrZXIgaGlnaCBieXRlXHJcbi8qIGFmMjUgKi8gICAgICAgICAgICAgICAgICAgU0JDLnpwZyAoXCJmYWNobyszXzAwNjVcIik7ICAgICAvLyBzdWJ0cmFjdCB2YXJpYWJsZSBhZGRyZXNzIGhpZ2ggYnl0ZVxyXG4vKiBhZjI3ICovICAgICAgICBfYF9hZjI3YDsgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHZhcmlhYmxlIG5hbWUgc2V0LXVwXHJcbi8qIGFmMjggKi8gICBfYGlzdmFyX2FmMjhgOyAgSlNSLmFicyAoXCJwdHJnZXRfYjA4YlwiKTsgICAgICAvLyBnZXQgdmFyaWFibGUgYWRkcmVzc1xyXG4vKiBhZjJiICovICBfYGlzdnJldF9hZjJiYDsgIFNUQS56cGcgKFwiZmFjaG8rMl8wMDY0XCIpOyAgICAgLy8gc2F2ZSB2YXJpYWJsZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGFmMmQgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJmYWNobyszXzAwNjVcIik7ICAgICAvLyBzYXZlIHZhcmlhYmxlIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGFmMmYgKi8gICAgICAgICAgICAgICAgICAgTERYLnpwZyAoXCJ2YXJuYW0rMF8wMDQ1XCIpOyAgICAvLyBnZXQgY3VycmVudCB2YXJpYWJsZSBuYW1lIGZpcnN0IGNoYXJhY3RlclxyXG4vKiBhZjMxICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwidmFybmFtKzFfMDA0NlwiKTsgICAgLy8gZ2V0IGN1cnJlbnQgdmFyaWFibGUgbmFtZSBzZWNvbmQgY2hhcmFjdGVyXHJcbi8qIGFmMzMgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ2YWx0eXBfMDAwZFwiKTsgICAgICAvLyBnZXQgZGF0YSB0eXBlIGZsYWcsICRGRiA9IHN0cmluZywgJDAwID0gbnVtZXJpY1xyXG4vKiBhZjM1ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2FmNWRcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG51bWVyaWNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB2YXJpYWJsZSBpcyBzdHJpbmdcclxuLyogYWYzNyAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBlbHNlIGNsZWFyIEFcclxuLyogYWYzOSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZhY292XzAwNzBcIik7ICAgICAgIC8vIGNsZWFyIEZBQzEgcm91bmRpbmcgYnl0ZVxyXG4vKiBhZjNiICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwicnN2dmFyX2FmMTRcIik7ICAgICAgLy8gY2hlY2sgYWRkcmVzcyByYW5nZVxyXG4vKiBhZjNlICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2FmNWNcIik7ICAgICAgICAgICAgLy8gZXhpdCBpZiBub3QgaW4gQkFTSUMgUk9NXHJcbi8qIGFmNDAgKi8gICAgICAgICAgICAgICAgICAgQ1BYLmltbSAoMHg1NCk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB2YXJpYWJsZSBuYW1lIGZpcnN0IGNoYXJhY3RlciB3aXRoIFwiVFwiXHJcbi8qIGFmNDIgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYWY1Y1wiKTsgICAgICAgICAgICAvLyBleGl0IGlmIG5vdCBcIlRcIlxyXG4vKiBhZjQ0ICovICAgICAgICAgICAgICAgICAgIENQWS5pbW0gKDB4YzkpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgdmFyaWFibGUgbmFtZSBzZWNvbmQgY2hhcmFjdGVyIHdpdGggXCJJJFwiXHJcbi8qIGFmNDYgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYWY1Y1wiKTsgICAgICAgICAgICAvLyBleGl0IGlmIG5vdCBcIkkkXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB2YXJpYWJsZSBuYW1lIHdhcyBcIlRJJFwiXHJcbi8qIGFmNDggKi8gIF9gdGlzYXNjX2FmNDhgOyAgSlNSLmFicyAoXCJfYWY4NFwiKTsgICAgICAgICAgICAvLyByZWFkIHJlYWwgdGltZSBjbG9jayBpbnRvIEZBQzEgbWFudGlzc2EsIDBITUxcclxuLyogYWY0YiAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcInRlbXBmMisyXzAwNWVcIik7ICAgIC8vIGNsZWFyIGV4cG9uZW50IGNvdW50IGFkanVzdFxyXG4vKiBhZjRkICovICAgICAgICAgICAgICAgICAgIERFWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIFkgPSAkRkZcclxuLyogYWY0ZSAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcImZidWZwdCswXzAwNzFcIik7ICAgIC8vIHNldCBvdXRwdXQgc3RyaW5nIGluZGV4LCAtMSB0byBhbGxvdyBmb3IgcHJlIGluY3JlbWVudFxyXG4vKiBhZjUwICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4MDYpOyAgICAgICAgICAgICAgIC8vIEhIOk1NOlNTIGlzIHNpeCBkaWdpdHNcclxuLyogYWY1MiAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcInRlbXBmMisxXzAwNWRcIik7ICAgIC8vIHNldCBudW1iZXIgb2YgY2hhcmFjdGVycyBiZWZvcmUgdGhlIGRlY2ltYWwgcG9pbnRcclxuLyogYWY1NCAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDI0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmRleCB0byBqaWZmeSBjb252ZXJzaW9uIHRhYmxlXHJcbi8qIGFmNTYgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJmb3V0aW1fYmU2OFwiKTsgICAgICAvLyBjb252ZXJ0IGppZmZ5IGNvdW50IHRvIHN0cmluZ1xyXG4vKiBhZjU5ICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2I0NmZcIik7ICAgICAgICAgICAgLy8gZXhpdCB2aWEgU1RSJCgpIGNvZGUgdGFpbFxyXG4vKiBhZjVjICovICAgICAgICBfYF9hZjVjYDsgIFJUUy5pbXAgKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFyaWFibGUgbmFtZSBzZXQtdXAsIHZhcmlhYmxlIGlzIG51bWVyaWNcclxuLyogYWY1ZCAqLyAgICAgICAgX2BfYWY1ZGA7ICBCSVQuenBnIChcImludGZsZ18wMDBlXCIpOyAgICAgIC8vIHRlc3QgZGF0YSB0eXBlIGZsYWcsICQ4MCA9IGludGVnZXIsICQwMCA9IGZsb2F0XHJcbi8qIGFmNWYgKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfYWY2ZVwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgZmxvYXRcclxuLyogYWY2MSAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBpbmRleFxyXG4vKiBhZjYzICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwiZmFjaG8rMl8wMDY0XCIpOyAgICAgLy8gZ2V0IGludGVnZXIgdmFyaWFibGUgbG93IGJ5dGVcclxuLyogYWY2NSAqLyAgICAgICAgICAgICAgICAgICBUQVguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IHRvIFhcclxuLyogYWY2NiAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgaW5kZXhcclxuLyogYWY2NyAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcImZhY2hvKzJfMDA2NFwiKTsgICAgIC8vIGdldCBpbnRlZ2VyIHZhcmlhYmxlIGhpZ2ggYnl0ZVxyXG4vKiBhZjY5ICovICAgICAgICAgICAgICAgICAgIFRBWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgdG8gWVxyXG4vKiBhZjZhICovICAgICAgICAgICAgICAgICAgIFRYQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgbG9hIGJ5dGUgdG8gQVxyXG4vKiBhZjZiICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiZ2l2YXlmX2IzOTFcIik7ICAgICAgLy8gY29udmVydCBmaXhlZCBpbnRlZ2VyIEFZIHRvIGZsb2F0IEZBQzEgYW5kIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhcmlhYmxlIG5hbWUgc2V0LXVwLCB2YXJpYWJsZSBpcyBmbG9hdFxyXG4vKiBhZjZlICovICAgICAgICBfYF9hZjZlYDsgIEpTUi5hYnMgKFwicnN2dmFyX2FmMTRcIik7ICAgICAgLy8gY2hlY2sgYWRkcmVzcyByYW5nZVxyXG4vKiBhZjcxICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2FmYTBcIik7ICAgICAgICAgICAgLy8gaWYgbm90IGluIEJBU0lDIFJPTSBnZXQgcG9pbnRlciBhbmQgdW5wYWNrIGludG8gRkFDMVxyXG4vKiBhZjczICovICAgICAgICAgICAgICAgICAgIENQWC5pbW0gKDB4NTQpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgdmFyaWFibGUgbmFtZSBmaXJzdCBjaGFyYWN0ZXIgd2l0aCBcIlRcIlxyXG4vKiBhZjc1ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2FmOTJcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vdCBcIlRcIlxyXG4vKiBhZjc3ICovICAgICAgICAgICAgICAgICAgIENQWS5pbW0gKDB4NDkpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgdmFyaWFibGUgbmFtZSBzZWNvbmQgY2hhcmFjdGVyIHdpdGggXCJJXCJcclxuLyogYWY3OSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9hZmEwXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBub3QgXCJJXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB2YXJpYWJsZSBuYW1lIHdhcyBcIlRJXCJcclxuLyogYWY3YiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9hZjg0XCIpOyAgICAgICAgICAgIC8vIHJlYWQgcmVhbCB0aW1lIGNsb2NrIGludG8gRkFDMSBtYW50aXNzYSwgMEhNTFxyXG4vKiBhZjdlICovICAgICAgICAgICAgICAgICAgIFRZQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIEFcclxuLyogYWY3ZiAqLyAgICAgICAgICAgICAgICAgICBMRFguaW1tICgweGEwKTsgICAgICAgICAgICAgICAvLyBzZXQgZXhwb25lbnQgdG8gMzIgYml0IHZhbHVlXHJcbi8qIGFmODEgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfYmM0ZlwiKTsgICAgICAgICAgICAvLyBzZXQgZXhwb25lbnQgPSBYIGFuZCBub3JtYWxpc2UgRkFDMVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyByZWFkIHJlYWwgdGltZSBjbG9jayBpbnRvIEZBQzEgbWFudGlzc2EsIDBITUxcclxuLyogYWY4NCAqLyAgICAgICAgX2BfYWY4NGA7ICBKU1IuYWJzIChcInJkdGltX2ZmZGVcIik7ICAgICAgIC8vIHJlYWQgcmVhbCB0aW1lIGNsb2NrXHJcbi8qIGFmODcgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJmYWNobysyXzAwNjRcIik7ICAgICAvLyBzYXZlIGppZmZ5IGNsb2NrIG1pZCBieXRlIGFzICBGQUMxIG1hbnRpc3NhIDNcclxuLyogYWY4OSAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcImZhY2hvKzFfMDA2M1wiKTsgICAgIC8vIHNhdmUgamlmZnkgY2xvY2sgaGlnaCBieXRlIGFzICBGQUMxIG1hbnRpc3NhIDJcclxuLyogYWY4YiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZhY2hvKzNfMDA2NVwiKTsgICAgIC8vIHNhdmUgamlmZnkgY2xvY2sgbG93IGJ5dGUgYXMgIEZBQzEgbWFudGlzc2EgNFxyXG4vKiBhZjhkICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIFlcclxuLyogYWY4ZiAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcImZhY2hvKzBfMDA2MlwiKTsgICAgIC8vIGNsZWFyIEZBQzEgbWFudGlzc2EgMVxyXG4vKiBhZjkxICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFyaWFibGUgbmFtZSBzZXQtdXAsIHZhcmlhYmxlIGlzIGZsb2F0IGFuZCBub3QgXCJUeFwiXHJcbi8qIGFmOTIgKi8gICAgICAgIF9gX2FmOTJgOyAgQ1BYLmltbSAoMHg1Myk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB2YXJpYWJsZSBuYW1lIGZpcnN0IGNoYXJhY3RlciB3aXRoIFwiU1wiXHJcbi8qIGFmOTQgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYWZhMFwiKTsgICAgICAgICAgICAvLyBpZiBub3QgXCJTXCIgZ28gZG8gbm9ybWFsIGZsb2F0aW5nIHZhcmlhYmxlXHJcbi8qIGFmOTYgKi8gICAgICAgICAgICAgICAgICAgQ1BZLmltbSAoMHg1NCk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB2YXJpYWJsZSBuYW1lIHNlY29uZCBjaGFyYWN0ZXIgd2l0aCBcIlxyXG4vKiBhZjk4ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2FmYTBcIik7ICAgICAgICAgICAgLy8gaWYgbm90IFwiVFwiIGdvIGRvIG5vcm1hbCBmbG9hdGluZyB2YXJpYWJsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhcmlhYmxlIG5hbWUgd2FzIFwiU1RcIlxyXG4vKiBhZjlhICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwicmVhZHN0X2ZmYjdcIik7ICAgICAgLy8gcmVhZCBJL08gc3RhdHVzIHdvcmRcclxuLyogYWY5ZCAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9iYzNjXCIpOyAgICAgICAgICAgIC8vIHNhdmUgQSBhcyBpbnRlZ2VyIGJ5dGUgYW5kIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhcmlhYmxlIGlzIGZsb2F0XHJcbi8qIGFmYTAgKi8gICAgICAgIF9gX2FmYTBgOyAgTERBLnpwZyAoXCJmYWNobysyXzAwNjRcIik7ICAgICAvLyBnZXQgdmFyaWFibGUgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBhZmEyICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwiZmFjaG8rM18wMDY1XCIpOyAgICAgLy8gZ2V0IHZhcmlhYmxlIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGFmYTQgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJtb3ZmbV9iYmEyXCIpOyAgICAgICAvLyB1bnBhY2sgbWVtb3J5IChBWSkgaW50byBGQUMxXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGdldCB2YWx1ZSBmcm9tIGxpbmUgY29udGludWVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBmdW5jdGlvbnMgbGVmdCBzbyAuLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCB1cCBmdW5jdGlvbiByZWZlcmVuY2VzXHJcbi8qIGFmYTcgKi8gICBfYGlzZnVuX2FmYTdgOyAgQVNMLmFjYyAoKTsgICAgICAgICAgICAgICAgICAgLy8gKjIgKDIgYnl0ZXMgcGVyIGZ1bmN0aW9uIGFkZHJlc3MpXHJcbi8qIGFmYTggKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBmdW5jdGlvbiBvZmZzZXRcclxuLyogYWZhOSAqLyAgICAgICAgICAgICAgICAgICBUQVguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IGZ1bmN0aW9uIG9mZnNldFxyXG4vKiBhZmFhICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiY2hyZ2V0KzBfMDA3M1wiKTsgICAgLy8gaW5jcmVtZW50IGFuZCBzY2FuIG1lbW9yeVxyXG4vKiBhZmFkICovICAgICAgICAgICAgICAgICAgIENQWC5pbW0gKDB4OGYpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgZnVuY3Rpb24gb2Zmc2V0IHRvIENIUiQgdG9rZW4gb2Zmc2V0KzFcclxuLyogYWZhZiAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIm51bWZ1bl9hZmQxXCIpOyAgICAgIC8vIGJyYW5jaCBpZiA8IExFRlQkIChjYW4gbm90IGJlID0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHZhbHVlIGZyb20gbGluZSAuLiBjb250aW51ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3YXMgTEVGVCQsIFJJR0hUJCBvciBNSUQkIHNvLi5cclxuLyogYWZiMSAqLyAgX2BzdHJmdW5fYWZiMWA7ICBKU1IuYWJzIChcImNoa29wbl9hZWZhXCIpOyAgICAgIC8vIHNjYW4gZm9yIFwiKFwiLCBlbHNlIGRvIHN5bnRheCBlcnJvciB0aGVuIHdhcm0gc3RhcnRcclxuLyogYWZiNCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImZybWV2bF9hZDllXCIpOyAgICAgIC8vIGV2YWx1YXRlLCBzaG91bGQgYmUgc3RyaW5nLCBleHByZXNzaW9uXHJcbi8qIGFmYjcgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfYWVmZFwiKTsgICAgICAgICAgICAvLyBzY2FuIGZvciBcIixcIiwgZWxzZSBkbyBzeW50YXggZXJyb3IgdGhlbiB3YXJtIHN0YXJ0XHJcbi8qIGFmYmEgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfYWQ4ZlwiKTsgICAgICAgICAgICAvLyBjaGVjayBpZiBzb3VyY2UgaXMgc3RyaW5nLCBlbHNlIGRvIHR5cGUgbWlzbWF0Y2hcclxuLyogYWZiZCAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIGZ1bmN0aW9uIG9mZnNldFxyXG4vKiBhZmJlICovICAgICAgICAgICAgICAgICAgIFRBWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgaXRcclxuLyogYWZiZiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZhY2hvKzNfMDA2NVwiKTsgICAgIC8vIGdldCBkZXNjcmlwdG9yIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGFmYzEgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVzaCBzdHJpbmcgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYWZjMiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZhY2hvKzJfMDA2NFwiKTsgICAgIC8vIGdldCBkZXNjcmlwdG9yIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYWZjNCAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdXNoIHN0cmluZyBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGFmYzUgKi8gICAgICAgICAgICAgICAgICAgVFhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBmdW5jdGlvbiBvZmZzZXRcclxuLyogYWZjNiAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzYXZlIGZ1bmN0aW9uIG9mZnNldFxyXG4vKiBhZmM3ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2I3OWVcIik7ICAgICAgICAgICAgLy8gZ2V0IGJ5dGUgcGFyYW1ldGVyXHJcbi8qIGFmY2EgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBmdW5jdGlvbiBvZmZzZXRcclxuLyogYWZjYiAqLyAgICAgICAgICAgICAgICAgICBUQVkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IGZ1bmN0aW9uIG9mZnNldFxyXG4vKiBhZmNjICovICAgICAgICAgICAgICAgICAgIFRYQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgYnl0ZSBwYXJhbWV0ZXIgdG8gQVxyXG4vKiBhZmNkICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggYnl0ZSBwYXJhbWV0ZXJcclxuLyogYWZjZSAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9hZmQ2XCIpOyAgICAgICAgICAgIC8vIGdvIGNhbGwgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdmFsdWUgZnJvbSBsaW5lIC4uIGNvbnRpbnVlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdhcyBTR04oKSB0byBDSFIkKCkgc28uLlxyXG4vKiBhZmQxICovICBfYG51bWZ1bl9hZmQxYDsgIEpTUi5hYnMgKFwicGFyY2hrX2FlZjFcIik7ICAgICAgLy8gZXZhbHVhdGUgZXhwcmVzc2lvbiB3aXRoaW4gcGFyZW50aGVzZXNcclxuLyogYWZkNCAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIGZ1bmN0aW9uIG9mZnNldFxyXG4vKiBhZmQ1ICovICAgICAgICAgICAgICAgICAgIFRBWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgdG8gaW5kZXhcclxuLyogYWZkNiAqLyAgICAgICAgX2BfYWZkNmA7ICBMREEuYWJ5IChcIl85ZmVhXCIpOyAgICAgICAgICAgIC8vIGdldCBmdW5jdGlvbiBqdW1wIHZlY3RvciBsb3cgYnl0ZVxyXG4vKiBhZmQ5ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiam1wZXIrMV8wMDU1XCIpOyAgICAgLy8gc2F2ZSBmdW5jdGlvbnMganVtcCB2ZWN0b3IgbG93IGJ5dGVcclxuLyogYWZkYiAqLyAgICAgICAgICAgICAgICAgICBMREEuYWJ5IChcIl85ZmViXCIpOyAgICAgICAgICAgIC8vIGdldCBmdW5jdGlvbiBqdW1wIHZlY3RvciBoaWdoIGJ5dGVcclxuLyogYWZkZSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImptcGVyKzJfMDA1NlwiKTsgICAgIC8vIHNhdmUgZnVuY3Rpb25zIGp1bXAgdmVjdG9yIGhpZ2ggYnl0ZVxyXG4vKiBhZmUwICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiam1wZXIrMF8wMDU0XCIpOyAgICAgLy8gZG8gZnVuY3Rpb24gY2FsbFxyXG4vKiBhZmUzICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2FkOGRcIik7ICAgICAgICAgICAgLy8gY2hlY2sgaWYgc291cmNlIGlzIG51bWVyaWMgYW5kIFJUUywgZWxzZSBkbyB0eXBlIG1pc21hdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5nIGZ1bmN0aW9ucyBhdm9pZCB0aGlzIGJ5IGR1bXBpbmcgdGhlIHJldHVybiBhZGRyZXNzXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHBlcmZvcm0gT1JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdvcmtzIGJlY2F1c2UgTk9UKE5PVCh4KSBBTkQgTk9UKHkpKSA9IHggT1IgeVxyXG4vKiBhZmU2ICovICAgIF9gb3JvcF9hZmU2YDsgIExEWS5pbW0gKDB4ZmYpOyAgICAgICAgICAgICAgIC8vIHNldCBZIGZvciBPUlxyXG4vKiBhZmU4ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgyYyk7ICAgICAgICAgICAgICAgIC8vIG1ha2VzIG5leHQgbGluZSBCSVQgJDAwQTBcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcGVyZm9ybSBBTkRcclxuLyogYWZlOSAqLyAgIF9gYW5kb3BfYWZlOWA7ICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBZIGZvciBBTkRcclxuLyogYWZlYiAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcImNvdW50XzAwMGJcIik7ICAgICAgIC8vIHNldCBBTkQvT1IgaW52ZXJ0IHZhbHVlXHJcbi8qIGFmZWQgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJheWludF9iMWJmXCIpOyAgICAgICAvLyBldmFsdWF0ZSBpbnRlZ2VyIGV4cHJlc3Npb24sIG5vIHNpZ24gY2hlY2tcclxuLyogYWZmMCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZhY2hvKzJfMDA2NFwiKTsgICAgIC8vIGdldCBGQUMxIG1hbnRpc3NhIDNcclxuLyogYWZmMiAqLyAgICAgICAgICAgICAgICAgICBFT1IuenBnIChcImNvdW50XzAwMGJcIik7ICAgICAgIC8vIEVPUiBsb3cgYnl0ZVxyXG4vKiBhZmY0ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiY2hhcmFjXzAwMDdcIik7ICAgICAgLy8gc2F2ZSBpdFxyXG4vKiBhZmY2ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZmFjaG8rM18wMDY1XCIpOyAgICAgLy8gZ2V0IEZBQzEgbWFudGlzc2EgNFxyXG4vKiBhZmY4ICovICAgICAgICAgICAgICAgICAgIEVPUi56cGcgKFwiY291bnRfMDAwYlwiKTsgICAgICAgLy8gRU9SIGhpZ2ggYnl0ZVxyXG4vKiBhZmZhICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZW5kY2hyXzAwMDhcIik7ICAgICAgLy8gc2F2ZSBpdFxyXG4vKiBhZmZjICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwibW92ZmFfYmJmY1wiKTsgICAgICAgLy8gY29weSBGQUMyIHRvIEZBQzEsIGdldCAybmQgdmFsdWUgaW4gZXhwcmVzc2lvblxyXG4vKiBhZmZmICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiYXlpbnRfYjFiZlwiKTsgICAgICAgLy8gZXZhbHVhdGUgaW50ZWdlciBleHByZXNzaW9uLCBubyBzaWduIGNoZWNrXHJcbi8qIGIwMDIgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJmYWNobyszXzAwNjVcIik7ICAgICAvLyBnZXQgRkFDMSBtYW50aXNzYSA0XHJcbi8qIGIwMDQgKi8gICAgICAgICAgICAgICAgICAgRU9SLnpwZyAoXCJjb3VudF8wMDBiXCIpOyAgICAgICAvLyBFT1IgaGlnaCBieXRlXHJcbi8qIGIwMDYgKi8gICAgICAgICAgICAgICAgICAgQU5ELnpwZyAoXCJlbmRjaHJfMDAwOFwiKTsgICAgICAvLyBBTkQgd2l0aCBleHByZXNzaW9uIDEgaGlnaCBieXRlXHJcbi8qIGIwMDggKi8gICAgICAgICAgICAgICAgICAgRU9SLnpwZyAoXCJjb3VudF8wMDBiXCIpOyAgICAgICAvLyBFT1IgcmVzdWx0IGhpZ2ggYnl0ZVxyXG4vKiBiMDBhICovICAgICAgICAgICAgICAgICAgIFRBWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgaW4gWVxyXG4vKiBiMDBiICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZmFjaG8rMl8wMDY0XCIpOyAgICAgLy8gZ2V0IEZBQzEgbWFudGlzc2EgM1xyXG4vKiBiMDBkICovICAgICAgICAgICAgICAgICAgIEVPUi56cGcgKFwiY291bnRfMDAwYlwiKTsgICAgICAgLy8gRU9SIGxvdyBieXRlXHJcbi8qIGIwMGYgKi8gICAgICAgICAgICAgICAgICAgQU5ELnpwZyAoXCJjaGFyYWNfMDAwN1wiKTsgICAgICAvLyBBTkQgd2l0aCBleHByZXNzaW9uIDEgbG93IGJ5dGVcclxuLyogYjAxMSAqLyAgICAgICAgICAgICAgICAgICBFT1IuenBnIChcImNvdW50XzAwMGJcIik7ICAgICAgIC8vIEVPUiByZXN1bHQgbG93IGJ5dGVcclxuLyogYjAxMyAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcImdpdmF5Zl9iMzkxXCIpOyAgICAgIC8vIGNvbnZlcnQgZml4ZWQgaW50ZWdlciBBWSB0byBmbG9hdCBGQUMxIGFuZCByZXR1cm5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcGVyZm9ybSBjb21wYXJpc29uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvIDwgY29tcGFyZVxyXG4vKiBiMDE2ICovICAgX2Bkb3JlbF9iMDE2YDsgIEpTUi5hYnMgKFwiX2FkOTBcIik7ICAgICAgICAgICAgLy8gdHlwZSBtYXRjaCBjaGVjaywgc2V0IEMgZm9yIHN0cmluZ1xyXG4vKiBiMDE5ICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwic3RycmVsX2IwMmVcIik7ICAgICAgLy8gYnJhbmNoIGlmIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvIG51bWVyaWMgPCBjb21wYXJlXHJcbi8qIGIwMWIgKi8gIF9gbnVtcmVsX2IwMWJgOyAgTERBLnpwZyAoXCJhcmdzZ25fMDA2ZVwiKTsgICAgICAvLyBnZXQgRkFDMiBzaWduIChiNylcclxuLyogYjAxZCAqLyAgICAgICAgICAgICAgICAgICBPUkEuaW1tICgweDdmKTsgICAgICAgICAgICAgICAvLyBzZXQgYWxsIG5vbiBzaWduIGJpdHNcclxuLyogYjAxZiAqLyAgICAgICAgICAgICAgICAgICBBTkQuenBnIChcImFyZ2hvKzBfMDA2YVwiKTsgICAgIC8vIGFuZCBGQUMyIG1hbnRpc3NhIDEgKEFORCBpbiBzaWduIGJpdClcclxuLyogYjAyMSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImFyZ2hvKzBfMDA2YVwiKTsgICAgIC8vIHNhdmUgRkFDMiBtYW50aXNzYSAxXHJcbi8qIGIwMjMgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHg2OSk7ICAgICAgICAgICAgICAgLy8gc2V0IHBvaW50ZXIgbG93IGJ5dGUgdG8gRkFDMlxyXG4vKiBiMDI1ICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIHNldCBwb2ludGVyIGhpZ2ggYnl0ZSB0byBGQUMyXHJcbi8qIGIwMjcgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJmY29tcF9iYzViXCIpOyAgICAgICAvLyBjb21wYXJlIEZBQzEgd2l0aCAoQVkpXHJcbi8qIGIwMmEgKi8gICAgICAgICAgICAgICAgICAgVEFYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSB0aGUgcmVzdWx0XHJcbi8qIGIwMmIgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfYjA2MVwiKTsgICAgICAgICAgICAvLyBnbyBldmFsdWF0ZSByZXN1bHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyBzdHJpbmcgPCBjb21wYXJlXHJcbi8qIGIwMmUgKi8gIF9gc3RycmVsX2IwMmVgOyAgTERBLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgYnl0ZVxyXG4vKiBiMDMwICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwidmFsdHlwXzAwMGRcIik7ICAgICAgLy8gY2xlYXIgZGF0YSB0eXBlIGZsYWcsICRGRiA9IHN0cmluZywgJDAwID0gbnVtZXJpY1xyXG4vKiBiMDMyICovICAgICAgICAgICAgICAgICAgIERFQy56cGcgKFwib3BtYXNrXzAwNGRcIik7ICAgICAgLy8gY2xlYXIgPCBiaXQgaW4gY29tcGFycmlzb24gZXZhbHVhdGlvbiBmbGFnXHJcbi8qIGIwMzQgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfYjZhNlwiKTsgICAgICAgICAgICAvLyBwb3Agc3RyaW5nIG9mZiBkZXNjcmlwdG9yIHN0YWNrLCBvciBmcm9tIHRvcCBvZiBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGFjZSByZXR1cm5zIHdpdGggQSA9IGxlbmd0aCwgWCA9IHBvaW50ZXIgbG93IGJ5dGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWSA9IHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGIwMzcgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmYWNleHBfMDA2MVwiKTsgICAgICAvLyBzYXZlIGxlbmd0aFxyXG4vKiBiMDM5ICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwiZmFjaG8rMF8wMDYyXCIpOyAgICAgLy8gc2F2ZSBzdHJpbmcgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiMDNiICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwiZmFjaG8rMV8wMDYzXCIpOyAgICAgLy8gc2F2ZSBzdHJpbmcgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYjAzZCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImFyZ2hvKzJfMDA2Y1wiKTsgICAgIC8vIGdldCBkZXNjcmlwdG9yIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYjAzZiAqLyAgICAgICAgICAgICAgICAgICBMRFkuenBnIChcImFyZ2hvKzNfMDA2ZFwiKTsgICAgIC8vIGdldCBkZXNjcmlwdG9yIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGIwNDEgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfYjZhYVwiKTsgICAgICAgICAgICAvLyBwb3AgKFlBKSBkZXNjcmlwdG9yIG9mZiBzdGFjayBvciBmcm9tIHRvcCBvZiBzdHJpbmcgc3BhY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIHdpdGggQSA9IGxlbmd0aCwgWCA9IHBvaW50ZXIgbG93IGJ5dGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWSA9IHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGIwNDQgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJhcmdobysyXzAwNmNcIik7ICAgICAvLyBzYXZlIHN0cmluZyBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGIwNDYgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJhcmdobyszXzAwNmRcIik7ICAgICAvLyBzYXZlIHN0cmluZyBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiMDQ4ICovICAgICAgICAgICAgICAgICAgIFRBWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgbGVuZ3RoXHJcbi8qIGIwNDkgKi8gICAgICAgICAgICAgICAgICAgU0VDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2V0IGNhcnJ5IGZvciBzdWJ0cmFjdFxyXG4vKiBiMDRhICovICAgICAgICAgICAgICAgICAgIFNCQy56cGcgKFwiZmFjZXhwXzAwNjFcIik7ICAgICAgLy8gc3VidHJhY3Qgc3RyaW5nIDEgbGVuZ3RoXHJcbi8qIGIwNGMgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYjA1NlwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgc3RyIDEgbGVuZ3RoID0gc3RyaW5nIDIgbGVuZ3RoXHJcbi8qIGIwNGUgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMSk7ICAgICAgICAgICAgICAgLy8gc2V0IHN0ciAxIGxlbmd0aCA+IHN0cmluZyAyIGxlbmd0aFxyXG4vKiBiMDUwICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2IwNTZcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIHNvXHJcbi8qIGIwNTIgKi8gICAgICAgICAgICAgICAgICAgTERYLnpwZyAoXCJmYWNleHBfMDA2MVwiKTsgICAgICAvLyBnZXQgc3RyaW5nIDEgbGVuZ3RoXHJcbi8qIGIwNTQgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHhmZik7ICAgICAgICAgICAgICAgLy8gc2V0IHN0ciAxIGxlbmd0aCA8IHN0cmluZyAyIGxlbmd0aFxyXG4vKiBiMDU2ICovICAgICAgICBfYF9iMDU2YDsgIFNUQS56cGcgKFwiZmFjc2duXzAwNjZcIik7ICAgICAgLy8gc2F2ZSBsZW5ndGggY29tcGFyZVxyXG4vKiBiMDU4ICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4ZmYpOyAgICAgICAgICAgICAgIC8vIHNldCBpbmRleFxyXG4vKiBiMDVhICovICAgICAgICAgICAgICAgICAgIElOWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGFkanVzdCBmb3IgbG9vcFxyXG4vKiBiMDViICovICAgICAgICBfYF9iMDViYDsgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBpbmRleFxyXG4vKiBiMDVjICovICAgICAgICAgICAgICAgICAgIERFWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCBjb3VudFxyXG4vKiBiMDVkICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2IwNjZcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIHN0aWxsIGJ5dGVzIHRvIGRvXHJcbi8qIGIwNWYgKi8gICAgICAgICAgICAgICAgICAgTERYLnpwZyAoXCJmYWNzZ25fMDA2NlwiKTsgICAgICAvLyBnZXQgbGVuZ3RoIGNvbXBhcmUgYmFja1xyXG4vKiBiMDYxICovICAgICAgICBfYF9iMDYxYDsgIEJNSS5yZWwgKFwiX2IwNzJcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIHN0ciAxIDwgc3RyIDJcclxuLyogYjA2MyAqLyAgICAgICAgICAgICAgICAgICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBmbGFnIHN0ciAxIDw9IHN0ciAyXHJcbi8qIGIwNjQgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYjA3MlwiKTsgICAgICAgICAgICAvLyBnbyBldmFsdWF0ZSByZXN1bHRcclxuLyogYjA2NiAqLyAgICAgICAgX2BfYjA2NmA7ICBMREEuaW55IChcImFyZ2hvKzJfMDA2Y1wiKTsgICAgIC8vIGdldCBzdHJpbmcgMiBieXRlXHJcbi8qIGIwNjggKi8gICAgICAgICAgICAgICAgICAgQ01QLmlueSAoXCJmYWNobyswXzAwNjJcIik7ICAgICAvLyBjb21wYXJlIHdpdGggc3RyaW5nIDEgYnl0ZVxyXG4vKiBiMDZhICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2IwNWJcIik7ICAgICAgICAgICAgLy8gbG9vcCBpZiBieXRlcyA9XHJcbi8qIGIwNmMgKi8gICAgICAgICAgICAgICAgICAgTERYLmltbSAoMHhmZik7ICAgICAgICAgICAgICAgLy8gc2V0IHN0ciAxIDwgc3RyaW5nIDJcclxuLyogYjA2ZSAqLyAgICAgICAgICAgICAgICAgICBCQ1MucmVsIChcIl9iMDcyXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBzb1xyXG4vKiBiMDcwICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4MDEpOyAgICAgICAgICAgICAgIC8vIHNldCBzdHIgMSA+IHN0cmluZyAyXHJcbi8qIGIwNzIgKi8gICAgICAgIF9gX2IwNzJgOyAgSU5YLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8geCA9IDAsIDEgb3IgMlxyXG4vKiBiMDczICovICAgICAgICAgICAgICAgICAgIFRYQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgdG8gQVxyXG4vKiBiMDc0ICovICAgICAgICAgICAgICAgICAgIFJPTC5hY2MgKCk7ICAgICAgICAgICAgICAgICAgIC8vICogMiAoMSwgMiBvciA0KVxyXG4vKiBiMDc1ICovICAgICAgICAgICAgICAgICAgIEFORC56cGcgKFwidGFuc2duXzAwMTJcIik7ICAgICAgLy8gQU5EIHdpdGggdGhlIGNvbXBhcmlzb24gZXZhbHVhdGlvbiBmbGFnXHJcbi8qIGIwNzcgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYjA3YlwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgMCAoY29tcGFyZSBpcyBmYWxzZSlcclxuLyogYjA3OSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweGZmKTsgICAgICAgICAgICAgICAvLyBlbHNlIHNldCByZXN1bHQgdHJ1ZVxyXG4vKiBiMDdiICovICAgICAgICBfYF9iMDdiYDsgIEpNUC5hYnMgKFwiX2JjM2NcIik7ICAgICAgICAgICAgLy8gc2F2ZSBBIGFzIGludGVnZXIgYnl0ZSBhbmQgcmV0dXJuXHJcbi8qIGIwN2UgKi8gICAgICAgIF9gX2IwN2VgOyAgSlNSLmFicyAoXCJfYWVmZFwiKTsgICAgICAgICAgICAvLyBzY2FuIGZvciBcIixcIiwgZWxzZSBkbyBzeW50YXggZXJyb3IgdGhlbiB3YXJtIHN0YXJ0XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHBlcmZvcm0gRElNXHJcbi8qIGIwODEgKi8gICAgIF9gZGltX2IwODFgOyAgVEFYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBcIkRJTVwiIGZsYWcgdG8gWFxyXG4vKiBiMDgyICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2IwOTBcIik7ICAgICAgICAgICAgLy8gc2VhcmNoIGZvciB2YXJpYWJsZVxyXG4vKiBiMDg1ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiY2hyZ290XzAwNzlcIik7ICAgICAgLy8gc2NhbiBtZW1vcnlcclxuLyogYjA4OCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9iMDdlXCIpOyAgICAgICAgICAgIC8vIHNjYW4gZm9yIFwiLFwiIGFuZCBsb29wIGlmIG5vdCBudWxsXHJcbi8qIGIwOGEgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gc2VhcmNoIGZvciB2YXJpYWJsZVxyXG4vKiBiMDhiICovICBfYHB0cmdldF9iMDhiYDsgIExEWC5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIHNldCBESU0gZmxhZyA9ICQwMFxyXG4vKiBiMDhkICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiY2hyZ290XzAwNzlcIik7ICAgICAgLy8gc2NhbiBtZW1vcnksIDFzdCBjaGFyYWN0ZXJcclxuLyogYjA5MCAqLyAgICAgICAgX2BfYjA5MGA7ICBTVFguenBnIChcImRpbWZsZ18wMDBjXCIpOyAgICAgIC8vIHNhdmUgRElNIGZsYWdcclxuLyogYjA5MiAqLyAgICAgICAgX2BfYjA5MmA7ICBTVEEuenBnIChcInZhcm5hbSswXzAwNDVcIik7ICAgIC8vIHNhdmUgMXN0IGNoYXJhY3RlclxyXG4vKiBiMDk0ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiY2hyZ290XzAwNzlcIik7ICAgICAgLy8gc2NhbiBtZW1vcnlcclxuLyogYjA5NyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImlzbGV0Y19iMTEzXCIpOyAgICAgIC8vIGNoZWNrIGJ5dGUsIHJldHVybiBDYiA9IDAgaWY8XCJBXCIgb3IgPlwiWlwiXHJcbi8qIGIwOWEgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfYjA5ZlwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgb2tcclxuLyogYjA5YyAqLyAgICAgICAgX2BfYjA5Y2A7ICBKTVAuYWJzIChcInN5bmVycl9hZjA4XCIpOyAgICAgIC8vIGVsc2Ugc3ludGF4IGVycm9yIHRoZW4gd2FybSBzdGFydFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdhcyB2YXJpYWJsZSBuYW1lIHNvIC4uLlxyXG4vKiBiMDlmICovICAgICAgICBfYF9iMDlmYDsgIExEWC5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIDJuZCBjaGFyYWN0ZXIgdGVtcFxyXG4vKiBiMGExICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwidmFsdHlwXzAwMGRcIik7ICAgICAgLy8gY2xlYXIgZGF0YSB0eXBlIGZsYWcsICRGRiA9IHN0cmluZywgJDAwID0gbnVtZXJpY1xyXG4vKiBiMGEzICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwiaW50ZmxnXzAwMGVcIik7ICAgICAgLy8gY2xlYXIgZGF0YSB0eXBlIGZsYWcsICQ4MCA9IGludGVnZXIsICQwMCA9IGZsb2F0XHJcbi8qIGIwYTUgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJjaHJnZXQrMF8wMDczXCIpOyAgICAvLyBpbmNyZW1lbnQgYW5kIHNjYW4gbWVtb3J5LCAybmQgY2hhcmFjdGVyXHJcbi8qIGIwYTggKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYjBhZlwiKTsgICAgICAgICAgICAvLyBpZiBjaGFyYWN0ZXIgPSBcIjBcIi1cIjlcIiAob2spIGdvIHNhdmUgMm5kIGNoYXJhY3RlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDJuZCBjaGFyYWN0ZXIgd2Fzbid0IFwiMFwiIHRvIFwiOVwiIHNvIC4uLlxyXG4vKiBiMGFhICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiaXNsZXRjX2IxMTNcIik7ICAgICAgLy8gY2hlY2sgYnl0ZSwgcmV0dXJuIENiID0gMCBpZjxcIkFcIiBvciA+XCJaXCJcclxuLyogYjBhZCAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9iMGJhXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiA8XCJBXCIgb3IgPlwiWlwiIChnbyBjaGVjayBpZiBzdHJpbmcpXHJcbi8qIGIwYWYgKi8gICAgICAgIF9gX2IwYWZgOyAgVEFYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSAybmQgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIGZ1cnRoZXIgKHZhbGlkKSBjaGFyYWN0ZXJzIGluIHRoZSB2YXJpYWJsZSBuYW1lXHJcbi8qIGIwYjAgKi8gICAgICAgIF9gX2IwYjBgOyAgSlNSLmFicyAoXCJjaHJnZXQrMF8wMDczXCIpOyAgICAvLyBpbmNyZW1lbnQgYW5kIHNjYW4gbWVtb3J5LCAzcmQgY2hhcmFjdGVyXHJcbi8qIGIwYjMgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYjBiMFwiKTsgICAgICAgICAgICAvLyBsb29wIGlmIGNoYXJhY3RlciA9IFwiMFwiLVwiOVwiIChpZ25vcmUpXHJcbi8qIGIwYjUgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJpc2xldGNfYjExM1wiKTsgICAgICAvLyBjaGVjayBieXRlLCByZXR1cm4gQ2IgPSAwIGlmPFwiQVwiIG9yID5cIlpcIlxyXG4vKiBiMGI4ICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2IwYjBcIik7ICAgICAgICAgICAgLy8gbG9vcCBpZiBjaGFyYWN0ZXIgPSBcIkFcIi1cIlpcIiAoaWdub3JlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHN0cmluZyB2YXJpYWJsZVxyXG4vKiBiMGJhICovICAgICAgICBfYF9iMGJhYDsgIENNUC5pbW0gKDB4MjQpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCBcIiRcIlxyXG4vKiBiMGJjICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2IwYzRcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vdCBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0eXBlIGlzIHN0cmluZ1xyXG4vKiBiMGJlICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4ZmYpOyAgICAgICAgICAgICAgIC8vIHNldCBkYXRhIHR5cGUgPSBzdHJpbmdcclxuLyogYjBjMCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInZhbHR5cF8wMDBkXCIpOyAgICAgIC8vIHNldCBkYXRhIHR5cGUgZmxhZywgJEZGID0gc3RyaW5nLCAkMDAgPSBudW1lcmljXHJcbi8qIGIwYzIgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYjBkNFwiKTsgICAgICAgICAgICAvLyBicmFuY2ggYWx3YXlzXHJcbi8qIGIwYzQgKi8gICAgICAgIF9gX2IwYzRgOyAgQ01QLmltbSAoMHgyNSk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIFwiJVwiXHJcbi8qIGIwYzYgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYjBkYlwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbm90IGludGVnZXJcclxuLyogYjBjOCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInN1YmZsZ18wMDEwXCIpOyAgICAgIC8vIGdldCBzdWJzY3JpcHQvRk5YIGZsYWdcclxuLyogYjBjYSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9iMDljXCIpOyAgICAgICAgICAgIC8vIGlmID8/IGRvIHN5bnRheCBlcnJvciB0aGVuIHdhcm0gc3RhcnRcclxuLyogYjBjYyAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDgwKTsgICAgICAgICAgICAgICAvLyBzZXQgaW50ZWdlciB0eXBlXHJcbi8qIGIwY2UgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJpbnRmbGdfMDAwZVwiKTsgICAgICAvLyBzZXQgZGF0YSB0eXBlID0gaW50ZWdlclxyXG4vKiBiMGQwICovICAgICAgICAgICAgICAgICAgIE9SQS56cGcgKFwidmFybmFtKzBfMDA0NVwiKTsgICAgLy8gT1IgY3VycmVudCB2YXJpYWJsZSBuYW1lIGZpcnN0IGJ5dGVcclxuLyogYjBkMiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInZhcm5hbSswXzAwNDVcIik7ICAgIC8vIHNhdmUgY3VycmVudCB2YXJpYWJsZSBuYW1lIGZpcnN0IGJ5dGVcclxuLyogYjBkNCAqLyAgICAgICAgX2BfYjBkNGA7ICBUWEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBnZXQgMm5kIGNoYXJhY3RlciBiYWNrXHJcbi8qIGIwZDUgKi8gICAgICAgICAgICAgICAgICAgT1JBLmltbSAoMHg4MCk7ICAgICAgICAgICAgICAgLy8gc2V0IHRvcCBiaXQsIGluZGljYXRlIHN0cmluZyBvciBpbnRlZ2VyIHZhcmlhYmxlXHJcbi8qIGIwZDcgKi8gICAgICAgICAgICAgICAgICAgVEFYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBiYWNrIHRvIDJuZCBjaGFyYWN0ZXIgdGVtcFxyXG4vKiBiMGQ4ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiY2hyZ2V0KzBfMDA3M1wiKTsgICAgLy8gaW5jcmVtZW50IGFuZCBzY2FuIG1lbW9yeVxyXG4vKiBiMGRiICovICAgICAgICBfYF9iMGRiYDsgIFNUWC56cGcgKFwidmFybmFtKzFfMDA0NlwiKTsgICAgLy8gc2F2ZSAybmQgY2hhcmFjdGVyXHJcbi8qIGIwZGQgKi8gICAgICAgICAgICAgICAgICAgU0VDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2V0IGNhcnJ5IGZvciBzdWJ0cmFjdFxyXG4vKiBiMGRlICovICAgICAgICAgICAgICAgICAgIE9SQS56cGcgKFwic3ViZmxnXzAwMTBcIik7ICAgICAgLy8gb3Igd2l0aCBzdWJzY3JpcHQvRk5YIGZsYWcgLSBvciBGTiBuYW1lXHJcbi8qIGIwZTAgKi8gICAgICAgICAgICAgICAgICAgU0JDLmltbSAoMHgyOCk7ICAgICAgICAgICAgICAgLy8gc3VidHJhY3QgXCIoXCJcclxuLyogYjBlMiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIm9yZHZhcl9iMGU3XCIpOyAgICAgIC8vIGJyYW5jaCBpZiBub3QgXCIoXCJcclxuLyogYjBlNCAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcImlzYXJ5X2IxZDFcIik7ICAgICAgIC8vIGdvIGZpbmQsIG9yIG1ha2UsIGFycmF5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWl0aGVyIGZpbmQgb3IgY3JlYXRlIHZhcmlhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFyaWFibGUgbmFtZSB3YXNuJ3QgeHgoLi4uLiBzbyBsb29rIGZvciBwbGFpbiB2YXJpYWJsZVxyXG4vKiBiMGU3ICovICBfYG9yZHZhcl9iMGU3YDsgIExEWS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIEFcclxuLyogYjBlOSAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcInN1YmZsZ18wMDEwXCIpOyAgICAgIC8vIGNsZWFyIHN1YnNjcmlwdC9GTlggZmxhZ1xyXG4vKiBiMGViICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwidmFydGFiKzBfMDAyZFwiKTsgICAgLy8gZ2V0IHN0YXJ0IG9mIHZhcmlhYmxlcyBsb3cgYnl0ZVxyXG4vKiBiMGVkICovICAgICAgICAgICAgICAgICAgIExEWC56cGcgKFwidmFydGFiKzFfMDAyZVwiKTsgICAgLy8gZ2V0IHN0YXJ0IG9mIHZhcmlhYmxlcyBoaWdoIGJ5dGVcclxuLyogYjBlZiAqLyAgICAgICAgX2BfYjBlZmA7ICBTVFguenBnIChcInRlbXBmMis0XzAwNjBcIik7ICAgIC8vIHNhdmUgc2VhcmNoIGFkZHJlc3MgaGlnaCBieXRlXHJcbi8qIGIwZjEgKi8gICAgICAgIF9gX2IwZjFgOyAgU1RBLnpwZyAoXCJ0ZW1wZjIrM18wMDVmXCIpOyAgICAvLyBzYXZlIHNlYXJjaCBhZGRyZXNzIGxvdyBieXRlXHJcbi8qIGIwZjMgKi8gICAgICAgICAgICAgICAgICAgQ1BYLnpwZyAoXCJhcnl0YWIrMV8wMDMwXCIpOyAgICAvLyBjb21wYXJlIHdpdGggZW5kIG9mIHZhcmlhYmxlcyBoaWdoIGJ5dGVcclxuLyogYjBmNSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9iMGZiXCIpOyAgICAgICAgICAgIC8vIHNraXAgbmV4dCBjb21wYXJlIGlmIDw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGlnaCBhZGRyZXNzZXMgd2VyZSA9IHNvIGNvbXBhcmUgbG93IGFkZHJlc3Nlc1xyXG4vKiBiMGY3ICovICAgICAgICAgICAgICAgICAgIENNUC56cGcgKFwiYXJ5dGFiKzBfMDAyZlwiKTsgICAgLy8gY29tcGFyZSBsb3cgYWRkcmVzcyB3aXRoIGVuZCBvZiB2YXJpYWJsZXMgbG93IGJ5dGVcclxuLyogYjBmOSAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIm5vdGZuc19iMTFkXCIpOyAgICAgIC8vIGlmIG5vdCBmb3VuZCBnbyBtYWtlIG5ldyB2YXJpYWJsZVxyXG4vKiBiMGZiICovICAgICAgICBfYF9iMGZiYDsgIExEQS56cGcgKFwidmFybmFtKzBfMDA0NVwiKTsgICAgLy8gZ2V0IDFzdCBjaGFyYWN0ZXIgb2YgdmFyaWFibGUgdG8gZmluZFxyXG4vKiBiMGZkICovICAgICAgICAgICAgICAgICAgIENNUC5pbnkgKFwidGVtcGYyKzNfMDA1ZlwiKTsgICAgLy8gY29tcGFyZSB3aXRoIHZhcmlhYmxlIG5hbWUgMXN0IGNoYXJhY3RlclxyXG4vKiBiMGZmICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2IxMDlcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vIG1hdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMXN0IGNoYXJhY3RlcnMgbWF0Y2ggc28gY29tcGFyZSAybmQgY2hhcmFjdGVyXHJcbi8qIGIxMDEgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ2YXJuYW0rMV8wMDQ2XCIpOyAgICAvLyBnZXQgMm5kIGNoYXJhY3RlciBvZiB2YXJpYWJsZSB0byBmaW5kXHJcbi8qIGIxMDMgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5kZXggdG8gcG9pbnQgdG8gdmFyaWFibGUgbmFtZSAybmQgY2hhcmFjdGVyXHJcbi8qIGIxMDQgKi8gICAgICAgICAgICAgICAgICAgQ01QLmlueSAoXCJ0ZW1wZjIrM18wMDVmXCIpOyAgICAvLyBjb21wYXJlIHdpdGggdmFyaWFibGUgbmFtZSAybmQgY2hhcmFjdGVyXHJcbi8qIGIxMDYgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJmaW5wdHJfYjE4NVwiKTsgICAgICAvLyBicmFuY2ggaWYgbWF0Y2ggKGZvdW5kIHZhcmlhYmxlKVxyXG4vKiBiMTA4ICovICAgICAgICAgICAgICAgICAgIERFWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgZGVjcmVtZW50IGluZGV4IChub3cgPSAkMDApXHJcbi8qIGIxMDkgKi8gICAgICAgIF9gX2IxMDlgOyAgQ0xDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgY2FycnkgZm9yIGFkZFxyXG4vKiBiMTBhICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwidGVtcGYyKzNfMDA1ZlwiKTsgICAgLy8gZ2V0IHNlYXJjaCBhZGRyZXNzIGxvdyBieXRlXHJcbi8qIGIxMGMgKi8gICAgICAgICAgICAgICAgICAgQURDLmltbSAoMHgwNyk7ICAgICAgICAgICAgICAgLy8gKzcsIG9mZnNldCB0byBuZXh0IHZhcmlhYmxlIG5hbWVcclxuLyogYjEwZSAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9iMGYxXCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgbm8gb3ZlcmZsb3cgdG8gaGlnaCBieXRlXHJcbi8qIGIxMTAgKi8gICAgICAgICAgICAgICAgICAgSU5YLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBpbmNyZW1lbnQgaGlnaCBieXRlXHJcbi8qIGIxMTEgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYjBlZlwiKTsgICAgICAgICAgICAvLyBsb29wIGFsd2F5cywgUkFNIGRvZXNuJ3QgZXh0ZW5kIHRvICRGRkZGXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgYnl0ZSwgcmV0dXJuIENiID0gMCBpZjxcIkFcIiBvciA+XCJaXCJcclxuLyogYjExMyAqLyAgX2Bpc2xldGNfYjExM2A7ICBDTVAuaW1tICgweDQxKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggXCJBXCJcclxuLyogYjExNSAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9iMTFjXCIpOyAgICAgICAgICAgIC8vIGV4aXQgaWYgbGVzc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhcnJ5IGlzIHNldFxyXG4vKiBiMTE3ICovICAgICAgICAgICAgICAgICAgIFNCQy5pbW0gKDB4NWIpOyAgICAgICAgICAgICAgIC8vIHN1YnRyYWN0IFwiWlwiKzFcclxuLyogYjExOSAqLyAgICAgICAgICAgICAgICAgICBTRUMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzZXQgY2FycnlcclxuLyogYjExYSAqLyAgICAgICAgICAgICAgICAgICBTQkMuaW1tICgweGE1KTsgICAgICAgICAgICAgICAvLyBzdWJ0cmFjdCAkQTUgKHJlc3RvcmUgYnl0ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXJyeSBjbGVhciBpZiBieXRlID4gJDVBXHJcbi8qIGIxMWMgKi8gICAgICAgIF9gX2IxMWNgOyAgUlRTLmltcCAoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWFjaGVkIGVuZCBvZiB2YXJpYWJsZSBtZW1vcnkgd2l0aG91dCBtYXRjaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLiBzbyBjcmVhdGUgbmV3IHZhcmlhYmxlXHJcbi8qIGIxMWQgKi8gIF9gbm90Zm5zX2IxMWRgOyAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcG9wIHJldHVybiBhZGRyZXNzIGxvdyBieXRlXHJcbi8qIGIxMWUgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVzaCByZXR1cm4gYWRkcmVzcyBsb3cgYnl0ZVxyXG4vKiBiMTFmICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4MmEpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCBleHBlY3RlZCBjYWxsaW5nIHJvdXRpbmUgcmV0dXJuIGxvdyBieXRlXHJcbi8qIGIxMjEgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJub3RldmxfYjEyOFwiKTsgICAgICAvLyBpZiBub3QgZ2V0IHZhcmlhYmxlIGdvIGNyZWF0ZSBuZXcgdmFyaWFibGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgb25seSBkcm9wIHRocm91Z2ggaWYgdGhlIGNhbGwgd2FzIGZyb20gJEFGMjggYW5kIGlzIG9ubHkgY2FsbGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSB0aGVyZSBpZiBpdCBpcyBzZWFyY2hpbmcgZm9yIGEgdmFyaWFibGUgZnJvbSB0aGUgcmlnaHQgaGFuZCBzaWRlIG9mIGEgTEVUIGE9YlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YXRlbWVudCwgaXQgcHJldmVudHMgdGhlIGNyZWF0aW9uIG9mIHZhcmlhYmxlcyBub3QgYXNzaWduZWQgYSB2YWx1ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZSByZXR1cm5lZCBieSB0aGlzIGlzIGVpdGhlciBudW1lcmljIHplcm8sIGV4cG9uZW50IGJ5dGUgaXMgJDAwLCBvciBudWxsIHN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZXNjcmlwdG9yIGxlbmd0aCBieXRlIGlzICQwMC4gaW4gZmFjdCBhIHBvaW50ZXIgdG8gYW55ICQwMCBieXRlIHdvdWxkIGhhdmUgZG9uZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIHJldHVybiBkdW1teSBudWxsIHZhbHVlXHJcbi8qIGIxMjMgKi8gICAgICAgIF9gX2IxMjNgOyAgTERBLmltbSAoMHgxMyk7ICAgICAgICAgICAgICAgLy8gc2V0IHJlc3VsdCBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGIxMjUgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHhiZik7ICAgICAgICAgICAgICAgLy8gc2V0IHJlc3VsdCBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiMTI3ICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIG5ldyBudW1lcmljIHZhcmlhYmxlXHJcbi8qIGIxMjggKi8gIF9gbm90ZXZsX2IxMjhgOyAgTERBLnpwZyAoXCJ2YXJuYW0rMF8wMDQ1XCIpOyAgICAvLyBnZXQgdmFyaWFibGUgbmFtZSBmaXJzdCBjaGFyYWN0ZXJcclxuLyogYjEyYSAqLyAgICAgICAgICAgICAgICAgICBMRFkuenBnIChcInZhcm5hbSsxXzAwNDZcIik7ICAgIC8vIGdldCB2YXJpYWJsZSBuYW1lIHNlY29uZCBjaGFyYWN0ZXJcclxuLyogYjEyYyAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW1tICgweDU0KTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIGZpcnN0IGNoYXJhY3RlciB3aXRoIFwiVFwiXHJcbi8qIGIxMmUgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYjEzYlwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbm90IFwiVFwiXHJcbi8qIGIxMzAgKi8gICAgICAgICAgICAgICAgICAgQ1BZLmltbSAoMHhjOSk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSBzZWNvbmQgY2hhcmFjdGVyIHdpdGggXCJJJFwiXHJcbi8qIGIxMzIgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYjEyM1wiKTsgICAgICAgICAgICAvLyBpZiBcIkkkXCIgcmV0dXJuIG51bGwgdmFsdWVcclxuLyogYjEzNCAqLyAgICAgICAgICAgICAgICAgICBDUFkuaW1tICgweDQ5KTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHNlY29uZCBjaGFyYWN0ZXIgd2l0aCBcIklcIlxyXG4vKiBiMTM2ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2IxM2JcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vdCBcIklcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG5hbWUgaXMgXCJUSVwiIGRvIHN5bnRheCBlcnJvclxyXG4vKiBiMTM4ICovICAgICAgICBfYF9iMTM4YDsgIEpNUC5hYnMgKFwic3luZXJyX2FmMDhcIik7ICAgICAgLy8gZG8gc3ludGF4IGVycm9yIHRoZW4gd2FybSBzdGFydFxyXG4vKiBiMTNiICovICAgICAgICBfYF9iMTNiYDsgIENNUC5pbW0gKDB4NTMpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgZmlyc3QgY2hhcmFjdGVyIHdpdGggXCJTXCJcclxuLyogYjEzZCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9iMTQzXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBub3QgXCJTXCJcclxuLyogYjEzZiAqLyAgICAgICAgICAgICAgICAgICBDUFkuaW1tICgweDU0KTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHNlY29uZCBjaGFyYWN0ZXIgd2l0aCBcIlRcIlxyXG4vKiBiMTQxICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2IxMzhcIik7ICAgICAgICAgICAgLy8gaWYgbmFtZSBpcyBcIlNUXCIgZG8gc3ludGF4IGVycm9yXHJcbi8qIGIxNDMgKi8gICAgICAgIF9gX2IxNDNgOyAgTERBLnpwZyAoXCJhcnl0YWIrMF8wMDJmXCIpOyAgICAvLyBnZXQgZW5kIG9mIHZhcmlhYmxlcyBsb3cgYnl0ZVxyXG4vKiBiMTQ1ICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwiYXJ5dGFiKzFfMDAzMFwiKTsgICAgLy8gZ2V0IGVuZCBvZiB2YXJpYWJsZXMgaGlnaCBieXRlXHJcbi8qIGIxNDcgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJ0ZW1wZjIrM18wMDVmXCIpOyAgICAvLyBzYXZlIG9sZCBibG9jayBzdGFydCBsb3cgYnl0ZVxyXG4vKiBiMTQ5ICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwidGVtcGYyKzRfMDA2MFwiKTsgICAgLy8gc2F2ZSBvbGQgYmxvY2sgc3RhcnQgaGlnaCBieXRlXHJcbi8qIGIxNGIgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJzdHJlbmQrMF8wMDMxXCIpOyAgICAvLyBnZXQgZW5kIG9mIGFycmF5cyBsb3cgYnl0ZVxyXG4vKiBiMTRkICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwic3RyZW5kKzFfMDAzMlwiKTsgICAgLy8gZ2V0IGVuZCBvZiBhcnJheXMgaGlnaCBieXRlXHJcbi8qIGIxNGYgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJ0ZW1wZjErM18wMDVhXCIpOyAgICAvLyBzYXZlIG9sZCBibG9jayBlbmQgbG93IGJ5dGVcclxuLyogYjE1MSAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcInRlbXBmMSs0XzAwNWJcIik7ICAgIC8vIHNhdmUgb2xkIGJsb2NrIGVuZCBoaWdoIGJ5dGVcclxuLyogYjE1MyAqLyAgICAgICAgICAgICAgICAgICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBjYXJyeSBmb3IgYWRkXHJcbi8qIGIxNTQgKi8gICAgICAgICAgICAgICAgICAgQURDLmltbSAoMHgwNyk7ICAgICAgICAgICAgICAgLy8gKzcsIHNwYWNlIGZvciBvbmUgdmFyaWFibGVcclxuLyogYjE1NiAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9iMTU5XCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBubyBvdmVyZmxvdyB0byBoaWdoIGJ5dGVcclxuLyogYjE1OCAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBlbHNlIGluY3JlbWVudCBoaWdoIGJ5dGVcclxuLyogYjE1OSAqLyAgICAgICAgX2BfYjE1OWA7ICBTVEEuenBnIChcInRlbXBmMSsxXzAwNThcIik7ICAgIC8vIHNldCBuZXcgYmxvY2sgZW5kIGxvdyBieXRlXHJcbi8qIGIxNWIgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJ0ZW1wZjErMl8wMDU5XCIpOyAgICAvLyBzZXQgbmV3IGJsb2NrIGVuZCBoaWdoIGJ5dGVcclxuLyogYjE1ZCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImJsdHVfYTNiOFwiKTsgICAgICAgIC8vIG9wZW4gdXAgc3BhY2UgaW4gbWVtb3J5XHJcbi8qIGIxNjAgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ0ZW1wZjErMV8wMDU4XCIpOyAgICAvLyBnZXQgbmV3IHN0YXJ0IGxvdyBieXRlXHJcbi8qIGIxNjIgKi8gICAgICAgICAgICAgICAgICAgTERZLnpwZyAoXCJ0ZW1wZjErMl8wMDU5XCIpOyAgICAvLyBnZXQgbmV3IHN0YXJ0IGhpZ2ggYnl0ZSAoLSQxMDApXHJcbi8qIGIxNjQgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29ycmVjdCBoaWdoIGJ5dGVcclxuLyogYjE2NSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImFyeXRhYiswXzAwMmZcIik7ICAgIC8vIHNldCBlbmQgb2YgdmFyaWFibGVzIGxvdyBieXRlXHJcbi8qIGIxNjcgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJhcnl0YWIrMV8wMDMwXCIpOyAgICAvLyBzZXQgZW5kIG9mIHZhcmlhYmxlcyBoaWdoIGJ5dGVcclxuLyogYjE2OSAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBpbmRleFxyXG4vKiBiMTZiICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwidmFybmFtKzBfMDA0NVwiKTsgICAgLy8gZ2V0IHZhcmlhYmxlIG5hbWUgMXN0IGNoYXJhY3RlclxyXG4vKiBiMTZkICovICAgICAgICAgICAgICAgICAgIFNUQS5pbnkgKFwidGVtcGYyKzNfMDA1ZlwiKTsgICAgLy8gc2F2ZSB2YXJpYWJsZSBuYW1lIDFzdCBjaGFyYWN0ZXJcclxuLyogYjE2ZiAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgaW5kZXhcclxuLyogYjE3MCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInZhcm5hbSsxXzAwNDZcIik7ICAgIC8vIGdldCB2YXJpYWJsZSBuYW1lIDJuZCBjaGFyYWN0ZXJcclxuLyogYjE3MiAqLyAgICAgICAgICAgICAgICAgICBTVEEuaW55IChcInRlbXBmMiszXzAwNWZcIik7ICAgIC8vIHNhdmUgdmFyaWFibGUgbmFtZSAybmQgY2hhcmFjdGVyXHJcbi8qIGIxNzQgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgQVxyXG4vKiBiMTc2ICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBpbmRleFxyXG4vKiBiMTc3ICovICAgICAgICAgICAgICAgICAgIFNUQS5pbnkgKFwidGVtcGYyKzNfMDA1ZlwiKTsgICAgLy8gaW5pdGlhbGlzZSB2YXJpYWJsZSBieXRlXHJcbi8qIGIxNzkgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGluZGV4XHJcbi8qIGIxN2EgKi8gICAgICAgICAgICAgICAgICAgU1RBLmlueSAoXCJ0ZW1wZjIrM18wMDVmXCIpOyAgICAvLyBpbml0aWFsaXNlIHZhcmlhYmxlIGJ5dGVcclxuLyogYjE3YyAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgaW5kZXhcclxuLyogYjE3ZCAqLyAgICAgICAgICAgICAgICAgICBTVEEuaW55IChcInRlbXBmMiszXzAwNWZcIik7ICAgIC8vIGluaXRpYWxpc2UgdmFyaWFibGUgYnl0ZVxyXG4vKiBiMTdmICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBpbmRleFxyXG4vKiBiMTgwICovICAgICAgICAgICAgICAgICAgIFNUQS5pbnkgKFwidGVtcGYyKzNfMDA1ZlwiKTsgICAgLy8gaW5pdGlhbGlzZSB2YXJpYWJsZSBieXRlXHJcbi8qIGIxODIgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGluZGV4XHJcbi8qIGIxODMgKi8gICAgICAgICAgICAgICAgICAgU1RBLmlueSAoXCJ0ZW1wZjIrM18wMDVmXCIpOyAgICAvLyBpbml0aWFsaXNlIHZhcmlhYmxlIGJ5dGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3VuZCBhIG1hdGNoIGZvciB2YXJpYWJsZVxyXG4vKiBiMTg1ICovICBfYGZpbnB0cl9iMTg1YDsgIExEQS56cGcgKFwidGVtcGYyKzNfMDA1ZlwiKTsgICAgLy8gZ2V0IHZhcmlhYmxlIGFkZHJlc3MgbG93IGJ5dGVcclxuLyogYjE4NyAqLyAgICAgICAgICAgICAgICAgICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBjYXJyeSBmb3IgYWRkXHJcbi8qIGIxODggKi8gICAgICAgICAgICAgICAgICAgQURDLmltbSAoMHgwMik7ICAgICAgICAgICAgICAgLy8gKzIsIG9mZnNldCBwYXN0IHZhcmlhYmxlIG5hbWUgYnl0ZXNcclxuLyogYjE4YSAqLyAgICAgICAgICAgICAgICAgICBMRFkuenBnIChcInRlbXBmMis0XzAwNjBcIik7ICAgIC8vIGdldCB2YXJpYWJsZSBhZGRyZXNzIGhpZ2ggYnl0ZVxyXG4vKiBiMThjICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2IxOGZcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vIG92ZXJmbG93IGZyb20gYWRkXHJcbi8qIGIxOGUgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBpbmNyZW1lbnQgaGlnaCBieXRlXHJcbi8qIGIxOGYgKi8gICAgICAgIF9gX2IxOGZgOyAgU1RBLnpwZyAoXCJ2YXJwbnQrMF8wMDQ3XCIpOyAgICAvLyBzYXZlIGN1cnJlbnQgdmFyaWFibGUgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiMTkxICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwidmFycG50KzFfMDA0OFwiKTsgICAgLy8gc2F2ZSBjdXJyZW50IHZhcmlhYmxlIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGIxOTMgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQtdXAgYXJyYXkgcG9pbnRlciB0byBmaXJzdCBlbGVtZW50IGluIGFycmF5XHJcbi8qIGIxOTQgKi8gIF9gYXJ5Z2V0X2IxOTRgOyAgTERBLnpwZyAoXCJjb3VudF8wMDBiXCIpOyAgICAgICAvLyBnZXQgIyBvZiBkaW1lbnNpb25zICgxLCAyIG9yIDMpXHJcbi8qIGIxOTYgKi8gICAgICAgICAgICAgICAgICAgQVNMLmFjYyAoKTsgICAgICAgICAgICAgICAgICAgLy8gKjIgKGFsc28gY2xlYXJzIHRoZSBjYXJyeSAhKVxyXG4vKiBiMTk3ICovICAgICAgICAgICAgICAgICAgIEFEQy5pbW0gKDB4MDUpOyAgICAgICAgICAgICAgIC8vICs1IChyZXN1bHQgaXMgNywgOSBvciAxMSBoZXJlKVxyXG4vKiBiMTk5ICovICAgICAgICAgICAgICAgICAgIEFEQy56cGcgKFwidGVtcGYyKzNfMDA1ZlwiKTsgICAgLy8gYWRkIGFycmF5IHN0YXJ0IHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYjE5YiAqLyAgICAgICAgICAgICAgICAgICBMRFkuenBnIChcInRlbXBmMis0XzAwNjBcIik7ICAgIC8vIGdldCBhcnJheSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiMTlkICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2IxYTBcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vIG92ZXJmbG93XHJcbi8qIGIxOWYgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBpbmNyZW1lbnQgaGlnaCBieXRlXHJcbi8qIGIxYTAgKi8gICAgICAgIF9gX2IxYTBgOyAgU1RBLnpwZyAoXCJ0ZW1wZjErMV8wMDU4XCIpOyAgICAvLyBzYXZlIGFycmF5IGRhdGEgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiMWEyICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwidGVtcGYxKzJfMDA1OVwiKTsgICAgLy8gc2F2ZSBhcnJheSBkYXRhIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGIxYTQgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gLTMyNzY4IGFzIGZsb2F0aW5nIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLTMyNzY4XHJcbi8qIGIxYTUgKi8gIF9gbjMyNzY4X2IxYTVgOyAgXy5ieXRlcygweDkwLCAweDgwLCAweDAwLCAweDAwLCAweDAwKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY29udmVydCBmbG9hdCB0byBmaXhlZFxyXG4vKiBiMWFhICovICBfYGZhY2lueF9iMWFhYDsgIEpTUi5hYnMgKFwiYXlpbnRfYjFiZlwiKTsgICAgICAgLy8gZXZhbHVhdGUgaW50ZWdlciBleHByZXNzaW9uLCBubyBzaWduIGNoZWNrXHJcbi8qIGIxYWQgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJmYWNobysyXzAwNjRcIik7ICAgICAvLyBnZXQgcmVzdWx0IGxvdyBieXRlXHJcbi8qIGIxYWYgKi8gICAgICAgICAgICAgICAgICAgTERZLnpwZyAoXCJmYWNobyszXzAwNjVcIik7ICAgICAvLyBnZXQgcmVzdWx0IGhpZ2ggYnl0ZVxyXG4vKiBiMWIxICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGV2YWx1YXRlIGludGVnZXIgZXhwcmVzc2lvblxyXG4vKiBiMWIyICovICBfYGludGlkeF9iMWIyYDsgIEpTUi5hYnMgKFwiY2hyZ2V0KzBfMDA3M1wiKTsgICAgLy8gaW5jcmVtZW50IGFuZCBzY2FuIG1lbW9yeVxyXG4vKiBiMWI1ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiZnJtZXZsX2FkOWVcIik7ICAgICAgLy8gZXZhbHVhdGUgZXhwcmVzc2lvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV2YWx1YXRlIGludGVnZXIgZXhwcmVzc2lvbiwgc2lnbiBjaGVja1xyXG4vKiBiMWI4ICovICAgICAgICBfYF9iMWI4YDsgIEpTUi5hYnMgKFwiX2FkOGRcIik7ICAgICAgICAgICAgLy8gY2hlY2sgaWYgc291cmNlIGlzIG51bWVyaWMsIGVsc2UgZG8gdHlwZSBtaXNtYXRjaFxyXG4vKiBiMWJiICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZmFjc2duXzAwNjZcIik7ICAgICAgLy8gZ2V0IEZBQzEgc2lnbiAoYjcpXHJcbi8qIGIxYmQgKi8gICAgICAgICAgICAgICAgICAgQk1JLnJlbCAoXCJfYjFjY1wiKTsgICAgICAgICAgICAvLyBkbyBpbGxlZ2FsIHF1YW50aXR5IGVycm9yIGlmIC12ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV2YWx1YXRlIGludGVnZXIgZXhwcmVzc2lvbiwgbm8gc2lnbiBjaGVja1xyXG4vKiBiMWJmICovICAgX2BheWludF9iMWJmYDsgIExEQS56cGcgKFwiZmFjZXhwXzAwNjFcIik7ICAgICAgLy8gZ2V0IEZBQzEgZXhwb25lbnRcclxuLyogYjFjMSAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW1tICgweDkwKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggZXhwb25lbnQgPSAyXjE2IChuPjJeMTUpXHJcbi8qIGIxYzMgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYjFjZVwiKTsgICAgICAgICAgICAvLyBpZiBuPDJeMTYgZ28gY29udmVydCBGQUMxIGZsb2F0aW5nIHRvIGZpeGVkIGFuZCByZXR1cm5cclxuLyogYjFjNSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweGE1KTsgICAgICAgICAgICAgICAvLyBzZXQgcG9pbnRlciBsb3cgYnl0ZSB0byAtMzI3NjhcclxuLyogYjFjNyAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweGIxKTsgICAgICAgICAgICAgICAvLyBzZXQgcG9pbnRlciBoaWdoIGJ5dGUgdG8gLTMyNzY4XHJcbi8qIGIxYzkgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJmY29tcF9iYzViXCIpOyAgICAgICAvLyBjb21wYXJlIEZBQzEgd2l0aCAoQVkpXHJcbi8qIGIxY2MgKi8gICAgICAgIF9gX2IxY2NgOyAgQk5FLnJlbCAoXCJmY2Vycl9iMjQ4XCIpOyAgICAgICAvLyBpZiA8PiBkbyBpbGxlZ2FsIHF1YW50aXR5IGVycm9yIHRoZW4gd2FybSBzdGFydFxyXG4vKiBiMWNlICovICAgICAgICBfYF9iMWNlYDsgIEpNUC5hYnMgKFwicWludF9iYzliXCIpOyAgICAgICAgLy8gY29udmVydCBGQUMxIGZsb2F0aW5nIHRvIGZpeGVkIGFuZCByZXR1cm5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gZmluZCBvciBtYWtlIGFycmF5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW4gYXJyYXkgaXMgc3RvcmVkIGFzIGZvbGxvd3NcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJyYXkgbmFtZSAgICAgICAgICAgICB0d28gYnl0ZXMgd2l0aCB0aGUgZm9sbG93aW5nIHBhdHRlcm5zIGZvciBkaWZmZXJlbnQgdHlwZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgIDFzdCBjaGFyICAgIDJuZCBjaGFyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICBiNyAgICAgICAgICBiNyAgICAgICB0eXBlICAgICAgICAgICAgIGVsZW1lbnQgc2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgLS0tLS0tLS0gICAgLS0tLS0tLS0gICAgLS0tLS0gICAgICAgICAgICAtLS0tLS0tLS0tLS1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgIDAgICAgICAgICAgIDAgICAgICAgIGZsb2F0aW5nIHBvaW50ICAgNVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgMCAgICAgICAgICAgMSAgICAgICAgc3RyaW5nICAgICAgICAgICAzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAxICAgICAgICAgICAxICAgICAgICBpbnRlZ2VyICAgICAgICAgIDJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvZmZzZXQgdG8gbmV4dCBhcnJheSAgIHdvcmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkaW1lbnNpb24gY291bnQgICAgICAgIGJ5dGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxc3QgZGltZW5zaW9uIHNpemUgICAgIHdvcmQsIHRoaXMgaXMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbmNsdWRpbmcgMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDJuZCBkaW1lbnNpb24gc2l6ZSAgICAgd29yZCwgb25seSBoZXJlIGlmIHRoZSBhcnJheSBoYXMgYSBzZWNvbmQgZGltZW5zaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMm5kIGRpbWVuc2lvbiBzaXplICAgICB3b3JkLCBvbmx5IGhlcmUgaWYgdGhlIGFycmF5IGhhcyBhIHRoaXJkIGRpbWVuc2lvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgbm90ZTogdGhlIGRpbWVuc2lvbiBzaXplIHdvcmQgaXMgaW4gaGlnaCBieXRlIGxvdyBieXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQsIG5vdCBsaWtlIG1vc3QgNjUwMiB3b3Jkc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gZm9yIGVhY2ggZWxlbWVudCB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIGJ5dGVzIGdpdmVuIGFzIHRoZSBlbGVtZW50IHNpemUgYWJvdmVcclxuLyogYjFkMSAqLyAgIF9gaXNhcnlfYjFkMWA7ICBMREEuenBnIChcImRpbWZsZ18wMDBjXCIpOyAgICAgIC8vIGdldCBESU0gZmxhZ1xyXG4vKiBiMWQzICovICAgICAgICAgICAgICAgICAgIE9SQS56cGcgKFwiaW50ZmxnXzAwMGVcIik7ICAgICAgLy8gT1Igd2l0aCBkYXRhIHR5cGUgZmxhZ1xyXG4vKiBiMWQ1ICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggaXRcclxuLyogYjFkNiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInZhbHR5cF8wMDBkXCIpOyAgICAgIC8vIGdldCBkYXRhIHR5cGUgZmxhZywgJEZGID0gc3RyaW5nLCAkMDAgPSBudW1lcmljXHJcbi8qIGIxZDggKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVzaCBpdFxyXG4vKiBiMWQ5ICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIGRpbWVuc2lvbnMgY291bnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3cgZ2V0IHRoZSBhcnJheSBkaW1lbnNpb24ocykgYW5kIHN0YWNrIGl0ICh0aGVtKSBiZWZvcmUgdGhlIGRhdGEgdHlwZSBhbmQgRElNIGZsYWdcclxuLyogYjFkYiAqLyAgICAgICAgX2BfYjFkYmA7ICBUWUEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IGRpbWVuc2lvbnMgY291bnRcclxuLyogYjFkYyAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzYXZlIGl0XHJcbi8qIGIxZGQgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ2YXJuYW0rMV8wMDQ2XCIpOyAgICAvLyBnZXQgYXJyYXkgbmFtZSAybmQgYnl0ZVxyXG4vKiBiMWRmICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgaXRcclxuLyogYjFlMCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInZhcm5hbSswXzAwNDVcIik7ICAgIC8vIGdldCBhcnJheSBuYW1lIDFzdCBieXRlXHJcbi8qIGIxZTIgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBpdFxyXG4vKiBiMWUzICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiaW50aWR4X2IxYjJcIik7ICAgICAgLy8gZXZhbHVhdGUgaW50ZWdlciBleHByZXNzaW9uXHJcbi8qIGIxZTYgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVsbCBhcnJheSBuYW1lIDFzdCBieXRlXHJcbi8qIGIxZTcgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJ2YXJuYW0rMF8wMDQ1XCIpOyAgICAvLyByZXN0b3JlIGFycmF5IG5hbWUgMXN0IGJ5dGVcclxuLyogYjFlOSAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdWxsIGFycmF5IG5hbWUgMm5kIGJ5dGVcclxuLyogYjFlYSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInZhcm5hbSsxXzAwNDZcIik7ICAgIC8vIHJlc3RvcmUgYXJyYXkgbmFtZSAybmQgYnl0ZVxyXG4vKiBiMWVjICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHB1bGwgZGltZW5zaW9ucyBjb3VudFxyXG4vKiBiMWVkICovICAgICAgICAgICAgICAgICAgIFRBWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgaXRcclxuLyogYjFlZSAqLyAgICAgICAgICAgICAgICAgICBUU1guaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IHN0YWNrIHBvaW50ZXJcclxuLyogYjFlZiAqLyAgICAgICAgICAgICAgICAgICBMREEuYWJ4IChcImJhZCsyXzAxMDJcIik7ICAgICAgIC8vIGdldCBESU0gZmxhZ1xyXG4vKiBiMWYyICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggaXRcclxuLyogYjFmMyAqLyAgICAgICAgICAgICAgICAgICBMREEuYWJ4IChcImJhZCsxXzAxMDFcIik7ICAgICAgIC8vIGdldCBkYXRhIHR5cGUgZmxhZ1xyXG4vKiBiMWY2ICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggaXRcclxuLyogYjFmNyAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZhY2hvKzJfMDA2NFwiKTsgICAgIC8vIGdldCB0aGlzIGRpbWVuc2lvbiBzaXplIGhpZ2ggYnl0ZVxyXG4vKiBiMWY5ICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnggKFwiYmFkKzJfMDEwMlwiKTsgICAgICAgLy8gc3RhY2sgYmVmb3JlIGZsYWcgYnl0ZXNcclxuLyogYjFmYyAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZhY2hvKzNfMDA2NVwiKTsgICAgIC8vIGdldCB0aGlzIGRpbWVuc2lvbiBzaXplIGxvdyBieXRlXHJcbi8qIGIxZmUgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFieCAoXCJiYWQrMV8wMTAxXCIpOyAgICAgICAvLyBzdGFjayBiZWZvcmUgZmxhZyBieXRlc1xyXG4vKiBiMjAxICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBkaW1lbnNpb25zIGNvdW50XHJcbi8qIGIyMDIgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJjaHJnb3RfMDA3OVwiKTsgICAgICAvLyBzY2FuIG1lbW9yeVxyXG4vKiBiMjA1ICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4MmMpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCBcIixcIlxyXG4vKiBiMjA3ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2IxZGJcIik7ICAgICAgICAgICAgLy8gaWYgZm91bmQgZ28gZG8gbmV4dCBkaW1lbnNpb25cclxuLyogYjIwOSAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcImNvdW50XzAwMGJcIik7ICAgICAgIC8vIHN0b3JlIGRpbWVuc2lvbnMgY291bnRcclxuLyogYjIwYiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImNoa2Nsc19hZWY3XCIpOyAgICAgIC8vIHNjYW4gZm9yIFwiKVwiLCBlbHNlIGRvIHN5bnRheCBlcnJvciB0aGVuIHdhcm0gc3RhcnRcclxuLyogYjIwZSAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdWxsIGRhdGEgdHlwZSBmbGFnXHJcbi8qIGIyMGYgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJ2YWx0eXBfMDAwZFwiKTsgICAgICAvLyByZXN0b3JlIGRhdGEgdHlwZSBmbGFnLCAkRkYgPSBzdHJpbmcsICQwMCA9IG51bWVyaWNcclxuLyogYjIxMSAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdWxsIGRhdGEgdHlwZSBmbGFnXHJcbi8qIGIyMTIgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJpbnRmbGdfMDAwZVwiKTsgICAgICAvLyByZXN0b3JlIGRhdGEgdHlwZSBmbGFnLCAkODAgPSBpbnRlZ2VyLCAkMDAgPSBmbG9hdFxyXG4vKiBiMjE0ICovICAgICAgICAgICAgICAgICAgIEFORC5pbW0gKDB4N2YpOyAgICAgICAgICAgICAgIC8vIG1hc2sgZGltIGZsYWdcclxuLyogYjIxNiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImRpbWZsZ18wMDBjXCIpOyAgICAgIC8vIHJlc3RvcmUgRElNIGZsYWdcclxuLyogYjIxOCAqLyAgX2BmbmRhcnlfYjIxOGA7ICBMRFguenBnIChcImFyeXRhYiswXzAwMmZcIik7ICAgIC8vIHNldCBlbmQgb2YgdmFyaWFibGVzIGxvdyBieXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGFycmF5IG1lbW9yeSBzdGFydCBsb3cgYnl0ZSlcclxuLyogYjIxYSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImFyeXRhYisxXzAwMzBcIik7ICAgIC8vIHNldCBlbmQgb2YgdmFyaWFibGVzIGhpZ2ggYnl0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIChhcnJheSBtZW1vcnkgc3RhcnQgaGlnaCBieXRlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdyBjaGVjayB0byBzZWUgaWYgd2UgYXJlIGF0IHRoZSBlbmQgb2YgYXJyYXkgbWVtb3J5LCB3ZSB3b3VsZCBiZSBpZiB0aGVyZSB3ZXJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gYXJyYXlzLlxyXG4vKiBiMjFjICovICAgICAgICBfYF9iMjFjYDsgIFNUWC56cGcgKFwidGVtcGYyKzNfMDA1ZlwiKTsgICAgLy8gc2F2ZSBhcyBhcnJheSBzdGFydCBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGIyMWUgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJ0ZW1wZjIrNF8wMDYwXCIpOyAgICAvLyBzYXZlIGFzIGFycmF5IHN0YXJ0IHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGIyMjAgKi8gICAgICAgICAgICAgICAgICAgQ01QLnpwZyAoXCJzdHJlbmQrMV8wMDMyXCIpOyAgICAvLyBjb21wYXJlIHdpdGggZW5kIG9mIGFycmF5cyBoaWdoIGJ5dGVcclxuLyogYjIyMiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9iMjI4XCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBub3QgcmVhY2hlZCBhcnJheSBtZW1vcnkgZW5kXHJcbi8qIGIyMjQgKi8gICAgICAgICAgICAgICAgICAgQ1BYLnpwZyAoXCJzdHJlbmQrMF8wMDMxXCIpOyAgICAvLyBlbHNlIGNvbXBhcmUgd2l0aCBlbmQgb2YgYXJyYXlzIGxvdyBieXRlXHJcbi8qIGIyMjYgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJub3RmZGRfYjI2MVwiKTsgICAgICAvLyBnbyBidWlsZCBhcnJheSBpZiBub3QgZm91bmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWFyY2ggZm9yIGFycmF5XHJcbi8qIGIyMjggKi8gICAgICAgIF9gX2IyMjhgOyAgTERZLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgaW5kZXhcclxuLyogYjIyYSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcInRlbXBmMiszXzAwNWZcIik7ICAgIC8vIGdldCBhcnJheSBuYW1lIGZpcnN0IGJ5dGVcclxuLyogYjIyYyAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgaW5kZXggdG8gc2Vjb25kIG5hbWUgYnl0ZVxyXG4vKiBiMjJkICovICAgICAgICAgICAgICAgICAgIENNUC56cGcgKFwidmFybmFtKzBfMDA0NVwiKTsgICAgLy8gY29tcGFyZSB3aXRoIHRoaXMgYXJyYXkgbmFtZSBmaXJzdCBieXRlXHJcbi8qIGIyMmYgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYjIzN1wiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbm8gbWF0Y2hcclxuLyogYjIzMSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInZhcm5hbSsxXzAwNDZcIik7ICAgIC8vIGVsc2UgZ2V0IHRoaXMgYXJyYXkgbmFtZSBzZWNvbmQgYnl0ZVxyXG4vKiBiMjMzICovICAgICAgICAgICAgICAgICAgIENNUC5pbnkgKFwidGVtcGYyKzNfMDA1ZlwiKTsgICAgLy8gY29tcGFyZSB3aXRoIGFycmF5IG5hbWUgc2Vjb25kIGJ5dGVcclxuLyogYjIzNSAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9iMjRkXCIpOyAgICAgICAgICAgIC8vIGFycmF5IGZvdW5kIHNvIGJyYW5jaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIG1hdGNoXHJcbi8qIGIyMzcgKi8gICAgICAgIF9gX2IyMzdgOyAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGluZGV4XHJcbi8qIGIyMzggKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJ0ZW1wZjIrM18wMDVmXCIpOyAgICAvLyBnZXQgYXJyYXkgc2l6ZSBsb3cgYnl0ZVxyXG4vKiBiMjNhICovICAgICAgICAgICAgICAgICAgIENMQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIGNhcnJ5IGZvciBhZGRcclxuLyogYjIzYiAqLyAgICAgICAgICAgICAgICAgICBBREMuenBnIChcInRlbXBmMiszXzAwNWZcIik7ICAgIC8vIGFkZCBhcnJheSBzdGFydCBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGIyM2QgKi8gICAgICAgICAgICAgICAgICAgVEFYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBsb3cgYnl0ZSB0byBYXHJcbi8qIGIyM2UgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGluZGV4XHJcbi8qIGIyM2YgKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJ0ZW1wZjIrM18wMDVmXCIpOyAgICAvLyBnZXQgYXJyYXkgc2l6ZSBoaWdoIGJ5dGVcclxuLyogYjI0MSAqLyAgICAgICAgICAgICAgICAgICBBREMuenBnIChcInRlbXBmMis0XzAwNjBcIik7ICAgIC8vIGFkZCBhcnJheSBtZW1vcnkgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYjI0MyAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9iMjFjXCIpOyAgICAgICAgICAgIC8vIGlmIG5vIG92ZXJmbG93IGdvIGNoZWNrIG5leHQgYXJyYXlcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gZG8gYmFkIHN1YnNjcmlwdCBlcnJvclxyXG4vKiBiMjQ1ICovICAgX2Bic2Vycl9iMjQ1YDsgIExEWC5pbW0gKDB4MTIpOyAgICAgICAgICAgICAgIC8vIGVycm9yICQxMiwgYmFkIHN1YnNjcmlwdCBlcnJvclxyXG4vKiBiMjQ3ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgyYyk7ICAgICAgICAgICAgICAgIC8vIG1ha2VzIG5leHQgbGluZSBCSVQgJDBFQTJcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gZG8gaWxsZWdhbCBxdWFudGl0eSBlcnJvclxyXG4vKiBiMjQ4ICovICAgX2BmY2Vycl9iMjQ4YDsgIExEWC5pbW0gKDB4MGUpOyAgICAgICAgICAgICAgIC8vIGVycm9yICQwRSwgaWxsZWdhbCBxdWFudGl0eSBlcnJvclxyXG4vKiBiMjRhICovICAgICAgICBfYF9iMjRhYDsgIEpNUC5hYnMgKFwiZXJyb3JfYTQzN1wiKTsgICAgICAgLy8gZG8gZXJyb3IgI1ggdGhlbiB3YXJtIHN0YXJ0XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGZvdW5kIHRoZSBhcnJheVxyXG4vKiBiMjRkICovICAgICAgICBfYF9iMjRkYDsgIExEWC5pbW0gKDB4MTMpOyAgICAgICAgICAgICAgIC8vIHNldCBlcnJvciAkMTMsIGRvdWJsZSBkaW1lbnNpb24gZXJyb3JcclxuLyogYjI0ZiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImRpbWZsZ18wMDBjXCIpOyAgICAgIC8vIGdldCBESU0gZmxhZ1xyXG4vKiBiMjUxICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2IyNGFcIik7ICAgICAgICAgICAgLy8gaWYgd2UgYXJlIHRyeWluZyB0byBkaW1lbnNpb24gaXQgZG8gZXJyb3IgI1ggdGhlbiB3YXJtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3VuZCB0aGUgYXJyYXkgYW5kIHdlJ3JlIG5vdCBkaW1lbnNpb25pbmcgaXQgc28gd2UgbXVzdCBmaW5kIGFuIGVsZW1lbnQgaW4gaXRcclxuLyogYjI1MyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImFyeWdldF9iMTk0XCIpOyAgICAgIC8vIHNldC11cCBhcnJheSBwb2ludGVyIHRvIGZpcnN0IGVsZW1lbnQgaW4gYXJyYXlcclxuLyogYjI1NiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImNvdW50XzAwMGJcIik7ICAgICAgIC8vIGdldCBkaW1lbnNpb25zIGNvdW50XHJcbi8qIGIyNTggKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgwNCk7ICAgICAgICAgICAgICAgLy8gc2V0IGluZGV4IHRvIGFycmF5J3MgIyBvZiBkaW1lbnNpb25zXHJcbi8qIGIyNWEgKi8gICAgICAgICAgICAgICAgICAgQ01QLmlueSAoXCJ0ZW1wZjIrM18wMDVmXCIpOyAgICAvLyBjb21wYXJlIHdpdGggbm8gb2YgZGltZW5zaW9uc1xyXG4vKiBiMjVjICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiYnNlcnJfYjI0NVwiKTsgICAgICAgLy8gaWYgd3JvbmcgZG8gYmFkIHN1YnNjcmlwdCBlcnJvclxyXG4vKiBiMjVlICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2IyZWFcIik7ICAgICAgICAgICAgLy8gZm91bmQgYXJyYXkgc28gZ28gZ2V0IGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhcnJheSBub3QgZm91bmQsIHNvIGJ1aWxkIGl0XHJcbi8qIGIyNjEgKi8gIF9gbm90ZmRkX2IyNjFgOyAgSlNSLmFicyAoXCJhcnlnZXRfYjE5NFwiKTsgICAgICAvLyBzZXQtdXAgYXJyYXkgcG9pbnRlciB0byBmaXJzdCBlbGVtZW50IGluIGFycmF5XHJcbi8qIGIyNjQgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJyZWFzb25fYTQwOFwiKTsgICAgICAvLyBjaGVjayBhdmFpbGFibGUgbWVtb3J5LCBkbyBvdXQgb2YgbWVtb3J5IGVycm9yIGlmIG5vIHJvb21cclxuLyogYjI2NyAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBZXHJcbi8qIGIyNjkgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJmYnVmcHQrMV8wMDcyXCIpOyAgICAvLyBjbGVhciBhcnJheSBkYXRhIHNpemUgaGlnaCBieXRlXHJcbi8qIGIyNmIgKi8gICAgICAgICAgICAgICAgICAgTERYLmltbSAoMHgwNSk7ICAgICAgICAgICAgICAgLy8gc2V0IGRlZmF1bHQgZWxlbWVudCBzaXplXHJcbi8qIGIyNmQgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ2YXJuYW0rMF8wMDQ1XCIpOyAgICAvLyBnZXQgdmFyaWFibGUgbmFtZSAxc3QgYnl0ZVxyXG4vKiBiMjZmICovICAgICAgICAgICAgICAgICAgIFNUQS5pbnkgKFwidGVtcGYyKzNfMDA1ZlwiKTsgICAgLy8gc2F2ZSBhcnJheSBuYW1lIDFzdCBieXRlXHJcbi8qIGIyNzEgKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfYjI3NFwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbm90IHN0cmluZyBvciBmbG9hdGluZyBwb2ludCBhcnJheVxyXG4vKiBiMjczICovICAgICAgICAgICAgICAgICAgIERFWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCBlbGVtZW50IHNpemUsICQwNFxyXG4vKiBiMjc0ICovICAgICAgICBfYF9iMjc0YDsgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBpbmRleFxyXG4vKiBiMjc1ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwidmFybmFtKzFfMDA0NlwiKTsgICAgLy8gZ2V0IHZhcmlhYmxlIG5hbWUgMm5kIGJ5dGVcclxuLyogYjI3NyAqLyAgICAgICAgICAgICAgICAgICBTVEEuaW55IChcInRlbXBmMiszXzAwNWZcIik7ICAgIC8vIHNhdmUgYXJyYXkgbmFtZSAybmQgYnl0ZVxyXG4vKiBiMjc5ICovICAgICAgICAgICAgICAgICAgIEJQTC5yZWwgKFwiX2IyN2RcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vdCBpbnRlZ2VyIG9yIHN0cmluZ1xyXG4vKiBiMjdiICovICAgICAgICAgICAgICAgICAgIERFWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCBlbGVtZW50IHNpemUsICQwM1xyXG4vKiBiMjdjICovICAgICAgICAgICAgICAgICAgIERFWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCBlbGVtZW50IHNpemUsICQwMlxyXG4vKiBiMjdkICovICAgICAgICBfYF9iMjdkYDsgIFNUWC56cGcgKFwiZmJ1ZnB0KzBfMDA3MVwiKTsgICAgLy8gc2F2ZSBlbGVtZW50IHNpemVcclxuLyogYjI3ZiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImNvdW50XzAwMGJcIik7ICAgICAgIC8vIGdldCBkaW1lbnNpb25zIGNvdW50XHJcbi8qIGIyODEgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGluZGV4IC4uXHJcbi8qIGIyODIgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gLi4gdG8gYXJyYXkgIC4uXHJcbi8qIGIyODMgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gLi4gZGltZW5zaW9uIGNvdW50XHJcbi8qIGIyODQgKi8gICAgICAgICAgICAgICAgICAgU1RBLmlueSAoXCJ0ZW1wZjIrM18wMDVmXCIpOyAgICAvLyBzYXZlIGFycmF5IGRpbWVuc2lvbiBjb3VudFxyXG4vKiBiMjg2ICovICAgICAgICBfYF9iMjg2YDsgIExEWC5pbW0gKDB4MGIpOyAgICAgICAgICAgICAgIC8vIHNldCBkZWZhdWx0IGRpbWVuc2lvbiBzaXplIGxvdyBieXRlXHJcbi8qIGIyODggKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gc2V0IGRlZmF1bHQgZGltZW5zaW9uIHNpemUgaGlnaCBieXRlXHJcbi8qIGIyOGEgKi8gICAgICAgICAgICAgICAgICAgQklULnpwZyAoXCJkaW1mbGdfMDAwY1wiKTsgICAgICAvLyB0ZXN0IERJTSBmbGFnXHJcbi8qIGIyOGMgKi8gICAgICAgICAgICAgICAgICAgQlZDLnJlbCAoXCJfYjI5NlwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgZGVmYXVsdCB0byBiZSB1c2VkXHJcbi8qIGIyOGUgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVsbCBkaW1lbnNpb24gc2l6ZSBsb3cgYnl0ZVxyXG4vKiBiMjhmICovICAgICAgICAgICAgICAgICAgIENMQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIGNhcnJ5IGZvciBhZGRcclxuLyogYjI5MCAqLyAgICAgICAgICAgICAgICAgICBBREMuaW1tICgweDAxKTsgICAgICAgICAgICAgICAvLyBhZGQgMSwgYWxsb3cgZm9yIHplcm9ldGggZWxlbWVudFxyXG4vKiBiMjkyICovICAgICAgICAgICAgICAgICAgIFRBWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgbG93IGJ5dGUgdG8gWFxyXG4vKiBiMjkzICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHB1bGwgZGltZW5zaW9uIHNpemUgaGlnaCBieXRlXHJcbi8qIGIyOTQgKi8gICAgICAgICAgICAgICAgICAgQURDLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gYWRkIGNhcnJ5IHRvIGhpZ2ggYnl0ZVxyXG4vKiBiMjk2ICovICAgICAgICBfYF9iMjk2YDsgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY2VtZW50IGluZGV4IHRvIGRpbWVuc2lvbiBzaXplIGhpZ2ggYnl0ZVxyXG4vKiBiMjk3ICovICAgICAgICAgICAgICAgICAgIFNUQS5pbnkgKFwidGVtcGYyKzNfMDA1ZlwiKTsgICAgLy8gc2F2ZSBkaW1lbnNpb24gc2l6ZSBoaWdoIGJ5dGVcclxuLyogYjI5OSAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNlbWVudCBpbmRleCB0byBkaW1lbnNpb24gc2l6ZSBsb3cgYnl0ZVxyXG4vKiBiMjlhICovICAgICAgICAgICAgICAgICAgIFRYQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgZGltZW5zaW9uIHNpemUgbG93IGJ5dGVcclxuLyogYjI5YiAqLyAgICAgICAgICAgICAgICAgICBTVEEuaW55IChcInRlbXBmMiszXzAwNWZcIik7ICAgIC8vIHNhdmUgZGltZW5zaW9uIHNpemUgbG93IGJ5dGVcclxuLyogYjI5ZCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcInVtdWx0X2IzNGNcIik7ICAgICAgIC8vIGNvbXB1dGUgYXJyYXkgc2l6ZVxyXG4vKiBiMmEwICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwiZmJ1ZnB0KzBfMDA3MVwiKTsgICAgLy8gc2F2ZSByZXN1bHQgbG93IGJ5dGVcclxuLyogYjJhMiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZidWZwdCsxXzAwNzJcIik7ICAgIC8vIHNhdmUgcmVzdWx0IGhpZ2ggYnl0ZVxyXG4vKiBiMmE0ICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwiaW5kZXgrMF8wMDIyXCIpOyAgICAgLy8gcmVzdG9yZSBpbmRleFxyXG4vKiBiMmE2ICovICAgICAgICAgICAgICAgICAgIERFQy56cGcgKFwiY291bnRfMDAwYlwiKTsgICAgICAgLy8gZGVjcmVtZW50IGRpbWVuc2lvbnMgY291bnRcclxuLyogYjJhOCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9iMjg2XCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgbm90IGFsbCBkb25lXHJcbi8qIGIyYWEgKi8gICAgICAgICAgICAgICAgICAgQURDLnpwZyAoXCJ0ZW1wZjErMl8wMDU5XCIpOyAgICAvLyBhZGQgYXJyYXkgZGF0YSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiMmFjICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2IzMGJcIik7ICAgICAgICAgICAgLy8gaWYgb3ZlcmZsb3cgZG8gb3V0IG9mIG1lbW9yeSBlcnJvciB0aGVuIHdhcm0gc3RhcnRcclxuLyogYjJhZSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInRlbXBmMSsyXzAwNTlcIik7ICAgIC8vIHNhdmUgYXJyYXkgZGF0YSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiMmIwICovICAgICAgICAgICAgICAgICAgIFRBWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgYXJyYXkgZGF0YSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiMmIxICovICAgICAgICAgICAgICAgICAgIFRYQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgYXJyYXkgc2l6ZSBsb3cgYnl0ZVxyXG4vKiBiMmIyICovICAgICAgICAgICAgICAgICAgIEFEQy56cGcgKFwidGVtcGYxKzFfMDA1OFwiKTsgICAgLy8gYWRkIGFycmF5IGRhdGEgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiMmI0ICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2IyYjlcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vIHJvbGxvdmVyXHJcbi8qIGIyYjYgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBpbmNyZW1lbnQgbmV4dCBhcnJheSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiMmI3ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2IzMGJcIik7ICAgICAgICAgICAgLy8gaWYgcm9sbGVkIG92ZXIgZG8gb3V0IG9mIG1lbW9yeSBlcnJvciB0aGVuIHdhcm0gc3RhcnRcclxuLyogYjJiOSAqLyAgICAgICAgX2BfYjJiOWA7ICBKU1IuYWJzIChcInJlYXNvbl9hNDA4XCIpOyAgICAgIC8vIGNoZWNrIGF2YWlsYWJsZSBtZW1vcnksIGRvIG91dCBvZiBtZW1vcnkgZXJyb3IgaWYgbm8gcm9vbVxyXG4vKiBiMmJjICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwic3RyZW5kKzBfMDAzMVwiKTsgICAgLy8gc2V0IGVuZCBvZiBhcnJheXMgbG93IGJ5dGVcclxuLyogYjJiZSAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcInN0cmVuZCsxXzAwMzJcIik7ICAgIC8vIHNldCBlbmQgb2YgYXJyYXlzIGhpZ2ggYnl0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdyB0aGUgYXJheSBpcyBjcmVhdGVkIHdlIG5lZWQgdG8gemVybyBhbGwgdGhlIGVsZW1lbnRzIGluIGl0XHJcbi8qIGIyYzAgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgQSBmb3IgYXJyYXkgY2xlYXJcclxuLyogYjJjMiAqLyAgICAgICAgICAgICAgICAgICBJTkMuenBnIChcImZidWZwdCsxXzAwNzJcIik7ICAgIC8vIGluY3JlbWVudCBhcnJheSBzaXplIGhpZ2ggYnl0ZSwgbm93IGJsb2NrIGNvdW50XHJcbi8qIGIyYzQgKi8gICAgICAgICAgICAgICAgICAgTERZLnpwZyAoXCJmYnVmcHQrMF8wMDcxXCIpOyAgICAvLyBnZXQgYXJyYXkgc2l6ZSBsb3cgYnl0ZSwgbm93IGluZGV4IHRvIGJsb2NrXHJcbi8qIGIyYzYgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYjJjZFwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgJDAwXHJcbi8qIGIyYzggKi8gICAgICAgIF9gX2IyYzhgOyAgREVZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZGVjcmVtZW50IGluZGV4LCBkbyAwIHRvIG4tMVxyXG4vKiBiMmM5ICovICAgICAgICAgICAgICAgICAgIFNUQS5pbnkgKFwidGVtcGYxKzFfMDA1OFwiKTsgICAgLy8gY2xlYXIgYXJyYXkgZWxlbWVudCBieXRlXHJcbi8qIGIyY2IgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYjJjOFwiKTsgICAgICAgICAgICAvLyBsb29wIHVudGlsIHRoaXMgYmxvY2sgZG9uZVxyXG4vKiBiMmNkICovICAgICAgICBfYF9iMmNkYDsgIERFQy56cGcgKFwidGVtcGYxKzJfMDA1OVwiKTsgICAgLy8gZGVjcmVtZW50IGFycmF5IHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGIyY2YgKi8gICAgICAgICAgICAgICAgICAgREVDLnpwZyAoXCJmYnVmcHQrMV8wMDcyXCIpOyAgICAvLyBkZWNyZW1lbnQgYmxvY2sgY291bnQgaGlnaCBieXRlXHJcbi8qIGIyZDEgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYjJjOFwiKTsgICAgICAgICAgICAvLyBsb29wIHVudGlsIGFsbCBibG9ja3MgZG9uZVxyXG4vKiBiMmQzICovICAgICAgICAgICAgICAgICAgIElOQy56cGcgKFwidGVtcGYxKzJfMDA1OVwiKTsgICAgLy8gY29ycmVjdCBmb3IgbGFzdCBsb29wXHJcbi8qIGIyZDUgKi8gICAgICAgICAgICAgICAgICAgU0VDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2V0IGNhcnJ5IGZvciBzdWJ0cmFjdFxyXG4vKiBiMmQ2ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwic3RyZW5kKzBfMDAzMVwiKTsgICAgLy8gZ2V0IGVuZCBvZiBhcnJheXMgbG93IGJ5dGVcclxuLyogYjJkOCAqLyAgICAgICAgICAgICAgICAgICBTQkMuenBnIChcInRlbXBmMiszXzAwNWZcIik7ICAgIC8vIHN1YnRyYWN0IGFycmF5IHN0YXJ0IGxvdyBieXRlXHJcbi8qIGIyZGEgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgwMik7ICAgICAgICAgICAgICAgLy8gaW5kZXggdG8gYXJyYXkgc2l6ZSBsb3cgYnl0ZVxyXG4vKiBiMmRjICovICAgICAgICAgICAgICAgICAgIFNUQS5pbnkgKFwidGVtcGYyKzNfMDA1ZlwiKTsgICAgLy8gc2F2ZSBhcnJheSBzaXplIGxvdyBieXRlXHJcbi8qIGIyZGUgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJzdHJlbmQrMV8wMDMyXCIpOyAgICAvLyBnZXQgZW5kIG9mIGFycmF5cyBoaWdoIGJ5dGVcclxuLyogYjJlMCAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmRleCB0byBhcnJheSBzaXplIGhpZ2ggYnl0ZVxyXG4vKiBiMmUxICovICAgICAgICAgICAgICAgICAgIFNCQy56cGcgKFwidGVtcGYyKzRfMDA2MFwiKTsgICAgLy8gc3VidHJhY3QgYXJyYXkgc3RhcnQgaGlnaCBieXRlXHJcbi8qIGIyZTMgKi8gICAgICAgICAgICAgICAgICAgU1RBLmlueSAoXCJ0ZW1wZjIrM18wMDVmXCIpOyAgICAvLyBzYXZlIGFycmF5IHNpemUgaGlnaCBieXRlXHJcbi8qIGIyZTUgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJkaW1mbGdfMDAwY1wiKTsgICAgICAvLyBnZXQgZGVmYXVsdCBESU0gZmxhZ1xyXG4vKiBiMmU3ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2IzNGJcIik7ICAgICAgICAgICAgLy8gZXhpdCBpZiB0aGlzIHdhcyBhIERJTSBjb21tYW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSwgZmluZCBlbGVtZW50XHJcbi8qIGIyZTkgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2V0IGluZGV4IHRvICMgb2YgZGltZW5zaW9ucywgdGhlIGRpbWVuc2lvbiBpbmRlY2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJlIG9uIHRoZSBzdGFjayBhbmQgd2lsbCBiZSByZW1vdmVkIGFzIHRoZSBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBhcnJheSBlbGVtZW50IGlzIGNhbGN1bGF0ZWRcclxuLyogYjJlYSAqLyAgICAgICAgX2BfYjJlYWA7ICBMREEuaW55IChcInRlbXBmMiszXzAwNWZcIik7ICAgIC8vIGdldCBhcnJheSdzIGRpbWVuc2lvbiBjb3VudFxyXG4vKiBiMmVjICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiY291bnRfMDAwYlwiKTsgICAgICAgLy8gc2F2ZSBpdFxyXG4vKiBiMmVlICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIGJ5dGVcclxuLyogYjJmMCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZidWZwdCswXzAwNzFcIik7ICAgIC8vIGNsZWFyIGFycmF5IGRhdGEgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiMmYyICovICAgICAgICBfYF9iMmYyYDsgIFNUQS56cGcgKFwiZmJ1ZnB0KzFfMDA3MlwiKTsgICAgLy8gc2F2ZSBhcnJheSBkYXRhIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGIyZjQgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGluZGV4LCBwb2ludCB0byBhcnJheSBib3VuZCBoaWdoIGJ5dGVcclxuLyogYjJmNSAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdWxsIGFycmF5IGluZGV4IGxvdyBieXRlXHJcbi8qIGIyZjYgKi8gICAgICAgICAgICAgICAgICAgVEFYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSB0byBYXHJcbi8qIGIyZjcgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmYWNobysyXzAwNjRcIik7ICAgICAvLyBzYXZlIGluZGV4IGxvdyBieXRlIHRvIEZBQzEgbWFudGlzc2EgM1xyXG4vKiBiMmY5ICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHB1bGwgYXJyYXkgaW5kZXggaGlnaCBieXRlXHJcbi8qIGIyZmEgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmYWNobyszXzAwNjVcIik7ICAgICAvLyBzYXZlIGluZGV4IGhpZ2ggYnl0ZSB0byBGQUMxIG1hbnRpc3NhIDRcclxuLyogYjJmYyAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW55IChcInRlbXBmMiszXzAwNWZcIik7ICAgIC8vIGNvbXBhcmUgd2l0aCBhcnJheSBib3VuZCBoaWdoIGJ5dGVcclxuLyogYjJmZSAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcImlubHBuMl9iMzBlXCIpOyAgICAgIC8vIGJyYW5jaCBpZiB3aXRoaW4gYm91bmRzXHJcbi8qIGIzMDAgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYjMwOFwiKTsgICAgICAgICAgICAvLyBpZiBvdXRzaWRlIGJvdW5kcyBkbyBiYWQgc3Vic2NyaXB0IGVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBoaWdoIGJ5dGUgd2FzID0gc28gdGVzdCBsb3cgYnl0ZXNcclxuLyogYjMwMiAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmRleCB0byBhcnJheSBib3VuZCBsb3cgYnl0ZVxyXG4vKiBiMzAzICovICAgICAgICAgICAgICAgICAgIFRYQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGdldCBhcnJheSBpbmRleCBsb3cgYnl0ZVxyXG4vKiBiMzA0ICovICAgICAgICAgICAgICAgICAgIENNUC5pbnkgKFwidGVtcGYyKzNfMDA1ZlwiKTsgICAgLy8gY29tcGFyZSB3aXRoIGFycmF5IGJvdW5kIGxvdyBieXRlXHJcbi8qIGIzMDYgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYjMwZlwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgd2l0aGluIGJvdW5kc1xyXG4vKiBiMzA4ICovICAgICAgICBfYF9iMzA4YDsgIEpNUC5hYnMgKFwiYnNlcnJfYjI0NVwiKTsgICAgICAgLy8gZG8gYmFkIHN1YnNjcmlwdCBlcnJvclxyXG4vKiBiMzBiICovICAgICAgICBfYF9iMzBiYDsgIEpNUC5hYnMgKFwib21lcnJfYTQzNVwiKTsgICAgICAgLy8gZG8gb3V0IG9mIG1lbW9yeSBlcnJvciB0aGVuIHdhcm0gc3RhcnRcclxuLyogYjMwZSAqLyAgX2BpbmxwbjJfYjMwZWA7ICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmRleCB0byBhcnJheSBib3VuZCBsb3cgYnl0ZVxyXG4vKiBiMzBmICovICAgICAgICBfYF9iMzBmYDsgIExEQS56cGcgKFwiZmJ1ZnB0KzFfMDA3MlwiKTsgICAgLy8gZ2V0IGFycmF5IGRhdGEgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYjMxMSAqLyAgICAgICAgICAgICAgICAgICBPUkEuenBnIChcImZidWZwdCswXzAwNzFcIik7ICAgIC8vIE9SIHdpdGggYXJyYXkgZGF0YSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGIzMTMgKi8gICAgICAgICAgICAgICAgICAgQ0xDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgY2FycnkgZm9yIGVpdGhlciBhZGQsIGNhcnJ5IGFsd2F5cyBjbGVhciBoZXJlID8/XHJcbi8qIGIzMTQgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYjMyMFwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgYXJyYXkgZGF0YSBwb2ludGVyID0gbnVsbCwgc2tpcCBtdWx0aXBseVxyXG4vKiBiMzE2ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwidW11bHRfYjM0Y1wiKTsgICAgICAgLy8gY29tcHV0ZSBhcnJheSBzaXplXHJcbi8qIGIzMTkgKi8gICAgICAgICAgICAgICAgICAgVFhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHJlc3VsdCBsb3cgYnl0ZVxyXG4vKiBiMzFhICovICAgICAgICAgICAgICAgICAgIEFEQy56cGcgKFwiZmFjaG8rMl8wMDY0XCIpOyAgICAgLy8gYWRkIGluZGV4IGxvdyBieXRlIGZyb20gRkFDMSBtYW50aXNzYSAzXHJcbi8qIGIzMWMgKi8gICAgICAgICAgICAgICAgICAgVEFYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSByZXN1bHQgbG93IGJ5dGVcclxuLyogYjMxZCAqLyAgICAgICAgICAgICAgICAgICBUWUEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBnZXQgcmVzdWx0IGhpZ2ggYnl0ZVxyXG4vKiBiMzFlICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwiaW5kZXgrMF8wMDIyXCIpOyAgICAgLy8gcmVzdG9yZSBpbmRleFxyXG4vKiBiMzIwICovICAgICAgICBfYF9iMzIwYDsgIEFEQy56cGcgKFwiZmFjaG8rM18wMDY1XCIpOyAgICAgLy8gYWRkIGluZGV4IGhpZ2ggYnl0ZSBmcm9tIEZBQzEgbWFudGlzc2EgNFxyXG4vKiBiMzIyICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwiZmJ1ZnB0KzBfMDA3MVwiKTsgICAgLy8gc2F2ZSBhcnJheSBkYXRhIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYjMyNCAqLyAgICAgICAgICAgICAgICAgICBERUMuenBnIChcImNvdW50XzAwMGJcIik7ICAgICAgIC8vIGRlY3JlbWVudCBkaW1lbnNpb25zIGNvdW50XHJcbi8qIGIzMjYgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYjJmMlwiKTsgICAgICAgICAgICAvLyBsb29wIGlmIGRpbWVuc2lvbnMgc3RpbGwgdG8gZG9cclxuLyogYjMyOCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZidWZwdCsxXzAwNzJcIik7ICAgIC8vIHNhdmUgYXJyYXkgZGF0YSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiMzJhICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4MDUpOyAgICAgICAgICAgICAgIC8vIHNldCBkZWZhdWx0IGVsZW1lbnQgc2l6ZVxyXG4vKiBiMzJjICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwidmFybmFtKzBfMDA0NVwiKTsgICAgLy8gZ2V0IHZhcmlhYmxlIG5hbWUgMXN0IGJ5dGVcclxuLyogYjMyZSAqLyAgICAgICAgICAgICAgICAgICBCUEwucmVsIChcIl9iMzMxXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBub3Qgc3RyaW5nIG9yIGZsb2F0aW5nIHBvaW50IGFycmF5XHJcbi8qIGIzMzAgKi8gICAgICAgICAgICAgICAgICAgREVYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZGVjcmVtZW50IGVsZW1lbnQgc2l6ZSwgJDA0XHJcbi8qIGIzMzEgKi8gICAgICAgIF9gX2IzMzFgOyAgTERBLnpwZyAoXCJ2YXJuYW0rMV8wMDQ2XCIpOyAgICAvLyBnZXQgdmFyaWFibGUgbmFtZSAybmQgYnl0ZVxyXG4vKiBiMzMzICovICAgICAgICAgICAgICAgICAgIEJQTC5yZWwgKFwiX2IzMzdcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vdCBpbnRlZ2VyIG9yIHN0cmluZ1xyXG4vKiBiMzM1ICovICAgICAgICAgICAgICAgICAgIERFWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCBlbGVtZW50IHNpemUsICQwM1xyXG4vKiBiMzM2ICovICAgICAgICAgICAgICAgICAgIERFWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCBlbGVtZW50IHNpemUsICQwMlxyXG4vKiBiMzM3ICovICAgICAgICBfYF9iMzM3YDsgIFNUWC56cGcgKFwicmVzaG8rMl8wMDI4XCIpOyAgICAgLy8gc2F2ZSBkaW1lbnNpb24gc2l6ZSBsb3cgYnl0ZVxyXG4vKiBiMzM5ICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIGRpbWVuc2lvbiBzaXplIGhpZ2ggYnl0ZVxyXG4vKiBiMzNiICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2IzNTVcIik7ICAgICAgICAgICAgLy8gY29tcHV0ZSBhcnJheSBzaXplXHJcbi8qIGIzM2UgKi8gICAgICAgICAgICAgICAgICAgVFhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBhcnJheSBzaXplIGxvdyBieXRlXHJcbi8qIGIzM2YgKi8gICAgICAgICAgICAgICAgICAgQURDLnpwZyAoXCJ0ZW1wZjErMV8wMDU4XCIpOyAgICAvLyBhZGQgYXJyYXkgZGF0YSBzdGFydCBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGIzNDEgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJ2YXJwbnQrMF8wMDQ3XCIpOyAgICAvLyBzYXZlIGFzIGN1cnJlbnQgdmFyaWFibGUgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiMzQzICovICAgICAgICAgICAgICAgICAgIFRZQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgYXJyYXkgc2l6ZSBoaWdoIGJ5dGVcclxuLyogYjM0NCAqLyAgICAgICAgICAgICAgICAgICBBREMuenBnIChcInRlbXBmMSsyXzAwNTlcIik7ICAgIC8vIGFkZCBhcnJheSBkYXRhIHN0YXJ0IHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGIzNDYgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJ2YXJwbnQrMV8wMDQ4XCIpOyAgICAvLyBzYXZlIGFzIGN1cnJlbnQgdmFyaWFibGUgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYjM0OCAqLyAgICAgICAgICAgICAgICAgICBUQVkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IGhpZ2ggYnl0ZSB0byBZXHJcbi8qIGIzNDkgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ2YXJwbnQrMF8wMDQ3XCIpOyAgICAvLyBnZXQgY3VycmVudCB2YXJpYWJsZSBwb2ludGVyIGxvdyBieXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnRlciB0byBlbGVtZW50IGlzIG5vdyBpbiBBWVxyXG4vKiBiMzRiICovICAgICAgICBfYF9iMzRiYDsgIFJUUy5pbXAgKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tcHV0ZSBhcnJheSBzaXplLCByZXN1bHQgaW4gWFlcclxuLyogYjM0YyAqLyAgIF9gdW11bHRfYjM0Y2A7ICBTVFkuenBnIChcImluZGV4KzBfMDAyMlwiKTsgICAgIC8vIHNhdmUgaW5kZXhcclxuLyogYjM0ZSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcInRlbXBmMiszXzAwNWZcIik7ICAgIC8vIGdldCBkaW1lbnNpb24gc2l6ZSBsb3cgYnl0ZVxyXG4vKiBiMzUwICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwicmVzaG8rMl8wMDI4XCIpOyAgICAgLy8gc2F2ZSBkaW1lbnNpb24gc2l6ZSBsb3cgYnl0ZVxyXG4vKiBiMzUyICovICAgICAgICAgICAgICAgICAgIERFWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCBpbmRleFxyXG4vKiBiMzUzICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwidGVtcGYyKzNfMDA1ZlwiKTsgICAgLy8gZ2V0IGRpbWVuc2lvbiBzaXplIGhpZ2ggYnl0ZVxyXG4vKiBiMzU1ICovICAgICAgICBfYF9iMzU1YDsgIFNUQS56cGcgKFwicmVzaG8rM18wMDI5XCIpOyAgICAgLy8gc2F2ZSBkaW1lbnNpb24gc2l6ZSBoaWdoIGJ5dGVcclxuLyogYjM1NyAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDEwKTsgICAgICAgICAgICAgICAvLyBjb3VudCA9ICQxMCAoMTYgYml0IG11bHRpcGx5KVxyXG4vKiBiMzU5ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwidGVtcGYyKzFfMDA1ZFwiKTsgICAgLy8gc2F2ZSBiaXQgY291bnRcclxuLyogYjM1YiAqLyAgICAgICAgICAgICAgICAgICBMRFguaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciByZXN1bHQgbG93IGJ5dGVcclxuLyogYjM1ZCAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciByZXN1bHQgaGlnaCBieXRlXHJcbi8qIGIzNWYgKi8gICAgICAgIF9gX2IzNWZgOyAgVFhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHJlc3VsdCBsb3cgYnl0ZVxyXG4vKiBiMzYwICovICAgICAgICAgICAgICAgICAgIEFTTC5hY2MgKCk7ICAgICAgICAgICAgICAgICAgIC8vICoyXHJcbi8qIGIzNjEgKi8gICAgICAgICAgICAgICAgICAgVEFYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSByZXN1bHQgbG93IGJ5dGVcclxuLyogYjM2MiAqLyAgICAgICAgICAgICAgICAgICBUWUEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBnZXQgcmVzdWx0IGhpZ2ggYnl0ZVxyXG4vKiBiMzYzICovICAgICAgICAgICAgICAgICAgIFJPTC5hY2MgKCk7ICAgICAgICAgICAgICAgICAgIC8vICoyXHJcbi8qIGIzNjQgKi8gICAgICAgICAgICAgICAgICAgVEFZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSByZXN1bHQgaGlnaCBieXRlXHJcbi8qIGIzNjUgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfYjMwYlwiKTsgICAgICAgICAgICAvLyBpZiBvdmVyZmxvdyBnbyBkbyBcIk91dCBvZiBtZW1vcnlcIiBlcnJvclxyXG4vKiBiMzY3ICovICAgICAgICAgICAgICAgICAgIEFTTC56cGcgKFwiZmJ1ZnB0KzBfMDA3MVwiKTsgICAgLy8gc2hpZnQgZWxlbWVudCBzaXplIGxvdyBieXRlXHJcbi8qIGIzNjkgKi8gICAgICAgICAgICAgICAgICAgUk9MLnpwZyAoXCJmYnVmcHQrMV8wMDcyXCIpOyAgICAvLyBzaGlmdCBlbGVtZW50IHNpemUgaGlnaCBieXRlXHJcbi8qIGIzNmIgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYjM3OFwiKTsgICAgICAgICAgICAvLyBza2lwIGFkZCBpZiBubyBjYXJyeVxyXG4vKiBiMzZkICovICAgICAgICAgICAgICAgICAgIENMQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgY2xlYXIgY2FycnkgZm9yIGFkZFxyXG4vKiBiMzZlICovICAgICAgICAgICAgICAgICAgIFRYQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGdldCByZXN1bHQgbG93IGJ5dGVcclxuLyogYjM2ZiAqLyAgICAgICAgICAgICAgICAgICBBREMuenBnIChcInJlc2hvKzJfMDAyOFwiKTsgICAgIC8vIGFkZCBkaW1lbnNpb24gc2l6ZSBsb3cgYnl0ZVxyXG4vKiBiMzcxICovICAgICAgICAgICAgICAgICAgIFRBWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgcmVzdWx0IGxvdyBieXRlXHJcbi8qIGIzNzIgKi8gICAgICAgICAgICAgICAgICAgVFlBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHJlc3VsdCBoaWdoIGJ5dGVcclxuLyogYjM3MyAqLyAgICAgICAgICAgICAgICAgICBBREMuenBnIChcInJlc2hvKzNfMDAyOVwiKTsgICAgIC8vIGFkZCBkaW1lbnNpb24gc2l6ZSBoaWdoIGJ5dGVcclxuLyogYjM3NSAqLyAgICAgICAgICAgICAgICAgICBUQVkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzYXZlIHJlc3VsdCBoaWdoIGJ5dGVcclxuLyogYjM3NiAqLyAgICAgICAgICAgICAgICAgICBCQ1MucmVsIChcIl9iMzBiXCIpOyAgICAgICAgICAgIC8vIGlmIG92ZXJmbG93IGdvIGRvIFwiT3V0IG9mIG1lbW9yeVwiIGVycm9yXHJcbi8qIGIzNzggKi8gICAgICAgIF9gX2IzNzhgOyAgREVDLnpwZyAoXCJ0ZW1wZjIrMV8wMDVkXCIpOyAgICAvLyBkZWNyZW1lbnQgYml0IGNvdW50XHJcbi8qIGIzN2EgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYjM1ZlwiKTsgICAgICAgICAgICAvLyBsb29wIHVudGlsIGFsbCBkb25lXHJcbi8qIGIzN2MgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwZXJmb3JtIEZSRSgpXHJcbi8qIGIzN2QgKi8gICAgIF9gZnJlX2IzN2RgOyAgTERBLnpwZyAoXCJ2YWx0eXBfMDAwZFwiKTsgICAgICAvLyBnZXQgZGF0YSB0eXBlIGZsYWcsICRGRiA9IHN0cmluZywgJDAwID0gbnVtZXJpY1xyXG4vKiBiMzdmICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2IzODRcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG51bWVyaWNcclxuLyogYjM4MSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9iNmE2XCIpOyAgICAgICAgICAgIC8vIHBvcCBzdHJpbmcgb2ZmIGRlc2NyaXB0b3Igc3RhY2ssIG9yIGZyb20gdG9wIG9mIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwYWNlIHJldHVybnMgd2l0aCBBID0gbGVuZ3RoLCBYPSQ3MT1wb2ludGVyIGxvdyBieXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFk9JDcyPXBvaW50ZXIgaGlnaCBieXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRlJFKG4pIHdhcyBudW1lcmljIHNvIGRvIHRoaXNcclxuLyogYjM4NCAqLyAgICAgICAgX2BfYjM4NGA7ICBKU1IuYWJzIChcImdhcmJhZ19iNTI2XCIpOyAgICAgIC8vIGdvIGRvIGdhcmJhZ2UgY29sbGVjdGlvblxyXG4vKiBiMzg3ICovICAgICAgICAgICAgICAgICAgIFNFQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNldCBjYXJyeSBmb3Igc3VidHJhY3RcclxuLyogYjM4OCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZyZXRvcCswXzAwMzNcIik7ICAgIC8vIGdldCBib3R0b20gb2Ygc3RyaW5nIHNwYWNlIGxvdyBieXRlXHJcbi8qIGIzOGEgKi8gICAgICAgICAgICAgICAgICAgU0JDLnpwZyAoXCJzdHJlbmQrMF8wMDMxXCIpOyAgICAvLyBzdWJ0cmFjdCBlbmQgb2YgYXJyYXlzIGxvdyBieXRlXHJcbi8qIGIzOGMgKi8gICAgICAgICAgICAgICAgICAgVEFZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSByZXN1bHQgdG8gWVxyXG4vKiBiMzhkICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZnJldG9wKzFfMDAzNFwiKTsgICAgLy8gZ2V0IGJvdHRvbSBvZiBzdHJpbmcgc3BhY2UgaGlnaCBieXRlXHJcbi8qIGIzOGYgKi8gICAgICAgICAgICAgICAgICAgU0JDLnpwZyAoXCJzdHJlbmQrMV8wMDMyXCIpOyAgICAvLyBzdWJ0cmFjdCBlbmQgb2YgYXJyYXlzIGhpZ2ggYnl0ZVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBjb252ZXJ0IGZpeGVkIGludGVnZXIgQVkgdG8gZmxvYXQgRkFDMVxyXG4vKiBiMzkxICovICBfYGdpdmF5Zl9iMzkxYDsgIExEWC5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIHNldCB0eXBlID0gbnVtZXJpY1xyXG4vKiBiMzkzICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwidmFsdHlwXzAwMGRcIik7ICAgICAgLy8gY2xlYXIgZGF0YSB0eXBlIGZsYWcsICRGRiA9IHN0cmluZywgJDAwID0gbnVtZXJpY1xyXG4vKiBiMzk1ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZmFjaG8rMF8wMDYyXCIpOyAgICAgLy8gc2F2ZSBGQUMxIG1hbnRpc3NhIDFcclxuLyogYjM5NyAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcImZhY2hvKzFfMDA2M1wiKTsgICAgIC8vIHNhdmUgRkFDMSBtYW50aXNzYSAyXHJcbi8qIGIzOTkgKi8gICAgICAgICAgICAgICAgICAgTERYLmltbSAoMHg5MCk7ICAgICAgICAgICAgICAgLy8gc2V0IGV4cG9uZW50PTJeMTYgKGludGVnZXIpXHJcbi8qIGIzOWIgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfYmM0NFwiKTsgICAgICAgICAgICAvLyBzZXQgZXhwID0gWCwgY2xlYXIgRkFDMSAzIGFuZCA0LCBub3JtYWxpc2UgYW5kIHJldHVyblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBwZXJmb3JtIFBPUygpXHJcbi8qIGIzOWUgKi8gICAgIF9gcG9zX2IzOWVgOyAgU0VDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2V0IENiIGZvciByZWFkIGN1cnNvciBwb3NpdGlvblxyXG4vKiBiMzlmICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwicGxvdF9mZmYwXCIpOyAgICAgICAgLy8gcmVhZC9zZXQgWCxZIGN1cnNvciBwb3NpdGlvblxyXG4vKiBiM2EyICovICAgICAgICBfYF9iM2EyYDsgIExEQS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIGhpZ2ggYnl0ZVxyXG4vKiBiM2E0ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiZ2l2YXlmX2IzOTFcIik7ICAgICAgLy8gY29udmVydCBmaXhlZCBpbnRlZ2VyIEFZIHRvIGZsb2F0IEZBQzEsIGJyYW5jaCBhbHdheXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBub3QgRGlyZWN0LCB1c2VkIGJ5IERFRiBhbmQgSU5QVVRcclxuLyogYjNhNiAqLyAgX2BlcnJkaXJfYjNhNmA7ICBMRFguenBnIChcImN1cmxpbisxXzAwM2FcIik7ICAgIC8vIGdldCBjdXJyZW50IGxpbmUgbnVtYmVyIGhpZ2ggYnl0ZVxyXG4vKiBiM2E4ICovICAgICAgICAgICAgICAgICAgIElOWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBpdFxyXG4vKiBiM2E5ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2IzNGJcIik7ICAgICAgICAgICAgLy8gcmV0dXJuIGlmIG5vdCBkaXJlY3QgbW9kZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgZG8gaWxsZWdhbCBkaXJlY3QgZXJyb3JcclxuLyogYjNhYiAqLyAgICAgICAgICAgICAgICAgICBMRFguaW1tICgweDE1KTsgICAgICAgICAgICAgICAvLyBlcnJvciAkMTUsIGlsbGVnYWwgZGlyZWN0IGVycm9yXHJcbi8qIGIzYWQgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDJjKTsgICAgICAgICAgICAgICAgLy8gbWFrZXMgbmV4dCBsaW5lIEJJVCAkMUJBMlxyXG4vKiBiM2FlICovICAgICAgICBfYF9iM2FlYDsgIExEWC5pbW0gKDB4MWIpOyAgICAgICAgICAgICAgIC8vIGVycm9yICQxQiwgdW5kZWZpbmVkIGZ1bmN0aW9uIGVycm9yXHJcbi8qIGIzYjAgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJlcnJvcl9hNDM3XCIpOyAgICAgICAvLyBkbyBlcnJvciAjWCB0aGVuIHdhcm0gc3RhcnRcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcGVyZm9ybSBERUZcclxuLyogYjNiMyAqLyAgICAgX2BkZWZfYjNiM2A7ICBKU1IuYWJzIChcImdldGZubV9iM2UxXCIpOyAgICAgIC8vIGNoZWNrIEZOeCBzeW50YXhcclxuLyogYjNiNiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImVycmRpcl9iM2E2XCIpOyAgICAgIC8vIGNoZWNrIG5vdCBkaXJlY3QsIGJhY2sgaGVyZSBpZiBva1xyXG4vKiBiM2I5ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiY2hrb3BuX2FlZmFcIik7ICAgICAgLy8gc2NhbiBmb3IgXCIoXCIsIGVsc2UgZG8gc3ludGF4IGVycm9yIHRoZW4gd2FybSBzdGFydFxyXG4vKiBiM2JjICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4ODApOyAgICAgICAgICAgICAgIC8vIHNldCBmbGFnIGZvciBGTnhcclxuLyogYjNiZSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInN1YmZsZ18wMDEwXCIpOyAgICAgIC8vIHNhdmUgc3Vic2NyaXB0L0ZOeCBmbGFnXHJcbi8qIGIzYzAgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJwdHJnZXRfYjA4YlwiKTsgICAgICAvLyBnZXQgdmFyaWFibGUgYWRkcmVzc1xyXG4vKiBiM2MzICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2FkOGRcIik7ICAgICAgICAgICAgLy8gY2hlY2sgaWYgc291cmNlIGlzIG51bWVyaWMsIGVsc2UgZG8gdHlwZSBtaXNtYXRjaFxyXG4vKiBiM2M2ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiY2hrY2xzX2FlZjdcIik7ICAgICAgLy8gc2NhbiBmb3IgXCIpXCIsIGVsc2UgZG8gc3ludGF4IGVycm9yIHRoZW4gd2FybSBzdGFydFxyXG4vKiBiM2M5ICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4YjIpOyAgICAgICAgICAgICAgIC8vIGdldCA9IHRva2VuXHJcbi8qIGIzY2IgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJjaGtjb21fYWVmZlwiKTsgICAgICAvLyBzY2FuIGZvciBDSFIkKEEpLCBlbHNlIGRvIHN5bnRheCBlcnJvciB0aGVuIHdhcm0gc3RhcnRcclxuLyogYjNjZSAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdXNoIG5leHQgY2hhcmFjdGVyXHJcbi8qIGIzY2YgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ2YXJwbnQrMV8wMDQ4XCIpOyAgICAvLyBnZXQgY3VycmVudCB2YXJpYWJsZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiM2QxICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggaXRcclxuLyogYjNkMiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInZhcnBudCswXzAwNDdcIik7ICAgIC8vIGdldCBjdXJyZW50IHZhcmlhYmxlIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYjNkNCAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdXNoIGl0XHJcbi8qIGIzZDUgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ0eHRwdHIrMV8wMDdiXCIpOyAgICAvLyBnZXQgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiM2Q3ICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggaXRcclxuLyogYjNkOCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInR4dHB0ciswXzAwN2FcIik7ICAgIC8vIGdldCBCQVNJQyBleGVjdXRlIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYjNkYSAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdXNoIGl0XHJcbi8qIGIzZGIgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJkYXRhX2E4ZjhcIik7ICAgICAgICAvLyBwZXJmb3JtIERBVEFcclxuLyogYjNkZSAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9iNDRmXCIpOyAgICAgICAgICAgIC8vIHB1dCBleGVjdXRlIHBvaW50ZXIgYW5kIHZhcmlhYmxlIHBvaW50ZXIgaW50byBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCByZXR1cm5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY2hlY2sgRk54IHN5bnRheFxyXG4vKiBiM2UxICovICBfYGdldGZubV9iM2UxYDsgIExEQS5pbW0gKDB4YTUpOyAgICAgICAgICAgICAgIC8vIHNldCBGTiB0b2tlblxyXG4vKiBiM2UzICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiY2hrY29tX2FlZmZcIik7ICAgICAgLy8gc2NhbiBmb3IgQ0hSJChBKSwgZWxzZSBkbyBzeW50YXggZXJyb3IgdGhlbiB3YXJtIHN0YXJ0XHJcbi8qIGIzZTYgKi8gICAgICAgICAgICAgICAgICAgT1JBLmltbSAoMHg4MCk7ICAgICAgICAgICAgICAgLy8gc2V0IEZOIGZsYWcgYml0XHJcbi8qIGIzZTggKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJzdWJmbGdfMDAxMFwiKTsgICAgICAvLyBzYXZlIEZOIG5hbWVcclxuLyogYjNlYSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9iMDkyXCIpOyAgICAgICAgICAgIC8vIHNlYXJjaCBmb3IgRk4gdmFyaWFibGVcclxuLyogYjNlZCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImRlZnBudCswXzAwNGVcIik7ICAgIC8vIHNhdmUgZnVuY3Rpb24gcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiM2VmICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwiZGVmcG50KzFfMDA0ZlwiKTsgICAgLy8gc2F2ZSBmdW5jdGlvbiBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiM2YxICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2FkOGRcIik7ICAgICAgICAgICAgLy8gY2hlY2sgaWYgc291cmNlIGlzIG51bWVyaWMgYW5kIHJldHVybiwgZWxzZSBkbyB0eXBlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWlzbWF0Y2hcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gRXZhbHVhdGUgRk54XHJcbi8qIGIzZjQgKi8gIF9gZm5kb2VyX2IzZjRgOyAgSlNSLmFicyAoXCJnZXRmbm1fYjNlMVwiKTsgICAgICAvLyBjaGVjayBGTnggc3ludGF4XHJcbi8qIGIzZjcgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJkZWZwbnQrMV8wMDRmXCIpOyAgICAvLyBnZXQgZnVuY3Rpb24gcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYjNmOSAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdXNoIGl0XHJcbi8qIGIzZmEgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJkZWZwbnQrMF8wMDRlXCIpOyAgICAvLyBnZXQgZnVuY3Rpb24gcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiM2ZjICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggaXRcclxuLyogYjNmZCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcInBhcmNoa19hZWYxXCIpOyAgICAgIC8vIGV2YWx1YXRlIGV4cHJlc3Npb24gd2l0aGluIHBhcmVudGhlc2VzXHJcbi8qIGI0MDAgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfYWQ4ZFwiKTsgICAgICAgICAgICAvLyBjaGVjayBpZiBzb3VyY2UgaXMgbnVtZXJpYywgZWxzZSBkbyB0eXBlIG1pc21hdGNoXHJcbi8qIGI0MDMgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcG9wIGZ1bmN0aW9uIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYjQwNCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImRlZnBudCswXzAwNGVcIik7ICAgIC8vIHJlc3RvcmUgaXRcclxuLyogYjQwNiAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwb3AgZnVuY3Rpb24gcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYjQwNyAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImRlZnBudCsxXzAwNGZcIik7ICAgIC8vIHJlc3RvcmUgaXRcclxuLyogYjQwOSAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAyKTsgICAgICAgICAgICAgICAvLyBpbmRleCB0byB2YXJpYWJsZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiNDBiICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwiZGVmcG50KzBfMDA0ZVwiKTsgICAgLy8gZ2V0IHZhcmlhYmxlIGFkZHJlc3MgbG93IGJ5dGVcclxuLyogYjQwZCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInZhcnBudCswXzAwNDdcIik7ICAgIC8vIHNhdmUgY3VycmVudCB2YXJpYWJsZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGI0MGYgKi8gICAgICAgICAgICAgICAgICAgVEFYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBhZGRyZXNzIGxvdyBieXRlXHJcbi8qIGI0MTAgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5kZXggdG8gdmFyaWFibGUgYWRkcmVzcyBoaWdoIGJ5dGVcclxuLyogYjQxMSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcImRlZnBudCswXzAwNGVcIik7ICAgIC8vIGdldCB2YXJpYWJsZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiNDEzICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2IzYWVcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIGhpZ2ggYnl0ZSB6ZXJvXHJcbi8qIGI0MTUgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJ2YXJwbnQrMV8wMDQ4XCIpOyAgICAvLyBzYXZlIGN1cnJlbnQgdmFyaWFibGUgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYjQxNyAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmRleCB0byBtYW50aXNzYSAzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm93IHN0YWNrIHRoZSBmdW5jdGlvbiB2YXJpYWJsZSB2YWx1ZSBiZWZvcmUgdXNlXHJcbi8qIGI0MTggKi8gICAgICAgIF9gX2I0MThgOyAgTERBLmlueSAoXCJ2YXJwbnQrMF8wMDQ3XCIpOyAgICAvLyBnZXQgYnl0ZSBmcm9tIHZhcmlhYmxlXHJcbi8qIGI0MWEgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc3RhY2sgaXRcclxuLyogYjQxYiAqLyAgICAgICAgICAgICAgICAgICBERVkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBkZWNyZW1lbnQgaW5kZXhcclxuLyogYjQxYyAqLyAgICAgICAgICAgICAgICAgICBCUEwucmVsIChcIl9iNDE4XCIpOyAgICAgICAgICAgIC8vIGxvb3AgdW50aWwgdmFyaWFibGUgc3RhY2tlZFxyXG4vKiBiNDFlICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwidmFycG50KzFfMDA0OFwiKTsgICAgLy8gZ2V0IGN1cnJlbnQgdmFyaWFibGUgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYjQyMCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9iYmQ0XCIpOyAgICAgICAgICAgIC8vIHBhY2sgRkFDMSBpbnRvIChYWSlcclxuLyogYjQyMyAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInR4dHB0cisxXzAwN2JcIik7ICAgIC8vIGdldCBCQVNJQyBleGVjdXRlIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGI0MjUgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVzaCBpdFxyXG4vKiBiNDI2ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwidHh0cHRyKzBfMDA3YVwiKTsgICAgLy8gZ2V0IEJBU0lDIGV4ZWN1dGUgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiNDI4ICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggaXRcclxuLyogYjQyOSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcImRlZnBudCswXzAwNGVcIik7ICAgIC8vIGdldCBmdW5jdGlvbiBleGVjdXRlIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYjQyYiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInR4dHB0ciswXzAwN2FcIik7ICAgIC8vIHNhdmUgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGI0MmQgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5kZXggdG8gaGlnaCBieXRlXHJcbi8qIGI0MmUgKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJkZWZwbnQrMF8wMDRlXCIpOyAgICAvLyBnZXQgZnVuY3Rpb24gZXhlY3V0ZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiNDMwICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwidHh0cHRyKzFfMDA3YlwiKTsgICAgLy8gc2F2ZSBCQVNJQyBleGVjdXRlIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGI0MzIgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ2YXJwbnQrMV8wMDQ4XCIpOyAgICAvLyBnZXQgY3VycmVudCB2YXJpYWJsZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiNDM0ICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggaXRcclxuLyogYjQzNSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInZhcnBudCswXzAwNDdcIik7ICAgIC8vIGdldCBjdXJyZW50IHZhcmlhYmxlIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYjQzNyAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdXNoIGl0XHJcbi8qIGI0MzggKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJmcm1udW1fYWQ4YVwiKTsgICAgICAvLyBldmFsdWF0ZSBleHByZXNzaW9uIGFuZCBjaGVjayBpcyBudW1lcmljLCBlbHNlIGRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHlwZSBtaXNtYXRjaFxyXG4vKiBiNDNiICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHB1bGwgdmFyaWFibGUgYWRkcmVzcyBsb3cgYnl0ZVxyXG4vKiBiNDNjICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZGVmcG50KzBfMDA0ZVwiKTsgICAgLy8gc2F2ZSB2YXJpYWJsZSBhZGRyZXNzIGxvdyBieXRlXHJcbi8qIGI0M2UgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVsbCB2YXJpYWJsZSBhZGRyZXNzIGhpZ2ggYnl0ZVxyXG4vKiBiNDNmICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZGVmcG50KzFfMDA0ZlwiKTsgICAgLy8gc2F2ZSB2YXJpYWJsZSBhZGRyZXNzIGhpZ2ggYnl0ZVxyXG4vKiBiNDQxICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiY2hyZ290XzAwNzlcIik7ICAgICAgLy8gc2NhbiBtZW1vcnlcclxuLyogYjQ0NCAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9iNDQ5XCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBudWxsIChzaG91bGQgYmUgW0VPTF0gbWFya2VyKVxyXG4vKiBiNDQ2ICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwic3luZXJyX2FmMDhcIik7ICAgICAgLy8gZWxzZSBzeW50YXggZXJyb3IgdGhlbiB3YXJtIHN0YXJ0XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHJlc3RvcmUgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGFuZCBmdW5jdGlvbiB2YXJpYWJsZSBmcm9tIHN0YWNrXHJcbi8qIGI0NDkgKi8gICAgICAgIF9gX2I0NDlgOyAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVsbCBCQVNJQyBleGVjdXRlIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYjQ0YSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInR4dHB0ciswXzAwN2FcIik7ICAgIC8vIHNhdmUgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGI0NGMgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVsbCBCQVNJQyBleGVjdXRlIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGI0NGQgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJ0eHRwdHIrMV8wMDdiXCIpOyAgICAvLyBzYXZlIEJBU0lDIGV4ZWN1dGUgcG9pbnRlciBoaWdoIGJ5dGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwdXQgZXhlY3V0ZSBwb2ludGVyIGFuZCB2YXJpYWJsZSBwb2ludGVyIGludG8gZnVuY3Rpb25cclxuLyogYjQ0ZiAqLyAgICAgICAgX2BfYjQ0ZmA7ICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBpbmRleFxyXG4vKiBiNDUxICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHB1bGwgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGI0NTIgKi8gICAgICAgICAgICAgICAgICAgU1RBLmlueSAoXCJkZWZwbnQrMF8wMDRlXCIpOyAgICAvLyBzYXZlIHRvIGZ1bmN0aW9uXHJcbi8qIGI0NTQgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVsbCBCQVNJQyBleGVjdXRlIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGI0NTUgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGluZGV4XHJcbi8qIGI0NTYgKi8gICAgICAgICAgICAgICAgICAgU1RBLmlueSAoXCJkZWZwbnQrMF8wMDRlXCIpOyAgICAvLyBzYXZlIHRvIGZ1bmN0aW9uXHJcbi8qIGI0NTggKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVsbCBjdXJyZW50IHZhcmlhYmxlIGFkZHJlc3MgbG93IGJ5dGVcclxuLyogYjQ1OSAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgaW5kZXhcclxuLyogYjQ1YSAqLyAgICAgICAgICAgICAgICAgICBTVEEuaW55IChcImRlZnBudCswXzAwNGVcIik7ICAgIC8vIHNhdmUgdG8gZnVuY3Rpb25cclxuLyogYjQ1YyAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdWxsIGN1cnJlbnQgdmFyaWFibGUgYWRkcmVzcyBoaWdoIGJ5dGVcclxuLyogYjQ1ZCAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgaW5kZXhcclxuLyogYjQ1ZSAqLyAgICAgICAgICAgICAgICAgICBTVEEuaW55IChcImRlZnBudCswXzAwNGVcIik7ICAgIC8vIHNhdmUgdG8gZnVuY3Rpb25cclxuLyogYjQ2MCAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdWxsID8/XHJcbi8qIGI0NjEgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGluZGV4XHJcbi8qIGI0NjIgKi8gICAgICAgICAgICAgICAgICAgU1RBLmlueSAoXCJkZWZwbnQrMF8wMDRlXCIpOyAgICAvLyBzYXZlIHRvIGZ1bmN0aW9uXHJcbi8qIGI0NjQgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcGVyZm9ybSBTVFIkKClcclxuLyogYjQ2NSAqLyAgICBfYHN0cmRfYjQ2NWA7ICBKU1IuYWJzIChcIl9hZDhkXCIpOyAgICAgICAgICAgIC8vIGNoZWNrIGlmIHNvdXJjZSBpcyBudW1lcmljLCBlbHNlIGRvIHR5cGUgbWlzbWF0Y2hcclxuLyogYjQ2OCAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBzZXQgc3RyaW5nIGluZGV4XHJcbi8qIGI0NmEgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfYmRkZlwiKTsgICAgICAgICAgICAvLyBjb252ZXJ0IEZBQzEgdG8gc3RyaW5nXHJcbi8qIGI0NmQgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZHVtcCByZXR1cm4gYWRkcmVzcyAoc2tpcCB0eXBlIGNoZWNrKVxyXG4vKiBiNDZlICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGR1bXAgcmV0dXJuIGFkZHJlc3MgKHNraXAgdHlwZSBjaGVjaylcclxuLyogYjQ2ZiAqLyAgICAgICAgX2BfYjQ2ZmA7ICBMREEuaW1tICgweGZmKTsgICAgICAgICAgICAgICAvLyBzZXQgcmVzdWx0IHN0cmluZyBsb3cgcG9pbnRlclxyXG4vKiBiNDcxICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIHNldCByZXN1bHQgc3RyaW5nIGhpZ2ggcG9pbnRlclxyXG4vKiBiNDczICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwic3RybGl0X2I0ODdcIik7ICAgICAgLy8gcHJpbnQgbnVsbCB0ZXJtaW5hdGVkIHN0cmluZyB0byB1dGlsaXR5IHBvaW50ZXJcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gZG8gc3RyaW5nIHZlY3RvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgZGVzY3JpcHRvciBwb2ludGVyIGFuZCBtYWtlIHN0cmluZyBzcGFjZSBBIGJ5dGVzIGxvbmdcclxuLyogYjQ3NSAqLyAgICAgICAgX2BfYjQ3NWA7ICBMRFguenBnIChcImZhY2hvKzJfMDA2NFwiKTsgICAgIC8vIGdldCBkZXNjcmlwdG9yIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYjQ3NyAqLyAgICAgICAgICAgICAgICAgICBMRFkuenBnIChcImZhY2hvKzNfMDA2NVwiKTsgICAgIC8vIGdldCBkZXNjcmlwdG9yIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGI0NzkgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJkc2NwbnQrMF8wMDUwXCIpOyAgICAvLyBzYXZlIGRlc2NyaXB0b3IgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiNDdiICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwiZHNjcG50KzFfMDA1MVwiKTsgICAgLy8gc2F2ZSBkZXNjcmlwdG9yIHBvaW50ZXIgaGlnaCBieXRlXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIG1ha2Ugc3RyaW5nIHNwYWNlIEEgYnl0ZXMgbG9uZ1xyXG4vKiBiNDdkICovICAgICAgICBfYF9iNDdkYDsgIEpTUi5hYnMgKFwiZ2V0c3BhX2I0ZjRcIik7ICAgICAgLy8gbWFrZSBzcGFjZSBpbiBzdHJpbmcgbWVtb3J5IGZvciBzdHJpbmcgQSBsb25nXHJcbi8qIGI0ODAgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJmYWNobyswXzAwNjJcIik7ICAgICAvLyBzYXZlIHN0cmluZyBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGI0ODIgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJmYWNobysxXzAwNjNcIik7ICAgICAvLyBzYXZlIHN0cmluZyBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiNDg0ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZmFjZXhwXzAwNjFcIik7ICAgICAgLy8gc2F2ZSBsZW5ndGhcclxuLyogYjQ4NiAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzY2FuLCBzZXQgdXAgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJpbnQgXCIgdGVybWluYXRlZCBzdHJpbmcgdG8gdXRpbGl0eSBwb2ludGVyXHJcbi8qIGI0ODcgKi8gIF9gc3RybGl0X2I0ODdgOyAgTERYLmltbSAoMHgyMik7ICAgICAgICAgICAgICAgLy8gc2V0IHRlcm1pbmF0b3IgdG8gXCJcclxuLyogYjQ4OSAqLyAgICAgICAgICAgICAgICAgICBTVFguenBnIChcImNoYXJhY18wMDA3XCIpOyAgICAgIC8vIHNldCBzZWFyY2ggY2hhcmFjdGVyLCB0ZXJtaW5hdG9yIDFcclxuLyogYjQ4YiAqLyAgICAgICAgICAgICAgICAgICBTVFguenBnIChcImVuZGNocl8wMDA4XCIpOyAgICAgIC8vIHNldCB0ZXJtaW5hdG9yIDJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcmludCBzZWFyY2ggb3IgYWx0ZXJuYXRlIHRlcm1pbmF0ZWQgc3RyaW5nIHRvIHV0aWxpdHkgcG9pbnRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvdXJjZSBpcyBBWVxyXG4vKiBiNDhkICovICAgICAgICBfYF9iNDhkYDsgIFNUQS56cGcgKFwiYXJpc2duXzAwNmZcIik7ICAgICAgLy8gc3RvcmUgc3RyaW5nIHN0YXJ0IGxvdyBieXRlXHJcbi8qIGI0OGYgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJmYWNvdl8wMDcwXCIpOyAgICAgICAvLyBzdG9yZSBzdHJpbmcgc3RhcnQgaGlnaCBieXRlXHJcbi8qIGI0OTEgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmYWNobyswXzAwNjJcIik7ICAgICAvLyBzYXZlIHN0cmluZyBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGI0OTMgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJmYWNobysxXzAwNjNcIik7ICAgICAvLyBzYXZlIHN0cmluZyBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiNDk1ICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4ZmYpOyAgICAgICAgICAgICAgIC8vIHNldCBsZW5ndGggdG8gLTFcclxuLyogYjQ5NyAqLyAgICAgICAgX2BfYjQ5N2A7ICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgbGVuZ3RoXHJcbi8qIGI0OTggKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJhcmlzZ25fMDA2ZlwiKTsgICAgICAvLyBnZXQgYnl0ZSBmcm9tIHN0cmluZ1xyXG4vKiBiNDlhICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2I0YThcIik7ICAgICAgICAgICAgLy8gZXhpdCBsb29wIGlmIG51bGwgYnl0ZSBbRU9TXVxyXG4vKiBiNDljICovICAgICAgICAgICAgICAgICAgIENNUC56cGcgKFwiY2hhcmFjXzAwMDdcIik7ICAgICAgLy8gY29tcGFyZSB3aXRoIHNlYXJjaCBjaGFyYWN0ZXIsIHRlcm1pbmF0b3IgMVxyXG4vKiBiNDllICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2I0YTRcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIHRlcm1pbmF0b3JcclxuLyogYjRhMCAqLyAgICAgICAgICAgICAgICAgICBDTVAuenBnIChcImVuZGNocl8wMDA4XCIpOyAgICAgIC8vIGNvbXBhcmUgd2l0aCB0ZXJtaW5hdG9yIDJcclxuLyogYjRhMiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9iNDk3XCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgbm90IHRlcm1pbmF0b3IgMlxyXG4vKiBiNGE0ICovICAgICAgICBfYF9iNGE0YDsgIENNUC5pbW0gKDB4MjIpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCBcIlxyXG4vKiBiNGE2ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2I0YTlcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIFwiIChjYXJyeSBzZXQgaWYgPSAhKVxyXG4vKiBiNGE4ICovICAgICAgICBfYF9iNGE4YDsgIENMQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIGNhcnJ5IGZvciBhZGQgKG9ubHkgaWYgW0VPTF0gdGVybWluYXRlZCBzdHJpbmcpXHJcbi8qIGI0YTkgKi8gICAgICAgIF9gX2I0YTlgOyAgU1RZLnpwZyAoXCJmYWNleHBfMDA2MVwiKTsgICAgICAvLyBzYXZlIGxlbmd0aCBpbiBGQUMxIGV4cG9uZW50XHJcbi8qIGI0YWIgKi8gICAgICAgICAgICAgICAgICAgVFlBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBsZW5ndGggdG8gQVxyXG4vKiBiNGFjICovICAgICAgICAgICAgICAgICAgIEFEQy56cGcgKFwiYXJpc2duXzAwNmZcIik7ICAgICAgLy8gYWRkIHN0cmluZyBzdGFydCBsb3cgYnl0ZVxyXG4vKiBiNGFlICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZmJ1ZnB0KzBfMDA3MVwiKTsgICAgLy8gc2F2ZSBzdHJpbmcgZW5kIGxvdyBieXRlXHJcbi8qIGI0YjAgKi8gICAgICAgICAgICAgICAgICAgTERYLnpwZyAoXCJmYWNvdl8wMDcwXCIpOyAgICAgICAvLyBnZXQgc3RyaW5nIHN0YXJ0IGhpZ2ggYnl0ZVxyXG4vKiBiNGIyICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2I0YjVcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vIGxvdyBieXRlIG92ZXJmbG93XHJcbi8qIGI0YjQgKi8gICAgICAgICAgICAgICAgICAgSU5YLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBpbmNyZW1lbnQgaGlnaCBieXRlXHJcbi8qIGI0YjUgKi8gICAgICAgIF9gX2I0YjVgOyAgU1RYLnpwZyAoXCJmYnVmcHQrMV8wMDcyXCIpOyAgICAvLyBzYXZlIHN0cmluZyBlbmQgaGlnaCBieXRlXHJcbi8qIGI0YjcgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJmYWNvdl8wMDcwXCIpOyAgICAgICAvLyBnZXQgc3RyaW5nIHN0YXJ0IGhpZ2ggYnl0ZVxyXG4vKiBiNGI5ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2I0YmZcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIGluIHV0aWxpdHkgYXJlYVxyXG4vKiBiNGJiICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4MDIpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCBpbnB1dCBidWZmZXIgbWVtb3J5IGhpZ2ggYnl0ZVxyXG4vKiBiNGJkICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2I0Y2FcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vdCBpbiBpbnB1dCBidWZmZXIgbWVtb3J5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5nIGluIGlucHV0IGJ1ZmZlciBvciB1dGlsaXR5IGFyZWEsIG1vdmUgdG8gc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWVtb3J5XHJcbi8qIGI0YmYgKi8gICAgICAgIF9gX2I0YmZgOyAgVFlBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBsZW5ndGggdG8gQVxyXG4vKiBiNGMwICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2I0NzVcIik7ICAgICAgICAgICAgLy8gY29weSBkZXNjcmlwdG9yIHBvaW50ZXIgYW5kIG1ha2Ugc3RyaW5nIHNwYWNlIEEgYnl0ZXMgbG9uZ1xyXG4vKiBiNGMzICovICAgICAgICAgICAgICAgICAgIExEWC56cGcgKFwiYXJpc2duXzAwNmZcIik7ICAgICAgLy8gZ2V0IHN0cmluZyBzdGFydCBsb3cgYnl0ZVxyXG4vKiBiNGM1ICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwiZmFjb3ZfMDA3MFwiKTsgICAgICAgLy8gZ2V0IHN0cmluZyBzdGFydCBoaWdoIGJ5dGVcclxuLyogYjRjNyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9iNjg4XCIpOyAgICAgICAgICAgIC8vIHN0b3JlIHN0cmluZyBBIGJ5dGVzIGxvbmcgZnJvbSBYWSB0byB1dGlsaXR5IHBvaW50ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3Igc3BhY2Ugb24gZGVzY3JpcHRvciBzdGFjayB0aGVuIC4uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHB1dCBzdHJpbmcgYWRkcmVzcyBhbmQgbGVuZ3RoIG9uIGRlc2NyaXB0b3Igc3RhY2sgYW5kIHVwZGF0ZSBzdGFjayBwb2ludGVyc1xyXG4vKiBiNGNhICovICAgICAgICBfYF9iNGNhYDsgIExEWC56cGcgKFwidGVtcHB0XzAwMTZcIik7ICAgICAgLy8gZ2V0IHRoZSBkZXNjcmlwdG9yIHN0YWNrIHBvaW50ZXJcclxuLyogYjRjYyAqLyAgICAgICAgICAgICAgICAgICBDUFguaW1tICgweDIyKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIGl0IHdpdGggdGhlIG1heGltdW0gKyAxXHJcbi8qIGI0Y2UgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJwdXRudzFfYjRkNVwiKTsgICAgICAvLyBpZiB0aGVyZSBpcyBzcGFjZSBvbiB0aGUgc3RyaW5nIHN0YWNrIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBkbyBzdHJpbmcgdG9vIGNvbXBsZXggZXJyb3JcclxuLyogYjRkMCAqLyAgICAgICAgICAgICAgICAgICBMRFguaW1tICgweDE5KTsgICAgICAgICAgICAgICAvLyBlcnJvciAkMTksIHN0cmluZyB0b28gY29tcGxleCBlcnJvclxyXG4vKiBiNGQyICovICAgICAgICBfYF9iNGQyYDsgIEpNUC5hYnMgKFwiZXJyb3JfYTQzN1wiKTsgICAgICAgLy8gZG8gZXJyb3IgI1ggdGhlbiB3YXJtIHN0YXJ0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHV0IHN0cmluZyBhZGRyZXNzIGFuZCBsZW5ndGggb24gZGVzY3JpcHRvciBzdGFjayBhbmQgdXBkYXRlIHN0YWNrIHBvaW50ZXJzXHJcbi8qIGI0ZDUgKi8gIF9gcHV0bncxX2I0ZDVgOyAgTERBLnpwZyAoXCJmYWNleHBfMDA2MVwiKTsgICAgICAvLyBnZXQgdGhlIHN0cmluZyBsZW5ndGhcclxuLyogYjRkNyAqLyAgICAgICAgICAgICAgICAgICBTVEEuenB4ICgweDAwKTsgICAgICAgICAgICAgICAvLyBwdXQgaXQgb24gdGhlIHN0cmluZyBzdGFja1xyXG4vKiBiNGQ5ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZmFjaG8rMF8wMDYyXCIpOyAgICAgLy8gZ2V0IHRoZSBzdHJpbmcgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiNGRiICovICAgICAgICAgICAgICAgICAgIFNUQS56cHggKDB4MDEpOyAgICAgICAgICAgICAgIC8vIHB1dCBpdCBvbiB0aGUgc3RyaW5nIHN0YWNrXHJcbi8qIGI0ZGQgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJmYWNobysxXzAwNjNcIik7ICAgICAvLyBnZXQgdGhlIHN0cmluZyBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiNGRmICovICAgICAgICAgICAgICAgICAgIFNUQS56cHggKDB4MDIpOyAgICAgICAgICAgICAgIC8vIHB1dCBpdCBvbiB0aGUgc3RyaW5nIHN0YWNrXHJcbi8qIGI0ZTEgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgWVxyXG4vKiBiNGUzICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwiZmFjaG8rMl8wMDY0XCIpOyAgICAgLy8gc2F2ZSB0aGUgc3RyaW5nIGRlc2NyaXB0b3IgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiNGU1ICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwiZmFjaG8rM18wMDY1XCIpOyAgICAgLy8gc2F2ZSB0aGUgc3RyaW5nIGRlc2NyaXB0b3IgcG9pbnRlciBoaWdoIGJ5dGUsIGFsd2F5cyAkMDBcclxuLyogYjRlNyAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcImZhY292XzAwNzBcIik7ICAgICAgIC8vIGNsZWFyIEZBQzEgcm91bmRpbmcgYnl0ZVxyXG4vKiBiNGU5ICovICAgICAgICAgICAgICAgICAgIERFWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIFkgPSAkRkZcclxuLyogYjRlYSAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcInZhbHR5cF8wMDBkXCIpOyAgICAgIC8vIHNhdmUgdGhlIGRhdGEgdHlwZSBmbGFnLCAkRkYgPSBzdHJpbmdcclxuLyogYjRlYyAqLyAgICAgICAgICAgICAgICAgICBTVFguenBnIChcImxhc3RwdCswXzAwMTdcIik7ICAgIC8vIHNhdmUgdGhlIGN1cnJlbnQgZGVzY3JpcHRvciBzdGFjayBpdGVtIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYjRlZSAqLyAgICAgICAgICAgICAgICAgICBJTlguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHN0YWNrIHBvaW50ZXJcclxuLyogYjRlZiAqLyAgICAgICAgICAgICAgICAgICBJTlguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHN0YWNrIHBvaW50ZXJcclxuLyogYjRmMCAqLyAgICAgICAgICAgICAgICAgICBJTlguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHN0YWNrIHBvaW50ZXJcclxuLyogYjRmMSAqLyAgICAgICAgICAgICAgICAgICBTVFguenBnIChcInRlbXBwdF8wMDE2XCIpOyAgICAgIC8vIHNhdmUgdGhlIG5ldyBkZXNjcmlwdG9yIHN0YWNrIHBvaW50ZXJcclxuLyogYjRmMyAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBtYWtlIHNwYWNlIGluIHN0cmluZyBtZW1vcnkgZm9yIHN0cmluZyBBIGxvbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gWCA9IHBvaW50ZXIgbG93IGJ5dGUsIFkgPSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiNGY0ICovICBfYGdldHNwYV9iNGY0YDsgIExTUi56cGcgKFwiZ2FyYmZsXzAwMGZcIik7ICAgICAgLy8gY2xlYXIgZ2FyYmFnZSBjb2xsZWN0ZWQgZmxhZyAoYjcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzcGFjZSBmb3Igc3RyaW5nIEEgbG9uZ1xyXG4vKiBiNGY2ICovICAgICAgICBfYF9iNGY2YDsgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgc3RyaW5nIGxlbmd0aFxyXG4vKiBiNGY3ICovICAgICAgICAgICAgICAgICAgIEVPUi5pbW0gKDB4ZmYpOyAgICAgICAgICAgICAgIC8vIGNvbXBsZW1lbnQgaXRcclxuLyogYjRmOSAqLyAgICAgICAgICAgICAgICAgICBTRUMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzZXQgY2FycnkgZm9yIHN1YnRyYWN0LCB0d28ncyBjb21wbGVtZW50IGFkZFxyXG4vKiBiNGZhICovICAgICAgICAgICAgICAgICAgIEFEQy56cGcgKFwiZnJldG9wKzBfMDAzM1wiKTsgICAgLy8gYWRkIGJvdHRvbSBvZiBzdHJpbmcgc3BhY2UgbG93IGJ5dGUsIHN1YnRyYWN0IGxlbmd0aFxyXG4vKiBiNGZjICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwiZnJldG9wKzFfMDAzNFwiKTsgICAgLy8gZ2V0IGJvdHRvbSBvZiBzdHJpbmcgc3BhY2UgaGlnaCBieXRlXHJcbi8qIGI0ZmUgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfYjUwMVwiKTsgICAgICAgICAgICAvLyBza2lwIGRlY3JlbWVudCBpZiBubyB1bmRlcmZsb3dcclxuLyogYjUwMCAqLyAgICAgICAgICAgICAgICAgICBERVkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBkZWNyZW1lbnQgYm90dG9tIG9mIHN0cmluZyBzcGFjZSBoaWdoIGJ5dGVcclxuLyogYjUwMSAqLyAgICAgICAgX2BfYjUwMWA7ICBDUFkuenBnIChcInN0cmVuZCsxXzAwMzJcIik7ICAgIC8vIGNvbXBhcmUgd2l0aCBlbmQgb2YgYXJyYXlzIGhpZ2ggYnl0ZVxyXG4vKiBiNTAzICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2I1MTZcIik7ICAgICAgICAgICAgLy8gZG8gb3V0IG9mIG1lbW9yeSBlcnJvciBpZiBsZXNzXHJcbi8qIGI1MDUgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYjUwYlwiKTsgICAgICAgICAgICAvLyBpZiBub3QgPSBza2lwIG5leHQgdGVzdFxyXG4vKiBiNTA3ICovICAgICAgICAgICAgICAgICAgIENNUC56cGcgKFwic3RyZW5kKzBfMDAzMVwiKTsgICAgLy8gY29tcGFyZSB3aXRoIGVuZCBvZiBhcnJheXMgbG93IGJ5dGVcclxuLyogYjUwOSAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9iNTE2XCIpOyAgICAgICAgICAgIC8vIGRvIG91dCBvZiBtZW1vcnkgZXJyb3IgaWYgbGVzc1xyXG4vKiBiNTBiICovICAgICAgICBfYF9iNTBiYDsgIFNUQS56cGcgKFwiZnJldG9wKzBfMDAzM1wiKTsgICAgLy8gc2F2ZSBib3R0b20gb2Ygc3RyaW5nIHNwYWNlIGxvdyBieXRlXHJcbi8qIGI1MGQgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJmcmV0b3ArMV8wMDM0XCIpOyAgICAvLyBzYXZlIGJvdHRvbSBvZiBzdHJpbmcgc3BhY2UgaGlnaCBieXRlXHJcbi8qIGI1MGYgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmcmVzcGMrMF8wMDM1XCIpOyAgICAvLyBzYXZlIHN0cmluZyB1dGlsaXR5IHB0ciBsb3cgYnl0ZVxyXG4vKiBiNTExICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwiZnJlc3BjKzFfMDAzNlwiKTsgICAgLy8gc2F2ZSBzdHJpbmcgdXRpbGl0eSBwdHIgaGlnaCBieXRlXHJcbi8qIGI1MTMgKi8gICAgICAgICAgICAgICAgICAgVEFYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBsb3cgYnl0ZSB0byBYXHJcbi8qIGI1MTQgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHN0cmluZyBsZW5ndGggYmFja1xyXG4vKiBiNTE1ICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcbi8qIGI1MTYgKi8gICAgICAgIF9gX2I1MTZgOyAgTERYLmltbSAoMHgxMCk7ICAgICAgICAgICAgICAgLy8gZXJyb3IgY29kZSAkMTAsIG91dCBvZiBtZW1vcnkgZXJyb3JcclxuLyogYjUxOCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImdhcmJmbF8wMDBmXCIpOyAgICAgIC8vIGdldCBnYXJiYWdlIGNvbGxlY3RlZCBmbGFnXHJcbi8qIGI1MWEgKi8gICAgICAgICAgICAgICAgICAgQk1JLnJlbCAoXCJfYjRkMlwiKTsgICAgICAgICAgICAvLyBpZiBzZXQgdGhlbiBkbyBlcnJvciBjb2RlIFhcclxuLyogYjUxYyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImdhcmJhZ19iNTI2XCIpOyAgICAgIC8vIGVsc2UgZ28gZG8gZ2FyYmFnZSBjb2xsZWN0aW9uXHJcbi8qIGI1MWYgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHg4MCk7ICAgICAgICAgICAgICAgLy8gZmxhZyBmb3IgZ2FyYmFnZSBjb2xsZWN0ZWRcclxuLyogYjUyMSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImdhcmJmbF8wMDBmXCIpOyAgICAgIC8vIHNldCBnYXJiYWdlIGNvbGxlY3RlZCBmbGFnXHJcbi8qIGI1MjMgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVsbCBsZW5ndGhcclxuLyogYjUyNCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9iNGY2XCIpOyAgICAgICAgICAgIC8vIGdvIHRyeSBhZ2FpbiAobG9vcCBhbHdheXMsIGxlbmd0aCBzaG91bGQgbmV2ZXIgYmUgPSAkMDApXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGdhcmJhZ2UgY29sbGVjdGlvbiByb3V0aW5lXHJcbi8qIGI1MjYgKi8gIF9gZ2FyYmFnX2I1MjZgOyAgTERYLnpwZyAoXCJtZW1zaXorMF8wMDM3XCIpOyAgICAvLyBnZXQgZW5kIG9mIG1lbW9yeSBsb3cgYnl0ZVxyXG4vKiBiNTI4ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwibWVtc2l6KzFfMDAzOFwiKTsgICAgLy8gZ2V0IGVuZCBvZiBtZW1vcnkgaGlnaCBieXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmUtcnVuIHJvdXRpbmUgZnJvbSBsYXN0IGVuZGluZ1xyXG4vKiBiNTJhICovICAgICAgICBfYF9iNTJhYDsgIFNUWC56cGcgKFwiZnJldG9wKzBfMDAzM1wiKTsgICAgLy8gc2V0IGJvdHRvbSBvZiBzdHJpbmcgc3BhY2UgbG93IGJ5dGVcclxuLyogYjUyYyAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZyZXRvcCsxXzAwMzRcIik7ICAgIC8vIHNldCBib3R0b20gb2Ygc3RyaW5nIHNwYWNlIGhpZ2ggYnl0ZVxyXG4vKiBiNTJlICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIGluZGV4XHJcbi8qIGI1MzAgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJkZWZwbnQrMV8wMDRmXCIpOyAgICAvLyBjbGVhciB3b3JraW5nIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGI1MzIgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJkZWZwbnQrMF8wMDRlXCIpOyAgICAvLyBjbGVhciB3b3JraW5nIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYjUzNCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInN0cmVuZCswXzAwMzFcIik7ICAgIC8vIGdldCBlbmQgb2YgYXJyYXlzIGxvdyBieXRlXHJcbi8qIGI1MzYgKi8gICAgICAgICAgICAgICAgICAgTERYLnpwZyAoXCJzdHJlbmQrMV8wMDMyXCIpOyAgICAvLyBnZXQgZW5kIG9mIGFycmF5cyBoaWdoIGJ5dGVcclxuLyogYjUzOCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInRlbXBmMiszXzAwNWZcIik7ICAgIC8vIHNhdmUgYXMgaGlnaGVzdCB1bmNvbGxlY3RlZCBzdHJpbmcgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiNTNhICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwidGVtcGYyKzRfMDA2MFwiKTsgICAgLy8gc2F2ZSBhcyBoaWdoZXN0IHVuY29sbGVjdGVkIHN0cmluZyBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiNTNjICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MTkpOyAgICAgICAgICAgICAgIC8vIHNldCBkZXNjcmlwdG9yIHN0YWNrIHBvaW50ZXJcclxuLyogYjUzZSAqLyAgICAgICAgICAgICAgICAgICBMRFguaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBYXHJcbi8qIGI1NDAgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJpbmRleCswXzAwMjJcIik7ICAgICAvLyBzYXZlIGRlc2NyaXB0b3Igc3RhY2sgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiNTQyICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwiaW5kZXgrMV8wMDIzXCIpOyAgICAgLy8gc2F2ZSBkZXNjcmlwdG9yIHN0YWNrIHBvaW50ZXIgaGlnaCBieXRlICgkMDApXHJcbi8qIGI1NDQgKi8gICAgICAgIF9gX2I1NDRgOyAgQ01QLnpwZyAoXCJ0ZW1wcHRfMDAxNlwiKTsgICAgICAvLyBjb21wYXJlIHdpdGggZGVzY3JpcHRvciBzdGFjayBwb2ludGVyXHJcbi8qIGI1NDYgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYjU0ZFwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgPVxyXG4vKiBiNTQ4ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2I1YzdcIik7ICAgICAgICAgICAgLy8gY2hlY2sgc3RyaW5nIHNhbHZhZ2VhYmlsaXR5XHJcbi8qIGI1NGIgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYjU0NFwiKTsgICAgICAgICAgICAvLyBsb29wIGFsd2F5c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbmUgc3RhY2tlZCBzdHJpbmdzLCBub3cgZG8gc3RyaW5nIHZhcmlhYmxlc1xyXG4vKiBiNTRkICovICAgICAgICBfYF9iNTRkYDsgIExEQS5pbW0gKDB4MDcpOyAgICAgICAgICAgICAgIC8vIHNldCBzdGVwIHNpemUgPSAkMDcsIGNvbGxlY3RpbmcgdmFyaWFibGVzXHJcbi8qIGI1NGYgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmb3VyNl8wMDUzXCIpOyAgICAgICAvLyBzYXZlIGdhcmJhZ2UgY29sbGVjdGlvbiBzdGVwIHNpemVcclxuLyogYjU1MSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInZhcnRhYiswXzAwMmRcIik7ICAgIC8vIGdldCBzdGFydCBvZiB2YXJpYWJsZXMgbG93IGJ5dGVcclxuLyogYjU1MyAqLyAgICAgICAgICAgICAgICAgICBMRFguenBnIChcInZhcnRhYisxXzAwMmVcIik7ICAgIC8vIGdldCBzdGFydCBvZiB2YXJpYWJsZXMgaGlnaCBieXRlXHJcbi8qIGI1NTUgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJpbmRleCswXzAwMjJcIik7ICAgICAvLyBzYXZlIGFzIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYjU1NyAqLyAgICAgICAgICAgICAgICAgICBTVFguenBnIChcImluZGV4KzFfMDAyM1wiKTsgICAgIC8vIHNhdmUgYXMgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYjU1OSAqLyAgICAgICAgX2BfYjU1OWA7ICBDUFguenBnIChcImFyeXRhYisxXzAwMzBcIik7ICAgIC8vIGNvbXBhcmUgZW5kIG9mIHZhcmlhYmxlcyBoaWdoIGJ5dGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnQgb2YgYXJyYXlzIGhpZ2ggYnl0ZVxyXG4vKiBiNTViICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2I1NjFcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vIGhpZ2ggYnl0ZSBtYXRjaFxyXG4vKiBiNTVkICovICAgICAgICAgICAgICAgICAgIENNUC56cGcgKFwiYXJ5dGFiKzBfMDAyZlwiKTsgICAgLy8gZWxzZSBjb21wYXJlIGVuZCBvZiB2YXJpYWJsZXMgbG93IGJ5dGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnQgb2YgYXJyYXlzIGxvdyBieXRlXHJcbi8qIGI1NWYgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYjU2NlwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgPSB2YXJpYWJsZSBtZW1vcnkgZW5kXHJcbi8qIGI1NjEgKi8gICAgICAgIF9gX2I1NjFgOyAgSlNSLmFicyAoXCJkdmFyc19iNWJkXCIpOyAgICAgICAvLyBjaGVjayB2YXJpYWJsZSBzYWx2YWdlYWJpbGl0eVxyXG4vKiBiNTY0ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2I1NTlcIik7ICAgICAgICAgICAgLy8gbG9vcCBhbHdheXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkb25lIHN0cmluZyB2YXJpYWJsZXMsIG5vdyBkbyBzdHJpbmcgYXJyYXlzXHJcbi8qIGI1NjYgKi8gICAgICAgIF9gX2I1NjZgOyAgU1RBLnpwZyAoXCJ0ZW1wZjErMV8wMDU4XCIpOyAgICAvLyBzYXZlIHN0YXJ0IG9mIGFycmF5cyBsb3cgYnl0ZSBhcyB3b3JraW5nIHBvaW50ZXJcclxuLyogYjU2OCAqLyAgICAgICAgICAgICAgICAgICBTVFguenBnIChcInRlbXBmMSsyXzAwNTlcIik7ICAgIC8vIHNhdmUgc3RhcnQgb2YgYXJyYXlzIGhpZ2ggYnl0ZSBhcyB3b3JraW5nIHBvaW50ZXJcclxuLyogYjU2YSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDAzKTsgICAgICAgICAgICAgICAvLyBzZXQgc3RlcCBzaXplLCBjb2xsZWN0aW5nIGRlc2NyaXB0b3JzXHJcbi8qIGI1NmMgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmb3VyNl8wMDUzXCIpOyAgICAgICAvLyBzYXZlIHN0ZXAgc2l6ZVxyXG4vKiBiNTZlICovICAgICAgICBfYF9iNTZlYDsgIExEQS56cGcgKFwidGVtcGYxKzFfMDA1OFwiKTsgICAgLy8gZ2V0IHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYjU3MCAqLyAgICAgICAgICAgICAgICAgICBMRFguenBnIChcInRlbXBmMSsyXzAwNTlcIik7ICAgIC8vIGdldCBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiNTcyICovICAgICAgICBfYF9iNTcyYDsgIENQWC56cGcgKFwic3RyZW5kKzFfMDAzMlwiKTsgICAgLy8gY29tcGFyZSB3aXRoIGVuZCBvZiBhcnJheXMgaGlnaCBieXRlXHJcbi8qIGI1NzQgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYjU3ZFwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbm90IGF0IGVuZFxyXG4vKiBiNTc2ICovICAgICAgICAgICAgICAgICAgIENNUC56cGcgKFwic3RyZW5kKzBfMDAzMVwiKTsgICAgLy8gZWxzZSBjb21wYXJlIHdpdGggZW5kIG9mIGFycmF5cyBsb3cgYnl0ZVxyXG4vKiBiNTc4ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2I1N2RcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vdCBhdCBlbmRcclxuLyogYjU3YSAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcImdyYnBhc19iNjA2XCIpOyAgICAgIC8vIGNvbGxlY3Qgc3RyaW5nLCB0aWR5IHVwIGFuZCBleGl0IGlmIGF0IGVuZCA/P1xyXG4vKiBiNTdkICovICAgICAgICBfYF9iNTdkYDsgIFNUQS56cGcgKFwiaW5kZXgrMF8wMDIyXCIpOyAgICAgLy8gc2F2ZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGI1N2YgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJpbmRleCsxXzAwMjNcIik7ICAgICAvLyBzYXZlIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGI1ODEgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gc2V0IGluZGV4XHJcbi8qIGI1ODMgKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJpbmRleCswXzAwMjJcIik7ICAgICAvLyBnZXQgYXJyYXkgbmFtZSBmaXJzdCBieXRlXHJcbi8qIGI1ODUgKi8gICAgICAgICAgICAgICAgICAgVEFYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBpdFxyXG4vKiBiNTg2ICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBpbmRleFxyXG4vKiBiNTg3ICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwiaW5kZXgrMF8wMDIyXCIpOyAgICAgLy8gZ2V0IGFycmF5IG5hbWUgc2Vjb25kIGJ5dGVcclxuLyogYjU4OSAqLyAgICAgICAgICAgICAgICAgICBQSFAuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdXNoIHRoZSBmbGFnc1xyXG4vKiBiNThhICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBpbmRleFxyXG4vKiBiNThiICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwiaW5kZXgrMF8wMDIyXCIpOyAgICAgLy8gZ2V0IGFycmF5IHNpemUgbG93IGJ5dGVcclxuLyogYjU4ZCAqLyAgICAgICAgICAgICAgICAgICBBREMuenBnIChcInRlbXBmMSsxXzAwNThcIik7ICAgIC8vIGFkZCBzdGFydCBvZiB0aGlzIGFycmF5IGxvdyBieXRlXHJcbi8qIGI1OGYgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJ0ZW1wZjErMV8wMDU4XCIpOyAgICAvLyBzYXZlIHN0YXJ0IG9mIG5leHQgYXJyYXkgbG93IGJ5dGVcclxuLyogYjU5MSAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgaW5kZXhcclxuLyogYjU5MiAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcImluZGV4KzBfMDAyMlwiKTsgICAgIC8vIGdldCBhcnJheSBzaXplIGhpZ2ggYnl0ZVxyXG4vKiBiNTk0ICovICAgICAgICAgICAgICAgICAgIEFEQy56cGcgKFwidGVtcGYxKzJfMDA1OVwiKTsgICAgLy8gYWRkIHN0YXJ0IG9mIHRoaXMgYXJyYXkgaGlnaCBieXRlXHJcbi8qIGI1OTYgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJ0ZW1wZjErMl8wMDU5XCIpOyAgICAvLyBzYXZlIHN0YXJ0IG9mIG5leHQgYXJyYXkgaGlnaCBieXRlXHJcbi8qIGI1OTggKi8gICAgICAgICAgICAgICAgICAgUExQLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSB0aGUgZmxhZ3NcclxuLyogYjU5OSAqLyAgICAgICAgICAgICAgICAgICBCUEwucmVsIChcIl9iNTZlXCIpOyAgICAgICAgICAgIC8vIHNraXAgaWYgbm90IHN0cmluZyBhcnJheVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdhcyBwb3NzaWJseSBzdHJpbmcgYXJyYXkgc28gLi4uXHJcbi8qIGI1OWIgKi8gICAgICAgICAgICAgICAgICAgVFhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZ2V0IG5hbWUgZmlyc3QgYnl0ZSBiYWNrXHJcbi8qIGI1OWMgKi8gICAgICAgICAgICAgICAgICAgQk1JLnJlbCAoXCJfYjU2ZVwiKTsgICAgICAgICAgICAvLyBza2lwIGlmIG5vdCBzdHJpbmcgYXJyYXlcclxuLyogYjU5ZSAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgaW5kZXhcclxuLyogYjU5ZiAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcImluZGV4KzBfMDAyMlwiKTsgICAgIC8vIGdldCAjIG9mIGRpbWVuc2lvbnNcclxuLyogYjVhMSAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBpbmRleFxyXG4vKiBiNWEzICovICAgICAgICAgICAgICAgICAgIEFTTC5hY2MgKCk7ICAgICAgICAgICAgICAgICAgIC8vICoyXHJcbi8qIGI1YTQgKi8gICAgICAgICAgICAgICAgICAgQURDLmltbSAoMHgwNSk7ICAgICAgICAgICAgICAgLy8gKzUgKGFycmF5IGhlYWRlciBzaXplKVxyXG4vKiBiNWE2ICovICAgICAgICAgICAgICAgICAgIEFEQy56cGcgKFwiaW5kZXgrMF8wMDIyXCIpOyAgICAgLy8gYWRkIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYjVhOCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImluZGV4KzBfMDAyMlwiKTsgICAgIC8vIHNhdmUgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiNWFhICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2I1YWVcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vIHJvbGxvdmVyXHJcbi8qIGI1YWMgKi8gICAgICAgICAgICAgICAgICAgSU5DLnpwZyAoXCJpbmRleCsxXzAwMjNcIik7ICAgICAvLyBlbHNlIGluY3JlbWVudCBwb2ludGVyIGhnaWggYnl0ZVxyXG4vKiBiNWFlICovICAgICAgICBfYF9iNWFlYDsgIExEWC56cGcgKFwiaW5kZXgrMV8wMDIzXCIpOyAgICAgLy8gZ2V0IHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGI1YjAgKi8gICAgICAgIF9gX2I1YjBgOyAgQ1BYLnpwZyAoXCJ0ZW1wZjErMl8wMDU5XCIpOyAgICAvLyBjb21wYXJlIHBvaW50ZXIgaGlnaCBieXRlIHdpdGggZW5kIG9mIHRoaXMgYXJyYXkgaGlnaCBieXRlXHJcbi8qIGI1YjIgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYjViOFwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbm90IHRoZXJlIHlldFxyXG4vKiBiNWI0ICovICAgICAgICAgICAgICAgICAgIENNUC56cGcgKFwidGVtcGYxKzFfMDA1OFwiKTsgICAgLy8gY29tcGFyZSBwb2ludGVyIGxvdyBieXRlIHdpdGggZW5kIG9mIHRoaXMgYXJyYXkgbG93IGJ5dGVcclxuLyogYjViNiAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9iNTcyXCIpOyAgICAgICAgICAgIC8vIGlmIGF0IGVuZCBvZiB0aGlzIGFycmF5IGdvIGNoZWNrIG5leHQgYXJyYXlcclxuLyogYjViOCAqLyAgICAgICAgX2BfYjViOGA7ICBKU1IuYWJzIChcIl9iNWM3XCIpOyAgICAgICAgICAgIC8vIGNoZWNrIHN0cmluZyBzYWx2YWdlYWJpbGl0eVxyXG4vKiBiNWJiICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2I1YjBcIik7ICAgICAgICAgICAgLy8gbG9vcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHZhcmlhYmxlIHNhbHZhZ2VhYmlsaXR5XHJcbi8qIGI1YmQgKi8gICBfYGR2YXJzX2I1YmRgOyAgTERBLmlueSAoXCJpbmRleCswXzAwMjJcIik7ICAgICAvLyBnZXQgdmFyaWFibGUgbmFtZSBmaXJzdCBieXRlXHJcbi8qIGI1YmYgKi8gICAgICAgICAgICAgICAgICAgQk1JLnJlbCAoXCJfYjVmNlwiKTsgICAgICAgICAgICAvLyBhZGQgc3RlcCBhbmQgZXhpdCBpZiBub3Qgc3RyaW5nXHJcbi8qIGI1YzEgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGluZGV4XHJcbi8qIGI1YzIgKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJpbmRleCswXzAwMjJcIik7ICAgICAvLyBnZXQgdmFyaWFibGUgbmFtZSBzZWNvbmQgYnl0ZVxyXG4vKiBiNWM0ICovICAgICAgICAgICAgICAgICAgIEJQTC5yZWwgKFwiX2I1ZjZcIik7ICAgICAgICAgICAgLy8gYWRkIHN0ZXAgYW5kIGV4aXQgaWYgbm90IHN0cmluZ1xyXG4vKiBiNWM2ICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBpbmRleFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHN0cmluZyBzYWx2YWdlYWJpbGl0eVxyXG4vKiBiNWM3ICovICAgICAgICBfYF9iNWM3YDsgIExEQS5pbnkgKFwiaW5kZXgrMF8wMDIyXCIpOyAgICAgLy8gZ2V0IHN0cmluZyBsZW5ndGhcclxuLyogYjVjOSAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9iNWY2XCIpOyAgICAgICAgICAgIC8vIGFkZCBzdGVwIGFuZCBleGl0IGlmIG51bGwgc3RyaW5nXHJcbi8qIGI1Y2IgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGluZGV4XHJcbi8qIGI1Y2MgKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJpbmRleCswXzAwMjJcIik7ICAgICAvLyBnZXQgc3RyaW5nIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYjVjZSAqLyAgICAgICAgICAgICAgICAgICBUQVguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IHRvIFhcclxuLyogYjVjZiAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgaW5kZXhcclxuLyogYjVkMCAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcImluZGV4KzBfMDAyMlwiKTsgICAgIC8vIGdldCBzdHJpbmcgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYjVkMiAqLyAgICAgICAgICAgICAgICAgICBDTVAuenBnIChcImZyZXRvcCsxXzAwMzRcIik7ICAgIC8vIGNvbXBhcmUgc3RyaW5nIHBvaW50ZXIgaGlnaCBieXRlIHdpdGggYm90dG9tIG9mIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwYWNlIGhpZ2ggYnl0ZVxyXG4vKiBiNWQ0ICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2I1ZGNcIik7ICAgICAgICAgICAgLy8gaWYgYm90dG9tIG9mIHN0cmluZyBzcGFjZSBncmVhdGVyIGdvIHRlc3QgYWdhaW5zdCBoaWdoZXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW5jb2xsZWN0ZWQgc3RyaW5nXHJcbi8qIGI1ZDYgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYjVmNlwiKTsgICAgICAgICAgICAvLyBpZiBib3R0b20gb2Ygc3RyaW5nIHNwYWNlIGxlc3Mgc3RyaW5nIGhhcyBiZWVuIGNvbGxlY3RlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIGdvIHVwZGF0ZSBwb2ludGVycywgc3RlcCB0byBuZXh0IGFuZCByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoaWdoIGJ5dGVzIHdlcmUgZXF1YWwgc28gdGVzdCBsb3cgYnl0ZXNcclxuLyogYjVkOCAqLyAgICAgICAgICAgICAgICAgICBDUFguenBnIChcImZyZXRvcCswXzAwMzNcIik7ICAgIC8vIGNvbXBhcmUgc3RyaW5nIHBvaW50ZXIgbG93IGJ5dGUgd2l0aCBib3R0b20gb2Ygc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BhY2UgbG93IGJ5dGVcclxuLyogYjVkYSAqLyAgICAgICAgICAgICAgICAgICBCQ1MucmVsIChcIl9iNWY2XCIpOyAgICAgICAgICAgIC8vIGlmIGJvdHRvbSBvZiBzdHJpbmcgc3BhY2UgbGVzcyBzdHJpbmcgaGFzIGJlZW4gY29sbGVjdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gZ28gdXBkYXRlIHBvaW50ZXJzLCBzdGVwIHRvIG5leHQgYW5kIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgdGVzdCBzdHJpbmcgYWdhaW5zdCBoaWdoZXN0IHVuY29sbGVjdGVkIHN0cmluZyBzbyBmYXJcclxuLyogYjVkYyAqLyAgICAgICAgX2BfYjVkY2A7ICBDTVAuenBnIChcInRlbXBmMis0XzAwNjBcIik7ICAgIC8vIGNvbXBhcmUgc3RyaW5nIHBvaW50ZXIgaGlnaCBieXRlIHdpdGggaGlnaGVzdCB1bmNvbGxlY3RlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZyBoaWdoIGJ5dGVcclxuLyogYjVkZSAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9iNWY2XCIpOyAgICAgICAgICAgIC8vIGlmIGhpZ2hlc3QgdW5jb2xsZWN0ZWQgc3RyaW5nIGlzIGdyZWF0ZXIgdGhlbiBnbyB1cGRhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludGVycywgc3RlcCB0byBuZXh0IGFuZCByZXR1cm5cclxuLyogYjVlMCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9iNWU2XCIpOyAgICAgICAgICAgIC8vIGlmIGhpZ2hlc3QgdW5jb2xsZWN0ZWQgc3RyaW5nIGlzIGxlc3MgdGhlbiBnbyBzZXQgdGhpc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZyBhcyBoaWdoZXN0IHVuY29sbGVjdGVkIHNvIGZhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhpZ2ggYnl0ZXMgd2VyZSBlcXVhbCBzbyB0ZXN0IGxvdyBieXRlc1xyXG4vKiBiNWUyICovICAgICAgICAgICAgICAgICAgIENQWC56cGcgKFwidGVtcGYyKzNfMDA1ZlwiKTsgICAgLy8gY29tcGFyZSBzdHJpbmcgcG9pbnRlciBsb3cgYnl0ZSB3aXRoIGhpZ2hlc3QgdW5jb2xsZWN0ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJpbmcgbG93IGJ5dGVcclxuLyogYjVlNCAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9iNWY2XCIpOyAgICAgICAgICAgIC8vIGlmIGhpZ2hlc3QgdW5jb2xsZWN0ZWQgc3RyaW5nIGlzIGdyZWF0ZXIgdGhlbiBnbyB1cGRhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludGVycywgc3RlcCB0byBuZXh0IGFuZCByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIHNldCBjdXJyZW50IHN0cmluZyBhcyBoaWdoZXN0IHVuY29sbGVjdGVkIHN0cmluZ1xyXG4vKiBiNWU2ICovICAgICAgICBfYF9iNWU2YDsgIFNUWC56cGcgKFwidGVtcGYyKzNfMDA1ZlwiKTsgICAgLy8gc2F2ZSBzdHJpbmcgcG9pbnRlciBsb3cgYnl0ZSBhcyBoaWdoZXN0IHVuY29sbGVjdGVkIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvdyBieXRlXHJcbi8qIGI1ZTggKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJ0ZW1wZjIrNF8wMDYwXCIpOyAgICAvLyBzYXZlIHN0cmluZyBwb2ludGVyIGhpZ2ggYnl0ZSBhcyBoaWdoZXN0IHVuY29sbGVjdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5nIGhpZ2ggYnl0ZVxyXG4vKiBiNWVhICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiaW5kZXgrMF8wMDIyXCIpOyAgICAgLy8gZ2V0IGRlc2NyaXB0b3IgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiNWVjICovICAgICAgICAgICAgICAgICAgIExEWC56cGcgKFwiaW5kZXgrMV8wMDIzXCIpOyAgICAgLy8gZ2V0IGRlc2NyaXB0b3IgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYjVlZSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImRlZnBudCswXzAwNGVcIik7ICAgIC8vIHNhdmUgd29ya2luZyBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiNWYwICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwiZGVmcG50KzFfMDA0ZlwiKTsgICAgLy8gc2F2ZSB3b3JraW5nIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYjVmMiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZvdXI2XzAwNTNcIik7ICAgICAgIC8vIGdldCBzdGVwIHNpemVcclxuLyogYjVmNCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImptcGVyKzFfMDA1NVwiKTsgICAgIC8vIGNvcHkgc3RlcCBzaXplXHJcbi8qIGI1ZjYgKi8gICAgICAgIF9gX2I1ZjZgOyAgTERBLnpwZyAoXCJmb3VyNl8wMDUzXCIpOyAgICAgICAvLyBnZXQgc3RlcCBzaXplXHJcbi8qIGI1ZjggKi8gICAgICAgICAgICAgICAgICAgQ0xDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgY2FycnkgZm9yIGFkZFxyXG4vKiBiNWY5ICovICAgICAgICAgICAgICAgICAgIEFEQy56cGcgKFwiaW5kZXgrMF8wMDIyXCIpOyAgICAgLy8gYWRkIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYjVmYiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImluZGV4KzBfMDAyMlwiKTsgICAgIC8vIHNhdmUgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiNWZkICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2I2MDFcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vIHJvbGxvdmVyXHJcbi8qIGI1ZmYgKi8gICAgICAgICAgICAgICAgICAgSU5DLnpwZyAoXCJpbmRleCsxXzAwMjNcIik7ICAgICAvLyBlbHNlIGluY3JlbWVudCBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiNjAxICovICAgICAgICBfYF9iNjAxYDsgIExEWC56cGcgKFwiaW5kZXgrMV8wMDIzXCIpOyAgICAgLy8gZ2V0IHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGI2MDMgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gZmxhZyBub3QgbW92ZWRcclxuLyogYjYwNSAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbGxlY3Qgc3RyaW5nXHJcbi8qIGI2MDYgKi8gIF9gZ3JicGFzX2I2MDZgOyAgTERBLnpwZyAoXCJkZWZwbnQrMV8wMDRmXCIpOyAgICAvLyBnZXQgd29ya2luZyBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGI2MDggKi8gICAgICAgICAgICAgICAgICAgT1JBLnpwZyAoXCJkZWZwbnQrMF8wMDRlXCIpOyAgICAvLyBPUiB3b3JraW5nIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGI2MGEgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYjYwMVwiKTsgICAgICAgICAgICAvLyBleGl0IGlmIG5vdGhpbmcgdG8gY29sbGVjdFxyXG4vKiBiNjBjICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiam1wZXIrMV8wMDU1XCIpOyAgICAgLy8gZ2V0IGNvcGllZCBzdGVwIHNpemVcclxuLyogYjYwZSAqLyAgICAgICAgICAgICAgICAgICBBTkQuaW1tICgweDA0KTsgICAgICAgICAgICAgICAvLyBtYXNrIHN0ZXAgc2l6ZSwgJDA0IGZvciB2YXJpYWJsZXMsICQwMCBmb3IgYXJyYXkgb3Igc3RhY2tcclxuLyogYjYxMCAqLyAgICAgICAgICAgICAgICAgICBMU1IuYWNjICgpOyAgICAgICAgICAgICAgICAgICAvLyA+PiAxXHJcbi8qIGI2MTEgKi8gICAgICAgICAgICAgICAgICAgVEFZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSB0byBpbmRleFxyXG4vKiBiNjEyICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiam1wZXIrMV8wMDU1XCIpOyAgICAgLy8gc2F2ZSBvZmZzZXQgdG8gZGVzY3JpcHRvciBzdGFydFxyXG4vKiBiNjE0ICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwiZGVmcG50KzBfMDA0ZVwiKTsgICAgLy8gZ2V0IHN0cmluZyBsZW5ndGggbG93IGJ5dGVcclxuLyogYjYxNiAqLyAgICAgICAgICAgICAgICAgICBBREMuenBnIChcInRlbXBmMiszXzAwNWZcIik7ICAgIC8vIGFkZCBzdHJpbmcgc3RhcnQgbG93IGJ5dGVcclxuLyogYjYxOCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInRlbXBmMSszXzAwNWFcIik7ICAgIC8vIHNldCBibG9jayBlbmQgbG93IGJ5dGVcclxuLyogYjYxYSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInRlbXBmMis0XzAwNjBcIik7ICAgIC8vIGdldCBzdHJpbmcgc3RhcnQgaGlnaCBieXRlXHJcbi8qIGI2MWMgKi8gICAgICAgICAgICAgICAgICAgQURDLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gYWRkIGNhcnJ5XHJcbi8qIGI2MWUgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJ0ZW1wZjErNF8wMDViXCIpOyAgICAvLyBzZXQgYmxvY2sgZW5kIGhpZ2ggYnl0ZVxyXG4vKiBiNjIwICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZnJldG9wKzBfMDAzM1wiKTsgICAgLy8gZ2V0IGJvdHRvbSBvZiBzdHJpbmcgc3BhY2UgbG93IGJ5dGVcclxuLyogYjYyMiAqLyAgICAgICAgICAgICAgICAgICBMRFguenBnIChcImZyZXRvcCsxXzAwMzRcIik7ICAgIC8vIGdldCBib3R0b20gb2Ygc3RyaW5nIHNwYWNlIGhpZ2ggYnl0ZVxyXG4vKiBiNjI0ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwidGVtcGYxKzFfMDA1OFwiKTsgICAgLy8gc2F2ZSBkZXN0aW5hdGlvbiBlbmQgbG93IGJ5dGVcclxuLyogYjYyNiAqLyAgICAgICAgICAgICAgICAgICBTVFguenBnIChcInRlbXBmMSsyXzAwNTlcIik7ICAgIC8vIHNhdmUgZGVzdGluYXRpb24gZW5kIGhpZ2ggYnl0ZVxyXG4vKiBiNjI4ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2EzYmZcIik7ICAgICAgICAgICAgLy8gb3BlbiB1cCBzcGFjZSBpbiBtZW1vcnksIGRvbid0IHNldCBhcnJheSBlbmQuIHRoaXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb3BpZXMgdGhlIHN0cmluZyBmcm9tIHdoZXJlIGl0IGlzIHRvIHRoZSBlbmQgb2YgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW5jb2xsZWN0ZWQgc3RyaW5nIG1lbW9yeVxyXG4vKiBiNjJiICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwiam1wZXIrMV8wMDU1XCIpOyAgICAgLy8gcmVzdG9yZSBvZmZzZXQgdG8gZGVzY3JpcHRvciBzdGFydFxyXG4vKiBiNjJkICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBpbmRleCB0byBzdHJpbmcgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiNjJlICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwidGVtcGYxKzFfMDA1OFwiKTsgICAgLy8gZ2V0IG5ldyBzdHJpbmcgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiNjMwICovICAgICAgICAgICAgICAgICAgIFNUQS5pbnkgKFwiZGVmcG50KzBfMDA0ZVwiKTsgICAgLy8gc2F2ZSBuZXcgc3RyaW5nIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYjYzMiAqLyAgICAgICAgICAgICAgICAgICBUQVguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IHN0cmluZyBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGI2MzMgKi8gICAgICAgICAgICAgICAgICAgSU5DLnpwZyAoXCJ0ZW1wZjErMl8wMDU5XCIpOyAgICAvLyBpbmNyZW1lbnQgbmV3IHN0cmluZyBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiNjM1ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwidGVtcGYxKzJfMDA1OVwiKTsgICAgLy8gZ2V0IG5ldyBzdHJpbmcgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYjYzNyAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgaW5kZXggdG8gc3RyaW5nIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGI2MzggKi8gICAgICAgICAgICAgICAgICAgU1RBLmlueSAoXCJkZWZwbnQrMF8wMDRlXCIpOyAgICAvLyBzYXZlIG5ldyBzdHJpbmcgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYjYzYSAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9iNTJhXCIpOyAgICAgICAgICAgIC8vIHJlLXJ1biByb3V0aW5lIGZyb20gbGFzdCBlbmRpbmcsIFhBIGhvbGRzIG5ldyBib3R0b21cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiBzdHJpbmcgbWVtb3J5IHBvaW50ZXJcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY29uY2F0ZW5hdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgc3RyaW5ncywgdGhlIGZpcnN0IHN0cmluZyBpcyBpbiB0aGUgZGVzY3JpcHRvciwgdGhlIHNlY29uZCBzdHJpbmcgaXMgaW4gbGluZVxyXG4vKiBiNjNkICovICAgICBfYGNhdF9iNjNkYDsgIExEQS56cGcgKFwiZmFjaG8rM18wMDY1XCIpOyAgICAgLy8gZ2V0IGRlc2NyaXB0b3IgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYjYzZiAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdXQgb24gc3RhY2tcclxuLyogYjY0MCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZhY2hvKzJfMDA2NFwiKTsgICAgIC8vIGdldCBkZXNjcmlwdG9yIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYjY0MiAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdXQgb24gc3RhY2tcclxuLyogYjY0MyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImV2YWxfYWU4M1wiKTsgICAgICAgIC8vIGdldCB2YWx1ZSBmcm9tIGxpbmVcclxuLyogYjY0NiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9hZDhmXCIpOyAgICAgICAgICAgIC8vIGNoZWNrIGlmIHNvdXJjZSBpcyBzdHJpbmcsIGVsc2UgZG8gdHlwZSBtaXNtYXRjaFxyXG4vKiBiNjQ5ICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGdldCBkZXNjcmlwdG9yIHBvaW50ZXIgbG93IGJ5dGUgYmFja1xyXG4vKiBiNjRhICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiYXJpc2duXzAwNmZcIik7ICAgICAgLy8gc2V0IHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYjY0YyAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBnZXQgZGVzY3JpcHRvciBwb2ludGVyIGhpZ2ggYnl0ZSBiYWNrXHJcbi8qIGI2NGQgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmYWNvdl8wMDcwXCIpOyAgICAgICAvLyBzZXQgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYjY0ZiAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBpbmRleFxyXG4vKiBiNjUxICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwiYXJpc2duXzAwNmZcIik7ICAgICAgLy8gZ2V0IGxlbmd0aCBvZiBmaXJzdCBzdHJpbmcgZnJvbSBkZXNjcmlwdG9yXHJcbi8qIGI2NTMgKi8gICAgICAgICAgICAgICAgICAgQ0xDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgY2FycnkgZm9yIGFkZFxyXG4vKiBiNjU0ICovICAgICAgICAgICAgICAgICAgIEFEQy5pbnkgKFwiZmFjaG8rMl8wMDY0XCIpOyAgICAgLy8gYWRkIGxlbmd0aCBvZiBzZWNvbmQgc3RyaW5nXHJcbi8qIGI2NTYgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYjY1ZFwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbm8gb3ZlcmZsb3dcclxuLyogYjY1OCAqLyAgICAgICAgICAgICAgICAgICBMRFguaW1tICgweDE3KTsgICAgICAgICAgICAgICAvLyBlbHNlIGVycm9yICQxNywgc3RyaW5nIHRvbyBsb25nIGVycm9yXHJcbi8qIGI2NWEgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJlcnJvcl9hNDM3XCIpOyAgICAgICAvLyBkbyBlcnJvciAjWCB0aGVuIHdhcm0gc3RhcnRcclxuLyogYjY1ZCAqLyAgICAgICAgX2BfYjY1ZGA7ICBKU1IuYWJzIChcIl9iNDc1XCIpOyAgICAgICAgICAgIC8vIGNvcHkgZGVzY3JpcHRvciBwb2ludGVyIGFuZCBtYWtlIHN0cmluZyBzcGFjZSBBIGJ5dGVzIGxvbmdcclxuLyogYjY2MCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIm1vdmluc19iNjdhXCIpOyAgICAgIC8vIGNvcHkgc3RyaW5nIGZyb20gZGVzY3JpcHRvciB0byB1dGlsaXR5IHBvaW50ZXJcclxuLyogYjY2MyAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImRzY3BudCswXzAwNTBcIik7ICAgIC8vIGdldCBkZXNjcmlwdG9yIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYjY2NSAqLyAgICAgICAgICAgICAgICAgICBMRFkuenBnIChcImRzY3BudCsxXzAwNTFcIik7ICAgIC8vIGdldCBkZXNjcmlwdG9yIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGI2NjcgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfYjZhYVwiKTsgICAgICAgICAgICAvLyBwb3AgKFlBKSBkZXNjcmlwdG9yIG9mZiBzdGFjayBvciBmcm9tIHRvcCBvZiBzdHJpbmcgc3BhY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIHdpdGggQSA9IGxlbmd0aCwgWCA9IHBvaW50ZXIgbG93IGJ5dGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWSA9IHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGI2NmEgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfYjY4Y1wiKTsgICAgICAgICAgICAvLyBzdG9yZSBzdHJpbmcgZnJvbSBwb2ludGVyIHRvIHV0aWxpdHkgcG9pbnRlclxyXG4vKiBiNjZkICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiYXJpc2duXzAwNmZcIik7ICAgICAgLy8gZ2V0IGRlc2NyaXB0b3IgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiNjZmICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwiZmFjb3ZfMDA3MFwiKTsgICAgICAgLy8gZ2V0IGRlc2NyaXB0b3IgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYjY3MSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9iNmFhXCIpOyAgICAgICAgICAgIC8vIHBvcCAoWUEpIGRlc2NyaXB0b3Igb2ZmIHN0YWNrIG9yIGZyb20gdG9wIG9mIHN0cmluZyBzcGFjZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgd2l0aCBBID0gbGVuZ3RoLCBYID0gcG9pbnRlciBsb3cgYnl0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBZID0gcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYjY3NCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9iNGNhXCIpOyAgICAgICAgICAgIC8vIGNoZWNrIHNwYWNlIG9uIGRlc2NyaXB0b3Igc3RhY2sgdGhlbiBwdXQgc3RyaW5nIGFkZHJlc3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbGVuZ3RoIG9uIGRlc2NyaXB0b3Igc3RhY2sgYW5kIHVwZGF0ZSBzdGFjayBwb2ludGVyc1xyXG4vKiBiNjc3ICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2FkYjhcIik7ICAgICAgICAgICAgLy8gY29udGludWUgZXZhbHVhdGlvblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBjb3B5IHN0cmluZyBmcm9tIGRlc2NyaXB0b3IgdG8gdXRpbGl0eSBwb2ludGVyXHJcbi8qIGI2N2EgKi8gIF9gbW92aW5zX2I2N2FgOyAgTERZLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgaW5kZXhcclxuLyogYjY3YyAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcImFyaXNnbl8wMDZmXCIpOyAgICAgIC8vIGdldCBzdHJpbmcgbGVuZ3RoXHJcbi8qIGI2N2UgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBpdFxyXG4vKiBiNjdmICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBpbmRleFxyXG4vKiBiNjgwICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwiYXJpc2duXzAwNmZcIik7ICAgICAgLy8gZ2V0IHN0cmluZyBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGI2ODIgKi8gICAgICAgICAgICAgICAgICAgVEFYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSB0byBYXHJcbi8qIGI2ODMgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGluZGV4XHJcbi8qIGI2ODQgKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJhcmlzZ25fMDA2ZlwiKTsgICAgICAvLyBnZXQgc3RyaW5nIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGI2ODYgKi8gICAgICAgICAgICAgICAgICAgVEFZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSB0byBZXHJcbi8qIGI2ODcgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGxlbmd0aCBiYWNrXHJcbi8qIGI2ODggKi8gICAgICAgIF9gX2I2ODhgOyAgU1RYLnpwZyAoXCJpbmRleCswXzAwMjJcIik7ICAgICAvLyBzYXZlIHN0cmluZyBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGI2OGEgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJpbmRleCsxXzAwMjNcIik7ICAgICAvLyBzYXZlIHN0cmluZyBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIHN0cmluZyBmcm9tIHBvaW50ZXIgdG8gdXRpbGl0eSBwb2ludGVyXHJcbi8qIGI2OGMgKi8gICAgICAgIF9gX2I2OGNgOyAgVEFZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBsZW5ndGggYXMgaW5kZXhcclxuLyogYjY4ZCAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9iNjk5XCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBudWxsIHN0cmluZ1xyXG4vKiBiNjhmICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgbGVuZ3RoXHJcbi8qIGI2OTAgKi8gICAgICAgIF9gX2I2OTBgOyAgREVZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZGVjcmVtZW50IGxlbmd0aC9pbmRleFxyXG4vKiBiNjkxICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwiaW5kZXgrMF8wMDIyXCIpOyAgICAgLy8gZ2V0IGJ5dGUgZnJvbSBzdHJpbmdcclxuLyogYjY5MyAqLyAgICAgICAgICAgICAgICAgICBTVEEuaW55IChcImZyZXNwYyswXzAwMzVcIik7ICAgIC8vIHNhdmUgYnl0ZSB0byBkZXN0aW5hdGlvblxyXG4vKiBiNjk1ICovICAgICAgICAgICAgICAgICAgIFRZQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgbGVuZ3RoL2luZGV4XHJcbi8qIGI2OTYgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYjY5MFwiKTsgICAgICAgICAgICAvLyBsb29wIGlmIG5vdCBhbGwgZG9uZSB5ZXRcclxuLyogYjY5OCAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIGxlbmd0aFxyXG4vKiBiNjk5ICovICAgICAgICBfYF9iNjk5YDsgIENMQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIGNhcnJ5IGZvciBhZGRcclxuLyogYjY5YSAqLyAgICAgICAgICAgICAgICAgICBBREMuenBnIChcImZyZXNwYyswXzAwMzVcIik7ICAgIC8vIGFkZCBzdHJpbmcgdXRpbGl0eSBwdHIgbG93IGJ5dGVcclxuLyogYjY5YyAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZyZXNwYyswXzAwMzVcIik7ICAgIC8vIHNhdmUgc3RyaW5nIHV0aWxpdHkgcHRyIGxvdyBieXRlXHJcbi8qIGI2OWUgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYjZhMlwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbm8gcm9sbG92ZXJcclxuLyogYjZhMCAqLyAgICAgICAgICAgICAgICAgICBJTkMuenBnIChcImZyZXNwYysxXzAwMzZcIik7ICAgIC8vIGluY3JlbWVudCBzdHJpbmcgdXRpbGl0eSBwdHIgaGlnaCBieXRlXHJcbi8qIGI2YTIgKi8gICAgICAgIF9gX2I2YTJgOyAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gZXZhbHVhdGUgc3RyaW5nXHJcbi8qIGI2YTMgKi8gIF9gZnJlc3RyX2I2YTNgOyAgSlNSLmFicyAoXCJfYWQ4ZlwiKTsgICAgICAgICAgICAvLyBjaGVjayBpZiBzb3VyY2UgaXMgc3RyaW5nLCBlbHNlIGRvIHR5cGUgbWlzbWF0Y2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwb3Agc3RyaW5nIG9mZiBkZXNjcmlwdG9yIHN0YWNrLCBvciBmcm9tIHRvcCBvZiBzdHJpbmcgc3BhY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIHdpdGggQSA9IGxlbmd0aCwgWCA9IHBvaW50ZXIgbG93IGJ5dGUsIFkgPSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiNmE2ICovICAgICAgICBfYF9iNmE2YDsgIExEQS56cGcgKFwiZmFjaG8rMl8wMDY0XCIpOyAgICAgLy8gZ2V0IGRlc2NyaXB0b3IgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiNmE4ICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwiZmFjaG8rM18wMDY1XCIpOyAgICAgLy8gZ2V0IGRlc2NyaXB0b3IgcG9pbnRlciBoaWdoIGJ5dGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwb3AgKFlBKSBkZXNjcmlwdG9yIG9mZiBzdGFjayBvciBmcm9tIHRvcCBvZiBzdHJpbmcgc3BhY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIHdpdGggQSA9IGxlbmd0aCwgWCA9IHBvaW50ZXIgbG93IGJ5dGUsIFkgPSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiNmFhICovICAgICAgICBfYF9iNmFhYDsgIFNUQS56cGcgKFwiaW5kZXgrMF8wMDIyXCIpOyAgICAgLy8gc2F2ZSBzdHJpbmcgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiNmFjICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwiaW5kZXgrMV8wMDIzXCIpOyAgICAgLy8gc2F2ZSBzdHJpbmcgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYjZhZSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImZyZWZhY19iNmRiXCIpOyAgICAgIC8vIGNsZWFuIGRlc2NyaXB0b3Igc3RhY2ssIFlBID0gcG9pbnRlclxyXG4vKiBiNmIxICovICAgICAgICAgICAgICAgICAgIFBIUC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgc3RhdHVzIGZsYWdzXHJcbi8qIGI2YjIgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgaW5kZXhcclxuLyogYjZiNCAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcImluZGV4KzBfMDAyMlwiKTsgICAgIC8vIGdldCBsZW5ndGggZnJvbSBzdHJpbmcgZGVzY3JpcHRvclxyXG4vKiBiNmI2ICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHB1dCBvbiBzdGFja1xyXG4vKiBiNmI3ICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBpbmRleFxyXG4vKiBiNmI4ICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwiaW5kZXgrMF8wMDIyXCIpOyAgICAgLy8gZ2V0IHN0cmluZyBwb2ludGVyIGxvdyBieXRlIGZyb20gZGVzY3JpcHRvclxyXG4vKiBiNmJhICovICAgICAgICAgICAgICAgICAgIFRBWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgdG8gWFxyXG4vKiBiNmJiICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBpbmRleFxyXG4vKiBiNmJjICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwiaW5kZXgrMF8wMDIyXCIpOyAgICAgLy8gZ2V0IHN0cmluZyBwb2ludGVyIGhpZ2ggYnl0ZSBmcm9tIGRlc2NyaXB0b3JcclxuLyogYjZiZSAqLyAgICAgICAgICAgICAgICAgICBUQVkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IHRvIFlcclxuLyogYjZiZiAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBnZXQgc3RyaW5nIGxlbmd0aCBiYWNrXHJcbi8qIGI2YzAgKi8gICAgICAgICAgICAgICAgICAgUExQLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBzdGF0dXNcclxuLyogYjZjMSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9iNmQ2XCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBwb2ludGVyIDw+IGxhc3Rfc2wsbGFzdF9zaFxyXG4vKiBiNmMzICovICAgICAgICAgICAgICAgICAgIENQWS56cGcgKFwiZnJldG9wKzFfMDAzNFwiKTsgICAgLy8gY29tcGFyZSB3aXRoIGJvdHRvbSBvZiBzdHJpbmcgc3BhY2UgaGlnaCBieXRlXHJcbi8qIGI2YzUgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYjZkNlwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgPD5cclxuLyogYjZjNyAqLyAgICAgICAgICAgICAgICAgICBDUFguenBnIChcImZyZXRvcCswXzAwMzNcIik7ICAgIC8vIGVsc2UgY29tcGFyZSB3aXRoIGJvdHRvbSBvZiBzdHJpbmcgc3BhY2UgbG93IGJ5dGVcclxuLyogYjZjOSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9iNmQ2XCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiA8PlxyXG4vKiBiNmNiICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgc3RyaW5nIGxlbmd0aFxyXG4vKiBiNmNjICovICAgICAgICAgICAgICAgICAgIENMQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIGNhcnJ5IGZvciBhZGRcclxuLyogYjZjZCAqLyAgICAgICAgICAgICAgICAgICBBREMuenBnIChcImZyZXRvcCswXzAwMzNcIik7ICAgIC8vIGFkZCBib3R0b20gb2Ygc3RyaW5nIHNwYWNlIGxvdyBieXRlXHJcbi8qIGI2Y2YgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmcmV0b3ArMF8wMDMzXCIpOyAgICAvLyBzZXQgYm90dG9tIG9mIHN0cmluZyBzcGFjZSBsb3cgYnl0ZVxyXG4vKiBiNmQxICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2I2ZDVcIik7ICAgICAgICAgICAgLy8gc2tpcCBpbmNyZW1lbnQgaWYgbm8gb3ZlcmZsb3dcclxuLyogYjZkMyAqLyAgICAgICAgICAgICAgICAgICBJTkMuenBnIChcImZyZXRvcCsxXzAwMzRcIik7ICAgIC8vIGluY3JlbWVudCBib3R0b20gb2Ygc3RyaW5nIHNwYWNlIGhpZ2ggYnl0ZVxyXG4vKiBiNmQ1ICovICAgICAgICBfYF9iNmQ1YDsgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgc3RyaW5nIGxlbmd0aFxyXG4vKiBiNmQ2ICovICAgICAgICBfYF9iNmQ2YDsgIFNUWC56cGcgKFwiaW5kZXgrMF8wMDIyXCIpOyAgICAgLy8gc2F2ZSBzdHJpbmcgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiNmQ4ICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwiaW5kZXgrMV8wMDIzXCIpOyAgICAgLy8gc2F2ZSBzdHJpbmcgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYjZkYSAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNsZWFuIGRlc2NyaXB0b3Igc3RhY2ssIFlBID0gcG9pbnRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrcyBpZiBBWSBpcyBvbiB0aGUgZGVzY3JpcHRvciBzdGFjaywgaWYgc28gZG9lcyBhIHN0YWNrIGRpc2NhcmRcclxuLyogYjZkYiAqLyAgX2BmcmVmYWNfYjZkYmA7ICBDUFkuenBnIChcImxhc3RwdCsxXzAwMThcIik7ICAgIC8vIGNvbXBhcmUgaGlnaCBieXRlIHdpdGggY3VycmVudCBkZXNjcmlwdG9yIHN0YWNrIGl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiNmRkICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2I2ZWJcIik7ICAgICAgICAgICAgLy8gZXhpdCBpZiA8PlxyXG4vKiBiNmRmICovICAgICAgICAgICAgICAgICAgIENNUC56cGcgKFwibGFzdHB0KzBfMDAxN1wiKTsgICAgLy8gY29tcGFyZSBsb3cgYnl0ZSB3aXRoIGN1cnJlbnQgZGVzY3JpcHRvciBzdGFjayBpdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiNmUxICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2I2ZWJcIik7ICAgICAgICAgICAgLy8gZXhpdCBpZiA8PlxyXG4vKiBiNmUzICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwidGVtcHB0XzAwMTZcIik7ICAgICAgLy8gc2V0IGRlc2NyaXB0b3Igc3RhY2sgcG9pbnRlclxyXG4vKiBiNmU1ICovICAgICAgICAgICAgICAgICAgIFNCQy5pbW0gKDB4MDMpOyAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBsYXN0IHN0cmluZyBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGI2ZTcgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJsYXN0cHQrMF8wMDE3XCIpOyAgICAvLyBzYXZlIGN1cnJlbnQgZGVzY3JpcHRvciBzdGFjayBpdGVtIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYjZlOSAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBoaWdoIGJ5dGVcclxuLyogYjZlYiAqLyAgICAgICAgX2BfYjZlYmA7ICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBwZXJmb3JtIENIUiQoKVxyXG4vKiBiNmVjICovICAgIF9gY2hyZF9iNmVjYDsgIEpTUi5hYnMgKFwiX2I3YTFcIik7ICAgICAgICAgICAgLy8gZXZhbHVhdGUgYnl0ZSBleHByZXNzaW9uLCByZXN1bHQgaW4gWFxyXG4vKiBiNmVmICovICAgICAgICAgICAgICAgICAgIFRYQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgdG8gQVxyXG4vKiBiNmYwICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgY2hhcmFjdGVyXHJcbi8qIGI2ZjEgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMSk7ICAgICAgICAgICAgICAgLy8gc3RyaW5nIGlzIHNpbmdsZSBieXRlXHJcbi8qIGI2ZjMgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfYjQ3ZFwiKTsgICAgICAgICAgICAvLyBtYWtlIHN0cmluZyBzcGFjZSBBIGJ5dGVzIGxvbmdcclxuLyogYjZmNiAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBnZXQgY2hhcmFjdGVyIGJhY2tcclxuLyogYjZmNyAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBpbmRleFxyXG4vKiBiNmY5ICovICAgICAgICAgICAgICAgICAgIFNUQS5pbnkgKFwiZmFjaG8rMF8wMDYyXCIpOyAgICAgLy8gc2F2ZSBieXRlIGluIHN0cmluZyAtIGJ5dGUgSVMgc3RyaW5nIVxyXG4vKiBiNmZiICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGR1bXAgcmV0dXJuIGFkZHJlc3MgKHNraXAgdHlwZSBjaGVjaylcclxuLyogYjZmYyAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBkdW1wIHJldHVybiBhZGRyZXNzIChza2lwIHR5cGUgY2hlY2spXHJcbi8qIGI2ZmQgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfYjRjYVwiKTsgICAgICAgICAgICAvLyBjaGVjayBzcGFjZSBvbiBkZXNjcmlwdG9yIHN0YWNrIHRoZW4gcHV0IHN0cmluZyBhZGRyZXNzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGxlbmd0aCBvbiBkZXNjcmlwdG9yIHN0YWNrIGFuZCB1cGRhdGUgc3RhY2sgcG9pbnRlcnNcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcGVyZm9ybSBMRUZUJCgpXHJcbi8qIGI3MDAgKi8gICBfYGxlZnRkX2I3MDBgOyAgSlNSLmFicyAoXCJwcmVhbV9iNzYxXCIpOyAgICAgICAvLyBwdWxsIHN0cmluZyBkYXRhIGFuZCBieXRlIHBhcmFtZXRlciBmcm9tIHN0YWNrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIHBvaW50ZXIgaW4gZGVzY3JpcHRvciwgYnl0ZSBpbiBBIChhbmQgWCksIFk9MFxyXG4vKiBiNzAzICovICAgICAgICAgICAgICAgICAgIENNUC5pbnkgKFwiZHNjcG50KzBfMDA1MFwiKTsgICAgLy8gY29tcGFyZSBieXRlIHBhcmFtZXRlciB3aXRoIHN0cmluZyBsZW5ndGhcclxuLyogYjcwNSAqLyAgICAgICAgICAgICAgICAgICBUWUEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBBXHJcbi8qIGI3MDYgKi8gICAgICAgIF9gX2I3MDZgOyAgQkNDLnJlbCAoXCJfYjcwY1wiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgc3RyaW5nIGxlbmd0aCA+IGJ5dGUgcGFyYW1ldGVyXHJcbi8qIGI3MDggKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJkc2NwbnQrMF8wMDUwXCIpOyAgICAvLyBlbHNlIG1ha2UgcGFyYW1ldGVyID0gbGVuZ3RoXHJcbi8qIGI3MGEgKi8gICAgICAgICAgICAgICAgICAgVEFYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSB0byBieXRlIHBhcmFtZXRlciBjb3B5XHJcbi8qIGI3MGIgKi8gICAgICAgICAgICAgICAgICAgVFlBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgc3RyaW5nIHN0YXJ0IG9mZnNldFxyXG4vKiBiNzBjICovICAgICAgICBfYF9iNzBjYDsgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgc3RyaW5nIHN0YXJ0IG9mZnNldFxyXG4vKiBiNzBkICovICAgICAgICBfYF9iNzBkYDsgIFRYQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgYnl0ZSBwYXJhbWV0ZXIgKG9yIHN0cmluZyBsZW5ndGggaWYgPClcclxuLyogYjcwZSAqLyAgICAgICAgX2BfYjcwZWA7ICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzYXZlIHN0cmluZyBsZW5ndGhcclxuLyogYjcwZiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9iNDdkXCIpOyAgICAgICAgICAgIC8vIG1ha2Ugc3RyaW5nIHNwYWNlIEEgYnl0ZXMgbG9uZ1xyXG4vKiBiNzEyICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZHNjcG50KzBfMDA1MFwiKTsgICAgLy8gZ2V0IGRlc2NyaXB0b3IgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiNzE0ICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwiZHNjcG50KzFfMDA1MVwiKTsgICAgLy8gZ2V0IGRlc2NyaXB0b3IgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYjcxNiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9iNmFhXCIpOyAgICAgICAgICAgIC8vIHBvcCAoWUEpIGRlc2NyaXB0b3Igb2ZmIHN0YWNrIG9yIGZyb20gdG9wIG9mIHN0cmluZyBzcGFjZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgd2l0aCBBID0gbGVuZ3RoLCBYID0gcG9pbnRlciBsb3cgYnl0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBZID0gcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYjcxOSAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBnZXQgc3RyaW5nIGxlbmd0aCBiYWNrXHJcbi8qIGI3MWEgKi8gICAgICAgICAgICAgICAgICAgVEFZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBsZW5ndGggdG8gWVxyXG4vKiBiNzFiICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGdldCBzdHJpbmcgc3RhcnQgb2Zmc2V0IGJhY2tcclxuLyogYjcxYyAqLyAgICAgICAgICAgICAgICAgICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBjYXJyeSBmb3IgYWRkXHJcbi8qIGI3MWQgKi8gICAgICAgICAgICAgICAgICAgQURDLnpwZyAoXCJpbmRleCswXzAwMjJcIik7ICAgICAvLyBhZGQgc3RhcnQgb2Zmc2V0IHRvIHN0cmluZyBzdGFydCBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGI3MWYgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJpbmRleCswXzAwMjJcIik7ICAgICAvLyBzYXZlIHN0cmluZyBzdGFydCBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGI3MjEgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYjcyNVwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbm8gb3ZlcmZsb3dcclxuLyogYjcyMyAqLyAgICAgICAgICAgICAgICAgICBJTkMuenBnIChcImluZGV4KzFfMDAyM1wiKTsgICAgIC8vIGVsc2UgaW5jcmVtZW50IHN0cmluZyBzdGFydCBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiNzI1ICovICAgICAgICBfYF9iNzI1YDsgIFRZQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgbGVuZ3RoIHRvIEFcclxuLyogYjcyNiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9iNjhjXCIpOyAgICAgICAgICAgIC8vIHN0b3JlIHN0cmluZyBmcm9tIHBvaW50ZXIgdG8gdXRpbGl0eSBwb2ludGVyXHJcbi8qIGI3MjkgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfYjRjYVwiKTsgICAgICAgICAgICAvLyBjaGVjayBzcGFjZSBvbiBkZXNjcmlwdG9yIHN0YWNrIHRoZW4gcHV0IHN0cmluZyBhZGRyZXNzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGxlbmd0aCBvbiBkZXNjcmlwdG9yIHN0YWNrIGFuZCB1cGRhdGUgc3RhY2sgcG9pbnRlcnNcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcGVyZm9ybSBSSUdIVCQoKVxyXG4vKiBiNzJjICovICBfYHJpZ2h0ZF9iNzJjYDsgIEpTUi5hYnMgKFwicHJlYW1fYjc2MVwiKTsgICAgICAgLy8gcHVsbCBzdHJpbmcgZGF0YSBhbmQgYnl0ZSBwYXJhbWV0ZXIgZnJvbSBzdGFja1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBwb2ludGVyIGluIGRlc2NyaXB0b3IsIGJ5dGUgaW4gQSAoYW5kIFgpLCBZPTBcclxuLyogYjcyZiAqLyAgICAgICAgICAgICAgICAgICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBjYXJyeSBmb3IgYWRkLTFcclxuLyogYjczMCAqLyAgICAgICAgICAgICAgICAgICBTQkMuaW55IChcImRzY3BudCswXzAwNTBcIik7ICAgIC8vIHN1YnRyYWN0IHN0cmluZyBsZW5ndGhcclxuLyogYjczMiAqLyAgICAgICAgICAgICAgICAgICBFT1IuaW1tICgweGZmKTsgICAgICAgICAgICAgICAvLyBpbnZlcnQgaXQgKEE9TEVOKGV4cHJlc3Npb24kKS1sKVxyXG4vKiBiNzM0ICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2I3MDZcIik7ICAgICAgICAgICAgLy8gZ28gZG8gcmVzdCBvZiBMRUZUJCgpXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHBlcmZvcm0gTUlEJCgpXHJcbi8qIGI3MzcgKi8gICAgX2BtaWRkX2I3MzdgOyAgTERBLmltbSAoMHhmZik7ICAgICAgICAgICAgICAgLy8gc2V0IGRlZmF1bHQgbGVuZ3RoID0gMjU1XHJcbi8qIGI3MzkgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmYWNobyszXzAwNjVcIik7ICAgICAvLyBzYXZlIGRlZmF1bHQgbGVuZ3RoXHJcbi8qIGI3M2IgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJjaHJnb3RfMDA3OVwiKTsgICAgICAvLyBzY2FuIG1lbW9yeVxyXG4vKiBiNzNlICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4MjkpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCBcIilcIlxyXG4vKiBiNzQwICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2I3NDhcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmID0gXCIpXCIgKHNraXAgc2Vjb25kIGJ5dGUgZ2V0KVxyXG4vKiBiNzQyICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2FlZmRcIik7ICAgICAgICAgICAgLy8gc2NhbiBmb3IgXCIsXCIsIGVsc2UgZG8gc3ludGF4IGVycm9yIHRoZW4gd2FybSBzdGFydFxyXG4vKiBiNzQ1ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2I3OWVcIik7ICAgICAgICAgICAgLy8gZ2V0IGJ5dGUgcGFyYW1ldGVyXHJcbi8qIGI3NDggKi8gICAgICAgIF9gX2I3NDhgOyAgSlNSLmFicyAoXCJwcmVhbV9iNzYxXCIpOyAgICAgICAvLyBwdWxsIHN0cmluZyBkYXRhIGFuZCBieXRlIHBhcmFtZXRlciBmcm9tIHN0YWNrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIHBvaW50ZXIgaW4gZGVzY3JpcHRvciwgYnl0ZSBpbiBBIChhbmQgWCksIFk9MFxyXG4vKiBiNzRiICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2I3OThcIik7ICAgICAgICAgICAgLy8gaWYgbnVsbCBkbyBpbGxlZ2FsIHF1YW50aXR5IGVycm9yIHRoZW4gd2FybSBzdGFydFxyXG4vKiBiNzRkICovICAgICAgICAgICAgICAgICAgIERFWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCBzdGFydCBpbmRleFxyXG4vKiBiNzRlICovICAgICAgICAgICAgICAgICAgIFRYQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgdG8gQVxyXG4vKiBiNzRmICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgc3RyaW5nIHN0YXJ0IG9mZnNldFxyXG4vKiBiNzUwICovICAgICAgICAgICAgICAgICAgIENMQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIGNhcnJ5IGZvciBzdWItMVxyXG4vKiBiNzUxICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIG91dHB1dCBzdHJpbmcgbGVuZ3RoXHJcbi8qIGI3NTMgKi8gICAgICAgICAgICAgICAgICAgU0JDLmlueSAoXCJkc2NwbnQrMF8wMDUwXCIpOyAgICAvLyBzdWJ0cmFjdCBzdHJpbmcgbGVuZ3RoXHJcbi8qIGI3NTUgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfYjcwZFwiKTsgICAgICAgICAgICAvLyBpZiBzdGFydD5zdHJpbmcgbGVuZ3RoIGdvIGRvIG51bGwgc3RyaW5nXHJcbi8qIGI3NTcgKi8gICAgICAgICAgICAgICAgICAgRU9SLmltbSAoMHhmZik7ICAgICAgICAgICAgICAgLy8gY29tcGxlbWVudCAtbGVuZ3RoXHJcbi8qIGI3NTkgKi8gICAgICAgICAgICAgICAgICAgQ01QLnpwZyAoXCJmYWNobyszXzAwNjVcIik7ICAgICAvLyBjb21wYXJlIGJ5dGUgcGFyYW1ldGVyXHJcbi8qIGI3NWIgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYjcwZVwiKTsgICAgICAgICAgICAvLyBpZiBsZW5ndGg+cmVtYWluaW5nIHN0cmluZyBnbyBkbyBSSUdIVCRcclxuLyogYjc1ZCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZhY2hvKzNfMDA2NVwiKTsgICAgIC8vIGdldCBsZW5ndGggYnl0ZVxyXG4vKiBiNzVmICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2I3MGVcIik7ICAgICAgICAgICAgLy8gZ28gZG8gc3RyaW5nIGNvcHksIGJyYW5jaCBhbHdheXNcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcHVsbCBzdHJpbmcgZGF0YSBhbmQgYnl0ZSBwYXJhbWV0ZXIgZnJvbSBzdGFja1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBwb2ludGVyIGluIGRlc2NyaXB0b3IsIGJ5dGUgaW4gQSAoYW5kIFgpLCBZPTBcclxuLyogYjc2MSAqLyAgIF9gcHJlYW1fYjc2MWA7ICBKU1IuYWJzIChcImNoa2Nsc19hZWY3XCIpOyAgICAgIC8vIHNjYW4gZm9yIFwiKVwiLCBlbHNlIGRvIHN5bnRheCBlcnJvciB0aGVuIHdhcm0gc3RhcnRcclxuLyogYjc2NCAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdWxsIHJldHVybiBhZGRyZXNzIGxvdyBieXRlXHJcbi8qIGI3NjUgKi8gICAgICAgICAgICAgICAgICAgVEFZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSByZXR1cm4gYWRkcmVzcyBsb3cgYnl0ZVxyXG4vKiBiNzY2ICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHB1bGwgcmV0dXJuIGFkZHJlc3MgaGlnaCBieXRlXHJcbi8qIGI3NjcgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJqbXBlcisxXzAwNTVcIik7ICAgICAvLyBzYXZlIHJldHVybiBhZGRyZXNzIGhpZ2ggYnl0ZVxyXG4vKiBiNzY5ICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGR1bXAgY2FsbCB0byBmdW5jdGlvbiB2ZWN0b3IgbG93IGJ5dGVcclxuLyogYjc2YSAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBkdW1wIGNhbGwgdG8gZnVuY3Rpb24gdmVjdG9yIGhpZ2ggYnl0ZVxyXG4vKiBiNzZiICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHB1bGwgYnl0ZSBwYXJhbWV0ZXJcclxuLyogYjc2YyAqLyAgICAgICAgICAgICAgICAgICBUQVguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IGJ5dGUgcGFyYW1ldGVyIHRvIFhcclxuLyogYjc2ZCAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdWxsIHN0cmluZyBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGI3NmUgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJkc2NwbnQrMF8wMDUwXCIpOyAgICAvLyBzYXZlIGl0XHJcbi8qIGI3NzAgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVsbCBzdHJpbmcgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYjc3MSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImRzY3BudCsxXzAwNTFcIik7ICAgIC8vIHNhdmUgaXRcclxuLyogYjc3MyAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImptcGVyKzFfMDA1NVwiKTsgICAgIC8vIGdldCByZXR1cm4gYWRkcmVzcyBoaWdoIGJ5dGVcclxuLyogYjc3NSAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBiYWNrIG9uIHN0YWNrXHJcbi8qIGI3NzYgKi8gICAgICAgICAgICAgICAgICAgVFlBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHJldHVybiBhZGRyZXNzIGxvdyBieXRlXHJcbi8qIGI3NzcgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gYmFjayBvbiBzdGFja1xyXG4vKiBiNzc4ICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIGluZGV4XHJcbi8qIGI3N2EgKi8gICAgICAgICAgICAgICAgICAgVFhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBieXRlIHBhcmFtZXRlclxyXG4vKiBiNzdiICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHBlcmZvcm0gTEVOKClcclxuLyogYjc3YyAqLyAgICAgX2BsZW5fYjc3Y2A7ICBKU1IuYWJzIChcImxlbjFfYjc4MlwiKTsgICAgICAgIC8vIGV2YWx1YXRlIHN0cmluZywgZ2V0IGxlbmd0aCBpbiBBIChhbmQgWSlcclxuLyogYjc3ZiAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9iM2EyXCIpOyAgICAgICAgICAgIC8vIGNvbnZlcnQgWSB0byBieXRlIGluIEZBQzEgYW5kIHJldHVyblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBldmFsdWF0ZSBzdHJpbmcsIGdldCBsZW5ndGggaW4gWVxyXG4vKiBiNzgyICovICAgIF9gbGVuMV9iNzgyYDsgIEpTUi5hYnMgKFwiZnJlc3RyX2I2YTNcIik7ICAgICAgLy8gZXZhbHVhdGUgc3RyaW5nXHJcbi8qIGI3ODUgKi8gICAgICAgICAgICAgICAgICAgTERYLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gc2V0IGRhdGEgdHlwZSA9IG51bWVyaWNcclxuLyogYjc4NyAqLyAgICAgICAgICAgICAgICAgICBTVFguenBnIChcInZhbHR5cF8wMDBkXCIpOyAgICAgIC8vIGNsZWFyIGRhdGEgdHlwZSBmbGFnLCAkRkYgPSBzdHJpbmcsICQwMCA9IG51bWVyaWNcclxuLyogYjc4OSAqLyAgICAgICAgICAgICAgICAgICBUQVkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IGxlbmd0aCB0byBZXHJcbi8qIGI3OGEgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcGVyZm9ybSBBU0MoKVxyXG4vKiBiNzhiICovICAgICBfYGFzY19iNzhiYDsgIEpTUi5hYnMgKFwibGVuMV9iNzgyXCIpOyAgICAgICAgLy8gZXZhbHVhdGUgc3RyaW5nLCBnZXQgbGVuZ3RoIGluIEEgKGFuZCBZKVxyXG4vKiBiNzhlICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2I3OThcIik7ICAgICAgICAgICAgLy8gaWYgbnVsbCBkbyBpbGxlZ2FsIHF1YW50aXR5IGVycm9yIHRoZW4gd2FybSBzdGFydFxyXG4vKiBiNzkwICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIHNldCBpbmRleCB0byBmaXJzdCBjaGFyYWN0ZXJcclxuLyogYjc5MiAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcImluZGV4KzBfMDAyMlwiKTsgICAgIC8vIGdldCBieXRlXHJcbi8qIGI3OTQgKi8gICAgICAgICAgICAgICAgICAgVEFZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSB0byBZXHJcbi8qIGI3OTUgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfYjNhMlwiKTsgICAgICAgICAgICAvLyBjb252ZXJ0IFkgdG8gYnl0ZSBpbiBGQUMxIGFuZCByZXR1cm5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gZG8gaWxsZWdhbCBxdWFudGl0eSBlcnJvciB0aGVuIHdhcm0gc3RhcnRcclxuLyogYjc5OCAqLyAgICAgICAgX2BfYjc5OGA7ICBKTVAuYWJzIChcImZjZXJyX2IyNDhcIik7ICAgICAgIC8vIGRvIGlsbGVnYWwgcXVhbnRpdHkgZXJyb3IgdGhlbiB3YXJtIHN0YXJ0XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHNjYW4gYW5kIGdldCBieXRlIHBhcmFtZXRlclxyXG4vKiBiNzliICovICBfYGd0Ynl0Y19iNzliYDsgIEpTUi5hYnMgKFwiY2hyZ2V0KzBfMDA3M1wiKTsgICAgLy8gaW5jcmVtZW50IGFuZCBzY2FuIG1lbW9yeVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBnZXQgYnl0ZSBwYXJhbWV0ZXJcclxuLyogYjc5ZSAqLyAgICAgICAgX2BfYjc5ZWA7ICBKU1IuYWJzIChcImZybW51bV9hZDhhXCIpOyAgICAgIC8vIGV2YWx1YXRlIGV4cHJlc3Npb24gYW5kIGNoZWNrIGlzIG51bWVyaWMsIGVsc2UgZG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0eXBlIG1pc21hdGNoXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGV2YWx1YXRlIGJ5dGUgZXhwcmVzc2lvbiwgcmVzdWx0IGluIFhcclxuLyogYjdhMSAqLyAgICAgICAgX2BfYjdhMWA7ICBKU1IuYWJzIChcIl9iMWI4XCIpOyAgICAgICAgICAgIC8vIGV2YWx1YXRlIGludGVnZXIgZXhwcmVzc2lvbiwgc2lnbiBjaGVja1xyXG4vKiBiN2E0ICovICAgICAgICAgICAgICAgICAgIExEWC56cGcgKFwiZmFjaG8rMl8wMDY0XCIpOyAgICAgLy8gZ2V0IEZBQzEgbWFudGlzc2EgM1xyXG4vKiBiN2E2ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2I3OThcIik7ICAgICAgICAgICAgLy8gaWYgbm90IG51bGwgZG8gaWxsZWdhbCBxdWFudGl0eSBlcnJvciB0aGVuIHdhcm0gc3RhcnRcclxuLyogYjdhOCAqLyAgICAgICAgICAgICAgICAgICBMRFguenBnIChcImZhY2hvKzNfMDA2NVwiKTsgICAgIC8vIGdldCBGQUMxIG1hbnRpc3NhIDRcclxuLyogYjdhYSAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcImNocmdvdF8wMDc5XCIpOyAgICAgIC8vIHNjYW4gbWVtb3J5IGFuZCByZXR1cm5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcGVyZm9ybSBWQUwoKVxyXG4vKiBiN2FkICovICAgICBfYHZhbF9iN2FkYDsgIEpTUi5hYnMgKFwibGVuMV9iNzgyXCIpOyAgICAgICAgLy8gZXZhbHVhdGUgc3RyaW5nLCBnZXQgbGVuZ3RoIGluIEEgKGFuZCBZKVxyXG4vKiBiN2IwICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwic3RydmFsX2I3YjVcIik7ICAgICAgLy8gYnJhbmNoIGlmIG5vdCBudWxsIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZyB3YXMgbnVsbCBzbyBzZXQgcmVzdWx0ID0gJDAwXHJcbi8qIGI3YjIgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfYjhmN1wiKTsgICAgICAgICAgICAvLyBjbGVhciBGQUMxIGV4cG9uZW50IGFuZCBzaWduIGFuZCByZXR1cm5cclxuLyogYjdiNSAqLyAgX2BzdHJ2YWxfYjdiNWA7ICBMRFguenBnIChcInR4dHB0ciswXzAwN2FcIik7ICAgIC8vIGdldCBCQVNJQyBleGVjdXRlIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYjdiNyAqLyAgICAgICAgICAgICAgICAgICBMRFkuenBnIChcInR4dHB0cisxXzAwN2JcIik7ICAgIC8vIGdldCBCQVNJQyBleGVjdXRlIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGI3YjkgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJmYnVmcHQrMF8wMDcxXCIpOyAgICAvLyBzYXZlIEJBU0lDIGV4ZWN1dGUgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiN2JiICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwiZmJ1ZnB0KzFfMDA3MlwiKTsgICAgLy8gc2F2ZSBCQVNJQyBleGVjdXRlIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGI3YmQgKi8gICAgICAgICAgICAgICAgICAgTERYLnpwZyAoXCJpbmRleCswXzAwMjJcIik7ICAgICAvLyBnZXQgc3RyaW5nIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYjdiZiAqLyAgICAgICAgICAgICAgICAgICBTVFguenBnIChcInR4dHB0ciswXzAwN2FcIik7ICAgIC8vIHNhdmUgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGI3YzEgKi8gICAgICAgICAgICAgICAgICAgQ0xDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgY2FycnkgZm9yIGFkZFxyXG4vKiBiN2MyICovICAgICAgICAgICAgICAgICAgIEFEQy56cGcgKFwiaW5kZXgrMF8wMDIyXCIpOyAgICAgLy8gYWRkIHN0cmluZyBsZW5ndGhcclxuLyogYjdjNCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImluZGV4KzJfMDAyNFwiKTsgICAgIC8vIHNhdmUgc3RyaW5nIGVuZCBsb3cgYnl0ZVxyXG4vKiBiN2M2ICovICAgICAgICAgICAgICAgICAgIExEWC56cGcgKFwiaW5kZXgrMV8wMDIzXCIpOyAgICAgLy8gZ2V0IHN0cmluZyBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiN2M4ICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwidHh0cHRyKzFfMDA3YlwiKTsgICAgLy8gc2F2ZSBCQVNJQyBleGVjdXRlIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGI3Y2EgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYjdjZFwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbm8gaGlnaCBieXRlIGluY3JlbWVudFxyXG4vKiBiN2NjICovICAgICAgICAgICAgICAgICAgIElOWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBzdHJpbmcgZW5kIGhpZ2ggYnl0ZVxyXG4vKiBiN2NkICovICAgICAgICBfYF9iN2NkYDsgIFNUWC56cGcgKFwiaW5kZXgrM18wMDI1XCIpOyAgICAgLy8gc2F2ZSBzdHJpbmcgZW5kIGhpZ2ggYnl0ZVxyXG4vKiBiN2NmICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIHNldCBpbmRleCB0byAkMDBcclxuLyogYjdkMSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcImluZGV4KzJfMDAyNFwiKTsgICAgIC8vIGdldCBzdHJpbmcgZW5kIGJ5dGVcclxuLyogYjdkMyAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdXNoIGl0XHJcbi8qIGI3ZDQgKi8gICAgICAgICAgICAgICAgICAgVFlBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgQVxyXG4vKiBiN2Q1ICovICAgICAgICAgICAgICAgICAgIFNUQS5pbnkgKFwiaW5kZXgrMl8wMDI0XCIpOyAgICAgLy8gdGVybWluYXRlIHN0cmluZyB3aXRoICQwMFxyXG4vKiBiN2Q3ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiY2hyZ290XzAwNzlcIik7ICAgICAgLy8gc2NhbiBtZW1vcnlcclxuLyogYjdkYSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImZpbl9iY2YzXCIpOyAgICAgICAgIC8vIGdldCBGQUMxIGZyb20gc3RyaW5nXHJcbi8qIGI3ZGQgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBzdHJpbmcgZW5kIGJ5dGVcclxuLyogYjdkZSAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBpbmRleFxyXG4vKiBiN2UwICovICAgICAgICAgICAgICAgICAgIFNUQS5pbnkgKFwiaW5kZXgrMl8wMDI0XCIpOyAgICAgLy8gcHV0IHN0cmluZyBlbmQgYnl0ZSBiYWNrXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHJlc3RvcmUgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGZyb20gdGVtcFxyXG4vKiBiN2UyICovICAgICAgICBfYF9iN2UyYDsgIExEWC56cGcgKFwiZmJ1ZnB0KzBfMDA3MVwiKTsgICAgLy8gZ2V0IEJBU0lDIGV4ZWN1dGUgcG9pbnRlciBsb3cgYnl0ZSBiYWNrXHJcbi8qIGI3ZTQgKi8gICAgICAgICAgICAgICAgICAgTERZLnpwZyAoXCJmYnVmcHQrMV8wMDcyXCIpOyAgICAvLyBnZXQgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGhpZ2ggYnl0ZSBiYWNrXHJcbi8qIGI3ZTYgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJ0eHRwdHIrMF8wMDdhXCIpOyAgICAvLyBzYXZlIEJBU0lDIGV4ZWN1dGUgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiN2U4ICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwidHh0cHRyKzFfMDA3YlwiKTsgICAgLy8gc2F2ZSBCQVNJQyBleGVjdXRlIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGI3ZWEgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gZ2V0IHBhcmFtZXRlcnMgZm9yIFBPS0UvV0FJVFxyXG4vKiBiN2ViICovICBfYGdldG51bV9iN2ViYDsgIEpTUi5hYnMgKFwiZnJtbnVtX2FkOGFcIik7ICAgICAgLy8gZXZhbHVhdGUgZXhwcmVzc2lvbiBhbmQgY2hlY2sgaXMgbnVtZXJpYywgZWxzZSBkb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHR5cGUgbWlzbWF0Y2hcclxuLyogYjdlZSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImdldGFkcl9iN2Y3XCIpOyAgICAgIC8vIGNvbnZlcnQgRkFDXzEgdG8gaW50ZWdlciBpbiB0ZW1wb3JhcnkgaW50ZWdlclxyXG4vKiBiN2YxICovICAgICAgICBfYF9iN2YxYDsgIEpTUi5hYnMgKFwiX2FlZmRcIik7ICAgICAgICAgICAgLy8gc2NhbiBmb3IgXCIsXCIsIGVsc2UgZG8gc3ludGF4IGVycm9yIHRoZW4gd2FybSBzdGFydFxyXG4vKiBiN2Y0ICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2I3OWVcIik7ICAgICAgICAgICAgLy8gZ2V0IGJ5dGUgcGFyYW1ldGVyIGFuZCByZXR1cm5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY29udmVydCBGQUNfMSB0byBpbnRlZ2VyIGluIHRlbXBvcmFyeSBpbnRlZ2VyXHJcbi8qIGI3ZjcgKi8gIF9gZ2V0YWRyX2I3ZjdgOyAgTERBLnpwZyAoXCJmYWNzZ25fMDA2NlwiKTsgICAgICAvLyBnZXQgRkFDMSBzaWduXHJcbi8qIGI3ZjkgKi8gICAgICAgICAgICAgICAgICAgQk1JLnJlbCAoXCJfYjc5OFwiKTsgICAgICAgICAgICAvLyBpZiAtdmUgZG8gaWxsZWdhbCBxdWFudGl0eSBlcnJvciB0aGVuIHdhcm0gc3RhcnRcclxuLyogYjdmYiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZhY2V4cF8wMDYxXCIpOyAgICAgIC8vIGdldCBGQUMxIGV4cG9uZW50XHJcbi8qIGI3ZmQgKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHg5MSk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIGV4cG9uZW50ID0gMl4xNlxyXG4vKiBiN2ZmICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2I3OThcIik7ICAgICAgICAgICAgLy8gaWYgPj0gZG8gaWxsZWdhbCBxdWFudGl0eSBlcnJvciB0aGVuIHdhcm0gc3RhcnRcclxuLyogYjgwMSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcInFpbnRfYmM5YlwiKTsgICAgICAgIC8vIGNvbnZlcnQgRkFDMSBmbG9hdGluZyB0byBmaXhlZFxyXG4vKiBiODA0ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZmFjaG8rMl8wMDY0XCIpOyAgICAgLy8gZ2V0IEZBQzEgbWFudGlzc2EgM1xyXG4vKiBiODA2ICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwiZmFjaG8rM18wMDY1XCIpOyAgICAgLy8gZ2V0IEZBQzEgbWFudGlzc2EgNFxyXG4vKiBiODA4ICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwibGlubnVtKzBfMDAxNFwiKTsgICAgLy8gc2F2ZSB0ZW1wb3JhcnkgaW50ZWdlciBsb3cgYnl0ZVxyXG4vKiBiODBhICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwibGlubnVtKzFfMDAxNVwiKTsgICAgLy8gc2F2ZSB0ZW1wb3JhcnkgaW50ZWdlciBoaWdoIGJ5dGVcclxuLyogYjgwYyAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBwZXJmb3JtIFBFRUsoKVxyXG4vKiBiODBkICovICAgIF9gcGVla19iODBkYDsgIExEQS56cGcgKFwibGlubnVtKzFfMDAxNVwiKTsgICAgLy8gZ2V0IGxpbmUgbnVtYmVyIGhpZ2ggYnl0ZVxyXG4vKiBiODBmICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgbGluZSBudW1iZXIgaGlnaCBieXRlXHJcbi8qIGI4MTAgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJsaW5udW0rMF8wMDE0XCIpOyAgICAvLyBnZXQgbGluZSBudW1iZXIgbG93IGJ5dGVcclxuLyogYjgxMiAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzYXZlIGxpbmUgbnVtYmVyIGxvdyBieXRlXHJcbi8qIGI4MTMgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJnZXRhZHJfYjdmN1wiKTsgICAgICAvLyBjb252ZXJ0IEZBQ18xIHRvIGludGVnZXIgaW4gdGVtcG9yYXJ5IGludGVnZXJcclxuLyogYjgxNiAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBpbmRleFxyXG4vKiBiODE4ICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwibGlubnVtKzBfMDAxNFwiKTsgICAgLy8gcmVhZCBieXRlXHJcbi8qIGI4MWEgKi8gICAgICAgICAgICAgICAgICAgVEFZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBieXRlIHRvIEFcclxuLyogYjgxYiAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdWxsIGJ5dGVcclxuLyogYjgxYyAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImxpbm51bSswXzAwMTRcIik7ICAgIC8vIHJlc3RvcmUgbGluZSBudW1iZXIgbG93IGJ5dGVcclxuLyogYjgxZSAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdWxsIGJ5dGVcclxuLyogYjgxZiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImxpbm51bSsxXzAwMTVcIik7ICAgIC8vIHJlc3RvcmUgbGluZSBudW1iZXIgaGlnaCBieXRlXHJcbi8qIGI4MjEgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfYjNhMlwiKTsgICAgICAgICAgICAvLyBjb252ZXJ0IFkgdG8gYnl0ZSBpbiBGQUNfMSBhbmQgcmV0dXJuXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHBlcmZvcm0gUE9LRVxyXG4vKiBiODI0ICovICAgIF9gcG9rZV9iODI0YDsgIEpTUi5hYnMgKFwiZ2V0bnVtX2I3ZWJcIik7ICAgICAgLy8gZ2V0IHBhcmFtZXRlcnMgZm9yIFBPS0UvV0FJVFxyXG4vKiBiODI3ICovICAgICAgICAgICAgICAgICAgIFRYQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgYnl0ZSB0byBBXHJcbi8qIGI4MjggKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgaW5kZXhcclxuLyogYjgyYSAqLyAgICAgICAgICAgICAgICAgICBTVEEuaW55IChcImxpbm51bSswXzAwMTRcIik7ICAgIC8vIHdyaXRlIGJ5dGVcclxuLyogYjgyYyAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBwZXJmb3JtIFdBSVRcclxuLyogYjgyZCAqLyAgICBfYHdhaXRfYjgyZGA7ICBKU1IuYWJzIChcImdldG51bV9iN2ViXCIpOyAgICAgIC8vIGdldCBwYXJhbWV0ZXJzIGZvciBQT0tFL1dBSVRcclxuLyogYjgzMCAqLyAgICAgICAgICAgICAgICAgICBTVFguenBnIChcImZvcnBudCswXzAwNDlcIik7ICAgIC8vIHNhdmUgYnl0ZVxyXG4vKiBiODMyICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIG1hc2tcclxuLyogYjgzNCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImNocmdvdF8wMDc5XCIpOyAgICAgIC8vIHNjYW4gbWVtb3J5XHJcbi8qIGI4MzcgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYjgzY1wiKTsgICAgICAgICAgICAvLyBza2lwIGlmIG5vIHRoaXJkIGFyZ3VtZW50XHJcbi8qIGI4MzkgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfYjdmMVwiKTsgICAgICAgICAgICAvLyBzY2FuIGZvciBcIixcIiBhbmQgZ2V0IGJ5dGUsIGVsc2Ugc3ludGF4IGVycm9yIHRoZW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3YXJtIHN0YXJ0XHJcbi8qIGI4M2MgKi8gICAgICAgIF9gX2I4M2NgOyAgU1RYLnpwZyAoXCJmb3JwbnQrMV8wMDRhXCIpOyAgICAvLyBzYXZlIEVPUiBhcmd1bWVudFxyXG4vKiBiODNlICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIGluZGV4XHJcbi8qIGI4NDAgKi8gICAgICAgIF9gX2I4NDBgOyAgTERBLmlueSAoXCJsaW5udW0rMF8wMDE0XCIpOyAgICAvLyBnZXQgYnl0ZSB2aWEgdGVtcG9yYXJ5IGludGVnZXIgKGFkZHJlc3MpXHJcbi8qIGI4NDIgKi8gICAgICAgICAgICAgICAgICAgRU9SLnpwZyAoXCJmb3JwbnQrMV8wMDRhXCIpOyAgICAvLyBFT1Igd2l0aCBzZWNvbmQgYXJndW1lbnQgICAgICAgKG1hc2spXHJcbi8qIGI4NDQgKi8gICAgICAgICAgICAgICAgICAgQU5ELnpwZyAoXCJmb3JwbnQrMF8wMDQ5XCIpOyAgICAvLyBBTkQgd2l0aCBmaXJzdCBhcmd1bWVudCAgICAgICAgKGJ5dGUpXHJcbi8qIGI4NDYgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYjg0MFwiKTsgICAgICAgICAgICAvLyBsb29wIGlmIHJlc3VsdCBpcyB6ZXJvXHJcbi8qIGI4NDggKi8gICAgICAgIF9gX2I4NDhgOyAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gYWRkIDAuNSB0byBGQUMxIChyb3VuZCBGQUMxKVxyXG4vKiBiODQ5ICovICAgX2BmYWRkaF9iODQ5YDsgIExEQS5pbW0gKDB4MTEpOyAgICAgICAgICAgICAgIC8vIHNldCAwLjUgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiODRiICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4YmYpOyAgICAgICAgICAgICAgIC8vIHNldCAwLjUgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYjg0ZCAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcImZhZGRfYjg2N1wiKTsgICAgICAgIC8vIGFkZCAoQVkpIHRvIEZBQzFcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcGVyZm9ybSBzdWJ0cmFjdGlvbiwgRkFDMSBmcm9tIChBWSlcclxuLyogYjg1MCAqLyAgICBfYGZzdWJfYjg1MGA7ICBKU1IuYWJzIChcImNvbnVwa19iYThjXCIpOyAgICAgIC8vIHVucGFjayBtZW1vcnkgKEFZKSBpbnRvIEZBQzJcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcGVyZm9ybSBzdWJ0cmFjdGlvbiwgRkFDMSBmcm9tIEZBQzJcclxuLyogYjg1MyAqLyAgIF9gZnN1YnRfYjg1M2A7ICBMREEuenBnIChcImZhY3Nnbl8wMDY2XCIpOyAgICAgIC8vIGdldCBGQUMxIHNpZ24gKGI3KVxyXG4vKiBiODU1ICovICAgICAgICAgICAgICAgICAgIEVPUi5pbW0gKDB4ZmYpOyAgICAgICAgICAgICAgIC8vIGNvbXBsZW1lbnQgaXRcclxuLyogYjg1NyAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZhY3Nnbl8wMDY2XCIpOyAgICAgIC8vIHNhdmUgRkFDMSBzaWduIChiNylcclxuLyogYjg1OSAqLyAgICAgICAgICAgICAgICAgICBFT1IuenBnIChcImFyZ3Nnbl8wMDZlXCIpOyAgICAgIC8vIEVPUiB3aXRoIEZBQzIgc2lnbiAoYjcpXHJcbi8qIGI4NWIgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJhcmlzZ25fMDA2ZlwiKTsgICAgICAvLyBzYXZlIHNpZ24gY29tcGFyZSAoRkFDMSBFT1IgRkFDMilcclxuLyogYjg1ZCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZhY2V4cF8wMDYxXCIpOyAgICAgIC8vIGdldCBGQUMxIGV4cG9uZW50XHJcbi8qIGI4NWYgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJmYWRkdF9iODZhXCIpOyAgICAgICAvLyBhZGQgRkFDMiB0byBGQUMxIGFuZCByZXR1cm5cclxuLyogYjg2MiAqLyAgIF9gZmFkZDVfYjg2MmA7ICBKU1IuYWJzIChcIl9iOTk5XCIpOyAgICAgICAgICAgIC8vIHNoaWZ0IEZBQ1ggQSB0aW1lcyByaWdodCAoPjggc2hpZnRzKVxyXG4vKiBiODY1ICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2I4YTNcIik7ICAgICAgICAgICAgLy8gZ28gc3VidHJhY3QgbWFudGlzc2FzXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGFkZCAoQVkpIHRvIEZBQzFcclxuLyogYjg2NyAqLyAgICBfYGZhZGRfYjg2N2A7ICBKU1IuYWJzIChcImNvbnVwa19iYThjXCIpOyAgICAgIC8vIHVucGFjayBtZW1vcnkgKEFZKSBpbnRvIEZBQzJcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gYWRkIEZBQzIgdG8gRkFDMVxyXG4vKiBiODZhICovICAgX2BmYWRkdF9iODZhYDsgIEJORS5yZWwgKFwiX2I4NmZcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIEZBQzEgaXMgbm90IHplcm9cclxuLyogYjg2YyAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIm1vdmZhX2JiZmNcIik7ICAgICAgIC8vIEZBQzEgd2FzIHplcm8gc28gY29weSBGQUMyIHRvIEZBQzEgYW5kIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZBQzEgaXMgbm9uIHplcm9cclxuLyogYjg2ZiAqLyAgICAgICAgX2BfYjg2ZmA7ICBMRFguenBnIChcImZhY292XzAwNzBcIik7ICAgICAgIC8vIGdldCBGQUMxIHJvdW5kaW5nIGJ5dGVcclxuLyogYjg3MSAqLyAgICAgICAgICAgICAgICAgICBTVFguenBnIChcImptcGVyKzJfMDA1NlwiKTsgICAgIC8vIHNhdmUgYXMgRkFDMiByb3VuZGluZyBieXRlXHJcbi8qIGI4NzMgKi8gICAgICAgICAgICAgICAgICAgTERYLmltbSAoMHg2OSk7ICAgICAgICAgICAgICAgLy8gc2V0IGluZGV4IHRvIEZBQzIgZXhwb25lbnQgYWRkcmVzc1xyXG4vKiBiODc1ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiYXJnZXhwXzAwNjlcIik7ICAgICAgLy8gZ2V0IEZBQzIgZXhwb25lbnRcclxuLyogYjg3NyAqLyAgICAgICAgX2BfYjg3N2A7ICBUQVkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IGV4cG9uZW50XHJcbi8qIGI4NzggKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYjg0OFwiKTsgICAgICAgICAgICAvLyBleGl0IGlmIHplcm9cclxuLyogYjg3YSAqLyAgICAgICAgICAgICAgICAgICBTRUMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzZXQgY2FycnkgZm9yIHN1YnRyYWN0XHJcbi8qIGI4N2IgKi8gICAgICAgICAgICAgICAgICAgU0JDLnpwZyAoXCJmYWNleHBfMDA2MVwiKTsgICAgICAvLyBzdWJ0cmFjdCBGQUMxIGV4cG9uZW50XHJcbi8qIGI4N2QgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYjhhM1wiKTsgICAgICAgICAgICAvLyBpZiBlcXVhbCBnbyBhZGQgbWFudGlzc2FzXHJcbi8qIGI4N2YgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYjg5M1wiKTsgICAgICAgICAgICAvLyBpZiBGQUMyIDwgRkFDMSB0aGVuIGdvIHNoaWZ0IEZBQzIgcmlnaHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIEZBQzIgPiBGQUMxXHJcbi8qIGI4ODEgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJmYWNleHBfMDA2MVwiKTsgICAgICAvLyBzYXZlIEZBQzEgZXhwb25lbnRcclxuLyogYjg4MyAqLyAgICAgICAgICAgICAgICAgICBMRFkuenBnIChcImFyZ3Nnbl8wMDZlXCIpOyAgICAgIC8vIGdldCBGQUMyIHNpZ24gKGI3KVxyXG4vKiBiODg1ICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwiZmFjc2duXzAwNjZcIik7ICAgICAgLy8gc2F2ZSBGQUMxIHNpZ24gKGI3KVxyXG4vKiBiODg3ICovICAgICAgICAgICAgICAgICAgIEVPUi5pbW0gKDB4ZmYpOyAgICAgICAgICAgICAgIC8vIGNvbXBsZW1lbnQgQVxyXG4vKiBiODg5ICovICAgICAgICAgICAgICAgICAgIEFEQy5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vICsxLCB0d29zIGNvbXBsZW1lbnQsIGNhcnJ5IGlzIHNldFxyXG4vKiBiODhiICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIFlcclxuLyogYjg4ZCAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcImptcGVyKzJfMDA1NlwiKTsgICAgIC8vIGNsZWFyIEZBQzIgcm91bmRpbmcgYnl0ZVxyXG4vKiBiODhmICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4NjEpOyAgICAgICAgICAgICAgIC8vIHNldCBpbmRleCB0byBGQUMxIGV4cG9uZW50IGFkZHJlc3NcclxuLyogYjg5MSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9iODk3XCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBhbHdheXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGQUMyIDwgRkFDMVxyXG4vKiBiODkzICovICAgICAgICBfYF9iODkzYDsgIExEWS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIFlcclxuLyogYjg5NSAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcImZhY292XzAwNzBcIik7ICAgICAgIC8vIGNsZWFyIEZBQzEgcm91bmRpbmcgYnl0ZVxyXG4vKiBiODk3ICovICAgICAgICBfYF9iODk3YDsgIENNUC5pbW0gKDB4ZjkpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgZXhwb25lbnQgZGlmZiB3aXRoICRGOVxyXG4vKiBiODk5ICovICAgICAgICAgICAgICAgICAgIEJNSS5yZWwgKFwiZmFkZDVfYjg2MlwiKTsgICAgICAgLy8gYnJhbmNoIGlmIHJhbmdlICQ3OS0kRjhcclxuLyogYjg5YiAqLyAgICAgICAgICAgICAgICAgICBUQVkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IGV4cG9uZW50IGRpZmZlcmVuY2UgdG8gWVxyXG4vKiBiODljICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZmFjb3ZfMDA3MFwiKTsgICAgICAgLy8gZ2V0IEZBQzEgcm91bmRpbmcgYnl0ZVxyXG4vKiBiODllICovICAgICAgICAgICAgICAgICAgIExTUi56cHggKDB4MDEpOyAgICAgICAgICAgICAgIC8vIHNoaWZ0IEZBQz8gbWFudGlzc2EgMVxyXG4vKiBiOGEwICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2I5YjBcIik7ICAgICAgICAgICAgLy8gc2hpZnQgRkFDWCBZIHRpbWVzIHJpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhwb25lbnRzIGFyZSBlcXVhbCBub3cgZG8gbWFudGlzc2Egc3VidHJhY3RcclxuLyogYjhhMyAqLyAgICAgICAgX2BfYjhhM2A7ICBCSVQuenBnIChcImFyaXNnbl8wMDZmXCIpOyAgICAgIC8vIHRlc3Qgc2lnbiBjb21wYXJlIChGQUMxIEVPUiBGQUMyKVxyXG4vKiBiOGE1ICovICAgICAgICAgICAgICAgICAgIEJQTC5yZWwgKFwibm9ybWFsX2I4ZmVcIik7ICAgICAgLy8gaWYgPSBhZGQgRkFDMiBtYW50aXNzYSB0byBGQUMxIG1hbnRpc3NhIGFuZCByZXR1cm5cclxuLyogYjhhNyAqLyAgIF9gZmFkZDRfYjhhN2A7ICBMRFkuaW1tICgweDYxKTsgICAgICAgICAgICAgICAvLyBzZXQgdGhlIFkgaW5kZXggdG8gRkFDMSBleHBvbmVudCBhZGRyZXNzXHJcbi8qIGI4YTkgKi8gICAgICAgICAgICAgICAgICAgQ1BYLmltbSAoMHg2OSk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSBYIHRvIEZBQzIgZXhwb25lbnQgYWRkcmVzc1xyXG4vKiBiOGFiICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2I4YWZcIik7ICAgICAgICAgICAgLy8gaWYgPSBjb250aW51ZSwgWSA9IEZBQzEsIFggPSBGQUMyXHJcbi8qIGI4YWQgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHg2OSk7ICAgICAgICAgICAgICAgLy8gZWxzZSBzZXQgdGhlIFkgaW5kZXggdG8gRkFDMiBleHBvbmVudCBhZGRyZXNzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3VidHJhY3QgdGhlIHNtYWxsZXIgZnJvbSB0aGUgYmlnZ2VyICh0YWtlIHRoZSBzaWduIG9mXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGJpZ2dlcilcclxuLyogYjhhZiAqLyAgICAgICAgX2BfYjhhZmA7ICBTRUMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzZXQgY2FycnkgZm9yIHN1YnRyYWN0XHJcbi8qIGI4YjAgKi8gICAgICAgICAgICAgICAgICAgRU9SLmltbSAoMHhmZik7ICAgICAgICAgICAgICAgLy8gb25lcyBjb21wbGVtZW50IEFcclxuLyogYjhiMiAqLyAgICAgICAgICAgICAgICAgICBBREMuenBnIChcImptcGVyKzJfMDA1NlwiKTsgICAgIC8vIGFkZCBGQUMyIHJvdW5kaW5nIGJ5dGVcclxuLyogYjhiNCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZhY292XzAwNzBcIik7ICAgICAgIC8vIHNhdmUgRkFDMSByb3VuZGluZyBieXRlXHJcbi8qIGI4YjYgKi8gICAgICAgICAgICAgICAgICAgTERBLmFieSAoXCJhZHJheTErMV8wMDA0XCIpOyAgICAvLyBnZXQgRkFDWSBtYW50aXNzYSA0XHJcbi8qIGI4YjkgKi8gICAgICAgICAgICAgICAgICAgU0JDLnpweCAoMHgwNCk7ICAgICAgICAgICAgICAgLy8gc3VidHJhY3QgRkFDWCBtYW50aXNzYSA0XHJcbi8qIGI4YmIgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmYWNobyszXzAwNjVcIik7ICAgICAvLyBzYXZlIEZBQzEgbWFudGlzc2EgNFxyXG4vKiBiOGJkICovICAgICAgICAgICAgICAgICAgIExEQS5hYnkgKFwiYWRyYXkxKzBfMDAwM1wiKTsgICAgLy8gZ2V0IEZBQ1kgbWFudGlzc2EgM1xyXG4vKiBiOGMwICovICAgICAgICAgICAgICAgICAgIFNCQy56cHggKDB4MDMpOyAgICAgICAgICAgICAgIC8vIHN1YnRyYWN0IEZBQ1ggbWFudGlzc2EgM1xyXG4vKiBiOGMyICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZmFjaG8rMl8wMDY0XCIpOyAgICAgLy8gc2F2ZSBGQUMxIG1hbnRpc3NhIDNcclxuLyogYjhjNCAqLyAgICAgICAgICAgICAgICAgICBMREEuYWJ5IChcIl8wMDAyXCIpOyAgICAgICAgICAgIC8vIGdldCBGQUNZIG1hbnRpc3NhIDJcclxuLyogYjhjNyAqLyAgICAgICAgICAgICAgICAgICBTQkMuenB4ICgweDAyKTsgICAgICAgICAgICAgICAvLyBzdWJ0cmFjdCBGQUNYIG1hbnRpc3NhIDJcclxuLyogYjhjOSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZhY2hvKzFfMDA2M1wiKTsgICAgIC8vIHNhdmUgRkFDMSBtYW50aXNzYSAyXHJcbi8qIGI4Y2IgKi8gICAgICAgICAgICAgICAgICAgTERBLmFieSAoXCJyNjUxMF8wMDAxXCIpOyAgICAgICAvLyBnZXQgRkFDWSBtYW50aXNzYSAxXHJcbi8qIGI4Y2UgKi8gICAgICAgICAgICAgICAgICAgU0JDLnpweCAoMHgwMSk7ICAgICAgICAgICAgICAgLy8gc3VidHJhY3QgRkFDWCBtYW50aXNzYSAxXHJcbi8qIGI4ZDAgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmYWNobyswXzAwNjJcIik7ICAgICAvLyBzYXZlIEZBQzEgbWFudGlzc2EgMVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBkbyBBQlMgYW5kIG5vcm1hbGlzZSBGQUMxXHJcbi8qIGI4ZDIgKi8gICAgICAgIF9gX2I4ZDJgOyAgQkNTLnJlbCAoXCJfYjhkN1wiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbnVtYmVyIGlzICt2ZVxyXG4vKiBiOGQ0ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwibmVnZmFjX2I5NDdcIik7ICAgICAgLy8gbmVnYXRlIEZBQzFcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gbm9ybWFsaXNlIEZBQzFcclxuLyogYjhkNyAqLyAgICAgICAgX2BfYjhkN2A7ICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBZXHJcbi8qIGI4ZDkgKi8gICAgICAgICAgICAgICAgICAgVFlBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgQVxyXG4vKiBiOGRhICovICAgICAgICAgICAgICAgICAgIENMQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIGNhcnJ5IGZvciBhZGRcclxuLyogYjhkYiAqLyAgICAgICAgX2BfYjhkYmA7ICBMRFguenBnIChcImZhY2hvKzBfMDA2MlwiKTsgICAgIC8vIGdldCBGQUMxIG1hbnRpc3NhIDFcclxuLyogYjhkZCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9iOTI5XCIpOyAgICAgICAgICAgIC8vIGlmIG5vdCB6ZXJvIG5vcm1hbGlzZSBGQUMxXHJcbi8qIGI4ZGYgKi8gICAgICAgICAgICAgICAgICAgTERYLnpwZyAoXCJmYWNobysxXzAwNjNcIik7ICAgICAvLyBnZXQgRkFDMSBtYW50aXNzYSAyXHJcbi8qIGI4ZTEgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJmYWNobyswXzAwNjJcIik7ICAgICAvLyBzYXZlIEZBQzEgbWFudGlzc2EgMVxyXG4vKiBiOGUzICovICAgICAgICAgICAgICAgICAgIExEWC56cGcgKFwiZmFjaG8rMl8wMDY0XCIpOyAgICAgLy8gZ2V0IEZBQzEgbWFudGlzc2EgM1xyXG4vKiBiOGU1ICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwiZmFjaG8rMV8wMDYzXCIpOyAgICAgLy8gc2F2ZSBGQUMxIG1hbnRpc3NhIDJcclxuLyogYjhlNyAqLyAgICAgICAgICAgICAgICAgICBMRFguenBnIChcImZhY2hvKzNfMDA2NVwiKTsgICAgIC8vIGdldCBGQUMxIG1hbnRpc3NhIDRcclxuLyogYjhlOSAqLyAgICAgICAgICAgICAgICAgICBTVFguenBnIChcImZhY2hvKzJfMDA2NFwiKTsgICAgIC8vIHNhdmUgRkFDMSBtYW50aXNzYSAzXHJcbi8qIGI4ZWIgKi8gICAgICAgICAgICAgICAgICAgTERYLnpwZyAoXCJmYWNvdl8wMDcwXCIpOyAgICAgICAvLyBnZXQgRkFDMSByb3VuZGluZyBieXRlXHJcbi8qIGI4ZWQgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJmYWNobyszXzAwNjVcIik7ICAgICAvLyBzYXZlIEZBQzEgbWFudGlzc2EgNFxyXG4vKiBiOGVmICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwiZmFjb3ZfMDA3MFwiKTsgICAgICAgLy8gY2xlYXIgRkFDMSByb3VuZGluZyBieXRlXHJcbi8qIGI4ZjEgKi8gICAgICAgICAgICAgICAgICAgQURDLmltbSAoMHgwOCk7ICAgICAgICAgICAgICAgLy8gYWRkIHggdG8gZXhwb25lbnQgb2Zmc2V0XHJcbi8qIGI4ZjMgKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHgyMCk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoICQyMCwgbWF4IG9mZnNldCwgYWxsIGJpdHMgd291bGQgYmUgPSAwXHJcbi8qIGI4ZjUgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYjhkYlwiKTsgICAgICAgICAgICAvLyBsb29wIGlmIG5vdCBtYXhcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY2xlYXIgRkFDMSBleHBvbmVudCBhbmQgc2lnblxyXG4vKiBiOGY3ICovICAgICAgICBfYF9iOGY3YDsgIExEQS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIEFcclxuLyogYjhmOSAqLyAgICAgICAgX2BfYjhmOWA7ICBTVEEuenBnIChcImZhY2V4cF8wMDYxXCIpOyAgICAgIC8vIHNldCBGQUMxIGV4cG9uZW50XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHNhdmUgRkFDMSBzaWduXHJcbi8qIGI4ZmIgKi8gICAgICAgIF9gX2I4ZmJgOyAgU1RBLnpwZyAoXCJmYWNzZ25fMDA2NlwiKTsgICAgICAvLyBzYXZlIEZBQzEgc2lnbiAoYjcpXHJcbi8qIGI4ZmQgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gYWRkIEZBQzIgbWFudGlzc2EgdG8gRkFDMSBtYW50aXNzYVxyXG4vKiBiOGZlICovICBfYG5vcm1hbF9iOGZlYDsgIEFEQy56cGcgKFwiam1wZXIrMl8wMDU2XCIpOyAgICAgLy8gYWRkIEZBQzIgcm91bmRpbmcgYnl0ZVxyXG4vKiBiOTAwICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZmFjb3ZfMDA3MFwiKTsgICAgICAgLy8gc2F2ZSBGQUMxIHJvdW5kaW5nIGJ5dGVcclxuLyogYjkwMiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZhY2hvKzNfMDA2NVwiKTsgICAgIC8vIGdldCBGQUMxIG1hbnRpc3NhIDRcclxuLyogYjkwNCAqLyAgICAgICAgICAgICAgICAgICBBREMuenBnIChcImFyZ2hvKzNfMDA2ZFwiKTsgICAgIC8vIGFkZCBGQUMyIG1hbnRpc3NhIDRcclxuLyogYjkwNiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZhY2hvKzNfMDA2NVwiKTsgICAgIC8vIHNhdmUgRkFDMSBtYW50aXNzYSA0XHJcbi8qIGI5MDggKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJmYWNobysyXzAwNjRcIik7ICAgICAvLyBnZXQgRkFDMSBtYW50aXNzYSAzXHJcbi8qIGI5MGEgKi8gICAgICAgICAgICAgICAgICAgQURDLnpwZyAoXCJhcmdobysyXzAwNmNcIik7ICAgICAvLyBhZGQgRkFDMiBtYW50aXNzYSAzXHJcbi8qIGI5MGMgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmYWNobysyXzAwNjRcIik7ICAgICAvLyBzYXZlIEZBQzEgbWFudGlzc2EgM1xyXG4vKiBiOTBlICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZmFjaG8rMV8wMDYzXCIpOyAgICAgLy8gZ2V0IEZBQzEgbWFudGlzc2EgMlxyXG4vKiBiOTEwICovICAgICAgICAgICAgICAgICAgIEFEQy56cGcgKFwiYXJnaG8rMV8wMDZiXCIpOyAgICAgLy8gYWRkIEZBQzIgbWFudGlzc2EgMlxyXG4vKiBiOTEyICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZmFjaG8rMV8wMDYzXCIpOyAgICAgLy8gc2F2ZSBGQUMxIG1hbnRpc3NhIDJcclxuLyogYjkxNCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZhY2hvKzBfMDA2MlwiKTsgICAgIC8vIGdldCBGQUMxIG1hbnRpc3NhIDFcclxuLyogYjkxNiAqLyAgICAgICAgICAgICAgICAgICBBREMuenBnIChcImFyZ2hvKzBfMDA2YVwiKTsgICAgIC8vIGFkZCBGQUMyIG1hbnRpc3NhIDFcclxuLyogYjkxOCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZhY2hvKzBfMDA2MlwiKTsgICAgIC8vIHNhdmUgRkFDMSBtYW50aXNzYSAxXHJcbi8qIGI5MWEgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfYjkzNlwiKTsgICAgICAgICAgICAvLyB0ZXN0IGFuZCBub3JtYWxpc2UgRkFDMSBmb3IgQz0wLzFcclxuLyogYjkxZCAqLyAgICAgICAgX2BfYjkxZGA7ICBBREMuaW1tICgweDAxKTsgICAgICAgICAgICAgICAvLyBhZGQgMSB0byBleHBvbmVudCBvZmZzZXRcclxuLyogYjkxZiAqLyAgICAgICAgICAgICAgICAgICBBU0wuenBnIChcImZhY292XzAwNzBcIik7ICAgICAgIC8vIHNoaWZ0IEZBQzEgcm91bmRpbmcgYnl0ZVxyXG4vKiBiOTIxICovICAgICAgICAgICAgICAgICAgIFJPTC56cGcgKFwiZmFjaG8rM18wMDY1XCIpOyAgICAgLy8gc2hpZnQgRkFDMSBtYW50aXNzYSA0XHJcbi8qIGI5MjMgKi8gICAgICAgICAgICAgICAgICAgUk9MLnpwZyAoXCJmYWNobysyXzAwNjRcIik7ICAgICAvLyBzaGlmdCBGQUMxIG1hbnRpc3NhIDNcclxuLyogYjkyNSAqLyAgICAgICAgICAgICAgICAgICBST0wuenBnIChcImZhY2hvKzFfMDA2M1wiKTsgICAgIC8vIHNoaWZ0IEZBQzEgbWFudGlzc2EgMlxyXG4vKiBiOTI3ICovICAgICAgICAgICAgICAgICAgIFJPTC56cGcgKFwiZmFjaG8rMF8wMDYyXCIpOyAgICAgLy8gc2hpZnQgRkFDMSBtYW50aXNzYSAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9ybWFsaXNlIEZBQzFcclxuLyogYjkyOSAqLyAgICAgICAgX2BfYjkyOWA7ICBCUEwucmVsIChcIl9iOTFkXCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgbm90IG5vcm1hbGlzZWRcclxuLyogYjkyYiAqLyAgICAgICAgICAgICAgICAgICBTRUMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzZXQgY2FycnkgZm9yIHN1YnRyYWN0XHJcbi8qIGI5MmMgKi8gICAgICAgICAgICAgICAgICAgU0JDLnpwZyAoXCJmYWNleHBfMDA2MVwiKTsgICAgICAvLyBzdWJ0cmFjdCBGQUMxIGV4cG9uZW50XHJcbi8qIGI5MmUgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfYjhmN1wiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgdW5kZXJmbG93IChzZXQgcmVzdWx0ID0gJDApXHJcbi8qIGI5MzAgKi8gICAgICAgICAgICAgICAgICAgRU9SLmltbSAoMHhmZik7ICAgICAgICAgICAgICAgLy8gY29tcGxlbWVudCBleHBvbmVudFxyXG4vKiBiOTMyICovICAgICAgICAgICAgICAgICAgIEFEQy5pbW0gKDB4MDEpOyAgICAgICAgICAgICAgIC8vICsxICh0d29zIGNvbXBsZW1lbnQpXHJcbi8qIGI5MzQgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmYWNleHBfMDA2MVwiKTsgICAgICAvLyBzYXZlIEZBQzEgZXhwb25lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0ZXN0IGFuZCBub3JtYWxpc2UgRkFDMSBmb3IgQz0wLzFcclxuLyogYjkzNiAqLyAgICAgICAgX2BfYjkzNmA7ICBCQ0MucmVsIChcIl9iOTQ2XCIpOyAgICAgICAgICAgIC8vIGV4aXQgaWYgbm8gb3ZlcmZsb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3JtYWxpc2UgRkFDMSBmb3IgQz0xXHJcbi8qIGI5MzggKi8gICAgICAgIF9gX2I5MzhgOyAgSU5DLnpwZyAoXCJmYWNleHBfMDA2MVwiKTsgICAgICAvLyBpbmNyZW1lbnQgRkFDMSBleHBvbmVudFxyXG4vKiBiOTNhICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwib3ZlcnJfYjk3ZVwiKTsgICAgICAgLy8gaWYgemVybyBkbyBvdmVyZmxvdyBlcnJvciB0aGVuIHdhcm0gc3RhcnRcclxuLyogYjkzYyAqLyAgICAgICAgICAgICAgICAgICBST1IuenBnIChcImZhY2hvKzBfMDA2MlwiKTsgICAgIC8vIHNoaWZ0IEZBQzEgbWFudGlzc2EgMVxyXG4vKiBiOTNlICovICAgICAgICAgICAgICAgICAgIFJPUi56cGcgKFwiZmFjaG8rMV8wMDYzXCIpOyAgICAgLy8gc2hpZnQgRkFDMSBtYW50aXNzYSAyXHJcbi8qIGI5NDAgKi8gICAgICAgICAgICAgICAgICAgUk9SLnpwZyAoXCJmYWNobysyXzAwNjRcIik7ICAgICAvLyBzaGlmdCBGQUMxIG1hbnRpc3NhIDNcclxuLyogYjk0MiAqLyAgICAgICAgICAgICAgICAgICBST1IuenBnIChcImZhY2hvKzNfMDA2NVwiKTsgICAgIC8vIHNoaWZ0IEZBQzEgbWFudGlzc2EgNFxyXG4vKiBiOTQ0ICovICAgICAgICAgICAgICAgICAgIFJPUi56cGcgKFwiZmFjb3ZfMDA3MFwiKTsgICAgICAgLy8gc2hpZnQgRkFDMSByb3VuZGluZyBieXRlXHJcbi8qIGI5NDYgKi8gICAgICAgIF9gX2I5NDZgOyAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gbmVnYXRlIEZBQzFcclxuLyogYjk0NyAqLyAgX2BuZWdmYWNfYjk0N2A7ICBMREEuenBnIChcImZhY3Nnbl8wMDY2XCIpOyAgICAgIC8vIGdldCBGQUMxIHNpZ24gKGI3KVxyXG4vKiBiOTQ5ICovICAgICAgICAgICAgICAgICAgIEVPUi5pbW0gKDB4ZmYpOyAgICAgICAgICAgICAgIC8vIGNvbXBsZW1lbnQgaXRcclxuLyogYjk0YiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZhY3Nnbl8wMDY2XCIpOyAgICAgIC8vIHNhdmUgRkFDMSBzaWduIChiNylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0d29zIGNvbXBsZW1lbnQgRkFDMSBtYW50aXNzYVxyXG4vKiBiOTRkICovICAgICAgICBfYF9iOTRkYDsgIExEQS56cGcgKFwiZmFjaG8rMF8wMDYyXCIpOyAgICAgLy8gZ2V0IEZBQzEgbWFudGlzc2EgMVxyXG4vKiBiOTRmICovICAgICAgICAgICAgICAgICAgIEVPUi5pbW0gKDB4ZmYpOyAgICAgICAgICAgICAgIC8vIGNvbXBsZW1lbnQgaXRcclxuLyogYjk1MSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZhY2hvKzBfMDA2MlwiKTsgICAgIC8vIHNhdmUgRkFDMSBtYW50aXNzYSAxXHJcbi8qIGI5NTMgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJmYWNobysxXzAwNjNcIik7ICAgICAvLyBnZXQgRkFDMSBtYW50aXNzYSAyXHJcbi8qIGI5NTUgKi8gICAgICAgICAgICAgICAgICAgRU9SLmltbSAoMHhmZik7ICAgICAgICAgICAgICAgLy8gY29tcGxlbWVudCBpdFxyXG4vKiBiOTU3ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZmFjaG8rMV8wMDYzXCIpOyAgICAgLy8gc2F2ZSBGQUMxIG1hbnRpc3NhIDJcclxuLyogYjk1OSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZhY2hvKzJfMDA2NFwiKTsgICAgIC8vIGdldCBGQUMxIG1hbnRpc3NhIDNcclxuLyogYjk1YiAqLyAgICAgICAgICAgICAgICAgICBFT1IuaW1tICgweGZmKTsgICAgICAgICAgICAgICAvLyBjb21wbGVtZW50IGl0XHJcbi8qIGI5NWQgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmYWNobysyXzAwNjRcIik7ICAgICAvLyBzYXZlIEZBQzEgbWFudGlzc2EgM1xyXG4vKiBiOTVmICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZmFjaG8rM18wMDY1XCIpOyAgICAgLy8gZ2V0IEZBQzEgbWFudGlzc2EgNFxyXG4vKiBiOTYxICovICAgICAgICAgICAgICAgICAgIEVPUi5pbW0gKDB4ZmYpOyAgICAgICAgICAgICAgIC8vIGNvbXBsZW1lbnQgaXRcclxuLyogYjk2MyAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZhY2hvKzNfMDA2NVwiKTsgICAgIC8vIHNhdmUgRkFDMSBtYW50aXNzYSA0XHJcbi8qIGI5NjUgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJmYWNvdl8wMDcwXCIpOyAgICAgICAvLyBnZXQgRkFDMSByb3VuZGluZyBieXRlXHJcbi8qIGI5NjcgKi8gICAgICAgICAgICAgICAgICAgRU9SLmltbSAoMHhmZik7ICAgICAgICAgICAgICAgLy8gY29tcGxlbWVudCBpdFxyXG4vKiBiOTY5ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZmFjb3ZfMDA3MFwiKTsgICAgICAgLy8gc2F2ZSBGQUMxIHJvdW5kaW5nIGJ5dGVcclxuLyogYjk2YiAqLyAgICAgICAgICAgICAgICAgICBJTkMuenBnIChcImZhY292XzAwNzBcIik7ICAgICAgIC8vIGluY3JlbWVudCBGQUMxIHJvdW5kaW5nIGJ5dGVcclxuLyogYjk2ZCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9iOTdkXCIpOyAgICAgICAgICAgIC8vIGV4aXQgaWYgbm8gb3ZlcmZsb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgRkFDMSBtYW50aXNzYVxyXG4vKiBiOTZmICovICAgICAgICBfYF9iOTZmYDsgIElOQy56cGcgKFwiZmFjaG8rM18wMDY1XCIpOyAgICAgLy8gaW5jcmVtZW50IEZBQzEgbWFudGlzc2EgNFxyXG4vKiBiOTcxICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2I5N2RcIik7ICAgICAgICAgICAgLy8gZmluaXNoZWQgaWYgbm8gcm9sbG92ZXJcclxuLyogYjk3MyAqLyAgICAgICAgICAgICAgICAgICBJTkMuenBnIChcImZhY2hvKzJfMDA2NFwiKTsgICAgIC8vIGluY3JlbWVudCBGQUMxIG1hbnRpc3NhIDNcclxuLyogYjk3NSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9iOTdkXCIpOyAgICAgICAgICAgIC8vIGZpbmlzaGVkIGlmIG5vIHJvbGxvdmVyXHJcbi8qIGI5NzcgKi8gICAgICAgICAgICAgICAgICAgSU5DLnpwZyAoXCJmYWNobysxXzAwNjNcIik7ICAgICAvLyBpbmNyZW1lbnQgRkFDMSBtYW50aXNzYSAyXHJcbi8qIGI5NzkgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYjk3ZFwiKTsgICAgICAgICAgICAvLyBmaW5pc2hlZCBpZiBubyByb2xsb3ZlclxyXG4vKiBiOTdiICovICAgICAgICAgICAgICAgICAgIElOQy56cGcgKFwiZmFjaG8rMF8wMDYyXCIpOyAgICAgLy8gaW5jcmVtZW50IEZBQzEgbWFudGlzc2EgMVxyXG4vKiBiOTdkICovICAgICAgICBfYF9iOTdkYDsgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGRvIG92ZXJmbG93IGVycm9yIHRoZW4gd2FybSBzdGFydFxyXG4vKiBiOTdlICovICAgX2BvdmVycl9iOTdlYDsgIExEWC5pbW0gKDB4MGYpOyAgICAgICAgICAgICAgIC8vIGVycm9yICQwRiwgb3ZlcmZsb3cgZXJyb3JcclxuLyogYjk4MCAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcImVycm9yX2E0MzdcIik7ICAgICAgIC8vIGRvIGVycm9yICNYIHRoZW4gd2FybSBzdGFydFxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzaGlmdCBGQ0F0ZW1wIDw8IEErOCB0aW1lc1xyXG4vKiBiOTgzICovICBfYG11bHNoZl9iOTgzYDsgIExEWC5pbW0gKDB4MjUpOyAgICAgICAgICAgICAgIC8vIHNldCB0aGUgb2Zmc2V0IHRvIEZBQ3RlbXBcclxuLyogYjk4NSAqLyAgICAgICAgX2BfYjk4NWA7ICBMRFkuenB4ICgweDA0KTsgICAgICAgICAgICAgICAvLyBnZXQgRkFDWCBtYW50aXNzYSA0XHJcbi8qIGI5ODcgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJmYWNvdl8wMDcwXCIpOyAgICAgICAvLyBzYXZlIGFzIEZBQzEgcm91bmRpbmcgYnl0ZVxyXG4vKiBiOTg5ICovICAgICAgICAgICAgICAgICAgIExEWS56cHggKDB4MDMpOyAgICAgICAgICAgICAgIC8vIGdldCBGQUNYIG1hbnRpc3NhIDNcclxuLyogYjk4YiAqLyAgICAgICAgICAgICAgICAgICBTVFkuenB4ICgweDA0KTsgICAgICAgICAgICAgICAvLyBzYXZlIEZBQ1ggbWFudGlzc2EgNFxyXG4vKiBiOThkICovICAgICAgICAgICAgICAgICAgIExEWS56cHggKDB4MDIpOyAgICAgICAgICAgICAgIC8vIGdldCBGQUNYIG1hbnRpc3NhIDJcclxuLyogYjk4ZiAqLyAgICAgICAgICAgICAgICAgICBTVFkuenB4ICgweDAzKTsgICAgICAgICAgICAgICAvLyBzYXZlIEZBQ1ggbWFudGlzc2EgM1xyXG4vKiBiOTkxICovICAgICAgICAgICAgICAgICAgIExEWS56cHggKDB4MDEpOyAgICAgICAgICAgICAgIC8vIGdldCBGQUNYIG1hbnRpc3NhIDFcclxuLyogYjk5MyAqLyAgICAgICAgICAgICAgICAgICBTVFkuenB4ICgweDAyKTsgICAgICAgICAgICAgICAvLyBzYXZlIEZBQ1ggbWFudGlzc2EgMlxyXG4vKiBiOTk1ICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwiYml0c18wMDY4XCIpOyAgICAgICAgLy8gZ2V0IEZBQzEgb3ZlcmZsb3cgYnl0ZVxyXG4vKiBiOTk3ICovICAgICAgICAgICAgICAgICAgIFNUWS56cHggKDB4MDEpOyAgICAgICAgICAgICAgIC8vIHNhdmUgRkFDWCBtYW50aXNzYSAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hpZnQgRkFDWCAtQSB0aW1lcyByaWdodCAoPiA4IHNoaWZ0cylcclxuLyogYjk5OSAqLyAgICAgICAgX2BfYjk5OWA7ICBBREMuaW1tICgweDA4KTsgICAgICAgICAgICAgICAvLyBhZGQgOCB0byBzaGlmdCBjb3VudFxyXG4vKiBiOTliICovICAgICAgICAgICAgICAgICAgIEJNSS5yZWwgKFwiX2I5ODVcIik7ICAgICAgICAgICAgLy8gZ28gZG8gOCBzaGlmdCBpZiBzdGlsbCAtdmVcclxuLyogYjk5ZCAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9iOTg1XCIpOyAgICAgICAgICAgIC8vIGdvIGRvIDggc2hpZnQgaWYgemVyb1xyXG4vKiBiOTlmICovICAgICAgICAgICAgICAgICAgIFNCQy5pbW0gKDB4MDgpOyAgICAgICAgICAgICAgIC8vIGVsc2Ugc3VidHJhY3QgOCBhZ2FpblxyXG4vKiBiOWExICovICAgICAgICAgICAgICAgICAgIFRBWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgY291bnQgdG8gWVxyXG4vKiBiOWEyICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZmFjb3ZfMDA3MFwiKTsgICAgICAgLy8gZ2V0IEZBQzEgcm91bmRpbmcgYnl0ZVxyXG4vKiBiOWE0ICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2I5YmFcIik7XHJcbi8qIGI5YTYgKi8gICAgICAgIF9gX2I5YTZgOyAgQVNMLnpweCAoMHgwMSk7ICAgICAgICAgICAgICAgLy8gc2hpZnQgRkFDWCBtYW50aXNzYSAxXHJcbi8qIGI5YTggKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYjlhY1wiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgK3ZlXHJcbi8qIGI5YWEgKi8gICAgICAgICAgICAgICAgICAgSU5DLnpweCAoMHgwMSk7ICAgICAgICAgICAgICAgLy8gdGhpcyBzZXRzIGI3IGV2ZW50dWFsbHlcclxuLyogYjlhYyAqLyAgICAgICAgX2BfYjlhY2A7ICBST1IuenB4ICgweDAxKTsgICAgICAgICAgICAgICAvLyBzaGlmdCBGQUNYIG1hbnRpc3NhIDEgKGNvcnJlY3QgZm9yIEFTTClcclxuLyogYjlhZSAqLyAgICAgICAgICAgICAgICAgICBST1IuenB4ICgweDAxKTsgICAgICAgICAgICAgICAvLyBzaGlmdCBGQUNYIG1hbnRpc3NhIDEgKHB1dCBjYXJyeSBpbiBiNylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaGlmdCBGQUNYIFkgdGltZXMgcmlnaHRcclxuLyogYjliMCAqLyAgICAgICAgX2BfYjliMGA7ICBST1IuenB4ICgweDAyKTsgICAgICAgICAgICAgICAvLyBzaGlmdCBGQUNYIG1hbnRpc3NhIDJcclxuLyogYjliMiAqLyAgICAgICAgICAgICAgICAgICBST1IuenB4ICgweDAzKTsgICAgICAgICAgICAgICAvLyBzaGlmdCBGQUNYIG1hbnRpc3NhIDNcclxuLyogYjliNCAqLyAgICAgICAgICAgICAgICAgICBST1IuenB4ICgweDA0KTsgICAgICAgICAgICAgICAvLyBzaGlmdCBGQUNYIG1hbnRpc3NhIDRcclxuLyogYjliNiAqLyAgICAgICAgICAgICAgICAgICBST1IuYWNjICgpOyAgICAgICAgICAgICAgICAgICAvLyBzaGlmdCBGQUNYIHJvdW5kaW5nIGJ5dGVcclxuLyogYjliNyAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgZXhwb25lbnQgZGlmZlxyXG4vKiBiOWI4ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2I5YTZcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIHJhbmdlIGFkanVzdCBub3QgY29tcGxldGVcclxuLyogYjliYSAqLyAgICAgICAgX2BfYjliYWA7ICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBqdXN0IGNsZWFyIGl0XHJcbi8qIGI5YmIgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY29uc3RhbnRzIGFuZCBzZXJpZXMgZm9yIExPRyhuKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDFcclxuLyogYjliYyAqLyAgICBfYGZvbmVfYjliY2A7ICBfLmJ5dGVzKDB4ODEsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDApO1xyXG4vKiBiOWMxICovICBfYGxvZ2NuMl9iOWMxYDsgIF8uYnl0ZXMoMHgwMyk7ICAgICAgICAgICAgICAgIC8vIHNlcmllcyBjb3VudGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIC40MzQyNTU5NDJcclxuLyogYjljMiAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4N2YsIDB4NWUsIDB4NTYsIDB4Y2IsIDB4NzkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAuNTc2NTg0NTQxXHJcbi8qIGI5YzcgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDgwLCAweDEzLCAweDliLCAweDBiLCAweDY0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgLjk2MTgwMDc1OVxyXG4vKiBiOWNjICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg4MCwgMHg3NiwgMHgzOCwgMHg5MywgMHgxNik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMi44ODUzOTAwN1xyXG4vKiBiOWQxICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg4MiwgMHgzOCwgMHhhYSwgMHgzYiwgMHgyMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIC43MDcxMDY3ODEgPSAxL1NRUigyKVxyXG4vKiBiOWQ2ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg4MCwgMHgzNSwgMHgwNCwgMHhmMywgMHgzNCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMS40MTQyMTM1NiA9IFNRUigyKVxyXG4vKiBiOWRiICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg4MSwgMHgzNSwgMHgwNCwgMHhmMywgMHgzNCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLS41XHJcbi8qIGI5ZTAgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDgwLCAweDgwLCAweDAwLCAweDAwLCAweDAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgLjY5MzE0NzE4MSAgPSAgTE9HKDIpXHJcbi8qIGI5ZTUgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDgwLCAweDMxLCAweDcyLCAweDE3LCAweGY4KTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcGVyZm9ybSBMT0coKVxyXG4vKiBiOWVhICovICAgICBfYGxvZ19iOWVhYDsgIEpTUi5hYnMgKFwic2lnbl9iYzJiXCIpOyAgICAgICAgLy8gdGVzdCBzaWduIGFuZCB6ZXJvXHJcbi8qIGI5ZWQgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYjlmMVwiKTsgICAgICAgICAgICAvLyBpZiB6ZXJvIGRvIGlsbGVnYWwgcXVhbnRpdHkgZXJyb3IgdGhlbiB3YXJtIHN0YXJ0XHJcbi8qIGI5ZWYgKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfYjlmNFwiKTsgICAgICAgICAgICAvLyBza2lwIGVycm9yIGlmICt2ZVxyXG4vKiBiOWYxICovICAgICAgICBfYF9iOWYxYDsgIEpNUC5hYnMgKFwiZmNlcnJfYjI0OFwiKTsgICAgICAgLy8gZG8gaWxsZWdhbCBxdWFudGl0eSBlcnJvciB0aGVuIHdhcm0gc3RhcnRcclxuLyogYjlmNCAqLyAgICAgICAgX2BfYjlmNGA7ICBMREEuenBnIChcImZhY2V4cF8wMDYxXCIpOyAgICAgIC8vIGdldCBGQUMxIGV4cG9uZW50XHJcbi8qIGI5ZjYgKi8gICAgICAgICAgICAgICAgICAgU0JDLmltbSAoMHg3Zik7ICAgICAgICAgICAgICAgLy8gbm9ybWFsaXNlIGl0XHJcbi8qIGI5ZjggKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBpdFxyXG4vKiBiOWY5ICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4ODApOyAgICAgICAgICAgICAgIC8vIHNldCBleHBvbmVudCB0byB6ZXJvXHJcbi8qIGI5ZmIgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmYWNleHBfMDA2MVwiKTsgICAgICAvLyBzYXZlIEZBQzEgZXhwb25lbnRcclxuLyogYjlmZCAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweGQ2KTsgICAgICAgICAgICAgICAvLyBwb2ludGVyIHRvIDEvcm9vdCAyIGxvdyBieXRlXHJcbi8qIGI5ZmYgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHhiOSk7ICAgICAgICAgICAgICAgLy8gcG9pbnRlciB0byAxL3Jvb3QgMiBoaWdoIGJ5dGVcclxuLyogYmEwMSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImZhZGRfYjg2N1wiKTsgICAgICAgIC8vIGFkZCAoQVkpIHRvIEZBQzEgKDEvcm9vdDIpXHJcbi8qIGJhMDQgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHhkYik7ICAgICAgICAgICAgICAgLy8gcG9pbnRlciB0byByb290IDIgbG93IGJ5dGVcclxuLyogYmEwNiAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweGI5KTsgICAgICAgICAgICAgICAvLyBwb2ludGVyIHRvIHJvb3QgMiBoaWdoIGJ5dGVcclxuLyogYmEwOCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImZkaXZfYmIwZlwiKTsgICAgICAgIC8vIGNvbnZlcnQgQVkgYW5kIGRvIChBWSkvRkFDMSAocm9vdDIvKHgrKDEvcm9vdDIpKSlcclxuLyogYmEwYiAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweGJjKTsgICAgICAgICAgICAgICAvLyBwb2ludGVyIHRvIDEgbG93IGJ5dGVcclxuLyogYmEwZCAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweGI5KTsgICAgICAgICAgICAgICAvLyBwb2ludGVyIHRvIDEgaGlnaCBieXRlXHJcbi8qIGJhMGYgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJmc3ViX2I4NTBcIik7ICAgICAgICAvLyBzdWJ0cmFjdCBGQUMxICgocm9vdDIvKHgrKDEvcm9vdDIpKSktMSkgZnJvbSAoQVkpXHJcbi8qIGJhMTIgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHhjMSk7ICAgICAgICAgICAgICAgLy8gcG9pbnRlciB0byBzZXJpZXMgZm9yIExPRyhuKSBsb3cgYnl0ZVxyXG4vKiBiYTE0ICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4YjkpOyAgICAgICAgICAgICAgIC8vIHBvaW50ZXIgdG8gc2VyaWVzIGZvciBMT0cobikgaGlnaCBieXRlXHJcbi8qIGJhMTYgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJwb2x5eF9lMDQzXCIpOyAgICAgICAvLyBeMiB0aGVuIHNlcmllcyBldmFsdWF0aW9uXHJcbi8qIGJhMTkgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHhlMCk7ICAgICAgICAgICAgICAgLy8gcG9pbnRlciB0byAtMC41IGxvdyBieXRlXHJcbi8qIGJhMWIgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHhiOSk7ICAgICAgICAgICAgICAgLy8gcG9pbnRlciB0byAtMC41IGhpZ2ggYnl0ZVxyXG4vKiBiYTFkICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiZmFkZF9iODY3XCIpOyAgICAgICAgLy8gYWRkIChBWSkgdG8gRkFDMVxyXG4vKiBiYTIwICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgRkFDMSBleHBvbmVudFxyXG4vKiBiYTIxICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiZmlubG9nX2JkN2VcIik7ICAgICAgLy8gZXZhbHVhdGUgbmV3IEFTQ0lJIGRpZ2l0XHJcbi8qIGJhMjQgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHhlNSk7ICAgICAgICAgICAgICAgLy8gcG9pbnRlciB0byBMT0coMikgbG93IGJ5dGVcclxuLyogYmEyNiAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweGI5KTsgICAgICAgICAgICAgICAvLyBwb2ludGVyIHRvIExPRygyKSBoaWdoIGJ5dGVcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gZG8gY29udmVydCBBWSwgRkNBMSooQVkpXHJcbi8qIGJhMjggKi8gICBfYGZtdWx0X2JhMjhgOyAgSlNSLmFicyAoXCJjb251cGtfYmE4Y1wiKTsgICAgICAvLyB1bnBhY2sgbWVtb3J5IChBWSkgaW50byBGQUMyXHJcbi8qIGJhMmIgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYmEzMFwiKTsgICAgICAgICAgICAvLyBtdWx0aXBseSBGQUMxIGJ5IEZBQzIgPz9cclxuLyogYmEyZCAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9iYThiXCIpOyAgICAgICAgICAgIC8vIGV4aXQgaWYgemVyb1xyXG4vKiBiYTMwICovICAgICAgICBfYF9iYTMwYDsgIEpTUi5hYnMgKFwibXVsZGl2X2JhYjdcIik7ICAgICAgLy8gdGVzdCBhbmQgYWRqdXN0IGFjY3VtdWxhdG9yc1xyXG4vKiBiYTMzICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIEFcclxuLyogYmEzNSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInJlc2hvKzBfMDAyNlwiKTsgICAgIC8vIGNsZWFyIHRlbXAgbWFudGlzc2EgMVxyXG4vKiBiYTM3ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwicmVzaG8rMV8wMDI3XCIpOyAgICAgLy8gY2xlYXIgdGVtcCBtYW50aXNzYSAyXHJcbi8qIGJhMzkgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJyZXNobysyXzAwMjhcIik7ICAgICAvLyBjbGVhciB0ZW1wIG1hbnRpc3NhIDNcclxuLyogYmEzYiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInJlc2hvKzNfMDAyOVwiKTsgICAgIC8vIGNsZWFyIHRlbXAgbWFudGlzc2EgNFxyXG4vKiBiYTNkICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZmFjb3ZfMDA3MFwiKTsgICAgICAgLy8gZ2V0IEZBQzEgcm91bmRpbmcgYnl0ZVxyXG4vKiBiYTNmICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwibXVscGx5X2JhNTlcIik7ICAgICAgLy8gZ28gZG8gc2hpZnQvYWRkIEZBQzJcclxuLyogYmE0MiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZhY2hvKzNfMDA2NVwiKTsgICAgIC8vIGdldCBGQUMxIG1hbnRpc3NhIDRcclxuLyogYmE0NCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIm11bHBseV9iYTU5XCIpOyAgICAgIC8vIGdvIGRvIHNoaWZ0L2FkZCBGQUMyXHJcbi8qIGJhNDcgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJmYWNobysyXzAwNjRcIik7ICAgICAvLyBnZXQgRkFDMSBtYW50aXNzYSAzXHJcbi8qIGJhNDkgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJtdWxwbHlfYmE1OVwiKTsgICAgICAvLyBnbyBkbyBzaGlmdC9hZGQgRkFDMlxyXG4vKiBiYTRjICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZmFjaG8rMV8wMDYzXCIpOyAgICAgLy8gZ2V0IEZBQzEgbWFudGlzc2EgMlxyXG4vKiBiYTRlICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwibXVscGx5X2JhNTlcIik7ICAgICAgLy8gZ28gZG8gc2hpZnQvYWRkIEZBQzJcclxuLyogYmE1MSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZhY2hvKzBfMDA2MlwiKTsgICAgIC8vIGdldCBGQUMxIG1hbnRpc3NhIDFcclxuLyogYmE1MyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9iYTVlXCIpOyAgICAgICAgICAgIC8vIGdvIGRvIHNoaWZ0L2FkZCBGQUMyXHJcbi8qIGJhNTYgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfYmI4ZlwiKTsgICAgICAgICAgICAvLyBjb3B5IHRlbXAgdG8gRkFDMSwgbm9ybWFsaXNlIGFuZCByZXR1cm5cclxuLyogYmE1OSAqLyAgX2BtdWxwbHlfYmE1OWA7ICBCTkUucmVsIChcIl9iYTVlXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBieXRlIDw+IHplcm9cclxuLyogYmE1YiAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIm11bHNoZl9iOTgzXCIpOyAgICAgIC8vIHNoaWZ0IEZDQXRlbXAgPDwgQSs4IHRpbWVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBkbyBzaGlmdCBhbmQgYWRkXHJcbi8qIGJhNWUgKi8gICAgICAgIF9gX2JhNWVgOyAgTFNSLmFjYyAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2hpZnQgYnl0ZVxyXG4vKiBiYTVmICovICAgICAgICAgICAgICAgICAgIE9SQS5pbW0gKDB4ODApOyAgICAgICAgICAgICAgIC8vIHNldCB0b3AgYml0IChtYXJrIGZvciA4IHRpbWVzKVxyXG4vKiBiYTYxICovICAgICAgICBfYF9iYTYxYDsgIFRBWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgcmVzdWx0XHJcbi8qIGJhNjIgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYmE3ZFwiKTsgICAgICAgICAgICAvLyBza2lwIG5leHQgaWYgYml0IHdhcyB6ZXJvXHJcbi8qIGJhNjQgKi8gICAgICAgICAgICAgICAgICAgQ0xDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgY2FycnkgZm9yIGFkZFxyXG4vKiBiYTY1ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwicmVzaG8rM18wMDI5XCIpOyAgICAgLy8gZ2V0IHRlbXAgbWFudGlzc2EgNFxyXG4vKiBiYTY3ICovICAgICAgICAgICAgICAgICAgIEFEQy56cGcgKFwiYXJnaG8rM18wMDZkXCIpOyAgICAgLy8gYWRkIEZBQzIgbWFudGlzc2EgNFxyXG4vKiBiYTY5ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwicmVzaG8rM18wMDI5XCIpOyAgICAgLy8gc2F2ZSB0ZW1wIG1hbnRpc3NhIDRcclxuLyogYmE2YiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInJlc2hvKzJfMDAyOFwiKTsgICAgIC8vIGdldCB0ZW1wIG1hbnRpc3NhIDNcclxuLyogYmE2ZCAqLyAgICAgICAgICAgICAgICAgICBBREMuenBnIChcImFyZ2hvKzJfMDA2Y1wiKTsgICAgIC8vIGFkZCBGQUMyIG1hbnRpc3NhIDNcclxuLyogYmE2ZiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInJlc2hvKzJfMDAyOFwiKTsgICAgIC8vIHNhdmUgdGVtcCBtYW50aXNzYSAzXHJcbi8qIGJhNzEgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJyZXNobysxXzAwMjdcIik7ICAgICAvLyBnZXQgdGVtcCBtYW50aXNzYSAyXHJcbi8qIGJhNzMgKi8gICAgICAgICAgICAgICAgICAgQURDLnpwZyAoXCJhcmdobysxXzAwNmJcIik7ICAgICAvLyBhZGQgRkFDMiBtYW50aXNzYSAyXHJcbi8qIGJhNzUgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJyZXNobysxXzAwMjdcIik7ICAgICAvLyBzYXZlIHRlbXAgbWFudGlzc2EgMlxyXG4vKiBiYTc3ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwicmVzaG8rMF8wMDI2XCIpOyAgICAgLy8gZ2V0IHRlbXAgbWFudGlzc2EgMVxyXG4vKiBiYTc5ICovICAgICAgICAgICAgICAgICAgIEFEQy56cGcgKFwiYXJnaG8rMF8wMDZhXCIpOyAgICAgLy8gYWRkIEZBQzIgbWFudGlzc2EgMVxyXG4vKiBiYTdiICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwicmVzaG8rMF8wMDI2XCIpOyAgICAgLy8gc2F2ZSB0ZW1wIG1hbnRpc3NhIDFcclxuLyogYmE3ZCAqLyAgICAgICAgX2BfYmE3ZGA7ICBST1IuenBnIChcInJlc2hvKzBfMDAyNlwiKTsgICAgIC8vIHNoaWZ0IHRlbXAgbWFudGlzc2EgMVxyXG4vKiBiYTdmICovICAgICAgICAgICAgICAgICAgIFJPUi56cGcgKFwicmVzaG8rMV8wMDI3XCIpOyAgICAgLy8gc2hpZnQgdGVtcCBtYW50aXNzYSAyXHJcbi8qIGJhODEgKi8gICAgICAgICAgICAgICAgICAgUk9SLnpwZyAoXCJyZXNobysyXzAwMjhcIik7ICAgICAvLyBzaGlmdCB0ZW1wIG1hbnRpc3NhIDNcclxuLyogYmE4MyAqLyAgICAgICAgICAgICAgICAgICBST1IuenBnIChcInJlc2hvKzNfMDAyOVwiKTsgICAgIC8vIHNoaWZ0IHRlbXAgbWFudGlzc2EgNFxyXG4vKiBiYTg1ICovICAgICAgICAgICAgICAgICAgIFJPUi56cGcgKFwiZmFjb3ZfMDA3MFwiKTsgICAgICAgLy8gc2hpZnQgdGVtcCByb3VuZGluZyBieXRlXHJcbi8qIGJhODcgKi8gICAgICAgICAgICAgICAgICAgVFlBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGJ5dGUgYmFja1xyXG4vKiBiYTg4ICovICAgICAgICAgICAgICAgICAgIExTUi5hY2MgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNoaWZ0IGJ5dGVcclxuLyogYmE4OSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9iYTYxXCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgYWxsIGJpdHMgbm90IGRvbmVcclxuLyogYmE4YiAqLyAgICAgICAgX2BfYmE4YmA7ICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyB1bnBhY2sgbWVtb3J5IChBWSkgaW50byBGQUMyXHJcbi8qIGJhOGMgKi8gIF9gY29udXBrX2JhOGNgOyAgU1RBLnpwZyAoXCJpbmRleCswXzAwMjJcIik7ICAgICAvLyBzYXZlIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYmE4ZSAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcImluZGV4KzFfMDAyM1wiKTsgICAgIC8vIHNhdmUgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYmE5MCAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDA0KTsgICAgICAgICAgICAgICAvLyA1IGJ5dGVzIHRvIGdldCAoMC00KVxyXG4vKiBiYTkyICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwiaW5kZXgrMF8wMDIyXCIpOyAgICAgLy8gZ2V0IG1hbnRpc3NhIDRcclxuLyogYmE5NCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImFyZ2hvKzNfMDA2ZFwiKTsgICAgIC8vIHNhdmUgRkFDMiBtYW50aXNzYSA0XHJcbi8qIGJhOTYgKi8gICAgICAgICAgICAgICAgICAgREVZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZGVjcmVtZW50IGluZGV4XHJcbi8qIGJhOTcgKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJpbmRleCswXzAwMjJcIik7ICAgICAvLyBnZXQgbWFudGlzc2EgM1xyXG4vKiBiYTk5ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiYXJnaG8rMl8wMDZjXCIpOyAgICAgLy8gc2F2ZSBGQUMyIG1hbnRpc3NhIDNcclxuLyogYmE5YiAqLyAgICAgICAgICAgICAgICAgICBERVkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBkZWNyZW1lbnQgaW5kZXhcclxuLyogYmE5YyAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcImluZGV4KzBfMDAyMlwiKTsgICAgIC8vIGdldCBtYW50aXNzYSAyXHJcbi8qIGJhOWUgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJhcmdobysxXzAwNmJcIik7ICAgICAvLyBzYXZlIEZBQzIgbWFudGlzc2EgMlxyXG4vKiBiYWEwICovICAgICAgICAgICAgICAgICAgIERFWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCBpbmRleFxyXG4vKiBiYWExICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwiaW5kZXgrMF8wMDIyXCIpOyAgICAgLy8gZ2V0IG1hbnRpc3NhIDEgKyBzaWduXHJcbi8qIGJhYTMgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJhcmdzZ25fMDA2ZVwiKTsgICAgICAvLyBzYXZlIEZBQzIgc2lnbiAoYjcpXHJcbi8qIGJhYTUgKi8gICAgICAgICAgICAgICAgICAgRU9SLnpwZyAoXCJmYWNzZ25fMDA2NlwiKTsgICAgICAvLyBFT1Igd2l0aCBGQUMxIHNpZ24gKGI3KVxyXG4vKiBiYWE3ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiYXJpc2duXzAwNmZcIik7ICAgICAgLy8gc2F2ZSBzaWduIGNvbXBhcmUgKEZBQzEgRU9SIEZBQzIpXHJcbi8qIGJhYTkgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJhcmdzZ25fMDA2ZVwiKTsgICAgICAvLyByZWNvdmVyIEZBQzIgc2lnbiAoYjcpXHJcbi8qIGJhYWIgKi8gICAgICAgICAgICAgICAgICAgT1JBLmltbSAoMHg4MCk7ICAgICAgICAgICAgICAgLy8gc2V0IDF4eHggeHh4IChzZXQgbm9ybWFsIGJpdClcclxuLyogYmFhZCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImFyZ2hvKzBfMDA2YVwiKTsgICAgIC8vIHNhdmUgRkFDMiBtYW50aXNzYSAxXHJcbi8qIGJhYWYgKi8gICAgICAgICAgICAgICAgICAgREVZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZGVjcmVtZW50IGluZGV4XHJcbi8qIGJhYjAgKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJpbmRleCswXzAwMjJcIik7ICAgICAvLyBnZXQgZXhwb25lbnQgYnl0ZVxyXG4vKiBiYWIyICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiYXJnZXhwXzAwNjlcIik7ICAgICAgLy8gc2F2ZSBGQUMyIGV4cG9uZW50XHJcbi8qIGJhYjQgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJmYWNleHBfMDA2MVwiKTsgICAgICAvLyBnZXQgRkFDMSBleHBvbmVudFxyXG4vKiBiYWI2ICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHRlc3QgYW5kIGFkanVzdCBhY2N1bXVsYXRvcnNcclxuLyogYmFiNyAqLyAgX2BtdWxkaXZfYmFiN2A7ICBMREEuenBnIChcImFyZ2V4cF8wMDY5XCIpOyAgICAgIC8vIGdldCBGQUMyIGV4cG9uZW50XHJcbi8qIGJhYjkgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYmFkYVwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgRkFDMiA9ICQwMCAoaGFuZGxlIHVuZGVyZmxvdylcclxuLyogYmFiYiAqLyAgICAgICAgICAgICAgICAgICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBjYXJyeSBmb3IgYWRkXHJcbi8qIGJhYmMgKi8gICAgICAgICAgICAgICAgICAgQURDLnpwZyAoXCJmYWNleHBfMDA2MVwiKTsgICAgICAvLyBhZGQgRkFDMSBleHBvbmVudFxyXG4vKiBiYWJlICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2JhYzRcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIHN1bSBvZiBleHBvbmVudHMgPCAkMDEwMFxyXG4vKiBiYWMwICovICAgICAgICAgICAgICAgICAgIEJNSS5yZWwgKFwiX2JhZGZcIik7ICAgICAgICAgICAgLy8gZG8gb3ZlcmZsb3cgZXJyb3JcclxuLyogYmFjMiAqLyAgICAgICAgICAgICAgICAgICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBjYXJyeSBmb3IgdGhlIGFkZFxyXG4vKiBiYWMzICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgyYyk7ICAgICAgICAgICAgICAgIC8vIG1ha2VzIG5leHQgbGluZSBCSVQgJDE0MTBcclxuLyogYmFjNCAqLyAgICAgICAgX2BfYmFjNGA7ICBCUEwucmVsIChcIl9iYWRhXCIpOyAgICAgICAgICAgIC8vIGlmICt2ZSBnbyBoYW5kbGUgdW5kZXJmbG93XHJcbi8qIGJhYzYgKi8gICAgICAgICAgICAgICAgICAgQURDLmltbSAoMHg4MCk7ICAgICAgICAgICAgICAgLy8gYWRqdXN0IGV4cG9uZW50XHJcbi8qIGJhYzggKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmYWNleHBfMDA2MVwiKTsgICAgICAvLyBzYXZlIEZBQzEgZXhwb25lbnRcclxuLyogYmFjYSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9iYWNmXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBub3QgemVyb1xyXG4vKiBiYWNjICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2I4ZmJcIik7ICAgICAgICAgICAgLy8gc2F2ZSBGQUMxIHNpZ24gYW5kIHJldHVyblxyXG4vKiBiYWNmICovICAgICAgICBfYF9iYWNmYDsgIExEQS56cGcgKFwiYXJpc2duXzAwNmZcIik7ICAgICAgLy8gZ2V0IHNpZ24gY29tcGFyZSAoRkFDMSBFT1IgRkFDMilcclxuLyogYmFkMSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZhY3Nnbl8wMDY2XCIpOyAgICAgIC8vIHNhdmUgRkFDMSBzaWduIChiNylcclxuLyogYmFkMyAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBvdmVyZmxvdyBhbmQgdW5kZXJmbG93XHJcbi8qIGJhZDQgKi8gIF9gbWxkdmV4X2JhZDRgOyAgTERBLnpwZyAoXCJmYWNzZ25fMDA2NlwiKTsgICAgICAvLyBnZXQgRkFDMSBzaWduIChiNylcclxuLyogYmFkNiAqLyAgICAgICAgICAgICAgICAgICBFT1IuaW1tICgweGZmKTsgICAgICAgICAgICAgICAvLyBjb21wbGVtZW50IGl0XHJcbi8qIGJhZDggKi8gICAgICAgICAgICAgICAgICAgQk1JLnJlbCAoXCJfYmFkZlwiKTsgICAgICAgICAgICAvLyBkbyBvdmVyZmxvdyBlcnJvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSB1bmRlcmZsb3dcclxuLyogYmFkYSAqLyAgICAgICAgX2BfYmFkYWA7ICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwb3AgcmV0dXJuIGFkZHJlc3MgbG93IGJ5dGVcclxuLyogYmFkYiAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwb3AgcmV0dXJuIGFkZHJlc3MgaGlnaCBieXRlXHJcbi8qIGJhZGMgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfYjhmN1wiKTsgICAgICAgICAgICAvLyBjbGVhciBGQUMxIGV4cG9uZW50IGFuZCBzaWduIGFuZCByZXR1cm5cclxuLyogYmFkZiAqLyAgICAgICAgX2BfYmFkZmA7ICBKTVAuYWJzIChcIm92ZXJyX2I5N2VcIik7ICAgICAgIC8vIGRvIG92ZXJmbG93IGVycm9yIHRoZW4gd2FybSBzdGFydFxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBtdWx0aXBseSBGQUMxIGJ5IDEwXHJcbi8qIGJhZTIgKi8gICBfYG11bDEwX2JhZTJgOyAgSlNSLmFicyAoXCJtb3ZhZl9iYzBjXCIpOyAgICAgICAvLyByb3VuZCBhbmQgY29weSBGQUMxIHRvIEZBQzJcclxuLyogYmFlNSAqLyAgICAgICAgICAgICAgICAgICBUQVguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IGV4cG9uZW50IChzZXQgdGhlIGZsYWdzKVxyXG4vKiBiYWU2ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2JhZjhcIik7ICAgICAgICAgICAgLy8gZXhpdCBpZiB6ZXJvXHJcbi8qIGJhZTggKi8gICAgICAgICAgICAgICAgICAgQ0xDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgY2FycnkgZm9yIGFkZFxyXG4vKiBiYWU5ICovICAgICAgICAgICAgICAgICAgIEFEQy5pbW0gKDB4MDIpOyAgICAgICAgICAgICAgIC8vIGFkZCB0d28gdG8gZXhwb25lbnQgKCo0KVxyXG4vKiBiYWViICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2JhZGZcIik7ICAgICAgICAgICAgLy8gZG8gb3ZlcmZsb3cgZXJyb3IgaWYgPiAkRkZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGQUMxID0gKEZBQzEgKyBGQUMyKSAqIDJcclxuLyogYmFlZCAqLyAgICAgICAgX2BfYmFlZGA7ICBMRFguaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBieXRlXHJcbi8qIGJhZWYgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJhcmlzZ25fMDA2ZlwiKTsgICAgICAvLyBjbGVhciBzaWduIGNvbXBhcmUgKEZBQzEgRU9SIEZBQzIpXHJcbi8qIGJhZjEgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfYjg3N1wiKTsgICAgICAgICAgICAvLyBhZGQgRkFDMiB0byBGQUMxICgqNSlcclxuLyogYmFmNCAqLyAgICAgICAgICAgICAgICAgICBJTkMuenBnIChcImZhY2V4cF8wMDYxXCIpOyAgICAgIC8vIGluY3JlbWVudCBGQUMxIGV4cG9uZW50ICgqMTApXHJcbi8qIGJhZjYgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYmFkZlwiKTsgICAgICAgICAgICAvLyBpZiBleHBvbmVudCBub3cgemVybyBnbyBkbyBvdmVyZmxvdyBlcnJvclxyXG4vKiBiYWY4ICovICAgICAgICBfYF9iYWY4YDsgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIDEwIGFzIGEgZmxvYXRpbmcgdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxMFxyXG4vKiBiYWY5ICovICAgIF9gdGVuY19iYWY5YDsgIF8uYnl0ZXMoMHg4NCwgMHgyMCwgMHgwMCwgMHgwMCwgMHgwMCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGRpdmlkZSBGQUMxIGJ5IDEwXHJcbi8qIGJhZmUgKi8gICBfYGRpdjEwX2JhZmVgOyAgSlNSLmFicyAoXCJtb3ZhZl9iYzBjXCIpOyAgICAgICAvLyByb3VuZCBhbmQgY29weSBGQUMxIHRvIEZBQzJcclxuLyogYmIwMSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweGY5KTsgICAgICAgICAgICAgICAvLyBzZXQgMTAgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiYjAzICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4YmEpOyAgICAgICAgICAgICAgIC8vIHNldCAxMCBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiYjA1ICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIHNpZ25cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gZGl2aWRlIGJ5IChBWSkgKFg9c2lnbilcclxuLyogYmIwNyAqLyAgIF9gZmRpdmZfYmIwN2A7ICBTVFguenBnIChcImFyaXNnbl8wMDZmXCIpOyAgICAgIC8vIHNhdmUgc2lnbiBjb21wYXJlIChGQUMxIEVPUiBGQUMyKVxyXG4vKiBiYjA5ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwibW92Zm1fYmJhMlwiKTsgICAgICAgLy8gdW5wYWNrIG1lbW9yeSAoQVkpIGludG8gRkFDMVxyXG4vKiBiYjBjICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiZmRpdnRfYmIxMlwiKTsgICAgICAgLy8gZG8gRkFDMi9GQUMxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGVyZm9ybSBkaXZpZGUtYnlcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY29udmVydCBBWSBhbmQgZG8gKEFZKS9GQUMxXHJcbi8qIGJiMGYgKi8gICAgX2BmZGl2X2JiMGZgOyAgSlNSLmFicyAoXCJjb251cGtfYmE4Y1wiKTsgICAgICAvLyB1bnBhY2sgbWVtb3J5IChBWSkgaW50byBGQUMyXHJcbi8qIGJiMTIgKi8gICBfYGZkaXZ0X2JiMTJgOyAgQkVRLnJlbCAoXCJfYmI4YVwiKTsgICAgICAgICAgICAvLyBpZiB6ZXJvIGdvIGRvIC8wIGVycm9yXHJcbi8qIGJiMTQgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJyb3VuZF9iYzFiXCIpOyAgICAgICAvLyByb3VuZCBGQUMxXHJcbi8qIGJiMTcgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgQVxyXG4vKiBiYjE5ICovICAgICAgICAgICAgICAgICAgIFNFQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNldCBjYXJyeSBmb3Igc3VidHJhY3RcclxuLyogYmIxYSAqLyAgICAgICAgICAgICAgICAgICBTQkMuenBnIChcImZhY2V4cF8wMDYxXCIpOyAgICAgIC8vIHN1YnRyYWN0IEZBQzEgZXhwb25lbnQgKDJzIGNvbXBsZW1lbnQpXHJcbi8qIGJiMWMgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmYWNleHBfMDA2MVwiKTsgICAgICAvLyBzYXZlIEZBQzEgZXhwb25lbnRcclxuLyogYmIxZSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIm11bGRpdl9iYWI3XCIpOyAgICAgIC8vIHRlc3QgYW5kIGFkanVzdCBhY2N1bXVsYXRvcnNcclxuLyogYmIyMSAqLyAgICAgICAgICAgICAgICAgICBJTkMuenBnIChcImZhY2V4cF8wMDYxXCIpOyAgICAgIC8vIGluY3JlbWVudCBGQUMxIGV4cG9uZW50XHJcbi8qIGJiMjMgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYmFkZlwiKTsgICAgICAgICAgICAvLyBpZiB6ZXJvIGRvIG92ZXJmbG93IGVycm9yXHJcbi8qIGJiMjUgKi8gICAgICAgICAgICAgICAgICAgTERYLmltbSAoMHhmYyk7ICAgICAgICAgICAgICAgLy8gc2V0IGluZGV4IHRvIEZBQyB0ZW1wXHJcbi8qIGJiMjcgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMSk7ICAgICAgICAgICAgICAgLy8gc2V0IGJ5dGVcclxuLyogYmIyOSAqLyAgICAgICAgX2BfYmIyOWA7ICBMRFkuenBnIChcImFyZ2hvKzBfMDA2YVwiKTsgICAgIC8vIGdldCBGQUMyIG1hbnRpc3NhIDFcclxuLyogYmIyYiAqLyAgICAgICAgICAgICAgICAgICBDUFkuenBnIChcImZhY2hvKzBfMDA2MlwiKTsgICAgIC8vIGNvbXBhcmUgRkFDMSBtYW50aXNzYSAxXHJcbi8qIGJiMmQgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYmIzZlwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgPD5cclxuLyogYmIyZiAqLyAgICAgICAgICAgICAgICAgICBMRFkuenBnIChcImFyZ2hvKzFfMDA2YlwiKTsgICAgIC8vIGdldCBGQUMyIG1hbnRpc3NhIDJcclxuLyogYmIzMSAqLyAgICAgICAgICAgICAgICAgICBDUFkuenBnIChcImZhY2hvKzFfMDA2M1wiKTsgICAgIC8vIGNvbXBhcmUgRkFDMSBtYW50aXNzYSAyXHJcbi8qIGJiMzMgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYmIzZlwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgPD5cclxuLyogYmIzNSAqLyAgICAgICAgICAgICAgICAgICBMRFkuenBnIChcImFyZ2hvKzJfMDA2Y1wiKTsgICAgIC8vIGdldCBGQUMyIG1hbnRpc3NhIDNcclxuLyogYmIzNyAqLyAgICAgICAgICAgICAgICAgICBDUFkuenBnIChcImZhY2hvKzJfMDA2NFwiKTsgICAgIC8vIGNvbXBhcmUgRkFDMSBtYW50aXNzYSAzXHJcbi8qIGJiMzkgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYmIzZlwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgPD5cclxuLyogYmIzYiAqLyAgICAgICAgICAgICAgICAgICBMRFkuenBnIChcImFyZ2hvKzNfMDA2ZFwiKTsgICAgIC8vIGdldCBGQUMyIG1hbnRpc3NhIDRcclxuLyogYmIzZCAqLyAgICAgICAgICAgICAgICAgICBDUFkuenBnIChcImZhY2hvKzNfMDA2NVwiKTsgICAgIC8vIGNvbXBhcmUgRkFDMSBtYW50aXNzYSA0XHJcbi8qIGJiM2YgKi8gICAgICAgIF9gX2JiM2ZgOyAgUEhQLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBGQUMyLUZBQzEgY29tcGFyZSBzdGF0dXNcclxuLyogYmI0MCAqLyAgICAgICAgICAgICAgICAgICBST0wuYWNjICgpOyAgICAgICAgICAgICAgICAgICAvLyBzaGlmdCBieXRlXHJcbi8qIGJiNDEgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYmI0Y1wiKTsgICAgICAgICAgICAvLyBza2lwIG5leHQgaWYgbm8gY2FycnlcclxuLyogYmI0MyAqLyAgICAgICAgICAgICAgICAgICBJTlguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgaW5kZXggdG8gRkFDIHRlbXBcclxuLyogYmI0NCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenB4ICgweDI5KTtcclxuLyogYmI0NiAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9iYjdhXCIpO1xyXG4vKiBiYjQ4ICovICAgICAgICAgICAgICAgICAgIEJQTC5yZWwgKFwiX2JiN2VcIik7XHJcbi8qIGJiNGEgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMSk7XHJcbi8qIGJiNGMgKi8gICAgICAgIF9gX2JiNGNgOyAgUExQLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBGQUMyLUZBQzEgY29tcGFyZSBzdGF0dXNcclxuLyogYmI0ZCAqLyAgICAgICAgICAgICAgICAgICBCQ1MucmVsIChcIl9iYjVkXCIpOyAgICAgICAgICAgIC8vIGlmIEZBQzIgPj0gRkFDMSB0aGVuIGRvIHN1YnRyYWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRkFDMiA9IEZBQzIqMlxyXG4vKiBiYjRmICovICAgICAgICBfYF9iYjRmYDsgIEFTTC56cGcgKFwiYXJnaG8rM18wMDZkXCIpOyAgICAgLy8gc2hpZnQgRkFDMiBtYW50aXNzYSA0XHJcbi8qIGJiNTEgKi8gICAgICAgICAgICAgICAgICAgUk9MLnpwZyAoXCJhcmdobysyXzAwNmNcIik7ICAgICAvLyBzaGlmdCBGQUMyIG1hbnRpc3NhIDNcclxuLyogYmI1MyAqLyAgICAgICAgICAgICAgICAgICBST0wuenBnIChcImFyZ2hvKzFfMDA2YlwiKTsgICAgIC8vIHNoaWZ0IEZBQzIgbWFudGlzc2EgMlxyXG4vKiBiYjU1ICovICAgICAgICAgICAgICAgICAgIFJPTC56cGcgKFwiYXJnaG8rMF8wMDZhXCIpOyAgICAgLy8gc2hpZnQgRkFDMiBtYW50aXNzYSAxXHJcbi8qIGJiNTcgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfYmIzZlwiKTsgICAgICAgICAgICAvLyBsb29wIHdpdGggbm8gY29tcGFyZVxyXG4vKiBiYjU5ICovICAgICAgICAgICAgICAgICAgIEJNSS5yZWwgKFwiX2JiMjlcIik7ICAgICAgICAgICAgLy8gbG9vcCB3aXRoIGNvbXBhcmVcclxuLyogYmI1YiAqLyAgICAgICAgICAgICAgICAgICBCUEwucmVsIChcIl9iYjNmXCIpOyAgICAgICAgICAgIC8vIGxvb3Agd2l0aCBubyBjb21wYXJlLCBicmFuY2ggYWx3YXlzXHJcbi8qIGJiNWQgKi8gICAgICAgIF9gX2JiNWRgOyAgVEFZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBGQUMyLUZBQzEgY29tcGFyZSBzdGF0dXNcclxuLyogYmI1ZSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImFyZ2hvKzNfMDA2ZFwiKTsgICAgIC8vIGdldCBGQUMyIG1hbnRpc3NhIDRcclxuLyogYmI2MCAqLyAgICAgICAgICAgICAgICAgICBTQkMuenBnIChcImZhY2hvKzNfMDA2NVwiKTsgICAgIC8vIHN1YnRyYWN0IEZBQzEgbWFudGlzc2EgNFxyXG4vKiBiYjYyICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiYXJnaG8rM18wMDZkXCIpOyAgICAgLy8gc2F2ZSBGQUMyIG1hbnRpc3NhIDRcclxuLyogYmI2NCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImFyZ2hvKzJfMDA2Y1wiKTsgICAgIC8vIGdldCBGQUMyIG1hbnRpc3NhIDNcclxuLyogYmI2NiAqLyAgICAgICAgICAgICAgICAgICBTQkMuenBnIChcImZhY2hvKzJfMDA2NFwiKTsgICAgIC8vIHN1YnRyYWN0IEZBQzEgbWFudGlzc2EgM1xyXG4vKiBiYjY4ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiYXJnaG8rMl8wMDZjXCIpOyAgICAgLy8gc2F2ZSBGQUMyIG1hbnRpc3NhIDNcclxuLyogYmI2YSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImFyZ2hvKzFfMDA2YlwiKTsgICAgIC8vIGdldCBGQUMyIG1hbnRpc3NhIDJcclxuLyogYmI2YyAqLyAgICAgICAgICAgICAgICAgICBTQkMuenBnIChcImZhY2hvKzFfMDA2M1wiKTsgICAgIC8vIHN1YnRyYWN0IEZBQzEgbWFudGlzc2EgMlxyXG4vKiBiYjZlICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiYXJnaG8rMV8wMDZiXCIpOyAgICAgLy8gc2F2ZSBGQUMyIG1hbnRpc3NhIDJcclxuLyogYmI3MCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImFyZ2hvKzBfMDA2YVwiKTsgICAgIC8vIGdldCBGQUMyIG1hbnRpc3NhIDFcclxuLyogYmI3MiAqLyAgICAgICAgICAgICAgICAgICBTQkMuenBnIChcImZhY2hvKzBfMDA2MlwiKTsgICAgIC8vIHN1YnRyYWN0IEZBQzEgbWFudGlzc2EgMVxyXG4vKiBiYjc0ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiYXJnaG8rMF8wMDZhXCIpOyAgICAgLy8gc2F2ZSBGQUMyIG1hbnRpc3NhIDFcclxuLyogYmI3NiAqLyAgICAgICAgICAgICAgICAgICBUWUEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIEZBQzItRkFDMSBjb21wYXJlIHN0YXR1c1xyXG4vKiBiYjc3ICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2JiNGZcIik7XHJcbi8qIGJiN2EgKi8gICAgICAgIF9gX2JiN2FgOyAgTERBLmltbSAoMHg0MCk7XHJcbi8qIGJiN2MgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYmI0Y1wiKTsgICAgICAgICAgICAvLyBicmFuY2ggYWx3YXlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gQTw8Niwgc2F2ZSBhcyBGQUMxIHJvdW5kaW5nIGJ5dGUsIG5vcm1hbGlzZSBhbmQgcmV0dXJuXHJcbi8qIGJiN2UgKi8gICAgICAgIF9gX2JiN2VgOyAgQVNMLmFjYyAoKTtcclxuLyogYmI3ZiAqLyAgICAgICAgICAgICAgICAgICBBU0wuYWNjICgpO1xyXG4vKiBiYjgwICovICAgICAgICAgICAgICAgICAgIEFTTC5hY2MgKCk7XHJcbi8qIGJiODEgKi8gICAgICAgICAgICAgICAgICAgQVNMLmFjYyAoKTtcclxuLyogYmI4MiAqLyAgICAgICAgICAgICAgICAgICBBU0wuYWNjICgpO1xyXG4vKiBiYjgzICovICAgICAgICAgICAgICAgICAgIEFTTC5hY2MgKCk7XHJcbi8qIGJiODQgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmYWNvdl8wMDcwXCIpOyAgICAgICAvLyBzYXZlIEZBQzEgcm91bmRpbmcgYnl0ZVxyXG4vKiBiYjg2ICovICAgICAgICAgICAgICAgICAgIFBMUC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGR1bXAgRkFDMi1GQUMxIGNvbXBhcmUgc3RhdHVzXHJcbi8qIGJiODcgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfYmI4ZlwiKTsgICAgICAgICAgICAvLyBjb3B5IHRlbXAgdG8gRkFDMSwgbm9ybWFsaXNlIGFuZCByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyBcIkRpdmlkZSBieSB6ZXJvXCIgZXJyb3JcclxuLyogYmI4YSAqLyAgICAgICAgX2BfYmI4YWA7ICBMRFguaW1tICgweDE0KTsgICAgICAgICAgICAgICAvLyBlcnJvciAkMTQsIGRpdmlkZSBieSB6ZXJvIGVycm9yXHJcbi8qIGJiOGMgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJlcnJvcl9hNDM3XCIpOyAgICAgICAvLyBkbyBlcnJvciAjWCB0aGVuIHdhcm0gc3RhcnRcclxuLyogYmI4ZiAqLyAgICAgICAgX2BfYmI4ZmA7ICBMREEuenBnIChcInJlc2hvKzBfMDAyNlwiKTsgICAgIC8vIGdldCB0ZW1wIG1hbnRpc3NhIDFcclxuLyogYmI5MSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZhY2hvKzBfMDA2MlwiKTsgICAgIC8vIHNhdmUgRkFDMSBtYW50aXNzYSAxXHJcbi8qIGJiOTMgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJyZXNobysxXzAwMjdcIik7ICAgICAvLyBnZXQgdGVtcCBtYW50aXNzYSAyXHJcbi8qIGJiOTUgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmYWNobysxXzAwNjNcIik7ICAgICAvLyBzYXZlIEZBQzEgbWFudGlzc2EgMlxyXG4vKiBiYjk3ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwicmVzaG8rMl8wMDI4XCIpOyAgICAgLy8gZ2V0IHRlbXAgbWFudGlzc2EgM1xyXG4vKiBiYjk5ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZmFjaG8rMl8wMDY0XCIpOyAgICAgLy8gc2F2ZSBGQUMxIG1hbnRpc3NhIDNcclxuLyogYmI5YiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInJlc2hvKzNfMDAyOVwiKTsgICAgIC8vIGdldCB0ZW1wIG1hbnRpc3NhIDRcclxuLyogYmI5ZCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZhY2hvKzNfMDA2NVwiKTsgICAgIC8vIHNhdmUgRkFDMSBtYW50aXNzYSA0XHJcbi8qIGJiOWYgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfYjhkN1wiKTsgICAgICAgICAgICAvLyBub3JtYWxpc2UgRkFDMSBhbmQgcmV0dXJuXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHVucGFjayBtZW1vcnkgKEFZKSBpbnRvIEZBQzFcclxuLyogYmJhMiAqLyAgIF9gbW92Zm1fYmJhMmA7ICBTVEEuenBnIChcImluZGV4KzBfMDAyMlwiKTsgICAgIC8vIHNhdmUgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiYmE0ICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwiaW5kZXgrMV8wMDIzXCIpOyAgICAgLy8gc2F2ZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiYmE2ICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4MDQpOyAgICAgICAgICAgICAgIC8vIDUgYnl0ZXMgdG8gZG9cclxuLyogYmJhOCAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcImluZGV4KzBfMDAyMlwiKTsgICAgIC8vIGdldCBmaWZ0aCBieXRlXHJcbi8qIGJiYWEgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmYWNobyszXzAwNjVcIik7ICAgICAvLyBzYXZlIEZBQzEgbWFudGlzc2EgNFxyXG4vKiBiYmFjICovICAgICAgICAgICAgICAgICAgIERFWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCBpbmRleFxyXG4vKiBiYmFkICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwiaW5kZXgrMF8wMDIyXCIpOyAgICAgLy8gZ2V0IGZvdXJ0aCBieXRlXHJcbi8qIGJiYWYgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmYWNobysyXzAwNjRcIik7ICAgICAvLyBzYXZlIEZBQzEgbWFudGlzc2EgM1xyXG4vKiBiYmIxICovICAgICAgICAgICAgICAgICAgIERFWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCBpbmRleFxyXG4vKiBiYmIyICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwiaW5kZXgrMF8wMDIyXCIpOyAgICAgLy8gZ2V0IHRoaXJkIGJ5dGVcclxuLyogYmJiNCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZhY2hvKzFfMDA2M1wiKTsgICAgIC8vIHNhdmUgRkFDMSBtYW50aXNzYSAyXHJcbi8qIGJiYjYgKi8gICAgICAgICAgICAgICAgICAgREVZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZGVjcmVtZW50IGluZGV4XHJcbi8qIGJiYjcgKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJpbmRleCswXzAwMjJcIik7ICAgICAvLyBnZXQgc2Vjb25kIGJ5dGVcclxuLyogYmJiOSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZhY3Nnbl8wMDY2XCIpOyAgICAgIC8vIHNhdmUgRkFDMSBzaWduIChiNylcclxuLyogYmJiYiAqLyAgICAgICAgICAgICAgICAgICBPUkEuaW1tICgweDgwKTsgICAgICAgICAgICAgICAvLyBzZXQgMXh4eCB4eHh4IChhZGQgbm9ybWFsIGJpdClcclxuLyogYmJiZCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZhY2hvKzBfMDA2MlwiKTsgICAgIC8vIHNhdmUgRkFDMSBtYW50aXNzYSAxXHJcbi8qIGJiYmYgKi8gICAgICAgICAgICAgICAgICAgREVZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZGVjcmVtZW50IGluZGV4XHJcbi8qIGJiYzAgKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJpbmRleCswXzAwMjJcIik7ICAgICAvLyBnZXQgZmlyc3QgYnl0ZSAoZXhwb25lbnQpXHJcbi8qIGJiYzIgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmYWNleHBfMDA2MVwiKTsgICAgICAvLyBzYXZlIEZBQzEgZXhwb25lbnRcclxuLyogYmJjNCAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcImZhY292XzAwNzBcIik7ICAgICAgIC8vIGNsZWFyIEZBQzEgcm91bmRpbmcgYnl0ZVxyXG4vKiBiYmM2ICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHBhY2sgRkFDMSBpbnRvICQ1Q1xyXG4vKiBiYmM3ICovICAgX2Btb3YyZl9iYmM3YDsgIExEWC5pbW0gKDB4NWMpOyAgICAgICAgICAgICAgIC8vIHNldCBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGJiYzkgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDJjKTsgICAgICAgICAgICAgICAgLy8gbWFrZXMgbmV4dCBsaW5lIEJJVCAkNTdBMlxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBwYWNrIEZBQzEgaW50byAkNTdcclxuLyogYmJjYSAqLyAgICAgICAgICAgICAgICAgICBMRFguaW1tICgweDU3KTsgICAgICAgICAgICAgICAvLyBzZXQgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiYmNjICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIHNldCBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiYmNlICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2JiZDRcIik7ICAgICAgICAgICAgLy8gcGFjayBGQUMxIGludG8gKFhZKSBhbmQgcmV0dXJuLCBicmFuY2ggYWx3YXlzXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHBhY2sgRkFDMSBpbnRvIHZhcmlhYmxlIHBvaW50ZXJcclxuLyogYmJkMCAqLyAgICAgICAgX2BfYmJkMGA7ICBMRFguenBnIChcImZvcnBudCswXzAwNDlcIik7ICAgIC8vIGdldCBkZXN0aW5hdGlvbiBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGJiZDIgKi8gICAgICAgICAgICAgICAgICAgTERZLnpwZyAoXCJmb3JwbnQrMV8wMDRhXCIpOyAgICAvLyBnZXQgZGVzdGluYXRpb24gcG9pbnRlciBoaWdoIGJ5dGVcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcGFjayBGQUMxIGludG8gKFhZKVxyXG4vKiBiYmQ0ICovICAgICAgICBfYF9iYmQ0YDsgIEpTUi5hYnMgKFwicm91bmRfYmMxYlwiKTsgICAgICAgLy8gcm91bmQgRkFDMVxyXG4vKiBiYmQ3ICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwiaW5kZXgrMF8wMDIyXCIpOyAgICAgLy8gc2F2ZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGJiZDkgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJpbmRleCsxXzAwMjNcIik7ICAgICAvLyBzYXZlIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGJiZGIgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgwNCk7ICAgICAgICAgICAgICAgLy8gc2V0IGluZGV4XHJcbi8qIGJiZGQgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJmYWNobyszXzAwNjVcIik7ICAgICAvLyBnZXQgRkFDMSBtYW50aXNzYSA0XHJcbi8qIGJiZGYgKi8gICAgICAgICAgICAgICAgICAgU1RBLmlueSAoXCJpbmRleCswXzAwMjJcIik7ICAgICAvLyBzdG9yZSBpbiBkZXN0aW5hdGlvblxyXG4vKiBiYmUxICovICAgICAgICAgICAgICAgICAgIERFWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCBpbmRleFxyXG4vKiBiYmUyICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZmFjaG8rMl8wMDY0XCIpOyAgICAgLy8gZ2V0IEZBQzEgbWFudGlzc2EgM1xyXG4vKiBiYmU0ICovICAgICAgICAgICAgICAgICAgIFNUQS5pbnkgKFwiaW5kZXgrMF8wMDIyXCIpOyAgICAgLy8gc3RvcmUgaW4gZGVzdGluYXRpb25cclxuLyogYmJlNiAqLyAgICAgICAgICAgICAgICAgICBERVkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBkZWNyZW1lbnQgaW5kZXhcclxuLyogYmJlNyAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZhY2hvKzFfMDA2M1wiKTsgICAgIC8vIGdldCBGQUMxIG1hbnRpc3NhIDJcclxuLyogYmJlOSAqLyAgICAgICAgICAgICAgICAgICBTVEEuaW55IChcImluZGV4KzBfMDAyMlwiKTsgICAgIC8vIHN0b3JlIGluIGRlc3RpbmF0aW9uXHJcbi8qIGJiZWIgKi8gICAgICAgICAgICAgICAgICAgREVZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZGVjcmVtZW50IGluZGV4XHJcbi8qIGJiZWMgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJmYWNzZ25fMDA2NlwiKTsgICAgICAvLyBnZXQgRkFDMSBzaWduIChiNylcclxuLyogYmJlZSAqLyAgICAgICAgICAgICAgICAgICBPUkEuaW1tICgweDdmKTsgICAgICAgICAgICAgICAvLyBzZXQgYml0cyB4MTExIDExMTFcclxuLyogYmJmMCAqLyAgICAgICAgICAgICAgICAgICBBTkQuenBnIChcImZhY2hvKzBfMDA2MlwiKTsgICAgIC8vIEFORCBpbiBGQUMxIG1hbnRpc3NhIDFcclxuLyogYmJmMiAqLyAgICAgICAgICAgICAgICAgICBTVEEuaW55IChcImluZGV4KzBfMDAyMlwiKTsgICAgIC8vIHN0b3JlIGluIGRlc3RpbmF0aW9uXHJcbi8qIGJiZjQgKi8gICAgICAgICAgICAgICAgICAgREVZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZGVjcmVtZW50IGluZGV4XHJcbi8qIGJiZjUgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJmYWNleHBfMDA2MVwiKTsgICAgICAvLyBnZXQgRkFDMSBleHBvbmVudFxyXG4vKiBiYmY3ICovICAgICAgICAgICAgICAgICAgIFNUQS5pbnkgKFwiaW5kZXgrMF8wMDIyXCIpOyAgICAgLy8gc3RvcmUgaW4gZGVzdGluYXRpb25cclxuLyogYmJmOSAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcImZhY292XzAwNzBcIik7ICAgICAgIC8vIGNsZWFyIEZBQzEgcm91bmRpbmcgYnl0ZVxyXG4vKiBiYmZiICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGNvcHkgRkFDMiB0byBGQUMxXHJcbi8qIGJiZmMgKi8gICBfYG1vdmZhX2JiZmNgOyAgTERBLnpwZyAoXCJhcmdzZ25fMDA2ZVwiKTsgICAgICAvLyBnZXQgRkFDMiBzaWduIChiNylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzYXZlIEZBQzEgc2lnbiBhbmQgY29weSBBQlMoRkFDMikgdG8gRkFDMVxyXG4vKiBiYmZlICovICAgICAgICBfYF9iYmZlYDsgIFNUQS56cGcgKFwiZmFjc2duXzAwNjZcIik7ICAgICAgLy8gc2F2ZSBGQUMxIHNpZ24gKGI3KVxyXG4vKiBiYzAwICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4MDUpOyAgICAgICAgICAgICAgIC8vIDUgYnl0ZXMgdG8gY29weVxyXG4vKiBiYzAyICovICAgICAgICBfYF9iYzAyYDsgIExEQS56cHggKDB4NjgpOyAgICAgICAgICAgICAgIC8vIGdldCBieXRlIGZyb20gRkFDMixYXHJcbi8qIGJjMDQgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpweCAoMHg2MCk7ICAgICAgICAgICAgICAgLy8gc2F2ZSBieXRlIGF0IEZBQzEsWFxyXG4vKiBiYzA2ICovICAgICAgICAgICAgICAgICAgIERFWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCBjb3VudFxyXG4vKiBiYzA3ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2JjMDJcIik7ICAgICAgICAgICAgLy8gbG9vcCBpZiBub3QgYWxsIGRvbmVcclxuLyogYmMwOSAqLyAgICAgICAgICAgICAgICAgICBTVFguenBnIChcImZhY292XzAwNzBcIik7ICAgICAgIC8vIGNsZWFyIEZBQzEgcm91bmRpbmcgYnl0ZVxyXG4vKiBiYzBiICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHJvdW5kIGFuZCBjb3B5IEZBQzEgdG8gRkFDMlxyXG4vKiBiYzBjICovICAgX2Btb3ZhZl9iYzBjYDsgIEpTUi5hYnMgKFwicm91bmRfYmMxYlwiKTsgICAgICAgLy8gcm91bmQgRkFDMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgRkFDMSB0byBGQUMyXHJcbi8qIGJjMGYgKi8gICBfYG1vdmVmX2JjMGZgOyAgTERYLmltbSAoMHgwNik7ICAgICAgICAgICAgICAgLy8gNiBieXRlcyB0byBjb3B5XHJcbi8qIGJjMTEgKi8gICAgICAgIF9gX2JjMTFgOyAgTERBLnpweCAoMHg2MCk7ICAgICAgICAgICAgICAgLy8gZ2V0IGJ5dGUgZnJvbSBGQUMxLFhcclxuLyogYmMxMyAqLyAgICAgICAgICAgICAgICAgICBTVEEuenB4ICgweDY4KTsgICAgICAgICAgICAgICAvLyBzYXZlIGJ5dGUgYXQgRkFDMixYXHJcbi8qIGJjMTUgKi8gICAgICAgICAgICAgICAgICAgREVYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZGVjcmVtZW50IGNvdW50XHJcbi8qIGJjMTYgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYmMxMVwiKTsgICAgICAgICAgICAvLyBsb29wIGlmIG5vdCBhbGwgZG9uZVxyXG4vKiBiYzE4ICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwiZmFjb3ZfMDA3MFwiKTsgICAgICAgLy8gY2xlYXIgRkFDMSByb3VuZGluZyBieXRlXHJcbi8qIGJjMWEgKi8gICAgICAgIF9gX2JjMWFgOyAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcm91bmQgRkFDMVxyXG4vKiBiYzFiICovICAgX2Byb3VuZF9iYzFiYDsgIExEQS56cGcgKFwiZmFjZXhwXzAwNjFcIik7ICAgICAgLy8gZ2V0IEZBQzEgZXhwb25lbnRcclxuLyogYmMxZCAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9iYzFhXCIpOyAgICAgICAgICAgIC8vIGV4aXQgaWYgemVyb1xyXG4vKiBiYzFmICovICAgICAgICAgICAgICAgICAgIEFTTC56cGcgKFwiZmFjb3ZfMDA3MFwiKTsgICAgICAgLy8gc2hpZnQgRkFDMSByb3VuZGluZyBieXRlXHJcbi8qIGJjMjEgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYmMxYVwiKTsgICAgICAgICAgICAvLyBleGl0IGlmIG5vIG92ZXJmbG93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcm91bmQgRkFDMSAobm8gY2hlY2spXHJcbi8qIGJjMjMgKi8gICAgICAgIF9gX2JjMjNgOyAgSlNSLmFicyAoXCJfYjk2ZlwiKTsgICAgICAgICAgICAvLyBpbmNyZW1lbnQgRkFDMSBtYW50aXNzYVxyXG4vKiBiYzI2ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2JjMWFcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vIG92ZXJmbG93XHJcbi8qIGJjMjggKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfYjkzOFwiKTsgICAgICAgICAgICAvLyBub3JuYWxpc2UgRkFDMSBmb3IgQz0xIGFuZCByZXR1cm5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gZ2V0IEZBQzEgc2lnblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBBID0gJEZGLCBDYiA9IDEvLXZlIEEgPSAkMDEsIENiID0gMC8rdmUsIEEgPSAkMDAsIENiID0gPy8wXHJcbi8qIGJjMmIgKi8gICAgX2BzaWduX2JjMmJgOyAgTERBLnpwZyAoXCJmYWNleHBfMDA2MVwiKTsgICAgICAvLyBnZXQgRkFDMSBleHBvbmVudFxyXG4vKiBiYzJkICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2JjMzhcIik7ICAgICAgICAgICAgLy8gZXhpdCBpZiB6ZXJvIChhbGxyZWFkeSBjb3JyZWN0IFNHTigwKT0wKVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyByZXR1cm4gQSA9ICRGRiwgQ2IgPSAxLy12ZSBBID0gJDAxLCBDYiA9IDAvK3ZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gPSAwIGNoZWNrXHJcbi8qIGJjMmYgKi8gICAgICAgIF9gX2JjMmZgOyAgTERBLnpwZyAoXCJmYWNzZ25fMDA2NlwiKTsgICAgICAvLyBlbHNlIGdldCBGQUMxIHNpZ24gKGI3KVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyByZXR1cm4gQSA9ICRGRiwgQ2IgPSAxLy12ZSBBID0gJDAxLCBDYiA9IDAvK3ZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gPSAwIGNoZWNrLCBzaWduIGluIEFcclxuLyogYmMzMSAqLyAgICAgICAgX2BfYmMzMWA7ICBST0wuYWNjICgpOyAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIHNpZ24gYml0IHRvIGNhcnJ5XHJcbi8qIGJjMzIgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHhmZik7ICAgICAgICAgICAgICAgLy8gc2V0IGJ5dGUgZm9yIC12ZSByZXN1bHRcclxuLyogYmMzNCAqLyAgICAgICAgICAgICAgICAgICBCQ1MucmVsIChcIl9iYzM4XCIpOyAgICAgICAgICAgIC8vIHJldHVybiBpZiBzaWduIHdhcyBzZXQgKC12ZSlcclxuLyogYmMzNiAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDAxKTsgICAgICAgICAgICAgICAvLyBlbHNlIHNldCBieXRlIGZvciArdmUgcmVzdWx0XHJcbi8qIGJjMzggKi8gICAgICAgIF9gX2JjMzhgOyAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcGVyZm9ybSBTR04oKVxyXG4vKiBiYzM5ICovICAgICBfYHNnbl9iYzM5YDsgIEpTUi5hYnMgKFwic2lnbl9iYzJiXCIpOyAgICAgICAgLy8gZ2V0IEZBQzEgc2lnbiwgcmV0dXJuIEEgPSAkRkYgLXZlLCBBID0gJDAxICt2ZVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzYXZlIEEgYXMgaW50ZWdlciBieXRlXHJcbi8qIGJjM2MgKi8gICAgICAgIF9gX2JjM2NgOyAgU1RBLnpwZyAoXCJmYWNobyswXzAwNjJcIik7ICAgICAvLyBzYXZlIEZBQzEgbWFudGlzc2EgMVxyXG4vKiBiYzNlICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIEFcclxuLyogYmM0MCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZhY2hvKzFfMDA2M1wiKTsgICAgIC8vIGNsZWFyIEZBQzEgbWFudGlzc2EgMlxyXG4vKiBiYzQyICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4ODgpOyAgICAgICAgICAgICAgIC8vIHNldCBleHBvbmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCBleHBvbmVudCA9IFgsIGNsZWFyIEZBQzEgMyBhbmQgNCBhbmQgbm9ybWFsaXNlXHJcbi8qIGJjNDQgKi8gICAgICAgIF9gX2JjNDRgOyAgTERBLnpwZyAoXCJmYWNobyswXzAwNjJcIik7ICAgICAvLyBnZXQgRkFDMSBtYW50aXNzYSAxXHJcbi8qIGJjNDYgKi8gICAgICAgICAgICAgICAgICAgRU9SLmltbSAoMHhmZik7ICAgICAgICAgICAgICAgLy8gY29tcGxlbWVudCBpdFxyXG4vKiBiYzQ4ICovICAgICAgICAgICAgICAgICAgIFJPTC5hY2MgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNpZ24gYml0IGludG8gY2FycnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgZXhwb25lbnQgPSBYLCBjbGVhciBtYW50aXNzYSA0IGFuZCAzIGFuZCBub3JtYWxpc2UgRkFDMVxyXG4vKiBiYzQ5ICovICAgICAgICBfYF9iYzQ5YDsgIExEQS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIEFcclxuLyogYmM0YiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZhY2hvKzNfMDA2NVwiKTsgICAgIC8vIGNsZWFyIEZBQzEgbWFudGlzc2EgNFxyXG4vKiBiYzRkICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZmFjaG8rMl8wMDY0XCIpOyAgICAgLy8gY2xlYXIgRkFDMSBtYW50aXNzYSAzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IGV4cG9uZW50ID0gWCBhbmQgbm9ybWFsaXNlIEZBQzFcclxuLyogYmM0ZiAqLyAgICAgICAgX2BfYmM0ZmA7ICBTVFguenBnIChcImZhY2V4cF8wMDYxXCIpOyAgICAgIC8vIHNldCBGQUMxIGV4cG9uZW50XHJcbi8qIGJjNTEgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmYWNvdl8wMDcwXCIpOyAgICAgICAvLyBjbGVhciBGQUMxIHJvdW5kaW5nIGJ5dGVcclxuLyogYmM1MyAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZhY3Nnbl8wMDY2XCIpOyAgICAgIC8vIGNsZWFyIEZBQzEgc2lnbiAoYjcpXHJcbi8qIGJjNTUgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfYjhkMlwiKTsgICAgICAgICAgICAvLyBkbyBBQlMgYW5kIG5vcm1hbGlzZSBGQUMxXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHBlcmZvcm0gQUJTKClcclxuLyogYmM1OCAqLyAgICAgX2BhYnNfYmM1OGA7ICBMU1IuenBnIChcImZhY3Nnbl8wMDY2XCIpOyAgICAgIC8vIGNsZWFyIEZBQzEgc2lnbiwgcHV0IHplcm8gaW4gYjdcclxuLyogYmM1YSAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBjb21wYXJlIEZBQzEgd2l0aCAoQVkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBBPSQwMCBpZiBGQUMxID0gKEFZKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgQT0kMDEgaWYgRkFDMSA+IChBWSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIEE9JEZGIGlmIEZBQzEgPCAoQVkpXHJcbi8qIGJjNWIgKi8gICBfYGZjb21wX2JjNWJgOyAgU1RBLnpwZyAoXCJpbmRleCsyXzAwMjRcIik7ICAgICAvLyBzYXZlIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYmM1ZCAqLyAgICAgICAgX2BfYmM1ZGA7ICBTVFkuenBnIChcImluZGV4KzNfMDAyNVwiKTsgICAgIC8vIHNhdmUgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYmM1ZiAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBpbmRleFxyXG4vKiBiYzYxICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwiaW5kZXgrMl8wMDI0XCIpOyAgICAgLy8gZ2V0IGV4cG9uZW50XHJcbi8qIGJjNjMgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGluZGV4XHJcbi8qIGJjNjQgKi8gICAgICAgICAgICAgICAgICAgVEFYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSAoQVkpIGV4cG9uZW50IHRvIFhcclxuLyogYmM2NSAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcInNpZ25fYmMyYlwiKTsgICAgICAgIC8vIGJyYW5jaCBpZiAoQVkpIGV4cG9uZW50PTAgYW5kIGdldCBGQUMxIHNpZ25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBID0gJEZGLCBDYiA9IDEvLXZlIEEgPSAkMDEsIENiID0gMC8rdmVcclxuLyogYmM2NyAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcImluZGV4KzJfMDAyNFwiKTsgICAgIC8vIGdldCAoQVkpIG1hbnRpc3NhIDEsIHdpdGggc2lnblxyXG4vKiBiYzY5ICovICAgICAgICAgICAgICAgICAgIEVPUi56cGcgKFwiZmFjc2duXzAwNjZcIik7ICAgICAgLy8gRU9SIEZBQzEgc2lnbiAoYjcpXHJcbi8qIGJjNmIgKi8gICAgICAgICAgICAgICAgICAgQk1JLnJlbCAoXCJfYmMyZlwiKTsgICAgICAgICAgICAvLyBpZiBzaWducyA8PiBkbyByZXR1cm4gQSA9ICRGRiwgQ2IgPSAxLy12ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgPSAkMDEsIENiID0gMC8rdmUgYW5kIHJldHVyblxyXG4vKiBiYzZkICovICAgICAgICAgICAgICAgICAgIENQWC56cGcgKFwiZmFjZXhwXzAwNjFcIik7ICAgICAgLy8gY29tcGFyZSAoQVkpIGV4cG9uZW50IHdpdGggRkFDMSBleHBvbmVudFxyXG4vKiBiYzZmICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2JjOTJcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIGRpZmZlcmVudFxyXG4vKiBiYzcxICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwiaW5kZXgrMl8wMDI0XCIpOyAgICAgLy8gZ2V0IChBWSkgbWFudGlzc2EgMSwgd2l0aCBzaWduXHJcbi8qIGJjNzMgKi8gICAgICAgICAgICAgICAgICAgT1JBLmltbSAoMHg4MCk7ICAgICAgICAgICAgICAgLy8gbm9ybWFsaXNlIHRvcCBiaXRcclxuLyogYmM3NSAqLyAgICAgICAgICAgICAgICAgICBDTVAuenBnIChcImZhY2hvKzBfMDA2MlwiKTsgICAgIC8vIGNvbXBhcmUgd2l0aCBGQUMxIG1hbnRpc3NhIDFcclxuLyogYmM3NyAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9iYzkyXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBkaWZmZXJlbnRcclxuLyogYmM3OSAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgaW5kZXhcclxuLyogYmM3YSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcImluZGV4KzJfMDAyNFwiKTsgICAgIC8vIGdldCBtYW50aXNzYSAyXHJcbi8qIGJjN2MgKi8gICAgICAgICAgICAgICAgICAgQ01QLnpwZyAoXCJmYWNobysxXzAwNjNcIik7ICAgICAvLyBjb21wYXJlIHdpdGggRkFDMSBtYW50aXNzYSAyXHJcbi8qIGJjN2UgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYmM5MlwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgZGlmZmVyZW50XHJcbi8qIGJjODAgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGluZGV4XHJcbi8qIGJjODEgKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJpbmRleCsyXzAwMjRcIik7ICAgICAvLyBnZXQgbWFudGlzc2EgM1xyXG4vKiBiYzgzICovICAgICAgICAgICAgICAgICAgIENNUC56cGcgKFwiZmFjaG8rMl8wMDY0XCIpOyAgICAgLy8gY29tcGFyZSB3aXRoIEZBQzEgbWFudGlzc2EgM1xyXG4vKiBiYzg1ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2JjOTJcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIGRpZmZlcmVudFxyXG4vKiBiYzg3ICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBpbmRleFxyXG4vKiBiYzg4ICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4N2YpOyAgICAgICAgICAgICAgIC8vIHNldCBmb3IgMS8yIHZhbHVlIHJvdW5kaW5nIGJ5dGVcclxuLyogYmM4YSAqLyAgICAgICAgICAgICAgICAgICBDTVAuenBnIChcImZhY292XzAwNzBcIik7ICAgICAgIC8vIGNvbXBhcmUgd2l0aCBGQUMxIHJvdW5kaW5nIGJ5dGUgKHNldCBjYXJyeSlcclxuLyogYmM4YyAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcImluZGV4KzJfMDAyNFwiKTsgICAgIC8vIGdldCBtYW50aXNzYSA0XHJcbi8qIGJjOGUgKi8gICAgICAgICAgICAgICAgICAgU0JDLnpwZyAoXCJmYWNobyszXzAwNjVcIik7ICAgICAvLyBzdWJ0cmFjdCBGQUMxIG1hbnRpc3NhIDRcclxuLyogYmM5MCAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9iY2JhXCIpOyAgICAgICAgICAgIC8vIGV4aXQgaWYgbWFudGlzc2EgNCBlcXVhbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldHMgaGVyZSBpZiBudW1iZXIgPD4gRkFDMVxyXG4vKiBiYzkyICovICAgICAgICBfYF9iYzkyYDsgIExEQS56cGcgKFwiZmFjc2duXzAwNjZcIik7ICAgICAgLy8gZ2V0IEZBQzEgc2lnbiAoYjcpXHJcbi8qIGJjOTQgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYmM5OFwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgRkFDMSA+IChBWSlcclxuLyogYmM5NiAqLyAgICAgICAgICAgICAgICAgICBFT1IuaW1tICgweGZmKTsgICAgICAgICAgICAgICAvLyBlbHNlIHRvZ2dsZSBGQUMxIHNpZ25cclxuLyogYmM5OCAqLyAgICAgICAgX2BfYmM5OGA7ICBKTVAuYWJzIChcIl9iYzMxXCIpOyAgICAgICAgICAgIC8vIHJldHVybiBBID0gJEZGLCBDYiA9IDEvLXZlIEEgPSAkMDEsIENiID0gMC8rdmVcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY29udmVydCBGQUMxIGZsb2F0aW5nIHRvIGZpeGVkXHJcbi8qIGJjOWIgKi8gICAgX2BxaW50X2JjOWJgOyAgTERBLnpwZyAoXCJmYWNleHBfMDA2MVwiKTsgICAgICAvLyBnZXQgRkFDMSBleHBvbmVudFxyXG4vKiBiYzlkICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2JjZTlcIik7ICAgICAgICAgICAgLy8gaWYgemVybyBnbyBjbGVhciBGQUMxIGFuZCByZXR1cm5cclxuLyogYmM5ZiAqLyAgICAgICAgICAgICAgICAgICBTRUMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzZXQgY2FycnkgZm9yIHN1YnRyYWN0XHJcbi8qIGJjYTAgKi8gICAgICAgICAgICAgICAgICAgU0JDLmltbSAoMHhhMCk7ICAgICAgICAgICAgICAgLy8gc3VidHJhY3QgbWF4aW11bSBpbnRlZ2VyIHJhbmdlIGV4cG9uZW50XHJcbi8qIGJjYTIgKi8gICAgICAgICAgICAgICAgICAgQklULnpwZyAoXCJmYWNzZ25fMDA2NlwiKTsgICAgICAvLyB0ZXN0IEZBQzEgc2lnbiAoYjcpXHJcbi8qIGJjYTQgKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfYmNhZlwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgRkFDMSArdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGQUMxIHdhcyAtdmVcclxuLyogYmNhNiAqLyAgICAgICAgICAgICAgICAgICBUQVguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IHN1YnRyYWN0ZWQgZXhwb25lbnRcclxuLyogYmNhNyAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweGZmKTsgICAgICAgICAgICAgICAvLyBvdmVyZmxvdyBmb3IgLXZlIG51bWJlclxyXG4vKiBiY2E5ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiYml0c18wMDY4XCIpOyAgICAgICAgLy8gc2V0IEZBQzEgb3ZlcmZsb3cgYnl0ZVxyXG4vKiBiY2FiICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2I5NGRcIik7ICAgICAgICAgICAgLy8gdHdvcyBjb21wbGVtZW50IEZBQzEgbWFudGlzc2FcclxuLyogYmNhZSAqLyAgICAgICAgICAgICAgICAgICBUWEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIHN1YnRyYWN0ZWQgZXhwb25lbnRcclxuLyogYmNhZiAqLyAgICAgICAgX2BfYmNhZmA7ICBMRFguaW1tICgweDYxKTsgICAgICAgICAgICAgICAvLyBzZXQgaW5kZXggdG8gRkFDMVxyXG4vKiBiY2IxICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4ZjkpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgZXhwb25lbnQgcmVzdWx0XHJcbi8qIGJjYjMgKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfYmNiYlwiKTsgICAgICAgICAgICAvLyBpZiA8IDggc2hpZnRzIHNoaWZ0IEZBQzEgQSB0aW1lcyByaWdodCBhbmQgcmV0dXJuXHJcbi8qIGJjYjUgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfYjk5OVwiKTsgICAgICAgICAgICAvLyBzaGlmdCBGQUMxIEEgdGltZXMgcmlnaHQgKD4gOCBzaGlmdHMpXHJcbi8qIGJjYjggKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJiaXRzXzAwNjhcIik7ICAgICAgICAvLyBjbGVhciBGQUMxIG92ZXJmbG93IGJ5dGVcclxuLyogYmNiYSAqLyAgICAgICAgX2BfYmNiYWA7ICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzaGlmdCBGQUMxIEEgdGltZXMgcmlnaHRcclxuLyogYmNiYiAqLyAgICAgICAgX2BfYmNiYmA7ICBUQVkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IHNoaWZ0IGNvdW50XHJcbi8qIGJjYmMgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJmYWNzZ25fMDA2NlwiKTsgICAgICAvLyBnZXQgRkFDMSBzaWduIChiNylcclxuLyogYmNiZSAqLyAgICAgICAgICAgICAgICAgICBBTkQuaW1tICgweDgwKTsgICAgICAgICAgICAgICAvLyBtYXNrIHNpZ24gYml0IG9ubHkgKHgwMDAgMDAwMClcclxuLyogYmNjMCAqLyAgICAgICAgICAgICAgICAgICBMU1IuenBnIChcImZhY2hvKzBfMDA2MlwiKTsgICAgIC8vIHNoaWZ0IEZBQzEgbWFudGlzc2EgMVxyXG4vKiBiY2MyICovICAgICAgICAgICAgICAgICAgIE9SQS56cGcgKFwiZmFjaG8rMF8wMDYyXCIpOyAgICAgLy8gT1Igc2lnbiBpbiBiNyBGQUMxIG1hbnRpc3NhIDFcclxuLyogYmNjNCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZhY2hvKzBfMDA2MlwiKTsgICAgIC8vIHNhdmUgRkFDMSBtYW50aXNzYSAxXHJcbi8qIGJjYzYgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfYjliMFwiKTsgICAgICAgICAgICAvLyBzaGlmdCBGQUMxIFkgdGltZXMgcmlnaHRcclxuLyogYmNjOSAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcImJpdHNfMDA2OFwiKTsgICAgICAgIC8vIGNsZWFyIEZBQzEgb3ZlcmZsb3cgYnl0ZVxyXG4vKiBiY2NiICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHBlcmZvcm0gSU5UKClcclxuLyogYmNjYyAqLyAgICAgX2BpbnRfYmNjY2A7ICBMREEuenBnIChcImZhY2V4cF8wMDYxXCIpOyAgICAgIC8vIGdldCBGQUMxIGV4cG9uZW50XHJcbi8qIGJjY2UgKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHhhMCk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIG1heCBpbnRcclxuLyogYmNkMCAqLyAgICAgICAgICAgICAgICAgICBCQ1MucmVsIChcIl9iY2YyXCIpOyAgICAgICAgICAgIC8vIGV4aXQgaWYgPj0gKGFsbHJlYWR5IGludCwgdG9vIGJpZyBmb3IgZnJhY3Rpb25hbCBwYXJ0ISlcclxuLyogYmNkMiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcInFpbnRfYmM5YlwiKTsgICAgICAgIC8vIGNvbnZlcnQgRkFDMSBmbG9hdGluZyB0byBmaXhlZFxyXG4vKiBiY2Q1ICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwiZmFjb3ZfMDA3MFwiKTsgICAgICAgLy8gc2F2ZSBGQUMxIHJvdW5kaW5nIGJ5dGVcclxuLyogYmNkNyAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZhY3Nnbl8wMDY2XCIpOyAgICAgIC8vIGdldCBGQUMxIHNpZ24gKGI3KVxyXG4vKiBiY2Q5ICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwiZmFjc2duXzAwNjZcIik7ICAgICAgLy8gc2F2ZSBGQUMxIHNpZ24gKGI3KVxyXG4vKiBiY2RiICovICAgICAgICAgICAgICAgICAgIEVPUi5pbW0gKDB4ODApOyAgICAgICAgICAgICAgIC8vIHRvZ2dsZSBGQUMxIHNpZ25cclxuLyogYmNkZCAqLyAgICAgICAgICAgICAgICAgICBST0wuYWNjICgpOyAgICAgICAgICAgICAgICAgICAvLyBzaGlmdCBpbnRvIGNhcnJ5XHJcbi8qIGJjZGUgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHhhMCk7ICAgICAgICAgICAgICAgLy8gc2V0IG5ldyBleHBvbmVudFxyXG4vKiBiY2UwICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZmFjZXhwXzAwNjFcIik7ICAgICAgLy8gc2F2ZSBGQUMxIGV4cG9uZW50XHJcbi8qIGJjZTIgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJmYWNobyszXzAwNjVcIik7ICAgICAvLyBnZXQgRkFDMSBtYW50aXNzYSA0XHJcbi8qIGJjZTQgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJjaGFyYWNfMDAwN1wiKTsgICAgICAvLyBzYXZlIEZBQzEgbWFudGlzc2EgNCBmb3IgcG93ZXIgZnVuY3Rpb25cclxuLyogYmNlNiAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9iOGQyXCIpOyAgICAgICAgICAgIC8vIGRvIEFCUyBhbmQgbm9ybWFsaXNlIEZBQzFcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY2xlYXIgRkFDMSBhbmQgcmV0dXJuXHJcbi8qIGJjZTkgKi8gICAgICAgIF9gX2JjZTlgOyAgU1RBLnpwZyAoXCJmYWNobyswXzAwNjJcIik7ICAgICAvLyBjbGVhciBGQUMxIG1hbnRpc3NhIDFcclxuLyogYmNlYiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZhY2hvKzFfMDA2M1wiKTsgICAgIC8vIGNsZWFyIEZBQzEgbWFudGlzc2EgMlxyXG4vKiBiY2VkICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZmFjaG8rMl8wMDY0XCIpOyAgICAgLy8gY2xlYXIgRkFDMSBtYW50aXNzYSAzXHJcbi8qIGJjZWYgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmYWNobyszXzAwNjVcIik7ICAgICAvLyBjbGVhciBGQUMxIG1hbnRpc3NhIDRcclxuLyogYmNmMSAqLyAgICAgICAgICAgICAgICAgICBUQVkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBZXHJcbi8qIGJjZjIgKi8gICAgICAgIF9gX2JjZjJgOyAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gZ2V0IEZBQzEgZnJvbSBzdHJpbmdcclxuLyogYmNmMyAqLyAgICAgX2BmaW5fYmNmM2A7ICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBZXHJcbi8qIGJjZjUgKi8gICAgICAgICAgICAgICAgICAgTERYLmltbSAoMHgwYSk7ICAgICAgICAgICAgICAgLy8gc2V0IGluZGV4XHJcbi8qIGJjZjcgKi8gICAgICAgIF9gX2JjZjdgOyAgU1RZLnpweCAoMHg1ZCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgYnl0ZVxyXG4vKiBiY2Y5ICovICAgICAgICAgICAgICAgICAgIERFWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCBpbmRleFxyXG4vKiBiY2ZhICovICAgICAgICAgICAgICAgICAgIEJQTC5yZWwgKFwiX2JjZjdcIik7ICAgICAgICAgICAgLy8gbG9vcCB1bnRpbCBudW1leHAgdG8gbmVnbnVtIChhbmQgRkFDMSkgPSAkMDBcclxuLyogYmNmYyAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9iZDBkXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBmaXJzdCBjaGFyYWN0ZXIgaXMgbnVtZXJpY1xyXG4vKiBiY2ZlICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4MmQpOyAgICAgICAgICAgICAgIC8vIGVsc2UgY29tcGFyZSB3aXRoIFwiLVwiXHJcbi8qIGJkMDAgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYmQwNlwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbm90IFwiLVwiXHJcbi8qIGJkMDIgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJzZ25mbGdfMDA2N1wiKTsgICAgICAvLyBzZXQgZmxhZyBmb3IgLXZlIG4gKG5lZ251bSA9ICRGRilcclxuLyogYmQwNCAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9iZDBhXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBhbHdheXNcclxuLyogYmQwNiAqLyAgICAgICAgX2BfYmQwNmA7ICBDTVAuaW1tICgweDJiKTsgICAgICAgICAgICAgICAvLyBlbHNlIGNvbXBhcmUgd2l0aCBcIitcIlxyXG4vKiBiZDA4ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2JkMGZcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vdCBcIitcIlxyXG4vKiBiZDBhICovICAgICAgICBfYF9iZDBhYDsgIEpTUi5hYnMgKFwiY2hyZ2V0KzBfMDA3M1wiKTsgICAgLy8gaW5jcmVtZW50IGFuZCBzY2FuIG1lbW9yeVxyXG4vKiBiZDBkICovICAgICAgICBfYF9iZDBkYDsgIEJDQy5yZWwgKFwiX2JkNmFcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG51bWVyaWMgY2hhcmFjdGVyXHJcbi8qIGJkMGYgKi8gICAgICAgIF9gX2JkMGZgOyAgQ01QLmltbSAoMHgyZSk7ICAgICAgICAgICAgICAgLy8gZWxzZSBjb21wYXJlIHdpdGggXCIuXCJcclxuLyogYmQxMSAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9iZDQxXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBcIi5cIlxyXG4vKiBiZDEzICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4NDUpOyAgICAgICAgICAgICAgIC8vIGVsc2UgY29tcGFyZSB3aXRoIFwiRVwiXHJcbi8qIGJkMTUgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYmQ0N1wiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbm90IFwiRVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2FzIFwiRVwiIHNvIGV2YWx1YXRlIGV4cG9uZW50aWFsIHBhcnRcclxuLyogYmQxNyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImNocmdldCswXzAwNzNcIik7ICAgIC8vIGluY3JlbWVudCBhbmQgc2NhbiBtZW1vcnlcclxuLyogYmQxYSAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9iZDMzXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBudW1lcmljIGNoYXJhY3RlclxyXG4vKiBiZDFjICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4YWIpOyAgICAgICAgICAgICAgIC8vIGVsc2UgY29tcGFyZSB3aXRoIHRva2VuIGZvciAtXHJcbi8qIGJkMWUgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYmQyZVwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgdG9rZW4gZm9yIC1cclxuLyogYmQyMCAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW1tICgweDJkKTsgICAgICAgICAgICAgICAvLyBlbHNlIGNvbXBhcmUgd2l0aCBcIi1cIlxyXG4vKiBiZDIyICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2JkMmVcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIFwiLVwiXHJcbi8qIGJkMjQgKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHhhYSk7ICAgICAgICAgICAgICAgLy8gZWxzZSBjb21wYXJlIHdpdGggdG9rZW4gZm9yICtcclxuLyogYmQyNiAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9iZDMwXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiB0b2tlbiBmb3IgK1xyXG4vKiBiZDI4ICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4MmIpOyAgICAgICAgICAgICAgIC8vIGVsc2UgY29tcGFyZSB3aXRoIFwiK1wiXHJcbi8qIGJkMmEgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYmQzMFwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgXCIrXCJcclxuLyogYmQyYyAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9iZDM1XCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBhbHdheXNcclxuLyogYmQyZSAqLyAgICAgICAgX2BfYmQyZWA7ICBST1IuenBnIChcInRlbXBmMis0XzAwNjBcIik7ICAgIC8vIHNldCBleHBvbmVudCAtdmUgZmxhZyAoQywgd2hpY2g9MSwgaW50byBiNylcclxuLyogYmQzMCAqLyAgICAgICAgX2BfYmQzMGA7ICBKU1IuYWJzIChcImNocmdldCswXzAwNzNcIik7ICAgIC8vIGluY3JlbWVudCBhbmQgc2NhbiBtZW1vcnlcclxuLyogYmQzMyAqLyAgICAgICAgX2BfYmQzM2A7ICBCQ0MucmVsIChcIl9iZDkxXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBudW1lcmljIGNoYXJhY3RlclxyXG4vKiBiZDM1ICovICAgICAgICBfYF9iZDM1YDsgIEJJVC56cGcgKFwidGVtcGYyKzRfMDA2MFwiKTsgICAgLy8gdGVzdCBleHBvbmVudCAtdmUgZmxhZ1xyXG4vKiBiZDM3ICovICAgICAgICAgICAgICAgICAgIEJQTC5yZWwgKFwiX2JkNDdcIik7ICAgICAgICAgICAgLy8gaWYgK3ZlIGdvIGV2YWx1YXRlIGV4cG9uZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBkbyBleHBvbmVudCA9IC1leHBvbmVudFxyXG4vKiBiZDM5ICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIHJlc3VsdFxyXG4vKiBiZDNiICovICAgICAgICAgICAgICAgICAgIFNFQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNldCBjYXJyeSBmb3Igc3VidHJhY3RcclxuLyogYmQzYyAqLyAgICAgICAgICAgICAgICAgICBTQkMuenBnIChcInRlbXBmMisyXzAwNWVcIik7ICAgIC8vIHN1YnRyYWN0IGV4cG9uZW50IGJ5dGVcclxuLyogYmQzZSAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9iZDQ5XCIpOyAgICAgICAgICAgIC8vIGdvIGV2YWx1YXRlIGV4cG9uZW50XHJcbi8qIGJkNDEgKi8gICAgICAgIF9gX2JkNDFgOyAgUk9SLnpwZyAoXCJ0ZW1wZjIrM18wMDVmXCIpOyAgICAvLyBzZXQgZGVjaW1hbCBwb2ludCBmbGFnXHJcbi8qIGJkNDMgKi8gICAgICAgICAgICAgICAgICAgQklULnpwZyAoXCJ0ZW1wZjIrM18wMDVmXCIpOyAgICAvLyB0ZXN0IGRlY2ltYWwgcG9pbnQgZmxhZ1xyXG4vKiBiZDQ1ICovICAgICAgICAgICAgICAgICAgIEJWQy5yZWwgKFwiX2JkMGFcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG9ubHkgb25lIGRlY2ltYWwgcG9pbnQgc28gZmFyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXZhbHVhdGUgZXhwb25lbnRcclxuLyogYmQ0NyAqLyAgICAgICAgX2BfYmQ0N2A7ICBMREEuenBnIChcInRlbXBmMisyXzAwNWVcIik7ICAgIC8vIGdldCBleHBvbmVudCBjb3VudCBieXRlXHJcbi8qIGJkNDkgKi8gICAgICAgIF9gX2JkNDlgOyAgU0VDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2V0IGNhcnJ5IGZvciBzdWJ0cmFjdFxyXG4vKiBiZDRhICovICAgICAgICAgICAgICAgICAgIFNCQy56cGcgKFwidGVtcGYyKzFfMDA1ZFwiKTsgICAgLy8gc3VidHJhY3QgbnVtZXJhdG9yIGV4cG9uZW50XHJcbi8qIGJkNGMgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJ0ZW1wZjIrMl8wMDVlXCIpOyAgICAvLyBzYXZlIGV4cG9uZW50IGNvdW50IGJ5dGVcclxuLyogYmQ0ZSAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9iZDYyXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBubyBhZGp1c3RtZW50XHJcbi8qIGJkNTAgKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfYmQ1YlwiKTsgICAgICAgICAgICAvLyBlbHNlIGlmICt2ZSBnbyBkbyBGQUMxKjEwXmV4cGNudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgZ28gZG8gRkFDMS8xMF4oMC1leHBjbnQpXHJcbi8qIGJkNTIgKi8gICAgICAgIF9gX2JkNTJgOyAgSlNSLmFicyAoXCJkaXYxMF9iYWZlXCIpOyAgICAgICAvLyBkaXZpZGUgRkFDMSBieSAxMFxyXG4vKiBiZDU1ICovICAgICAgICAgICAgICAgICAgIElOQy56cGcgKFwidGVtcGYyKzJfMDA1ZVwiKTsgICAgLy8gaW5jcmVtZW50IGV4cG9uZW50IGNvdW50IGJ5dGVcclxuLyogYmQ1NyAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9iZDUyXCIpOyAgICAgICAgICAgIC8vIGxvb3AgdW50aWwgYWxsIGRvbmVcclxuLyogYmQ1OSAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9iZDYyXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBhbHdheXNcclxuLyogYmQ1YiAqLyAgICAgICAgX2BfYmQ1YmA7ICBKU1IuYWJzIChcIm11bDEwX2JhZTJcIik7ICAgICAgIC8vIG11bHRpcGx5IEZBQzEgYnkgMTBcclxuLyogYmQ1ZSAqLyAgICAgICAgICAgICAgICAgICBERUMuenBnIChcInRlbXBmMisyXzAwNWVcIik7ICAgIC8vIGRlY3JlbWVudCBleHBvbmVudCBjb3VudCBieXRlXHJcbi8qIGJkNjAgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYmQ1YlwiKTsgICAgICAgICAgICAvLyBsb29wIHVudGlsIGFsbCBkb25lXHJcbi8qIGJkNjIgKi8gICAgICAgIF9gX2JkNjJgOyAgTERBLnpwZyAoXCJzZ25mbGdfMDA2N1wiKTsgICAgICAvLyBnZXQgLXZlIGZsYWdcclxuLyogYmQ2NCAqLyAgICAgICAgICAgICAgICAgICBCTUkucmVsIChcIl9iZDY3XCIpOyAgICAgICAgICAgIC8vIGlmIC12ZSBkbyAtIEZBQzEgYW5kIHJldHVyblxyXG4vKiBiZDY2ICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGRvIC0gRkFDMSBhbmQgcmV0dXJuXHJcbi8qIGJkNjcgKi8gICAgICAgIF9gX2JkNjdgOyAgSk1QLmFicyAoXCJuZWdvcF9iZmI0XCIpOyAgICAgICAvLyBkbyAtIEZBQzFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyB1bnNpZ25lZCBGQUMxKjEwK251bWJlclxyXG4vKiBiZDZhICovICAgICAgICBfYF9iZDZhYDsgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgY2hhcmFjdGVyXHJcbi8qIGJkNmIgKi8gICAgICAgICAgICAgICAgICAgQklULnpwZyAoXCJ0ZW1wZjIrM18wMDVmXCIpOyAgICAvLyB0ZXN0IGRlY2ltYWwgcG9pbnQgZmxhZ1xyXG4vKiBiZDZkICovICAgICAgICAgICAgICAgICAgIEJQTC5yZWwgKFwiX2JkNzFcIik7ICAgICAgICAgICAgLy8gc2tpcCBleHBvbmVudCBpbmNyZW1lbnQgaWYgbm90IHNldFxyXG4vKiBiZDZmICovICAgICAgICAgICAgICAgICAgIElOQy56cGcgKFwidGVtcGYyKzFfMDA1ZFwiKTsgICAgLy8gZWxzZSBpbmNyZW1lbnQgbnVtYmVyIGV4cG9uZW50XHJcbi8qIGJkNzEgKi8gICAgICAgIF9gX2JkNzFgOyAgSlNSLmFicyAoXCJtdWwxMF9iYWUyXCIpOyAgICAgICAvLyBtdWx0aXBseSBGQUMxIGJ5IDEwXHJcbi8qIGJkNzQgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBjaGFyYWN0ZXJcclxuLyogYmQ3NSAqLyAgICAgICAgICAgICAgICAgICBTRUMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzZXQgY2FycnkgZm9yIHN1YnRyYWN0XHJcbi8qIGJkNzYgKi8gICAgICAgICAgICAgICAgICAgU0JDLmltbSAoMHgzMCk7ICAgICAgICAgICAgICAgLy8gY29udmVydCB0byBiaW5hcnlcclxuLyogYmQ3OCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImZpbmxvZ19iZDdlXCIpOyAgICAgIC8vIGV2YWx1YXRlIG5ldyBBU0NJSSBkaWdpdFxyXG4vKiBiZDdiICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2JkMGFcIik7ICAgICAgICAgICAgLy8gZ28gZG8gbmV4dCBjaGFyYWN0ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBldmFsdWF0ZSBuZXcgQVNDSUkgZGlnaXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtdWx0aXBseSBGQUMxIGJ5IDEwIHRoZW4gKEFCUykgYWRkIGluIG5ldyBkaWdpdFxyXG4vKiBiZDdlICovICBfYGZpbmxvZ19iZDdlYDsgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgZGlnaXRcclxuLyogYmQ3ZiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIm1vdmFmX2JjMGNcIik7ICAgICAgIC8vIHJvdW5kIGFuZCBjb3B5IEZBQzEgdG8gRkFDMlxyXG4vKiBiZDgyICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgZGlnaXRcclxuLyogYmQ4MyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9iYzNjXCIpOyAgICAgICAgICAgIC8vIHNhdmUgQSBhcyBpbnRlZ2VyIGJ5dGVcclxuLyogYmQ4NiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImFyZ3Nnbl8wMDZlXCIpOyAgICAgIC8vIGdldCBGQUMyIHNpZ24gKGI3KVxyXG4vKiBiZDg4ICovICAgICAgICAgICAgICAgICAgIEVPUi56cGcgKFwiZmFjc2duXzAwNjZcIik7ICAgICAgLy8gdG9nZ2xlIHdpdGggRkFDMSBzaWduIChiNylcclxuLyogYmQ4YSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImFyaXNnbl8wMDZmXCIpOyAgICAgIC8vIHNhdmUgc2lnbiBjb21wYXJlIChGQUMxIEVPUiBGQUMyKVxyXG4vKiBiZDhjICovICAgICAgICAgICAgICAgICAgIExEWC56cGcgKFwiZmFjZXhwXzAwNjFcIik7ICAgICAgLy8gZ2V0IEZBQzEgZXhwb25lbnRcclxuLyogYmQ4ZSAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcImZhZGR0X2I4NmFcIik7ICAgICAgIC8vIGFkZCBGQUMyIHRvIEZBQzEgYW5kIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV2YWx1YXRlIG5leHQgY2hhcmFjdGVyIG9mIGV4cG9uZW50aWFsIHBhcnQgb2YgbnVtYmVyXHJcbi8qIGJkOTEgKi8gICAgICAgIF9gX2JkOTFgOyAgTERBLnpwZyAoXCJ0ZW1wZjIrMl8wMDVlXCIpOyAgICAvLyBnZXQgZXhwb25lbnQgY291bnQgYnl0ZVxyXG4vKiBiZDkzICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4MGEpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCAxMCBkZWNpbWFsXHJcbi8qIGJkOTUgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYmRhMFwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbGVzc1xyXG4vKiBiZDk3ICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4NjQpOyAgICAgICAgICAgICAgIC8vIG1ha2UgYWxsIC12ZSBleHBvbmVudHMgPSAtMTAwIGRlY2ltYWwgKGNhdXNlcyB1bmRlcmZsb3cpXHJcbi8qIGJkOTkgKi8gICAgICAgICAgICAgICAgICAgQklULnpwZyAoXCJ0ZW1wZjIrNF8wMDYwXCIpOyAgICAvLyB0ZXN0IGV4cG9uZW50IC12ZSBmbGFnXHJcbi8qIGJkOWIgKi8gICAgICAgICAgICAgICAgICAgQk1JLnJlbCAoXCJfYmRhZVwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgLXZlXHJcbi8qIGJkOWQgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJvdmVycl9iOTdlXCIpOyAgICAgICAvLyBlbHNlIGRvIG92ZXJmbG93IGVycm9yIHRoZW4gd2FybSBzdGFydFxyXG4vKiBiZGEwICovICAgICAgICBfYF9iZGEwYDsgIEFTTC5hY2MgKCk7ICAgICAgICAgICAgICAgICAgIC8vICoyXHJcbi8qIGJkYTEgKi8gICAgICAgICAgICAgICAgICAgQVNMLmFjYyAoKTsgICAgICAgICAgICAgICAgICAgLy8gKjRcclxuLyogYmRhMiAqLyAgICAgICAgICAgICAgICAgICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBjYXJyeSBmb3IgYWRkXHJcbi8qIGJkYTMgKi8gICAgICAgICAgICAgICAgICAgQURDLnpwZyAoXCJ0ZW1wZjIrMl8wMDVlXCIpOyAgICAvLyAqNVxyXG4vKiBiZGE1ICovICAgICAgICAgICAgICAgICAgIEFTTC5hY2MgKCk7ICAgICAgICAgICAgICAgICAgIC8vICoxMFxyXG4vKiBiZGE2ICovICAgICAgICAgICAgICAgICAgIENMQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIGNhcnJ5IGZvciBhZGRcclxuLyogYmRhNyAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBzZXQgaW5kZXhcclxuLyogYmRhOSAqLyAgICAgICAgICAgICAgICAgICBBREMuaW55IChcInR4dHB0ciswXzAwN2FcIik7ICAgIC8vIGFkZCBjaGFyYWN0ZXIgKHdpbGwgYmUgJDMwIHRvbyBtdWNoISlcclxuLyogYmRhYiAqLyAgICAgICAgICAgICAgICAgICBTRUMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzZXQgY2FycnkgZm9yIHN1YnRyYWN0XHJcbi8qIGJkYWMgKi8gICAgICAgICAgICAgICAgICAgU0JDLmltbSAoMHgzMCk7ICAgICAgICAgICAgICAgLy8gY29udmVydCBjaGFyYWN0ZXIgdG8gYmluYXJ5XHJcbi8qIGJkYWUgKi8gICAgICAgIF9gX2JkYWVgOyAgU1RBLnpwZyAoXCJ0ZW1wZjIrMl8wMDVlXCIpOyAgICAvLyBzYXZlIGV4cG9uZW50IGNvdW50IGJ5dGVcclxuLyogYmRiMCAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9iZDMwXCIpOyAgICAgICAgICAgIC8vIGdvIGdldCBuZXh0IGNoYXJhY3RlclxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBsaW1pdHMgZm9yIHNjaWVudGlmaWMgbW9kZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDk5OTk5OTk5LjkwNjI1LCBtYXhpbXVtIHZhbHVlIHdpdGggYXQgbGVhc3Qgb25lIGRlY2ltYWxcclxuLyogYmRiMyAqLyAgIF9gbjA5OTlfYmRiM2A7ICBfLmJ5dGVzKDB4OWIsIDB4M2UsIDB4YmMsIDB4MWYsIDB4ZmQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDk5OTk5OTk5OS4yNSwgbWF4aW11bSB2YWx1ZSBiZWZvcmUgc2NpZW50aWZpYyBub3RhdGlvblxyXG4vKiBiZGI4ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg5ZSwgMHg2ZSwgMHg2YiwgMHgyNywgMHhmZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMTAwMDAwMDAwMFxyXG4vKiBiZGJkICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg5ZSwgMHg2ZSwgMHg2YiwgMHgyOCwgMHgwMCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGRvIFwiIElOIFwiIGxpbmUgbnVtYmVyIG1lc3NhZ2VcclxuLyogYmRjMiAqLyAgIF9gaW5wcnRfYmRjMmA7ICBMREEuaW1tICgweDcxKTsgICAgICAgICAgICAgICAvLyBzZXQgXCIgSU4gXCIgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiZGM0ICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4YTMpOyAgICAgICAgICAgICAgIC8vIHNldCBcIiBJTiBcIiBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiZGM2ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2JkZGFcIik7ICAgICAgICAgICAgLy8gcHJpbnQgbnVsbCB0ZXJtaW5hdGVkIHN0cmluZ1xyXG4vKiBiZGM5ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiY3VybGluKzFfMDAzYVwiKTsgICAgLy8gZ2V0IHRoZSBjdXJyZW50IGxpbmUgbnVtYmVyIGhpZ2ggYnl0ZVxyXG4vKiBiZGNiICovICAgICAgICAgICAgICAgICAgIExEWC56cGcgKFwiY3VybGluKzBfMDAzOVwiKTsgICAgLy8gZ2V0IHRoZSBjdXJyZW50IGxpbmUgbnVtYmVyIGxvdyBieXRlXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHByaW50IFhBIGFzIHVuc2lnbmVkIGludGVnZXJcclxuLyogYmRjZCAqLyAgX2BsaW5wcnRfYmRjZGA7ICBTVEEuenBnIChcImZhY2hvKzBfMDA2MlwiKTsgICAgIC8vIHNhdmUgaGlnaCBieXRlIGFzIEZBQzEgbWFudGlzc2ExXHJcbi8qIGJkY2YgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJmYWNobysxXzAwNjNcIik7ICAgICAvLyBzYXZlIGxvdyBieXRlIGFzIEZBQzEgbWFudGlzc2EyXHJcbi8qIGJkZDEgKi8gICAgICAgICAgICAgICAgICAgTERYLmltbSAoMHg5MCk7ICAgICAgICAgICAgICAgLy8gc2V0IGV4cG9uZW50IHRvIDE2ZCBiaXRzXHJcbi8qIGJkZDMgKi8gICAgICAgICAgICAgICAgICAgU0VDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2V0IGludGVnZXIgaXMgK3ZlIGZsYWdcclxuLyogYmRkNCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9iYzQ5XCIpOyAgICAgICAgICAgIC8vIHNldCBleHBvbmVudCA9IFgsIGNsZWFyIG1hbnRpc3NhIDQgYW5kIDMgYW5kIG5vcm1hbGlzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZBQzFcclxuLyogYmRkNyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9iZGRmXCIpOyAgICAgICAgICAgIC8vIGNvbnZlcnQgRkFDMSB0byBzdHJpbmdcclxuLyogYmRkYSAqLyAgICAgICAgX2BfYmRkYWA7ICBKTVAuYWJzIChcInN0cm91dF9hYjFlXCIpOyAgICAgIC8vIHByaW50IG51bGwgdGVybWluYXRlZCBzdHJpbmdcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY29udmVydCBGQUMxIHRvIEFTQ0lJIHN0cmluZyByZXN1bHQgaW4gKEFZKVxyXG4vKiBiZGRkICovICAgIF9gZm91dF9iZGRkYDsgIExEWS5pbW0gKDB4MDEpOyAgICAgICAgICAgICAgIC8vIHNldCBpbmRleCA9IDFcclxuLyogYmRkZiAqLyAgICAgICAgX2BfYmRkZmA7ICBMREEuaW1tICgweDIwKTsgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIgPSBcIiBcIiAoYXNzdW1lICt2ZSlcclxuLyogYmRlMSAqLyAgICAgICAgICAgICAgICAgICBCSVQuenBnIChcImZhY3Nnbl8wMDY2XCIpOyAgICAgIC8vIHRlc3QgRkFDMSBzaWduIChiNylcclxuLyogYmRlMyAqLyAgICAgICAgICAgICAgICAgICBCUEwucmVsIChcIl9iZGU3XCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiArdmVcclxuLyogYmRlNSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDJkKTsgICAgICAgICAgICAgICAvLyBlbHNlIGNoYXJhY3RlciA9IFwiLVwiXHJcbi8qIGJkZTcgKi8gICAgICAgIF9gX2JkZTdgOyAgU1RBLmFieSAoXCJiYXN6cHRfMDBmZlwiKTsgICAgICAvLyBzYXZlIGxlYWRpbmcgY2hhcmFjdGVyIChcIiBcIiBvciBcIi1cIilcclxuLyogYmRlYSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZhY3Nnbl8wMDY2XCIpOyAgICAgIC8vIHNhdmUgRkFDMSBzaWduIChiNylcclxuLyogYmRlYyAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcImZidWZwdCswXzAwNzFcIik7ICAgIC8vIHNhdmUgaW5kZXhcclxuLyogYmRlZSAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgaW5kZXhcclxuLyogYmRlZiAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDMwKTsgICAgICAgICAgICAgICAvLyBzZXQgY2hhcmFjdGVyID0gXCIwXCJcclxuLyogYmRmMSAqLyAgICAgICAgICAgICAgICAgICBMRFguenBnIChcImZhY2V4cF8wMDYxXCIpOyAgICAgIC8vIGdldCBGQUMxIGV4cG9uZW50XHJcbi8qIGJkZjMgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYmRmOFwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgRkFDMTw+MFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4cG9uZW50IHdhcyAkMDAgc28gRkFDMSBpcyAwXHJcbi8qIGJkZjUgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfYmYwNFwiKTsgICAgICAgICAgICAvLyBzYXZlIGxhc3QgY2hhcmFjdGVyLCBbRU9UXSBhbmQgZXhpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZBQzEgaXMgc29tZSBub24gemVybyB2YWx1ZVxyXG4vKiBiZGY4ICovICAgICAgICBfYF9iZGY4YDsgIExEQS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIChudW1iZXIgZXhwb25lbnQgY291bnQpXHJcbi8qIGJkZmEgKi8gICAgICAgICAgICAgICAgICAgQ1BYLmltbSAoMHg4MCk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSBGQUMxIGV4cG9uZW50IHdpdGggJDgwICg8MS4wMDAwMClcclxuLyogYmRmYyAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9iZTAwXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiAwLjUgPD0gRkFDMSA8IDEuMFxyXG4vKiBiZGZlICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2JlMDlcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIEZBQzE9PjFcclxuLyogYmUwMCAqLyAgICAgICAgX2BfYmUwMGA7ICBMREEuaW1tICgweGJkKTsgICAgICAgICAgICAgICAvLyBzZXQgMTAwMDAwMDAwMCBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGJlMDIgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHhiZCk7ICAgICAgICAgICAgICAgLy8gc2V0IDEwMDAwMDAwMDAgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYmUwNCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImZtdWx0X2JhMjhcIik7ICAgICAgIC8vIGRvIGNvbnZlcnQgQVksIEZDQTEqKEFZKVxyXG4vKiBiZTA3ICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4ZjcpOyAgICAgICAgICAgICAgIC8vIHNldCBudW1iZXIgZXhwb25lbnQgY291bnRcclxuLyogYmUwOSAqLyAgICAgICAgX2BfYmUwOWA7ICBTVEEuenBnIChcInRlbXBmMisxXzAwNWRcIik7ICAgIC8vIHNhdmUgbnVtYmVyIGV4cG9uZW50IGNvdW50XHJcbi8qIGJlMGIgKi8gICAgICAgIF9gX2JlMGJgOyAgTERBLmltbSAoMHhiOCk7ICAgICAgICAgICAgICAgLy8gc2V0IDk5OTk5OTk5OS4yNSBwb2ludGVyIGxvdyBieXRlIChtYXggYmVmb3JlIHNjaSBub3RlKVxyXG4vKiBiZTBkICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4YmQpOyAgICAgICAgICAgICAgIC8vIHNldCA5OTk5OTk5OTkuMjUgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYmUwZiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImZjb21wX2JjNWJcIik7ICAgICAgIC8vIGNvbXBhcmUgRkFDMSB3aXRoIChBWSlcclxuLyogYmUxMiAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9iZTMyXCIpOyAgICAgICAgICAgIC8vIGV4aXQgaWYgRkFDMSA9IChBWSlcclxuLyogYmUxNCAqLyAgICAgICAgICAgICAgICAgICBCUEwucmVsIChcIl9iZTI4XCIpOyAgICAgICAgICAgIC8vIGdvIGRvIC8xMCBpZiBGQUMxID4gKEFZKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZBQzEgPCAoQVkpXHJcbi8qIGJlMTYgKi8gICAgICAgIF9gX2JlMTZgOyAgTERBLmltbSAoMHhiMyk7ICAgICAgICAgICAgICAgLy8gc2V0IDk5OTk5OTk5LjkwNjI1IHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYmUxOCAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweGJkKTsgICAgICAgICAgICAgICAvLyBzZXQgOTk5OTk5OTkuOTA2MjUgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYmUxYSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImZjb21wX2JjNWJcIik7ICAgICAgIC8vIGNvbXBhcmUgRkFDMSB3aXRoIChBWSlcclxuLyogYmUxZCAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9iZTIxXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBGQUMxID0gKEFZKSAoYWxsb3cgZGVjaW1hbCBwbGFjZXMpXHJcbi8qIGJlMWYgKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfYmUyZlwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgRkFDMSA+IChBWSkgKG5vIGRlY2ltYWwgcGxhY2VzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZBQzEgPD0gKEFZKVxyXG4vKiBiZTIxICovICAgICAgICBfYF9iZTIxYDsgIEpTUi5hYnMgKFwibXVsMTBfYmFlMlwiKTsgICAgICAgLy8gbXVsdGlwbHkgRkFDMSBieSAxMFxyXG4vKiBiZTI0ICovICAgICAgICAgICAgICAgICAgIERFQy56cGcgKFwidGVtcGYyKzFfMDA1ZFwiKTsgICAgLy8gZGVjcmVtZW50IG51bWJlciBleHBvbmVudCBjb3VudFxyXG4vKiBiZTI2ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2JlMTZcIik7ICAgICAgICAgICAgLy8gZ28gdGVzdCBhZ2FpbiwgYnJhbmNoIGFsd2F5c1xyXG4vKiBiZTI4ICovICAgICAgICBfYF9iZTI4YDsgIEpTUi5hYnMgKFwiZGl2MTBfYmFmZVwiKTsgICAgICAgLy8gZGl2aWRlIEZBQzEgYnkgMTBcclxuLyogYmUyYiAqLyAgICAgICAgICAgICAgICAgICBJTkMuenBnIChcInRlbXBmMisxXzAwNWRcIik7ICAgIC8vIGluY3JlbWVudCBudW1iZXIgZXhwb25lbnQgY291bnRcclxuLyogYmUyZCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9iZTBiXCIpOyAgICAgICAgICAgIC8vIGdvIHRlc3QgYWdhaW4sIGJyYW5jaCBhbHdheXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3cgd2UgaGF2ZSBqdXN0IHRoZSBkaWdpdHMgdG8gZG9cclxuLyogYmUyZiAqLyAgICAgICAgX2BfYmUyZmA7ICBKU1IuYWJzIChcImZhZGRoX2I4NDlcIik7ICAgICAgIC8vIGFkZCAwLjUgdG8gRkFDMSAocm91bmQgRkFDMSlcclxuLyogYmUzMiAqLyAgICAgICAgX2BfYmUzMmA7ICBKU1IuYWJzIChcInFpbnRfYmM5YlwiKTsgICAgICAgIC8vIGNvbnZlcnQgRkFDMSBmbG9hdGluZyB0byBmaXhlZFxyXG4vKiBiZTM1ICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4MDEpOyAgICAgICAgICAgICAgIC8vIHNldCBkZWZhdWx0IGRpZ2l0cyBiZWZvcmUgZHAgPSAxXHJcbi8qIGJlMzcgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ0ZW1wZjIrMV8wMDVkXCIpOyAgICAvLyBnZXQgbnVtYmVyIGV4cG9uZW50IGNvdW50XHJcbi8qIGJlMzkgKi8gICAgICAgICAgICAgICAgICAgQ0xDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgY2FycnkgZm9yIGFkZFxyXG4vKiBiZTNhICovICAgICAgICAgICAgICAgICAgIEFEQy5pbW0gKDB4MGEpOyAgICAgICAgICAgICAgIC8vIHVwIHRvIDkgZGlnaXRzIGJlZm9yZSBwb2ludFxyXG4vKiBiZTNjICovICAgICAgICAgICAgICAgICAgIEJNSS5yZWwgKFwiX2JlNDdcIik7ICAgICAgICAgICAgLy8gaWYgLXZlIHRoZW4gMSBkaWdpdCBiZWZvcmUgZHBcclxuLyogYmUzZSAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW1tICgweDBiKTsgICAgICAgICAgICAgICAvLyBBPj0kMEIgaWYgbj49MUU5XHJcbi8qIGJlNDAgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfYmU0OFwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgPj0gJDBCXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FycnkgaXMgY2xlYXJcclxuLyogYmU0MiAqLyAgICAgICAgICAgICAgICAgICBBREMuaW1tICgweGZmKTsgICAgICAgICAgICAgICAvLyB0YWtlIDEgZnJvbSBkaWdpdCBjb3VudFxyXG4vKiBiZTQ0ICovICAgICAgICAgICAgICAgICAgIFRBWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgdG8gWFxyXG4vKiBiZTQ1ICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MDIpOyAgICAgICAgICAgICAgIC8vIHNldCBleHBvbmVudCBhZGp1c3RcclxuLyogYmU0NyAqLyAgICAgICAgX2BfYmU0N2A7ICBTRUMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzZXQgY2FycnkgZm9yIHN1YnRyYWN0XHJcbi8qIGJlNDggKi8gICAgICAgIF9gX2JlNDhgOyAgU0JDLmltbSAoMHgwMik7ICAgICAgICAgICAgICAgLy8gLTJcclxuLyogYmU0YSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInRlbXBmMisyXzAwNWVcIik7ICAgIC8vIHNhdmUgZXhwb25lbnQgYWRqdXN0XHJcbi8qIGJlNGMgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJ0ZW1wZjIrMV8wMDVkXCIpOyAgICAvLyBzYXZlIGRpZ2l0cyBiZWZvcmUgZHAgY291bnRcclxuLyogYmU0ZSAqLyAgICAgICAgICAgICAgICAgICBUWEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IHRvIEFcclxuLyogYmU0ZiAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9iZTUzXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBubyBkaWdpdHMgYmVmb3JlIGRwXHJcbi8qIGJlNTEgKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfYmU2NlwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgZGlnaXRzIGJlZm9yZSBkcFxyXG4vKiBiZTUzICovICAgICAgICBfYF9iZTUzYDsgIExEWS56cGcgKFwiZmJ1ZnB0KzBfMDA3MVwiKTsgICAgLy8gZ2V0IG91dHB1dCBzdHJpbmcgaW5kZXhcclxuLyogYmU1NSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDJlKTsgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIgXCIuXCJcclxuLyogYmU1NyAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgaW5kZXhcclxuLyogYmU1OCAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJ5IChcImJhc3pwdF8wMGZmXCIpOyAgICAgIC8vIHNhdmUgdG8gb3V0cHV0IHN0cmluZ1xyXG4vKiBiZTViICovICAgICAgICAgICAgICAgICAgIFRYQS5pbXAgKCk7XHJcbi8qIGJlNWMgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYmU2NFwiKTtcclxuLyogYmU1ZSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDMwKTsgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIgXCIwXCJcclxuLyogYmU2MCAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgaW5kZXhcclxuLyogYmU2MSAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJ5IChcImJhc3pwdF8wMGZmXCIpOyAgICAgIC8vIHNhdmUgdG8gb3V0cHV0IHN0cmluZ1xyXG4vKiBiZTY0ICovICAgICAgICBfYF9iZTY0YDsgIFNUWS56cGcgKFwiZmJ1ZnB0KzBfMDA3MVwiKTsgICAgLy8gc2F2ZSBvdXRwdXQgc3RyaW5nIGluZGV4XHJcbi8qIGJlNjYgKi8gICAgICAgIF9gX2JlNjZgOyAgTERZLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgaW5kZXggKHBvaW50IHRvIDEwMCwwMDApXHJcbi8qIGJlNjggKi8gIF9gZm91dGltX2JlNjhgOyAgTERYLmltbSAoMHg4MCk7XHJcbi8qIGJlNmEgKi8gICAgICAgIF9gX2JlNmFgOyAgTERBLnpwZyAoXCJmYWNobyszXzAwNjVcIik7ICAgICAvLyBnZXQgRkFDMSBtYW50aXNzYSA0XHJcbi8qIGJlNmMgKi8gICAgICAgICAgICAgICAgICAgQ0xDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgY2FycnkgZm9yIGFkZFxyXG4vKiBiZTZkICovICAgICAgICAgICAgICAgICAgIEFEQy5hYnkgKDB4YmYxOSk7ICAgICAgICAgICAgIC8vIGFkZCBieXRlIDQsIGxlYXN0IHNpZ25pZmljYW50XHJcbi8qIGJlNzAgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmYWNobyszXzAwNjVcIik7ICAgICAvLyBzYXZlIEZBQzEgbWFudGlzc2E0XHJcbi8qIGJlNzIgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJmYWNobysyXzAwNjRcIik7ICAgICAvLyBnZXQgRkFDMSBtYW50aXNzYSAzXHJcbi8qIGJlNzQgKi8gICAgICAgICAgICAgICAgICAgQURDLmFieSAoMHhiZjE4KTsgICAgICAgICAgICAgLy8gYWRkIGJ5dGUgM1xyXG4vKiBiZTc3ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZmFjaG8rMl8wMDY0XCIpOyAgICAgLy8gc2F2ZSBGQUMxIG1hbnRpc3NhM1xyXG4vKiBiZTc5ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZmFjaG8rMV8wMDYzXCIpOyAgICAgLy8gZ2V0IEZBQzEgbWFudGlzc2EgMlxyXG4vKiBiZTdiICovICAgICAgICAgICAgICAgICAgIEFEQy5hYnkgKDB4YmYxNyk7ICAgICAgICAgICAgIC8vIGFkZCBieXRlIDJcclxuLyogYmU3ZSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZhY2hvKzFfMDA2M1wiKTsgICAgIC8vIHNhdmUgRkFDMSBtYW50aXNzYTJcclxuLyogYmU4MCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZhY2hvKzBfMDA2MlwiKTsgICAgIC8vIGdldCBGQUMxIG1hbnRpc3NhIDFcclxuLyogYmU4MiAqLyAgICAgICAgICAgICAgICAgICBBREMuYWJ5IChcIl9iZjE2XCIpOyAgICAgICAgICAgIC8vIGFkZCBieXRlIDEsIG1vc3Qgc2lnbmlmaWNhbnRcclxuLyogYmU4NSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZhY2hvKzBfMDA2MlwiKTsgICAgIC8vIHNhdmUgRkFDMSBtYW50aXNzYTFcclxuLyogYmU4NyAqLyAgICAgICAgICAgICAgICAgICBJTlguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgdGhlIGRpZ2l0LCBzZXQgdGhlIHNpZ24gb24gdGhlIHRlc3Qgc2Vuc2UgYml0XHJcbi8qIGJlODggKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfYmU4ZVwiKTsgICAgICAgICAgICAvLyBpZiB0aGUgY2FycnkgaXMgc2V0IGdvIHRlc3QgaWYgdGhlIHJlc3VsdCB3YXMgcG9zaXRpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIHRoZSByZXN1bHQgbmVlZHMgdG8gYmUgbmVnYXRpdmVcclxuLyogYmU4YSAqLyAgICAgICAgICAgICAgICAgICBCUEwucmVsIChcIl9iZTZhXCIpOyAgICAgICAgICAgIC8vIG5vdCAtdmUgc28gdHJ5IGFnYWluXHJcbi8qIGJlOGMgKi8gICAgICAgICAgICAgICAgICAgQk1JLnJlbCAoXCJfYmU5MFwiKTsgICAgICAgICAgICAvLyBlbHNlIGRvbmUgc28gcmV0dXJuIHRoZSBkaWdpdFxyXG4vKiBiZThlICovICAgICAgICBfYF9iZThlYDsgIEJNSS5yZWwgKFwiX2JlNmFcIik7ICAgICAgICAgICAgLy8gbm90ICt2ZSBzbyB0cnkgYWdhaW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIGRvbmUgc28gcmV0dXJuIHRoZSBkaWdpdFxyXG4vKiBiZTkwICovICAgICAgICBfYF9iZTkwYDsgIFRYQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgdGhlIGRpZ2l0XHJcbi8qIGJlOTEgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYmU5N1wiKTsgICAgICAgICAgICAvLyBpZiBDYj0wIGp1c3QgdXNlIGl0XHJcbi8qIGJlOTMgKi8gICAgICAgICAgICAgICAgICAgRU9SLmltbSAoMHhmZik7ICAgICAgICAgICAgICAgLy8gZWxzZSBtYWtlIHRoZSAyJ3MgY29tcGxlbWVudCAuLlxyXG4vKiBiZTk1ICovICAgICAgICAgICAgICAgICAgIEFEQy5pbW0gKDB4MGEpOyAgICAgICAgICAgICAgIC8vIC4uIGFuZCBzdWJ0cmFjdCBpdCBmcm9tIDEwXHJcbi8qIGJlOTcgKi8gICAgICAgIF9gX2JlOTdgOyAgQURDLmltbSAoMHgyZik7ICAgICAgICAgICAgICAgLy8gYWRkIFwiMFwiLTEgdG8gcmVzdWx0XHJcbi8qIGJlOTkgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IC4uXHJcbi8qIGJlOWEgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gLi4gaW5kZXggdG8uLlxyXG4vKiBiZTliICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIC4uIG5leHQgbGVzcyAuLlxyXG4vKiBiZTljICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIC4uIHBvd2VyIG9mIHRlblxyXG4vKiBiZTlkICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwidmFycG50KzBfMDA0N1wiKTsgICAgLy8gc2F2ZSBjdXJyZW50IHZhcmlhYmxlIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYmU5ZiAqLyAgICAgICAgICAgICAgICAgICBMRFkuenBnIChcImZidWZwdCswXzAwNzFcIik7ICAgIC8vIGdldCBvdXRwdXQgc3RyaW5nIGluZGV4XHJcbi8qIGJlYTEgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IG91dHB1dCBzdHJpbmcgaW5kZXhcclxuLyogYmVhMiAqLyAgICAgICAgICAgICAgICAgICBUQVguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IGNoYXJhY3RlciB0byBYXHJcbi8qIGJlYTMgKi8gICAgICAgICAgICAgICAgICAgQU5ELmltbSAoMHg3Zik7ICAgICAgICAgICAgICAgLy8gbWFzayBvdXQgdG9wIGJpdFxyXG4vKiBiZWE1ICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnkgKFwiYmFzenB0XzAwZmZcIik7ICAgICAgLy8gc2F2ZSB0byBvdXRwdXQgc3RyaW5nXHJcbi8qIGJlYTggKi8gICAgICAgICAgICAgICAgICAgREVDLnpwZyAoXCJ0ZW1wZjIrMV8wMDVkXCIpOyAgICAvLyBkZWNyZW1lbnQgIyBvZiBjaGFyYWN0ZXJzIGJlZm9yZSB0aGUgZHBcclxuLyogYmVhYSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9iZWIyXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBzdGlsbCBjaGFyYWN0ZXJzIHRvIGRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBvdXRwdXQgdGhlIHBvaW50XHJcbi8qIGJlYWMgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgyZSk7ICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyIFwiLlwiXHJcbi8qIGJlYWUgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IG91dHB1dCBzdHJpbmcgaW5kZXhcclxuLyogYmVhZiAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJ5IChcImJhc3pwdF8wMGZmXCIpOyAgICAgIC8vIHNhdmUgdG8gb3V0cHV0IHN0cmluZ1xyXG4vKiBiZWIyICovICAgICAgICBfYF9iZWIyYDsgIFNUWS56cGcgKFwiZmJ1ZnB0KzBfMDA3MVwiKTsgICAgLy8gc2F2ZSBvdXRwdXQgc3RyaW5nIGluZGV4XHJcbi8qIGJlYjQgKi8gICAgICAgICAgICAgICAgICAgTERZLnpwZyAoXCJ2YXJwbnQrMF8wMDQ3XCIpOyAgICAvLyBnZXQgY3VycmVudCB2YXJpYWJsZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGJlYjYgKi8gICAgICAgICAgICAgICAgICAgVFhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGNoYXJhY3RlciBiYWNrXHJcbi8qIGJlYjcgKi8gICAgICAgICAgICAgICAgICAgRU9SLmltbSAoMHhmZik7ICAgICAgICAgICAgICAgLy8gdG9nZ2xlIHRoZSB0ZXN0IHNlbnNlIGJpdFxyXG4vKiBiZWI5ICovICAgICAgICAgICAgICAgICAgIEFORC5pbW0gKDB4ODApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIHRoZSBkaWdpdFxyXG4vKiBiZWJiICovICAgICAgICAgICAgICAgICAgIFRBWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgaXQgdG8gdGhlIG5ldyBkaWdpdFxyXG4vKiBiZWJjICovICAgICAgICAgICAgICAgICAgIENQWS5pbW0gKDB4MjQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgdGhlIHRhYmxlIGluZGV4IHdpdGggdGhlIG1heCBmb3IgZGVjaW1hbCBudW1iZXJzXHJcbi8qIGJlYmUgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYmVjNFwiKTsgICAgICAgICAgICAvLyBpZiBhdCB0aGUgbWF4IGV4aXQgdGhlIGRpZ2l0IGxvb3BcclxuLyogYmVjMCAqLyAgICAgICAgICAgICAgICAgICBDUFkuaW1tICgweDNjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21wYXJlIHRoZSB0YWJsZSBpbmRleCB3aXRoIHRoZSBtYXggZm9yIHRpbWVcclxuLyogYmVjMiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9iZTZhXCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgbm90IGF0IHRoZSBtYXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3cgcmVtb3ZlIHRyYWlsaW5nIHplcm9lc1xyXG4vKiBiZWM0ICovICAgICAgICBfYF9iZWM0YDsgIExEWS56cGcgKFwiZmJ1ZnB0KzBfMDA3MVwiKTsgICAgLy8gcmVzdG9yZSB0aGUgb3V0cHV0IHN0cmluZyBpbmRleFxyXG4vKiBiZWM2ICovICAgICAgICBfYF9iZWM2YDsgIExEQS5hYnkgKFwiYmFzenB0XzAwZmZcIik7ICAgICAgLy8gZ2V0IGNoYXJhY3RlciBmcm9tIG91dHB1dCBzdHJpbmdcclxuLyogYmVjOSAqLyAgICAgICAgICAgICAgICAgICBERVkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBkZWNyZW1lbnQgb3V0cHV0IHN0cmluZyBpbmRleFxyXG4vKiBiZWNhICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4MzApOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCBcIjBcIlxyXG4vKiBiZWNjICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2JlYzZcIik7ICAgICAgICAgICAgLy8gbG9vcCB1bnRpbCBub24gXCIwXCIgY2hhcmFjdGVyIGZvdW5kXHJcbi8qIGJlY2UgKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHgyZSk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIFwiLlwiXHJcbi8qIGJlZDAgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYmVkM1wiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgd2FzIGRwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBsYXN0IGNoYXJhY3RlclxyXG4vKiBiZWQyICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBvdXRwdXQgc3RyaW5nIGluZGV4XHJcbi8qIGJlZDMgKi8gICAgICAgIF9gX2JlZDNgOyAgTERBLmltbSAoMHgyYik7ICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyIFwiK1wiXHJcbi8qIGJlZDUgKi8gICAgICAgICAgICAgICAgICAgTERYLnpwZyAoXCJ0ZW1wZjIrMl8wMDVlXCIpOyAgICAvLyBnZXQgZXhwb25lbnQgY291bnRcclxuLyogYmVkNyAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9iZjA3XCIpOyAgICAgICAgICAgIC8vIGlmIHplcm8gZ28gc2V0IG51bGwgdGVybWluYXRvciBhbmQgZXhpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4cG9uZW50IGlzbid0IHplcm8gc28gd3JpdGUgZXhwb25lbnRcclxuLyogYmVkOSAqLyAgICAgICAgICAgICAgICAgICBCUEwucmVsIChcIl9iZWUzXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBleHBvbmVudCBjb3VudCArdmVcclxuLyogYmVkYiAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBBXHJcbi8qIGJlZGQgKi8gICAgICAgICAgICAgICAgICAgU0VDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2V0IGNhcnJ5IGZvciBzdWJ0cmFjdFxyXG4vKiBiZWRlICovICAgICAgICAgICAgICAgICAgIFNCQy56cGcgKFwidGVtcGYyKzJfMDA1ZVwiKTsgICAgLy8gc3VidHJhY3QgZXhwb25lbnQgY291bnQgYWRqdXN0IChjb252ZXJ0IC12ZSB0byArdmUpXHJcbi8qIGJlZTAgKi8gICAgICAgICAgICAgICAgICAgVEFYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBleHBvbmVudCBjb3VudCB0byBYXHJcbi8qIGJlZTEgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgyZCk7ICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyIFwiLVwiXHJcbi8qIGJlZTMgKi8gICAgICAgIF9gX2JlZTNgOyAgU1RBLmFieSAoXCJiYWQrMV8wMTAxXCIpOyAgICAgICAvLyBzYXZlIHRvIG91dHB1dCBzdHJpbmdcclxuLyogYmVlNiAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDQ1KTsgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIgXCJFXCJcclxuLyogYmVlOCAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJ5IChcImJhZCswXzAxMDBcIik7ICAgICAgIC8vIHNhdmUgZXhwb25lbnQgc2lnbiB0byBvdXRwdXQgc3RyaW5nXHJcbi8qIGJlZWIgKi8gICAgICAgICAgICAgICAgICAgVFhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGV4cG9uZW50IGNvdW50IGJhY2tcclxuLyogYmVlYyAqLyAgICAgICAgICAgICAgICAgICBMRFguaW1tICgweDJmKTsgICAgICAgICAgICAgICAvLyBvbmUgbGVzcyB0aGFuIFwiMFwiIGNoYXJhY3RlclxyXG4vKiBiZWVlICovICAgICAgICAgICAgICAgICAgIFNFQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNldCBjYXJyeSBmb3Igc3VidHJhY3RcclxuLyogYmVlZiAqLyAgICAgICAgX2BfYmVlZmA7ICBJTlguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgMTAncyBjaGFyYWN0ZXJcclxuLyogYmVmMCAqLyAgICAgICAgICAgICAgICAgICBTQkMuaW1tICgweDBhKTsgICAgICAgICAgICAgICAvLyBzdWJ0cmFjdCAxMCBmcm9tIGV4cG9uZW50IGNvdW50XHJcbi8qIGJlZjIgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfYmVlZlwiKTsgICAgICAgICAgICAvLyBsb29wIHdoaWxlIHN0aWxsID49IDBcclxuLyogYmVmNCAqLyAgICAgICAgICAgICAgICAgICBBREMuaW1tICgweDNhKTsgICAgICAgICAgICAgICAvLyBhZGQgY2hhcmFjdGVyIFwiOlwiICgkMzArJDBBLCByZXN1bHQgaXMgMTAgbGVzcyB0aGF0IHZhbHVlKVxyXG4vKiBiZWY2ICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnkgKFwiYmFkKzNfMDEwM1wiKTsgICAgICAgLy8gc2F2ZSB0byBvdXRwdXQgc3RyaW5nXHJcbi8qIGJlZjkgKi8gICAgICAgICAgICAgICAgICAgVFhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSAxMCdzIGNoYXJhY3RlclxyXG4vKiBiZWZhICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnkgKFwiYmFkKzJfMDEwMlwiKTsgICAgICAgLy8gc2F2ZSB0byBvdXRwdXQgc3RyaW5nXHJcbi8qIGJlZmQgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gc2V0IG51bGwgdGVybWluYXRvclxyXG4vKiBiZWZmICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnkgKFwiYmFkKzRfMDEwNFwiKTsgICAgICAgLy8gc2F2ZSB0byBvdXRwdXQgc3RyaW5nXHJcbi8qIGJmMDIgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfYmYwY1wiKTsgICAgICAgICAgICAvLyBnbyBzZXQgc3RyaW5nIHBvaW50ZXIgKEFZKSBhbmQgZXhpdCwgYnJhbmNoIGFsd2F5c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgbGFzdCBjaGFyYWN0ZXIsIFtFT1RdIGFuZCBleGl0XHJcbi8qIGJmMDQgKi8gICAgICAgIF9gX2JmMDRgOyAgU1RBLmFieSAoXCJiYXN6cHRfMDBmZlwiKTsgICAgICAvLyBzYXZlIGxhc3QgY2hhcmFjdGVyIHRvIG91dHB1dCBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgbnVsbCB0ZXJtaW5hdG9yIGFuZCBleGl0XHJcbi8qIGJmMDcgKi8gICAgICAgIF9gX2JmMDdgOyAgTERBLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gc2V0IG51bGwgdGVybWluYXRvclxyXG4vKiBiZjA5ICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnkgKFwiYmFkKzBfMDEwMFwiKTsgICAgICAgLy8gc2F2ZSBhZnRlciBsYXN0IGNoYXJhY3RlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCBzdHJpbmcgcG9pbnRlciAoQVkpIGFuZCBleGl0XHJcbi8qIGJmMGMgKi8gICAgICAgIF9gX2JmMGNgOyAgTERBLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gc2V0IHJlc3VsdCBzdHJpbmcgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiZjBlICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4MDEpOyAgICAgICAgICAgICAgIC8vIHNldCByZXN1bHQgc3RyaW5nIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGJmMTAgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY29uc3RhbnRzXHJcbi8qIGJmMTEgKi8gICBfYGZoYWxmX2JmMTFgOyAgXy5ieXRlcygweDgwLCAweDAwKTsgICAgICAgICAgLy8gMC41LCBmaXJzdCB0d28gYnl0ZXNcclxuLyogYmYxMyAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MDAsIDB4MDAsIDB4MDApOyAgICAvLyBudWxsIHJldHVybiBmb3IgdW5kZWZpbmVkIHZhcmlhYmxlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0xMDAgMDAwIDAwMFxyXG4vKiBiZjE2ICovICAgICAgICBfYF9iZjE2YDsgIF8uYnl0ZXMoMHhmYSwgMHgwYSwgMHgxZiwgMHgwMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICsxMCAwMDAgMDAwXHJcbi8qIGJmMWEgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDAwLCAweDk4LCAweDk2LCAweDgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIC0xIDAwMCAwMDBcclxuLyogYmYxZSAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4ZmYsIDB4ZjAsIDB4YmQsIDB4YzApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICArMTAwIDAwMFxyXG4vKiBiZjIyICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgwMCwgMHgwMSwgMHg4NiwgMHhhMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAtMTAgMDAwXHJcbi8qIGJmMjYgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweGZmLCAweGZmLCAweGQ4LCAweGYwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICArMSAwMDBcclxuLyogYmYyYSAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MDAsIDB4MDAsIDB4MDMsIDB4ZTgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAtIDEwMFxyXG4vKiBiZjJlICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHhmZiwgMHhmZiwgMHhmZiwgMHg5Yyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgKzEwXHJcbi8qIGJmMzIgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDAwLCAweDAwLCAweDAwLCAweDBhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgLTFcclxuLyogYmYzNiAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBqaWZmeSBjb3VudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtMjE2MDAwMCAgICAxMHMgaG91cnNcclxuLyogYmYzYSAqLyAgX2BmZGNlbmRfYmYzYWA7ICBfLmJ5dGVzKDB4ZmYsIDB4ZGYsIDB4MGEsIDB4ODApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICArMjE2MDAwICAgICAgICBob3Vyc1xyXG4vKiBiZjNlICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgwMCwgMHgwMywgMHg0YiwgMHhjMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAtMzYwMDAgICAgMTBzIG1pbnNcclxuLyogYmY0MiAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4ZmYsIDB4ZmYsIDB4NzMsIDB4NjApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICszNjAwICAgICAgICBtaW5zXHJcbi8qIGJmNDYgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDAwLCAweDAwLCAweDBlLCAweDEwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgLTYwMCAgICAxMHMgc2Vjc1xyXG4vKiBiZjRhICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHhmZiwgMHhmZiwgMHhmZCwgMHhhOCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICArNjAgICAgICAgIHNlY3NcclxuLyogYmY0ZSAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MDAsIDB4MDAsIDB4MDAsIDB4M2MpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBub3QgcmVmZXJlbmNlZFxyXG4vKiBiZjUyICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHhlYyk7ICAgICAgICAgICAgICAgIC8vIGNoZWNrc3VtIGJ5dGVcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gc3BhcmUgYnl0ZXMsIG5vdCByZWZlcmVuY2VkXHJcbi8qIGJmNTMgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweGFhLCAweGFhLCAweGFhLCAweGFhLCAweGFhKTtcclxuLyogYmY1OCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4YWEsIDB4YWEsIDB4YWEsIDB4YWEsIDB4YWEsIDB4YWEsIDB4YWEsIDB4YWEpO1xyXG4vKiBiZjYwICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHhhYSwgMHhhYSwgMHhhYSwgMHhhYSwgMHhhYSwgMHhhYSwgMHhhYSwgMHhhYSk7XHJcbi8qIGJmNjggKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweGFhLCAweGFhLCAweGFhLCAweGFhLCAweGFhLCAweGFhLCAweGFhLCAweGFhKTtcclxuLyogYmY3MCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4YWEpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBwZXJmb3JtIFNRUigpXHJcbi8qIGJmNzEgKi8gICAgIF9gc3FyX2JmNzFgOyAgSlNSLmFicyAoXCJtb3ZhZl9iYzBjXCIpOyAgICAgICAvLyByb3VuZCBhbmQgY29weSBGQUMxIHRvIEZBQzJcclxuLyogYmY3NCAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDExKTsgICAgICAgICAgICAgICAvLyBzZXQgMC41IHBvaW50ZXIgbG93IGFkZHJlc3NcclxuLyogYmY3NiAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweGJmKTsgICAgICAgICAgICAgICAvLyBzZXQgMC41IHBvaW50ZXIgaGlnaCBhZGRyZXNzXHJcbi8qIGJmNzggKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJtb3ZmbV9iYmEyXCIpOyAgICAgICAvLyB1bnBhY2sgbWVtb3J5IChBWSkgaW50byBGQUMxXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHBlcmZvcm0gcG93ZXIgZnVuY3Rpb25cclxuLyogYmY3YiAqLyAgIF9gZnB3cnRfYmY3YmA7ICBCRVEucmVsIChcImV4cF9iZmVkXCIpOyAgICAgICAgIC8vIHBlcmZvcm0gRVhQKClcclxuLyogYmY3ZCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImFyZ2V4cF8wMDY5XCIpOyAgICAgIC8vIGdldCBGQUMyIGV4cG9uZW50XHJcbi8qIGJmN2YgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfYmY4NFwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgRkFDMjw+MFxyXG4vKiBiZjgxICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2I4ZjlcIik7ICAgICAgICAgICAgLy8gY2xlYXIgRkFDMSBleHBvbmVudCBhbmQgc2lnbiBhbmQgcmV0dXJuXHJcbi8qIGJmODQgKi8gICAgICAgIF9gX2JmODRgOyAgTERYLmltbSAoMHg0ZSk7ICAgICAgICAgICAgICAgLy8gc2V0IGRlc3RpbmF0aW9uIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYmY4NiAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBzZXQgZGVzdGluYXRpb24gcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYmY4OCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9iYmQ0XCIpOyAgICAgICAgICAgIC8vIHBhY2sgRkFDMSBpbnRvIChYWSlcclxuLyogYmY4YiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImFyZ3Nnbl8wMDZlXCIpOyAgICAgIC8vIGdldCBGQUMyIHNpZ24gKGI3KVxyXG4vKiBiZjhkICovICAgICAgICAgICAgICAgICAgIEJQTC5yZWwgKFwiX2JmOWVcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIEZBQzI+MFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgRkFDMiBpcyAtdmUgYW5kIGNhbiBvbmx5IGJlIHJhaXNlZCB0byBhblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGludGVnZXIgcG93ZXIgd2hpY2ggZ2l2ZXMgYW4geCArIGowIHJlc3VsdFxyXG4vKiBiZjhmICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiaW50X2JjY2NcIik7ICAgICAgICAgLy8gcGVyZm9ybSBJTlQoKVxyXG4vKiBiZjkyICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4NGUpOyAgICAgICAgICAgICAgIC8vIHNldCBzb3VyY2UgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiZjk0ICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIHNldCBzb3VyY2UgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYmY5NiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImZjb21wX2JjNWJcIik7ICAgICAgIC8vIGNvbXBhcmUgRkFDMSB3aXRoIChBWSlcclxuLyogYmY5OSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9iZjllXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBGQUMxIDw+IChBWSkgdG8gYWxsb3cgRnVuY3Rpb24gQ2FsbCBlcnJvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBsZWF2ZSBGQUMxIC12ZSBhbmQgY2F1c2UgYSBGdW5jdGlvbiBDYWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXJyb3Igd2hlbiBMT0coKSBpcyBjYWxsZWRcclxuLyogYmY5YiAqLyAgICAgICAgICAgICAgICAgICBUWUEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBzaWduIGI3XHJcbi8qIGJmOWMgKi8gICAgICAgICAgICAgICAgICAgTERZLnpwZyAoXCJjaGFyYWNfMDAwN1wiKTsgICAgICAvLyBnZXQgRkFDMSBtYW50aXNzYSA0IGZyb20gSU5UKCkgZnVuY3Rpb24gYXMgc2lnbiBpblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFkgZm9yIHBvc3NpYmxlIGxhdGVyIG5lZ2F0aW9uLCBiMCBvbmx5IG5lZWRlZFxyXG4vKiBiZjllICovICAgICAgICBfYF9iZjllYDsgIEpTUi5hYnMgKFwiX2JiZmVcIik7ICAgICAgICAgICAgLy8gc2F2ZSBGQUMxIHNpZ24gYW5kIGNvcHkgQUJTKEZBQzIpIHRvIEZBQzFcclxuLyogYmZhMSAqLyAgICAgICAgICAgICAgICAgICBUWUEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IHNpZ24gYmFjayAuLlxyXG4vKiBiZmEyICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIC4uIGFuZCBzYXZlIGl0XHJcbi8qIGJmYTMgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJsb2dfYjllYVwiKTsgICAgICAgICAvLyBwZXJmb3JtIExPRygpXHJcbi8qIGJmYTYgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHg0ZSk7ICAgICAgICAgICAgICAgLy8gc2V0IHBvaW50ZXIgbG93IGJ5dGVcclxuLyogYmZhOCAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBzZXQgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogYmZhYSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImZtdWx0X2JhMjhcIik7ICAgICAgIC8vIGRvIGNvbnZlcnQgQVksIEZDQTEqKEFZKVxyXG4vKiBiZmFkICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiZXhwX2JmZWRcIik7ICAgICAgICAgLy8gcGVyZm9ybSBFWFAoKVxyXG4vKiBiZmIwICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHB1bGwgc2lnbiBmcm9tIHN0YWNrXHJcbi8qIGJmYjEgKi8gICAgICAgICAgICAgICAgICAgTFNSLmFjYyAoKTsgICAgICAgICAgICAgICAgICAgLy8gYjAgaXMgdG8gYmUgdGVzdGVkXHJcbi8qIGJmYjIgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYmZiZVwiKTsgICAgICAgICAgICAvLyBpZiBubyBiaXQgdGhlbiBleGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gLSBGQUMxXHJcbi8qIGJmYjQgKi8gICBfYG5lZ29wX2JmYjRgOyAgTERBLnpwZyAoXCJmYWNleHBfMDA2MVwiKTsgICAgICAvLyBnZXQgRkFDMSBleHBvbmVudFxyXG4vKiBiZmI2ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2JmYmVcIik7ICAgICAgICAgICAgLy8gZXhpdCBpZiBGQUMxX2UgPSAkMDBcclxuLyogYmZiOCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZhY3Nnbl8wMDY2XCIpOyAgICAgIC8vIGdldCBGQUMxIHNpZ24gKGI3KVxyXG4vKiBiZmJhICovICAgICAgICAgICAgICAgICAgIEVPUi5pbW0gKDB4ZmYpOyAgICAgICAgICAgICAgIC8vIGNvbXBsZW1lbnQgaXRcclxuLyogYmZiYyAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZhY3Nnbl8wMDY2XCIpOyAgICAgIC8vIHNhdmUgRkFDMSBzaWduIChiNylcclxuLyogYmZiZSAqLyAgICAgICAgX2BfYmZiZWA7ICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBleHAobikgY29uc3RhbnQgYW5kIHNlcmllc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEuNDQyNjk1MDQgPSAxL0xPRygyKVxyXG4vKiBiZmJmICovICBfYGxvZ2ViMl9iZmJmYDsgIF8uYnl0ZXMoMHg4MSwgMHgzOCwgMHhhYSwgMHgzYiwgMHgyOSk7XHJcbi8qIGJmYzQgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDA3KTsgICAgICAgICAgICAgICAgLy8gc2VyaWVzIGNvdW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMi4xNDk4NzYzN0UtNVxyXG4vKiBiZmM1ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg3MSwgMHgzNCwgMHg1OCwgMHgzZSwgMHg1Nik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMS40MzUyMzE0MEUtNFxyXG4vKiBiZmNhICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg3NCwgMHgxNiwgMHg3ZSwgMHhiMywgMHgxYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMS4zNDIyNjM0OEUtM1xyXG4vKiBiZmNmICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg3NywgMHgyZiwgMHhlZSwgMHhlMywgMHg4NSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gOS42MTQwMTcwMUUtM1xyXG4vKiBiZmQ0ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg3YSwgMHgxZCwgMHg4NCwgMHgxYywgMHgyYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gNS41NTA1MTI2OUUtMlxyXG4vKiBiZmQ5ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg3YywgMHg2MywgMHg1OSwgMHg1OCwgMHgwYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMi40MDIyNjM4NUUtMVxyXG4vKiBiZmRlICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg3ZSwgMHg3NSwgMHhmZCwgMHhlNywgMHhjNik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gNi45MzE0NzE4NkUtMVxyXG4vKiBiZmUzICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg4MCwgMHgzMSwgMHg3MiwgMHgxOCwgMHgxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMS4wMDAwMDAwMFxyXG4vKiBiZmU4ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg4MSwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHBlcmZvcm0gRVhQKClcclxuLyogYmZlZCAqLyAgICAgX2BleHBfYmZlZGA7ICBMREEuaW1tICgweGJmKTsgICAgICAgICAgICAgICAvLyBzZXQgMS40NDMgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBiZmVmICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4YmYpOyAgICAgICAgICAgICAgIC8vIHNldCAxLjQ0MyBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBiZmYxICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiZm11bHRfYmEyOFwiKTsgICAgICAgLy8gZG8gY29udmVydCBBWSwgRkNBMSooQVkpXHJcbi8qIGJmZjQgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJmYWNvdl8wMDcwXCIpOyAgICAgICAvLyBnZXQgRkFDMSByb3VuZGluZyBieXRlXHJcbi8qIGJmZjYgKi8gICAgICAgICAgICAgICAgICAgQURDLmltbSAoMHg1MCk7ICAgICAgICAgICAgICAgLy8gKyQ1MC8kMTAwXHJcbi8qIGJmZjggKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfYmZmZFwiKTsgICAgICAgICAgICAvLyBza2lwIHJvdW5kaW5nIGlmIG5vIGNhcnJ5XHJcbi8qIGJmZmEgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfYmMyM1wiKTsgICAgICAgICAgICAvLyByb3VuZCBGQUMxIChubyBjaGVjaylcclxuLyogYmZmZCAqLyAgICAgICAgX2BfYmZmZGA7ICBKTVAuYWJzIChcIihleHBfZTAwMFwiKTsgICAgICAgIC8vIGNvbnRpbnVlIEVYUCgpXHJcblxyXG4gIH1cclxuKTtcclxuIiwiLypcclxuICAgQ2hhcmFjdGVycyAoJGQwMDAg4oCTICRlZmZmLCB3aGVuIG1hcHBlZClcclxuXHJcbiAgIFRoZSBzb3VyY2UgYmVsb3cgYXNzZW1ibGVzIGludG8gYSBieXRlc3RyZWFtIGZ1bGx5IGNvbXBhdGlibGUgd2l0aCB0aGUgQzY0J3NcclxuICAgY2hhcmFjdGVyIFJPTS5cclxuXHJcbiAgIElmIHlvdSB3YW50IHRvIHN1YnN0aXR1dGUgeW91ciBvd24gUk9NLCBqdXN0IGV4cG9ydCBhIGJ5dGUgYXJyYXkgaW5zdGVhZDpcclxuICAgICAgIGV4cG9ydCBkZWZhdWx0IFsgMHguLiwgLi4uIF07XHJcblxyXG4gICBVbmxpa2UgdGhlIHJlc3Qgb2YgdGhlIFZpY2lpb3VzIHByb2plY3QsIHdoaWNoIHdhcyBhdXRob3JlZCBmcm9tIHNjcmF0Y2ggYW5kXHJcbiAgIGVudGVyZWQgaW50byB0aGUgcHVibGljIGRvbWFpbiwgdGhlIHNvdXJjZSBiZWxvdyBpcyBkZXJpdmVkIGZyb20gd29ya3MgYnlcclxuICAgbXVsdGlwbGUgb3RoZXIgYXV0aG9ycyBhbmQgSSBtYWtlIG5vIHJlcHJlc2VudGF0aW9ucyBhcyB0byBpdHMgb3duZXJzaGlwIG9yXHJcbiAgIHRlcm1zIG9mIHVzZS5cclxuKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFtcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQwMCAoMCkgPkA8XHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCBYWFggXCIsXHJcbiAgXCIgWFggWFhYIFwiLFxyXG4gIFwiIFhYICAgICBcIixcclxuICBcIiBYWCAgIFggXCIsXHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQwMSAoMSkgPkE8XHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFhYWFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQwMiAoMikgPkI8XHJcbiAgXCIgWFhYWFggIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFhYWFggIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFhYWFggIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQwMyAoMykgPkM8XHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgICAgXCIsXHJcbiAgXCIgWFggICAgIFwiLFxyXG4gIFwiIFhYICAgICBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQwNCAoNCkgPkQ8XHJcbiAgXCIgWFhYWCAgIFwiLFxyXG4gIFwiIFhYIFhYICBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCBYWCAgXCIsXHJcbiAgXCIgWFhYWCAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQwNSAoNSkgPkU8XHJcbiAgXCIgWFhYWFhYIFwiLFxyXG4gIFwiIFhYICAgICBcIixcclxuICBcIiBYWCAgICAgXCIsXHJcbiAgXCIgWFhYWCAgIFwiLFxyXG4gIFwiIFhYICAgICBcIixcclxuICBcIiBYWCAgICAgXCIsXHJcbiAgXCIgWFhYWFhYIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQwNiAoNikgPkY8XHJcbiAgXCIgWFhYWFhYIFwiLFxyXG4gIFwiIFhYICAgICBcIixcclxuICBcIiBYWCAgICAgXCIsXHJcbiAgXCIgWFhYWCAgIFwiLFxyXG4gIFwiIFhYICAgICBcIixcclxuICBcIiBYWCAgICAgXCIsXHJcbiAgXCIgWFggICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQwNyAoNykgPkc8XHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgICAgXCIsXHJcbiAgXCIgWFggWFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQwOCAoOCkgPkg8XHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFhYWFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQwOSAoOSkgPkk8XHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQwYSAoMTApID5KPFxyXG4gIFwiICAgWFhYWCBcIixcclxuICBcIiAgICBYWCAgXCIsXHJcbiAgXCIgICAgWFggIFwiLFxyXG4gIFwiICAgIFhYICBcIixcclxuICBcIiAgICBYWCAgXCIsXHJcbiAgXCIgWFggWFggIFwiLFxyXG4gIFwiICBYWFggICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkMGIgKDExKSA+SzxcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggWFggIFwiLFxyXG4gIFwiIFhYWFggICBcIixcclxuICBcIiBYWFggICAgXCIsXHJcbiAgXCIgWFhYWCAgIFwiLFxyXG4gIFwiIFhYIFhYICBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDBjICgxMikgPkw8XHJcbiAgXCIgWFggICAgIFwiLFxyXG4gIFwiIFhYICAgICBcIixcclxuICBcIiBYWCAgICAgXCIsXHJcbiAgXCIgWFggICAgIFwiLFxyXG4gIFwiIFhYICAgICBcIixcclxuICBcIiBYWCAgICAgXCIsXHJcbiAgXCIgWFhYWFhYIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQwZCAoMTMpID5NPFxyXG4gIFwiIFhYICAgWFhcIixcclxuICBcIiBYWFggWFhYXCIsXHJcbiAgXCIgWFhYWFhYWFwiLFxyXG4gIFwiIFhYIFggWFhcIixcclxuICBcIiBYWCAgIFhYXCIsXHJcbiAgXCIgWFggICBYWFwiLFxyXG4gIFwiIFhYICAgWFhcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkMGUgKDE0KSA+TjxcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFhYIFhYIFwiLFxyXG4gIFwiIFhYWFhYWCBcIixcclxuICBcIiBYWFhYWFggXCIsXHJcbiAgXCIgWFggWFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDBmICgxNSkgPk88XHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQxMCAoMTYpID5QPFxyXG4gIFwiIFhYWFhYICBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYWFhYICBcIixcclxuICBcIiBYWCAgICAgXCIsXHJcbiAgXCIgWFggICAgIFwiLFxyXG4gIFwiIFhYICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkMTEgKDE3KSA+UTxcclxuICBcIiAgWFhYWCAgXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiAgICBYWFggXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDEyICgxOCkgPlI8XHJcbiAgXCIgWFhYWFggIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFhYWFggIFwiLFxyXG4gIFwiIFhYWFggICBcIixcclxuICBcIiBYWCBYWCAgXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQxMyAoMTkpID5TPFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggICAgIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiAgICAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkMTQgKDIwKSA+VDxcclxuICBcIiBYWFhYWFggXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDE1ICgyMSkgPlU8XHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQxNiAoMjIpID5WPFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkMTcgKDIzKSA+VzxcclxuICBcIiBYWCAgIFhYXCIsXHJcbiAgXCIgWFggICBYWFwiLFxyXG4gIFwiIFhYICAgWFhcIixcclxuICBcIiBYWCBYIFhYXCIsXHJcbiAgXCIgWFhYWFhYWFwiLFxyXG4gIFwiIFhYWCBYWFhcIixcclxuICBcIiBYWCAgIFhYXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDE4ICgyNCkgPlg8XHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiAgWFhYWCAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQxOSAoMjUpID5ZPFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkMWEgKDI2KSA+WjxcclxuICBcIiBYWFhYWFggXCIsXHJcbiAgXCIgICAgIFhYIFwiLFxyXG4gIFwiICAgIFhYICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgIFhYICAgIFwiLFxyXG4gIFwiIFhYICAgICBcIixcclxuICBcIiBYWFhYWFggXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDFiICgyNykgPls8XHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiICBYWCAgICBcIixcclxuICBcIiAgWFggICAgXCIsXHJcbiAgXCIgIFhYICAgIFwiLFxyXG4gIFwiICBYWCAgICBcIixcclxuICBcIiAgWFggICAgXCIsXHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQxYyAoMjgpID7CozxcclxuICBcIiAgICBYWCAgXCIsXHJcbiAgXCIgICBYICBYIFwiLFxyXG4gIFwiICBYWCAgICBcIixcclxuICBcIiBYWFhYWCAgXCIsXHJcbiAgXCIgIFhYICAgIFwiLFxyXG4gIFwiIFhYICAgWCBcIixcclxuICBcIlhYWFhYWCAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDFkICgyOSkgPl08XHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiICAgIFhYICBcIixcclxuICBcIiAgICBYWCAgXCIsXHJcbiAgXCIgICAgWFggIFwiLFxyXG4gIFwiICAgIFhYICBcIixcclxuICBcIiAgICBYWCAgXCIsXHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQxZSAoMzApID7ihpE8XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgWFhYWCAgXCIsXHJcbiAgXCIgWFhYWFhYIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQxZiAoMzEpID7ihpA8XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgWCAgICBcIixcclxuICBcIiAgWFggICAgXCIsXHJcbiAgXCIgWFhYWFhYWFwiLFxyXG4gIFwiIFhYWFhYWFhcIixcclxuICBcIiAgWFggICAgXCIsXHJcbiAgXCIgICBYICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQyMCAoMzIpID4gPFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkMjEgKDMzKSA+ITxcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDIyICgzNCkgPlwiPFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkMjMgKDM1KSA+IzxcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDI0ICgzNikgPiQ8XHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICBYWFhYWCBcIixcclxuICBcIiBYWCAgICAgXCIsXHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiICAgICBYWCBcIixcclxuICBcIiBYWFhYWCAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQyNSAoMzcpID4lPFxyXG4gIFwiIFhYICAgWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgICAgWFggIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgWFggICAgXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFggICBYWCBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkMjYgKDM4KSA+JjxcclxuICBcIiAgWFhYWCAgXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiAgWFhYICAgXCIsXHJcbiAgXCIgWFggIFhYWFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiAgWFhYWFhYXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDI3ICgzOSkgPic8XHJcbiAgXCIgICAgIFhYIFwiLFxyXG4gIFwiICAgIFhYICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQyOCAoNDApID4oPFxyXG4gIFwiICAgIFhYICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgIFhYICAgIFwiLFxyXG4gIFwiICBYWCAgICBcIixcclxuICBcIiAgWFggICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgIFhYICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkMjkgKDQxKSA+KTxcclxuICBcIiAgWFggICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgIFhYICBcIixcclxuICBcIiAgICBYWCAgXCIsXHJcbiAgXCIgICAgWFggIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgWFggICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDJhICg0MikgPio8XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiAgWFhYWCAgXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQyYiAoNDMpID4rPFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiIFhYWFhYWCBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkMmMgKDQ0KSA+LDxcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgIFhYICAgIFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDJkICg0NSkgPi08XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgWFhYWFhYIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQyZSAoNDYpID4uPFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkMmYgKDQ3KSA+LzxcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICBYWFwiLFxyXG4gIFwiICAgICBYWCBcIixcclxuICBcIiAgICBYWCAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICBYWCAgICBcIixcclxuICBcIiBYWCAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDMwICg0OCkgPjA8XHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCBYWFggXCIsXHJcbiAgXCIgWFhYIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQzMSAoNDkpID4xPFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgIFhYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiIFhYWFhYWCBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkMzIgKDUwKSA+MjxcclxuICBcIiAgWFhYWCAgXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiICAgICBYWCBcIixcclxuICBcIiAgICBYWCAgXCIsXHJcbiAgXCIgIFhYICAgIFwiLFxyXG4gIFwiIFhYICAgICBcIixcclxuICBcIiBYWFhYWFggXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDMzICg1MSkgPjM8XHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiAgICAgWFggXCIsXHJcbiAgXCIgICBYWFggIFwiLFxyXG4gIFwiICAgICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQzNCAoNTIpID40PFxyXG4gIFwiICAgICBYWCBcIixcclxuICBcIiAgICBYWFggXCIsXHJcbiAgXCIgICBYWFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWFhYWFhYXCIsXHJcbiAgXCIgICAgIFhYIFwiLFxyXG4gIFwiICAgICBYWCBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkMzUgKDUzKSA+NTxcclxuICBcIiBYWFhYWFggXCIsXHJcbiAgXCIgWFggICAgIFwiLFxyXG4gIFwiIFhYWFhYICBcIixcclxuICBcIiAgICAgWFggXCIsXHJcbiAgXCIgICAgIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiAgWFhYWCAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDM2ICg1NCkgPjY8XHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgICAgXCIsXHJcbiAgXCIgWFhYWFggIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQzNyAoNTUpID43PFxyXG4gIFwiIFhYWFhYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgICAgWFggIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkMzggKDU2KSA+ODxcclxuICBcIiAgWFhYWCAgXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiAgWFhYWCAgXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiAgWFhYWCAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDM5ICg1NykgPjk8XHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgIFhYWFhYIFwiLFxyXG4gIFwiICAgICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQzYSAoNTgpID46PFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkM2IgKDU5KSA+OzxcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgIFhYICAgIFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDNjICg2MCkgPjw8XHJcbiAgXCIgICAgWFhYIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgWFggICAgXCIsXHJcbiAgXCIgWFggICAgIFwiLFxyXG4gIFwiICBYWCAgICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICAgWFhYIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQzZCAoNjEpID49PFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgWFhYWFhYIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiBYWFhYWFggXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkM2UgKDYyKSA+PjxcclxuICBcIiBYWFggICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgIFhYICBcIixcclxuICBcIiAgICAgWFggXCIsXHJcbiAgXCIgICAgWFggIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiBYWFggICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDNmICg2MykgPj88XHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiAgICAgWFggXCIsXHJcbiAgXCIgICAgWFggIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ0MCAoNjQpID7ilIA8XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ0MSAoNjUpID7imaA8XHJcbiAgXCIgICAgWCAgIFwiLFxyXG4gIFwiICAgWFhYICBcIixcclxuICBcIiAgWFhYWFggXCIsXHJcbiAgXCIgWFhYWFhYWFwiLFxyXG4gIFwiIFhYWFhYWFhcIixcclxuICBcIiAgIFhYWCAgXCIsXHJcbiAgXCIgIFhYWFhYIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ0MiAoNjYpID7ilII8XHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ0MyAoNjcpID7ilIA8XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ0NCAoNjgpID7ilIA8XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ0NSAoNjkpID7ilpQ8XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ0NiAoNzApID7ilIA8XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ0NyAoNzEpID7ilII8XHJcbiAgXCIgIFhYICAgIFwiLFxyXG4gIFwiICBYWCAgICBcIixcclxuICBcIiAgWFggICAgXCIsXHJcbiAgXCIgIFhYICAgIFwiLFxyXG4gIFwiICBYWCAgICBcIixcclxuICBcIiAgWFggICAgXCIsXHJcbiAgXCIgIFhYICAgIFwiLFxyXG4gIFwiICBYWCAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ0OCAoNzIpID7ilII8XHJcbiAgXCIgICAgWFggIFwiLFxyXG4gIFwiICAgIFhYICBcIixcclxuICBcIiAgICBYWCAgXCIsXHJcbiAgXCIgICAgWFggIFwiLFxyXG4gIFwiICAgIFhYICBcIixcclxuICBcIiAgICBYWCAgXCIsXHJcbiAgXCIgICAgWFggIFwiLFxyXG4gIFwiICAgIFhYICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ0OSAoNzMpID7ila48XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCJYWFggICAgIFwiLFxyXG4gIFwiWFhYWCAgICBcIixcclxuICBcIiAgWFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ0YSAoNzQpID7ilbA8XHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYWCAgXCIsXHJcbiAgXCIgICAgWFhYWFwiLFxyXG4gIFwiICAgICBYWFhcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ0YiAoNzUpID7ila88XHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgWFhYICAgXCIsXHJcbiAgXCJYWFhYICAgIFwiLFxyXG4gIFwiWFhYICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ0YyAoNzYpID7ijJ48XHJcbiAgXCJYWCAgICAgIFwiLFxyXG4gIFwiWFggICAgICBcIixcclxuICBcIlhYICAgICAgXCIsXHJcbiAgXCJYWCAgICAgIFwiLFxyXG4gIFwiWFggICAgICBcIixcclxuICBcIlhYICAgICAgXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ0ZCAoNzcpID7ilbI8XHJcbiAgXCJYWCAgICAgIFwiLFxyXG4gIFwiWFhYICAgICBcIixcclxuICBcIiBYWFggICAgXCIsXHJcbiAgXCIgIFhYWCAgIFwiLFxyXG4gIFwiICAgWFhYICBcIixcclxuICBcIiAgICBYWFggXCIsXHJcbiAgXCIgICAgIFhYWFwiLFxyXG4gIFwiICAgICAgWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ0ZSAoNzgpID7ilbE8XHJcbiAgXCIgICAgICBYWFwiLFxyXG4gIFwiICAgICBYWFhcIixcclxuICBcIiAgICBYWFggXCIsXHJcbiAgXCIgICBYWFggIFwiLFxyXG4gIFwiICBYWFggICBcIixcclxuICBcIiBYWFggICAgXCIsXHJcbiAgXCJYWFggICAgIFwiLFxyXG4gIFwiWFggICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ0ZiAoNzkpID7ijJw8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYICAgICAgXCIsXHJcbiAgXCJYWCAgICAgIFwiLFxyXG4gIFwiWFggICAgICBcIixcclxuICBcIlhYICAgICAgXCIsXHJcbiAgXCJYWCAgICAgIFwiLFxyXG4gIFwiWFggICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ1MCAoODApID7ijJ08XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIiAgICAgIFhYXCIsXHJcbiAgXCIgICAgICBYWFwiLFxyXG4gIFwiICAgICAgWFhcIixcclxuICBcIiAgICAgIFhYXCIsXHJcbiAgXCIgICAgICBYWFwiLFxyXG4gIFwiICAgICAgWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ1MSAoODEpID7il488XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiBYWFhYWFggXCIsXHJcbiAgXCIgWFhYWFhYIFwiLFxyXG4gIFwiIFhYWFhYWCBcIixcclxuICBcIiBYWFhYWFggXCIsXHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ1MiAoODIpID5fPFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkNTMgKDgzKSA+4pmlPFxyXG4gIFwiICBYWCBYWCBcIixcclxuICBcIiBYWFhYWFhYXCIsXHJcbiAgXCIgWFhYWFhYWFwiLFxyXG4gIFwiIFhYWFhYWFhcIixcclxuICBcIiAgWFhYWFggXCIsXHJcbiAgXCIgICBYWFggIFwiLFxyXG4gIFwiICAgIFggICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkNTQgKDg0KSA+4paOPFxyXG4gIFwiIFhYICAgICBcIixcclxuICBcIiBYWCAgICAgXCIsXHJcbiAgXCIgWFggICAgIFwiLFxyXG4gIFwiIFhYICAgICBcIixcclxuICBcIiBYWCAgICAgXCIsXHJcbiAgXCIgWFggICAgIFwiLFxyXG4gIFwiIFhYICAgICBcIixcclxuICBcIiBYWCAgICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkNTUgKDg1KSA+4pWtPFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICBYWFhcIixcclxuICBcIiAgICBYWFhYXCIsXHJcbiAgXCIgICBYWFggIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkNTYgKDg2KSA+4pWzPFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCIgWFhYWFhYIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiAgWFhYWCAgXCIsXHJcbiAgXCIgWFhYWFhYIFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYICAgIFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkNTcgKDg3KSA+4peLPFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgWFhYWCAgXCIsXHJcbiAgXCIgWFhYWFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFhYWFhYIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkNTggKDg4KSA+4pmjPFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkNTkgKDg5KSA+4paVPFxyXG4gIFwiICAgICBYWCBcIixcclxuICBcIiAgICAgWFggXCIsXHJcbiAgXCIgICAgIFhYIFwiLFxyXG4gIFwiICAgICBYWCBcIixcclxuICBcIiAgICAgWFggXCIsXHJcbiAgXCIgICAgIFhYIFwiLFxyXG4gIFwiICAgICBYWCBcIixcclxuICBcIiAgICAgWFggXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkNWEgKDkwKSA+4pmmPFxyXG4gIFwiICAgIFggICBcIixcclxuICBcIiAgIFhYWCAgXCIsXHJcbiAgXCIgIFhYWFhYIFwiLFxyXG4gIFwiIFhYWFhYWFhcIixcclxuICBcIiAgWFhYWFggXCIsXHJcbiAgXCIgICBYWFggIFwiLFxyXG4gIFwiICAgIFggICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkNWIgKDkxKSA+4pS8PFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkNWMgKDkyKSA+4paSPFxyXG4gIFwiWFggICAgICBcIixcclxuICBcIlhYICAgICAgXCIsXHJcbiAgXCIgIFhYICAgIFwiLFxyXG4gIFwiICBYWCAgICBcIixcclxuICBcIlhYICAgICAgXCIsXHJcbiAgXCJYWCAgICAgIFwiLFxyXG4gIFwiICBYWCAgICBcIixcclxuICBcIiAgWFggICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkNWQgKDkzKSA+4pSCPFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkNWUgKDk0KSA+z4A8XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgIFhYXCIsXHJcbiAgXCIgIFhYWFhYIFwiLFxyXG4gIFwiIFhYWCBYWCBcIixcclxuICBcIiAgWFggWFggXCIsXHJcbiAgXCIgIFhYIFhYIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ1ZiAoOTUpID7il6U8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiIFhYWFhYWFhcIixcclxuICBcIiAgWFhYWFhYXCIsXHJcbiAgXCIgICBYWFhYWFwiLFxyXG4gIFwiICAgIFhYWFhcIixcclxuICBcIiAgICAgWFhYXCIsXHJcbiAgXCIgICAgICBYWFwiLFxyXG4gIFwiICAgICAgIFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ2MCAoOTYpID4gPFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkNjEgKDk3KSA+4paMPFxyXG4gIFwiWFhYWCAgICBcIixcclxuICBcIlhYWFggICAgXCIsXHJcbiAgXCJYWFhYICAgIFwiLFxyXG4gIFwiWFhYWCAgICBcIixcclxuICBcIlhYWFggICAgXCIsXHJcbiAgXCJYWFhYICAgIFwiLFxyXG4gIFwiWFhYWCAgICBcIixcclxuICBcIlhYWFggICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkNjIgKDk4KSA+4paEPFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkNjMgKDk5KSA+4paUPFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkNjQgKDEwMCkgPuKWgTxcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDY1ICgxMDEpID7ilo48XHJcbiAgXCJYWCAgICAgIFwiLFxyXG4gIFwiWFggICAgICBcIixcclxuICBcIlhYICAgICAgXCIsXHJcbiAgXCJYWCAgICAgIFwiLFxyXG4gIFwiWFggICAgICBcIixcclxuICBcIlhYICAgICAgXCIsXHJcbiAgXCJYWCAgICAgIFwiLFxyXG4gIFwiWFggICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ2NiAoMTAyKSA+4paSPFxyXG4gIFwiWFggIFhYICBcIixcclxuICBcIlhYICBYWCAgXCIsXHJcbiAgXCIgIFhYICBYWFwiLFxyXG4gIFwiICBYWCAgWFhcIixcclxuICBcIlhYICBYWCAgXCIsXHJcbiAgXCJYWCAgWFggIFwiLFxyXG4gIFwiICBYWCAgWFhcIixcclxuICBcIiAgWFggIFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkNjcgKDEwMykgPuKWlTxcclxuICBcIiAgICAgIFhYXCIsXHJcbiAgXCIgICAgICBYWFwiLFxyXG4gIFwiICAgICAgWFhcIixcclxuICBcIiAgICAgIFhYXCIsXHJcbiAgXCIgICAgICBYWFwiLFxyXG4gIFwiICAgICAgWFhcIixcclxuICBcIiAgICAgIFhYXCIsXHJcbiAgXCIgICAgICBYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDY4ICgxMDQpID7ilpI8XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiWFggIFhYICBcIixcclxuICBcIlhYICBYWCAgXCIsXHJcbiAgXCIgIFhYICBYWFwiLFxyXG4gIFwiICBYWCAgWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ2OSAoMTA1KSA+4pekPFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFggXCIsXHJcbiAgXCJYWFhYWFggIFwiLFxyXG4gIFwiWFhYWFggICBcIixcclxuICBcIlhYWFggICAgXCIsXHJcbiAgXCJYWFggICAgIFwiLFxyXG4gIFwiWFggICAgICBcIixcclxuICBcIlggICAgICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkNmEgKDEwNikgPuKWlTxcclxuICBcIiAgICAgIFhYXCIsXHJcbiAgXCIgICAgICBYWFwiLFxyXG4gIFwiICAgICAgWFhcIixcclxuICBcIiAgICAgIFhYXCIsXHJcbiAgXCIgICAgICBYWFwiLFxyXG4gIFwiICAgICAgWFhcIixcclxuICBcIiAgICAgIFhYXCIsXHJcbiAgXCIgICAgICBYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDZiICgxMDcpID7ilJw8XHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWFhYWFwiLFxyXG4gIFwiICAgWFhYWFhcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ2YyAoMTA4KSA+4paXPFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICBYWFhYXCIsXHJcbiAgXCIgICAgWFhYWFwiLFxyXG4gIFwiICAgIFhYWFhcIixcclxuICBcIiAgICBYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkNmQgKDEwOSkgPuKUlDxcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYWFhYXCIsXHJcbiAgXCIgICBYWFhYWFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDZlICgxMTApID7ilJA8XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCJYWFhYWCAgIFwiLFxyXG4gIFwiWFhYWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ2ZiAoMTExKSA+4paCPFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkNzAgKDExMikgPuKUjDxcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgIFhYWFhYXCIsXHJcbiAgXCIgICBYWFhYWFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDcxICgxMTMpID7ilLQ8XHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ3MiAoMTE0KSA+4pSsPFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkNzMgKDExNSkgPuKUpDxcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIlhYWFhYICAgXCIsXHJcbiAgXCJYWFhYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDc0ICgxMTYpID7ilo48XHJcbiAgXCJYWCAgICAgIFwiLFxyXG4gIFwiWFggICAgICBcIixcclxuICBcIlhYICAgICAgXCIsXHJcbiAgXCJYWCAgICAgIFwiLFxyXG4gIFwiWFggICAgICBcIixcclxuICBcIlhYICAgICAgXCIsXHJcbiAgXCJYWCAgICAgIFwiLFxyXG4gIFwiWFggICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ3NSAoMTE3KSA+4paNPFxyXG4gIFwiWFhYICAgICBcIixcclxuICBcIlhYWCAgICAgXCIsXHJcbiAgXCJYWFggICAgIFwiLFxyXG4gIFwiWFhYICAgICBcIixcclxuICBcIlhYWCAgICAgXCIsXHJcbiAgXCJYWFggICAgIFwiLFxyXG4gIFwiWFhYICAgICBcIixcclxuICBcIlhYWCAgICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkNzYgKDExOCkgPuKWlTxcclxuICBcIiAgICAgWFhYXCIsXHJcbiAgXCIgICAgIFhYWFwiLFxyXG4gIFwiICAgICBYWFhcIixcclxuICBcIiAgICAgWFhYXCIsXHJcbiAgXCIgICAgIFhYWFwiLFxyXG4gIFwiICAgICBYWFhcIixcclxuICBcIiAgICAgWFhYXCIsXHJcbiAgXCIgICAgIFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDc3ICgxMTkpID7ilpQ8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ3OCAoMTIwKSA+4paUPFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkNzkgKDEyMSkgPuKWgzxcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDdhICgxMjIpID7ijJ88XHJcbiAgXCIgICAgICBYWFwiLFxyXG4gIFwiICAgICAgWFhcIixcclxuICBcIiAgICAgIFhYXCIsXHJcbiAgXCIgICAgICBYWFwiLFxyXG4gIFwiICAgICAgWFhcIixcclxuICBcIiAgICAgIFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ3YiAoMTIzKSA+4paWPFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIlhYWFggICAgXCIsXHJcbiAgXCJYWFhYICAgIFwiLFxyXG4gIFwiWFhYWCAgICBcIixcclxuICBcIlhYWFggICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkN2MgKDEyNCkgPuKWnTxcclxuICBcIiAgICBYWFhYXCIsXHJcbiAgXCIgICAgWFhYWFwiLFxyXG4gIFwiICAgIFhYWFhcIixcclxuICBcIiAgICBYWFhYXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDdkICgxMjUpID7ilJg8XHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCJYWFhYWCAgIFwiLFxyXG4gIFwiWFhYWFggICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ3ZSAoMTI2KSA+4paYPFxyXG4gIFwiWFhYWCAgICBcIixcclxuICBcIlhYWFggICAgXCIsXHJcbiAgXCJYWFhYICAgIFwiLFxyXG4gIFwiWFhYWCAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkN2YgKDEyNykgPuKWmjxcclxuICBcIlhYWFggICAgXCIsXHJcbiAgXCJYWFhYICAgIFwiLFxyXG4gIFwiWFhYWCAgICBcIixcclxuICBcIlhYWFggICAgXCIsXHJcbiAgXCIgICAgWFhYWFwiLFxyXG4gIFwiICAgIFhYWFhcIixcclxuICBcIiAgICBYWFhYXCIsXHJcbiAgXCIgICAgWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDgwICgxMjgpID5APFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYICAgWFwiLFxyXG4gIFwiWCAgWCAgIFhcIixcclxuICBcIlggIFhYWFhYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkODEgKDEyOSkgPkE8XHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICAgICAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ4MiAoMTMwKSA+QjxcclxuICBcIlggICAgIFhYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggICAgIFhYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggICAgIFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDgzICgxMzEpID5DPFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWFhYWFwiLFxyXG4gIFwiWCAgWFhYWFhcIixcclxuICBcIlggIFhYWFhYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkODQgKDEzMikgPkQ8XHJcbiAgXCJYICAgIFhYWFwiLFxyXG4gIFwiWCAgWCAgWFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFggIFhYXCIsXHJcbiAgXCJYICAgIFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ4NSAoMTMzKSA+RTxcclxuICBcIlggICAgICBYXCIsXHJcbiAgXCJYICBYWFhYWFwiLFxyXG4gIFwiWCAgWFhYWFhcIixcclxuICBcIlggICAgWFhYXCIsXHJcbiAgXCJYICBYWFhYWFwiLFxyXG4gIFwiWCAgWFhYWFhcIixcclxuICBcIlggICAgICBYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDg2ICgxMzQpID5GPFxyXG4gIFwiWCAgICAgIFhcIixcclxuICBcIlggIFhYWFhYXCIsXHJcbiAgXCJYICBYWFhYWFwiLFxyXG4gIFwiWCAgICBYWFhcIixcclxuICBcIlggIFhYWFhYXCIsXHJcbiAgXCJYICBYWFhYWFwiLFxyXG4gIFwiWCAgWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkODcgKDEzNSkgPkc8XHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYWFhYXCIsXHJcbiAgXCJYICBYICAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ4OCAoMTM2KSA+SDxcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggICAgICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDg5ICgxMzcpID5JPFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkOGEgKDEzOCkgPko8XHJcbiAgXCJYWFggICAgWFwiLFxyXG4gIFwiWFhYWCAgWFhcIixcclxuICBcIlhYWFggIFhYXCIsXHJcbiAgXCJYWFhYICBYWFwiLFxyXG4gIFwiWFhYWCAgWFhcIixcclxuICBcIlggIFggIFhYXCIsXHJcbiAgXCJYWCAgIFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ4YiAoMTM5KSA+SzxcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYICBYWFwiLFxyXG4gIFwiWCAgICBYWFhcIixcclxuICBcIlggICBYWFhYXCIsXHJcbiAgXCJYICAgIFhYWFwiLFxyXG4gIFwiWCAgWCAgWFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDhjICgxNDApID5MPFxyXG4gIFwiWCAgWFhYWFhcIixcclxuICBcIlggIFhYWFhYXCIsXHJcbiAgXCJYICBYWFhYWFwiLFxyXG4gIFwiWCAgWFhYWFhcIixcclxuICBcIlggIFhYWFhYXCIsXHJcbiAgXCJYICBYWFhYWFwiLFxyXG4gIFwiWCAgICAgIFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkOGQgKDE0MSkgPk08XHJcbiAgXCJYICBYWFggIFwiLFxyXG4gIFwiWCAgIFggICBcIixcclxuICBcIlggICAgICAgXCIsXHJcbiAgXCJYICBYIFggIFwiLFxyXG4gIFwiWCAgWFhYICBcIixcclxuICBcIlggIFhYWCAgXCIsXHJcbiAgXCJYICBYWFggIFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ4ZSAoMTQyKSA+TjxcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICAgWCAgWFwiLFxyXG4gIFwiWCAgICAgIFhcIixcclxuICBcIlggICAgICBYXCIsXHJcbiAgXCJYICBYICAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDhmICgxNDMpID5PPFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkOTAgKDE0NCkgPlA8XHJcbiAgXCJYICAgICBYWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICAgICBYWFwiLFxyXG4gIFwiWCAgWFhYWFhcIixcclxuICBcIlggIFhYWFhYXCIsXHJcbiAgXCJYICBYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ5MSAoMTQ1KSA+UTxcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlhYWFggICBYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDkyICgxNDYpID5SPFxyXG4gIFwiWCAgICAgWFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgICAgWFhcIixcclxuICBcIlggICAgWFhYXCIsXHJcbiAgXCJYICBYICBYWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkOTMgKDE0NykgPlM8XHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYWFhYXCIsXHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWFhYWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ5NCAoMTQ4KSA+VDxcclxuICBcIlggICAgICBYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDk1ICgxNDkpID5VPFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkOTYgKDE1MCkgPlY8XHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ5NyAoMTUxKSA+VzxcclxuICBcIlggIFhYWCAgXCIsXHJcbiAgXCJYICBYWFggIFwiLFxyXG4gIFwiWCAgWFhYICBcIixcclxuICBcIlggIFggWCAgXCIsXHJcbiAgXCJYICAgICAgIFwiLFxyXG4gIFwiWCAgIFggICBcIixcclxuICBcIlggIFhYWCAgXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDk4ICgxNTIpID5YPFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkOTkgKDE1MykgPlk8XHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ5YSAoMTU0KSA+WjxcclxuICBcIlggICAgICBYXCIsXHJcbiAgXCJYWFhYWCAgWFwiLFxyXG4gIFwiWFhYWCAgWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWCAgWFhYWFwiLFxyXG4gIFwiWCAgWFhYWFhcIixcclxuICBcIlggICAgICBYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJDliICgxNTUpID5bPFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlhYICBYWFhYXCIsXHJcbiAgXCJYWCAgWFhYWFwiLFxyXG4gIFwiWFggIFhYWFhcIixcclxuICBcIlhYICBYWFhYXCIsXHJcbiAgXCJYWCAgWFhYWFwiLFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkOWMgKDE1NikgPsKjPFxyXG4gIFwiWFhYWCAgWFhcIixcclxuICBcIlhYWCBYWCBYXCIsXHJcbiAgXCJYWCAgWFhYWFwiLFxyXG4gIFwiWCAgICAgWFhcIixcclxuICBcIlhYICBYWFhYXCIsXHJcbiAgXCJYICBYWFggWFwiLFxyXG4gIFwiICAgICAgWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkOWQgKDE1NykgPl08XHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWFhYWCAgWFhcIixcclxuICBcIlhYWFggIFhYXCIsXHJcbiAgXCJYWFhYICBYWFwiLFxyXG4gIFwiWFhYWCAgWFhcIixcclxuICBcIlhYWFggIFhYXCIsXHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICQ5ZSAoMTU4KSA+4oaRPFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWCAgICAgIFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkOWYgKDE1OSkgPuKGkDxcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFggWFhYWFwiLFxyXG4gIFwiWFggIFhYWFhcIixcclxuICBcIlggICAgICAgXCIsXHJcbiAgXCJYICAgICAgIFwiLFxyXG4gIFwiWFggIFhYWFhcIixcclxuICBcIlhYWCBYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGEwICgxNjApID4gPFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkYTEgKDE2MSkgPiE8XHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRhMiAoMTYyKSA+XCI8XHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRhMyAoMTYzKSA+IzxcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGE0ICgxNjQpID4kPFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYICAgICBYXCIsXHJcbiAgXCJYICBYWFhYWFwiLFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlhYWFhYICBYXCIsXHJcbiAgXCJYICAgICBYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkYTUgKDE2NSkgPiU8XHJcbiAgXCJYICBYWFggWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlhYWFggIFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFggIFhYWFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYIFhYWCAgWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRhNiAoMTY2KSA+JjxcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlhYICAgWFhYXCIsXHJcbiAgXCJYICBYWCAgIFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlhYICAgICAgXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGE3ICgxNjcpID4nPFxyXG4gIFwiWFhYWFggIFhcIixcclxuICBcIlhYWFggIFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkYTggKDE2OCkgPig8XHJcbiAgXCJYWFhYICBYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYICBYWFhYXCIsXHJcbiAgXCJYWCAgWFhYWFwiLFxyXG4gIFwiWFggIFhYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFhYICBYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRhOSAoMTY5KSA+KTxcclxuICBcIlhYICBYWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYWCAgWFhcIixcclxuICBcIlhYWFggIFhYXCIsXHJcbiAgXCJYWFhYICBYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYICBYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGFhICgxNzApID4qPFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkYWIgKDE3MSkgPis8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYICAgICAgWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRhYyAoMTcyKSA+LDxcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWCAgWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGFkICgxNzMpID4tPFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWCAgICAgIFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkYWUgKDE3NCkgPi48XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRhZiAoMTc1KSA+LzxcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFggIFwiLFxyXG4gIFwiWFhYWFggIFhcIixcclxuICBcIlhYWFggIFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFggIFhYWFhcIixcclxuICBcIlggIFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGIwICgxNzYpID4wPFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYICAgWFwiLFxyXG4gIFwiWCAgIFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkYjEgKDE3NykgPjE8XHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYICAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYICAgICAgWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRiMiAoMTc4KSA+MjxcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWFhYWFggIFhcIixcclxuICBcIlhYWFggIFhYXCIsXHJcbiAgXCJYWCAgWFhYWFwiLFxyXG4gIFwiWCAgWFhYWFhcIixcclxuICBcIlggICAgICBYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGIzICgxNzkpID4zPFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWFhYWCAgWFwiLFxyXG4gIFwiWFhYICAgWFhcIixcclxuICBcIlhYWFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkYjQgKDE4MCkgPjQ8XHJcbiAgXCJYWFhYWCAgWFwiLFxyXG4gIFwiWFhYWCAgIFhcIixcclxuICBcIlhYWCAgICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgICAgICBcIixcclxuICBcIlhYWFhYICBYXCIsXHJcbiAgXCJYWFhYWCAgWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRiNSAoMTgxKSA+NTxcclxuICBcIlggICAgICBYXCIsXHJcbiAgXCJYICBYWFhYWFwiLFxyXG4gIFwiWCAgICAgWFhcIixcclxuICBcIlhYWFhYICBYXCIsXHJcbiAgXCJYWFhYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGI2ICgxODIpID42PFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWFhYWFwiLFxyXG4gIFwiWCAgICAgWFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkYjcgKDE4MykgPjc8XHJcbiAgXCJYICAgICAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlhYWFggIFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRiOCAoMTg0KSA+ODxcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGI5ICgxODUpID45PFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWFggICAgIFhcIixcclxuICBcIlhYWFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkYmEgKDE4NikgPjo8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRiYiAoMTg3KSA+OzxcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWCAgWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGJjICgxODgpID48PFxyXG4gIFwiWFhYWCAgIFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWCAgWFhYWFwiLFxyXG4gIFwiWCAgWFhYWFhcIixcclxuICBcIlhYICBYWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYWCAgIFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkYmQgKDE4OSkgPj08XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlggICAgICBYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWCAgICAgIFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRiZSAoMTkwKSA+PjxcclxuICBcIlggICBYWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYWCAgWFhcIixcclxuICBcIlhYWFhYICBYXCIsXHJcbiAgXCJYWFhYICBYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlggICBYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGJmICgxOTEpID4/PFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWFhYWCAgWFwiLFxyXG4gIFwiWFhYWCAgWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkYzAgKDE5MikgPuKUgDxcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGMxICgxOTMpID7imaA8XHJcbiAgXCJYWFhYIFhYWFwiLFxyXG4gIFwiWFhYICAgWFhcIixcclxuICBcIlhYICAgICBYXCIsXHJcbiAgXCJYICAgICAgIFwiLFxyXG4gIFwiWCAgICAgICBcIixcclxuICBcIlhYWCAgIFhYXCIsXHJcbiAgXCJYWCAgICAgWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRjMiAoMTk0KSA+4pSCPFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkYzMgKDE5NSkgPuKUgDxcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGM0ICgxOTYpID7ilIA8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRjNSAoMTk3KSA+4paUPFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkYzYgKDE5OCkgPuKUgDxcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGM3ICgxOTkpID7ilII8XHJcbiAgXCJYWCAgWFhYWFwiLFxyXG4gIFwiWFggIFhYWFhcIixcclxuICBcIlhYICBYWFhYXCIsXHJcbiAgXCJYWCAgWFhYWFwiLFxyXG4gIFwiWFggIFhYWFhcIixcclxuICBcIlhYICBYWFhYXCIsXHJcbiAgXCJYWCAgWFhYWFwiLFxyXG4gIFwiWFggIFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRjOCAoMjAwKSA+4pSCPFxyXG4gIFwiWFhYWCAgWFhcIixcclxuICBcIlhYWFggIFhYXCIsXHJcbiAgXCJYWFhYICBYWFwiLFxyXG4gIFwiWFhYWCAgWFhcIixcclxuICBcIlhYWFggIFhYXCIsXHJcbiAgXCJYWFhYICBYWFwiLFxyXG4gIFwiWFhYWCAgWFhcIixcclxuICBcIlhYWFggIFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkYzkgKDIwMSkgPuKVrjxcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIiAgIFhYWFhYXCIsXHJcbiAgXCIgICAgWFhYWFwiLFxyXG4gIFwiWFggICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGNhICgyMDIpID7ilbA8XHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgIFhYXCIsXHJcbiAgXCJYWFhYICAgIFwiLFxyXG4gIFwiWFhYWFggICBcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRjYiAoMjAzKSA+4pWvPFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWCAgIFhYWFwiLFxyXG4gIFwiICAgIFhYWFhcIixcclxuICBcIiAgIFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkY2MgKDIwNCkgPuKMnjxcclxuICBcIiAgWFhYWFhYXCIsXHJcbiAgXCIgIFhYWFhYWFwiLFxyXG4gIFwiICBYWFhYWFhcIixcclxuICBcIiAgWFhYWFhYXCIsXHJcbiAgXCIgIFhYWFhYWFwiLFxyXG4gIFwiICBYWFhYWFhcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGNkICgyMDUpID7ilbI8XHJcbiAgXCIgIFhYWFhYWFwiLFxyXG4gIFwiICAgWFhYWFhcIixcclxuICBcIlggICBYWFhYXCIsXHJcbiAgXCJYWCAgIFhYWFwiLFxyXG4gIFwiWFhYICAgWFhcIixcclxuICBcIlhYWFggICBYXCIsXHJcbiAgXCJYWFhYWCAgIFwiLFxyXG4gIFwiWFhYWFhYICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRjZSAoMjA2KSA+4pWxPFxyXG4gIFwiWFhYWFhYICBcIixcclxuICBcIlhYWFhYICAgXCIsXHJcbiAgXCJYWFhYICAgWFwiLFxyXG4gIFwiWFhYICAgWFhcIixcclxuICBcIlhYICAgWFhYXCIsXHJcbiAgXCJYICAgWFhYWFwiLFxyXG4gIFwiICAgWFhYWFhcIixcclxuICBcIiAgWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkY2YgKDIwNykgPuKMnDxcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICBYWFhYWFhcIixcclxuICBcIiAgWFhYWFhYXCIsXHJcbiAgXCIgIFhYWFhYWFwiLFxyXG4gIFwiICBYWFhYWFhcIixcclxuICBcIiAgWFhYWFhYXCIsXHJcbiAgXCIgIFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGQwICgyMDgpID7ijJ08XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIlhYWFhYWCAgXCIsXHJcbiAgXCJYWFhYWFggIFwiLFxyXG4gIFwiWFhYWFhYICBcIixcclxuICBcIlhYWFhYWCAgXCIsXHJcbiAgXCJYWFhYWFggIFwiLFxyXG4gIFwiWFhYWFhYICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRkMSAoMjA5KSA+4pePPFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYICAgICAgWFwiLFxyXG4gIFwiWCAgICAgIFhcIixcclxuICBcIlggICAgICBYXCIsXHJcbiAgXCJYICAgICAgWFwiLFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkZDIgKDIxMCkgPl88XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRkMyAoMjExKSA+4pmlPFxyXG4gIFwiWFggIFggIFhcIixcclxuICBcIlggICAgICAgXCIsXHJcbiAgXCJYICAgICAgIFwiLFxyXG4gIFwiWCAgICAgICBcIixcclxuICBcIlhYICAgICBYXCIsXHJcbiAgXCJYWFggICBYWFwiLFxyXG4gIFwiWFhYWCBYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkZDQgKDIxMikgPuKWjjxcclxuICBcIlggIFhYWFhYXCIsXHJcbiAgXCJYICBYWFhYWFwiLFxyXG4gIFwiWCAgWFhYWFhcIixcclxuICBcIlggIFhYWFhYXCIsXHJcbiAgXCJYICBYWFhYWFwiLFxyXG4gIFwiWCAgWFhYWFhcIixcclxuICBcIlggIFhYWFhYXCIsXHJcbiAgXCJYICBYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGQ1ICgyMTMpID7ila08XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWCAgIFwiLFxyXG4gIFwiWFhYWCAgICBcIixcclxuICBcIlhYWCAgIFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRkNiAoMjE0KSA+4pWzPFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCJYICAgICAgWFwiLFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYICAgICAgWFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgWFhYWCAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkZDcgKDIxNSkgPuKXizxcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWCAgICAgIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgICAgIFhcIixcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGQ4ICgyMTYpID7imaM8XHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRkOSAoMjE3KSA+4paVPFxyXG4gIFwiWFhYWFggIFhcIixcclxuICBcIlhYWFhYICBYXCIsXHJcbiAgXCJYWFhYWCAgWFwiLFxyXG4gIFwiWFhYWFggIFhcIixcclxuICBcIlhYWFhYICBYXCIsXHJcbiAgXCJYWFhYWCAgWFwiLFxyXG4gIFwiWFhYWFggIFhcIixcclxuICBcIlhYWFhYICBYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkZGEgKDIxOCkgPuKZpjxcclxuICBcIlhYWFggWFhYXCIsXHJcbiAgXCJYWFggICBYWFwiLFxyXG4gIFwiWFggICAgIFhcIixcclxuICBcIlggICAgICAgXCIsXHJcbiAgXCJYWCAgICAgWFwiLFxyXG4gIFwiWFhYICAgWFhcIixcclxuICBcIlhYWFggWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGRiICgyMTkpID7ilLw8XHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRkYyAoMjIwKSA+4paSPFxyXG4gIFwiICBYWFhYWFhcIixcclxuICBcIiAgWFhYWFhYXCIsXHJcbiAgXCJYWCAgWFhYWFwiLFxyXG4gIFwiWFggIFhYWFhcIixcclxuICBcIiAgWFhYWFhYXCIsXHJcbiAgXCIgIFhYWFhYWFwiLFxyXG4gIFwiWFggIFhYWFhcIixcclxuICBcIlhYICBYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkZGQgKDIyMSkgPuKUgjxcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGRlICgyMjIpID7PgDxcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYICBcIixcclxuICBcIlhYICAgICBYXCIsXHJcbiAgXCJYICAgWCAgWFwiLFxyXG4gIFwiWFggIFggIFhcIixcclxuICBcIlhYICBYICBYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGRmICgyMjMpID7il6U8XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiWCAgICAgICBcIixcclxuICBcIlhYICAgICAgXCIsXHJcbiAgXCJYWFggICAgIFwiLFxyXG4gIFwiWFhYWCAgICBcIixcclxuICBcIlhYWFhYICAgXCIsXHJcbiAgXCJYWFhYWFggIFwiLFxyXG4gIFwiWFhYWFhYWCBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRlMCAoMjI0KSA+IDxcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGUxICgyMjUpID7ilow8XHJcbiAgXCIgICAgWFhYWFwiLFxyXG4gIFwiICAgIFhYWFhcIixcclxuICBcIiAgICBYWFhYXCIsXHJcbiAgXCIgICAgWFhYWFwiLFxyXG4gIFwiICAgIFhYWFhcIixcclxuICBcIiAgICBYWFhYXCIsXHJcbiAgXCIgICAgWFhYWFwiLFxyXG4gIFwiICAgIFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRlMiAoMjI2KSA+4paEPFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkZTMgKDIyNykgPuKWlDxcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGU0ICgyMjgpID7iloE8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRlNSAoMjI5KSA+4paOPFxyXG4gIFwiICBYWFhYWFhcIixcclxuICBcIiAgWFhYWFhYXCIsXHJcbiAgXCIgIFhYWFhYWFwiLFxyXG4gIFwiICBYWFhYWFhcIixcclxuICBcIiAgWFhYWFhYXCIsXHJcbiAgXCIgIFhYWFhYWFwiLFxyXG4gIFwiICBYWFhYWFhcIixcclxuICBcIiAgWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkZTYgKDIzMCkgPuKWkjxcclxuICBcIiAgWFggIFhYXCIsXHJcbiAgXCIgIFhYICBYWFwiLFxyXG4gIFwiWFggIFhYICBcIixcclxuICBcIlhYICBYWCAgXCIsXHJcbiAgXCIgIFhYICBYWFwiLFxyXG4gIFwiICBYWCAgWFhcIixcclxuICBcIlhYICBYWCAgXCIsXHJcbiAgXCJYWCAgWFggIFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGU3ICgyMzEpID7ilpU8XHJcbiAgXCJYWFhYWFggIFwiLFxyXG4gIFwiWFhYWFhYICBcIixcclxuICBcIlhYWFhYWCAgXCIsXHJcbiAgXCJYWFhYWFggIFwiLFxyXG4gIFwiWFhYWFhYICBcIixcclxuICBcIlhYWFhYWCAgXCIsXHJcbiAgXCJYWFhYWFggIFwiLFxyXG4gIFwiWFhYWFhYICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRlOCAoMjMyKSA+4paSPFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIiAgWFggIFhYXCIsXHJcbiAgXCIgIFhYICBYWFwiLFxyXG4gIFwiWFggIFhYICBcIixcclxuICBcIlhYICBYWCAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkZTkgKDIzMykgPuKXpDxcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgWFwiLFxyXG4gIFwiICAgICAgWFhcIixcclxuICBcIiAgICAgWFhYXCIsXHJcbiAgXCIgICAgWFhYWFwiLFxyXG4gIFwiICAgWFhYWFhcIixcclxuICBcIiAgWFhYWFhYXCIsXHJcbiAgXCIgWFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGVhICgyMzQpID7ilpU8XHJcbiAgXCJYWFhYWFggIFwiLFxyXG4gIFwiWFhYWFhYICBcIixcclxuICBcIlhYWFhYWCAgXCIsXHJcbiAgXCJYWFhYWFggIFwiLFxyXG4gIFwiWFhYWFhYICBcIixcclxuICBcIlhYWFhYWCAgXCIsXHJcbiAgXCJYWFhYWFggIFwiLFxyXG4gIFwiWFhYWFhYICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRlYiAoMjM1KSA+4pScPFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICAgICBcIixcclxuICBcIlhYWCAgICAgXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkZWMgKDIzNikgPuKWlzxcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYICAgIFwiLFxyXG4gIFwiWFhYWCAgICBcIixcclxuICBcIlhYWFggICAgXCIsXHJcbiAgXCJYWFhYICAgIFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGVkICgyMzcpID7ilJQ8XHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggICAgIFwiLFxyXG4gIFwiWFhYICAgICBcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRlZSAoMjM4KSA+4pSQPFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiICAgICBYWFhcIixcclxuICBcIiAgICAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkZWYgKDIzOSkgPuKWgjxcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGYwICgyNDApID7ilIw8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFggICAgIFwiLFxyXG4gIFwiWFhYICAgICBcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRmMSAoMjQxKSA+4pS0PFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkZjIgKDI0MikgPuKUrDxcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGYzICgyNDMpID7ilKQ8XHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCIgICAgIFhYWFwiLFxyXG4gIFwiICAgICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRmNCAoMjQ0KSA+4paOPFxyXG4gIFwiICBYWFhYWFhcIixcclxuICBcIiAgWFhYWFhYXCIsXHJcbiAgXCIgIFhYWFhYWFwiLFxyXG4gIFwiICBYWFhYWFhcIixcclxuICBcIiAgWFhYWFhYXCIsXHJcbiAgXCIgIFhYWFhYWFwiLFxyXG4gIFwiICBYWFhYWFhcIixcclxuICBcIiAgWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkZjUgKDI0NSkgPuKWjTxcclxuICBcIiAgIFhYWFhYXCIsXHJcbiAgXCIgICBYWFhYWFwiLFxyXG4gIFwiICAgWFhYWFhcIixcclxuICBcIiAgIFhYWFhYXCIsXHJcbiAgXCIgICBYWFhYWFwiLFxyXG4gIFwiICAgWFhYWFhcIixcclxuICBcIiAgIFhYWFhYXCIsXHJcbiAgXCIgICBYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGY2ICgyNDYpID7ilpU8XHJcbiAgXCJYWFhYWCAgIFwiLFxyXG4gIFwiWFhYWFggICBcIixcclxuICBcIlhYWFhYICAgXCIsXHJcbiAgXCJYWFhYWCAgIFwiLFxyXG4gIFwiWFhYWFggICBcIixcclxuICBcIlhYWFhYICAgXCIsXHJcbiAgXCJYWFhYWCAgIFwiLFxyXG4gIFwiWFhYWFggICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRmNyAoMjQ3KSA+4paUPFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkZjggKDI0OCkgPuKWlDxcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGY5ICgyNDkpID7iloM8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRmYSAoMjUwKSA+4oyfPFxyXG4gIFwiWFhYWFhYICBcIixcclxuICBcIlhYWFhYWCAgXCIsXHJcbiAgXCJYWFhYWFggIFwiLFxyXG4gIFwiWFhYWFhYICBcIixcclxuICBcIlhYWFhYWCAgXCIsXHJcbiAgXCJYWFhYWFggIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkZmIgKDI1MSkgPuKWljxcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCIgICAgWFhYWFwiLFxyXG4gIFwiICAgIFhYWFhcIixcclxuICBcIiAgICBYWFhYXCIsXHJcbiAgXCIgICAgWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGZjICgyNTIpID7ilp08XHJcbiAgXCJYWFhYICAgIFwiLFxyXG4gIFwiWFhYWCAgICBcIixcclxuICBcIlhYWFggICAgXCIsXHJcbiAgXCJYWFhYICAgIFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gVW5zaGlmdGVkICRmZCAoMjUzKSA+4pSYPFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiICAgICBYWFhcIixcclxuICBcIiAgICAgWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFVuc2hpZnRlZCAkZmUgKDI1NCkgPuKWmDxcclxuICBcIiAgICBYWFhYXCIsXHJcbiAgXCIgICAgWFhYWFwiLFxyXG4gIFwiICAgIFhYWFhcIixcclxuICBcIiAgICBYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBVbnNoaWZ0ZWQgJGZmICgyNTUpID7ilpo8XHJcbiAgXCIgICAgWFhYWFwiLFxyXG4gIFwiICAgIFhYWFhcIixcclxuICBcIiAgICBYWFhYXCIsXHJcbiAgXCIgICAgWFhYWFwiLFxyXG4gIFwiWFhYWCAgICBcIixcclxuICBcIlhYWFggICAgXCIsXHJcbiAgXCJYWFhYICAgIFwiLFxyXG4gIFwiWFhYWCAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkMDAgKDApID5APFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggWFhYIFwiLFxyXG4gIFwiIFhYIFhYWCBcIixcclxuICBcIiBYWCAgICAgXCIsXHJcbiAgXCIgWFggICBYIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDAxICgxKSA+YTxcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiAgICAgWFggXCIsXHJcbiAgXCIgIFhYWFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiAgWFhYWFggXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQwMiAoMikgPmI8XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiIFhYICAgICBcIixcclxuICBcIiBYWCAgICAgXCIsXHJcbiAgXCIgWFhYWFggIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFhYWFggIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkMDMgKDMpID5jPFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiIFhYICAgICBcIixcclxuICBcIiBYWCAgICAgXCIsXHJcbiAgXCIgWFggICAgIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDA0ICg0KSA+ZDxcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgIFhYIFwiLFxyXG4gIFwiICAgICBYWCBcIixcclxuICBcIiAgWFhYWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiAgWFhYWFggXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQwNSAoNSkgPmU8XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgWFhYWCAgXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYWFhYWCBcIixcclxuICBcIiBYWCAgICAgXCIsXHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkMDYgKDYpID5mPFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICBYWFggXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICBYWFhYWCBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDA3ICg3KSA+ZzxcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICBYWFhYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiICBYWFhYWCBcIixcclxuICBcIiAgICAgWFggXCIsXHJcbiAgXCIgWFhYWFggIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQwOCAoOCkgPmg8XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiIFhYICAgICBcIixcclxuICBcIiBYWCAgICAgXCIsXHJcbiAgXCIgWFhYWFggIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkMDkgKDkpID5pPFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICBYWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDBhICgxMCkgPmo8XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICBYWCBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgIFhYIFwiLFxyXG4gIFwiICAgICBYWCBcIixcclxuICBcIiAgICAgWFggXCIsXHJcbiAgXCIgICAgIFhYIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkMGIgKDExKSA+azxcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgWFggICAgIFwiLFxyXG4gIFwiIFhYICAgICBcIixcclxuICBcIiBYWCBYWCAgXCIsXHJcbiAgXCIgWFhYWCAgIFwiLFxyXG4gIFwiIFhYIFhYICBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQwYyAoMTIpID5sPFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgWFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDBkICgxMykgPm08XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFhYWFhYWFwiLFxyXG4gIFwiIFhYWFhYWFhcIixcclxuICBcIiBYWCBYIFhYXCIsXHJcbiAgXCIgWFggICBYWFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkMGUgKDE0KSA+bjxcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiIFhYWFhYICBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQwZiAoMTUpID5vPFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDEwICgxNikgPnA8XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiBYWFhYWCAgXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWFhYWCAgXCIsXHJcbiAgXCIgWFggICAgIFwiLFxyXG4gIFwiIFhYICAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkMTEgKDE3KSA+cTxcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICBYWFhYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiICBYWFhYWCBcIixcclxuICBcIiAgICAgWFggXCIsXHJcbiAgXCIgICAgIFhYIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQxMiAoMTgpID5yPFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgWFhYWFggIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgICAgXCIsXHJcbiAgXCIgWFggICAgIFwiLFxyXG4gIFwiIFhYICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDEzICgxOSkgPnM8XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgWFhYWFggXCIsXHJcbiAgXCIgWFggICAgIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiAgICAgWFggXCIsXHJcbiAgXCIgWFhYWFggIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkMTQgKDIwKSA+dDxcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiIFhYWFhYWCBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgICBYWFggXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQxNSAoMjEpID51PFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiICBYWFhYWCBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDE2ICgyMikgPnY8XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiAgWFhYWCAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkMTcgKDIzKSA+dzxcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiIFhYICAgWFhcIixcclxuICBcIiBYWCBYIFhYXCIsXHJcbiAgXCIgWFhYWFhYWFwiLFxyXG4gIFwiICBYWFhYWCBcIixcclxuICBcIiAgWFggWFggXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQxOCAoMjQpID54PFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDE5ICgyNSkgPnk8XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiAgWFhYWFggXCIsXHJcbiAgXCIgICAgWFggIFwiLFxyXG4gIFwiIFhYWFggICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkMWEgKDI2KSA+ejxcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiIFhYWFhYWCBcIixcclxuICBcIiAgICBYWCAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICBYWCAgICBcIixcclxuICBcIiBYWFhYWFggXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQxYiAoMjcpID5bPFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiAgWFggICAgXCIsXHJcbiAgXCIgIFhYICAgIFwiLFxyXG4gIFwiICBYWCAgICBcIixcclxuICBcIiAgWFggICAgXCIsXHJcbiAgXCIgIFhYICAgIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDFjICgyOCkgPsKjPFxyXG4gIFwiICAgIFhYICBcIixcclxuICBcIiAgIFggIFggXCIsXHJcbiAgXCIgIFhYICAgIFwiLFxyXG4gIFwiIFhYWFhYICBcIixcclxuICBcIiAgWFggICAgXCIsXHJcbiAgXCIgWFggICBYIFwiLFxyXG4gIFwiWFhYWFhYICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDFkICgyOSkgPl08XHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiICAgIFhYICBcIixcclxuICBcIiAgICBYWCAgXCIsXHJcbiAgXCIgICAgWFggIFwiLFxyXG4gIFwiICAgIFhYICBcIixcclxuICBcIiAgICBYWCAgXCIsXHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkMWUgKDMwKSA+4oaRPFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiIFhYWFhYWCBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDFmICgzMSkgPuKGkDxcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICBYICAgIFwiLFxyXG4gIFwiICBYWCAgICBcIixcclxuICBcIiBYWFhYWFhYXCIsXHJcbiAgXCIgWFhYWFhYWFwiLFxyXG4gIFwiICBYWCAgICBcIixcclxuICBcIiAgIFggICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQyMCAoMzIpID4gPFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDIxICgzMykgPiE8XHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkMjIgKDM0KSA+XCI8XHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkMjMgKDM1KSA+IzxcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQyNCAoMzYpID4kPFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgWFhYWFggXCIsXHJcbiAgXCIgWFggICAgIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiAgICAgWFggXCIsXHJcbiAgXCIgWFhYWFggIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDI1ICgzNykgPiU8XHJcbiAgXCIgWFggICBYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiAgICBYWCAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICBYWCAgICBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWCAgIFhYIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkMjYgKDM4KSA+JjxcclxuICBcIiAgWFhYWCAgXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiAgWFhYICAgXCIsXHJcbiAgXCIgWFggIFhYWFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiAgWFhYWFhYXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQyNyAoMzkpID4nPFxyXG4gIFwiICAgICBYWCBcIixcclxuICBcIiAgICBYWCAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDI4ICg0MCkgPig8XHJcbiAgXCIgICAgWFggIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgWFggICAgXCIsXHJcbiAgXCIgIFhYICAgIFwiLFxyXG4gIFwiICBYWCAgICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICAgWFggIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkMjkgKDQxKSA+KTxcclxuICBcIiAgWFggICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgIFhYICBcIixcclxuICBcIiAgICBYWCAgXCIsXHJcbiAgXCIgICAgWFggIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgWFggICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQyYSAoNDIpID4qPFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIiAgWFhYWCAgXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDJiICg0MykgPis8XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgWFhYWFhYIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkMmMgKDQ0KSA+LDxcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgIFhYICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQyZCAoNDUpID4tPFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiIFhYWFhYWCBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDJlICg0NikgPi48XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkMmYgKDQ3KSA+LzxcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICBYWFwiLFxyXG4gIFwiICAgICBYWCBcIixcclxuICBcIiAgICBYWCAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICBYWCAgICBcIixcclxuICBcIiBYWCAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQzMCAoNDgpID4wPFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggWFhYIFwiLFxyXG4gIFwiIFhYWCBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDMxICg0OSkgPjE8XHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgWFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgWFhYWFhYIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkMzIgKDUwKSA+MjxcclxuICBcIiAgWFhYWCAgXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiICAgICBYWCBcIixcclxuICBcIiAgICBYWCAgXCIsXHJcbiAgXCIgIFhYICAgIFwiLFxyXG4gIFwiIFhYICAgICBcIixcclxuICBcIiBYWFhYWFggXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQzMyAoNTEpID4zPFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgICAgIFhYIFwiLFxyXG4gIFwiICAgWFhYICBcIixcclxuICBcIiAgICAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDM0ICg1MikgPjQ8XHJcbiAgXCIgICAgIFhYIFwiLFxyXG4gIFwiICAgIFhYWCBcIixcclxuICBcIiAgIFhYWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYWFhYWFhcIixcclxuICBcIiAgICAgWFggXCIsXHJcbiAgXCIgICAgIFhYIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkMzUgKDUzKSA+NTxcclxuICBcIiBYWFhYWFggXCIsXHJcbiAgXCIgWFggICAgIFwiLFxyXG4gIFwiIFhYWFhYICBcIixcclxuICBcIiAgICAgWFggXCIsXHJcbiAgXCIgICAgIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiAgWFhYWCAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQzNiAoNTQpID42PFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggICAgIFwiLFxyXG4gIFwiIFhYWFhYICBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDM3ICg1NSkgPjc8XHJcbiAgXCIgWFhYWFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiAgICBYWCAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkMzggKDU2KSA+ODxcclxuICBcIiAgWFhYWCAgXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiAgWFhYWCAgXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiAgWFhYWCAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQzOSAoNTcpID45PFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiICBYWFhYWCBcIixcclxuICBcIiAgICAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDNhICg1OCkgPjo8XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkM2IgKDU5KSA+OzxcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgIFhYICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQzYyAoNjApID48PFxyXG4gIFwiICAgIFhYWCBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgIFhYICAgIFwiLFxyXG4gIFwiIFhYICAgICBcIixcclxuICBcIiAgWFggICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgIFhYWCBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDNkICg2MSkgPj08XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiBYWFhYWFggXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiIFhYWFhYWCBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkM2UgKDYyKSA+PjxcclxuICBcIiBYWFggICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgIFhYICBcIixcclxuICBcIiAgICAgWFggXCIsXHJcbiAgXCIgICAgWFggIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiBYWFggICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQzZiAoNjMpID4/PFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgICAgIFhYIFwiLFxyXG4gIFwiICAgIFhYICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDQwICg2NCkgPuKUgDxcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQ0MSAoNjUpID5BPFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgWFhYWCAgXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYWFhYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDQyICg2NikgPkI8XHJcbiAgXCIgWFhYWFggIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFhYWFggIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFhYWFggIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkNDMgKDY3KSA+QzxcclxuICBcIiAgWFhYWCAgXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYICAgICBcIixcclxuICBcIiBYWCAgICAgXCIsXHJcbiAgXCIgWFggICAgIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiAgWFhYWCAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQ0NCAoNjgpID5EPFxyXG4gIFwiIFhYWFggICBcIixcclxuICBcIiBYWCBYWCAgXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggWFggIFwiLFxyXG4gIFwiIFhYWFggICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDQ1ICg2OSkgPkU8XHJcbiAgXCIgWFhYWFhYIFwiLFxyXG4gIFwiIFhYICAgICBcIixcclxuICBcIiBYWCAgICAgXCIsXHJcbiAgXCIgWFhYWCAgIFwiLFxyXG4gIFwiIFhYICAgICBcIixcclxuICBcIiBYWCAgICAgXCIsXHJcbiAgXCIgWFhYWFhYIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkNDYgKDcwKSA+RjxcclxuICBcIiBYWFhYWFggXCIsXHJcbiAgXCIgWFggICAgIFwiLFxyXG4gIFwiIFhYICAgICBcIixcclxuICBcIiBYWFhYICAgXCIsXHJcbiAgXCIgWFggICAgIFwiLFxyXG4gIFwiIFhYICAgICBcIixcclxuICBcIiBYWCAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQ0NyAoNzEpID5HPFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggICAgIFwiLFxyXG4gIFwiIFhYIFhYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDQ4ICg3MikgPkg8XHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFhYWFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkNDkgKDczKSA+STxcclxuICBcIiAgWFhYWCAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgWFhYWCAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQ0YSAoNzQpID5KPFxyXG4gIFwiICAgWFhYWCBcIixcclxuICBcIiAgICBYWCAgXCIsXHJcbiAgXCIgICAgWFggIFwiLFxyXG4gIFwiICAgIFhYICBcIixcclxuICBcIiAgICBYWCAgXCIsXHJcbiAgXCIgWFggWFggIFwiLFxyXG4gIFwiICBYWFggICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDRiICg3NSkgPks8XHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYIFhYICBcIixcclxuICBcIiBYWFhYICAgXCIsXHJcbiAgXCIgWFhYICAgIFwiLFxyXG4gIFwiIFhYWFggICBcIixcclxuICBcIiBYWCBYWCAgXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkNGMgKDc2KSA+TDxcclxuICBcIiBYWCAgICAgXCIsXHJcbiAgXCIgWFggICAgIFwiLFxyXG4gIFwiIFhYICAgICBcIixcclxuICBcIiBYWCAgICAgXCIsXHJcbiAgXCIgWFggICAgIFwiLFxyXG4gIFwiIFhYICAgICBcIixcclxuICBcIiBYWFhYWFggXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQ0ZCAoNzcpID5NPFxyXG4gIFwiIFhYICAgWFhcIixcclxuICBcIiBYWFggWFhYXCIsXHJcbiAgXCIgWFhYWFhYWFwiLFxyXG4gIFwiIFhYIFggWFhcIixcclxuICBcIiBYWCAgIFhYXCIsXHJcbiAgXCIgWFggICBYWFwiLFxyXG4gIFwiIFhYICAgWFhcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDRlICg3OCkgPk48XHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYWCBYWCBcIixcclxuICBcIiBYWFhYWFggXCIsXHJcbiAgXCIgWFhYWFhYIFwiLFxyXG4gIFwiIFhYIFhYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkNGYgKDc5KSA+TzxcclxuICBcIiAgWFhYWCAgXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiAgWFhYWCAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQ1MCAoODApID5QPFxyXG4gIFwiIFhYWFhYICBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYWFhYICBcIixcclxuICBcIiBYWCAgICAgXCIsXHJcbiAgXCIgWFggICAgIFwiLFxyXG4gIFwiIFhYICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDUxICg4MSkgPlE8XHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiAgWFhYWCAgXCIsXHJcbiAgXCIgICAgWFhYIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkNTIgKDgyKSA+UjxcclxuICBcIiBYWFhYWCAgXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWFhYWCAgXCIsXHJcbiAgXCIgWFhYWCAgIFwiLFxyXG4gIFwiIFhYIFhYICBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQ1MyAoODMpID5TPFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggICAgIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiAgICAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDU0ICg4NCkgPlQ8XHJcbiAgXCIgWFhYWFhYIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkNTUgKDg1KSA+VTxcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiAgWFhYWCAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQ1NiAoODYpID5WPFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDU3ICg4NykgPlc8XHJcbiAgXCIgWFggICBYWFwiLFxyXG4gIFwiIFhYICAgWFhcIixcclxuICBcIiBYWCAgIFhYXCIsXHJcbiAgXCIgWFggWCBYWFwiLFxyXG4gIFwiIFhYWFhYWFhcIixcclxuICBcIiBYWFggWFhYXCIsXHJcbiAgXCIgWFggICBYWFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkNTggKDg4KSA+WDxcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgIFhYWFggIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQ1OSAoODkpID5ZPFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG4gIFwiICBYWFhYICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDVhICg5MCkgPlo8XHJcbiAgXCIgWFhYWFhYIFwiLFxyXG4gIFwiICAgICBYWCBcIixcclxuICBcIiAgICBYWCAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICBYWCAgICBcIixcclxuICBcIiBYWCAgICAgXCIsXHJcbiAgXCIgWFhYWFhYIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkNWIgKDkxKSA+4pS8PFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDVjICg5MikgPuKWkjxcclxuICBcIlhYICAgICAgXCIsXHJcbiAgXCJYWCAgICAgIFwiLFxyXG4gIFwiICBYWCAgICBcIixcclxuICBcIiAgWFggICAgXCIsXHJcbiAgXCJYWCAgICAgIFwiLFxyXG4gIFwiWFggICAgICBcIixcclxuICBcIiAgWFggICAgXCIsXHJcbiAgXCIgIFhYICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQ1ZCAoOTMpID7ilII8XHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkNWUgKDk0KSA+4paSPFxyXG4gIFwiICBYWCAgWFhcIixcclxuICBcIiAgWFggIFhYXCIsXHJcbiAgXCJYWCAgWFggIFwiLFxyXG4gIFwiWFggIFhYICBcIixcclxuICBcIiAgWFggIFhYXCIsXHJcbiAgXCIgIFhYICBYWFwiLFxyXG4gIFwiWFggIFhYICBcIixcclxuICBcIlhYICBYWCAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDVmICg5NSkgPuKWkjxcclxuICBcIiAgWFggIFhYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWFggIFhYICBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgIFhYICBYWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlhYICBYWCAgXCIsXHJcbiAgXCIgWFggIFhYIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQ2MCAoOTYpID4gPFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDYxICg5NykgPuKWjDxcclxuICBcIlhYWFggICAgXCIsXHJcbiAgXCJYWFhYICAgIFwiLFxyXG4gIFwiWFhYWCAgICBcIixcclxuICBcIlhYWFggICAgXCIsXHJcbiAgXCJYWFhYICAgIFwiLFxyXG4gIFwiWFhYWCAgICBcIixcclxuICBcIlhYWFggICAgXCIsXHJcbiAgXCJYWFhYICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQ2MiAoOTgpID7iloQ8XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkNjMgKDk5KSA+4paUPFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDY0ICgxMDApID7iloE8XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkNjUgKDEwMSkgPuKWjjxcclxuICBcIlhYICAgICAgXCIsXHJcbiAgXCJYWCAgICAgIFwiLFxyXG4gIFwiWFggICAgICBcIixcclxuICBcIlhYICAgICAgXCIsXHJcbiAgXCJYWCAgICAgIFwiLFxyXG4gIFwiWFggICAgICBcIixcclxuICBcIlhYICAgICAgXCIsXHJcbiAgXCJYWCAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQ2NiAoMTAyKSA+4paSPFxyXG4gIFwiWFggIFhYICBcIixcclxuICBcIlhYICBYWCAgXCIsXHJcbiAgXCIgIFhYICBYWFwiLFxyXG4gIFwiICBYWCAgWFhcIixcclxuICBcIlhYICBYWCAgXCIsXHJcbiAgXCJYWCAgWFggIFwiLFxyXG4gIFwiICBYWCAgWFhcIixcclxuICBcIiAgWFggIFhYXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDY3ICgxMDMpID7ilpU8XHJcbiAgXCIgICAgICBYWFwiLFxyXG4gIFwiICAgICAgWFhcIixcclxuICBcIiAgICAgIFhYXCIsXHJcbiAgXCIgICAgICBYWFwiLFxyXG4gIFwiICAgICAgWFhcIixcclxuICBcIiAgICAgIFhYXCIsXHJcbiAgXCIgICAgICBYWFwiLFxyXG4gIFwiICAgICAgWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkNjggKDEwNCkgPuKWkjxcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCJYWCAgWFggIFwiLFxyXG4gIFwiWFggIFhYICBcIixcclxuICBcIiAgWFggIFhYXCIsXHJcbiAgXCIgIFhYICBYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQ2OSAoMTA1KSA+4paSPFxyXG4gIFwiWFggIFhYICBcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCIgIFhYICBYWFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIlhYICBYWCAgXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiICBYWCAgWFhcIixcclxuICBcIiBYWCAgWFggXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDZhICgxMDYpID7ilpU8XHJcbiAgXCIgICAgICBYWFwiLFxyXG4gIFwiICAgICAgWFhcIixcclxuICBcIiAgICAgIFhYXCIsXHJcbiAgXCIgICAgICBYWFwiLFxyXG4gIFwiICAgICAgWFhcIixcclxuICBcIiAgICAgIFhYXCIsXHJcbiAgXCIgICAgICBYWFwiLFxyXG4gIFwiICAgICAgWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkNmIgKDEwNykgPuKUnDxcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYWFhYXCIsXHJcbiAgXCIgICBYWFhYWFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQ2YyAoMTA4KSA+4paXPFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICBYWFhYXCIsXHJcbiAgXCIgICAgWFhYWFwiLFxyXG4gIFwiICAgIFhYWFhcIixcclxuICBcIiAgICBYWFhYXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDZkICgxMDkpID7ilJQ8XHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWFhYWFwiLFxyXG4gIFwiICAgWFhYWFhcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkNmUgKDExMCkgPuKUkDxcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIlhYWFhYICAgXCIsXHJcbiAgXCJYWFhYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQ2ZiAoMTExKSA+4paCPFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDcwICgxMTIpID7ilIw8XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICBYWFhYWFwiLFxyXG4gIFwiICAgWFhYWFhcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkNzEgKDExMykgPuKUtDxcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQ3MiAoMTE0KSA+4pSsPFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDczICgxMTUpID7ilKQ8XHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCJYWFhYWCAgIFwiLFxyXG4gIFwiWFhYWFggICBcIixcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkNzQgKDExNikgPuKWjjxcclxuICBcIlhYICAgICAgXCIsXHJcbiAgXCJYWCAgICAgIFwiLFxyXG4gIFwiWFggICAgICBcIixcclxuICBcIlhYICAgICAgXCIsXHJcbiAgXCJYWCAgICAgIFwiLFxyXG4gIFwiWFggICAgICBcIixcclxuICBcIlhYICAgICAgXCIsXHJcbiAgXCJYWCAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQ3NSAoMTE3KSA+4paNPFxyXG4gIFwiWFhYICAgICBcIixcclxuICBcIlhYWCAgICAgXCIsXHJcbiAgXCJYWFggICAgIFwiLFxyXG4gIFwiWFhYICAgICBcIixcclxuICBcIlhYWCAgICAgXCIsXHJcbiAgXCJYWFggICAgIFwiLFxyXG4gIFwiWFhYICAgICBcIixcclxuICBcIlhYWCAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDc2ICgxMTgpID7ilpU8XHJcbiAgXCIgICAgIFhYWFwiLFxyXG4gIFwiICAgICBYWFhcIixcclxuICBcIiAgICAgWFhYXCIsXHJcbiAgXCIgICAgIFhYWFwiLFxyXG4gIFwiICAgICBYWFhcIixcclxuICBcIiAgICAgWFhYXCIsXHJcbiAgXCIgICAgIFhYWFwiLFxyXG4gIFwiICAgICBYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkNzcgKDExOSkgPuKWlDxcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQ3OCAoMTIwKSA+4paUPFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDc5ICgxMjEpID7iloM8XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkN2EgKDEyMikgPuKckzxcclxuICBcIiAgICAgICBYXCIsXHJcbiAgXCIgICAgICBYWFwiLFxyXG4gIFwiICAgICBYWCBcIixcclxuICBcIiBYWCBYWCAgXCIsXHJcbiAgXCIgWFhYWCAgIFwiLFxyXG4gIFwiIFhYWCAgICBcIixcclxuICBcIiBYWCAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQ3YiAoMTIzKSA+4paWPFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIlhYWFggICAgXCIsXHJcbiAgXCJYWFhYICAgIFwiLFxyXG4gIFwiWFhYWCAgICBcIixcclxuICBcIlhYWFggICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDdjICgxMjQpID7ilp08XHJcbiAgXCIgICAgWFhYWFwiLFxyXG4gIFwiICAgIFhYWFhcIixcclxuICBcIiAgICBYWFhYXCIsXHJcbiAgXCIgICAgWFhYWFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkN2QgKDEyNSkgPuKUmDxcclxuICBcIiAgIFhYICAgXCIsXHJcbiAgXCIgICBYWCAgIFwiLFxyXG4gIFwiICAgWFggICBcIixcclxuICBcIlhYWFhYICAgXCIsXHJcbiAgXCJYWFhYWCAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICQ3ZSAoMTI2KSA+4paYPFxyXG4gIFwiWFhYWCAgICBcIixcclxuICBcIlhYWFggICAgXCIsXHJcbiAgXCJYWFhYICAgIFwiLFxyXG4gIFwiWFhYWCAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDdmICgxMjcpID7ilpo8XHJcbiAgXCJYWFhYICAgIFwiLFxyXG4gIFwiWFhYWCAgICBcIixcclxuICBcIlhYWFggICAgXCIsXHJcbiAgXCJYWFhYICAgIFwiLFxyXG4gIFwiICAgIFhYWFhcIixcclxuICBcIiAgICBYWFhYXCIsXHJcbiAgXCIgICAgWFhYWFwiLFxyXG4gIFwiICAgIFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkODAgKDEyOCkgPkA8XHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFggICBYXCIsXHJcbiAgXCJYICBYICAgWFwiLFxyXG4gIFwiWCAgWFhYWFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkODEgKDEyOSkgPmE8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYWFhYWCAgWFwiLFxyXG4gIFwiWFggICAgIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWCAgICAgWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkODIgKDEzMCkgPmI8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWCAgWFhYWFhcIixcclxuICBcIlggIFhYWFhYXCIsXHJcbiAgXCJYICAgICBYWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICAgICBYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkODMgKDEzMSkgPmM8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYICBYWFhYWFwiLFxyXG4gIFwiWCAgWFhYWFhcIixcclxuICBcIlggIFhYWFhYXCIsXHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkODQgKDEzMikgPmQ8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFggIFhcIixcclxuICBcIlhYWFhYICBYXCIsXHJcbiAgXCJYWCAgICAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWCAgICAgWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkODUgKDEzMykgPmU8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgICAgIFhcIixcclxuICBcIlggIFhYWFhYXCIsXHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkODYgKDEzNCkgPmY8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWCAgIFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWCAgICAgWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkODcgKDEzNSkgPmc8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYICAgICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlhYICAgICBYXCIsXHJcbiAgXCJYWFhYWCAgWFwiLFxyXG4gIFwiWCAgICAgWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkODggKDEzNikgPmg8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWCAgWFhYWFhcIixcclxuICBcIlggIFhYWFhYXCIsXHJcbiAgXCJYICAgICBYWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkODkgKDEzNykgPmk8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWCAgIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkOGEgKDEzOCkgPmo8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFggIFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWCAgWFwiLFxyXG4gIFwiWFhYWFggIFhcIixcclxuICBcIlhYWFhYICBYXCIsXHJcbiAgXCJYWFhYWCAgWFwiLFxyXG4gIFwiWFggICAgWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkOGIgKDEzOSkgPms8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWCAgWFhYWFhcIixcclxuICBcIlggIFhYWFhYXCIsXHJcbiAgXCJYICBYICBYWFwiLFxyXG4gIFwiWCAgICBYWFhcIixcclxuICBcIlggIFggIFhYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkOGMgKDE0MCkgPmw8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFggICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkOGQgKDE0MSkgPm08XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICAgICAgIFwiLFxyXG4gIFwiWCAgICAgICBcIixcclxuICBcIlggIFggWCAgXCIsXHJcbiAgXCJYICBYWFggIFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkOGUgKDE0MikgPm48XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlggICAgIFhYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkOGYgKDE0MykgPm88XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkOTAgKDE0NCkgPnA8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlggICAgIFhYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggICAgIFhYXCIsXHJcbiAgXCJYICBYWFhYWFwiLFxyXG4gIFwiWCAgWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkOTEgKDE0NSkgPnE8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYICAgICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlhYICAgICBYXCIsXHJcbiAgXCJYWFhYWCAgWFwiLFxyXG4gIFwiWFhYWFggIFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkOTIgKDE0NikgPnI8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlggICAgIFhYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFhYWFhcIixcclxuICBcIlggIFhYWFhYXCIsXHJcbiAgXCJYICBYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkOTMgKDE0NykgPnM8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYICAgICBYXCIsXHJcbiAgXCJYICBYWFhYWFwiLFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlhYWFhYICBYXCIsXHJcbiAgXCJYICAgICBYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkOTQgKDE0OCkgPnQ8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlggICAgICBYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFhYICAgWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkOTUgKDE0OSkgPnU8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWCAgICAgWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkOTYgKDE1MCkgPnY8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkOTcgKDE1MSkgPnc8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlggIFhYWCAgXCIsXHJcbiAgXCJYICBYIFggIFwiLFxyXG4gIFwiWCAgICAgICBcIixcclxuICBcIlhYICAgICBYXCIsXHJcbiAgXCJYWCAgWCAgWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkOTggKDE1MikgPng8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkOTkgKDE1MykgPnk8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlhYICAgICBYXCIsXHJcbiAgXCJYWFhYICBYWFwiLFxyXG4gIFwiWCAgICBYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkOWEgKDE1NCkgPno8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlggICAgICBYXCIsXHJcbiAgXCJYWFhYICBYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYICBYWFhYXCIsXHJcbiAgXCJYICAgICAgWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkOWIgKDE1NSkgPls8XHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWFggIFhYWFhcIixcclxuICBcIlhYICBYWFhYXCIsXHJcbiAgXCJYWCAgWFhYWFwiLFxyXG4gIFwiWFggIFhYWFhcIixcclxuICBcIlhYICBYWFhYXCIsXHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkOWMgKDE1NikgPsKjPFxyXG4gIFwiWFhYWCAgWFhcIixcclxuICBcIlhYWCBYWCBYXCIsXHJcbiAgXCJYWCAgWFhYWFwiLFxyXG4gIFwiWCAgICAgWFhcIixcclxuICBcIlhYICBYWFhYXCIsXHJcbiAgXCJYICBYWFggWFwiLFxyXG4gIFwiICAgICAgWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDlkICgxNTcpID5dPFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlhYWFggIFhYXCIsXHJcbiAgXCJYWFhYICBYWFwiLFxyXG4gIFwiWFhYWCAgWFhcIixcclxuICBcIlhYWFggIFhYXCIsXHJcbiAgXCJYWFhYICBYWFwiLFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJDllICgxNTgpID7ihpE8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYICAgICAgWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkOWYgKDE1OSkgPuKGkDxcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFggWFhYWFwiLFxyXG4gIFwiWFggIFhYWFhcIixcclxuICBcIlggICAgICAgXCIsXHJcbiAgXCJYICAgICAgIFwiLFxyXG4gIFwiWFggIFhYWFhcIixcclxuICBcIlhYWCBYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRhMCAoMTYwKSA+IDxcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRhMSAoMTYxKSA+ITxcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRhMiAoMTYyKSA+XCI8XHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkYTMgKDE2MykgPiM8XHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkYTQgKDE2NCkgPiQ8XHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFggICAgIFhcIixcclxuICBcIlggIFhYWFhYXCIsXHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWFhYWFggIFhcIixcclxuICBcIlggICAgIFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkYTUgKDE2NSkgPiU8XHJcbiAgXCJYICBYWFggWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlhYWFggIFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFggIFhYWFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYIFhYWCAgWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkYTYgKDE2NikgPiY8XHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYWCAgIFhYWFwiLFxyXG4gIFwiWCAgWFggICBcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWCAgICAgIFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkYTcgKDE2NykgPic8XHJcbiAgXCJYWFhYWCAgWFwiLFxyXG4gIFwiWFhYWCAgWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkYTggKDE2OCkgPig8XHJcbiAgXCJYWFhYICBYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYICBYWFhYXCIsXHJcbiAgXCJYWCAgWFhYWFwiLFxyXG4gIFwiWFggIFhYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFhYICBYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkYTkgKDE2OSkgPik8XHJcbiAgXCJYWCAgWFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWFggIFhYXCIsXHJcbiAgXCJYWFhYICBYWFwiLFxyXG4gIFwiWFhYWCAgWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWCAgWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkYWEgKDE3MCkgPio8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkYWIgKDE3MSkgPis8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYICAgICAgWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkYWMgKDE3MikgPiw8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFggIFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkYWQgKDE3MykgPi08XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYICAgICAgWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkYWUgKDE3NCkgPi48XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkYWYgKDE3NSkgPi88XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYICBcIixcclxuICBcIlhYWFhYICBYXCIsXHJcbiAgXCJYWFhYICBYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYICBYWFhYXCIsXHJcbiAgXCJYICBYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkYjAgKDE3NikgPjA8XHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFggICBYXCIsXHJcbiAgXCJYICAgWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkYjEgKDE3NykgPjE8XHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYICAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYICAgICAgWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkYjIgKDE3OCkgPjI8XHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlhYWFhYICBYXCIsXHJcbiAgXCJYWFhYICBYWFwiLFxyXG4gIFwiWFggIFhYWFhcIixcclxuICBcIlggIFhYWFhYXCIsXHJcbiAgXCJYICAgICAgWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkYjMgKDE3OSkgPjM8XHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlhYWFhYICBYXCIsXHJcbiAgXCJYWFggICBYWFwiLFxyXG4gIFwiWFhYWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkYjQgKDE4MCkgPjQ8XHJcbiAgXCJYWFhYWCAgWFwiLFxyXG4gIFwiWFhYWCAgIFhcIixcclxuICBcIlhYWCAgICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgICAgICBcIixcclxuICBcIlhYWFhYICBYXCIsXHJcbiAgXCJYWFhYWCAgWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkYjUgKDE4MSkgPjU8XHJcbiAgXCJYICAgICAgWFwiLFxyXG4gIFwiWCAgWFhYWFhcIixcclxuICBcIlggICAgIFhYXCIsXHJcbiAgXCJYWFhYWCAgWFwiLFxyXG4gIFwiWFhYWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkYjYgKDE4MikgPjY8XHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYWFhYXCIsXHJcbiAgXCJYICAgICBYWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkYjcgKDE4MykgPjc8XHJcbiAgXCJYICAgICAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlhYWFggIFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkYjggKDE4NCkgPjg8XHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkYjkgKDE4NSkgPjk8XHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWCAgICAgWFwiLFxyXG4gIFwiWFhYWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkYmEgKDE4NikgPjo8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkYmIgKDE4NykgPjs8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFggIFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkYmMgKDE4OCkgPjw8XHJcbiAgXCJYWFhYICAgWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYICBYWFhYXCIsXHJcbiAgXCJYICBYWFhYWFwiLFxyXG4gIFwiWFggIFhYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFhYICAgWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkYmQgKDE4OSkgPj08XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlggICAgICBYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWCAgICAgIFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkYmUgKDE5MCkgPj48XHJcbiAgXCJYICAgWFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWFggIFhYXCIsXHJcbiAgXCJYWFhYWCAgWFwiLFxyXG4gIFwiWFhYWCAgWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYICAgWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkYmYgKDE5MSkgPj88XHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlhYWFhYICBYXCIsXHJcbiAgXCJYWFhYICBYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkYzAgKDE5MikgPuKUgDxcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRjMSAoMTkzKSA+QTxcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggICAgICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRjMiAoMTk0KSA+QjxcclxuICBcIlggICAgIFhYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggICAgIFhYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggICAgIFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRjMyAoMTk1KSA+QzxcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFhYWFhcIixcclxuICBcIlggIFhYWFhYXCIsXHJcbiAgXCJYICBYWFhYWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRjNCAoMTk2KSA+RDxcclxuICBcIlggICAgWFhYXCIsXHJcbiAgXCJYICBYICBYWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWCAgWFhcIixcclxuICBcIlggICAgWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRjNSAoMTk3KSA+RTxcclxuICBcIlggICAgICBYXCIsXHJcbiAgXCJYICBYWFhYWFwiLFxyXG4gIFwiWCAgWFhYWFhcIixcclxuICBcIlggICAgWFhYXCIsXHJcbiAgXCJYICBYWFhYWFwiLFxyXG4gIFwiWCAgWFhYWFhcIixcclxuICBcIlggICAgICBYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRjNiAoMTk4KSA+RjxcclxuICBcIlggICAgICBYXCIsXHJcbiAgXCJYICBYWFhYWFwiLFxyXG4gIFwiWCAgWFhYWFhcIixcclxuICBcIlggICAgWFhYXCIsXHJcbiAgXCJYICBYWFhYWFwiLFxyXG4gIFwiWCAgWFhYWFhcIixcclxuICBcIlggIFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRjNyAoMTk5KSA+RzxcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFhYWFhcIixcclxuICBcIlggIFggICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRjOCAoMjAwKSA+SDxcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggICAgICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRjOSAoMjAxKSA+STxcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRjYSAoMjAyKSA+SjxcclxuICBcIlhYWCAgICBYXCIsXHJcbiAgXCJYWFhYICBYWFwiLFxyXG4gIFwiWFhYWCAgWFhcIixcclxuICBcIlhYWFggIFhYXCIsXHJcbiAgXCJYWFhYICBYWFwiLFxyXG4gIFwiWCAgWCAgWFhcIixcclxuICBcIlhYICAgWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRjYiAoMjAzKSA+SzxcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYICBYWFwiLFxyXG4gIFwiWCAgICBYWFhcIixcclxuICBcIlggICBYWFhYXCIsXHJcbiAgXCJYICAgIFhYWFwiLFxyXG4gIFwiWCAgWCAgWFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRjYyAoMjA0KSA+TDxcclxuICBcIlggIFhYWFhYXCIsXHJcbiAgXCJYICBYWFhYWFwiLFxyXG4gIFwiWCAgWFhYWFhcIixcclxuICBcIlggIFhYWFhYXCIsXHJcbiAgXCJYICBYWFhYWFwiLFxyXG4gIFwiWCAgWFhYWFhcIixcclxuICBcIlggICAgICBYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRjZCAoMjA1KSA+TTxcclxuICBcIlggIFhYWCAgXCIsXHJcbiAgXCJYICAgWCAgIFwiLFxyXG4gIFwiWCAgICAgICBcIixcclxuICBcIlggIFggWCAgXCIsXHJcbiAgXCJYICBYWFggIFwiLFxyXG4gIFwiWCAgWFhYICBcIixcclxuICBcIlggIFhYWCAgXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRjZSAoMjA2KSA+TjxcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICAgWCAgWFwiLFxyXG4gIFwiWCAgICAgIFhcIixcclxuICBcIlggICAgICBYXCIsXHJcbiAgXCJYICBYICAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRjZiAoMjA3KSA+TzxcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRkMCAoMjA4KSA+UDxcclxuICBcIlggICAgIFhYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggICAgIFhYXCIsXHJcbiAgXCJYICBYWFhYWFwiLFxyXG4gIFwiWCAgWFhYWFhcIixcclxuICBcIlggIFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRkMSAoMjA5KSA+UTxcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlhYWFggICBYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRkMiAoMjEwKSA+UjxcclxuICBcIlggICAgIFhYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggICAgIFhYXCIsXHJcbiAgXCJYICAgIFhYWFwiLFxyXG4gIFwiWCAgWCAgWFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRkMyAoMjExKSA+UzxcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFhYWFhcIixcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYWFhYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRkNCAoMjEyKSA+VDxcclxuICBcIlggICAgICBYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRkNSAoMjEzKSA+VTxcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRkNiAoMjE0KSA+VjxcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRkNyAoMjE1KSA+VzxcclxuICBcIlggIFhYWCAgXCIsXHJcbiAgXCJYICBYWFggIFwiLFxyXG4gIFwiWCAgWFhYICBcIixcclxuICBcIlggIFggWCAgXCIsXHJcbiAgXCJYICAgICAgIFwiLFxyXG4gIFwiWCAgIFggICBcIixcclxuICBcIlggIFhYWCAgXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRkOCAoMjE2KSA+WDxcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWFggICAgWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWCAgICBYWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRkOSAoMjE3KSA+WTxcclxuICBcIlggIFhYICBYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuICBcIlhYICAgIFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRkYSAoMjE4KSA+WjxcclxuICBcIlggICAgICBYXCIsXHJcbiAgXCJYWFhYWCAgWFwiLFxyXG4gIFwiWFhYWCAgWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWCAgWFhYWFwiLFxyXG4gIFwiWCAgWFhYWFhcIixcclxuICBcIlggICAgICBYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRkYiAoMjE5KSA+4pS8PFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJGRjICgyMjApID7ilpI8XHJcbiAgXCIgIFhYWFhYWFwiLFxyXG4gIFwiICBYWFhYWFhcIixcclxuICBcIlhYICBYWFhYXCIsXHJcbiAgXCJYWCAgWFhYWFwiLFxyXG4gIFwiICBYWFhYWFhcIixcclxuICBcIiAgWFhYWFhYXCIsXHJcbiAgXCJYWCAgWFhYWFwiLFxyXG4gIFwiWFggIFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkZGQgKDIyMSkgPuKUgjxcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRkZSAoMjIyKSA+4paSPFxyXG4gIFwiWFggIFhYICBcIixcclxuICBcIlhYICBYWCAgXCIsXHJcbiAgXCIgIFhYICBYWFwiLFxyXG4gIFwiICBYWCAgWFhcIixcclxuICBcIlhYICBYWCAgXCIsXHJcbiAgXCJYWCAgWFggIFwiLFxyXG4gIFwiICBYWCAgWFhcIixcclxuICBcIiAgWFggIFhYXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJGRmICgyMjMpID7ilpI8XHJcbiAgXCJYWCAgWFggIFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIiAgWFggIFhYXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiWFggIFhYICBcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCIgIFhYICBYWFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkZTAgKDIyNCkgPiA8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkZTEgKDIyNSkgPuKWjDxcclxuICBcIiAgICBYWFhYXCIsXHJcbiAgXCIgICAgWFhYWFwiLFxyXG4gIFwiICAgIFhYWFhcIixcclxuICBcIiAgICBYWFhYXCIsXHJcbiAgXCIgICAgWFhYWFwiLFxyXG4gIFwiICAgIFhYWFhcIixcclxuICBcIiAgICBYWFhYXCIsXHJcbiAgXCIgICAgWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRlMiAoMjI2KSA+4paEPFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJGUzICgyMjcpID7ilpQ8XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkZTQgKDIyOCkgPuKWgTxcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRlNSAoMjI5KSA+4paOPFxyXG4gIFwiICBYWFhYWFhcIixcclxuICBcIiAgWFhYWFhYXCIsXHJcbiAgXCIgIFhYWFhYWFwiLFxyXG4gIFwiICBYWFhYWFhcIixcclxuICBcIiAgWFhYWFhYXCIsXHJcbiAgXCIgIFhYWFhYWFwiLFxyXG4gIFwiICBYWFhYWFhcIixcclxuICBcIiAgWFhYWFhYXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJGU2ICgyMzApID7ilpI8XHJcbiAgXCIgIFhYICBYWFwiLFxyXG4gIFwiICBYWCAgWFhcIixcclxuICBcIlhYICBYWCAgXCIsXHJcbiAgXCJYWCAgWFggIFwiLFxyXG4gIFwiICBYWCAgWFhcIixcclxuICBcIiAgWFggIFhYXCIsXHJcbiAgXCJYWCAgWFggIFwiLFxyXG4gIFwiWFggIFhYICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkZTcgKDIzMSkgPuKWlTxcclxuICBcIlhYWFhYWCAgXCIsXHJcbiAgXCJYWFhYWFggIFwiLFxyXG4gIFwiWFhYWFhYICBcIixcclxuICBcIlhYWFhYWCAgXCIsXHJcbiAgXCJYWFhYWFggIFwiLFxyXG4gIFwiWFhYWFhYICBcIixcclxuICBcIlhYWFhYWCAgXCIsXHJcbiAgXCJYWFhYWFggIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRlOCAoMjMyKSA+4paSPFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIiAgWFggIFhYXCIsXHJcbiAgXCIgIFhYICBYWFwiLFxyXG4gIFwiWFggIFhYICBcIixcclxuICBcIlhYICBYWCAgXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJGU5ICgyMzMpID7ilpI8XHJcbiAgXCIgIFhYICBYWFwiLFxyXG4gIFwiIFhYICBYWCBcIixcclxuICBcIlhYICBYWCAgXCIsXHJcbiAgXCJYICBYWCAgWFwiLFxyXG4gIFwiICBYWCAgWFhcIixcclxuICBcIiBYWCAgWFggXCIsXHJcbiAgXCJYWCAgWFggIFwiLFxyXG4gIFwiWCAgWFggIFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkZWEgKDIzNCkgPuKWlTxcclxuICBcIlhYWFhYWCAgXCIsXHJcbiAgXCJYWFhYWFggIFwiLFxyXG4gIFwiWFhYWFhYICBcIixcclxuICBcIlhYWFhYWCAgXCIsXHJcbiAgXCJYWFhYWFggIFwiLFxyXG4gIFwiWFhYWFhYICBcIixcclxuICBcIlhYWFhYWCAgXCIsXHJcbiAgXCJYWFhYWFggIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRlYiAoMjM1KSA+4pScPFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICAgICBcIixcclxuICBcIlhYWCAgICAgXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJGVjICgyMzYpID7ilpc8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWCAgICBcIixcclxuICBcIlhYWFggICAgXCIsXHJcbiAgXCJYWFhYICAgIFwiLFxyXG4gIFwiWFhYWCAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkZWQgKDIzNykgPuKUlDxcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgICAgXCIsXHJcbiAgXCJYWFggICAgIFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRlZSAoMjM4KSA+4pSQPFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiICAgICBYWFhcIixcclxuICBcIiAgICAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJGVmICgyMzkpID7iloI8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkZjAgKDI0MCkgPuKUjDxcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWCAgICAgXCIsXHJcbiAgXCJYWFggICAgIFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRmMSAoMjQxKSA+4pS0PFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJGYyICgyNDIpID7ilKw8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkZjMgKDI0MykgPuKUpDxcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIiAgICAgWFhYXCIsXHJcbiAgXCIgICAgIFhYWFwiLFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRmNCAoMjQ0KSA+4paOPFxyXG4gIFwiICBYWFhYWFhcIixcclxuICBcIiAgWFhYWFhYXCIsXHJcbiAgXCIgIFhYWFhYWFwiLFxyXG4gIFwiICBYWFhYWFhcIixcclxuICBcIiAgWFhYWFhYXCIsXHJcbiAgXCIgIFhYWFhYWFwiLFxyXG4gIFwiICBYWFhYWFhcIixcclxuICBcIiAgWFhYWFhYXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJGY1ICgyNDUpID7ilo08XHJcbiAgXCIgICBYWFhYWFwiLFxyXG4gIFwiICAgWFhYWFhcIixcclxuICBcIiAgIFhYWFhYXCIsXHJcbiAgXCIgICBYWFhYWFwiLFxyXG4gIFwiICAgWFhYWFhcIixcclxuICBcIiAgIFhYWFhYXCIsXHJcbiAgXCIgICBYWFhYWFwiLFxyXG4gIFwiICAgWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkZjYgKDI0NikgPuKWlTxcclxuICBcIlhYWFhYICAgXCIsXHJcbiAgXCJYWFhYWCAgIFwiLFxyXG4gIFwiWFhYWFggICBcIixcclxuICBcIlhYWFhYICAgXCIsXHJcbiAgXCJYWFhYWCAgIFwiLFxyXG4gIFwiWFhYWFggICBcIixcclxuICBcIlhYWFhYICAgXCIsXHJcbiAgXCJYWFhYWCAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRmNyAoMjQ3KSA+4paUPFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJGY4ICgyNDgpID7ilpQ8XHJcbiAgXCIgICAgICAgIFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkZjkgKDI0OSkgPuKWgzxcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiICAgICAgICBcIixcclxuICBcIiAgICAgICAgXCIsXHJcbiAgXCIgICAgICAgIFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRmYSAoMjUwKSA+4pyTPFxyXG4gIFwiWFhYWFhYWCBcIixcclxuICBcIlhYWFhYWCAgXCIsXHJcbiAgXCJYWFhYWCAgWFwiLFxyXG4gIFwiWCAgWCAgWFhcIixcclxuICBcIlggICAgWFhYXCIsXHJcbiAgXCJYICAgWFhYWFwiLFxyXG4gIFwiWCAgWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJGZiICgyNTEpID7ilpY8XHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiICAgIFhYWFhcIixcclxuICBcIiAgICBYWFhYXCIsXHJcbiAgXCIgICAgWFhYWFwiLFxyXG4gIFwiICAgIFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkZmMgKDI1MikgPuKWnTxcclxuICBcIlhYWFggICAgXCIsXHJcbiAgXCJYWFhYICAgIFwiLFxyXG4gIFwiWFhYWCAgICBcIixcclxuICBcIlhYWFggICAgXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG5cclxuICAvLyBTaGlmdGVkICRmZCAoMjUzKSA+4pSYPFxyXG4gIFwiWFhYICBYWFhcIixcclxuICBcIlhYWCAgWFhYXCIsXHJcbiAgXCJYWFggIFhYWFwiLFxyXG4gIFwiICAgICBYWFhcIixcclxuICBcIiAgICAgWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcblxyXG4gIC8vIFNoaWZ0ZWQgJGZlICgyNTQpID7ilpg8XHJcbiAgXCIgICAgWFhYWFwiLFxyXG4gIFwiICAgIFhYWFhcIixcclxuICBcIiAgICBYWFhYXCIsXHJcbiAgXCIgICAgWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuICBcIlhYWFhYWFhYXCIsXHJcbiAgXCJYWFhYWFhYWFwiLFxyXG4gIFwiWFhYWFhYWFhcIixcclxuXHJcbiAgLy8gU2hpZnRlZCAkZmYgKDI1NSkgPuKWmjxcclxuICBcIiAgICBYWFhYXCIsXHJcbiAgXCIgICAgWFhYWFwiLFxyXG4gIFwiICAgIFhYWFhcIixcclxuICBcIiAgICBYWFhYXCIsXHJcbiAgXCJYWFhYICAgIFwiLFxyXG4gIFwiWFhYWCAgICBcIixcclxuICBcIlhYWFggICAgXCIsXHJcbiAgXCJYWFhYICAgIFwiLFxyXG5cclxuXS5tYXAoXHJcbiAgc3RyID0+IEFycmF5XHJcbiAgICAuZnJvbShzdHIpXHJcbiAgICAucmVkdWNlKChhY2MsIGN1cikgPT4gKGFjYyA8PCAxKSB8ICgoY3VyID09PSBcIiBcIikgPyAwIDogMSksIDApXHJcbik7XHJcbiIsIi8qXHJcbiAgIEtlcm5hbCAoJGUwMDAg4oCTICRmZmZmKVxyXG5cclxuICAgVGhlIHNvdXJjZSBiZWxvdyBhc3NlbWJsZXMgaW50byBhIGJ5dGVzdHJlYW0gZnVsbHkgY29tcGF0aWJsZSB3aXRoIHRoZSBDNjQnc1xyXG4gICBLZXJuYWwgUk9NLiBJdCdzIGFkYXB0ZWQgZnJvbSBNaWNoYWVsIFN0ZWlsJ3MgYWRhcHRhdGlvbijigKAxKSBvZiBMZWUgRGF2aXNvbidzXHJcbiAgIGludmVzdGlnYXRpb24gaW50byB0aGUgb3JpZ2luYWwgZmlybXdhcmUuIEFsbCBjb21tZW50cyBiZWxvdyBhcmUgTGVlJ3MuXHJcblxyXG4gICBUaGUgbGFiZWxzIGFyZSBpbmZvcm1lZCBieSBQcm9qZWN0NjQncyBjb2xsZWN0aW9uIG9mIG1lbW9yeSBtYXBzKOKAoDIpIGFuZFxyXG4gICB0aG9zZSB1c2VkIGluIE1hcHBpbmcgVGhlIENvbW1vZG9yZSA2NCjigKAzKS4gV2hlcmUgc291cmNlcyBkaXNhZ3JlZSBvbiBuYW1lcy9cclxuICAgbG9jYXRpb25zLCBJJ3ZlIGJhc2VkIG15IGNob2ljZXMgb24gd2hpY2ggaGFkIHRoZSBtb3N0IGNvbnNlbnN1cyBhbmQgd2hpY2hcclxuICAgYmVzdCBjb3JyZXNwb25kcyB0byB0aGUgaW5zdHJ1Y3Rpb25zIG9yIGRhdGEgdG8gd2hpY2ggdGhleSByZWxhdGUuXHJcblxyXG4gICDigKAxIGh0dHBzOi8vZ2l0aHViLmNvbS9taXN0NjQvYzY0ZGlzYXNtXHJcbiAgIOKAoDIgaHR0cHM6Ly9naXRodWIuY29tL1Byb2plY3QtNjQvcmVsb2FkZWQvYmxvYi9tYXN0ZXIvYzY0LzY0TUFQMTEuVFhUXHJcbiAgIOKAoDMgaHR0cHM6Ly9naXRodWIuY29tL1Byb2plY3QtNjQvcmVsb2FkZWQvYmxvYi9tYXN0ZXIvYzY0L21hcGM2NC9NQVBDNjQxMi5UWFRcclxuXHJcbiAgIElmIHlvdSB3YW50IHRvIHN1YnN0aXR1dGUgeW91ciBvd24gUk9NLCBqdXN0IGV4cG9ydCBhIGJ5dGUgYXJyYXkgaW5zdGVhZDpcclxuICAgICAgIGV4cG9ydCBkZWZhdWx0IFsgMHguLiwgLi4uIF07XHJcblxyXG4gICBVbmxpa2UgdGhlIHJlc3Qgb2YgdGhlIFZpY2lpb3VzIHByb2plY3QsIHdoaWNoIHdhcyBhdXRob3JlZCBmcm9tIHNjcmF0Y2ggYW5kXHJcbiAgIGVudGVyZWQgaW50byB0aGUgcHVibGljIGRvbWFpbiwgdGhlIHNvdXJjZSBiZWxvdyBpcyBkZXJpdmVkIGZyb20gd29ya3MgYnlcclxuICAgbXVsdGlwbGUgb3RoZXIgYXV0aG9ycyBhbmQgSSBtYWtlIG5vIHJlcHJlc2VudGF0aW9ucyBhcyB0byBpdHMgb3duZXJzaGlwIG9yXHJcbiAgIHRlcm1zIG9mIHVzZS5cclxuKi9cclxuXHJcbmltcG9ydCB7IGFzc2VtYmxlIH0gZnJvbSBcIi4uLy4uL3Rvb2xzL2Fzc2VtYmxlclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgYXNzZW1ibGUoXHJcbiAgMHhlMDAwLFxyXG4gICh7XHJcbiAgICBOT1AsIExEQSwgTERYLCBMRFksIFNUQSwgU1RYLCBTVFksIENMQywgQ0xELCBDTEksIENMViwgU0VDLCBTRUQsIFNFSSxcclxuICAgIFRBWCwgVEFZLCBUU1gsIFRYQSwgVFhTLCBUWUEsIENNUCwgQ1BYLCBDUFksIEJDUywgQkNDLCBCRVEsIEJORSwgQk1JLFxyXG4gICAgQlBMLCBCVlMsIEJWQywgQklULCBKU1IsIFJUUywgUlRJLCBCUkssIEpNUCwgSU5DLCBERUMsIERFWCwgREVZLCBJTlgsXHJcbiAgICBJTlksIEFEQywgU0JDLCBBTkQsIEVPUiwgT1JBLCBBU0wsIFJPTCwgTFNSLCBST1IsIFBIQSwgUEhQLCBQTEEsIFBMUCxcclxuICAgIF9cclxuICB9KSA9PiB7XHJcbiAgICAgICAgICAgIC8vIEV4dGVybmFsIGxhYmVscyAoUkFNKVxyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDAwMiwgXCJfMDAwMlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwMDMsIFwiYWRyYXkxKzBfMDAwM1wiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwMDQsIFwiYWRyYXkxKzFfMDAwNFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwMDUsIFwiYWRyYXkyKzBfMDAwNVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwMDYsIFwiYWRyYXkyKzFfMDAwNlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwMDcsIFwiY2hhcmFjXzAwMDdcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDBhLCBcInZlcmNrXzAwMGFcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDEyLCBcInRhbnNnbl8wMDEyXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDAxMywgXCJjaGFubmxfMDAxM1wiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwMTQsIFwibGlubnVtKzBfMDAxNFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwMTYsIFwidGVtcHB0XzAwMTZcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDE4LCBcImxhc3RwdCsxXzAwMThcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDIyLCBcImluZGV4KzBfMDAyMlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwMjMsIFwiaW5kZXgrMV8wMDIzXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDAyYiwgXCJ0eHR0YWIrMF8wMDJiXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDAyYywgXCJ0eHR0YWIrMV8wMDJjXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDAyZCwgXCJ2YXJ0YWIrMF8wMDJkXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDAyZSwgXCJ2YXJ0YWIrMV8wMDJlXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDAzMywgXCJmcmV0b3ArMF8wMDMzXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDAzNCwgXCJmcmV0b3ArMV8wMDM0XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDAzNywgXCJtZW1zaXorMF8wMDM3XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDAzOCwgXCJtZW1zaXorMV8wMDM4XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDA0OSwgXCJmb3JwbnQrMF8wMDQ5XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDA0YSwgXCJmb3JwbnQrMV8wMDRhXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDA1MywgXCJmb3VyNl8wMDUzXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDA1NCwgXCJqbXBlciswXzAwNTRcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDU2LCBcImptcGVyKzJfMDA1NlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwNjEsIFwiZmFjZXhwXzAwNjFcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDYyLCBcImZhY2hvKzBfMDA2MlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwNjMsIFwiZmFjaG8rMV8wMDYzXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDA2NCwgXCJmYWNobysyXzAwNjRcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDY1LCBcImZhY2hvKzNfMDA2NVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwNjYsIFwiZmFjc2duXzAwNjZcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDY3LCBcInNnbmZsZ18wMDY3XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDA2OCwgXCJiaXRzXzAwNjhcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDZlLCBcImFyZ3Nnbl8wMDZlXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDA2ZiwgXCJhcmlzZ25fMDA2ZlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwNzAsIFwiZmFjb3ZfMDA3MFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwNzEsIFwiZmJ1ZnB0KzBfMDA3MVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwNzIsIFwiZmJ1ZnB0KzFfMDA3MlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwNzksIFwiY2hyZ290XzAwNzlcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDdhLCBcInR4dHB0ciswXzAwN2FcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDdiLCBcInR4dHB0cisxXzAwN2JcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDkwLCBcInN0YXR1c18wMDkwXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDA5MSwgXCJzdGtleV8wMDkxXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDA5MiwgXCJzdnh0XzAwOTJcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDkzLCBcInZlcmNrXzAwOTNcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDk0LCBcImMzcG9fMDA5NFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwOTUsIFwiYnNvdXJfMDA5NVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwOTYsIFwic3lub18wMDk2XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDA5NywgXCJ4c2F2XzAwOTdcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDk4LCBcImxkdG5kXzAwOThcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDk5LCBcImRmbHRuXzAwOTlcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDlhLCBcImRmbHRvXzAwOWFcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMDliLCBcInBydHlfMDA5YlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwOWMsIFwiZHBzd18wMDljXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDA5ZCwgXCJtc2dmbGdfMDA5ZFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwOWUsIFwicHRyMV8wMDllXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDA5ZiwgXCJwdHIyXzAwOWZcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMGEwLCBcInRpbWUrMF8wMGEwXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDBhMSwgXCJ0aW1lKzFfMDBhMVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwYTIsIFwidGltZSsyXzAwYTJcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMGEzLCBcInRzZmNudF8wMGEzXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDBhNCwgXCJ0YnRjbnRfMDBhNFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwYTUsIFwiY250ZG5fMDBhNVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwYTYsIFwiYnVmcG50XzAwYTZcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMGE3LCBcImluYml0XzAwYTdcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMGE4LCBcImJpdGNpXzAwYThcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMGE5LCBcInJpbm9uZV8wMGE5XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDBhYSwgXCJyaWRhdGFfMDBhYVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwYWIsIFwicmlwcnR5XzAwYWJcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMGFjLCBcInNhbCswXzAwYWNcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMGFkLCBcInNhbCsxXzAwYWRcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMGFlLCBcImVhbCswXzAwYWVcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMGFmLCBcImVhbCsxXzAwYWZcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMGIwLCBcImNtcDArMF8wMGIwXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDBiMSwgXCJjbXAwKzFfMDBiMVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwYjIsIFwidGFwZTErMF8wMGIyXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDBiMywgXCJ0YXBlMSsxXzAwYjNcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMGI0LCBcImJpdHRzXzAwYjRcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMGI1LCBcIm54dGJpdF8wMGI1XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDBiNiwgXCJyb2RhdGFfMDBiNlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwYjcsIFwiZm5sZW5fMDBiN1wiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwYjgsIFwibGFfMDBiOFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwYjksIFwic2FfMDBiOVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwYmEsIFwiZmFfMDBiYVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwYmIsIFwiZm5hZHIrMF8wMGJiXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDBiYywgXCJmbmFkcisxXzAwYmNcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMGJkLCBcInJvcHJ0eV8wMGJkXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDBiZSwgXCJmc2Jsa18wMGJlXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDBiZiwgXCJteWNoXzAwYmZcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMGMwLCBcImNhczFfMDBjMFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwYzEsIFwic3RhbCswXzAwYzFcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMGMyLCBcInN0YWwrMV8wMGMyXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDBjMywgXCJtZW11c3MrMF8wMGMzXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDBjNCwgXCJtZW11c3MrMV8wMGM0XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDBjNSwgXCJsc3R4XzAwYzVcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMGM2LCBcIm5keF8wMGM2XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDBjNywgXCJydnNfMDBjN1wiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwYzgsIFwiaW5keF8wMGM4XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDBjOSwgXCJseHNwKzBfMDBjOVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwY2EsIFwibHhzcCsxXzAwY2FcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMGNiLCBcInNmZHhfMDBjYlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwY2MsIFwiYmxuc3dfMDBjY1wiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwY2QsIFwiYmxuY3RfMDBjZFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwY2UsIFwiZ2RibG5fMDBjZVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwY2YsIFwiYmxub25fMDBjZlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwZDAsIFwiY3Jzd18wMGQwXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDBkMSwgXCJwbnQrMF8wMGQxXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDBkMiwgXCJwbnQrMV8wMGQyXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDBkMywgXCJwbnRyXzAwZDNcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMGQ0LCBcInF0c3dfMDBkNFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwZDUsIFwibG5teF8wMGQ1XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDBkNiwgXCJ0Ymx4XzAwZDZcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMGQ3LCBcInNjaGFyXzAwZDdcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMGQ4LCBcImluc3J0XzAwZDhcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMGQ5LCBcImxkdGIxKzBfMDBkOVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwZjEsIFwibGR0YjErMjRfMDBmMVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwZjMsIFwidXNlciswXzAwZjNcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMGY0LCBcInVzZXIrMV8wMGY0XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDBmNSwgXCJrZXl0YWIrMF8wMGY1XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDBmNiwgXCJrZXl0YWIrMV8wMGY2XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDBmNywgXCJyaWJ1ZiswXzAwZjdcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMGY4LCBcInJpYnVmKzFfMDBmOFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwZjksIFwicm9idWYrMF8wMGY5XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDBmYSwgXCJyb2J1ZisxXzAwZmFcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMTAwLCBcImJhZCswXzAxMDBcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMTAxLCBcImJhZCsxXzAxMDFcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMTA0LCBcImJhZCs0XzAxMDRcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMWZjLCBcImJzdGFjaysxODlfMDFmY1wiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAxZmQsIFwiYnN0YWNrKzE5MF8wMWZkXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDIwMCwgXCJidWYrMF8wMjAwXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDI1OSwgXCJsYXQrMF8wMjU5XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDI2MywgXCJmYXQrMF8wMjYzXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDI2ZCwgXCJzYXQrMF8wMjZkXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDI3NiwgXCJzYXQrOV8wMjc2XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDI3NywgXCJrZXlkKzBfMDI3N1wiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAyNzgsIFwia2V5ZCsxXzAyNzhcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMjgxLCBcIm1lbXN0ciswXzAyODFcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMjgyLCBcIm1lbXN0cisxXzAyODJcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMjgzLCBcIm1lbXNpeiswXzAyODNcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMjg0LCBcIm1lbXNpeisxXzAyODRcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMjg1LCBcInRpbW91dF8wMjg1XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDI4NiwgXCJjb2xvcl8wMjg2XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDI4NywgXCJnZGNvbF8wMjg3XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDI4OCwgXCJoaWJhc2VfMDI4OFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAyODksIFwieG1heF8wMjg5XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDI4YSwgXCJycHRmbGdfMDI4YVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAyOGIsIFwia291bnRfMDI4YlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAyOGMsIFwiZGVsYXlfMDI4Y1wiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAyOGQsIFwic2hmbGFnXzAyOGRcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMjhlLCBcImxzdHNoZl8wMjhlXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDI4ZiwgXCJrZXlsb2crMF8wMjhmXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDI5MCwgXCJrZXlsb2crMV8wMjkwXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDI5MSwgXCJtb2RlXzAyOTFcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMjkyLCBcImF1dG9kbl8wMjkyXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDI5MywgXCJtNTFjdHJfMDI5M1wiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAyOTQsIFwibTUxY2RyXzAyOTRcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMjk1LCBcIm01MWFqYiswXzAyOTVcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMjk2LCBcIm01MWFqYisxXzAyOTZcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMjk3LCBcInJzc3RhdF8wMjk3XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDI5OCwgXCJiaXRudW1fMDI5OFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAyOTksIFwiYmF1ZG9mKzBfMDI5OVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAyOWEsIFwiYmF1ZG9mKzFfMDI5YVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAyOWIsIFwicmlkYmVfMDI5YlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAyOWMsIFwicmlkYnNfMDI5Y1wiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAyOWQsIFwicm9kYnNfMDI5ZFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAyOWUsIFwicm9kYmVfMDI5ZVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAyOWYsIFwiaXJxdG1wKzBfMDI5ZlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAyYTAsIFwiaXJxdG1wKzFfMDJhMFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAyYTEsIFwiZW5hYmxfMDJhMVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAyYTIsIFwidG9kc25zXzAyYTJcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMmEzLCBcInRyZHRtcF8wMmEzXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDJhNCwgXCJ0ZDFpcnFfMDJhNFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAyYTUsIFwidGxuaWR4XzAyYTVcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMmE2LCBcInR2c2ZsZ18wMmE2XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDMwMCwgXCJpZXJyb3IrMF8wMzAwXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDMwYywgXCJzYXJlZ18wMzBjXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDMwZCwgXCJzeHJlZ18wMzBkXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDMwZSwgXCJzeXJlZ18wMzBlXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDMwZiwgXCJzcHJlZ18wMzBmXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDMxMCwgXCJ1c3Jwb2tfMDMxMFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAzMTEsIFwidXNyYWRkKzBfMDMxMVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAzMTIsIFwidXNyYWRkKzFfMDMxMlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAzMTQsIFwiY2ludiswXzAzMTRcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMzE1LCBcImNpbnYrMV8wMzE1XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDMxNiwgXCJjYmludiswXzAzMTZcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMzE4LCBcIm5taW52KzBfMDMxOFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAzMWEsIFwiaW9wZW4rMF8wMzFhXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDMxYywgXCJpY2xvc2UrMF8wMzFjXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDMxZSwgXCJpY2hraW4rMF8wMzFlXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDMyMCwgXCJpY2tvdXQrMF8wMzIwXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDMyMiwgXCJpY2xyY2grMF8wMzIyXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDMyNCwgXCJpYmFzaW4rMF8wMzI0XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDMyNiwgXCJpYnNvdXQrMF8wMzI2XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4MDMyOCwgXCJpc3RvcCswXzAzMjhcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMzJhLCBcImlnZXRpbiswXzAzMmFcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMzJjLCBcImljbGFsbCswXzAzMmNcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHgwMzMwLCBcImlsb2FkKzBfMDMzMFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAzMzIsIFwiaXNhdmUrMF8wMzMyXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4ODAwMCwgXCJfODAwMFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDgwMDIsIFwiXzgwMDJcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHg4MDAzLCBcIl84MDAzXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4Y2ZmZiwgXCJfY2ZmZlwiKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEV4dGVybmFsIGxhYmVscyAoTWVtb3J5LW1hcHBlZCBJTylcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwMDAsIFwiZDY1MTBfMDAwMFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweDAwMDEsIFwicjY1MTBfMDAwMVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweGQwMTEsIFwic2Nyb2x5X2QwMTFcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHhkMDEyLCBcInJhc3Rlcl9kMDEyXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4ZDAxNiwgXCJzY3JvbHhfZDAxNlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweGQwMTgsIFwidm1jc2JfZDAxOFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweGQwMTksIFwidmljaXJxX2QwMTlcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHhkNDE4LCBcInNpZ3ZvbF9kNDE4XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4ZGMwMCwgXCJjaWFwcmFfZGMwMFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweGRjMDEsIFwiY2lhcHJiX2RjMDFcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHhkYzAyLCBcImNpZGRyYV9kYzAyXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4ZGMwMywgXCJjaWRkcmJfZGMwM1wiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweGRjMDQsIFwidGltYWxvX2RjMDRcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHhkYzA1LCBcInRpbWFoaV9kYzA1XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4ZGMwNiwgXCJ0aW1ibG9fZGMwNlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweGRjMDcsIFwidGltYmhpX2RjMDdcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHhkYzBkLCBcImNpYWljcl9kYzBkXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4ZGMwZSwgXCJjaWFjcmFfZGMwZVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweGRjMGYsIFwiY2lhY3JiX2RjMGZcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHhkZDAwLCBcImNpMnByYV9kZDAwXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4ZGQwMSwgXCJjaTJwcmJfZGQwMVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweGRkMDIsIFwiYzJkZHJhX2RkMDJcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHhkZDAzLCBcImMyZGRyYl9kZDAzXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4ZGQwNCwgXCJ0aTJhbG9fZGQwNFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweGRkMDUsIFwidGkyYWhpX2RkMDVcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHhkZDA2LCBcInRpMmJsb19kZDA2XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4ZGQwNywgXCJ0aTJiaGlfZGQwN1wiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweGRkMGQsIFwiY2kyaWNyX2RkMGRcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHhkZDBlLCBcImNpMmNyYV9kZDBlXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4ZGQwZiwgXCJjaTJjcmJfZGQwZlwiKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEV4dGVybmFsIGxhYmVscyAoQmFzaWMgUk9NKVxyXG4gICAgICAgICAgICBfLmxhYmVsKDB4YTAwMCwgXCJyZXN0YXJ0X2EwMDBcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHhhMDAyLCBcIl9hMDAyXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4YTQwOCwgXCJyZWFzb25fYTQwOFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweGE0MzcsIFwiZXJyb3JfYTQzN1wiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweGE0M2EsIFwiX2E0M2FcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHhhNDc0LCBcInJlYWR5X2E0NzRcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHhhNTJhLCBcIl9hNTJhXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4YTUzMywgXCJsaW5rcHJnX2E1MzNcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHhhNjQ0LCBcIl9hNjQ0XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4YTY2MywgXCJfYTY2M1wiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweGE2NzcsIFwiX2E2NzdcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHhhNjdhLCBcIl9hNjdhXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4YTY4ZSwgXCJzdHhwdF9hNjhlXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4YWIxZSwgXCJzdHJvdXRfYWIxZVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweGFkOGEsIFwiZnJtbnVtX2FkOGFcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHhhZDllLCBcImZybWV2bF9hZDllXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4YWVmZCwgXCJfYWVmZFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweGFmMDgsIFwic3luZXJyX2FmMDhcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHhiNmEzLCBcImZyZXN0cl9iNmEzXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4Yjc5ZSwgXCJfYjc5ZVwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweGI3ZjcsIFwiZ2V0YWRyX2I3ZjdcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHhiODQ5LCBcImZhZGRoX2I4NDlcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHhiODUwLCBcImZzdWJfYjg1MFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweGI4NTMsIFwiZnN1YnRfYjg1M1wiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweGI4NjcsIFwiZmFkZF9iODY3XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4YjhkNywgXCJfYjhkN1wiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweGJhMjgsIFwiZm11bHRfYmEyOFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweGJhYjksIFwiX2JhYjlcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHhiYWQ0LCBcIm1sZHZleF9iYWQ0XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4YmIwNywgXCJmZGl2Zl9iYjA3XCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4YmIwZiwgXCJmZGl2X2JiMGZcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHhiYmEyLCBcIm1vdmZtX2JiYTJcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHhiYmM3LCBcIm1vdjJmX2JiYzdcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHhiYmNhLCBcIl9iYmNhXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4YmJkNCwgXCJfYmJkNFwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweGJjMGMsIFwibW92YWZfYmMwY1wiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweGJjMGYsIFwibW92ZWZfYmMwZlwiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweGJjMmIsIFwic2lnbl9iYzJiXCIpO1xyXG4gICAgICAgICAgICBfLmxhYmVsKDB4YmNjYywgXCJpbnRfYmNjY1wiKTtcclxuICAgICAgICAgICAgXy5sYWJlbCgweGJkY2QsIFwibGlucHJ0X2JkY2RcIik7XHJcbiAgICAgICAgICAgIF8ubGFiZWwoMHhiZmI0LCBcIm5lZ29wX2JmYjRcIik7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHN0YXJ0IG9mIHRoZSBrZXJuYWwgUk9NXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRVhQKCkgY29udGludWVkXHJcbi8qIGUwMDAgKi8gICAgX2AoZXhwX2UwMDBgOyAgU1RBLnpwZyAoXCJqbXBlcisyXzAwNTZcIik7ICAgICAvLyBzYXZlIEZBQzIgcm91bmRpbmcgYnl0ZVxyXG4vKiBlMDAyICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwibW92ZWZfYmMwZlwiKTsgICAgICAgLy8gY29weSBGQUMxIHRvIEZBQzJcclxuLyogZTAwNSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZhY2V4cF8wMDYxXCIpOyAgICAgIC8vIGdldCBGQUMxIGV4cG9uZW50XHJcbi8qIGUwMDcgKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHg4OCk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIEVYUCBsaW1pdCAoMjU2ZClcclxuLyogZTAwOSAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9lMDBlXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBsZXNzXHJcbi8qIGUwMGIgKi8gICAgICAgIF9gX2UwMGJgOyAgSlNSLmFicyAoXCJtbGR2ZXhfYmFkNFwiKTsgICAgICAvLyBoYW5kbGUgb3ZlcmZsb3cgYW5kIHVuZGVyZmxvd1xyXG4vKiBlMDBlICovICAgICAgICBfYF9lMDBlYDsgIEpTUi5hYnMgKFwiaW50X2JjY2NcIik7ICAgICAgICAgLy8gcGVyZm9ybSBJTlQoKVxyXG4vKiBlMDExICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiY2hhcmFjXzAwMDdcIik7ICAgICAgLy8gZ2V0IG1hbnRpc3NhIDQgZnJvbSBJTlQoKVxyXG4vKiBlMDEzICovICAgICAgICAgICAgICAgICAgIENMQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIGNhcnJ5IGZvciBhZGRcclxuLyogZTAxNCAqLyAgICAgICAgICAgICAgICAgICBBREMuaW1tICgweDgxKTsgICAgICAgICAgICAgICAvLyBub3JtYWxpc2UgKzFcclxuLyogZTAxNiAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9lMDBiXCIpOyAgICAgICAgICAgIC8vIGlmICQwMCByZXN1bHQgaGFzIG92ZXJmbG93ZWQgc28gZ28gaGFuZGxlIGl0XHJcbi8qIGUwMTggKi8gICAgICAgICAgICAgICAgICAgU0VDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2V0IGNhcnJ5IGZvciBzdWJ0cmFjdFxyXG4vKiBlMDE5ICovICAgICAgICAgICAgICAgICAgIFNCQy5pbW0gKDB4MDEpOyAgICAgICAgICAgICAgIC8vIGV4cG9uZW50IG5vdyBjb3JyZWN0XHJcbi8qIGUwMWIgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBGQUMyIGV4cG9uZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3dhcCBGQUMxIGFuZCBGQUMyXHJcbi8qIGUwMWMgKi8gICAgICAgICAgICAgICAgICAgTERYLmltbSAoMHgwNSk7ICAgICAgICAgICAgICAgLy8gNCBieXRlcyB0byBkb1xyXG4vKiBlMDFlICovICAgICAgICBfYF9lMDFlYDsgIExEQS56cHggKDB4NjkpOyAgICAgICAgICAgICAgIC8vIGdldCBGQUMyLFhcclxuLyogZTAyMCAqLyAgICAgICAgICAgICAgICAgICBMRFkuenB4ICgweDYxKTsgICAgICAgICAgICAgICAvLyBnZXQgRkFDMSxYXHJcbi8qIGUwMjIgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpweCAoMHg2MSk7ICAgICAgICAgICAgICAgLy8gc2F2ZSBGQUMxLFhcclxuLyogZTAyNCAqLyAgICAgICAgICAgICAgICAgICBTVFkuenB4ICgweDY5KTsgICAgICAgICAgICAgICAvLyBzYXZlIEZBQzIsWFxyXG4vKiBlMDI2ICovICAgICAgICAgICAgICAgICAgIERFWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCBjb3VudC9pbmRleFxyXG4vKiBlMDI3ICovICAgICAgICAgICAgICAgICAgIEJQTC5yZWwgKFwiX2UwMWVcIik7ICAgICAgICAgICAgLy8gbG9vcCBpZiBub3QgYWxsIGRvbmVcclxuLyogZTAyOSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImptcGVyKzJfMDA1NlwiKTsgICAgIC8vIGdldCBGQUMyIHJvdW5kaW5nIGJ5dGVcclxuLyogZTAyYiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZhY292XzAwNzBcIik7ICAgICAgIC8vIHNhdmUgYXMgRkFDMSByb3VuZGluZyBieXRlXHJcbi8qIGUwMmQgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJmc3VidF9iODUzXCIpOyAgICAgICAvLyBwZXJmb3JtIHN1YnRyYWN0aW9uLCBGQUMyIGZyb20gRkFDMVxyXG4vKiBlMDMwICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwibmVnb3BfYmZiNFwiKTsgICAgICAgLy8gZG8gLSBGQUMxXHJcbi8qIGUwMzMgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHhjNCk7ICAgICAgICAgICAgICAgLy8gc2V0IGNvdW50ZXIgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBlMDM1ICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4YmYpOyAgICAgICAgICAgICAgIC8vIHNldCBjb3VudGVyIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGUwMzcgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJwb2x5Ml9lMDU5XCIpOyAgICAgICAvLyBnbyBkbyBzZXJpZXMgZXZhbHVhdGlvblxyXG4vKiBlMDNhICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIEFcclxuLyogZTAzYyAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImFyaXNnbl8wMDZmXCIpOyAgICAgIC8vIGNsZWFyIHNpZ24gY29tcGFyZSAoRkFDMSBFT1IgRkFDMilcclxuLyogZTAzZSAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBnZXQgc2F2ZWQgRkFDMiBleHBvbmVudFxyXG4vKiBlMDNmICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2JhYjlcIik7ICAgICAgICAgICAgLy8gdGVzdCBhbmQgYWRqdXN0IGFjY3VtdWxhdG9yc1xyXG4vKiBlMDQyICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gXjIgdGhlbiBzZXJpZXMgZXZhbHVhdGlvblxyXG4vKiBlMDQzICovICAgX2Bwb2x5eF9lMDQzYDsgIFNUQS56cGcgKFwiZmJ1ZnB0KzBfMDA3MVwiKTsgICAgLy8gc2F2ZSBjb3VudCBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGUwNDUgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJmYnVmcHQrMV8wMDcyXCIpOyAgICAvLyBzYXZlIGNvdW50IHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGUwNDcgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfYmJjYVwiKTsgICAgICAgICAgICAvLyBwYWNrIEZBQzEgaW50byAkNTdcclxuLyogZTA0YSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDU3KTsgICAgICAgICAgICAgICAvLyBzZXQgcG9pbnRlciBsb3cgYnl0ZSAoWSBhbHJlYWR5ICQwMClcclxuLyogZTA0YyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImZtdWx0X2JhMjhcIik7ICAgICAgIC8vIGRvIGNvbnZlcnQgQVksIEZDQTEqKEFZKVxyXG4vKiBlMDRmICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2UwNWRcIik7ICAgICAgICAgICAgLy8gZ28gZG8gc2VyaWVzIGV2YWx1YXRpb25cclxuLyogZTA1MiAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDU3KTsgICAgICAgICAgICAgICAvLyBwb2ludGVyIHRvIG9yaWdpbmFsICMgbG93IGJ5dGVcclxuLyogZTA1NCAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBwb2ludGVyIHRvIG9yaWdpbmFsICMgaGlnaCBieXRlXHJcbi8qIGUwNTYgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJmbXVsdF9iYTI4XCIpOyAgICAgICAvLyBkbyBjb252ZXJ0IEFZLCBGQ0ExKihBWSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyBzZXJpZXMgZXZhbHVhdGlvblxyXG4vKiBlMDU5ICovICAgX2Bwb2x5Ml9lMDU5YDsgIFNUQS56cGcgKFwiZmJ1ZnB0KzBfMDA3MVwiKTsgICAgLy8gc2F2ZSBjb3VudCBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGUwNWIgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJmYnVmcHQrMV8wMDcyXCIpOyAgICAvLyBzYXZlIGNvdW50IHBvaW50ZXIgaGlnaCBieXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gc2VyaWVzIGV2YWx1YXRpb25cclxuLyogZTA1ZCAqLyAgICAgICAgX2BfZTA1ZGA7ICBKU1IuYWJzIChcIm1vdjJmX2JiYzdcIik7ICAgICAgIC8vIHBhY2sgRkFDMSBpbnRvICQ1Q1xyXG4vKiBlMDYwICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwiZmJ1ZnB0KzBfMDA3MVwiKTsgICAgLy8gZ2V0IGNvbnN0YW50cyBjb3VudFxyXG4vKiBlMDYyICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwic2duZmxnXzAwNjdcIik7ICAgICAgLy8gc2F2ZSBjb25zdGFudHMgY291bnRcclxuLyogZTA2NCAqLyAgICAgICAgICAgICAgICAgICBMRFkuenBnIChcImZidWZwdCswXzAwNzFcIik7ICAgIC8vIGdldCBjb3VudCBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGUwNjYgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGl0IChub3cgY29uc3RhbnRzIHBvaW50ZXIpXHJcbi8qIGUwNjcgKi8gICAgICAgICAgICAgICAgICAgVFlBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBpdFxyXG4vKiBlMDY4ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2UwNmNcIik7ICAgICAgICAgICAgLy8gc2tpcCBuZXh0IGlmIG5vIG92ZXJmbG93XHJcbi8qIGUwNmEgKi8gICAgICAgICAgICAgICAgICAgSU5DLnpwZyAoXCJmYnVmcHQrMV8wMDcyXCIpOyAgICAvLyBlbHNlIGluY3JlbWVudCBoaWdoIGJ5dGVcclxuLyogZTA2YyAqLyAgICAgICAgX2BfZTA2Y2A7ICBTVEEuenBnIChcImZidWZwdCswXzAwNzFcIik7ICAgIC8vIHNhdmUgbG93IGJ5dGVcclxuLyogZTA2ZSAqLyAgICAgICAgICAgICAgICAgICBMRFkuenBnIChcImZidWZwdCsxXzAwNzJcIik7ICAgIC8vIGdldCBoaWdoIGJ5dGVcclxuLyogZTA3MCAqLyAgICAgICAgX2BfZTA3MGA7ICBKU1IuYWJzIChcImZtdWx0X2JhMjhcIik7ICAgICAgIC8vIGRvIGNvbnZlcnQgQVksIEZDQTEqKEFZKVxyXG4vKiBlMDczICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZmJ1ZnB0KzBfMDA3MVwiKTsgICAgLy8gZ2V0IGNvbnN0YW50cyBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGUwNzUgKi8gICAgICAgICAgICAgICAgICAgTERZLnpwZyAoXCJmYnVmcHQrMV8wMDcyXCIpOyAgICAvLyBnZXQgY29uc3RhbnRzIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGUwNzcgKi8gICAgICAgICAgICAgICAgICAgQ0xDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgY2FycnkgZm9yIGFkZFxyXG4vKiBlMDc4ICovICAgICAgICAgICAgICAgICAgIEFEQy5pbW0gKDB4MDUpOyAgICAgICAgICAgICAgIC8vICs1IHRvIGxvdyBwb2ludGVyICg1IGJ5dGVzIHBlciBjb25zdGFudClcclxuLyogZTA3YSAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9lMDdkXCIpOyAgICAgICAgICAgIC8vIHNraXAgbmV4dCBpZiBubyBvdmVyZmxvd1xyXG4vKiBlMDdjICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBoaWdoIGJ5dGVcclxuLyogZTA3ZCAqLyAgICAgICAgX2BfZTA3ZGA7ICBTVEEuenBnIChcImZidWZwdCswXzAwNzFcIik7ICAgIC8vIHNhdmUgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBlMDdmICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwiZmJ1ZnB0KzFfMDA3MlwiKTsgICAgLy8gc2F2ZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBlMDgxICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiZmFkZF9iODY3XCIpOyAgICAgICAgLy8gYWRkIChBWSkgdG8gRkFDMVxyXG4vKiBlMDg0ICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4NWMpOyAgICAgICAgICAgICAgIC8vIHNldCBwb2ludGVyIGxvdyBieXRlIHRvIHBhcnRpYWxcclxuLyogZTA4NiAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBzZXQgcG9pbnRlciBoaWdoIGJ5dGUgdG8gcGFydGlhbFxyXG4vKiBlMDg4ICovICAgICAgICAgICAgICAgICAgIERFQy56cGcgKFwic2duZmxnXzAwNjdcIik7ICAgICAgLy8gZGVjcmVtZW50IGNvbnN0YW50cyBjb3VudFxyXG4vKiBlMDhhICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2UwNzBcIik7ICAgICAgICAgICAgLy8gbG9vcCB1bnRpbCBhbGwgZG9uZVxyXG4vKiBlMDhjICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIFJORCB2YWx1ZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxMTg3OTU0NiAgICAgICAgICAgIG11bHRpcGxpZXJcclxuLyogZTA4ZCAqLyAgIF9gcm11bGNfZTA4ZGA7ICBfLmJ5dGVzKDB4OTgsIDB4MzUsIDB4NDQsIDB4N2EsIDB4MDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDMuOTI3Njc3NzM5RS04ICAgICAgb2Zmc2V0XHJcbi8qIGUwOTIgKi8gICBfYHJhZGRjX2UwOTJgOyAgXy5ieXRlcygweDY4LCAweDI4LCAweGIxLCAweDQ2LCAweDAwKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcGVyZm9ybSBSTkQoKVxyXG4vKiBlMDk3ICovICAgICBfYHJuZF9lMDk3YDsgIEpTUi5hYnMgKFwic2lnbl9iYzJiXCIpOyAgICAgICAgLy8gZ2V0IEZBQzEgc2lnblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBBID0gJEZGIC12ZSwgQSA9ICQwMSArdmVcclxuLyogZTA5YSAqLyAgICAgICAgICAgICAgICAgICBCTUkucmVsIChcIl9lMGQzXCIpOyAgICAgICAgICAgIC8vIGlmIG48MCBjb3B5IGJ5dGUgc3dhcHBlZCBGQUMxIGludG8gUk5EKCkgc2VlZFxyXG4vKiBlMDljICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2UwYmVcIik7ICAgICAgICAgICAgLy8gaWYgbj4wIGdldCBuZXh0IG51bWJlciBpbiBSTkQoKSBzZXF1ZW5jZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2Ugbj0wIHNvIGdldCB0aGUgUk5EKCkgbnVtYmVyIGZyb20gVklBIDEgdGltZXJzXHJcbi8qIGUwOWUgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJpb2Jhc2VfZmZmM1wiKTsgICAgICAvLyByZXR1cm4gYmFzZSBhZGRyZXNzIG9mIEkvTyBkZXZpY2VzXHJcbi8qIGUwYTEgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJpbmRleCswXzAwMjJcIik7ICAgICAvLyBzYXZlIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogZTBhMyAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcImluZGV4KzFfMDAyM1wiKTsgICAgIC8vIHNhdmUgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogZTBhNSAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDA0KTsgICAgICAgICAgICAgICAvLyBzZXQgaW5kZXggdG8gVDEgbG93IGJ5dGVcclxuLyogZTBhNyAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcImluZGV4KzBfMDAyMlwiKTsgICAgIC8vIGdldCBUMSBsb3cgYnl0ZVxyXG4vKiBlMGE5ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZmFjaG8rMF8wMDYyXCIpOyAgICAgLy8gc2F2ZSBGQUMxIG1hbnRpc3NhIDFcclxuLyogZTBhYiAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgaW5kZXhcclxuLyogZTBhYyAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcImluZGV4KzBfMDAyMlwiKTsgICAgIC8vIGdldCBUMSBoaWdoIGJ5dGVcclxuLyogZTBhZSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZhY2hvKzJfMDA2NFwiKTsgICAgIC8vIHNhdmUgRkFDMSBtYW50aXNzYSAzXHJcbi8qIGUwYjAgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgwOCk7ICAgICAgICAgICAgICAgLy8gc2V0IGluZGV4IHRvIFQyIGxvdyBieXRlXHJcbi8qIGUwYjIgKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJpbmRleCswXzAwMjJcIik7ICAgICAvLyBnZXQgVDIgbG93IGJ5dGVcclxuLyogZTBiNCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZhY2hvKzFfMDA2M1wiKTsgICAgIC8vIHNhdmUgRkFDMSBtYW50aXNzYSAyXHJcbi8qIGUwYjYgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGluZGV4XHJcbi8qIGUwYjcgKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJpbmRleCswXzAwMjJcIik7ICAgICAvLyBnZXQgVDIgaGlnaCBieXRlXHJcbi8qIGUwYjkgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmYWNobyszXzAwNjVcIik7ICAgICAvLyBzYXZlIEZBQzEgbWFudGlzc2EgNFxyXG4vKiBlMGJiICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2UwZTNcIik7ICAgICAgICAgICAgLy8gc2V0IGV4cG9uZW50IGFuZCBleGl0XHJcbi8qIGUwYmUgKi8gICAgICAgIF9gX2UwYmVgOyAgTERBLmltbSAoMHg4Yik7ICAgICAgICAgICAgICAgLy8gc2V0IHNlZWQgcG9pbnRlciBsb3cgYWRkcmVzc1xyXG4vKiBlMGMwICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIHNldCBzZWVkIHBvaW50ZXIgaGlnaCBhZGRyZXNzXHJcbi8qIGUwYzIgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJtb3ZmbV9iYmEyXCIpOyAgICAgICAvLyB1bnBhY2sgbWVtb3J5IChBWSkgaW50byBGQUMxXHJcbi8qIGUwYzUgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHg4ZCk7ICAgICAgICAgICAgICAgLy8gc2V0IDExODc5NTQ2IHBvaW50ZXIgbG93IGJ5dGVcclxuLyogZTBjNyAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweGUwKTsgICAgICAgICAgICAgICAvLyBzZXQgMTE4Nzk1NDYgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogZTBjOSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImZtdWx0X2JhMjhcIik7ICAgICAgIC8vIGRvIGNvbnZlcnQgQVksIEZDQTEqKEFZKVxyXG4vKiBlMGNjICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4OTIpOyAgICAgICAgICAgICAgIC8vIHNldCAzLjkyNzY3NzczOUUtOCBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGUwY2UgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHhlMCk7ICAgICAgICAgICAgICAgLy8gc2V0IDMuOTI3Njc3NzM5RS04IHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGUwZDAgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJmYWRkX2I4NjdcIik7ICAgICAgICAvLyBhZGQgKEFZKSB0byBGQUMxXHJcbi8qIGUwZDMgKi8gICAgICAgIF9gX2UwZDNgOyAgTERYLnpwZyAoXCJmYWNobyszXzAwNjVcIik7ICAgICAvLyBnZXQgRkFDMSBtYW50aXNzYSA0XHJcbi8qIGUwZDUgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJmYWNobyswXzAwNjJcIik7ICAgICAvLyBnZXQgRkFDMSBtYW50aXNzYSAxXHJcbi8qIGUwZDcgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmYWNobyszXzAwNjVcIik7ICAgICAvLyBzYXZlIEZBQzEgbWFudGlzc2EgNFxyXG4vKiBlMGQ5ICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwiZmFjaG8rMF8wMDYyXCIpOyAgICAgLy8gc2F2ZSBGQUMxIG1hbnRpc3NhIDFcclxuLyogZTBkYiAqLyAgICAgICAgICAgICAgICAgICBMRFguenBnIChcImZhY2hvKzFfMDA2M1wiKTsgICAgIC8vIGdldCBGQUMxIG1hbnRpc3NhIDJcclxuLyogZTBkZCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZhY2hvKzJfMDA2NFwiKTsgICAgIC8vIGdldCBGQUMxIG1hbnRpc3NhIDNcclxuLyogZTBkZiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZhY2hvKzFfMDA2M1wiKTsgICAgIC8vIHNhdmUgRkFDMSBtYW50aXNzYSAyXHJcbi8qIGUwZTEgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJmYWNobysyXzAwNjRcIik7ICAgICAvLyBzYXZlIEZBQzEgbWFudGlzc2EgM1xyXG4vKiBlMGUzICovICAgICAgICBfYF9lMGUzYDsgIExEQS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIGJ5dGVcclxuLyogZTBlNSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZhY3Nnbl8wMDY2XCIpOyAgICAgIC8vIGNsZWFyIEZBQzEgc2lnbiAoYWx3YXlzICt2ZSlcclxuLyogZTBlNyAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZhY2V4cF8wMDYxXCIpOyAgICAgIC8vIGdldCBGQUMxIGV4cG9uZW50XHJcbi8qIGUwZTkgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmYWNvdl8wMDcwXCIpOyAgICAgICAvLyBzYXZlIEZBQzEgcm91bmRpbmcgYnl0ZVxyXG4vKiBlMGViICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4ODApOyAgICAgICAgICAgICAgIC8vIHNldCBleHBvbmVudCA9ICQ4MFxyXG4vKiBlMGVkICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZmFjZXhwXzAwNjFcIik7ICAgICAgLy8gc2F2ZSBGQUMxIGV4cG9uZW50XHJcbi8qIGUwZWYgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfYjhkN1wiKTsgICAgICAgICAgICAvLyBub3JtYWxpc2UgRkFDMVxyXG4vKiBlMGYyICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4OGIpOyAgICAgICAgICAgICAgIC8vIHNldCBzZWVkIHBvaW50ZXIgbG93IGFkZHJlc3NcclxuLyogZTBmNCAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBzZXQgc2VlZCBwb2ludGVyIGhpZ2ggYWRkcmVzc1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBwYWNrIEZBQzEgaW50byAoWFkpXHJcbi8qIGUwZjYgKi8gICAgICAgIF9gX2UwZjZgOyAgSk1QLmFicyAoXCJfYmJkNFwiKTsgICAgICAgICAgICAvLyBwYWNrIEZBQzEgaW50byAoWFkpXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGhhbmRsZSBCQVNJQyBJL08gZXJyb3JcclxuLyogZTBmOSAqLyAgX2BiaW9lcnJfZTBmOWA7ICBDTVAuaW1tICgweGYwKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIGVycm9yIHdpdGggJEYwXHJcbi8qIGUwZmIgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZTEwNFwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbm90ICRGMFxyXG4vKiBlMGZkICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwibWVtc2l6KzFfMDAzOFwiKTsgICAgLy8gc2V0IGVuZCBvZiBtZW1vcnkgaGlnaCBieXRlXHJcbi8qIGUwZmYgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJtZW1zaXorMF8wMDM3XCIpOyAgICAvLyBzZXQgZW5kIG9mIG1lbW9yeSBsb3cgYnl0ZVxyXG4vKiBlMTAxICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2E2NjNcIik7ICAgICAgICAgICAgLy8gY2xlYXIgZnJvbSBzdGFydCB0byBlbmQgYW5kIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVycm9yIHdhcyBub3QgJEYwXHJcbi8qIGUxMDQgKi8gICAgICAgIF9gX2UxMDRgOyAgVEFYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBlcnJvciAjXHJcbi8qIGUxMDUgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZTEwOVwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbm90ICQwMFxyXG4vKiBlMTA3ICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4MWUpOyAgICAgICAgICAgICAgIC8vIGVsc2UgZXJyb3IgJDFFLCBicmVhayBlcnJvclxyXG4vKiBlMTA5ICovICAgICAgICBfYF9lMTA5YDsgIEpNUC5hYnMgKFwiZXJyb3JfYTQzN1wiKTsgICAgICAgLy8gZG8gZXJyb3IgI1ggdGhlbiB3YXJtIHN0YXJ0XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIG91dHB1dCBjaGFyYWN0ZXIgdG8gY2hhbm5lbCB3aXRoIGVycm9yIGNoZWNrXHJcbi8qIGUxMGMgKi8gIF9gYmNob3V0X2UxMGNgOyAgSlNSLmFicyAoXCJjaHJvdXRfZmZkMlwiKTsgICAgICAvLyBvdXRwdXQgY2hhcmFjdGVyIHRvIGNoYW5uZWxcclxuLyogZTEwZiAqLyAgICAgICAgICAgICAgICAgICBCQ1MucmVsIChcImJpb2Vycl9lMGY5XCIpOyAgICAgIC8vIGlmIGVycm9yIGdvIGhhbmRsZSBCQVNJQyBJL08gZXJyb3JcclxuLyogZTExMSAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBpbnB1dCBjaGFyYWN0ZXIgZnJvbSBjaGFubmVsIHdpdGggZXJyb3IgY2hlY2tcclxuLyogZTExMiAqLyAgIF9gYmNoaW5fZTExMmA7ICBKU1IuYWJzIChcImNocmluX2ZmY2ZcIik7ICAgICAgIC8vIGlucHV0IGNoYXJhY3RlciBmcm9tIGNoYW5uZWxcclxuLyogZTExNSAqLyAgICAgICAgICAgICAgICAgICBCQ1MucmVsIChcImJpb2Vycl9lMGY5XCIpOyAgICAgIC8vIGlmIGVycm9yIGdvIGhhbmRsZSBCQVNJQyBJL08gZXJyb3JcclxuLyogZTExNyAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBvcGVuIGNoYW5uZWwgZm9yIG91dHB1dCB3aXRoIGVycm9yIGNoZWNrXHJcbi8qIGUxMTggKi8gIF9gYmNrb3V0X2UxMThgOyAgSlNSLmFicyAoXCJfZTRhZFwiKTsgICAgICAgICAgICAvLyBvcGVuIGNoYW5uZWwgZm9yIG91dHB1dFxyXG4vKiBlMTFiICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiYmlvZXJyX2UwZjlcIik7ICAgICAgLy8gaWYgZXJyb3IgZ28gaGFuZGxlIEJBU0lDIEkvTyBlcnJvclxyXG4vKiBlMTFkICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIG9wZW4gY2hhbm5lbCBmb3IgaW5wdXQgd2l0aCBlcnJvciBjaGVja1xyXG4vKiBlMTFlICovICAgX2BiY2tpbl9lMTFlYDsgIEpTUi5hYnMgKFwiY2hraW5fZmZjNlwiKTsgICAgICAgLy8gb3BlbiBjaGFubmVsIGZvciBpbnB1dFxyXG4vKiBlMTIxICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiYmlvZXJyX2UwZjlcIik7ICAgICAgLy8gaWYgZXJyb3IgZ28gaGFuZGxlIEJBU0lDIEkvTyBlcnJvclxyXG4vKiBlMTIzICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGdldCBjaGFyYWN0ZXIgZnJvbSBpbnB1dCBkZXZpY2Ugd2l0aCBlcnJvciBjaGVja1xyXG4vKiBlMTI0ICovICBfYGJnZXRpbl9lMTI0YDsgIEpTUi5hYnMgKFwiZ2V0aW5fZmZlNFwiKTsgICAgICAgLy8gZ2V0IGNoYXJhY3RlciBmcm9tIGlucHV0IGRldmljZVxyXG4vKiBlMTI3ICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiYmlvZXJyX2UwZjlcIik7ICAgICAgLy8gaWYgZXJyb3IgZ28gaGFuZGxlIEJBU0lDIEkvTyBlcnJvclxyXG4vKiBlMTI5ICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHBlcmZvcm0gU1lTXHJcbi8qIGUxMmEgKi8gICAgIF9gc3lzX2UxMmFgOyAgSlNSLmFicyAoXCJmcm1udW1fYWQ4YVwiKTsgICAgICAvLyBldmFsdWF0ZSBleHByZXNzaW9uIGFuZCBjaGVjayBpcyBudW1lcmljLCBlbHNlIGRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHlwZSBtaXNtYXRjaFxyXG4vKiBlMTJkICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiZ2V0YWRyX2I3ZjdcIik7ICAgICAgLy8gY29udmVydCBGQUNfMSB0byBpbnRlZ2VyIGluIHRlbXBvcmFyeSBpbnRlZ2VyXHJcbi8qIGUxMzAgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHhlMSk7ICAgICAgICAgICAgICAgLy8gZ2V0IHJldHVybiBhZGRyZXNzIGhpZ2ggYnl0ZVxyXG4vKiBlMTMyICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggYXMgcmV0dXJuIGFkZHJlc3NcclxuLyogZTEzMyAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDQ2KTsgICAgICAgICAgICAgICAvLyBnZXQgcmV0dXJuIGFkZHJlc3MgbG93IGJ5dGVcclxuLyogZTEzNSAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdXNoIGFzIHJldHVybiBhZGRyZXNzXHJcbi8qIGUxMzYgKi8gICAgICAgICAgICAgICAgICAgTERBLmFicyAoXCJzcHJlZ18wMzBmXCIpOyAgICAgICAvLyBnZXQgc2F2ZWQgc3RhdHVzIHJlZ2lzdGVyXHJcbi8qIGUxMzkgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHV0IG9uIHN0YWNrXHJcbi8qIGUxM2EgKi8gICAgICAgICAgICAgICAgICAgTERBLmFicyAoXCJzYXJlZ18wMzBjXCIpOyAgICAgICAvLyBnZXQgc2F2ZWQgQVxyXG4vKiBlMTNkICovICAgICAgICAgICAgICAgICAgIExEWC5hYnMgKFwic3hyZWdfMDMwZFwiKTsgICAgICAgLy8gZ2V0IHNhdmVkIFhcclxuLyogZTE0MCAqLyAgICAgICAgICAgICAgICAgICBMRFkuYWJzIChcInN5cmVnXzAzMGVcIik7ICAgICAgIC8vIGdldCBzYXZlZCBZXHJcbi8qIGUxNDMgKi8gICAgICAgICAgICAgICAgICAgUExQLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVsbCBwcm9jZXNzb3Igc3RhdHVzXHJcbi8qIGUxNDQgKi8gICAgICAgICAgICAgICAgICAgSk1QLmluZCAoXCJsaW5udW0rMF8wMDE0XCIpOyAgICAvLyBjYWxsIFNZUyBhZGRyZXNzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGFpbCBlbmQgb2YgU1lTIGNvZGVcclxuLyogZTE0NyAqLyAgICAgICAgICAgICAgICAgICBQSFAuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzYXZlIHN0YXR1c1xyXG4vKiBlMTQ4ICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwic2FyZWdfMDMwY1wiKTsgICAgICAgLy8gc2F2ZSByZXR1cm5lZCBBXHJcbi8qIGUxNGIgKi8gICAgICAgICAgICAgICAgICAgU1RYLmFicyAoXCJzeHJlZ18wMzBkXCIpOyAgICAgICAvLyBzYXZlIHJldHVybmVkIFhcclxuLyogZTE0ZSAqLyAgICAgICAgICAgICAgICAgICBTVFkuYWJzIChcInN5cmVnXzAzMGVcIik7ICAgICAgIC8vIHNhdmUgcmV0dXJuZWQgWVxyXG4vKiBlMTUxICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgc2F2ZWQgc3RhdHVzXHJcbi8qIGUxNTIgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJzcHJlZ18wMzBmXCIpOyAgICAgICAvLyBzYXZlIHN0YXR1c1xyXG4vKiBlMTU1ICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHBlcmZvcm0gU0FWRVxyXG4vKiBlMTU2ICovICAgX2BzYXZldF9lMTU2YDsgIEpTUi5hYnMgKFwic2xwYXJhX2UxZDRcIik7ICAgICAgLy8gZ2V0IHBhcmFtZXRlcnMgZm9yIExPQUQvU0FWRVxyXG4vKiBlMTU5ICovICAgICAgICAgICAgICAgICAgIExEWC56cGcgKFwidmFydGFiKzBfMDAyZFwiKTsgICAgLy8gZ2V0IHN0YXJ0IG9mIHZhcmlhYmxlcyBsb3cgYnl0ZVxyXG4vKiBlMTViICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwidmFydGFiKzFfMDAyZVwiKTsgICAgLy8gZ2V0IHN0YXJ0IG9mIHZhcmlhYmxlcyBoaWdoIGJ5dGVcclxuLyogZTE1ZCAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDJiKTsgICAgICAgICAgICAgICAvLyBpbmRleCB0byBzdGFydCBvZiBwcm9ncmFtIG1lbW9yeVxyXG4vKiBlMTVmICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwic2F2ZV9mZmQ4XCIpOyAgICAgICAgLy8gc2F2ZSBSQU0gdG8gZGV2aWNlLCBBID0gaW5kZXggdG8gc3RhcnQgYWRkcmVzcywgWFkgPSBlbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGRyZXNzIGxvdy9oaWdoXHJcbi8qIGUxNjIgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJiaW9lcnJfZTBmOVwiKTsgICAgICAvLyBpZiBlcnJvciBnbyBoYW5kbGUgQkFTSUMgSS9PIGVycm9yXHJcbi8qIGUxNjQgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcGVyZm9ybSBWRVJJRllcclxuLyogZTE2NSAqLyAgX2B2ZXJmeXRfZTE2NWA7ICBMREEuaW1tICgweDAxKTsgICAgICAgICAgICAgICAvLyBmbGFnIHZlcmlmeVxyXG4vKiBlMTY3ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgyYyk7ICAgICAgICAgICAgICAgIC8vIG1ha2VzIG5leHQgbGluZSBCSVQgJDAwQTlcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcGVyZm9ybSBMT0FEXHJcbi8qIGUxNjggKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gZmxhZyBsb2FkXHJcbi8qIGUxNmEgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJ2ZXJja18wMDBhXCIpOyAgICAgICAvLyBzZXQgbG9hZC92ZXJpZnkgZmxhZ1xyXG4vKiBlMTZjICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwic2xwYXJhX2UxZDRcIik7ICAgICAgLy8gZ2V0IHBhcmFtZXRlcnMgZm9yIExPQUQvU0FWRVxyXG4vKiBlMTZmICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwidmVyY2tfMDAwYVwiKTsgICAgICAgLy8gZ2V0IGxvYWQvdmVyaWZ5IGZsYWdcclxuLyogZTE3MSAqLyAgICAgICAgICAgICAgICAgICBMRFguenBnIChcInR4dHRhYiswXzAwMmJcIik7ICAgIC8vIGdldCBzdGFydCBvZiBtZW1vcnkgbG93IGJ5dGVcclxuLyogZTE3MyAqLyAgICAgICAgICAgICAgICAgICBMRFkuenBnIChcInR4dHRhYisxXzAwMmNcIik7ICAgIC8vIGdldCBzdGFydCBvZiBtZW1vcnkgaGlnaCBieXRlXHJcbi8qIGUxNzUgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJsb2FkX2ZmZDVcIik7ICAgICAgICAvLyBsb2FkIFJBTSBmcm9tIGEgZGV2aWNlXHJcbi8qIGUxNzggKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfZTFkMVwiKTsgICAgICAgICAgICAvLyBpZiBlcnJvciBnbyBoYW5kbGUgQkFTSUMgSS9PIGVycm9yXHJcbi8qIGUxN2EgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ2ZXJja18wMDBhXCIpOyAgICAgICAvLyBnZXQgbG9hZC92ZXJpZnkgZmxhZ1xyXG4vKiBlMTdjICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2UxOTVcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIGxvYWRcclxuLyogZTE3ZSAqLyAgICAgICAgICAgICAgICAgICBMRFguaW1tICgweDFjKTsgICAgICAgICAgICAgICAvLyBlcnJvciAkMUMsIHZlcmlmeSBlcnJvclxyXG4vKiBlMTgwICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwicmVhZHN0X2ZmYjdcIik7ICAgICAgLy8gcmVhZCBJL08gc3RhdHVzIHdvcmRcclxuLyogZTE4MyAqLyAgICAgICAgICAgICAgICAgICBBTkQuaW1tICgweDEwKTsgICAgICAgICAgICAgICAvLyBtYXNrIGZvciB0YXBlIHJlYWQgZXJyb3JcclxuLyogZTE4NSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9lMTllXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBubyByZWFkIGVycm9yXHJcbi8qIGUxODcgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ0eHRwdHIrMF8wMDdhXCIpOyAgICAvLyBnZXQgdGhlIEJBU0lDIGV4ZWN1dGUgcG9pbnRlciBsb3cgYnl0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIHRoaXMgY29ycmVjdCA/PyB3b24ndCB0aGlzIG1lYW4gdGhlIFwiT0tcIiBwcm9tcHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGRvaW5nIGEgbG9hZCBmcm9tIHdpdGhpbiBhIHByb2dyYW0gP1xyXG4vKiBlMTg5ICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4MDIpO1xyXG4vKiBlMThiICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2UxOTRcIik7ICAgICAgICAgICAgLy8gaWYgPz8gc2tpcCBcIk9LXCIgcHJvbXB0XHJcbi8qIGUxOGQgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHg2NCk7ICAgICAgICAgICAgICAgLy8gc2V0IFwiT0tcIiBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGUxOGYgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHhhMyk7ICAgICAgICAgICAgICAgLy8gc2V0IFwiT0tcIiBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBlMTkxICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwic3Ryb3V0X2FiMWVcIik7ICAgICAgLy8gcHJpbnQgbnVsbCB0ZXJtaW5hdGVkIHN0cmluZ1xyXG4vKiBlMTk0ICovICAgICAgICBfYF9lMTk0YDsgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGRvIFJFQURZIHJldHVybiB0byBCQVNJQ1xyXG4vKiBlMTk1ICovICAgICAgICBfYF9lMTk1YDsgIEpTUi5hYnMgKFwicmVhZHN0X2ZmYjdcIik7ICAgICAgLy8gcmVhZCBJL08gc3RhdHVzIHdvcmRcclxuLyogZTE5OCAqLyAgICAgICAgICAgICAgICAgICBBTkQuaW1tICgweGJmKTsgICAgICAgICAgICAgICAvLyBtYXNrIHgweHggeHh4eCwgY2xlYXIgcmVhZCBlcnJvclxyXG4vKiBlMTlhICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2UxYTFcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vIGVycm9yc1xyXG4vKiBlMTljICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4MWQpOyAgICAgICAgICAgICAgIC8vIGVycm9yICQxRCwgbG9hZCBlcnJvclxyXG4vKiBlMTllICovICAgICAgICBfYF9lMTllYDsgIEpNUC5hYnMgKFwiZXJyb3JfYTQzN1wiKTsgICAgICAgLy8gZG8gZXJyb3IgI1ggdGhlbiB3YXJtIHN0YXJ0XHJcbi8qIGUxYTEgKi8gICAgICAgIF9gX2UxYTFgOyAgTERBLnpwZyAoXCJ0eHRwdHIrMV8wMDdiXCIpOyAgICAvLyBnZXQgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBlMWEzICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4MDIpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCAkMDJ4eFxyXG4vKiBlMWE1ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2UxYjVcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vdCBpbW1lZGlhdGUgbW9kZVxyXG4vKiBlMWE3ICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwidmFydGFiKzBfMDAyZFwiKTsgICAgLy8gc2V0IHN0YXJ0IG9mIHZhcmlhYmxlcyBsb3cgYnl0ZVxyXG4vKiBlMWE5ICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwidmFydGFiKzFfMDAyZVwiKTsgICAgLy8gc2V0IHN0YXJ0IG9mIHZhcmlhYmxlcyBoaWdoIGJ5dGVcclxuLyogZTFhYiAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDc2KTsgICAgICAgICAgICAgICAvLyBzZXQgXCJSRUFEWS5cIiBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGUxYWQgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHhhMyk7ICAgICAgICAgICAgICAgLy8gc2V0IFwiUkVBRFkuXCIgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogZTFhZiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcInN0cm91dF9hYjFlXCIpOyAgICAgIC8vIHByaW50IG51bGwgdGVybWluYXRlZCBzdHJpbmdcclxuLyogZTFiMiAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9hNTJhXCIpOyAgICAgICAgICAgIC8vIHJlc2V0IGV4ZWN1dGlvbiwgY2xlYXIgdmFyaWFibGVzLCBmbHVzaCBzdGFjayxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWJ1aWxkIEJBU0lDIGNoYWluIGFuZCBkbyB3YXJtIHN0YXJ0XHJcbi8qIGUxYjUgKi8gICAgICAgIF9gX2UxYjVgOyAgSlNSLmFicyAoXCJzdHhwdF9hNjhlXCIpOyAgICAgICAvLyBzZXQgQkFTSUMgZXhlY3V0ZSBwb2ludGVyIHRvIHN0YXJ0IG9mIG1lbW9yeSAtIDFcclxuLyogZTFiOCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImxpbmtwcmdfYTUzM1wiKTsgICAgIC8vIHJlYnVpbGQgQkFTSUMgbGluZSBjaGFpbmluZ1xyXG4vKiBlMWJiICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2E2NzdcIik7ICAgICAgICAgICAgLy8gcmVidWlsZCBCQVNJQyBsaW5lIGNoYWluaW5nLCBkbyBSRVNUT1JFIGFuZCByZXR1cm5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcGVyZm9ybSBPUEVOXHJcbi8qIGUxYmUgKi8gICBfYG9wZW50X2UxYmVgOyAgSlNSLmFicyAoXCJvY3BhcmFfZTIxOVwiKTsgICAgICAvLyBnZXQgcGFyYW1ldGVycyBmb3IgT1BFTi9DTE9TRVxyXG4vKiBlMWMxICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwib3Blbl9mZmMwXCIpOyAgICAgICAgLy8gb3BlbiBhIGxvZ2ljYWwgZmlsZVxyXG4vKiBlMWM0ICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2UxZDFcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIGVycm9yXHJcbi8qIGUxYzYgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcGVyZm9ybSBDTE9TRVxyXG4vKiBlMWM3ICovICBfYGNsb3NldF9lMWM3YDsgIEpTUi5hYnMgKFwib2NwYXJhX2UyMTlcIik7ICAgICAgLy8gZ2V0IHBhcmFtZXRlcnMgZm9yIE9QRU4vQ0xPU0VcclxuLyogZTFjYSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZvcnBudCswXzAwNDlcIik7ICAgIC8vIGdldCBsb2dpY2FsIGZpbGUgbnVtYmVyXHJcbi8qIGUxY2MgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJjbG9zZV9mZmMzXCIpOyAgICAgICAvLyBjbG9zZSBhIHNwZWNpZmllZCBsb2dpY2FsIGZpbGVcclxuLyogZTFjZiAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9lMTk0XCIpOyAgICAgICAgICAgIC8vIGV4aXQgaWYgbm8gZXJyb3JcclxuLyogZTFkMSAqLyAgICAgICAgX2BfZTFkMWA7ICBKTVAuYWJzIChcImJpb2Vycl9lMGY5XCIpOyAgICAgIC8vIGdvIGhhbmRsZSBCQVNJQyBJL08gZXJyb3JcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gZ2V0IHBhcmFtZXRlcnMgZm9yIExPQUQvU0FWRVxyXG4vKiBlMWQ0ICovICBfYHNscGFyYV9lMWQ0YDsgIExEQS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIGZpbGUgbmFtZSBsZW5ndGhcclxuLyogZTFkNiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcInNldG5hbV9mZmJkXCIpOyAgICAgIC8vIGNsZWFyIHRoZSBmaWxlbmFtZVxyXG4vKiBlMWQ5ICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4MDEpOyAgICAgICAgICAgICAgIC8vIHNldCBkZWZhdWx0IGRldmljZSBudW1iZXIsIGNhc3NldHRlXHJcbi8qIGUxZGIgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gc2V0IGRlZmF1bHQgY29tbWFuZFxyXG4vKiBlMWRkICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwic2V0bGZzX2ZmYmFcIik7ICAgICAgLy8gc2V0IGxvZ2ljYWwsIGZpcnN0IGFuZCBzZWNvbmQgYWRkcmVzc2VzXHJcbi8qIGUxZTAgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJkZWZsdF9lMjA2XCIpOyAgICAgICAvLyBleGl0IGZ1bmN0aW9uIGlmIFtFT1RdIG9yIFwiOlwiXHJcbi8qIGUxZTMgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZTI1N1wiKTsgICAgICAgICAgICAvLyBzZXQgZmlsZW5hbWVcclxuLyogZTFlNiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImRlZmx0X2UyMDZcIik7ICAgICAgIC8vIGV4aXQgZnVuY3Rpb24gaWYgW0VPVF0gb3IgXCI6XCJcclxuLyogZTFlOSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImNvbWJ5dF9lMjAwXCIpOyAgICAgIC8vIHNjYW4gYW5kIGdldCBieXRlLCBlbHNlIGRvIHN5bnRheCBlcnJvciB0aGVuIHdhcm0gc3RhcnRcclxuLyogZTFlYyAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBjb21tYW5kXHJcbi8qIGUxZWUgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJmb3JwbnQrMF8wMDQ5XCIpOyAgICAvLyBzYXZlIGRldmljZSBudW1iZXJcclxuLyogZTFmMCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcInNldGxmc19mZmJhXCIpOyAgICAgIC8vIHNldCBsb2dpY2FsLCBmaXJzdCBhbmQgc2Vjb25kIGFkZHJlc3Nlc1xyXG4vKiBlMWYzICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiZGVmbHRfZTIwNlwiKTsgICAgICAgLy8gZXhpdCBmdW5jdGlvbiBpZiBbRU9UXSBvciBcIjpcIlxyXG4vKiBlMWY2ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiY29tYnl0X2UyMDBcIik7ICAgICAgLy8gc2NhbiBhbmQgZ2V0IGJ5dGUsIGVsc2UgZG8gc3ludGF4IGVycm9yIHRoZW4gd2FybSBzdGFydFxyXG4vKiBlMWY5ICovICAgICAgICAgICAgICAgICAgIFRYQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgY29tbWFuZCB0byBBXHJcbi8qIGUxZmEgKi8gICAgICAgICAgICAgICAgICAgVEFZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBjb21tYW5kIHRvIFlcclxuLyogZTFmYiAqLyAgICAgICAgICAgICAgICAgICBMRFguenBnIChcImZvcnBudCswXzAwNDlcIik7ICAgIC8vIGdldCBkZXZpY2UgbnVtYmVyIGJhY2tcclxuLyogZTFmZCAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcInNldGxmc19mZmJhXCIpOyAgICAgIC8vIHNldCBsb2dpY2FsLCBmaXJzdCBhbmQgc2Vjb25kIGFkZHJlc3NlcyBhbmQgcmV0dXJuXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHNjYW4gYW5kIGdldCBieXRlLCBlbHNlIGRvIHN5bnRheCBlcnJvciB0aGVuIHdhcm0gc3RhcnRcclxuLyogZTIwMCAqLyAgX2Bjb21ieXRfZTIwMGA7ICBKU1IuYWJzIChcImNtbWVycl9lMjBlXCIpOyAgICAgIC8vIHNjYW4gZm9yIFwiLGJ5dGVcIiwgZWxzZSBkbyBzeW50YXggZXJyb3IgdGhlbiB3YXJtIHN0YXJ0XHJcbi8qIGUyMDMgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfYjc5ZVwiKTsgICAgICAgICAgICAvLyBnZXQgYnl0ZSBwYXJhbWV0ZXIgYW5kIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4aXQgZnVuY3Rpb24gaWYgW0VPVF0gb3IgXCI6XCJcclxuLyogZTIwNiAqLyAgIF9gZGVmbHRfZTIwNmA7ICBKU1IuYWJzIChcImNocmdvdF8wMDc5XCIpOyAgICAgIC8vIHNjYW4gbWVtb3J5XHJcbi8qIGUyMDkgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZTIwZFwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbm90IFtFT0xdIG9yIFwiOlwiXHJcbi8qIGUyMGIgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZHVtcCByZXR1cm4gYWRkcmVzcyBsb3cgYnl0ZVxyXG4vKiBlMjBjICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGR1bXAgcmV0dXJuIGFkZHJlc3MgaGlnaCBieXRlXHJcbi8qIGUyMGQgKi8gICAgICAgIF9gX2UyMGRgOyAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gc2NhbiBmb3IgXCIsdmFsaWQgYnl0ZVwiLCBlbHNlIGRvIHN5bnRheCBlcnJvciB0aGVuIHdhcm0gc3RhcnRcclxuLyogZTIwZSAqLyAgX2BjbW1lcnJfZTIwZWA7ICBKU1IuYWJzIChcIl9hZWZkXCIpOyAgICAgICAgICAgIC8vIHNjYW4gZm9yIFwiLFwiLCBlbHNlIGRvIHN5bnRheCBlcnJvciB0aGVuIHdhcm0gc3RhcnRcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gc2NhbiBmb3IgdmFsaWQgYnl0ZSwgbm90IFtFT0xdIG9yIFwiOlwiLCBlbHNlIGRvIHN5bnRheCBlcnJvciB0aGVuIHdhcm0gc3RhcnRcclxuLyogZTIxMSAqLyAgICAgICAgX2BfZTIxMWA7ICBKU1IuYWJzIChcImNocmdvdF8wMDc5XCIpOyAgICAgIC8vIHNjYW4gbWVtb3J5XHJcbi8qIGUyMTQgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZTIwZFwiKTsgICAgICAgICAgICAvLyBleGl0IGlmIGZvbGxvd2luZyBieXRlXHJcbi8qIGUyMTYgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJzeW5lcnJfYWYwOFwiKTsgICAgICAvLyBlbHNlIGRvIHN5bnRheCBlcnJvciB0aGVuIHdhcm0gc3RhcnRcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gZ2V0IHBhcmFtZXRlcnMgZm9yIE9QRU4vQ0xPU0VcclxuLyogZTIxOSAqLyAgX2BvY3BhcmFfZTIxOWA7ICBMREEuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciB0aGUgZmlsZW5hbWUgbGVuZ3RoXHJcbi8qIGUyMWIgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJzZXRuYW1fZmZiZFwiKTsgICAgICAvLyBjbGVhciB0aGUgZmlsZW5hbWVcclxuLyogZTIxZSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9lMjExXCIpOyAgICAgICAgICAgIC8vIHNjYW4gZm9yIHZhbGlkIGJ5dGUsIGVsc2UgZG8gc3ludGF4IGVycm9yIHRoZW4gd2FybSBzdGFydFxyXG4vKiBlMjIxICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2I3OWVcIik7ICAgICAgICAgICAgLy8gZ2V0IGJ5dGUgcGFyYW1ldGVyLCBsb2dpY2FsIGZpbGUgbnVtYmVyXHJcbi8qIGUyMjQgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJmb3JwbnQrMF8wMDQ5XCIpOyAgICAvLyBzYXZlIGxvZ2ljYWwgZmlsZSBudW1iZXJcclxuLyogZTIyNiAqLyAgICAgICAgICAgICAgICAgICBUWEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IGxvZ2ljYWwgZmlsZSBudW1iZXIgdG8gQVxyXG4vKiBlMjI3ICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4MDEpOyAgICAgICAgICAgICAgIC8vIHNldCBkZWZhdWx0IGRldmljZSBudW1iZXIsIGNhc3NldHRlXHJcbi8qIGUyMjkgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gc2V0IGRlZmF1bHQgY29tbWFuZFxyXG4vKiBlMjJiICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwic2V0bGZzX2ZmYmFcIik7ICAgICAgLy8gc2V0IGxvZ2ljYWwsIGZpcnN0IGFuZCBzZWNvbmQgYWRkcmVzc2VzXHJcbi8qIGUyMmUgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJkZWZsdF9lMjA2XCIpOyAgICAgICAvLyBleGl0IGZ1bmN0aW9uIGlmIFtFT1RdIG9yIFwiOlwiXHJcbi8qIGUyMzEgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJjb21ieXRfZTIwMFwiKTsgICAgICAvLyBzY2FuIGFuZCBnZXQgYnl0ZSwgZWxzZSBkbyBzeW50YXggZXJyb3IgdGhlbiB3YXJtIHN0YXJ0XHJcbi8qIGUyMzQgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJmb3JwbnQrMV8wMDRhXCIpOyAgICAvLyBzYXZlIGRldmljZSBudW1iZXJcclxuLyogZTIzNiAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBjb21tYW5kXHJcbi8qIGUyMzggKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJmb3JwbnQrMF8wMDQ5XCIpOyAgICAvLyBnZXQgbG9naWNhbCBmaWxlIG51bWJlclxyXG4vKiBlMjNhICovICAgICAgICAgICAgICAgICAgIENQWC5pbW0gKDB4MDMpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgZGV2aWNlIG51bWJlciB3aXRoIHNjcmVlblxyXG4vKiBlMjNjICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2UyM2ZcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIGxlc3MgdGhhbiBzY3JlZW5cclxuLyogZTIzZSAqLyAgICAgICAgICAgICAgICAgICBERVkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBlbHNlIGRlY3JlbWVudCBjb21tYW5kXHJcbi8qIGUyM2YgKi8gICAgICAgIF9gX2UyM2ZgOyAgSlNSLmFicyAoXCJzZXRsZnNfZmZiYVwiKTsgICAgICAvLyBzZXQgbG9naWNhbCwgZmlyc3QgYW5kIHNlY29uZCBhZGRyZXNzZXNcclxuLyogZTI0MiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImRlZmx0X2UyMDZcIik7ICAgICAgIC8vIGV4aXQgZnVuY3Rpb24gaWYgW0VPVF0gb3IgXCI6XCJcclxuLyogZTI0NSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImNvbWJ5dF9lMjAwXCIpOyAgICAgIC8vIHNjYW4gYW5kIGdldCBieXRlLCBlbHNlIGRvIHN5bnRheCBlcnJvciB0aGVuIHdhcm0gc3RhcnRcclxuLyogZTI0OCAqLyAgICAgICAgICAgICAgICAgICBUWEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IGNvbW1hbmQgdG8gQVxyXG4vKiBlMjQ5ICovICAgICAgICAgICAgICAgICAgIFRBWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgY29tbWFuZCB0byBZXHJcbi8qIGUyNGEgKi8gICAgICAgICAgICAgICAgICAgTERYLnpwZyAoXCJmb3JwbnQrMV8wMDRhXCIpOyAgICAvLyBnZXQgZGV2aWNlIG51bWJlclxyXG4vKiBlMjRjICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZm9ycG50KzBfMDA0OVwiKTsgICAgLy8gZ2V0IGxvZ2ljYWwgZmlsZSBudW1iZXJcclxuLyogZTI0ZSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcInNldGxmc19mZmJhXCIpOyAgICAgIC8vIHNldCBsb2dpY2FsLCBmaXJzdCBhbmQgc2Vjb25kIGFkZHJlc3Nlc1xyXG4vKiBlMjUxICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiZGVmbHRfZTIwNlwiKTsgICAgICAgLy8gZXhpdCBmdW5jdGlvbiBpZiBbRU9UXSBvciBcIjpcIlxyXG4vKiBlMjU0ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiY21tZXJyX2UyMGVcIik7ICAgICAgLy8gc2NhbiBmb3IgXCIsYnl0ZVwiLCBlbHNlIGRvIHN5bnRheCBlcnJvciB0aGVuIHdhcm0gc3RhcnRcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gc2V0IGZpbGVuYW1lXHJcbi8qIGUyNTcgKi8gICAgICAgIF9gX2UyNTdgOyAgSlNSLmFicyAoXCJmcm1ldmxfYWQ5ZVwiKTsgICAgICAvLyBldmFsdWF0ZSBleHByZXNzaW9uXHJcbi8qIGUyNWEgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJmcmVzdHJfYjZhM1wiKTsgICAgICAvLyBldmFsdWF0ZSBzdHJpbmdcclxuLyogZTI1ZCAqLyAgICAgICAgICAgICAgICAgICBMRFguenBnIChcImluZGV4KzBfMDAyMlwiKTsgICAgIC8vIGdldCBzdHJpbmcgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBlMjVmICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwiaW5kZXgrMV8wMDIzXCIpOyAgICAgLy8gZ2V0IHN0cmluZyBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBlMjYxICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwic2V0bmFtX2ZmYmRcIik7ICAgICAgLy8gc2V0IHRoZSBmaWxlbmFtZSBhbmQgcmV0dXJuXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHBlcmZvcm0gQ09TKClcclxuLyogZTI2NCAqLyAgICAgX2Bjb3NfZTI2NGA7ICBMREEuaW1tICgweGUwKTsgICAgICAgICAgICAgICAvLyBzZXQgcGkvMiBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGUyNjYgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHhlMik7ICAgICAgICAgICAgICAgLy8gc2V0IHBpLzIgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogZTI2OCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImZhZGRfYjg2N1wiKTsgICAgICAgIC8vIGFkZCAoQVkpIHRvIEZBQzFcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcGVyZm9ybSBTSU4oKVxyXG4vKiBlMjZiICovICAgICBfYHNpbl9lMjZiYDsgIEpTUi5hYnMgKFwibW92YWZfYmMwY1wiKTsgICAgICAgLy8gcm91bmQgYW5kIGNvcHkgRkFDMSB0byBGQUMyXHJcbi8qIGUyNmUgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHhlNSk7ICAgICAgICAgICAgICAgLy8gc2V0IDIqcGkgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBlMjcwICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4ZTIpOyAgICAgICAgICAgICAgIC8vIHNldCAyKnBpIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGUyNzIgKi8gICAgICAgICAgICAgICAgICAgTERYLnpwZyAoXCJhcmdzZ25fMDA2ZVwiKTsgICAgICAvLyBnZXQgRkFDMiBzaWduIChiNylcclxuLyogZTI3NCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImZkaXZmX2JiMDdcIik7ICAgICAgIC8vIGRpdmlkZSBieSAoQVkpIChYPXNpZ24pXHJcbi8qIGUyNzcgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJtb3ZhZl9iYzBjXCIpOyAgICAgICAvLyByb3VuZCBhbmQgY29weSBGQUMxIHRvIEZBQzJcclxuLyogZTI3YSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImludF9iY2NjXCIpOyAgICAgICAgIC8vIHBlcmZvcm0gSU5UKClcclxuLyogZTI3ZCAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBieXRlXHJcbi8qIGUyN2YgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJhcmlzZ25fMDA2ZlwiKTsgICAgICAvLyBjbGVhciBzaWduIGNvbXBhcmUgKEZBQzEgRU9SIEZBQzIpXHJcbi8qIGUyODEgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJmc3VidF9iODUzXCIpOyAgICAgICAvLyBwZXJmb3JtIHN1YnRyYWN0aW9uLCBGQUMyIGZyb20gRkFDMVxyXG4vKiBlMjg0ICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4ZWEpOyAgICAgICAgICAgICAgIC8vIHNldCAwLjI1IHBvaW50ZXIgbG93IGJ5dGVcclxuLyogZTI4NiAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweGUyKTsgICAgICAgICAgICAgICAvLyBzZXQgMC4yNSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBlMjg4ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiZnN1Yl9iODUwXCIpOyAgICAgICAgLy8gcGVyZm9ybSBzdWJ0cmFjdGlvbiwgRkFDMSBmcm9tIChBWSlcclxuLyogZTI4YiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZhY3Nnbl8wMDY2XCIpOyAgICAgIC8vIGdldCBGQUMxIHNpZ24gKGI3KVxyXG4vKiBlMjhkICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgRkFDMSBzaWduXHJcbi8qIGUyOGUgKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfZTI5ZFwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgK3ZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRkFDMSBzaWduIHdhcyAtdmVcclxuLyogZTI5MCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImZhZGRoX2I4NDlcIik7ICAgICAgIC8vIGFkZCAwLjUgdG8gRkFDMSAocm91bmQgRkFDMSlcclxuLyogZTI5MyAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZhY3Nnbl8wMDY2XCIpOyAgICAgIC8vIGdldCBGQUMxIHNpZ24gKGI3KVxyXG4vKiBlMjk1ICovICAgICAgICAgICAgICAgICAgIEJNSS5yZWwgKFwiX2UyYTBcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIC12ZVxyXG4vKiBlMjk3ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwidGFuc2duXzAwMTJcIik7ICAgICAgLy8gZ2V0IHRoZSBjb21wYXJpc29uIGV2YWx1YXRpb24gZmxhZ1xyXG4vKiBlMjk5ICovICAgICAgICAgICAgICAgICAgIEVPUi5pbW0gKDB4ZmYpOyAgICAgICAgICAgICAgIC8vIHRvZ2dsZSBmbGFnXHJcbi8qIGUyOWIgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJ0YW5zZ25fMDAxMlwiKTsgICAgICAvLyBzYXZlIHRoZSBjb21wYXJpc29uIGV2YWx1YXRpb24gZmxhZ1xyXG4vKiBlMjlkICovICAgICAgICBfYF9lMjlkYDsgIEpTUi5hYnMgKFwibmVnb3BfYmZiNFwiKTsgICAgICAgLy8gZG8gLSBGQUMxXHJcbi8qIGUyYTAgKi8gICAgICAgIF9gX2UyYTBgOyAgTERBLmltbSAoMHhlYSk7ICAgICAgICAgICAgICAgLy8gc2V0IDAuMjUgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBlMmEyICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4ZTIpOyAgICAgICAgICAgICAgIC8vIHNldCAwLjI1IHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGUyYTQgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJmYWRkX2I4NjdcIik7ICAgICAgICAvLyBhZGQgKEFZKSB0byBGQUMxXHJcbi8qIGUyYTcgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBGQUMxIHNpZ25cclxuLyogZTJhOCAqLyAgICAgICAgICAgICAgICAgICBCUEwucmVsIChcIl9lMmFkXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiB3YXMgK3ZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBjb3JyZWN0IEZBQzFcclxuLyogZTJhYSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIm5lZ29wX2JmYjRcIik7ICAgICAgIC8vIGRvIC0gRkFDMVxyXG4vKiBlMmFkICovICAgICAgICBfYF9lMmFkYDsgIExEQS5pbW0gKDB4ZWYpOyAgICAgICAgICAgICAgIC8vIHNldCBwb2ludGVyIGxvdyBieXRlIHRvIGNvdW50ZXJcclxuLyogZTJhZiAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweGUyKTsgICAgICAgICAgICAgICAvLyBzZXQgcG9pbnRlciBoaWdoIGJ5dGUgdG8gY291bnRlclxyXG4vKiBlMmIxICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwicG9seXhfZTA0M1wiKTsgICAgICAgLy8gXjIgdGhlbiBzZXJpZXMgZXZhbHVhdGlvbiBhbmQgcmV0dXJuXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHBlcmZvcm0gVEFOKClcclxuLyogZTJiNCAqLyAgICAgX2B0YW5fZTJiNGA7ICBKU1IuYWJzIChcIl9iYmNhXCIpOyAgICAgICAgICAgIC8vIHBhY2sgRkFDMSBpbnRvICQ1N1xyXG4vKiBlMmI3ICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIEFcclxuLyogZTJiOSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInRhbnNnbl8wMDEyXCIpOyAgICAgIC8vIGNsZWFyIHRoZSBjb21wYXJpc29uIGV2YWx1YXRpb24gZmxhZ1xyXG4vKiBlMmJiICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwic2luX2UyNmJcIik7ICAgICAgICAgLy8gcGVyZm9ybSBTSU4oKVxyXG4vKiBlMmJlICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4NGUpOyAgICAgICAgICAgICAgIC8vIHNldCBzaW4obikgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBlMmMwICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIHNldCBzaW4obikgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogZTJjMiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9lMGY2XCIpOyAgICAgICAgICAgIC8vIHBhY2sgRkFDMSBpbnRvIChYWSlcclxuLyogZTJjNSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDU3KTsgICAgICAgICAgICAgICAvLyBzZXQgbiBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGUyYzcgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gc2V0IG4gcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogZTJjOSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIm1vdmZtX2JiYTJcIik7ICAgICAgIC8vIHVucGFjayBtZW1vcnkgKEFZKSBpbnRvIEZBQzFcclxuLyogZTJjYyAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBieXRlXHJcbi8qIGUyY2UgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJmYWNzZ25fMDA2NlwiKTsgICAgICAvLyBjbGVhciBGQUMxIHNpZ24gKGI3KVxyXG4vKiBlMmQwICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwidGFuc2duXzAwMTJcIik7ICAgICAgLy8gZ2V0IHRoZSBjb21wYXJpc29uIGV2YWx1YXRpb24gZmxhZ1xyXG4vKiBlMmQyICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2UyZGNcIik7ICAgICAgICAgICAgLy8gc2F2ZSBmbGFnIGFuZCBnbyBkbyBzZXJpZXMgZXZhbHVhdGlvblxyXG4vKiBlMmQ1ICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4NGUpOyAgICAgICAgICAgICAgIC8vIHNldCBzaW4obikgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBlMmQ3ICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIHNldCBzaW4obikgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogZTJkOSAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcImZkaXZfYmIwZlwiKTsgICAgICAgIC8vIGNvbnZlcnQgQVkgYW5kIGRvIChBWSkvRkFDMVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzYXZlIGNvbXBhcmlzb24gZmxhZyBhbmQgZG8gc2VyaWVzIGV2YWx1YXRpb25cclxuLyogZTJkYyAqLyAgICAgICAgX2BfZTJkY2A7ICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzYXZlIGNvbXBhcmlzb24gZmxhZ1xyXG4vKiBlMmRkICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2UyOWRcIik7ICAgICAgICAgICAgLy8gYWRkIDAuMjUsIF4yIHRoZW4gc2VyaWVzIGV2YWx1YXRpb25cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY29uc3RhbnRzIGFuZCBzZXJpZXMgZm9yIFNJTi9DT1MobilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxLjU3MDc5NjM3MSwgcGkvMiwgYXMgZmxvYXRpbmcgbnVtYmVyXHJcbi8qIGUyZTAgKi8gICAgIF9gcGkyX2UyZTBgOyAgXy5ieXRlcygweDgxLCAweDQ5LCAweDBmLCAweGRhLCAweGEyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA2LjI4MzE5LCAyKnBpLCBhcyBmbG9hdGluZyBudW1iZXJcclxuLyogZTJlNSAqLyAgIF9gdHdvcGlfZTJlNWA7ICBfLmJ5dGVzKDB4ODMsIDB4NDksIDB4MGYsIDB4ZGEsIDB4YTIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAuMjVcclxuLyogZTJlYSAqLyAgICAgX2BmcjRfZTJlYWA7ICBfLmJ5dGVzKDB4N2YsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDApO1xyXG4vKiBlMmVmICovICBfYHNpbmNvbl9lMmVmYDsgIF8uYnl0ZXMoMHgwNSk7ICAgICAgICAgICAgICAgIC8vIHNlcmllcyBjb3VudGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLTE0LjM4MTM5MDdcclxuLyogZTJmMCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4ODQsIDB4ZTYsIDB4MWEsIDB4MmQsIDB4MWIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICA0Mi4wMDc3OTcxXHJcbi8qIGUyZjUgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDg2LCAweDI4LCAweDA3LCAweGZiLCAweGY4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtNzYuNzA0MTcwM1xyXG4vKiBlMmZhICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg4NywgMHg5OSwgMHg2OCwgMHg4OSwgMHgwMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIDgxLjYwNTIyMzdcclxuLyogZTJmZiAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4ODcsIDB4MjMsIDB4MzUsIDB4ZGYsIDB4ZTEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC00MS4zMTQ3MDIxXHJcbi8qIGUzMDQgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDg2LCAweGE1LCAweDVkLCAweGU3LCAweDI4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIDYuMjgzMTg1MzEgICAyKnBpXHJcbi8qIGUzMDkgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDgzLCAweDQ5LCAweDBmLCAweGRhLCAweGEyKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcGVyZm9ybSBBVE4oKVxyXG4vKiBlMzBlICovICAgICBfYGF0bl9lMzBlYDsgIExEQS56cGcgKFwiZmFjc2duXzAwNjZcIik7ICAgICAgLy8gZ2V0IEZBQzEgc2lnbiAoYjcpXHJcbi8qIGUzMTAgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBzaWduXHJcbi8qIGUzMTEgKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfZTMxNlwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgK3ZlXHJcbi8qIGUzMTMgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJuZWdvcF9iZmI0XCIpOyAgICAgICAvLyBlbHNlIGRvIC0gRkFDMVxyXG4vKiBlMzE2ICovICAgICAgICBfYF9lMzE2YDsgIExEQS56cGcgKFwiZmFjZXhwXzAwNjFcIik7ICAgICAgLy8gZ2V0IEZBQzEgZXhwb25lbnRcclxuLyogZTMxOCAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdXNoIGV4cG9uZW50XHJcbi8qIGUzMTkgKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHg4MSk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIDFcclxuLyogZTMxYiAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9lMzI0XCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBGQUMxIDwgMVxyXG4vKiBlMzFkICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4YmMpOyAgICAgICAgICAgICAgIC8vIHBvaW50ZXIgdG8gMSBsb3cgYnl0ZVxyXG4vKiBlMzFmICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4YjkpOyAgICAgICAgICAgICAgIC8vIHBvaW50ZXIgdG8gMSBoaWdoIGJ5dGVcclxuLyogZTMyMSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImZkaXZfYmIwZlwiKTsgICAgICAgIC8vIGNvbnZlcnQgQVkgYW5kIGRvIChBWSkvRkFDMVxyXG4vKiBlMzI0ICovICAgICAgICBfYF9lMzI0YDsgIExEQS5pbW0gKDB4M2UpOyAgICAgICAgICAgICAgIC8vIHBvaW50ZXIgdG8gc2VyaWVzIGxvdyBieXRlXHJcbi8qIGUzMjYgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHhlMyk7ICAgICAgICAgICAgICAgLy8gcG9pbnRlciB0byBzZXJpZXMgaGlnaCBieXRlXHJcbi8qIGUzMjggKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJwb2x5eF9lMDQzXCIpOyAgICAgICAvLyBeMiB0aGVuIHNlcmllcyBldmFsdWF0aW9uXHJcbi8qIGUzMmIgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBvbGQgRkFDMSBleHBvbmVudFxyXG4vKiBlMzJjICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4ODEpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCAxXHJcbi8qIGUzMmUgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfZTMzN1wiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgRkFDMSA8IDFcclxuLyogZTMzMCAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweGUwKTsgICAgICAgICAgICAgICAvLyBwb2ludGVyIHRvIChwaS8yKSBsb3cgYnl0ZVxyXG4vKiBlMzMyICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4ZTIpOyAgICAgICAgICAgICAgIC8vIHBvaW50ZXIgdG8gKHBpLzIpIGxvdyBieXRlXHJcbi8qIGUzMzQgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJmc3ViX2I4NTBcIik7ICAgICAgICAvLyBwZXJmb3JtIHN1YnRyYWN0aW9uLCBGQUMxIGZyb20gKEFZKVxyXG4vKiBlMzM3ICovICAgICAgICBfYF9lMzM3YDsgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgRkFDMSBzaWduXHJcbi8qIGUzMzggKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfZTMzZFwiKTsgICAgICAgICAgICAvLyBleGl0IGlmIHdhcyArdmVcclxuLyogZTMzYSAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIm5lZ29wX2JmYjRcIik7ICAgICAgIC8vIGVsc2UgZG8gLSBGQUMxIGFuZCByZXR1cm5cclxuLyogZTMzZCAqLyAgICAgICAgX2BfZTMzZGA7ICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzZXJpZXMgZm9yIEFUTihuKVxyXG4vKiBlMzNlICovICBfYGF0bmNvbl9lMzNlYDsgIF8uYnl0ZXMoMHgwYik7ICAgICAgICAgICAgICAgIC8vIHNlcmllcyBjb3VudGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLTYuODQ3OTM5MTJFLTA0XHJcbi8qIGUzM2YgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDc2LCAweGIzLCAweDgzLCAweGJkLCAweGQzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgNC44NTA5NDIxNkUtMDNcclxuLyogZTM0NCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NzksIDB4MWUsIDB4ZjQsIDB4YTYsIDB4ZjUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAtLjAxNjExMTcwMTVcclxuLyogZTM0OSAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4N2IsIDB4ODMsIDB4ZmMsIDB4YjAsIDB4MTApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgLjAzNDIwOTYzOFxyXG4vKiBlMzRlICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg3YywgMHgwYywgMHgxZiwgMHg2NywgMHhjYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIC0uMDU0Mjc5MTMzXHJcbi8qIGUzNTMgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDdjLCAweGRlLCAweDUzLCAweGNiLCAweGMxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIC4wNzI0NTcxOTY1XHJcbi8qIGUzNTggKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDdkLCAweDE0LCAweDY0LCAweDcwLCAweDRjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgLS4wODk4MDE5MTg1XHJcbi8qIGUzNWQgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDdkLCAweGI3LCAweGVhLCAweDUxLCAweDdhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIC4xMTA5MzI0MTNcclxuLyogZTM2MiAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4N2QsIDB4NjMsIDB4MzAsIDB4ODgsIDB4N2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAtLjE0MjgzOTgwOFxyXG4vKiBlMzY3ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg3ZSwgMHg5MiwgMHg0NCwgMHg5OSwgMHgzYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAuMTk5OTk5MTJcclxuLyogZTM2YyAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4N2UsIDB4NGMsIDB4Y2MsIDB4OTEsIDB4YzcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAtLjMzMzMzMzMxNlxyXG4vKiBlMzcxICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg3ZiwgMHhhYSwgMHhhYSwgMHhhYSwgMHgxMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIDFcclxuLyogZTM3NiAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4ODEsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDApO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBCQVNJQyB3YXJtIHN0YXJ0IGVudHJ5IHBvaW50XHJcbi8qIGUzN2IgKi8gIF9gYmFzc2Z0X2UzN2JgOyAgSlNSLmFicyAoXCJjbHJjaG5fZmZjY1wiKTsgICAgICAvLyBjbG9zZSBpbnB1dCBhbmQgb3V0cHV0IGNoYW5uZWxzXHJcbi8qIGUzN2UgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgQVxyXG4vKiBlMzgwICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiY2hhbm5sXzAwMTNcIik7ICAgICAgLy8gc2V0IGN1cnJlbnQgSS9PIGNoYW5uZWwsIGZsYWcgZGVmYXVsdFxyXG4vKiBlMzgyICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2E2N2FcIik7ICAgICAgICAgICAgLy8gZmx1c2ggQkFTSUMgc3RhY2sgYW5kIGNsZWFyIGNvbnRpbnVlIHBvaW50ZXJcclxuLyogZTM4NSAqLyAgICAgICAgICAgICAgICAgICBDTEkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBlbmFibGUgdGhlIGludGVycnVwdHNcclxuLyogZTM4NiAqLyAgICAgICAgX2BfZTM4NmA7ICBMRFguaW1tICgweDgwKTsgICAgICAgICAgICAgICAvLyBzZXQgLXZlIGVycm9yLCBqdXN0IGRvIHdhcm0gc3RhcnRcclxuLyogZTM4OCAqLyAgICAgICAgICAgICAgICAgICBKTVAuaW5kIChcImllcnJvciswXzAzMDBcIik7ICAgIC8vIGdvIGhhbmRsZSBlcnJvciBtZXNzYWdlLCBub3JtYWxseSAkRTM4QlxyXG4vKiBlMzhiICovICAgICAgICAgICAgICAgICAgIFRYQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgdGhlIGVycm9yIG51bWJlclxyXG4vKiBlMzhjICovICAgICAgICAgICAgICAgICAgIEJNSS5yZWwgKFwiX2UzOTFcIik7ICAgICAgICAgICAgLy8gaWYgLXZlIGdvIGRvIHdhcm0gc3RhcnRcclxuLyogZTM4ZSAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9hNDNhXCIpOyAgICAgICAgICAgIC8vIGVsc2UgZG8gZXJyb3IgI1ggdGhlbiB3YXJtIHN0YXJ0XHJcbi8qIGUzOTEgKi8gICAgICAgIF9gX2UzOTFgOyAgSk1QLmFicyAoXCJyZWFkeV9hNDc0XCIpOyAgICAgICAvLyBkbyB3YXJtIHN0YXJ0XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIEJBU0lDIGNvbGQgc3RhcnQgZW50cnkgcG9pbnRcclxuLyogZTM5NCAqLyAgICBfYGluaXRfZTM5NGA7ICBKU1IuYWJzIChcImluaXR2X2U0NTNcIik7ICAgICAgIC8vIGluaXRpYWxpc2UgdGhlIEJBU0lDIHZlY3RvciB0YWJsZVxyXG4vKiBlMzk3ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiaW5pdGN6X2UzYmZcIik7ICAgICAgLy8gaW5pdGlhbGlzZSB0aGUgQkFTSUMgUkFNIGxvY2F0aW9uc1xyXG4vKiBlMzlhICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiaW5pdG1zX2U0MjJcIik7ICAgICAgLy8gcHJpbnQgdGhlIHN0YXJ0IHVwIG1lc3NhZ2UgYW5kIGluaXRpYWxpc2UgdGhlIG1lbW9yeVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBvaW50ZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IG9rID8/XHJcbi8qIGUzOWQgKi8gICAgICAgICAgICAgICAgICAgTERYLmltbSAoMHhmYik7ICAgICAgICAgICAgICAgLy8gdmFsdWUgZm9yIHN0YXJ0IHN0YWNrXHJcbi8qIGUzOWYgKi8gICAgICAgICAgICAgICAgICAgVFhTLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2V0IHN0YWNrIHBvaW50ZXJcclxuLyogZTNhMCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9lMzg2XCIpOyAgICAgICAgICAgIC8vIGRvIFwiUkVBRFkuXCIgd2FybSBzdGFydCwgYnJhbmNoIGFsd2F5c1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBjaGFyYWN0ZXIgZ2V0IHN1YnJvdXRpbmUgZm9yIHplcm8gcGFnZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSB0YXJnZXQgYWRkcmVzcyBmb3IgdGhlIExEQSAkRUE2MCBiZWNvbWVzIHRoZSBCQVNJQyBleGVjdXRlIHBvaW50ZXIgb25jZSB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBibG9jayBpcyBjb3BpZWQgdG8gaXRzIGRlc3RpbmF0aW9uLCBhbnkgbm9uIHplcm8gcGFnZSBhZGRyZXNzIHdpbGwgZG8gYXQgYXNzZW1ibHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aW1lLCB0byBhc3NlbWJsZSBhIHRocmVlIGJ5dGUgaW5zdHJ1Y3Rpb24uICRFQTYwIGlzIFJUUywgTk9QLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhZ2UgMCBpbml0aWFsaXNhdGlvbiB0YWJsZSBmcm9tICQwMDczXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGFuZCBzY2FuIG1lbW9yeVxyXG4vKiBlM2EyICovICBfYGluaXRhdF9lM2EyYDsgIElOQy56cGcgKFwidHh0cHRyKzBfMDA3YVwiKTsgICAgLy8gaW5jcmVtZW50IEJBU0lDIGV4ZWN1dGUgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBlM2E0ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2UzYThcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vIGNhcnJ5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZVxyXG4vKiBlM2E2ICovICAgICAgICAgICAgICAgICAgIElOQy56cGcgKFwidHh0cHRyKzFfMDA3YlwiKTsgICAgLy8gaW5jcmVtZW50IEJBU0lDIGV4ZWN1dGUgcG9pbnRlciBoaWdoIGJ5dGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwYWdlIDAgaW5pdGlhbGlzYXRpb24gdGFibGUgZnJvbSAkMDA3OVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNjYW4gbWVtb3J5XHJcbi8qIGUzYTggKi8gICAgICAgIF9gX2UzYThgOyAgTERBLmFicyAoMHhlYTYwKTsgICAgICAgICAgICAgLy8gZ2V0IGJ5dGUgdG8gc2NhbiwgYWRkcmVzcyBzZXQgYnkgY2FsbCByb3V0aW5lXHJcbi8qIGUzYWIgKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHgzYSk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIFwiOlwiXHJcbi8qIGUzYWQgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfZTNiOVwiKTsgICAgICAgICAgICAvLyBleGl0IGlmPj1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwYWdlIDAgaW5pdGlhbGlzYXRpb24gdGFibGUgZnJvbSAkMDA4MFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIENiIGlmIG51bWVyaWNcclxuLyogZTNhZiAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW1tICgweDIwKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggXCIgXCJcclxuLyogZTNiMSAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcImluaXRhdF9lM2EyXCIpOyAgICAgIC8vIGlmIFwiIFwiIGdvIGRvIG5leHRcclxuLyogZTNiMyAqLyAgICAgICAgICAgICAgICAgICBTRUMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzZXQgY2FycnkgZm9yIFNCQ1xyXG4vKiBlM2I0ICovICAgICAgICAgICAgICAgICAgIFNCQy5pbW0gKDB4MzApOyAgICAgICAgICAgICAgIC8vIHN1YnRyYWN0IFwiMFwiXHJcbi8qIGUzYjYgKi8gICAgICAgICAgICAgICAgICAgU0VDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2V0IGNhcnJ5IGZvciBTQkNcclxuLyogZTNiNyAqLyAgICAgICAgICAgICAgICAgICBTQkMuaW1tICgweGQwKTsgICAgICAgICAgICAgICAvLyBzdWJ0cmFjdCAtXCIwXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBjYXJyeSBpZiBieXRlID0gXCIwXCItXCI5XCJcclxuLyogZTNiOSAqLyAgICAgICAgX2BfZTNiOWA7ICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzcGFyZSBieXRlcywgbm90IHJlZmVyZW5jZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwLjgxMTYzNTE1N1xyXG4vKiBlM2JhICovICBfYHJuZHNlZF9lM2JhYDsgIF8uYnl0ZXMoMHg4MCwgMHg0ZiwgMHhjNywgMHg1MiwgMHg1OCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGluaXRpYWxpc2UgQkFTSUMgUkFNIGxvY2F0aW9uc1xyXG4vKiBlM2JmICovICBfYGluaXRjel9lM2JmYDsgIExEQS5pbW0gKDB4NGMpOyAgICAgICAgICAgICAgIC8vIG9wY29kZSBmb3IgSk1QXHJcbi8qIGUzYzEgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJqbXBlciswXzAwNTRcIik7ICAgICAvLyBzYXZlIGZvciBmdW5jdGlvbnMgdmVjdG9yIGp1bXBcclxuLyogZTNjMyAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcInVzcnBva18wMzEwXCIpOyAgICAgIC8vIHNhdmUgZm9yIFVTUigpIHZlY3RvciBqdW1wXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IFVTUigpIHZlY3RvciB0byBpbGxlZ2FsIHF1YW50aXR5IGVycm9yXHJcbi8qIGUzYzYgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHg0OCk7ICAgICAgICAgICAgICAgLy8gc2V0IFVTUigpIHZlY3RvciBsb3cgYnl0ZVxyXG4vKiBlM2M4ICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4YjIpOyAgICAgICAgICAgICAgIC8vIHNldCBVU1IoKSB2ZWN0b3IgaGlnaCBieXRlXHJcbi8qIGUzY2EgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJ1c3JhZGQrMF8wMzExXCIpOyAgICAvLyBzYXZlIFVTUigpIHZlY3RvciBsb3cgYnl0ZVxyXG4vKiBlM2NkICovICAgICAgICAgICAgICAgICAgIFNUWS5hYnMgKFwidXNyYWRkKzFfMDMxMlwiKTsgICAgLy8gc2F2ZSBVU1IoKSB2ZWN0b3IgaGlnaCBieXRlXHJcbi8qIGUzZDAgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHg5MSk7ICAgICAgICAgICAgICAgLy8gc2V0IGZpeGVkIHRvIGZsb2F0IHZlY3RvciBsb3cgYnl0ZVxyXG4vKiBlM2QyICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4YjMpOyAgICAgICAgICAgICAgIC8vIHNldCBmaXhlZCB0byBmbG9hdCB2ZWN0b3IgaGlnaCBieXRlXHJcbi8qIGUzZDQgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJhZHJheTIrMF8wMDA1XCIpOyAgICAvLyBzYXZlIGZpeGVkIHRvIGZsb2F0IHZlY3RvciBsb3cgYnl0ZVxyXG4vKiBlM2Q2ICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwiYWRyYXkyKzFfMDAwNlwiKTsgICAgLy8gc2F2ZSBmaXhlZCB0byBmbG9hdCB2ZWN0b3IgaGlnaCBieXRlXHJcbi8qIGUzZDggKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHhhYSk7ICAgICAgICAgICAgICAgLy8gc2V0IGZsb2F0IHRvIGZpeGVkIHZlY3RvciBsb3cgYnl0ZVxyXG4vKiBlM2RhICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4YjEpOyAgICAgICAgICAgICAgIC8vIHNldCBmbG9hdCB0byBmaXhlZCB2ZWN0b3IgaGlnaCBieXRlXHJcbi8qIGUzZGMgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJhZHJheTErMF8wMDAzXCIpOyAgICAvLyBzYXZlIGZsb2F0IHRvIGZpeGVkIHZlY3RvciBsb3cgYnl0ZVxyXG4vKiBlM2RlICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwiYWRyYXkxKzFfMDAwNFwiKTsgICAgLy8gc2F2ZSBmbG9hdCB0byBmaXhlZCB2ZWN0b3IgaGlnaCBieXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29weSB0aGUgY2hhcmFjdGVyIGdldCBzdWJyb3V0aW5lIGZyb20gJEUzQTIgdG8gJDAwNzRcclxuLyogZTNlMCAqLyAgICAgICAgICAgICAgICAgICBMRFguaW1tICgweDFjKTsgICAgICAgICAgICAgICAvLyBzZXQgdGhlIGJ5dGUgY291bnRcclxuLyogZTNlMiAqLyAgICAgICAgX2BfZTNlMmA7ICBMREEuYWJ4IChcImluaXRhdF9lM2EyXCIpOyAgICAgIC8vIGdldCBhIGJ5dGUgZnJvbSB0aGUgdGFibGVcclxuLyogZTNlNSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenB4ICgweDczKTsgICAgICAgICAgICAgICAvLyBzYXZlIHRoZSBieXRlIGluIHBhZ2UgemVyb1xyXG4vKiBlM2U3ICovICAgICAgICAgICAgICAgICAgIERFWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCB0aGUgY291bnRcclxuLyogZTNlOCAqLyAgICAgICAgICAgICAgICAgICBCUEwucmVsIChcIl9lM2UyXCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgbm90IGFsbCBkb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgZGVzY3JpcHRvcnMsIHN0cmluZ3MsIHByb2dyYW0gYXJlYSBhbmQgbWFtb3J5IHBvaW50ZXJzXHJcbi8qIGUzZWEgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMyk7ICAgICAgICAgICAgICAgLy8gc2V0IHRoZSBzdGVwIHNpemUsIGNvbGxlY3RpbmcgZGVzY3JpcHRvcnNcclxuLyogZTNlYyAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZvdXI2XzAwNTNcIik7ICAgICAgIC8vIHNhdmUgdGhlIGdhcmJhZ2UgY29sbGVjdGlvbiBzdGVwIHNpemVcclxuLyogZTNlZSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBBXHJcbi8qIGUzZjAgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJiaXRzXzAwNjhcIik7ICAgICAgICAvLyBjbGVhciBGQUMxIG92ZXJmbG93IGJ5dGVcclxuLyogZTNmMiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImNoYW5ubF8wMDEzXCIpOyAgICAgIC8vIGNsZWFyIHRoZSBjdXJyZW50IEkvTyBjaGFubmVsLCBmbGFnIGRlZmF1bHRcclxuLyogZTNmNCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImxhc3RwdCsxXzAwMThcIik7ICAgIC8vIGNsZWFyIHRoZSBjdXJyZW50IGRlc2NyaXB0b3Igc3RhY2sgaXRlbSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBlM2Y2ICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4MDEpOyAgICAgICAgICAgICAgIC8vIHNldCBYXHJcbi8qIGUzZjggKi8gICAgICAgICAgICAgICAgICAgU1RYLmFicyAoXCJic3RhY2srMTkwXzAxZmRcIik7ICAvLyBzZXQgdGhlIGNoYWluIGxpbmsgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBlM2ZiICovICAgICAgICAgICAgICAgICAgIFNUWC5hYnMgKFwiYnN0YWNrKzE4OV8wMWZjXCIpOyAgLy8gc2V0IHRoZSBjaGFpbiBsaW5rIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGUzZmUgKi8gICAgICAgICAgICAgICAgICAgTERYLmltbSAoMHgxOSk7ICAgICAgICAgICAgICAgLy8gaW5pdGlhbCB0aGUgdmFsdWUgZm9yIGRlc2NyaXB0b3Igc3RhY2tcclxuLyogZTQwMCAqLyAgICAgICAgICAgICAgICAgICBTVFguenBnIChcInRlbXBwdF8wMDE2XCIpOyAgICAgIC8vIHNldCBkZXNjcmlwdG9yIHN0YWNrIHBvaW50ZXJcclxuLyogZTQwMiAqLyAgICAgICAgICAgICAgICAgICBTRUMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzZXQgQ2IgPSAxIHRvIHJlYWQgdGhlIGJvdHRvbSBvZiBtZW1vcnlcclxuLyogZTQwMyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIm1lbWJvdF9mZjljXCIpOyAgICAgIC8vIHJlYWQvc2V0IHRoZSBib3R0b20gb2YgbWVtb3J5XHJcbi8qIGU0MDYgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJ0eHR0YWIrMF8wMDJiXCIpOyAgICAvLyBzYXZlIHRoZSBzdGFydCBvZiBtZW1vcnkgbG93IGJ5dGVcclxuLyogZTQwOCAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcInR4dHRhYisxXzAwMmNcIik7ICAgIC8vIHNhdmUgdGhlIHN0YXJ0IG9mIG1lbW9yeSBoaWdoIGJ5dGVcclxuLyogZTQwYSAqLyAgICAgICAgICAgICAgICAgICBTRUMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzZXQgQ2IgPSAxIHRvIHJlYWQgdGhlIHRvcCBvZiBtZW1vcnlcclxuLyogZTQwYiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIm1lbXRvcF9mZjk5XCIpOyAgICAgIC8vIHJlYWQvc2V0IHRoZSB0b3Agb2YgbWVtb3J5XHJcbi8qIGU0MGUgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJtZW1zaXorMF8wMDM3XCIpOyAgICAvLyBzYXZlIHRoZSBlbmQgb2YgbWVtb3J5IGxvdyBieXRlXHJcbi8qIGU0MTAgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJtZW1zaXorMV8wMDM4XCIpOyAgICAvLyBzYXZlIHRoZSBlbmQgb2YgbWVtb3J5IGhpZ2ggYnl0ZVxyXG4vKiBlNDEyICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwiZnJldG9wKzBfMDAzM1wiKTsgICAgLy8gc2V0IHRoZSBib3R0b20gb2Ygc3RyaW5nIHNwYWNlIGxvdyBieXRlXHJcbi8qIGU0MTQgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJmcmV0b3ArMV8wMDM0XCIpOyAgICAvLyBzZXQgdGhlIGJvdHRvbSBvZiBzdHJpbmcgc3BhY2UgaGlnaCBieXRlXHJcbi8qIGU0MTYgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgdGhlIGluZGV4XHJcbi8qIGU0MTggKi8gICAgICAgICAgICAgICAgICAgVFlBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgdGhlIEFcclxuLyogZTQxOSAqLyAgICAgICAgICAgICAgICAgICBTVEEuaW55IChcInR4dHRhYiswXzAwMmJcIik7ICAgIC8vIGNsZWFyIHRoZSB0aGUgZmlyc3QgYnl0ZSBvZiBtZW1vcnlcclxuLyogZTQxYiAqLyAgICAgICAgICAgICAgICAgICBJTkMuenBnIChcInR4dHRhYiswXzAwMmJcIik7ICAgIC8vIGluY3JlbWVudCB0aGUgc3RhcnQgb2YgbWVtb3J5IGxvdyBieXRlXHJcbi8qIGU0MWQgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZTQyMVwiKTsgICAgICAgICAgICAvLyBpZiBubyByb2xsb3ZlciBza2lwIHRoZSBoaWdoIGJ5dGUgaW5jcmVtZW50XHJcbi8qIGU0MWYgKi8gICAgICAgICAgICAgICAgICAgSU5DLnpwZyAoXCJ0eHR0YWIrMV8wMDJjXCIpOyAgICAvLyBpbmNyZW1lbnQgc3RhcnQgb2YgbWVtb3J5IGhpZ2ggYnl0ZVxyXG4vKiBlNDIxICovICAgICAgICBfYF9lNDIxYDsgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHByaW50IHRoZSBzdGFydCB1cCBtZXNzYWdlIGFuZCBpbml0aWFsaXNlIHRoZSBtZW1vcnkgcG9pbnRlcnNcclxuLyogZTQyMiAqLyAgX2Bpbml0bXNfZTQyMmA7ICBMREEuenBnIChcInR4dHRhYiswXzAwMmJcIik7ICAgIC8vIGdldCB0aGUgc3RhcnQgb2YgbWVtb3J5IGxvdyBieXRlXHJcbi8qIGU0MjQgKi8gICAgICAgICAgICAgICAgICAgTERZLnpwZyAoXCJ0eHR0YWIrMV8wMDJjXCIpOyAgICAvLyBnZXQgdGhlIHN0YXJ0IG9mIG1lbW9yeSBoaWdoIGJ5dGVcclxuLyogZTQyNiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcInJlYXNvbl9hNDA4XCIpOyAgICAgIC8vIGNoZWNrIGF2YWlsYWJsZSBtZW1vcnksIGRvIG91dCBvZiBtZW1vcnkgZXJyb3IgaWYgbm8gcm9vbVxyXG4vKiBlNDI5ICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4NzMpOyAgICAgICAgICAgICAgIC8vIHNldCBcIioqKiogQ09NTU9ET1JFIDY0IEJBU0lDIFYyICoqKipcIiBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGU0MmIgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHhlNCk7ICAgICAgICAgICAgICAgLy8gc2V0IFwiKioqKiBDT01NT0RPUkUgNjQgQkFTSUMgVjIgKioqKlwiIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGU0MmQgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJzdHJvdXRfYWIxZVwiKTsgICAgICAvLyBwcmludCBhIG51bGwgdGVybWluYXRlZCBzdHJpbmdcclxuLyogZTQzMCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcIm1lbXNpeiswXzAwMzdcIik7ICAgIC8vIGdldCB0aGUgZW5kIG9mIG1lbW9yeSBsb3cgYnl0ZVxyXG4vKiBlNDMyICovICAgICAgICAgICAgICAgICAgIFNFQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNldCBjYXJyeSBmb3Igc3VidHJhY3RcclxuLyogZTQzMyAqLyAgICAgICAgICAgICAgICAgICBTQkMuenBnIChcInR4dHRhYiswXzAwMmJcIik7ICAgIC8vIHN1YnRyYWN0IHRoZSBzdGFydCBvZiBtZW1vcnkgbG93IGJ5dGVcclxuLyogZTQzNSAqLyAgICAgICAgICAgICAgICAgICBUQVguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IHRoZSByZXN1bHQgdG8gWFxyXG4vKiBlNDM2ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwibWVtc2l6KzFfMDAzOFwiKTsgICAgLy8gZ2V0IHRoZSBlbmQgb2YgbWVtb3J5IGhpZ2ggYnl0ZVxyXG4vKiBlNDM4ICovICAgICAgICAgICAgICAgICAgIFNCQy56cGcgKFwidHh0dGFiKzFfMDAyY1wiKTsgICAgLy8gc3VidHJhY3QgdGhlIHN0YXJ0IG9mIG1lbW9yeSBoaWdoIGJ5dGVcclxuLyogZTQzYSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImxpbnBydF9iZGNkXCIpOyAgICAgIC8vIHByaW50IFhBIGFzIHVuc2lnbmVkIGludGVnZXJcclxuLyogZTQzZCAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDYwKTsgICAgICAgICAgICAgICAvLyBzZXQgXCIgQllURVMgRlJFRVwiIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogZTQzZiAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweGU0KTsgICAgICAgICAgICAgICAvLyBzZXQgXCIgQllURVMgRlJFRVwiIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGU0NDEgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJzdHJvdXRfYWIxZVwiKTsgICAgICAvLyBwcmludCBhIG51bGwgdGVybWluYXRlZCBzdHJpbmdcclxuLyogZTQ0NCAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9hNjQ0XCIpOyAgICAgICAgICAgIC8vIGRvIE5FVywgQ0xFQVIsIFJFU1RPUkUgYW5kIHJldHVyblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBCQVNJQyB2ZWN0b3JzLCB0aGVzZSBhcmUgY29waWVkIHRvIFJBTSBmcm9tICQwMzAwIG9ud2FyZHNcclxuLyogZTQ0NyAqLyAgIF9gYnZ0cnNfZTQ0N2A7ICBfLmJ5dGVzKDB4OGIsIDB4ZTMpOyAgICAgICAgICAvLyBlcnJvciBtZXNzYWdlICAgICAgICAgICQwMzAwXHJcbi8qIGU0NDkgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDgzLCAweGE0KTsgICAgICAgICAgLy8gQkFTSUMgd2FybSBzdGFydCAgICAgICAkMDMwMlxyXG4vKiBlNDRiICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg3YywgMHhhNSk7ICAgICAgICAgIC8vIGNydW5jaCBCQVNJQyB0b2tlbnMgICAgJDAzMDRcclxuLyogZTQ0ZCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MWEsIDB4YTcpOyAgICAgICAgICAvLyB1bmNydW5jaCBCQVNJQyB0b2tlbnMgICQwMzA2XHJcbi8qIGU0NGYgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweGU0LCAweGE3KTsgICAgICAgICAgLy8gc3RhcnQgbmV3IEJBU0lDIGNvZGUgICAkMDMwOFxyXG4vKiBlNDUxICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg4NiwgMHhhZSk7ICAgICAgICAgIC8vIGdldCBhcml0aG1ldGljIGVsZW1lbnQgJDAzMEFcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gaW5pdGlhbGlzZSB0aGUgQkFTSUMgdmVjdG9yc1xyXG4vKiBlNDUzICovICAgX2Bpbml0dl9lNDUzYDsgIExEWC5pbW0gKDB4MGIpOyAgICAgICAgICAgICAgIC8vIHNldCBieXRlIGNvdW50XHJcbi8qIGU0NTUgKi8gICAgICAgIF9gX2U0NTVgOyAgTERBLmFieCAoXCJidnRyc19lNDQ3XCIpOyAgICAgICAvLyBnZXQgYnl0ZSBmcm9tIHRhYmxlXHJcbi8qIGU0NTggKi8gICAgICAgICAgICAgICAgICAgU1RBLmFieCAoXCJpZXJyb3IrMF8wMzAwXCIpOyAgICAvLyBzYXZlIGJ5dGUgdG8gUkFNXHJcbi8qIGU0NWIgKi8gICAgICAgICAgICAgICAgICAgREVYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZGVjcmVtZW50IGluZGV4XHJcbi8qIGU0NWMgKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfZTQ1NVwiKTsgICAgICAgICAgICAvLyBsb29wIGlmIG1vcmUgdG8gZG9cclxuLyogZTQ1ZSAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBCQVNJQyBzdGFydHVwIG1lc3NhZ2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmFzaWMgYnl0ZXMgZnJlZVxyXG4vKiBlNDVmICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgwMCwgMHgyMCwgMHg0MiwgMHg0MSwgMHg1MywgMHg0OSwgMHg0MywgMHgyMCk7XHJcbi8qIGU0NjcgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDQyLCAweDU5LCAweDU0LCAweDQ1LCAweDUzLCAweDIwLCAweDQ2LCAweDUyKTtcclxuLyogZTQ2ZiAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NDUsIDB4NDUsIDB4MGQsIDB4MDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIChjbHIpICoqKiogY29tbW9kb3JlIDY0IGJhc2ljIHYyICoqKipcclxuLyogZTQ3MyAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4OTMsIDB4MGQsIDB4MjAsIDB4MjAsIDB4MjAsIDB4MjAsIDB4MmEsIDB4MmEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIChjcikgKGNyKSA2NGsgcmFtIHN5c3RlbVxyXG4vKiBlNDdiICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgyYSwgMHgyYSwgMHgyMCwgMHg0MywgMHg0ZiwgMHg0ZCwgMHg0ZCwgMHg0Zik7XHJcbi8qIGU0ODMgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDQ0LCAweDRmLCAweDUyLCAweDQ1LCAweDIwLCAweDM2LCAweDM0LCAweDIwKTtcclxuLyogZTQ4YiAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NDIsIDB4NDEsIDB4NTMsIDB4NDksIDB4NDMsIDB4MjAsIDB4NTYsIDB4MzIpO1xyXG4vKiBlNDkzICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgyMCwgMHgyYSwgMHgyYSwgMHgyYSwgMHgyYSwgMHgwZCwgMHgwZCwgMHgyMCk7XHJcbi8qIGU0OWIgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDM2LCAweDM0LCAweDRiLCAweDIwLCAweDUyLCAweDQxLCAweDRkLCAweDIwKTtcclxuLyogZTRhMyAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NTMsIDB4NTksIDB4NTMsIDB4NTQsIDB4NDUsIDB4NGQsIDB4MjAsIDB4MjApO1xyXG4vKiBlNGFiICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgwMCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHVudXNlZFxyXG4vKiBlNGFjICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg4MSk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIG9wZW4gY2hhbm5lbCBmb3Igb3V0cHV0XHJcbi8qIGU0YWQgKi8gICAgICAgIF9gX2U0YWRgOyAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSB0aGUgZmxhZyBieXRlXHJcbi8qIGU0YWUgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJjaGtvdXRfZmZjOVwiKTsgICAgICAvLyBvcGVuIGNoYW5uZWwgZm9yIG91dHB1dFxyXG4vKiBlNGIxICovICAgICAgICAgICAgICAgICAgIFRBWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgdGhlIHJldHVybmVkIGZsYWcgYnl0ZVxyXG4vKiBlNGIyICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgdGhlIGFsbGluZyBmbGFnIGJ5dGVcclxuLyogZTRiMyAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9lNGI2XCIpOyAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGVycm9yIHNraXAgY29weWluZyB0aGUgZXJyb3IgZmxhZ1xyXG4vKiBlNGI1ICovICAgICAgICAgICAgICAgICAgIFRYQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgY29weSB0aGUgZXJyb3IgZmxhZ1xyXG4vKiBlNGI2ICovICAgICAgICBfYF9lNGI2YDsgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHVudXNlZCBieXRlc1xyXG4vKiBlNGI3ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHhhYSwgMHhhYSwgMHhhYSwgMHhhYSwgMHhhYSwgMHhhYSwgMHhhYSwgMHhhYSk7XHJcbi8qIGU0YmYgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweGFhLCAweGFhLCAweGFhLCAweGFhLCAweGFhLCAweGFhLCAweGFhLCAweGFhKTtcclxuLyogZTRjNyAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4YWEsIDB4YWEsIDB4YWEsIDB4YWEsIDB4YWEsIDB4YWEsIDB4YWEsIDB4YWEpO1xyXG4vKiBlNGNmICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHhhYSwgMHhhYSwgMHhhYSwgMHhhYSk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGZsYWcgdGhlIFJTMjMyIHN0YXJ0IGJpdCBhbmQgc2V0IHRoZSBwYXJpdHlcclxuLyogZTRkMyAqLyAgICAgICAgX2BfZTRkM2A7ICBTVEEuenBnIChcInJpbm9uZV8wMGE5XCIpOyAgICAgIC8vIHNhdmUgdGhlIHN0YXJ0IGJpdCBjaGVjayBmbGFnLCBzZXQgc3RhcnQgYml0IHJlY2VpdmVkXHJcbi8qIGU0ZDUgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMSk7ICAgICAgICAgICAgICAgLy8gc2V0IHRoZSBpbml0aWFsIHBhcml0eSBzdGF0ZVxyXG4vKiBlNGQ3ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwicmlwcnR5XzAwYWJcIik7ICAgICAgLy8gc2F2ZSB0aGUgcmVjZWl2ZXIgcGFyaXR5IGJpdFxyXG4vKiBlNGQ5ICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHNhdmUgdGhlIGN1cnJlbnQgY29sb3VyIHRvIHRoZSBjb2xvdXIgUkFNXHJcbi8qIGU0ZGEgKi8gICAgICAgIF9gX2U0ZGFgOyAgTERBLmFicyAoXCJjb2xvcl8wMjg2XCIpOyAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgY29sb3VyIGNvZGVcclxuLyogZTRkZCAqLyAgICAgICAgICAgICAgICAgICBTVEEuaW55IChcInVzZXIrMF8wMGYzXCIpOyAgICAgIC8vIHNhdmUgaXQgdG8gdGhlIGNvbG91ciBSQU1cclxuLyogZTRkZiAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyB3YWl0IH44LjUgc2Vjb25kcyBmb3IgYW55IGtleSBmcm9tIHRoZSBTVE9QIGtleSBjb2x1bW5cclxuLyogZTRlMCAqLyAgICAgICAgX2BfZTRlMGA7ICBBREMuaW1tICgweDAyKTsgICAgICAgICAgICAgICAvLyBzZXQgdGhlIG51bWJlciBvZiBqaWZmaWVzIHRvIHdhaXRcclxuLyogZTRlMiAqLyAgICAgICAgX2BfZTRlMmA7ICBMRFkuenBnIChcInN0a2V5XzAwOTFcIik7ICAgICAgIC8vIHJlYWQgdGhlIHN0b3Aga2V5IGNvbHVtblxyXG4vKiBlNGU0ICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHRlc3QgZm9yICRGRiwgbm8ga2V5cyBwcmVzc2VkXHJcbi8qIGU0ZTUgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZTRlYlwiKTsgICAgICAgICAgICAvLyBpZiBhbnkga2V5cyB3ZXJlIHByZXNzZWQganVzdCBleGl0XHJcbi8qIGU0ZTcgKi8gICAgICAgICAgICAgICAgICAgQ01QLnpwZyAoXCJ0aW1lKzFfMDBhMVwiKTsgICAgICAvLyBjb21wYXJlIHRoZSB3YWl0IHRpbWUgd2l0aCB0aGUgamlmZnkgY2xvY2sgbWlkIGJ5dGVcclxuLyogZTRlOSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9lNGUyXCIpOyAgICAgICAgICAgIC8vIGlmIG5vdCB0aGVyZSB5ZXQgZ28gd2FpdCBzb21lIG1vcmVcclxuLyogZTRlYiAqLyAgICAgICAgX2BfZTRlYmA7ICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBiYXVkIHJhdGUgdGFibGVzIGZvciBQQUwgQzY0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmF1ZCByYXRlIHdvcmQgaXMgY2FsY3VsYXRlZCBmcm9tIC4uXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIChzeXN0ZW0gY2xvY2sgLyBiYXVkIHJhdGUpIC8gMiAtIDEwMFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgc3lzdGVtIGNsb2NrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIC0tLS0tLS0tLS0tLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBBTCAgICAgICA5ODUyNDggSHpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOVFNDICAgICAxMDIyNzI3IEh6XHJcbi8qIGU0ZWMgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDE5LCAweDI2KTsgICAgICAgICAgLy8gICA1MCAgIGJhdWQgICA5ODUzMDBcclxuLyogZTRlZSAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NDQsIDB4MTkpOyAgICAgICAgICAvLyAgIDc1ICAgYmF1ZCAgIDk4NTIwMFxyXG4vKiBlNGYwICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgxYSwgMHgxMSk7ICAgICAgICAgIC8vICAxMTAgICBiYXVkICAgOTg1MTYwXHJcbi8qIGU0ZjIgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweGU4LCAweDBkKTsgICAgICAgICAgLy8gIDEzNC41IGJhdWQgICA5ODQ1NDBcclxuLyogZTRmNCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NzAsIDB4MGMpOyAgICAgICAgICAvLyAgMTUwICAgYmF1ZCAgIDk4NTIwMFxyXG4vKiBlNGY2ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgwNiwgMHgwNik7ICAgICAgICAgIC8vICAzMDAgICBiYXVkICAgOTg1MjAwXHJcbi8qIGU0ZjggKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweGQxLCAweDAyKTsgICAgICAgICAgLy8gIDYwMCAgIGJhdWQgICA5ODUyMDBcclxuLyogZTRmYSAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MzcsIDB4MDEpOyAgICAgICAgICAvLyAxMjAwICAgYmF1ZCAgIDk4NjQwMFxyXG4vKiBlNGZjICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHhhZSwgMHgwMCk7ICAgICAgICAgIC8vIDE4MDAgICBiYXVkICAgOTg2NDAwXHJcbi8qIGU0ZmUgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDY5LCAweDAwKTsgICAgICAgICAgLy8gMjQwMCAgIGJhdWQgICA5ODQwMDBcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcmV0dXJuIHRoZSBiYXNlIGFkZHJlc3Mgb2YgdGhlIEkvTyBkZXZpY2VzXHJcbi8qIGU1MDAgKi8gIF9gaW9iYXNlX2U1MDBgOyAgTERYLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBJL08gYmFzZSBhZGRyZXNzIGxvdyBieXRlXHJcbi8qIGU1MDIgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHhkYyk7ICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBJL08gYmFzZSBhZGRyZXNzIGhpZ2ggYnl0ZVxyXG4vKiBlNTA0ICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHJldHVybiB0aGUgeCx5IG9yZ2FuaXphdGlvbiBvZiB0aGUgc2NyZWVuXHJcbi8qIGU1MDUgKi8gIF9gc2NyZWVuX2U1MDVgOyAgTERYLmltbSAoMHgyOCk7ICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSB4IHNpemVcclxuLyogZTUwNyAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDE5KTsgICAgICAgICAgICAgICAvLyBnZXQgdGhlIHkgc2l6ZVxyXG4vKiBlNTA5ICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHJlYWQvc2V0IHRoZSB4LHkgY3Vyc29yIHBvc2l0aW9uXHJcbi8qIGU1MGEgKi8gICAgX2BwbG90X2U1MGFgOyAgQkNTLnJlbCAoXCJfZTUxM1wiKTsgICAgICAgICAgICAvLyBpZiByZWFkIGN1cnNvciBnbyBkbyByZWFkXHJcbi8qIGU1MGMgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJ0Ymx4XzAwZDZcIik7ICAgICAgICAvLyBzYXZlIHRoZSBjdXJzb3Igcm93XHJcbi8qIGU1MGUgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJwbnRyXzAwZDNcIik7ICAgICAgICAvLyBzYXZlIHRoZSBjdXJzb3IgY29sdW1uXHJcbi8qIGU1MTAgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZTU2Y1wiKTsgICAgICAgICAgICAvLyBzZXQgdGhlIHNjcmVlbiBwb2ludGVycyBmb3IgdGhlIGN1cnNvciByb3csIGNvbHVtblxyXG4vKiBlNTEzICovICAgICAgICBfYF9lNTEzYDsgIExEWC56cGcgKFwidGJseF8wMGQ2XCIpOyAgICAgICAgLy8gZ2V0IHRoZSBjdXJzb3Igcm93XHJcbi8qIGU1MTUgKi8gICAgICAgICAgICAgICAgICAgTERZLnpwZyAoXCJwbnRyXzAwZDNcIik7ICAgICAgICAvLyBnZXQgdGhlIGN1cnNvciBjb2x1bW5cclxuLyogZTUxNyAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBpbml0aWFsaXNlIHRoZSBzY3JlZW4gYW5kIGtleWJvYXJkXHJcbi8qIGU1MTggKi8gICBfYGNpbnQxX2U1MThgOyAgSlNSLmFicyAoXCJfZTVhMFwiKTsgICAgICAgICAgICAvLyBpbml0aWFsaXNlIHRoZSB2aWMgY2hpcFxyXG4vKiBlNTFiICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIEFcclxuLyogZTUxZCAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcIm1vZGVfMDI5MVwiKTsgICAgICAgIC8vIGNsZWFyIHRoZSBzaGlmdCBtb2RlIHN3aXRjaFxyXG4vKiBlNTIwICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiYmxub25fMDBjZlwiKTsgICAgICAgLy8gY2xlYXIgdGhlIGN1cnNvciBibGluayBwaGFzZVxyXG4vKiBlNTIyICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4NDgpOyAgICAgICAgICAgICAgIC8vIGdldCB0aGUga2V5Ym9hcmQgZGVjb2RlIGxvZ2ljIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogZTUyNCAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcImtleWxvZyswXzAyOGZcIik7ICAgIC8vIHNhdmUgdGhlIGtleWJvYXJkIGRlY29kZSBsb2dpYyBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGU1MjcgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHhlYik7ICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBrZXlib2FyZCBkZWNvZGUgbG9naWMgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogZTUyOSAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcImtleWxvZysxXzAyOTBcIik7ICAgIC8vIHNhdmUgdGhlIGtleWJvYXJkIGRlY29kZSBsb2dpYyBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBlNTJjICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MGEpOyAgICAgICAgICAgICAgIC8vIHNldCB0aGUgbWF4aW11bSBzaXplIG9mIHRoZSBrZXlib2FyZCBidWZmZXJcclxuLyogZTUyZSAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcInhtYXhfMDI4OVwiKTsgICAgICAgIC8vIHNhdmUgdGhlIG1heGltdW0gc2l6ZSBvZiB0aGUga2V5Ym9hcmQgYnVmZmVyXHJcbi8qIGU1MzEgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJkZWxheV8wMjhjXCIpOyAgICAgICAvLyBzYXZlIHRoZSByZXBlYXQgZGVsYXkgY291bnRlclxyXG4vKiBlNTM0ICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MGUpOyAgICAgICAgICAgICAgIC8vIHNldCBsaWdodCBibHVlXHJcbi8qIGU1MzYgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJjb2xvcl8wMjg2XCIpOyAgICAgICAvLyBzYXZlIHRoZSBjdXJyZW50IGNvbG91ciBjb2RlXHJcbi8qIGU1MzkgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwNCk7ICAgICAgICAgICAgICAgLy8gc3BlZWQgNFxyXG4vKiBlNTNiICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwia291bnRfMDI4YlwiKTsgICAgICAgLy8gc2F2ZSB0aGUgcmVwZWF0IHNwZWVkIGNvdW50ZXJcclxuLyogZTUzZSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDBjKTsgICAgICAgICAgICAgICAvLyBzZXQgdGhlIGN1cnNvciBmbGFzaCB0aW1pbmdcclxuLyogZTU0MCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImJsbmN0XzAwY2RcIik7ICAgICAgIC8vIHNhdmUgdGhlIGN1cnNvciB0aW1pbmcgY291bnRkb3duXHJcbi8qIGU1NDIgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJibG5zd18wMGNjXCIpOyAgICAgICAvLyBzYXZlIHRoZSBjdXJzb3IgZW5hYmxlLCAkMDAgPSBmbGFzaCBjdXJzb3JcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY2xlYXIgdGhlIHNjcmVlblxyXG4vKiBlNTQ0ICovICAgICAgICBfYF9lNTQ0YDsgIExEQS5hYnMgKFwiaGliYXNlXzAyODhcIik7ICAgICAgLy8gZ2V0IHRoZSBzY3JlZW4gbWVtb3J5IHBhZ2VcclxuLyogZTU0NyAqLyAgICAgICAgICAgICAgICAgICBPUkEuaW1tICgweDgwKTsgICAgICAgICAgICAgICAvLyBzZXQgdGhlIGhpZ2ggYml0LCBmbGFnIGV2ZXJ5IGxpbmUgaXMgYSBsb2dpY2FsIGxpbmUgc3RhcnRcclxuLyogZTU0OSAqLyAgICAgICAgICAgICAgICAgICBUQVkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IHRvIFlcclxuLyogZTU0YSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciB0aGUgbGluZSBzdGFydCBsb3cgYnl0ZVxyXG4vKiBlNTRjICovICAgICAgICAgICAgICAgICAgIFRBWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIHRoZSBpbmRleFxyXG4vKiBlNTRkICovICAgICAgICBfYF9lNTRkYDsgIFNUWS56cHggKDB4ZDkpOyAgICAgICAgICAgICAgIC8vIHNhdmUgdGhlIHN0YXJ0IG9mIGxpbmUgWCBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBlNTRmICovICAgICAgICAgICAgICAgICAgIENMQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIGNhcnJ5IGZvciBhZGRcclxuLyogZTU1MCAqLyAgICAgICAgICAgICAgICAgICBBREMuaW1tICgweDI4KTsgICAgICAgICAgICAgICAvLyBhZGQgdGhlIGxpbmUgbGVuZ3RoIHRvIHRoZSBsb3cgYnl0ZVxyXG4vKiBlNTUyICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2U1NTVcIik7ICAgICAgICAgICAgLy8gaWYgbm8gcm9sbG92ZXIgc2tpcCB0aGUgaGlnaCBieXRlIGluY3JlbWVudFxyXG4vKiBlNTU0ICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgaW5jcmVtZW50IHRoZSBoaWdoIGJ5dGVcclxuLyogZTU1NSAqLyAgICAgICAgX2BfZTU1NWA7ICBJTlguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgdGhlIGxpbmUgaW5kZXhcclxuLyogZTU1NiAqLyAgICAgICAgICAgICAgICAgICBDUFguaW1tICgweDFhKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIGl0IHdpdGggdGhlIG51bWJlciBvZiBsaW5lcyArIDFcclxuLyogZTU1OCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9lNTRkXCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgbm90IGFsbCBkb25lXHJcbi8qIGU1NWEgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHhmZik7ICAgICAgICAgICAgICAgLy8gc2V0IHRoZSBlbmQgb2YgdGFibGUgbWFya2VyXHJcbi8qIGU1NWMgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpweCAoMHhkOSk7ICAgICAgICAgICAgICAgLy8gbWFyayB0aGUgZW5kIG9mIHRoZSB0YWJsZVxyXG4vKiBlNTVlICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4MTgpOyAgICAgICAgICAgICAgIC8vIHNldCB0aGUgbGluZSBjb3VudCwgMjUgbGluZXMgdG8gZG8sIDAgdG8gMjRcclxuLyogZTU2MCAqLyAgICAgICAgX2BfZTU2MGA7ICBKU1IuYWJzIChcIl9lOWZmXCIpOyAgICAgICAgICAgIC8vIGNsZWFyIHNjcmVlbiBsaW5lIFhcclxuLyogZTU2MyAqLyAgICAgICAgICAgICAgICAgICBERVguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBkZWNyZW1lbnQgdGhlIGNvdW50XHJcbi8qIGU1NjQgKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfZTU2MFwiKTsgICAgICAgICAgICAvLyBsb29wIGlmIG1vcmUgdG8gZG9cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gaG9tZSB0aGUgY3Vyc29yXHJcbi8qIGU1NjYgKi8gICAgICAgIF9gX2U1NjZgOyAgTERZLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgWVxyXG4vKiBlNTY4ICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwicG50cl8wMGQzXCIpOyAgICAgICAgLy8gY2xlYXIgdGhlIGN1cnNvciBjb2x1bW5cclxuLyogZTU2YSAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcInRibHhfMDBkNlwiKTsgICAgICAgIC8vIGNsZWFyIHRoZSBjdXJzb3Igcm93XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHNldCBzY3JlZW4gcG9pbnRlcnMgZm9yIGN1cnNvciByb3csIGNvbHVtblxyXG4vKiBlNTZjICovICAgICAgICBfYF9lNTZjYDsgIExEWC56cGcgKFwidGJseF8wMGQ2XCIpOyAgICAgICAgLy8gZ2V0IHRoZSBjdXJzb3Igcm93XHJcbi8qIGU1NmUgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJwbnRyXzAwZDNcIik7ICAgICAgICAvLyBnZXQgdGhlIGN1cnNvciBjb2x1bW5cclxuLyogZTU3MCAqLyAgICAgICAgX2BfZTU3MGA7ICBMRFkuenB4ICgweGQ5KTsgICAgICAgICAgICAgICAvLyBnZXQgc3RhcnQgb2YgbGluZSBYIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGU1NzIgKi8gICAgICAgICAgICAgICAgICAgQk1JLnJlbCAoXCJfZTU3Y1wiKTsgICAgICAgICAgICAvLyBpZiBpdCBpcyB0aGUgbG9naWNhbCBsaW5lIHN0YXJ0IGNvbnRpbnVlXHJcbi8qIGU1NzQgKi8gICAgICAgICAgICAgICAgICAgQ0xDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBjbGVhciBjYXJyeSBmb3IgYWRkXHJcbi8qIGU1NzUgKi8gICAgICAgICAgICAgICAgICAgQURDLmltbSAoMHgyOCk7ICAgICAgICAgICAgICAgLy8gYWRkIG9uZSBsaW5lIGxlbmd0aFxyXG4vKiBlNTc3ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwicG50cl8wMGQzXCIpOyAgICAgICAgLy8gc2F2ZSB0aGUgY3Vyc29yIGNvbHVtblxyXG4vKiBlNTc5ICovICAgICAgICAgICAgICAgICAgIERFWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCB0aGUgY3Vyc29yIHJvd1xyXG4vKiBlNTdhICovICAgICAgICAgICAgICAgICAgIEJQTC5yZWwgKFwiX2U1NzBcIik7ICAgICAgICAgICAgLy8gbG9vcCwgYnJhbmNoIGFsd2F5c1xyXG4vKiBlNTdjICovICAgICAgICBfYF9lNTdjYDsgIEpTUi5hYnMgKFwiX2U5ZjBcIik7ICAgICAgICAgICAgLy8gZmV0Y2ggYSBzY3JlZW4gYWRkcmVzc1xyXG4vKiBlNTdmICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MjcpOyAgICAgICAgICAgICAgIC8vIHNldCB0aGUgbGluZSBsZW5ndGhcclxuLyogZTU4MSAqLyAgICAgICAgICAgICAgICAgICBJTlguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgdGhlIGN1cnNvciByb3dcclxuLyogZTU4MiAqLyAgICAgICAgX2BfZTU4MmA7ICBMRFkuenB4ICgweGQ5KTsgICAgICAgICAgICAgICAvLyBnZXQgdGhlIHN0YXJ0IG9mIGxpbmUgWCBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBlNTg0ICovICAgICAgICAgICAgICAgICAgIEJNSS5yZWwgKFwiX2U1OGNcIik7ICAgICAgICAgICAgLy8gaWYgbG9naWNhbCBsaW5lIHN0YXJ0IGV4aXRcclxuLyogZTU4NiAqLyAgICAgICAgICAgICAgICAgICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBlbHNlIGNsZWFyIGNhcnJ5IGZvciBhZGRcclxuLyogZTU4NyAqLyAgICAgICAgICAgICAgICAgICBBREMuaW1tICgweDI4KTsgICAgICAgICAgICAgICAvLyBhZGQgb25lIGxpbmUgbGVuZ3RoIHRvIHRoZSBjdXJyZW50IGxpbmUgbGVuZ3RoXHJcbi8qIGU1ODkgKi8gICAgICAgICAgICAgICAgICAgSU5YLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IHRoZSBjdXJzb3Igcm93XHJcbi8qIGU1OGEgKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfZTU4MlwiKTsgICAgICAgICAgICAvLyBsb29wLCBicmFuY2ggYWx3YXlzXHJcbi8qIGU1OGMgKi8gICAgICAgIF9gX2U1OGNgOyAgU1RBLnpwZyAoXCJsbm14XzAwZDVcIik7ICAgICAgICAvLyBzYXZlIGN1cnJlbnQgc2NyZWVuIGxpbmUgbGVuZ3RoXHJcbi8qIGU1OGUgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZWEyNFwiKTsgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHBvaW50ZXIgdG8gY29sb3VyIFJBTSBhbmQgcmV0dXJuXHJcbi8qIGU1OTEgKi8gICAgICAgIF9gX2U1OTFgOyAgQ1BYLnpwZyAoXCJseHNwKzBfMDBjOVwiKTsgICAgICAvLyBjb21wYXJlIGl0IHdpdGggdGhlIGlucHV0IGN1cnNvciByb3dcclxuLyogZTU5MyAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9lNTk4XCIpOyAgICAgICAgICAgIC8vIGlmIHRoZXJlIGp1c3QgZXhpdFxyXG4vKiBlNTk1ICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2U2ZWRcIik7ICAgICAgICAgICAgLy8gZWxzZSBnbyA/P1xyXG4vKiBlNTk4ICovICAgICAgICBfYF9lNTk4YDsgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIG9ycGhhbiBieXRlcyA/P1xyXG4vKiBlNTk5ICovICAgICAgICAgICAgICAgICAgIE5PUC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGh1aFxyXG4vKiBlNTlhICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2U1YTBcIik7ICAgICAgICAgICAgLy8gaW5pdGlhbGlzZSB0aGUgdmljIGNoaXBcclxuLyogZTU5ZCAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9lNTY2XCIpOyAgICAgICAgICAgIC8vIGhvbWUgdGhlIGN1cnNvciBhbmQgcmV0dXJuXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGluaXRpYWxpc2UgdGhlIHZpYyBjaGlwXHJcbi8qIGU1YTAgKi8gICAgICAgIF9gX2U1YTBgOyAgTERBLmltbSAoMHgwMyk7ICAgICAgICAgICAgICAgLy8gc2V0IHRoZSBzY3JlZW4gYXMgdGhlIG91dHB1dCBkZXZpY2VcclxuLyogZTVhMiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImRmbHRvXzAwOWFcIik7ICAgICAgIC8vIHNhdmUgdGhlIG91dHB1dCBkZXZpY2UgbnVtYmVyXHJcbi8qIGU1YTQgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gc2V0IHRoZSBrZXlib2FyZCBhcyB0aGUgaW5wdXQgZGV2aWNlXHJcbi8qIGU1YTYgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJkZmx0bl8wMDk5XCIpOyAgICAgICAvLyBzYXZlIHRoZSBpbnB1dCBkZXZpY2UgbnVtYmVyXHJcbi8qIGU1YTggKi8gICAgICAgICAgICAgICAgICAgTERYLmltbSAoMHgyZik7ICAgICAgICAgICAgICAgLy8gc2V0IHRoZSBjb3VudC9pbmRleFxyXG4vKiBlNWFhICovICAgICAgICBfYF9lNWFhYDsgIExEQS5hYnggKFwiX2VjYjhcIik7ICAgICAgICAgICAgLy8gZ2V0IGEgdmljIGlpIGNoaXAgaW5pdGlhbGlzYXRpb24gdmFsdWVcclxuLyogZTVhZCAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJ4IChcIl9jZmZmXCIpOyAgICAgICAgICAgIC8vIHNhdmUgaXQgdG8gdGhlIHZpYyBpaSBjaGlwXHJcbi8qIGU1YjAgKi8gICAgICAgICAgICAgICAgICAgREVYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZGVjcmVtZW50IHRoZSBjb3VudC9pbmRleFxyXG4vKiBlNWIxICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2U1YWFcIik7ICAgICAgICAgICAgLy8gbG9vcCBpZiBtb3JlIHRvIGRvXHJcbi8qIGU1YjMgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gaW5wdXQgZnJvbSB0aGUga2V5Ym9hcmQgYnVmZmVyXHJcbi8qIGU1YjQgKi8gICAgIF9gbHAyX2U1YjRgOyAgTERZLmFicyAoXCJrZXlkKzBfMDI3N1wiKTsgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGZyb20gdGhlIGJ1ZmZlclxyXG4vKiBlNWI3ICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIHRoZSBpbmRleFxyXG4vKiBlNWI5ICovICAgICAgICBfYF9lNWI5YDsgIExEQS5hYnggKFwia2V5ZCsxXzAyNzhcIik7ICAgICAgLy8gZ2V0IHRoZSBuZXh0IGNoYXJhY3RlcixYIGZyb20gdGhlIGJ1ZmZlclxyXG4vKiBlNWJjICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnggKFwia2V5ZCswXzAyNzdcIik7ICAgICAgLy8gc2F2ZSBpdCBhcyB0aGUgY3VycmVudCBjaGFyYWN0ZXIsWCBpbiB0aGUgYnVmZmVyXHJcbi8qIGU1YmYgKi8gICAgICAgICAgICAgICAgICAgSU5YLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IHRoZSBpbmRleFxyXG4vKiBlNWMwICovICAgICAgICAgICAgICAgICAgIENQWC56cGcgKFwibmR4XzAwYzZcIik7ICAgICAgICAgLy8gY29tcGFyZSBpdCB3aXRoIHRoZSBrZXlib2FyZCBidWZmZXIgaW5kZXhcclxuLyogZTVjMiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9lNWI5XCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgbW9yZSB0byBkb1xyXG4vKiBlNWM0ICovICAgICAgICAgICAgICAgICAgIERFQy56cGcgKFwibmR4XzAwYzZcIik7ICAgICAgICAgLy8gZGVjcmVtZW50IGtleWJvYXJkIGJ1ZmZlciBpbmRleFxyXG4vKiBlNWM2ICovICAgICAgICAgICAgICAgICAgIFRZQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgdGhlIGtleSB0byBBXHJcbi8qIGU1YzcgKi8gICAgICAgICAgICAgICAgICAgQ0xJLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZW5hYmxlIHRoZSBpbnRlcnJ1cHRzXHJcbi8qIGU1YzggKi8gICAgICAgICAgICAgICAgICAgQ0xDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZmxhZyBnb3QgYnl0ZVxyXG4vKiBlNWM5ICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHdyaXRlIGNoYXJhY3RlciBhbmQgd2FpdCBmb3Iga2V5XHJcbi8qIGU1Y2EgKi8gICAgICAgIF9gX2U1Y2FgOyAgSlNSLmFicyAoXCJfZTcxNlwiKTsgICAgICAgICAgICAvLyBvdXRwdXQgY2hhcmFjdGVyXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHdhaXQgZm9yIGEga2V5IGZyb20gdGhlIGtleWJvYXJkXHJcbi8qIGU1Y2QgKi8gICAgICAgIF9gX2U1Y2RgOyAgTERBLnpwZyAoXCJuZHhfMDBjNlwiKTsgICAgICAgICAvLyBnZXQgdGhlIGtleWJvYXJkIGJ1ZmZlciBpbmRleFxyXG4vKiBlNWNmICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiYmxuc3dfMDBjY1wiKTsgICAgICAgLy8gY3Vyc29yIGVuYWJsZSwgJDAwID0gZmxhc2ggY3Vyc29yLCAkeHggPSBubyBmbGFzaFxyXG4vKiBlNWQxICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiYXV0b2RuXzAyOTJcIik7ICAgICAgLy8gc2NyZWVuIHNjcm9sbGluZyBmbGFnLCAkMDAgPSBzY3JvbGwsICR4eCA9IG5vIHNjcm9sbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgZGlzYWJsZXMgYm90aCB0aGUgY3Vyc29yIGZsYXNoIGFuZCB0aGUgc2NyZWVuIHNjcm9sbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaWxlIHRoZXJlIGFyZSBjaGFyYWN0ZXJzIGluIHRoZSBrZXlib2FyZCBidWZmZXJcclxuLyogZTVkNCAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9lNWNkXCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgdGhlIGJ1ZmZlciBpcyBlbXB0eVxyXG4vKiBlNWQ2ICovICAgICAgICAgICAgICAgICAgIFNFSS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRpc2FibGUgdGhlIGludGVycnVwdHNcclxuLyogZTVkNyAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImJsbm9uXzAwY2ZcIik7ICAgICAgIC8vIGdldCB0aGUgY3Vyc29yIGJsaW5rIHBoYXNlXHJcbi8qIGU1ZDkgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZTVlN1wiKTsgICAgICAgICAgICAvLyBpZiBjdXJzb3IgcGhhc2Ugc2tpcCB0aGUgb3ZlcndyaXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBpdCBpcyB0aGUgY2hhcmFjdGVyIHBoYXNlXHJcbi8qIGU1ZGIgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJnZGJsbl8wMGNlXCIpOyAgICAgICAvLyBnZXQgdGhlIGNoYXJhY3RlciB1bmRlciB0aGUgY3Vyc29yXHJcbi8qIGU1ZGQgKi8gICAgICAgICAgICAgICAgICAgTERYLmFicyAoXCJnZGNvbF8wMjg3XCIpOyAgICAgICAvLyBnZXQgdGhlIGNvbG91ciB1bmRlciB0aGUgY3Vyc29yXHJcbi8qIGU1ZTAgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgWVxyXG4vKiBlNWUyICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwiYmxub25fMDBjZlwiKTsgICAgICAgLy8gY2xlYXIgdGhlIGN1cnNvciBibGluayBwaGFzZVxyXG4vKiBlNWU0ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2VhMTNcIik7ICAgICAgICAgICAgLy8gcHJpbnQgY2hhcmFjdGVyIEEgYW5kIGNvbG91ciBYXHJcbi8qIGU1ZTcgKi8gICAgICAgIF9gX2U1ZTdgOyAgSlNSLmFicyAoXCJscDJfZTViNFwiKTsgICAgICAgICAvLyBpbnB1dCBmcm9tIHRoZSBrZXlib2FyZCBidWZmZXJcclxuLyogZTVlYSAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW1tICgweDgzKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggW1NISUZUXVtSVU5dXHJcbi8qIGU1ZWMgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZTVmZVwiKTsgICAgICAgICAgICAvLyBpZiBub3QgW1NISUZUXVtSVU5dIHNraXAgdGhlIGJ1ZmZlciBmaWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2V5cyBhcmUgW1NISUZUXVtSVU5dIHNvIHB1dCBcIkxPQURcIiwkMEQsXCJSVU5cIiwkMEQgaW50b1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBidWZmZXJcclxuLyogZTVlZSAqLyAgICAgICAgICAgICAgICAgICBMRFguaW1tICgweDA5KTsgICAgICAgICAgICAgICAvLyBzZXQgdGhlIGJ5dGUgY291bnRcclxuLyogZTVmMCAqLyAgICAgICAgICAgICAgICAgICBTRUkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBkaXNhYmxlIHRoZSBpbnRlcnJ1cHRzXHJcbi8qIGU1ZjEgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJuZHhfMDBjNlwiKTsgICAgICAgICAvLyBzZXQgdGhlIGtleWJvYXJkIGJ1ZmZlciBpbmRleFxyXG4vKiBlNWYzICovICAgICAgICBfYF9lNWYzYDsgIExEQS5hYnggKFwiX2VjZTZcIik7ICAgICAgICAgICAgLy8gZ2V0IGJ5dGUgZnJvbSB0aGUgYXV0byBsb2FkL3J1biB0YWJsZVxyXG4vKiBlNWY2ICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnggKFwic2F0KzlfMDI3NlwiKTsgICAgICAgLy8gc2F2ZSBpdCB0byB0aGUga2V5Ym9hcmQgYnVmZmVyXHJcbi8qIGU1ZjkgKi8gICAgICAgICAgICAgICAgICAgREVYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZGVjcmVtZW50IHRoZSBjb3VudC9pbmRleFxyXG4vKiBlNWZhICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2U1ZjNcIik7ICAgICAgICAgICAgLy8gbG9vcCB3aGlsZSBtb3JlIHRvIGRvXHJcbi8qIGU1ZmMgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZTVjZFwiKTsgICAgICAgICAgICAvLyBsb29wIGZvciB0aGUgbmV4dCBrZXksIGJyYW5jaCBhbHdheXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3YXMgbm90IFtTSElGVF1bUlVOXVxyXG4vKiBlNWZlICovICAgICAgICBfYF9lNWZlYDsgIENNUC5pbW0gKDB4MGQpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgdGhlIGtleSB3aXRoIFtDUl1cclxuLyogZTYwMCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9lNWNhXCIpOyAgICAgICAgICAgIC8vIGlmIG5vdCBbQ1JdIHByaW50IHRoZSBjaGFyYWN0ZXIgYW5kIGdldCB0aGUgbmV4dCBrZXlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIGl0IHdhcyBbQ1JdXHJcbi8qIGU2MDIgKi8gICAgICAgICAgICAgICAgICAgTERZLnpwZyAoXCJsbm14XzAwZDVcIik7ICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgc2NyZWVuIGxpbmUgbGVuZ3RoXHJcbi8qIGU2MDQgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJjcnN3XzAwZDBcIik7ICAgICAgICAvLyBpbnB1dCBmcm9tIGtleWJvYXJkIG9yIHNjcmVlbiwgJHh4ID0gc2NyZWVuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICQwMCA9IGtleWJvYXJkXHJcbi8qIGU2MDYgKi8gICAgICAgIF9gX2U2MDZgOyAgTERBLmlueSAoXCJwbnQrMF8wMGQxXCIpOyAgICAgICAvLyBnZXQgdGhlIGNoYXJhY3RlciBmcm9tIHRoZSBjdXJyZW50IHNjcmVlbiBsaW5lXHJcbi8qIGU2MDggKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHgyMCk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSBpdCB3aXRoIFtTUEFDRV1cclxuLyogZTYwYSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9lNjBmXCIpOyAgICAgICAgICAgIC8vIGlmIG5vdCBbU1BBQ0VdIGNvbnRpbnVlXHJcbi8qIGU2MGMgKi8gICAgICAgICAgICAgICAgICAgREVZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBlbGltaW5hdGUgdGhlIHNwYWNlLCBkZWNyZW1lbnQgZW5kIG9mIGlucHV0IGxpbmVcclxuLyogZTYwZCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9lNjA2XCIpOyAgICAgICAgICAgIC8vIGxvb3AsIGJyYW5jaCBhbHdheXNcclxuLyogZTYwZiAqLyAgICAgICAgX2BfZTYwZmA7ICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgcGFzdCB0aGUgbGFzdCBub24gc3BhY2UgY2hhcmFjdGVyIG9uIGxpbmVcclxuLyogZTYxMCAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcImluZHhfMDBjOFwiKTsgICAgICAgIC8vIHNhdmUgdGhlIGlucHV0IFtFT0xdIHBvaW50ZXJcclxuLyogZTYxMiAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBBXHJcbi8qIGU2MTQgKi8gICAgICAgICAgICAgICAgICAgU1RZLmFicyAoXCJhdXRvZG5fMDI5MlwiKTsgICAgICAvLyBjbGVhciB0aGUgc2NyZWVuIHNjcm9sbGluZyBmbGFnLCAkMDAgPSBzY3JvbGxcclxuLyogZTYxNyAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcInBudHJfMDBkM1wiKTsgICAgICAgIC8vIGNsZWFyIHRoZSBjdXJzb3IgY29sdW1uXHJcbi8qIGU2MTkgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJxdHN3XzAwZDRcIik7ICAgICAgICAvLyBjbGVhciB0aGUgY3Vyc29yIHF1b3RlIGZsYWcsICR4eCA9IHF1b3RlLCAkMDAgPSBubyBxdW90ZVxyXG4vKiBlNjFiICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwibHhzcCswXzAwYzlcIik7ICAgICAgLy8gZ2V0IHRoZSBpbnB1dCBjdXJzb3Igcm93XHJcbi8qIGU2MWQgKi8gICAgICAgICAgICAgICAgICAgQk1JLnJlbCAoXCJfZTYzYVwiKTtcclxuLyogZTYxZiAqLyAgICAgICAgICAgICAgICAgICBMRFguenBnIChcInRibHhfMDBkNlwiKTsgICAgICAgIC8vIGdldCB0aGUgY3Vyc29yIHJvd1xyXG4vKiBlNjIxICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2U1OTFcIik7ICAgICAgICAgICAgLy8gZmluZCBhbmQgc2V0IHRoZSBwb2ludGVycyBmb3IgdGhlIHN0YXJ0IG9mIGxvZ2ljYWwgbGluZVxyXG4vKiBlNjI0ICovICAgICAgICAgICAgICAgICAgIENQWC56cGcgKFwibHhzcCswXzAwYzlcIik7ICAgICAgLy8gY29tcGFyZSB3aXRoIGlucHV0IGN1cnNvciByb3dcclxuLyogZTYyNiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9lNjNhXCIpO1xyXG4vKiBlNjI4ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwibHhzcCsxXzAwY2FcIik7ICAgICAgLy8gZ2V0IHRoZSBpbnB1dCBjdXJzb3IgY29sdW1uXHJcbi8qIGU2MmEgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJwbnRyXzAwZDNcIik7ICAgICAgICAvLyBzYXZlIHRoZSBjdXJzb3IgY29sdW1uXHJcbi8qIGU2MmMgKi8gICAgICAgICAgICAgICAgICAgQ01QLnpwZyAoXCJpbmR4XzAwYzhcIik7ICAgICAgICAvLyBjb21wYXJlIHRoZSBjdXJzb3IgY29sdW1uIHdpdGggaW5wdXQgW0VPTF0gcG9pbnRlclxyXG4vKiBlNjJlICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2U2M2FcIik7ICAgICAgICAgICAgLy8gaWYgbGVzcywgY3Vyc29yIGlzIGluIGxpbmUsIGdvID8/XHJcbi8qIGU2MzAgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfZTY1ZFwiKTsgICAgICAgICAgICAvLyBlbHNlIHRoZSBjdXJzb3IgaXMgYmV5b25kIHRoZSBsaW5lIGVuZCwgYnJhbmNoIGFsd2F5c1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBpbnB1dCBmcm9tIHNjcmVlbiBvciBrZXlib2FyZFxyXG4vKiBlNjMyICovICAgICAgICBfYF9lNjMyYDsgIFRZQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgWVxyXG4vKiBlNjMzICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgWVxyXG4vKiBlNjM0ICovICAgICAgICAgICAgICAgICAgIFRYQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgWFxyXG4vKiBlNjM1ICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgWFxyXG4vKiBlNjM2ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiY3Jzd18wMGQwXCIpOyAgICAgICAgLy8gaW5wdXQgZnJvbSBrZXlib2FyZCBvciBzY3JlZW4sICR4eCA9IHNjcmVlbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAkMDAgPSBrZXlib2FyZFxyXG4vKiBlNjM4ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2U1Y2RcIik7ICAgICAgICAgICAgLy8gaWYga2V5Ym9hcmQgZ28gd2FpdCBmb3Iga2V5XHJcbi8qIGU2M2EgKi8gICAgICAgIF9gX2U2M2FgOyAgTERZLnpwZyAoXCJwbnRyXzAwZDNcIik7ICAgICAgICAvLyBnZXQgdGhlIGN1cnNvciBjb2x1bW5cclxuLyogZTYzYyAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcInBudCswXzAwZDFcIik7ICAgICAgIC8vIGdldCBjaGFyYWN0ZXIgZnJvbSB0aGUgY3VycmVudCBzY3JlZW4gbGluZVxyXG4vKiBlNjNlICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwic2NoYXJfMDBkN1wiKTsgICAgICAgLy8gc2F2ZSB0ZW1wb3JhcnkgbGFzdCBjaGFyYWN0ZXJcclxuLyogZTY0MCAqLyAgICAgICAgICAgICAgICAgICBBTkQuaW1tICgweDNmKTsgICAgICAgICAgICAgICAvLyBtYXNrIGtleSBiaXRzXHJcbi8qIGU2NDIgKi8gICAgICAgICAgICAgICAgICAgQVNMLnpwZyAoXCJzY2hhcl8wMGQ3XCIpOyAgICAgICAvLyA8PCB0ZW1wb3JhcnkgbGFzdCBjaGFyYWN0ZXJcclxuLyogZTY0NCAqLyAgICAgICAgICAgICAgICAgICBCSVQuenBnIChcInNjaGFyXzAwZDdcIik7ICAgICAgIC8vIHRlc3QgaXRcclxuLyogZTY0NiAqLyAgICAgICAgICAgICAgICAgICBCUEwucmVsIChcIl9lNjRhXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBub3QgW05PIEtFWV1cclxuLyogZTY0OCAqLyAgICAgICAgICAgICAgICAgICBPUkEuaW1tICgweDgwKTtcclxuLyogZTY0YSAqLyAgICAgICAgX2BfZTY0YWA7ICBCQ0MucmVsIChcIl9lNjUwXCIpO1xyXG4vKiBlNjRjICovICAgICAgICAgICAgICAgICAgIExEWC56cGcgKFwicXRzd18wMGQ0XCIpOyAgICAgICAgLy8gZ2V0IHRoZSBjdXJzb3IgcXVvdGUgZmxhZywgJHh4ID0gcXVvdGUsICQwMCA9IG5vIHF1b3RlXHJcbi8qIGU2NGUgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZTY1NFwiKTsgICAgICAgICAgICAvLyBpZiBpbiBxdW90ZSBtb2RlIGdvID8/XHJcbi8qIGU2NTAgKi8gICAgICAgIF9gX2U2NTBgOyAgQlZTLnJlbCAoXCJfZTY1NFwiKTtcclxuLyogZTY1MiAqLyAgICAgICAgICAgICAgICAgICBPUkEuaW1tICgweDQwKTtcclxuLyogZTY1NCAqLyAgICAgICAgX2BfZTY1NGA7ICBJTkMuenBnIChcInBudHJfMDBkM1wiKTsgICAgICAgIC8vIGluY3JlbWVudCB0aGUgY3Vyc29yIGNvbHVtblxyXG4vKiBlNjU2ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2U2ODRcIik7ICAgICAgICAgICAgLy8gaWYgb3BlbiBxdW90ZSB0b2dnbGUgdGhlIGN1cnNvciBxdW90ZSBmbGFnXHJcbi8qIGU2NTkgKi8gICAgICAgICAgICAgICAgICAgQ1BZLnpwZyAoXCJpbmR4XzAwYzhcIik7ICAgICAgICAvLyBjb21wYXJlID8/IHdpdGggaW5wdXQgW0VPTF0gcG9pbnRlclxyXG4vKiBlNjViICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2U2NzRcIik7ICAgICAgICAgICAgLy8gaWYgbm90IGF0IGxpbmUgZW5kIGdvID8/XHJcbi8qIGU2NWQgKi8gICAgICAgIF9gX2U2NWRgOyAgTERBLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgQVxyXG4vKiBlNjVmICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiY3Jzd18wMGQwXCIpOyAgICAgICAgLy8gY2xlYXIgaW5wdXQgZnJvbSBrZXlib2FyZCBvciBzY3JlZW4sICR4eCA9IHNjcmVlbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAkMDAgPSBrZXlib2FyZFxyXG4vKiBlNjYxICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MGQpOyAgICAgICAgICAgICAgIC8vIHNldCBjaGFyYWN0ZXIgW0NSXVxyXG4vKiBlNjYzICovICAgICAgICAgICAgICAgICAgIExEWC56cGcgKFwiZGZsdG5fMDA5OVwiKTsgICAgICAgLy8gZ2V0IHRoZSBpbnB1dCBkZXZpY2UgbnVtYmVyXHJcbi8qIGU2NjUgKi8gICAgICAgICAgICAgICAgICAgQ1BYLmltbSAoMHgwMyk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB0aGUgaW5wdXQgZGV2aWNlIHdpdGggdGhlIHNjcmVlblxyXG4vKiBlNjY3ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2U2NmZcIik7ICAgICAgICAgICAgLy8gaWYgc2NyZWVuIGdvID8/XHJcbi8qIGU2NjkgKi8gICAgICAgICAgICAgICAgICAgTERYLnpwZyAoXCJkZmx0b18wMDlhXCIpOyAgICAgICAvLyBnZXQgdGhlIG91dHB1dCBkZXZpY2UgbnVtYmVyXHJcbi8qIGU2NmIgKi8gICAgICAgICAgICAgICAgICAgQ1BYLmltbSAoMHgwMyk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB0aGUgb3V0cHV0IGRldmljZSB3aXRoIHRoZSBzY3JlZW5cclxuLyogZTY2ZCAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9lNjcyXCIpOyAgICAgICAgICAgIC8vIGlmIHNjcmVlbiBnbyA/P1xyXG4vKiBlNjZmICovICAgICAgICBfYF9lNjZmYDsgIEpTUi5hYnMgKFwiX2U3MTZcIik7ICAgICAgICAgICAgLy8gb3V0cHV0IHRoZSBjaGFyYWN0ZXJcclxuLyogZTY3MiAqLyAgICAgICAgX2BfZTY3MmA7ICBMREEuaW1tICgweDBkKTsgICAgICAgICAgICAgICAvLyBzZXQgY2hhcmFjdGVyIFtDUl1cclxuLyogZTY3NCAqLyAgICAgICAgX2BfZTY3NGA7ICBTVEEuenBnIChcInNjaGFyXzAwZDdcIik7ICAgICAgIC8vIHNhdmUgY2hhcmFjdGVyXHJcbi8qIGU2NzYgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVsbCBYXHJcbi8qIGU2NzcgKi8gICAgICAgICAgICAgICAgICAgVEFYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBYXHJcbi8qIGU2NzggKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVsbCBZXHJcbi8qIGU2NzkgKi8gICAgICAgICAgICAgICAgICAgVEFZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBZXHJcbi8qIGU2N2EgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJzY2hhcl8wMGQ3XCIpOyAgICAgICAvLyByZXN0b3JlIGNoYXJhY3RlclxyXG4vKiBlNjdjICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4ZGUpO1xyXG4vKiBlNjdlICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2U2ODJcIik7XHJcbi8qIGU2ODAgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHhmZik7XHJcbi8qIGU2ODIgKi8gICAgICAgIF9gX2U2ODJgOyAgQ0xDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZmxhZyBva1xyXG4vKiBlNjgzICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGlmIG9wZW4gcXVvdGUgdG9nZ2xlIGN1cnNvciBxdW90ZSBmbGFnXHJcbi8qIGU2ODQgKi8gICAgICAgIF9gX2U2ODRgOyAgQ01QLmltbSAoMHgyMik7ICAgICAgICAgICAgICAgLy8gY29tYXByZSBieXRlIHdpdGggXCJcclxuLyogZTY4NiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9lNjkwXCIpOyAgICAgICAgICAgIC8vIGV4aXQgaWYgbm90IFwiXHJcbi8qIGU2ODggKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJxdHN3XzAwZDRcIik7ICAgICAgICAvLyBnZXQgY3Vyc29yIHF1b3RlIGZsYWcsICR4eCA9IHF1b3RlLCAkMDAgPSBubyBxdW90ZVxyXG4vKiBlNjhhICovICAgICAgICAgICAgICAgICAgIEVPUi5pbW0gKDB4MDEpOyAgICAgICAgICAgICAgIC8vIHRvZ2dsZSBpdFxyXG4vKiBlNjhjICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwicXRzd18wMGQ0XCIpOyAgICAgICAgLy8gc2F2ZSBjdXJzb3IgcXVvdGUgZmxhZ1xyXG4vKiBlNjhlICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MjIpOyAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgdGhlIFwiXHJcbi8qIGU2OTAgKi8gICAgICAgIF9gX2U2OTBgOyAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gaW5zZXJ0IHVwcGVyY2FzZS9ncmFwaGljIGNoYXJhY3RlclxyXG4vKiBlNjkxICovICAgICAgICBfYF9lNjkxYDsgIE9SQS5pbW0gKDB4NDApOyAgICAgICAgICAgICAgIC8vIGNoYW5nZSB0byB1cHBlcmNhc2UvZ3JhcGhpY1xyXG4vKiBlNjkzICovICAgICAgICBfYF9lNjkzYDsgIExEWC56cGcgKFwicnZzXzAwYzdcIik7ICAgICAgICAgLy8gZ2V0IHRoZSByZXZlcnNlIGZsYWdcclxuLyogZTY5NSAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9lNjk5XCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBub3QgcmV2ZXJzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgLi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlcnQgcmV2ZXJzZWQgY2hhcmFjdGVyXHJcbi8qIGU2OTcgKi8gICAgICAgIF9gX2U2OTdgOyAgT1JBLmltbSAoMHg4MCk7ICAgICAgICAgICAgICAgLy8gcmV2ZXJzZSBjaGFyYWN0ZXJcclxuLyogZTY5OSAqLyAgICAgICAgX2BfZTY5OWA7ICBMRFguenBnIChcImluc3J0XzAwZDhcIik7ICAgICAgIC8vIGdldCB0aGUgaW5zZXJ0IGNvdW50XHJcbi8qIGU2OWIgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZTY5ZlwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbm9uZVxyXG4vKiBlNjlkICovICAgICAgICAgICAgICAgICAgIERFQy56cGcgKFwiaW5zcnRfMDBkOFwiKTsgICAgICAgLy8gZWxzZSBkZWNyZW1lbnQgdGhlIGluc2VydCBjb3VudFxyXG4vKiBlNjlmICovICAgICAgICBfYF9lNjlmYDsgIExEWC5hYnMgKFwiY29sb3JfMDI4NlwiKTsgICAgICAgLy8gZ2V0IHRoZSBjdXJyZW50IGNvbG91ciBjb2RlXHJcbi8qIGU2YTIgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZWExM1wiKTsgICAgICAgICAgICAvLyBwcmludCBjaGFyYWN0ZXIgQSBhbmQgY29sb3VyIFhcclxuLyogZTZhNSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9lNmI2XCIpOyAgICAgICAgICAgIC8vIGFkdmFuY2UgdGhlIGN1cnNvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgdGhlIHJlZ2lzdGVycywgc2V0IHRoZSBxdW90ZSBmbGFnIGFuZCBleGl0XHJcbi8qIGU2YTggKi8gICAgICAgIF9gX2U2YThgOyAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVsbCBZXHJcbi8qIGU2YTkgKi8gICAgICAgICAgICAgICAgICAgVEFZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBZXHJcbi8qIGU2YWEgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJpbnNydF8wMGQ4XCIpOyAgICAgICAvLyBnZXQgdGhlIGluc2VydCBjb3VudFxyXG4vKiBlNmFjICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2U2YjBcIik7ICAgICAgICAgICAgLy8gc2tpcCBxdW90ZSBmbGFnIGNsZWFyIGlmIGluc2VydHMgdG8gZG9cclxuLyogZTZhZSAqLyAgICAgICAgICAgICAgICAgICBMU1IuenBnIChcInF0c3dfMDBkNFwiKTsgICAgICAgIC8vIGNsZWFyIGN1cnNvciBxdW90ZSBmbGFnLCAkeHggPSBxdW90ZSwgJDAwID0gbm8gcXVvdGVcclxuLyogZTZiMCAqLyAgICAgICAgX2BfZTZiMGA7ICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdWxsIFhcclxuLyogZTZiMSAqLyAgICAgICAgICAgICAgICAgICBUQVguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIFhcclxuLyogZTZiMiAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIEFcclxuLyogZTZiMyAqLyAgICAgICAgICAgICAgICAgICBDTEMuaW1wICgpO1xyXG4vKiBlNmI0ICovICAgICAgICAgICAgICAgICAgIENMSS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGVuYWJsZSB0aGUgaW50ZXJydXB0c1xyXG4vKiBlNmI1ICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGFkdmFuY2UgdGhlIGN1cnNvclxyXG4vKiBlNmI2ICovICAgICAgICBfYF9lNmI2YDsgIEpTUi5hYnMgKFwiX2U4YjNcIik7ICAgICAgICAgICAgLy8gdGVzdCBmb3IgbGluZSBpbmNyZW1lbnRcclxuLyogZTZiOSAqLyAgICAgICAgICAgICAgICAgICBJTkMuenBnIChcInBudHJfMDBkM1wiKTsgICAgICAgIC8vIGluY3JlbWVudCB0aGUgY3Vyc29yIGNvbHVtblxyXG4vKiBlNmJiICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwibG5teF8wMGQ1XCIpOyAgICAgICAgLy8gZ2V0IGN1cnJlbnQgc2NyZWVuIGxpbmUgbGVuZ3RoXHJcbi8qIGU2YmQgKi8gICAgICAgICAgICAgICAgICAgQ01QLnpwZyAoXCJwbnRyXzAwZDNcIik7ICAgICAgICAvLyBjb21wYXJlID8/IHdpdGggdGhlIGN1cnNvciBjb2x1bW5cclxuLyogZTZiZiAqLyAgICAgICAgICAgICAgICAgICBCQ1MucmVsIChcIl9lNzAwXCIpOyAgICAgICAgICAgIC8vIGV4aXQgaWYgbGluZSBsZW5ndGggPj0gY3Vyc29yIGNvbHVtblxyXG4vKiBlNmMxICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4NGYpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCBtYXggbGVuZ3RoXHJcbi8qIGU2YzMgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZTZmN1wiKTsgICAgICAgICAgICAvLyBpZiBhdCBtYXggY2xlYXIgY29sdW1uLCBiYWNrIGN1cnNvciB1cCBhbmQgZG8gbmV3bGluZVxyXG4vKiBlNmM1ICovICAgICAgICAgICAgICAgICAgIExEQS5hYnMgKFwiYXV0b2RuXzAyOTJcIik7ICAgICAgLy8gZ2V0IHRoZSBhdXRvc2Nyb2xsIGZsYWdcclxuLyogZTZjOCAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9lNmNkXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBhdXRvc2Nyb2xsIG9uXHJcbi8qIGU2Y2EgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZTk2N1wiKTsgICAgICAgICAgICAvLyBlbHNlIG9wZW4gc3BhY2Ugb24gc2NyZWVuXHJcbi8qIGU2Y2QgKi8gICAgICAgIF9gX2U2Y2RgOyAgTERYLnpwZyAoXCJ0Ymx4XzAwZDZcIik7ICAgICAgICAvLyBnZXQgdGhlIGN1cnNvciByb3dcclxuLyogZTZjZiAqLyAgICAgICAgICAgICAgICAgICBDUFguaW1tICgweDE5KTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggbWF4ICsgMVxyXG4vKiBlNmQxICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2U2ZGFcIik7ICAgICAgICAgICAgLy8gaWYgbGVzcyB0aGFuIG1heCArIDEgZ28gYWRkIHRoaXMgcm93IHRvIHRoZSBjdXJyZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9naWNhbCBsaW5lXHJcbi8qIGU2ZDMgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZThlYVwiKTsgICAgICAgICAgICAvLyBlbHNlIHNjcm9sbCB0aGUgc2NyZWVuXHJcbi8qIGU2ZDYgKi8gICAgICAgICAgICAgICAgICAgREVDLnpwZyAoXCJ0Ymx4XzAwZDZcIik7ICAgICAgICAvLyBkZWNyZW1lbnQgdGhlIGN1cnNvciByb3dcclxuLyogZTZkOCAqLyAgICAgICAgICAgICAgICAgICBMRFguenBnIChcInRibHhfMDBkNlwiKTsgICAgICAgIC8vIGdldCB0aGUgY3Vyc29yIHJvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0aGlzIHJvdyB0byB0aGUgY3VycmVudCBsb2dpY2FsIGxpbmVcclxuLyogZTZkYSAqLyAgICAgICAgX2BfZTZkYWA7ICBBU0wuenB4ICgweGQ5KTsgICAgICAgICAgICAgICAvLyBzaGlmdCBzdGFydCBvZiBsaW5lIFggcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogZTZkYyAqLyAgICAgICAgICAgICAgICAgICBMU1IuenB4ICgweGQ5KTsgICAgICAgICAgICAgICAvLyBzaGlmdCBzdGFydCBvZiBsaW5lIFggcG9pbnRlciBoaWdoIGJ5dGUgYmFjayxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIG5leHQgc2NyZWVuIGxpbmUgc3RhcnQgb2YgbG9naWNhbCBsaW5lLCBpbmNyZW1lbnQgbGluZSBsZW5ndGggYW5kIHNldCBwb2ludGVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIGI3LCBzdGFydCBvZiBsb2dpY2FsIGxpbmVcclxuLyogZTZkZSAqLyAgICAgICAgICAgICAgICAgICBJTlguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgc2NyZWVuIHJvd1xyXG4vKiBlNmRmICovICAgICAgICAgICAgICAgICAgIExEQS56cHggKDB4ZDkpOyAgICAgICAgICAgICAgIC8vIGdldCBzdGFydCBvZiBsaW5lIFggcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogZTZlMSAqLyAgICAgICAgICAgICAgICAgICBPUkEuaW1tICgweDgwKTsgICAgICAgICAgICAgICAvLyBtYXJrIGFzIHN0YXJ0IG9mIGxvZ2ljYWwgbGluZVxyXG4vKiBlNmUzICovICAgICAgICAgICAgICAgICAgIFNUQS56cHggKDB4ZDkpOyAgICAgICAgICAgICAgIC8vIHNldCBzdGFydCBvZiBsaW5lIFggcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogZTZlNSAqLyAgICAgICAgICAgICAgICAgICBERVguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIHNjcmVlbiByb3dcclxuLyogZTZlNiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImxubXhfMDBkNVwiKTsgICAgICAgIC8vIGdldCBjdXJyZW50IHNjcmVlbiBsaW5lIGxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBvbmUgbGluZSBsZW5ndGggYW5kIHNldCB0aGUgcG9pbnRlcnMgZm9yIHRoZSBzdGFydCBvZiB0aGUgbGluZVxyXG4vKiBlNmU4ICovICAgICAgICAgICAgICAgICAgIENMQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIGNhcnJ5IGZvciBhZGRcclxuLyogZTZlOSAqLyAgICAgICAgICAgICAgICAgICBBREMuaW1tICgweDI4KTsgICAgICAgICAgICAgICAvLyBhZGQgb25lIGxpbmUgbGVuZ3RoXHJcbi8qIGU2ZWIgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJsbm14XzAwZDVcIik7ICAgICAgICAvLyBzYXZlIGN1cnJlbnQgc2NyZWVuIGxpbmUgbGVuZ3RoXHJcbi8qIGU2ZWQgKi8gICAgICAgIF9gX2U2ZWRgOyAgTERBLnpweCAoMHhkOSk7ICAgICAgICAgICAgICAgLy8gZ2V0IHN0YXJ0IG9mIGxpbmUgWCBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBlNmVmICovICAgICAgICAgICAgICAgICAgIEJNSS5yZWwgKFwiX2U2ZjRcIik7ICAgICAgICAgICAgLy8gZXhpdCBsb29wIGlmIHN0YXJ0IG9mIGxvZ2ljYWwgbGluZVxyXG4vKiBlNmYxICovICAgICAgICAgICAgICAgICAgIERFWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgYmFjayB1cCBvbmUgbGluZVxyXG4vKiBlNmYyICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2U2ZWRcIik7ICAgICAgICAgICAgLy8gbG9vcCBpZiBub3Qgb24gZmlyc3QgbGluZVxyXG4vKiBlNmY0ICovICAgICAgICBfYF9lNmY0YDsgIEpNUC5hYnMgKFwiX2U5ZjBcIik7ICAgICAgICAgICAgLy8gZmV0Y2ggYSBzY3JlZW4gYWRkcmVzc1xyXG4vKiBlNmY3ICovICAgICAgICBfYF9lNmY3YDsgIERFQy56cGcgKFwidGJseF8wMGQ2XCIpOyAgICAgICAgLy8gZGVjcmVtZW50IHRoZSBjdXJzb3Igcm93XHJcbi8qIGU2ZjkgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZTg3Y1wiKTsgICAgICAgICAgICAvLyBkbyBuZXdsaW5lXHJcbi8qIGU2ZmMgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgQVxyXG4vKiBlNmZlICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwicG50cl8wMGQzXCIpOyAgICAgICAgLy8gY2xlYXIgdGhlIGN1cnNvciBjb2x1bW5cclxuLyogZTcwMCAqLyAgICAgICAgX2BfZTcwMGA7ICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBiYWNrIG9udG8gdGhlIHByZXZpb3VzIGxpbmUgaWYgcG9zc2libGVcclxuLyogZTcwMSAqLyAgICAgICAgX2BfZTcwMWA7ICBMRFguenBnIChcInRibHhfMDBkNlwiKTsgICAgICAgIC8vIGdldCB0aGUgY3Vyc29yIHJvd1xyXG4vKiBlNzAzICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2U3MGJcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vdCB0b3Agcm93XHJcbi8qIGU3MDUgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJwbnRyXzAwZDNcIik7ICAgICAgICAvLyBjbGVhciBjdXJzb3IgY29sdW1uXHJcbi8qIGU3MDcgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZHVtcCByZXR1cm4gYWRkcmVzcyBsb3cgYnl0ZVxyXG4vKiBlNzA4ICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGR1bXAgcmV0dXJuIGFkZHJlc3MgaGlnaCBieXRlXHJcbi8qIGU3MDkgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZTZhOFwiKTsgICAgICAgICAgICAvLyByZXN0b3JlIHJlZ2lzdGVycywgc2V0IHF1b3RlIGZsYWcgYW5kIGV4aXQsIGJyYW5jaCBhbHdheXNcclxuLyogZTcwYiAqLyAgICAgICAgX2BfZTcwYmA7ICBERVguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBkZWNyZW1lbnQgdGhlIGN1cnNvciByb3dcclxuLyogZTcwYyAqLyAgICAgICAgICAgICAgICAgICBTVFguenBnIChcInRibHhfMDBkNlwiKTsgICAgICAgIC8vIHNhdmUgdGhlIGN1cnNvciByb3dcclxuLyogZTcwZSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9lNTZjXCIpOyAgICAgICAgICAgIC8vIHNldCB0aGUgc2NyZWVuIHBvaW50ZXJzIGZvciBjdXJzb3Igcm93LCBjb2x1bW5cclxuLyogZTcxMSAqLyAgICAgICAgICAgICAgICAgICBMRFkuenBnIChcImxubXhfMDBkNVwiKTsgICAgICAgIC8vIGdldCBjdXJyZW50IHNjcmVlbiBsaW5lIGxlbmd0aFxyXG4vKiBlNzEzICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwicG50cl8wMGQzXCIpOyAgICAgICAgLy8gc2F2ZSB0aGUgY3Vyc29yIGNvbHVtblxyXG4vKiBlNzE1ICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIG91dHB1dCBhIGNoYXJhY3RlciB0byB0aGUgc2NyZWVuXHJcbi8qIGU3MTYgKi8gICAgICAgIF9gX2U3MTZgOyAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBjaGFyYWN0ZXJcclxuLyogZTcxNyAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInNjaGFyXzAwZDdcIik7ICAgICAgIC8vIHNhdmUgdGVtcG9yYXJ5IGxhc3QgY2hhcmFjdGVyXHJcbi8qIGU3MTkgKi8gICAgICAgICAgICAgICAgICAgVFhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBYXHJcbi8qIGU3MWEgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBYXHJcbi8qIGU3MWIgKi8gICAgICAgICAgICAgICAgICAgVFlBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBZXHJcbi8qIGU3MWMgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBZXHJcbi8qIGU3MWQgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgQVxyXG4vKiBlNzFmICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiY3Jzd18wMGQwXCIpOyAgICAgICAgLy8gY2xlYXIgaW5wdXQgZnJvbSBrZXlib2FyZCBvciBzY3JlZW4sICR4eCA9IHNjcmVlbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAkMDAgPSBrZXlib2FyZFxyXG4vKiBlNzIxICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwicG50cl8wMGQzXCIpOyAgICAgICAgLy8gZ2V0IGN1cnNvciBjb2x1bW5cclxuLyogZTcyMyAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInNjaGFyXzAwZDdcIik7ICAgICAgIC8vIHJlc3RvcmUgbGFzdCBjaGFyYWN0ZXJcclxuLyogZTcyNSAqLyAgICAgICAgICAgICAgICAgICBCUEwucmVsIChcIl9lNzJhXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiB1bnNoaWZ0ZWRcclxuLyogZTcyNyAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9lN2Q0XCIpOyAgICAgICAgICAgIC8vIGRvIHNoaWZ0ZWQgY2hhcmFjdGVycyBhbmQgcmV0dXJuXHJcbi8qIGU3MmEgKi8gICAgICAgIF9gX2U3MmFgOyAgQ01QLmltbSAoMHgwZCk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIFtDUl1cclxuLyogZTcyYyAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9lNzMxXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBub3QgW0NSXVxyXG4vKiBlNzJlICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2U4OTFcIik7ICAgICAgICAgICAgLy8gZWxzZSBvdXRwdXQgW0NSXSBhbmQgcmV0dXJuXHJcbi8qIGU3MzEgKi8gICAgICAgIF9gX2U3MzFgOyAgQ01QLmltbSAoMHgyMCk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIFtTUEFDRV1cclxuLyogZTczMyAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9lNzQ1XCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiA8IFtTUEFDRV0sIG5vdCBhIHByaW50YWJsZSBjaGFyYWN0ZXJcclxuLyogZTczNSAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW1tICgweDYwKTtcclxuLyogZTczNyAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9lNzNkXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiAkMjAgdG8gJDVGXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyIGlzICQ2MCBvciBncmVhdGVyXHJcbi8qIGU3MzkgKi8gICAgICAgICAgICAgICAgICAgQU5ELmltbSAoMHhkZik7ICAgICAgICAgICAgICAgLy8gY29udmVyc2lvbiBvZiBQRVRTQ0lJIGNoYXJhY3RlciB0byBzY3JlZW4gY29kZVxyXG4vKiBlNzNiICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2U3M2ZcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGFsd2F5c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoYXJhY3RlciBpcyAkMjAgdG8gJDVGXHJcbi8qIGU3M2QgKi8gICAgICAgIF9gX2U3M2RgOyAgQU5ELmltbSAoMHgzZik7ICAgICAgICAgICAgICAgLy8gY29udmVyc2lvbiBvZiBQRVRTQ0lJIGNoYXJhY3RlciB0byBzY3JlZW4gY29kZVxyXG4vKiBlNzNmICovICAgICAgICBfYF9lNzNmYDsgIEpTUi5hYnMgKFwiX2U2ODRcIik7ICAgICAgICAgICAgLy8gaWYgb3BlbiBxdW90ZSB0b2dnbGUgY3Vyc29yIGRpcmVjdC9wcm9ncmFtbWVkIGZsYWdcclxuLyogZTc0MiAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9lNjkzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoYXJhY3RlciB3YXMgPCBbU1BBQ0VdIHNvIGlzIGEgY29udHJvbCBjaGFyYWN0ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiBzb21lIHNvcnRcclxuLyogZTc0NSAqLyAgICAgICAgX2BfZTc0NWA7ICBMRFguenBnIChcImluc3J0XzAwZDhcIik7ICAgICAgIC8vIGdldCB0aGUgaW5zZXJ0IGNvdW50XHJcbi8qIGU3NDcgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZTc0Y1wiKTsgICAgICAgICAgICAvLyBpZiBubyBjaGFyYWN0ZXJzIHRvIGluc2VydCBjb250aW51ZVxyXG4vKiBlNzQ5ICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2U2OTdcIik7ICAgICAgICAgICAgLy8gaW5zZXJ0IHJldmVyc2VkIGNoYXJhY3RlclxyXG4vKiBlNzRjICovICAgICAgICBfYF9lNzRjYDsgIENNUC5pbW0gKDB4MTQpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgdGhlIGNoYXJhY3RlciB3aXRoIFtJTlNFUlRdL1tERUxFVEVdXHJcbi8qIGU3NGUgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZTc3ZVwiKTsgICAgICAgICAgICAvLyBpZiBub3QgW0lOU0VSVF0vW0RFTEVURV0gZ28gPz9cclxuLyogZTc1MCAqLyAgICAgICAgICAgICAgICAgICBUWUEuaW1wICgpO1xyXG4vKiBlNzUxICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2U3NTlcIik7XHJcbi8qIGU3NTMgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZTcwMVwiKTsgICAgICAgICAgICAvLyBiYWNrIG9udG8gdGhlIHByZXZpb3VzIGxpbmUgaWYgcG9zc2libGVcclxuLyogZTc1NiAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9lNzczXCIpO1xyXG4vKiBlNzU5ICovICAgICAgICBfYF9lNzU5YDsgIEpTUi5hYnMgKFwiX2U4YTFcIik7ICAgICAgICAgICAgLy8gdGVzdCBmb3IgbGluZSBkZWNyZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3cgY2xvc2UgdXAgdGhlIGxpbmVcclxuLyogZTc1YyAqLyAgICAgICAgICAgICAgICAgICBERVkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBkZWNyZW1lbnQgaW5kZXggdG8gcHJldmlvdXMgY2hhcmFjdGVyXHJcbi8qIGU3NWQgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJwbnRyXzAwZDNcIik7ICAgICAgICAvLyBzYXZlIHRoZSBjdXJzb3IgY29sdW1uXHJcbi8qIGU3NWYgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZWEyNFwiKTsgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHBvaW50ZXIgdG8gY29sb3VyIFJBTVxyXG4vKiBlNzYyICovICAgICAgICBfYF9lNzYyYDsgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBpbmRleCB0byBuZXh0IGNoYXJhY3RlclxyXG4vKiBlNzYzICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwicG50KzBfMDBkMVwiKTsgICAgICAgLy8gZ2V0IGNoYXJhY3RlciBmcm9tIGN1cnJlbnQgc2NyZWVuIGxpbmVcclxuLyogZTc2NSAqLyAgICAgICAgICAgICAgICAgICBERVkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBkZWNyZW1lbnQgaW5kZXggdG8gcHJldmlvdXMgY2hhcmFjdGVyXHJcbi8qIGU3NjYgKi8gICAgICAgICAgICAgICAgICAgU1RBLmlueSAoXCJwbnQrMF8wMGQxXCIpOyAgICAgICAvLyBzYXZlIGNoYXJhY3RlciB0byBjdXJyZW50IHNjcmVlbiBsaW5lXHJcbi8qIGU3NjggKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGluZGV4IHRvIG5leHQgY2hhcmFjdGVyXHJcbi8qIGU3NjkgKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJ1c2VyKzBfMDBmM1wiKTsgICAgICAvLyBnZXQgY29sb3VyIFJBTSBieXRlXHJcbi8qIGU3NmIgKi8gICAgICAgICAgICAgICAgICAgREVZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZGVjcmVtZW50IGluZGV4IHRvIHByZXZpb3VzIGNoYXJhY3RlclxyXG4vKiBlNzZjICovICAgICAgICAgICAgICAgICAgIFNUQS5pbnkgKFwidXNlciswXzAwZjNcIik7ICAgICAgLy8gc2F2ZSBjb2xvdXIgUkFNIGJ5dGVcclxuLyogZTc2ZSAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgaW5kZXggdG8gbmV4dCBjaGFyYWN0ZXJcclxuLyogZTc2ZiAqLyAgICAgICAgICAgICAgICAgICBDUFkuenBnIChcImxubXhfMDBkNVwiKTsgICAgICAgIC8vIGNvbXBhcmUgd2l0aCBjdXJyZW50IHNjcmVlbiBsaW5lIGxlbmd0aFxyXG4vKiBlNzcxICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2U3NjJcIik7ICAgICAgICAgICAgLy8gbG9vcCBpZiBub3QgdGhlcmUgeWV0XHJcbi8qIGU3NzMgKi8gICAgICAgIF9gX2U3NzNgOyAgTERBLmltbSAoMHgyMCk7ICAgICAgICAgICAgICAgLy8gc2V0IFtTUEFDRV1cclxuLyogZTc3NSAqLyAgICAgICAgICAgICAgICAgICBTVEEuaW55IChcInBudCswXzAwZDFcIik7ICAgICAgIC8vIGNsZWFyIGxhc3QgY2hhcmFjdGVyIG9uIGN1cnJlbnQgc2NyZWVuIGxpbmVcclxuLyogZTc3NyAqLyAgICAgICAgICAgICAgICAgICBMREEuYWJzIChcImNvbG9yXzAyODZcIik7ICAgICAgIC8vIGdldCB0aGUgY3VycmVudCBjb2xvdXIgY29kZVxyXG4vKiBlNzdhICovICAgICAgICAgICAgICAgICAgIFNUQS5pbnkgKFwidXNlciswXzAwZjNcIik7ICAgICAgLy8gc2F2ZSB0byBjb2xvdXIgUkFNXHJcbi8qIGU3N2MgKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfZTdjYlwiKTsgICAgICAgICAgICAvLyBicmFuY2ggYWx3YXlzXHJcbi8qIGU3N2UgKi8gICAgICAgIF9gX2U3N2VgOyAgTERYLnpwZyAoXCJxdHN3XzAwZDRcIik7ICAgICAgICAvLyBnZXQgY3Vyc29yIHF1b3RlIGZsYWcsICR4eCA9IHF1b3RlLCAkMDAgPSBubyBxdW90ZVxyXG4vKiBlNzgwICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2U3ODVcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vdCBxdW90ZSBtb2RlXHJcbi8qIGU3ODIgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZTY5N1wiKTsgICAgICAgICAgICAvLyBpbnNlcnQgcmV2ZXJzZWQgY2hhcmFjdGVyXHJcbi8qIGU3ODUgKi8gICAgICAgIF9gX2U3ODVgOyAgQ01QLmltbSAoMHgxMik7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIFtSVlMgT05dXHJcbi8qIGU3ODcgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZTc4YlwiKTsgICAgICAgICAgICAvLyBpZiBub3QgW1JWUyBPTl0gc2tpcCBzZXR0aW5nIHRoZSByZXZlcnNlIGZsYWdcclxuLyogZTc4OSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInJ2c18wMGM3XCIpOyAgICAgICAgIC8vIGVsc2Ugc2V0IHRoZSByZXZlcnNlIGZsYWdcclxuLyogZTc4YiAqLyAgICAgICAgX2BfZTc4YmA7ICBDTVAuaW1tICgweDEzKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggW0NMUiBIT01FXVxyXG4vKiBlNzhkICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2U3OTJcIik7ICAgICAgICAgICAgLy8gaWYgbm90IFtDTFIgSE9NRV0gY29udGludWVcclxuLyogZTc4ZiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9lNTY2XCIpOyAgICAgICAgICAgIC8vIGhvbWUgdGhlIGN1cnNvclxyXG4vKiBlNzkyICovICAgICAgICBfYF9lNzkyYDsgIENNUC5pbW0gKDB4MWQpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCBbQ1VSU09SIFJJR0hUXVxyXG4vKiBlNzk0ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2U3YWRcIik7ICAgICAgICAgICAgLy8gaWYgbm90IFtDVVJTT1IgUklHSFRdIGdvID8/XHJcbi8qIGU3OTYgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IHRoZSBjdXJzb3IgY29sdW1uXHJcbi8qIGU3OTcgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZThiM1wiKTsgICAgICAgICAgICAvLyB0ZXN0IGZvciBsaW5lIGluY3JlbWVudFxyXG4vKiBlNzlhICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwicG50cl8wMGQzXCIpOyAgICAgICAgLy8gc2F2ZSB0aGUgY3Vyc29yIGNvbHVtblxyXG4vKiBlNzljICovICAgICAgICAgICAgICAgICAgIERFWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCB0aGUgY3Vyc29yIGNvbHVtblxyXG4vKiBlNzlkICovICAgICAgICAgICAgICAgICAgIENQWS56cGcgKFwibG5teF8wMGQ1XCIpOyAgICAgICAgLy8gY29tcGFyZSBjdXJzb3IgY29sdW1uIHdpdGggY3VycmVudCBzY3JlZW4gbGluZSBsZW5ndGhcclxuLyogZTc5ZiAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9lN2FhXCIpOyAgICAgICAgICAgIC8vIGV4aXQgaWYgbGVzc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgdGhlIGN1cnNvciBjb2x1bW4gaXMgPj0gdGhlIGN1cnJlbnQgc2NyZWVuIGxpbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsZW5ndGggc28gYmFjayBvbnRvIHRoZSBjdXJyZW50IGxpbmUgYW5kIGRvIGEgbmV3bGluZVxyXG4vKiBlN2ExICovICAgICAgICAgICAgICAgICAgIERFQy56cGcgKFwidGJseF8wMGQ2XCIpOyAgICAgICAgLy8gZGVjcmVtZW50IHRoZSBjdXJzb3Igcm93XHJcbi8qIGU3YTMgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZTg3Y1wiKTsgICAgICAgICAgICAvLyBkbyBuZXdsaW5lXHJcbi8qIGU3YTYgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgY3Vyc29yIGNvbHVtblxyXG4vKiBlN2E4ICovICAgICAgICBfYF9lN2E4YDsgIFNUWS56cGcgKFwicG50cl8wMGQzXCIpOyAgICAgICAgLy8gc2F2ZSB0aGUgY3Vyc29yIGNvbHVtblxyXG4vKiBlN2FhICovICAgICAgICBfYF9lN2FhYDsgIEpNUC5hYnMgKFwiX2U2YThcIik7ICAgICAgICAgICAgLy8gcmVzdG9yZSB0aGUgcmVnaXN0ZXJzLCBzZXQgdGhlIHF1b3RlIGZsYWcgYW5kIGV4aXRcclxuLyogZTdhZCAqLyAgICAgICAgX2BfZTdhZGA7ICBDTVAuaW1tICgweDExKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggW0NVUlNPUiBET1dOXVxyXG4vKiBlN2FmICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2U3Y2VcIik7ICAgICAgICAgICAgLy8gaWYgbm90IFtDVVJTT1IgRE9XTl0gZ28gPz9cclxuLyogZTdiMSAqLyAgICAgICAgICAgICAgICAgICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBjYXJyeSBmb3IgYWRkXHJcbi8qIGU3YjIgKi8gICAgICAgICAgICAgICAgICAgVFlBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSB0aGUgY3Vyc29yIGNvbHVtblxyXG4vKiBlN2IzICovICAgICAgICAgICAgICAgICAgIEFEQy5pbW0gKDB4MjgpOyAgICAgICAgICAgICAgIC8vIGFkZCBvbmUgbGluZVxyXG4vKiBlN2I1ICovICAgICAgICAgICAgICAgICAgIFRBWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgYmFjayB0byBZXHJcbi8qIGU3YjYgKi8gICAgICAgICAgICAgICAgICAgSU5DLnpwZyAoXCJ0Ymx4XzAwZDZcIik7ICAgICAgICAvLyBpbmNyZW1lbnQgdGhlIGN1cnNvciByb3dcclxuLyogZTdiOCAqLyAgICAgICAgICAgICAgICAgICBDTVAuenBnIChcImxubXhfMDBkNVwiKTsgICAgICAgIC8vIGNvbXBhcmUgY3Vyc29yIGNvbHVtbiB3aXRoIGN1cnJlbnQgc2NyZWVuIGxpbmUgbGVuZ3RoXHJcbi8qIGU3YmEgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfZTdhOFwiKTsgICAgICAgICAgICAvLyBpZiBsZXNzIGdvIHNhdmUgY3Vyc29yIGNvbHVtbiBhbmQgZXhpdFxyXG4vKiBlN2JjICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2U3YThcIik7ICAgICAgICAgICAgLy8gaWYgZXF1YWwgZ28gc2F2ZSBjdXJzb3IgY29sdW1uIGFuZCBleGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSB0aGUgY3Vyc29yIGhhcyBtb3ZlZCBiZXlvbmQgdGhlIGVuZCBvZiB0aGlzIGxpbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyBiYWNrIGl0IHVwIHVudGlsIGl0J3Mgb24gdGhlIHN0YXJ0IG9mIHRoZSBsb2dpY2FsIGxpbmVcclxuLyogZTdiZSAqLyAgICAgICAgICAgICAgICAgICBERUMuenBnIChcInRibHhfMDBkNlwiKTsgICAgICAgIC8vIGRlY3JlbWVudCB0aGUgY3Vyc29yIHJvd1xyXG4vKiBlN2MwICovICAgICAgICBfYF9lN2MwYDsgIFNCQy5pbW0gKDB4MjgpOyAgICAgICAgICAgICAgIC8vIHN1YnRyYWN0IG9uZSBsaW5lXHJcbi8qIGU3YzIgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfZTdjOFwiKTsgICAgICAgICAgICAvLyBpZiBvbiBwcmV2aW91cyBsaW5lIGV4aXQgdGhlIGxvb3BcclxuLyogZTdjNCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInBudHJfMDBkM1wiKTsgICAgICAgIC8vIGVsc2Ugc2F2ZSB0aGUgY3Vyc29yIGNvbHVtblxyXG4vKiBlN2M2ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2U3YzBcIik7ICAgICAgICAgICAgLy8gbG9vcCBpZiBub3QgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lXHJcbi8qIGU3YzggKi8gICAgICAgIF9gX2U3YzhgOyAgSlNSLmFicyAoXCJfZTg3Y1wiKTsgICAgICAgICAgICAvLyBkbyBuZXdsaW5lXHJcbi8qIGU3Y2IgKi8gICAgICAgIF9gX2U3Y2JgOyAgSk1QLmFicyAoXCJfZTZhOFwiKTsgICAgICAgICAgICAvLyByZXN0b3JlIHRoZSByZWdpc3RlcnMsIHNldCB0aGUgcXVvdGUgZmxhZyBhbmQgZXhpdFxyXG4vKiBlN2NlICovICAgICAgICBfYF9lN2NlYDsgIEpTUi5hYnMgKFwiX2U4Y2JcIik7ICAgICAgICAgICAgLy8gc2V0IHRoZSBjb2xvdXIgY29kZVxyXG4vKiBlN2QxICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2VjNDRcIik7ICAgICAgICAgICAgLy8gZ28gY2hlY2sgZm9yIHNwZWNpYWwgY2hhcmFjdGVyIGNvZGVzXHJcbi8qIGU3ZDQgKi8gICAgICAgIF9gX2U3ZDRgOyAgQU5ELmltbSAoMHg3Zik7ICAgICAgICAgICAgICAgLy8gbWFzayAweHh4IHh4eHgsIGNsZWFyIGI3XHJcbi8qIGU3ZDYgKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHg3Zik7ICAgICAgICAgICAgICAgLy8gd2FzIGl0ICRGRiBiZWZvcmUgdGhlIG1hc2tcclxuLyogZTdkOCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9lN2RjXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBub3RcclxuLyogZTdkYSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDVlKTsgICAgICAgICAgICAgICAvLyBlbHNlIG1ha2UgaXQgJDVFXHJcbi8qIGU3ZGMgKi8gICAgICAgIF9gX2U3ZGNgOyAgQ01QLmltbSAoMHgyMCk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB0aGUgY2hhcmFjdGVyIHdpdGggW1NQQUNFXVxyXG4vKiBlN2RlICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2U3ZTNcIik7ICAgICAgICAgICAgLy8gaWYgPCBbU1BBQ0VdIGdvID8/XHJcbi8qIGU3ZTAgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZTY5MVwiKTsgICAgICAgICAgICAvLyBpbnNlcnQgdXBwZXJjYXNlL2dyYXBoaWMgY2hhcmFjdGVyIGFuZCByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIgd2FzICQ4MCB0byAkOUYgYW5kIGlzIG5vdyAkMDAgdG8gJDFGXHJcbi8qIGU3ZTMgKi8gICAgICAgIF9gX2U3ZTNgOyAgQ01QLmltbSAoMHgwZCk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIFtDUl1cclxuLyogZTdlNSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9lN2VhXCIpOyAgICAgICAgICAgIC8vIGlmIG5vdCBbQ1JdIGNvbnRpbnVlXHJcbi8qIGU3ZTcgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZTg5MVwiKTsgICAgICAgICAgICAvLyBlbHNlIG91dHB1dCBbQ1JdIGFuZCByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3YXMgbm90IFtDUl1cclxuLyogZTdlYSAqLyAgICAgICAgX2BfZTdlYWA7ICBMRFguenBnIChcInF0c3dfMDBkNFwiKTsgICAgICAgIC8vIGdldCB0aGUgY3Vyc29yIHF1b3RlIGZsYWcsICR4eCA9IHF1b3RlLCAkMDAgPSBubyBxdW90ZVxyXG4vKiBlN2VjICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2U4MmRcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIHF1b3RlIG1vZGVcclxuLyogZTdlZSAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW1tICgweDE0KTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggW0lOU0VSVCBERUxFVEVdXHJcbi8qIGU3ZjAgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZTgyOVwiKTsgICAgICAgICAgICAvLyBpZiBub3QgW0lOU0VSVCBERUxFVEVdIGdvID8/XHJcbi8qIGU3ZjIgKi8gICAgICAgICAgICAgICAgICAgTERZLnpwZyAoXCJsbm14XzAwZDVcIik7ICAgICAgICAvLyBnZXQgY3VycmVudCBzY3JlZW4gbGluZSBsZW5ndGhcclxuLyogZTdmNCAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcInBudCswXzAwZDFcIik7ICAgICAgIC8vIGdldCBjaGFyYWN0ZXIgZnJvbSBjdXJyZW50IHNjcmVlbiBsaW5lXHJcbi8qIGU3ZjYgKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHgyMCk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB0aGUgY2hhcmFjdGVyIHdpdGggW1NQQUNFXVxyXG4vKiBlN2Y4ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2U3ZmVcIik7ICAgICAgICAgICAgLy8gaWYgbm90IFtTUEFDRV0gY29udGludWVcclxuLyogZTdmYSAqLyAgICAgICAgICAgICAgICAgICBDUFkuenBnIChcInBudHJfMDBkM1wiKTsgICAgICAgIC8vIGNvbXBhcmUgdGhlIGN1cnJlbnQgY29sdW1uIHdpdGggdGhlIGN1cnNvciBjb2x1bW5cclxuLyogZTdmYyAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9lODA1XCIpOyAgICAgICAgICAgIC8vIGlmIG5vdCBjdXJzb3IgY29sdW1uIGdvIG9wZW4gdXAgc3BhY2Ugb24gbGluZVxyXG4vKiBlN2ZlICovICAgICAgICBfYF9lN2ZlYDsgIENQWS5pbW0gKDB4NGYpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgY3VycmVudCBjb2x1bW4gd2l0aCBtYXggbGluZSBsZW5ndGhcclxuLyogZTgwMCAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9lODI2XCIpOyAgICAgICAgICAgIC8vIGlmIGF0IGxpbmUgZW5kIGp1c3QgZXhpdFxyXG4vKiBlODAyICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2U5NjVcIik7ICAgICAgICAgICAgLy8gZWxzZSBvcGVuIHVwIGEgc3BhY2Ugb24gdGhlIHNjcmVlblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdyBvcGVuIHVwIHNwYWNlIG9uIHRoZSBsaW5lIHRvIGluc2VydCBhIGNoYXJhY3RlclxyXG4vKiBlODA1ICovICAgICAgICBfYF9lODA1YDsgIExEWS56cGcgKFwibG5teF8wMGQ1XCIpOyAgICAgICAgLy8gZ2V0IGN1cnJlbnQgc2NyZWVuIGxpbmUgbGVuZ3RoXHJcbi8qIGU4MDcgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZWEyNFwiKTsgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHBvaW50ZXIgdG8gY29sb3VyIFJBTVxyXG4vKiBlODBhICovICAgICAgICBfYF9lODBhYDsgIERFWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCB0aGUgaW5kZXggdG8gcHJldmlvdXMgY2hhcmFjdGVyXHJcbi8qIGU4MGIgKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJwbnQrMF8wMGQxXCIpOyAgICAgICAvLyBnZXQgdGhlIGNoYXJhY3RlciBmcm9tIHRoZSBjdXJyZW50IHNjcmVlbiBsaW5lXHJcbi8qIGU4MGQgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IHRoZSBpbmRleCB0byBuZXh0IGNoYXJhY3RlclxyXG4vKiBlODBlICovICAgICAgICAgICAgICAgICAgIFNUQS5pbnkgKFwicG50KzBfMDBkMVwiKTsgICAgICAgLy8gc2F2ZSB0aGUgY2hhcmFjdGVyIHRvIHRoZSBjdXJyZW50IHNjcmVlbiBsaW5lXHJcbi8qIGU4MTAgKi8gICAgICAgICAgICAgICAgICAgREVZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZGVjcmVtZW50IHRoZSBpbmRleCB0byBwcmV2aW91cyBjaGFyYWN0ZXJcclxuLyogZTgxMSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcInVzZXIrMF8wMGYzXCIpOyAgICAgIC8vIGdldCB0aGUgY3VycmVudCBzY3JlZW4gbGluZSBjb2xvdXIgUkFNIGJ5dGVcclxuLyogZTgxMyAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgdGhlIGluZGV4IHRvIG5leHQgY2hhcmFjdGVyXHJcbi8qIGU4MTQgKi8gICAgICAgICAgICAgICAgICAgU1RBLmlueSAoXCJ1c2VyKzBfMDBmM1wiKTsgICAgICAvLyBzYXZlIHRoZSBjdXJyZW50IHNjcmVlbiBsaW5lIGNvbG91ciBSQU0gYnl0ZVxyXG4vKiBlODE2ICovICAgICAgICAgICAgICAgICAgIERFWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCB0aGUgaW5kZXggdG8gdGhlIHByZXZpb3VzIGNoYXJhY3RlclxyXG4vKiBlODE3ICovICAgICAgICAgICAgICAgICAgIENQWS56cGcgKFwicG50cl8wMGQzXCIpOyAgICAgICAgLy8gY29tcGFyZSB0aGUgaW5kZXggd2l0aCB0aGUgY3Vyc29yIGNvbHVtblxyXG4vKiBlODE5ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2U4MGFcIik7ICAgICAgICAgICAgLy8gbG9vcCBpZiBub3QgdGhlcmUgeWV0XHJcbi8qIGU4MWIgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgyMCk7ICAgICAgICAgICAgICAgLy8gc2V0IFtTUEFDRV1cclxuLyogZTgxZCAqLyAgICAgICAgICAgICAgICAgICBTVEEuaW55IChcInBudCswXzAwZDFcIik7ICAgICAgIC8vIGNsZWFyIGNoYXJhY3RlciBhdCBjdXJzb3IgcG9zaXRpb24gb24gY3VycmVudCBzY3JlZW4gbGluZVxyXG4vKiBlODFmICovICAgICAgICAgICAgICAgICAgIExEQS5hYnMgKFwiY29sb3JfMDI4NlwiKTsgICAgICAgLy8gZ2V0IGN1cnJlbnQgY29sb3VyIGNvZGVcclxuLyogZTgyMiAqLyAgICAgICAgICAgICAgICAgICBTVEEuaW55IChcInVzZXIrMF8wMGYzXCIpOyAgICAgIC8vIHNhdmUgdG8gY3Vyc29yIHBvc2l0aW9uIG9uIGN1cnJlbnQgc2NyZWVuIGxpbmUgY29sb3VyIFJBTVxyXG4vKiBlODI0ICovICAgICAgICAgICAgICAgICAgIElOQy56cGcgKFwiaW5zcnRfMDBkOFwiKTsgICAgICAgLy8gaW5jcmVtZW50IGluc2VydCBjb3VudFxyXG4vKiBlODI2ICovICAgICAgICBfYF9lODI2YDsgIEpNUC5hYnMgKFwiX2U2YThcIik7ICAgICAgICAgICAgLy8gcmVzdG9yZSB0aGUgcmVnaXN0ZXJzLCBzZXQgdGhlIHF1b3RlIGZsYWcgYW5kIGV4aXRcclxuLyogZTgyOSAqLyAgICAgICAgX2BfZTgyOWA7ICBMRFguenBnIChcImluc3J0XzAwZDhcIik7ICAgICAgIC8vIGdldCB0aGUgaW5zZXJ0IGNvdW50XHJcbi8qIGU4MmIgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZTgzMlwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbm8gaW5zZXJ0IHNwYWNlXHJcbi8qIGU4MmQgKi8gICAgICAgIF9gX2U4MmRgOyAgT1JBLmltbSAoMHg0MCk7ICAgICAgICAgICAgICAgLy8gY2hhbmdlIHRvIHVwcGVyY2FzZS9ncmFwaGljXHJcbi8qIGU4MmYgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZTY5N1wiKTsgICAgICAgICAgICAvLyBpbnNlcnQgcmV2ZXJzZWQgY2hhcmFjdGVyXHJcbi8qIGU4MzIgKi8gICAgICAgIF9gX2U4MzJgOyAgQ01QLmltbSAoMHgxMSk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIFtDVVJTT1IgVVBdXHJcbi8qIGU4MzQgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZTg0Y1wiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbm90IFtDVVJTT1IgVVBdXHJcbi8qIGU4MzYgKi8gICAgICAgICAgICAgICAgICAgTERYLnpwZyAoXCJ0Ymx4XzAwZDZcIik7ICAgICAgICAvLyBnZXQgdGhlIGN1cnNvciByb3dcclxuLyogZTgzOCAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9lODcxXCIpOyAgICAgICAgICAgIC8vIGlmIG9uIHRoZSB0b3AgbGluZSBnbyByZXN0b3JlIHRoZSByZWdpc3RlcnMsIHNldCB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBxdW90ZSBmbGFnIGFuZCBleGl0XHJcbi8qIGU4M2EgKi8gICAgICAgICAgICAgICAgICAgREVDLnpwZyAoXCJ0Ymx4XzAwZDZcIik7ICAgICAgICAvLyBkZWNyZW1lbnQgdGhlIGN1cnNvciByb3dcclxuLyogZTgzYyAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInBudHJfMDBkM1wiKTsgICAgICAgIC8vIGdldCB0aGUgY3Vyc29yIGNvbHVtblxyXG4vKiBlODNlICovICAgICAgICAgICAgICAgICAgIFNFQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNldCBjYXJyeSBmb3Igc3VidHJhY3RcclxuLyogZTgzZiAqLyAgICAgICAgICAgICAgICAgICBTQkMuaW1tICgweDI4KTsgICAgICAgICAgICAgICAvLyBzdWJ0cmFjdCBvbmUgbGluZSBsZW5ndGhcclxuLyogZTg0MSAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9lODQ3XCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBzdGVwcGVkIGJhY2sgdG8gcHJldmlvdXMgbGluZVxyXG4vKiBlODQzICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwicG50cl8wMGQzXCIpOyAgICAgICAgLy8gZWxzZSBzYXZlIHRoZSBjdXJzb3IgY29sdW1uIC4uXHJcbi8qIGU4NDUgKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfZTg3MVwiKTsgICAgICAgICAgICAvLyAuLiBhbmQgZXhpdCwgYnJhbmNoIGFsd2F5c1xyXG4vKiBlODQ3ICovICAgICAgICBfYF9lODQ3YDsgIEpTUi5hYnMgKFwiX2U1NmNcIik7ICAgICAgICAgICAgLy8gc2V0IHRoZSBzY3JlZW4gcG9pbnRlcnMgZm9yIGN1cnNvciByb3csIGNvbHVtbiAuLlxyXG4vKiBlODRhICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2U4NzFcIik7ICAgICAgICAgICAgLy8gLi4gYW5kIGV4aXQsIGJyYW5jaCBhbHdheXNcclxuLyogZTg0YyAqLyAgICAgICAgX2BfZTg0Y2A7ICBDTVAuaW1tICgweDEyKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggW1JWUyBPRkZdXHJcbi8qIGU4NGUgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZTg1NFwiKTsgICAgICAgICAgICAvLyBpZiBub3QgW1JWUyBPRkZdIGNvbnRpbnVlXHJcbi8qIGU4NTAgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gZWxzZSBjbGVhciBBXHJcbi8qIGU4NTIgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJydnNfMDBjN1wiKTsgICAgICAgICAvLyBjbGVhciB0aGUgcmV2ZXJzZSBmbGFnXHJcbi8qIGU4NTQgKi8gICAgICAgIF9gX2U4NTRgOyAgQ01QLmltbSAoMHgxZCk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIFtDVVJTT1IgTEVGVF1cclxuLyogZTg1NiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9lODZhXCIpOyAgICAgICAgICAgIC8vIGlmIG5vdCBbQ1VSU09SIExFRlRdIGdvID8/XHJcbi8qIGU4NTggKi8gICAgICAgICAgICAgICAgICAgVFlBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSB0aGUgY3Vyc29yIGNvbHVtblxyXG4vKiBlODU5ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2U4NjRcIik7ICAgICAgICAgICAgLy8gaWYgYXQgc3RhcnQgb2YgbGluZSBnbyBiYWNrIG9udG8gdGhlIHByZXZpb3VzIGxpbmVcclxuLyogZTg1YiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9lOGExXCIpOyAgICAgICAgICAgIC8vIHRlc3QgZm9yIGxpbmUgZGVjcmVtZW50XHJcbi8qIGU4NWUgKi8gICAgICAgICAgICAgICAgICAgREVZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZGVjcmVtZW50IHRoZSBjdXJzb3IgY29sdW1uXHJcbi8qIGU4NWYgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJwbnRyXzAwZDNcIik7ICAgICAgICAvLyBzYXZlIHRoZSBjdXJzb3IgY29sdW1uXHJcbi8qIGU4NjEgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZTZhOFwiKTsgICAgICAgICAgICAvLyByZXN0b3JlIHRoZSByZWdpc3RlcnMsIHNldCB0aGUgcXVvdGUgZmxhZyBhbmQgZXhpdFxyXG4vKiBlODY0ICovICAgICAgICBfYF9lODY0YDsgIEpTUi5hYnMgKFwiX2U3MDFcIik7ICAgICAgICAgICAgLy8gYmFjayBvbnRvIHRoZSBwcmV2aW91cyBsaW5lIGlmIHBvc3NpYmxlXHJcbi8qIGU4NjcgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZTZhOFwiKTsgICAgICAgICAgICAvLyByZXN0b3JlIHRoZSByZWdpc3RlcnMsIHNldCB0aGUgcXVvdGUgZmxhZyBhbmQgZXhpdFxyXG4vKiBlODZhICovICAgICAgICBfYF9lODZhYDsgIENNUC5pbW0gKDB4MTMpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCBbQ0xSXVxyXG4vKiBlODZjICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2U4NzRcIik7ICAgICAgICAgICAgLy8gaWYgbm90IFtDTFJdIGNvbnRpbnVlXHJcbi8qIGU4NmUgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZTU0NFwiKTsgICAgICAgICAgICAvLyBjbGVhciB0aGUgc2NyZWVuXHJcbi8qIGU4NzEgKi8gICAgICAgIF9gX2U4NzFgOyAgSk1QLmFicyAoXCJfZTZhOFwiKTsgICAgICAgICAgICAvLyByZXN0b3JlIHRoZSByZWdpc3RlcnMsIHNldCB0aGUgcXVvdGUgZmxhZyBhbmQgZXhpdFxyXG4vKiBlODc0ICovICAgICAgICBfYF9lODc0YDsgIE9SQS5pbW0gKDB4ODApOyAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgYjcsIGNvbG91ciBjYW4gb25seSBiZSBibGFjaywgY3lhbiwgbWFnZW50YVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIHllbGxvd1xyXG4vKiBlODc2ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2U4Y2JcIik7ICAgICAgICAgICAgLy8gc2V0IHRoZSBjb2xvdXIgY29kZVxyXG4vKiBlODc5ICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2VjNGZcIik7ICAgICAgICAgICAgLy8gZ28gY2hlY2sgZm9yIHNwZWNpYWwgY2hhcmFjdGVyIGNvZGVzIGV4Y2VwdCBmcm8gc3dpdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gbG93ZXIgY2FzZVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBkbyBuZXdsaW5lXHJcbi8qIGU4N2MgKi8gICAgICAgIF9gX2U4N2NgOyAgTFNSLnpwZyAoXCJseHNwKzBfMDBjOVwiKTsgICAgICAvLyBzaGlmdCA+PiBpbnB1dCBjdXJzb3Igcm93XHJcbi8qIGU4N2UgKi8gICAgICAgICAgICAgICAgICAgTERYLnpwZyAoXCJ0Ymx4XzAwZDZcIik7ICAgICAgICAvLyBnZXQgdGhlIGN1cnNvciByb3dcclxuLyogZTg4MCAqLyAgICAgICAgX2BfZTg4MGA7ICBJTlguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgdGhlIHJvd1xyXG4vKiBlODgxICovICAgICAgICAgICAgICAgICAgIENQWC5pbW0gKDB4MTkpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgaXQgd2l0aCBsYXN0IHJvdyArIDFcclxuLyogZTg4MyAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9lODg4XCIpOyAgICAgICAgICAgIC8vIGlmIG5vdCBsYXN0IHJvdyArIDEgc2tpcCB0aGUgc2NyZWVuIHNjcm9sbFxyXG4vKiBlODg1ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2U4ZWFcIik7ICAgICAgICAgICAgLy8gZWxzZSBzY3JvbGwgdGhlIHNjcmVlblxyXG4vKiBlODg4ICovICAgICAgICBfYF9lODg4YDsgIExEQS56cHggKDB4ZDkpOyAgICAgICAgICAgICAgIC8vIGdldCBzdGFydCBvZiBsaW5lIFggcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogZTg4YSAqLyAgICAgICAgICAgICAgICAgICBCUEwucmVsIChcIl9lODgwXCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgbm90IHN0YXJ0IG9mIGxvZ2ljYWwgbGluZVxyXG4vKiBlODhjICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwidGJseF8wMGQ2XCIpOyAgICAgICAgLy8gc2F2ZSB0aGUgY3Vyc29yIHJvd1xyXG4vKiBlODhlICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2U1NmNcIik7ICAgICAgICAgICAgLy8gc2V0IHRoZSBzY3JlZW4gcG9pbnRlcnMgZm9yIGN1cnNvciByb3csIGNvbHVtbiBhbmQgcmV0dXJuXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIG91dHB1dCBbQ1JdXHJcbi8qIGU4OTEgKi8gICAgICAgIF9gX2U4OTFgOyAgTERYLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgWFxyXG4vKiBlODkzICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwiaW5zcnRfMDBkOFwiKTsgICAgICAgLy8gY2xlYXIgdGhlIGluc2VydCBjb3VudFxyXG4vKiBlODk1ICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwicnZzXzAwYzdcIik7ICAgICAgICAgLy8gY2xlYXIgdGhlIHJldmVyc2UgZmxhZ1xyXG4vKiBlODk3ICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwicXRzd18wMGQ0XCIpOyAgICAgICAgLy8gY2xlYXIgdGhlIGN1cnNvciBxdW90ZSBmbGFnLCAkeHggPSBxdW90ZSwgJDAwID0gbm8gcXVvdGVcclxuLyogZTg5OSAqLyAgICAgICAgICAgICAgICAgICBTVFguenBnIChcInBudHJfMDBkM1wiKTsgICAgICAgIC8vIHNhdmUgdGhlIGN1cnNvciBjb2x1bW5cclxuLyogZTg5YiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9lODdjXCIpOyAgICAgICAgICAgIC8vIGRvIG5ld2xpbmVcclxuLyogZTg5ZSAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9lNmE4XCIpOyAgICAgICAgICAgIC8vIHJlc3RvcmUgdGhlIHJlZ2lzdGVycywgc2V0IHRoZSBxdW90ZSBmbGFnIGFuZCBleGl0XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHRlc3QgZm9yIGxpbmUgZGVjcmVtZW50XHJcbi8qIGU4YTEgKi8gICAgICAgIF9gX2U4YTFgOyAgTERYLmltbSAoMHgwMik7ICAgICAgICAgICAgICAgLy8gc2V0IHRoZSBjb3VudFxyXG4vKiBlOGEzICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIHNldCB0aGUgY29sdW1uXHJcbi8qIGU4YTUgKi8gICAgICAgIF9gX2U4YTVgOyAgQ01QLnpwZyAoXCJwbnRyXzAwZDNcIik7ICAgICAgICAvLyBjb21wYXJlIHRoZSBjb2x1bW4gd2l0aCB0aGUgY3Vyc29yIGNvbHVtblxyXG4vKiBlOGE3ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2U4YjBcIik7ICAgICAgICAgICAgLy8gaWYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lIGdvIGRlY3JlbWVudCB0aGUgY3Vyc29yIHJvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBleGl0XHJcbi8qIGU4YTkgKi8gICAgICAgICAgICAgICAgICAgQ0xDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBjbGVhciBjYXJyeSBmb3IgYWRkXHJcbi8qIGU4YWEgKi8gICAgICAgICAgICAgICAgICAgQURDLmltbSAoMHgyOCk7ICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IHRvIG5leHQgbGluZVxyXG4vKiBlOGFjICovICAgICAgICAgICAgICAgICAgIERFWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCBsb29wIGNvdW50XHJcbi8qIGU4YWQgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZThhNVwiKTsgICAgICAgICAgICAvLyBsb29wIGlmIG1vcmUgdG8gdGVzdFxyXG4vKiBlOGFmICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcbi8qIGU4YjAgKi8gICAgICAgIF9gX2U4YjBgOyAgREVDLnpwZyAoXCJ0Ymx4XzAwZDZcIik7ICAgICAgICAvLyBlbHNlIGRlY3JlbWVudCB0aGUgY3Vyc29yIHJvd1xyXG4vKiBlOGIyICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHRlc3QgZm9yIGxpbmUgaW5jcmVtZW50XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGF0IGVuZCBvZiB0aGUgbGluZSwgYnV0IG5vdCBhdCBlbmQgb2YgdGhlIGxhc3QgbGluZSwgaW5jcmVtZW50IHRoZSBjdXJzb3Igcm93XHJcbi8qIGU4YjMgKi8gICAgICAgIF9gX2U4YjNgOyAgTERYLmltbSAoMHgwMik7ICAgICAgICAgICAgICAgLy8gc2V0IHRoZSBjb3VudFxyXG4vKiBlOGI1ICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MjcpOyAgICAgICAgICAgICAgIC8vIHNldCB0aGUgY29sdW1uXHJcbi8qIGU4YjcgKi8gICAgICAgIF9gX2U4YjdgOyAgQ01QLnpwZyAoXCJwbnRyXzAwZDNcIik7ICAgICAgICAvLyBjb21wYXJlIHRoZSBjb2x1bW4gd2l0aCB0aGUgY3Vyc29yIGNvbHVtblxyXG4vKiBlOGI5ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2U4YzJcIik7ICAgICAgICAgICAgLy8gaWYgYXQgZW5kIG9mIGxpbmUgdGVzdCBhbmQgcG9zc2libHkgaW5jcmVtZW50IGN1cnNvciByb3dcclxuLyogZThiYiAqLyAgICAgICAgICAgICAgICAgICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBlbHNlIGNsZWFyIGNhcnJ5IGZvciBhZGRcclxuLyogZThiYyAqLyAgICAgICAgICAgICAgICAgICBBREMuaW1tICgweDI4KTsgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgdG8gdGhlIG5leHQgbGluZVxyXG4vKiBlOGJlICovICAgICAgICAgICAgICAgICAgIERFWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCB0aGUgbG9vcCBjb3VudFxyXG4vKiBlOGJmICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2U4YjdcIik7ICAgICAgICAgICAgLy8gbG9vcCBpZiBtb3JlIHRvIHRlc3RcclxuLyogZThjMSAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN1cnNvciBpcyBhdCBlbmQgb2YgbGluZVxyXG4vKiBlOGMyICovICAgICAgICBfYF9lOGMyYDsgIExEWC56cGcgKFwidGJseF8wMGQ2XCIpOyAgICAgICAgLy8gZ2V0IHRoZSBjdXJzb3Igcm93XHJcbi8qIGU4YzQgKi8gICAgICAgICAgICAgICAgICAgQ1BYLmltbSAoMHgxOSk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSBpdCB3aXRoIHRoZSBlbmQgb2YgdGhlIHNjcmVlblxyXG4vKiBlOGM2ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2U4Y2FcIik7ICAgICAgICAgICAgLy8gaWYgYXQgdGhlIGVuZCBvZiBzY3JlZW4ganVzdCBleGl0XHJcbi8qIGU4YzggKi8gICAgICAgICAgICAgICAgICAgSU5DLnpwZyAoXCJ0Ymx4XzAwZDZcIik7ICAgICAgICAvLyBlbHNlIGluY3JlbWVudCB0aGUgY3Vyc29yIHJvd1xyXG4vKiBlOGNhICovICAgICAgICBfYF9lOGNhYDsgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHNldCB0aGUgY29sb3VyIGNvZGUuIGVudGVyIHdpdGggdGhlIGNvbG91ciBjaGFyYWN0ZXIgaW4gQS4gaWYgQSBkb2VzIG5vdCBjb250YWluIGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb2xvdXIgY2hhcmFjdGVyIHRoaXMgcm91dGluZSBleGl0cyB3aXRob3V0IGNoYW5naW5nIHRoZSBjb2xvdXJcclxuLyogZThjYiAqLyAgICAgICAgX2BfZThjYmA7ICBMRFguaW1tICgweDBmKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgdGhlIGNvbG91ciBjb2RlIGNvdW50XHJcbi8qIGU4Y2QgKi8gICAgICAgIF9gX2U4Y2RgOyAgQ01QLmFieCAoXCJfZThkYVwiKTsgICAgICAgICAgICAvLyBjb21wYXJlIHRoZSBjaGFyYWN0ZXIgd2l0aCBhIHRhYmxlIGNvZGVcclxuLyogZThkMCAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9lOGQ2XCIpOyAgICAgICAgICAgIC8vIGlmIGEgbWF0Y2ggZ28gc2F2ZSB0aGUgY29sb3VyIGFuZCBleGl0XHJcbi8qIGU4ZDIgKi8gICAgICAgICAgICAgICAgICAgREVYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBkZWNyZW1lbnQgdGhlIGluZGV4XHJcbi8qIGU4ZDMgKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfZThjZFwiKTsgICAgICAgICAgICAvLyBsb29wIGlmIG1vcmUgdG8gZG9cclxuLyogZThkNSAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG4vKiBlOGQ2ICovICAgICAgICBfYF9lOGQ2YDsgIFNUWC5hYnMgKFwiY29sb3JfMDI4NlwiKTsgICAgICAgLy8gc2F2ZSB0aGUgY3VycmVudCBjb2xvdXIgY29kZVxyXG4vKiBlOGQ5ICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIEFTQ0lJIGNvbG91ciBjb2RlIHRhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ0hSJCgpICBjb2xvdXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtLS0tLS0gIC0tLS0tLVxyXG4vKiBlOGRhICovICAgICAgICBfYF9lOGRhYDsgIF8uYnl0ZXMoMHg5MCk7ICAgICAgICAgICAgICAgIC8vICAxNDQgICAgYmxhY2tcclxuLyogZThkYiAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MDUpOyAgICAgICAgICAgICAgICAvLyAgICA1ICAgIHdoaXRlIFxyXG4vKiBlOGRjICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgxYyk7ICAgICAgICAgICAgICAgIC8vICAgMjggICAgcmVkIFxyXG4vKiBlOGRkICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg5Zik7ICAgICAgICAgICAgICAgIC8vICAxNTkgICAgY3lhblxyXG4vKiBlOGRlICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg5Yyk7ICAgICAgICAgICAgICAgIC8vICAxNTYgICAgcHVycGxlXHJcbi8qIGU4ZGYgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDFlKTsgICAgICAgICAgICAgICAgLy8gICAzMCAgICBncmVlblxyXG4vKiBlOGUwICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgxZik7ICAgICAgICAgICAgICAgIC8vICAgMzEgICAgYmx1ZVxyXG4vKiBlOGUxICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg5ZSk7ICAgICAgICAgICAgICAgIC8vICAxNTggICAgeWVsbG93XHJcbi8qIGU4ZTIgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDgxKTsgICAgICAgICAgICAgICAgLy8gIDEyOSAgICBvcmFuZ2VcclxuLyogZThlMyAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4OTUpOyAgICAgICAgICAgICAgICAvLyAgMTQ5ICAgIGJyb3duXHJcbi8qIGU4ZTQgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDk2KTsgICAgICAgICAgICAgICAgLy8gIDE1MCAgICBsaWdodCByZWRcclxuLyogZThlNSAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4OTcpOyAgICAgICAgICAgICAgICAvLyAgMTUxICAgIGRhcmsgZ3JleVxyXG4vKiBlOGU2ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg5OCk7ICAgICAgICAgICAgICAgIC8vICAxNTIgICAgbWVkaXVtIGdyZXlcclxuLyogZThlNyAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4OTkpOyAgICAgICAgICAgICAgICAvLyAgMTUzICAgIGxpZ2h0IGdyZWVuXHJcbi8qIGU4ZTggKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDlhKTsgICAgICAgICAgICAgICAgLy8gIDE1NCAgICBsaWdodCBibHVlXHJcbi8qIGU4ZTkgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDliKTsgICAgICAgICAgICAgICAgLy8gIDE1NSAgICBsaWdodCBncmV5XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHNjcm9sbCB0aGUgc2NyZWVuXHJcbi8qIGU4ZWEgKi8gICAgICAgIF9gX2U4ZWFgOyAgTERBLnpwZyAoXCJzYWwrMF8wMGFjXCIpOyAgICAgICAvLyBjb3B5IHRoZSB0YXBlIGJ1ZmZlciBzdGFydCBwb2ludGVyXHJcbi8qIGU4ZWMgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBpdFxyXG4vKiBlOGVkICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwic2FsKzFfMDBhZFwiKTsgICAgICAgLy8gY29weSB0aGUgdGFwZSBidWZmZXIgc3RhcnQgcG9pbnRlclxyXG4vKiBlOGVmICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgaXRcclxuLyogZThmMCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImVhbCswXzAwYWVcIik7ICAgICAgIC8vIGNvcHkgdGhlIHRhcGUgYnVmZmVyIGVuZCBwb2ludGVyXHJcbi8qIGU4ZjIgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBpdFxyXG4vKiBlOGYzICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZWFsKzFfMDBhZlwiKTsgICAgICAgLy8gY29weSB0aGUgdGFwZSBidWZmZXIgZW5kIHBvaW50ZXJcclxuLyogZThmNSAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzYXZlIGl0XHJcbi8qIGU4ZjYgKi8gICAgICAgIF9gX2U4ZjZgOyAgTERYLmltbSAoMHhmZik7ICAgICAgICAgICAgICAgLy8gc2V0IHRvIC0xIGZvciBwcmUgaW5jcmVtZW50IGxvb3BcclxuLyogZThmOCAqLyAgICAgICAgICAgICAgICAgICBERUMuenBnIChcInRibHhfMDBkNlwiKTsgICAgICAgIC8vIGRlY3JlbWVudCB0aGUgY3Vyc29yIHJvd1xyXG4vKiBlOGZhICovICAgICAgICAgICAgICAgICAgIERFQy56cGcgKFwibHhzcCswXzAwYzlcIik7ICAgICAgLy8gZGVjcmVtZW50IHRoZSBpbnB1dCBjdXJzb3Igcm93XHJcbi8qIGU4ZmMgKi8gICAgICAgICAgICAgICAgICAgREVDLmFicyAoXCJ0bG5pZHhfMDJhNVwiKTsgICAgICAvLyBkZWNyZW1lbnQgdGhlIHNjcmVlbiByb3cgbWFya2VyXHJcbi8qIGU4ZmYgKi8gICAgICAgIF9gX2U4ZmZgOyAgSU5YLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IHRoZSBsaW5lIG51bWJlclxyXG4vKiBlOTAwICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2U5ZjBcIik7ICAgICAgICAgICAgLy8gZmV0Y2ggYSBzY3JlZW4gYWRkcmVzcywgc2V0IHRoZSBzdGFydCBvZiBsaW5lIFhcclxuLyogZTkwMyAqLyAgICAgICAgICAgICAgICAgICBDUFguaW1tICgweDE4KTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggbGFzdCBsaW5lXHJcbi8qIGU5MDUgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfZTkxM1wiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgPj0gJDE2XHJcbi8qIGU5MDcgKi8gICAgICAgICAgICAgICAgICAgTERBLmFieCAoMHhlY2YxKTsgICAgICAgICAgICAgLy8gZ2V0IHRoZSBzdGFydCBvZiB0aGUgbmV4dCBsaW5lIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogZTkwYSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInNhbCswXzAwYWNcIik7ICAgICAgIC8vIHNhdmUgdGhlIG5leHQgbGluZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGU5MGMgKi8gICAgICAgICAgICAgICAgICAgTERBLnpweCAoMHhkYSk7ICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBzdGFydCBvZiB0aGUgbmV4dCBsaW5lIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGU5MGUgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZTljOFwiKTsgICAgICAgICAgICAvLyBzaGlmdCB0aGUgc2NyZWVuIGxpbmUgdXBcclxuLyogZTkxMSAqLyAgICAgICAgICAgICAgICAgICBCTUkucmVsIChcIl9lOGZmXCIpOyAgICAgICAgICAgIC8vIGxvb3AsIGJyYW5jaCBhbHdheXNcclxuLyogZTkxMyAqLyAgICAgICAgX2BfZTkxM2A7ICBKU1IuYWJzIChcIl9lOWZmXCIpOyAgICAgICAgICAgIC8vIGNsZWFyIHNjcmVlbiBsaW5lIFhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3cgc2hpZnQgdXAgdGhlIHN0YXJ0IG9mIGxvZ2ljYWwgbGluZSBiaXRzXHJcbi8qIGU5MTYgKi8gICAgICAgICAgICAgICAgICAgTERYLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgaW5kZXhcclxuLyogZTkxOCAqLyAgICAgICAgX2BfZTkxOGA7ICBMREEuenB4ICgweGQ5KTsgICAgICAgICAgICAgICAvLyBnZXQgdGhlIHN0YXJ0IG9mIGxpbmUgWCBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBlOTFhICovICAgICAgICAgICAgICAgICAgIEFORC5pbW0gKDB4N2YpOyAgICAgICAgICAgICAgIC8vIGNsZWFyIHRoZSBsaW5lIFggc3RhcnQgb2YgbG9naWNhbCBsaW5lIGJpdFxyXG4vKiBlOTFjICovICAgICAgICAgICAgICAgICAgIExEWS56cHggKDB4ZGEpOyAgICAgICAgICAgICAgIC8vIGdldCB0aGUgc3RhcnQgb2YgdGhlIG5leHQgbGluZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBlOTFlICovICAgICAgICAgICAgICAgICAgIEJQTC5yZWwgKFwiX2U5MjJcIik7ICAgICAgICAgICAgLy8gaWYgbmV4dCBsaW5lIGlzIG5vdCBhIHN0YXJ0IG9mIGxpbmUgc2tpcCB0aGUgc3RhcnQgc2V0XHJcbi8qIGU5MjAgKi8gICAgICAgICAgICAgICAgICAgT1JBLmltbSAoMHg4MCk7ICAgICAgICAgICAgICAgLy8gc2V0IGxpbmUgWCBzdGFydCBvZiBsb2dpY2FsIGxpbmUgYml0XHJcbi8qIGU5MjIgKi8gICAgICAgIF9gX2U5MjJgOyAgU1RBLnpweCAoMHhkOSk7ICAgICAgICAgICAgICAgLy8gc2V0IHN0YXJ0IG9mIGxpbmUgWCBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBlOTI0ICovICAgICAgICAgICAgICAgICAgIElOWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBsaW5lIG51bWJlclxyXG4vKiBlOTI1ICovICAgICAgICAgICAgICAgICAgIENQWC5pbW0gKDB4MTgpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCBsYXN0IGxpbmVcclxuLyogZTkyNyAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9lOTE4XCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgbm90IGxhc3QgbGluZVxyXG4vKiBlOTI5ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwibGR0YjErMjRfMDBmMVwiKTsgICAgLy8gZ2V0IHN0YXJ0IG9mIGxhc3QgbGluZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBlOTJiICovICAgICAgICAgICAgICAgICAgIE9SQS5pbW0gKDB4ODApOyAgICAgICAgICAgICAgIC8vIG1hcmsgYXMgc3RhcnQgb2YgbG9naWNhbCBsaW5lXHJcbi8qIGU5MmQgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJsZHRiMSsyNF8wMGYxXCIpOyAgICAvLyBzZXQgc3RhcnQgb2YgbGFzdCBsaW5lIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGU5MmYgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJsZHRiMSswXzAwZDlcIik7ICAgICAvLyBnZXQgc3RhcnQgb2YgZmlyc3QgbGluZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBlOTMxICovICAgICAgICAgICAgICAgICAgIEJQTC5yZWwgKFwiX2U4ZjZcIik7ICAgICAgICAgICAgLy8gaWYgbm90IHN0YXJ0IG9mIGxvZ2ljYWwgbGluZSBsb29wIGJhY2sgYW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2Nyb2xsIHRoZSBzY3JlZW4gdXAgYW5vdGhlciBsaW5lXHJcbi8qIGU5MzMgKi8gICAgICAgICAgICAgICAgICAgSU5DLnpwZyAoXCJ0Ymx4XzAwZDZcIik7ICAgICAgICAvLyBpbmNyZW1lbnQgdGhlIGN1cnNvciByb3dcclxuLyogZTkzNSAqLyAgICAgICAgICAgICAgICAgICBJTkMuYWJzIChcInRsbmlkeF8wMmE1XCIpOyAgICAgIC8vIGluY3JlbWVudCBzY3JlZW4gcm93IG1hcmtlclxyXG4vKiBlOTM4ICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4N2YpOyAgICAgICAgICAgICAgIC8vIHNldCBrZXlib2FyZCBjb2x1bW4gYzdcclxuLyogZTkzYSAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcImNpYXByYV9kYzAwXCIpOyAgICAgIC8vIHNhdmUgVklBIDEgRFJBLCBrZXlib2FyZCBjb2x1bW4gZHJpdmVcclxuLyogZTkzZCAqLyAgICAgICAgICAgICAgICAgICBMREEuYWJzIChcImNpYXByYl9kYzAxXCIpOyAgICAgIC8vIHJlYWQgVklBIDEgRFJCLCBrZXlib2FyZCByb3cgcG9ydFxyXG4vKiBlOTQwICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4ZmIpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCByb3cgcjIgYWN0aXZlLCBbQ1RMXVxyXG4vKiBlOTQyICovICAgICAgICAgICAgICAgICAgIFBIUC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgc3RhdHVzXHJcbi8qIGU5NDMgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHg3Zik7ICAgICAgICAgICAgICAgLy8gc2V0IGtleWJvYXJkIGNvbHVtbiBjN1xyXG4vKiBlOTQ1ICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiY2lhcHJhX2RjMDBcIik7ICAgICAgLy8gc2F2ZSBWSUEgMSBEUkEsIGtleWJvYXJkIGNvbHVtbiBkcml2ZVxyXG4vKiBlOTQ4ICovICAgICAgICAgICAgICAgICAgIFBMUC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgc3RhdHVzXHJcbi8qIGU5NDkgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZTk1NlwiKTsgICAgICAgICAgICAvLyBza2lwIGRlbGF5IGlmID8/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmlyc3QgdGltZSByb3VuZCB0aGUgaW5uZXIgbG9vcCBYIHdpbGwgYmUgJDE2XHJcbi8qIGU5NGIgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgZGVsYXkgb3V0ZXIgbG9vcCBjb3VudCwgZG8gdGhpcyAyNTYgdGltZXNcclxuLyogZTk0ZCAqLyAgICAgICAgX2BfZTk0ZGA7ICBOT1AuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyB3YXN0ZSBjeWNsZXNcclxuLyogZTk0ZSAqLyAgICAgICAgICAgICAgICAgICBERVguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBkZWNyZW1lbnQgaW5uZXIgbG9vcCBjb3VudFxyXG4vKiBlOTRmICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2U5NGRcIik7ICAgICAgICAgICAgLy8gbG9vcCBpZiBub3QgYWxsIGRvbmVcclxuLyogZTk1MSAqLyAgICAgICAgICAgICAgICAgICBERVkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBkZWNyZW1lbnQgb3V0ZXIgbG9vcCBjb3VudFxyXG4vKiBlOTUyICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2U5NGRcIik7ICAgICAgICAgICAgLy8gbG9vcCBpZiBub3QgYWxsIGRvbmVcclxuLyogZTk1NCAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcIm5keF8wMGM2XCIpOyAgICAgICAgIC8vIGNsZWFyIHRoZSBrZXlib2FyZCBidWZmZXIgaW5kZXhcclxuLyogZTk1NiAqLyAgICAgICAgX2BfZTk1NmA7ICBMRFguenBnIChcInRibHhfMDBkNlwiKTsgICAgICAgIC8vIGdldCB0aGUgY3Vyc29yIHJvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgdGhlIHRhcGUgYnVmZmVyIHBvaW50ZXJzIGFuZCBleGl0XHJcbi8qIGU5NTggKi8gICAgICAgIF9gX2U5NThgOyAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVsbCB0YXBlIGJ1ZmZlciBlbmQgcG9pbnRlclxyXG4vKiBlOTU5ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZWFsKzFfMDBhZlwiKTsgICAgICAgLy8gcmVzdG9yZSBpdFxyXG4vKiBlOTViICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHB1bGwgdGFwZSBidWZmZXIgZW5kIHBvaW50ZXJcclxuLyogZTk1YyAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImVhbCswXzAwYWVcIik7ICAgICAgIC8vIHJlc3RvcmUgaXRcclxuLyogZTk1ZSAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdWxsIHRhcGUgYnVmZmVyIHBvaW50ZXJcclxuLyogZTk1ZiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInNhbCsxXzAwYWRcIik7ICAgICAgIC8vIHJlc3RvcmUgaXRcclxuLyogZTk2MSAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdWxsIHRhcGUgYnVmZmVyIHBvaW50ZXJcclxuLyogZTk2MiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInNhbCswXzAwYWNcIik7ICAgICAgIC8vIHJlc3RvcmUgaXRcclxuLyogZTk2NCAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBvcGVuIHVwIGEgc3BhY2Ugb24gdGhlIHNjcmVlblxyXG4vKiBlOTY1ICovICAgICAgICBfYF9lOTY1YDsgIExEWC56cGcgKFwidGJseF8wMGQ2XCIpOyAgICAgICAgLy8gZ2V0IHRoZSBjdXJzb3Igcm93XHJcbi8qIGU5NjcgKi8gICAgICAgIF9gX2U5NjdgOyAgSU5YLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IHRoZSByb3dcclxuLyogZTk2OCAqLyAgICAgICAgICAgICAgICAgICBMREEuenB4ICgweGQ5KTsgICAgICAgICAgICAgICAvLyBnZXQgdGhlIHN0YXJ0IG9mIGxpbmUgWCBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBlOTZhICovICAgICAgICAgICAgICAgICAgIEJQTC5yZWwgKFwiX2U5NjdcIik7ICAgICAgICAgICAgLy8gbG9vcCBpZiBub3Qgc3RhcnQgb2YgbG9naWNhbCBsaW5lXHJcbi8qIGU5NmMgKi8gICAgICAgICAgICAgICAgICAgU1RYLmFicyAoXCJ0bG5pZHhfMDJhNVwiKTsgICAgICAvLyBzYXZlIHRoZSBzY3JlZW4gcm93IG1hcmtlclxyXG4vKiBlOTZmICovICAgICAgICAgICAgICAgICAgIENQWC5pbW0gKDB4MTgpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgaXQgd2l0aCB0aGUgbGFzdCBsaW5lXHJcbi8qIGU5NzEgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZTk4MVwiKTsgICAgICAgICAgICAvLyBpZiA9IGxhc3QgbGluZSBnbyA/P1xyXG4vKiBlOTczICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2U5ODFcIik7ICAgICAgICAgICAgLy8gaWYgPCBsYXN0IGxpbmUgZ28gPz9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIGl0IHdhcyA+IGxhc3QgbGluZVxyXG4vKiBlOTc1ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2U4ZWFcIik7ICAgICAgICAgICAgLy8gc2Nyb2xsIHRoZSBzY3JlZW5cclxuLyogZTk3OCAqLyAgICAgICAgICAgICAgICAgICBMRFguYWJzIChcInRsbmlkeF8wMmE1XCIpOyAgICAgIC8vIGdldCB0aGUgc2NyZWVuIHJvdyBtYXJrZXJcclxuLyogZTk3YiAqLyAgICAgICAgICAgICAgICAgICBERVguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBkZWNyZW1lbnQgdGhlIHNjcmVlbiByb3cgbWFya2VyXHJcbi8qIGU5N2MgKi8gICAgICAgICAgICAgICAgICAgREVDLnpwZyAoXCJ0Ymx4XzAwZDZcIik7ICAgICAgICAvLyBkZWNyZW1lbnQgdGhlIGN1cnNvciByb3dcclxuLyogZTk3ZSAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9lNmRhXCIpOyAgICAgICAgICAgIC8vIGFkZCB0aGlzIHJvdyB0byB0aGUgY3VycmVudCBsb2dpY2FsIGxpbmUgYW5kIHJldHVyblxyXG4vKiBlOTgxICovICAgICAgICBfYF9lOTgxYDsgIExEQS56cGcgKFwic2FsKzBfMDBhY1wiKTsgICAgICAgLy8gY29weSB0YXBlIGJ1ZmZlciBwb2ludGVyXHJcbi8qIGU5ODMgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBpdFxyXG4vKiBlOTg0ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwic2FsKzFfMDBhZFwiKTsgICAgICAgLy8gY29weSB0YXBlIGJ1ZmZlciBwb2ludGVyXHJcbi8qIGU5ODYgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBpdFxyXG4vKiBlOTg3ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZWFsKzBfMDBhZVwiKTsgICAgICAgLy8gY29weSB0YXBlIGJ1ZmZlciBlbmQgcG9pbnRlclxyXG4vKiBlOTg5ICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgaXRcclxuLyogZTk4YSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImVhbCsxXzAwYWZcIik7ICAgICAgIC8vIGNvcHkgdGFwZSBidWZmZXIgZW5kIHBvaW50ZXJcclxuLyogZTk4YyAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzYXZlIGl0XHJcbi8qIGU5OGQgKi8gICAgICAgICAgICAgICAgICAgTERYLmltbSAoMHgxOSk7ICAgICAgICAgICAgICAgLy8gc2V0IHRvIGVuZCBsaW5lICsgMSBmb3IgcHJlZGVjcmVtZW50IGxvb3BcclxuLyogZTk4ZiAqLyAgICAgICAgX2BfZTk4ZmA7ICBERVguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBkZWNyZW1lbnQgdGhlIGxpbmUgbnVtYmVyXHJcbi8qIGU5OTAgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZTlmMFwiKTsgICAgICAgICAgICAvLyBmZXRjaCBhIHNjcmVlbiBhZGRyZXNzXHJcbi8qIGU5OTMgKi8gICAgICAgICAgICAgICAgICAgQ1BYLmFicyAoXCJ0bG5pZHhfMDJhNVwiKTsgICAgICAvLyBjb21wYXJlIGl0IHdpdGggdGhlIHNjcmVlbiByb3cgbWFya2VyXHJcbi8qIGU5OTYgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfZTlhNlwiKTsgICAgICAgICAgICAvLyBpZiA8IHNjcmVlbiByb3cgbWFya2VyIGdvID8/XHJcbi8qIGU5OTggKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZTlhNlwiKTsgICAgICAgICAgICAvLyBpZiA9IHNjcmVlbiByb3cgbWFya2VyIGdvID8/XHJcbi8qIGU5OWEgKi8gICAgICAgICAgICAgICAgICAgTERBLmFieCAoMHhlY2VmKTsgICAgICAgICAgICAgLy8gZWxzZSBnZXQgdGhlIHN0YXJ0IG9mIHRoZSBwcmV2aW91cyBsaW5lIGxvdyBieXRlIGZyb20gdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUk9NIHRhYmxlXHJcbi8qIGU5OWQgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJzYWwrMF8wMGFjXCIpOyAgICAgICAvLyBzYXZlIHByZXZpb3VzIGxpbmUgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBlOTlmICovICAgICAgICAgICAgICAgICAgIExEQS56cHggKDB4ZDgpOyAgICAgICAgICAgICAgIC8vIGdldCB0aGUgc3RhcnQgb2YgdGhlIHByZXZpb3VzIGxpbmUgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogZTlhMSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9lOWM4XCIpOyAgICAgICAgICAgIC8vIHNoaWZ0IHRoZSBzY3JlZW4gbGluZSBkb3duXHJcbi8qIGU5YTQgKi8gICAgICAgICAgICAgICAgICAgQk1JLnJlbCAoXCJfZTk4ZlwiKTsgICAgICAgICAgICAvLyBsb29wLCBicmFuY2ggYWx3YXlzXHJcbi8qIGU5YTYgKi8gICAgICAgIF9gX2U5YTZgOyAgSlNSLmFicyAoXCJfZTlmZlwiKTsgICAgICAgICAgICAvLyBjbGVhciBzY3JlZW4gbGluZSBYXHJcbi8qIGU5YTkgKi8gICAgICAgICAgICAgICAgICAgTERYLmltbSAoMHgxNyk7XHJcbi8qIGU5YWIgKi8gICAgICAgIF9gX2U5YWJgOyAgQ1BYLmFicyAoXCJ0bG5pZHhfMDJhNVwiKTsgICAgICAvLyBjb21wYXJlIGl0IHdpdGggdGhlIHNjcmVlbiByb3cgbWFya2VyXHJcbi8qIGU5YWUgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfZTliZlwiKTtcclxuLyogZTliMCAqLyAgICAgICAgICAgICAgICAgICBMREEuenB4ICgweGRhKTtcclxuLyogZTliMiAqLyAgICAgICAgICAgICAgICAgICBBTkQuaW1tICgweDdmKTtcclxuLyogZTliNCAqLyAgICAgICAgICAgICAgICAgICBMRFkuenB4ICgweGQ5KTsgICAgICAgICAgICAgICAvLyBnZXQgc3RhcnQgb2YgbGluZSBYIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGU5YjYgKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfZTliYVwiKTtcclxuLyogZTliOCAqLyAgICAgICAgICAgICAgICAgICBPUkEuaW1tICgweDgwKTtcclxuLyogZTliYSAqLyAgICAgICAgX2BfZTliYWA7ICBTVEEuenB4ICgweGRhKTtcclxuLyogZTliYyAqLyAgICAgICAgICAgICAgICAgICBERVguaW1wICgpO1xyXG4vKiBlOWJkICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2U5YWJcIik7XHJcbi8qIGU5YmYgKi8gICAgICAgIF9gX2U5YmZgOyAgTERYLmFicyAoXCJ0bG5pZHhfMDJhNVwiKTsgICAgICAvLyBnZXQgdGhlIHNjcmVlbiByb3cgbWFya2VyXHJcbi8qIGU5YzIgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZTZkYVwiKTsgICAgICAgICAgICAvLyBhZGQgdGhpcyByb3cgdG8gdGhlIGN1cnJlbnQgbG9naWNhbCBsaW5lXHJcbi8qIGU5YzUgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZTk1OFwiKTsgICAgICAgICAgICAvLyByZXN0b3JlIHRoZSB0YXBlIGJ1ZmZlciBwb2ludGVycyBhbmQgZXhpdFxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzaGlmdCBzY3JlZW4gbGluZSB1cC9kb3duXHJcbi8qIGU5YzggKi8gICAgICAgIF9gX2U5YzhgOyAgQU5ELmltbSAoMHgwMyk7ICAgICAgICAgICAgICAgLy8gbWFzayAwMDAwIDAweHgsIGxpbmUgbWVtb3J5IHBhZ2VcclxuLyogZTljYSAqLyAgICAgICAgICAgICAgICAgICBPUkEuYWJzIChcImhpYmFzZV8wMjg4XCIpOyAgICAgIC8vIE9SIHdpdGggc2NyZWVuIG1lbW9yeSBwYWdlXHJcbi8qIGU5Y2QgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJzYWwrMV8wMGFkXCIpOyAgICAgICAvLyBzYXZlIG5leHQvcHJldmlvdXMgbGluZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBlOWNmICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2U5ZTBcIik7ICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHBvaW50ZXJzIHRvIHNjcmVlbiBsaW5lcyBjb2xvdXIgUkFNXHJcbi8qIGU5ZDIgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgyNyk7ICAgICAgICAgICAgICAgLy8gc2V0IHRoZSBjb2x1bW4gY291bnRcclxuLyogZTlkNCAqLyAgICAgICAgX2BfZTlkNGA7ICBMREEuaW55IChcInNhbCswXzAwYWNcIik7ICAgICAgIC8vIGdldCBjaGFyYWN0ZXIgZnJvbSBuZXh0L3ByZXZpb3VzIHNjcmVlbiBsaW5lXHJcbi8qIGU5ZDYgKi8gICAgICAgICAgICAgICAgICAgU1RBLmlueSAoXCJwbnQrMF8wMGQxXCIpOyAgICAgICAvLyBzYXZlIGNoYXJhY3RlciB0byBjdXJyZW50IHNjcmVlbiBsaW5lXHJcbi8qIGU5ZDggKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJlYWwrMF8wMGFlXCIpOyAgICAgICAvLyBnZXQgY29sb3VyIGZyb20gbmV4dC9wcmV2aW91cyBzY3JlZW4gbGluZSBjb2xvdXIgUkFNXHJcbi8qIGU5ZGEgKi8gICAgICAgICAgICAgICAgICAgU1RBLmlueSAoXCJ1c2VyKzBfMDBmM1wiKTsgICAgICAvLyBzYXZlIGNvbG91ciB0byBjdXJyZW50IHNjcmVlbiBsaW5lIGNvbG91ciBSQU1cclxuLyogZTlkYyAqLyAgICAgICAgICAgICAgICAgICBERVkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBkZWNyZW1lbnQgY29sdW1uIGluZGV4L2NvdW50XHJcbi8qIGU5ZGQgKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfZTlkNFwiKTsgICAgICAgICAgICAvLyBsb29wIGlmIG1vcmUgdG8gZG9cclxuLyogZTlkZiAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBjYWxjdWxhdGUgcG9pbnRlcnMgdG8gc2NyZWVuIGxpbmVzIGNvbG91ciBSQU1cclxuLyogZTllMCAqLyAgICAgICAgX2BfZTllMGA7ICBKU1IuYWJzIChcIl9lYTI0XCIpOyAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgcG9pbnRlciB0byB0aGUgY3VycmVudCBzY3JlZW4gbGluZSBjb2xvdXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSQU1cclxuLyogZTllMyAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInNhbCswXzAwYWNcIik7ICAgICAgIC8vIGdldCB0aGUgbmV4dCBzY3JlZW4gbGluZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGU5ZTUgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJlYWwrMF8wMGFlXCIpOyAgICAgICAvLyBzYXZlIHRoZSBuZXh0IHNjcmVlbiBsaW5lIGNvbG91ciBSQU0gcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBlOWU3ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwic2FsKzFfMDBhZFwiKTsgICAgICAgLy8gZ2V0IHRoZSBuZXh0IHNjcmVlbiBsaW5lIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGU5ZTkgKi8gICAgICAgICAgICAgICAgICAgQU5ELmltbSAoMHgwMyk7ICAgICAgICAgICAgICAgLy8gbWFzayAwMDAwIDAweHgsIGxpbmUgbWVtb3J5IHBhZ2VcclxuLyogZTllYiAqLyAgICAgICAgICAgICAgICAgICBPUkEuaW1tICgweGQ4KTsgICAgICAgICAgICAgICAvLyBzZXQgIDExMDEgMDF4eCwgY29sb3VyIG1lbW9yeSBwYWdlXHJcbi8qIGU5ZWQgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJlYWwrMV8wMGFmXCIpOyAgICAgICAvLyBzYXZlIHRoZSBuZXh0IHNjcmVlbiBsaW5lIGNvbG91ciBSQU0gcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogZTllZiAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBmZXRjaCBhIHNjcmVlbiBhZGRyZXNzXHJcbi8qIGU5ZjAgKi8gICAgICAgIF9gX2U5ZjBgOyAgTERBLmFieCAoXCJfZWNmMFwiKTsgICAgICAgICAgICAvLyBnZXQgdGhlIHN0YXJ0IG9mIGxpbmUgbG93IGJ5dGUgZnJvbSB0aGUgUk9NIHRhYmxlXHJcbi8qIGU5ZjMgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJwbnQrMF8wMGQxXCIpOyAgICAgICAvLyBzZXQgdGhlIGN1cnJlbnQgc2NyZWVuIGxpbmUgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBlOWY1ICovICAgICAgICAgICAgICAgICAgIExEQS56cHggKDB4ZDkpOyAgICAgICAgICAgICAgIC8vIGdldCB0aGUgc3RhcnQgb2YgbGluZSBoaWdoIGJ5dGUgZnJvbSB0aGUgUkFNIHRhYmxlXHJcbi8qIGU5ZjcgKi8gICAgICAgICAgICAgICAgICAgQU5ELmltbSAoMHgwMyk7ICAgICAgICAgICAgICAgLy8gbWFzayAwMDAwIDAweHgsIGxpbmUgbWVtb3J5IHBhZ2VcclxuLyogZTlmOSAqLyAgICAgICAgICAgICAgICAgICBPUkEuYWJzIChcImhpYmFzZV8wMjg4XCIpOyAgICAgIC8vIE9SIHdpdGggdGhlIHNjcmVlbiBtZW1vcnkgcGFnZVxyXG4vKiBlOWZjICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwicG50KzFfMDBkMlwiKTsgICAgICAgLy8gc2F2ZSB0aGUgY3VycmVudCBzY3JlZW4gbGluZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBlOWZlICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGNsZWFyIHNjcmVlbiBsaW5lIFhcclxuLyogZTlmZiAqLyAgICAgICAgX2BfZTlmZmA7ICBMRFkuaW1tICgweDI3KTsgICAgICAgICAgICAgICAvLyBzZXQgbnVtYmVyIG9mIGNvbHVtbnMgdG8gY2xlYXJcclxuLyogZWEwMSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9lOWYwXCIpOyAgICAgICAgICAgIC8vIGZldGNoIGEgc2NyZWVuIGFkZHJlc3NcclxuLyogZWEwNCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9lYTI0XCIpOyAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgcG9pbnRlciB0byBjb2xvdXIgUkFNXHJcbi8qIGVhMDcgKi8gICAgICAgIF9gX2VhMDdgOyAgSlNSLmFicyAoXCJfZTRkYVwiKTsgICAgICAgICAgICAvLyBzYXZlIHRoZSBjdXJyZW50IGNvbG91ciB0byB0aGUgY29sb3VyIFJBTVxyXG4vKiBlYTBhICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MjApOyAgICAgICAgICAgICAgIC8vIHNldCBbU1BBQ0VdXHJcbi8qIGVhMGMgKi8gICAgICAgICAgICAgICAgICAgU1RBLmlueSAoXCJwbnQrMF8wMGQxXCIpOyAgICAgICAvLyBjbGVhciBjaGFyYWN0ZXIgaW4gY3VycmVudCBzY3JlZW4gbGluZVxyXG4vKiBlYTBlICovICAgICAgICAgICAgICAgICAgIERFWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCBpbmRleFxyXG4vKiBlYTBmICovICAgICAgICAgICAgICAgICAgIEJQTC5yZWwgKFwiX2VhMDdcIik7ICAgICAgICAgICAgLy8gbG9vcCBpZiBtb3JlIHRvIGRvXHJcbi8qIGVhMTEgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gb3JwaGFuIGJ5dGVcclxuLyogZWExMiAqLyAgICAgICAgICAgICAgICAgICBOT1AuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyB1bnVzZWRcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcHJpbnQgY2hhcmFjdGVyIEEgYW5kIGNvbG91ciBYXHJcbi8qIGVhMTMgKi8gICAgICAgIF9gX2VhMTNgOyAgVEFZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSB0aGUgY2hhcmFjdGVyXHJcbi8qIGVhMTQgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMik7ICAgICAgICAgICAgICAgLy8gY291bnQgdG8gJDAyLCB1c3VhbGx5ICQxNCA/P1xyXG4vKiBlYTE2ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiYmxuY3RfMDBjZFwiKTsgICAgICAgLy8gc2F2ZSB0aGUgY3Vyc29yIGNvdW50ZG93blxyXG4vKiBlYTE4ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2VhMjRcIik7ICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBwb2ludGVyIHRvIGNvbG91ciBSQU1cclxuLyogZWExYiAqLyAgICAgICAgICAgICAgICAgICBUWUEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGNoYXJhY3RlciBiYWNrXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHNhdmUgdGhlIGNoYXJhY3RlciBhbmQgY29sb3VyIHRvIHRoZSBzY3JlZW4gQCB0aGUgY3Vyc29yXHJcbi8qIGVhMWMgKi8gICAgICAgIF9gX2VhMWNgOyAgTERZLnpwZyAoXCJwbnRyXzAwZDNcIik7ICAgICAgICAvLyBnZXQgdGhlIGN1cnNvciBjb2x1bW5cclxuLyogZWExZSAqLyAgICAgICAgICAgICAgICAgICBTVEEuaW55IChcInBudCswXzAwZDFcIik7ICAgICAgIC8vIHNhdmUgdGhlIGNoYXJhY3RlciBmcm9tIGN1cnJlbnQgc2NyZWVuIGxpbmVcclxuLyogZWEyMCAqLyAgICAgICAgICAgICAgICAgICBUWEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IHRoZSBjb2xvdXIgdG8gQVxyXG4vKiBlYTIxICovICAgICAgICAgICAgICAgICAgIFNUQS5pbnkgKFwidXNlciswXzAwZjNcIik7ICAgICAgLy8gc2F2ZSB0byBjb2xvdXIgUkFNXHJcbi8qIGVhMjMgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY2FsY3VsYXRlIHRoZSBwb2ludGVyIHRvIGNvbG91ciBSQU1cclxuLyogZWEyNCAqLyAgICAgICAgX2BfZWEyNGA7ICBMREEuenBnIChcInBudCswXzAwZDFcIik7ICAgICAgIC8vIGdldCBjdXJyZW50IHNjcmVlbiBsaW5lIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogZWEyNiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInVzZXIrMF8wMGYzXCIpOyAgICAgIC8vIHNhdmUgcG9pbnRlciB0byBjb2xvdXIgUkFNIGxvdyBieXRlXHJcbi8qIGVhMjggKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJwbnQrMV8wMGQyXCIpOyAgICAgICAvLyBnZXQgY3VycmVudCBzY3JlZW4gbGluZSBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBlYTJhICovICAgICAgICAgICAgICAgICAgIEFORC5pbW0gKDB4MDMpOyAgICAgICAgICAgICAgIC8vIG1hc2sgMDAwMCAwMHh4LCBsaW5lIG1lbW9yeSBwYWdlXHJcbi8qIGVhMmMgKi8gICAgICAgICAgICAgICAgICAgT1JBLmltbSAoMHhkOCk7ICAgICAgICAgICAgICAgLy8gc2V0ICAxMTAxIDAxeHgsIGNvbG91ciBtZW1vcnkgcGFnZVxyXG4vKiBlYTJlICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwidXNlcisxXzAwZjRcIik7ICAgICAgLy8gc2F2ZSBwb2ludGVyIHRvIGNvbG91ciBSQU0gaGlnaCBieXRlXHJcbi8qIGVhMzAgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gSVJRIHZlY3RvclxyXG4vKiBlYTMxICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwidWR0aW1fZmZlYVwiKTsgICAgICAgLy8gaW5jcmVtZW50IHRoZSByZWFsIHRpbWUgY2xvY2tcclxuLyogZWEzNCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImJsbnN3XzAwY2NcIik7ICAgICAgIC8vIGdldCB0aGUgY3Vyc29yIGVuYWJsZSwgJDAwID0gZmxhc2ggY3Vyc29yXHJcbi8qIGVhMzYgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZWE2MVwiKTsgICAgICAgICAgICAvLyBpZiBmbGFzaCBub3QgZW5hYmxlZCBza2lwIHRoZSBmbGFzaFxyXG4vKiBlYTM4ICovICAgICAgICAgICAgICAgICAgIERFQy56cGcgKFwiYmxuY3RfMDBjZFwiKTsgICAgICAgLy8gZGVjcmVtZW50IHRoZSBjdXJzb3IgdGltaW5nIGNvdW50ZG93blxyXG4vKiBlYTNhICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2VhNjFcIik7ICAgICAgICAgICAgLy8gaWYgbm90IGNvdW50ZWQgb3V0IHNraXAgdGhlIGZsYXNoXHJcbi8qIGVhM2MgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgxNCk7ICAgICAgICAgICAgICAgLy8gc2V0IHRoZSBmbGFzaCBjb3VudFxyXG4vKiBlYTNlICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiYmxuY3RfMDBjZFwiKTsgICAgICAgLy8gc2F2ZSB0aGUgY3Vyc29yIHRpbWluZyBjb3VudGRvd25cclxuLyogZWE0MCAqLyAgICAgICAgICAgICAgICAgICBMRFkuenBnIChcInBudHJfMDBkM1wiKTsgICAgICAgIC8vIGdldCB0aGUgY3Vyc29yIGNvbHVtblxyXG4vKiBlYTQyICovICAgICAgICAgICAgICAgICAgIExTUi56cGcgKFwiYmxub25fMDBjZlwiKTsgICAgICAgLy8gc2hpZnQgYjAgY3Vyc29yIGJsaW5rIHBoYXNlIGludG8gY2FycnlcclxuLyogZWE0NCAqLyAgICAgICAgICAgICAgICAgICBMRFguYWJzIChcImdkY29sXzAyODdcIik7ICAgICAgIC8vIGdldCB0aGUgY29sb3VyIHVuZGVyIHRoZSBjdXJzb3JcclxuLyogZWE0NyAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcInBudCswXzAwZDFcIik7ICAgICAgIC8vIGdldCB0aGUgY2hhcmFjdGVyIGZyb20gY3VycmVudCBzY3JlZW4gbGluZVxyXG4vKiBlYTQ5ICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2VhNWNcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIGN1cnNvciBwaGFzZSBiMCB3YXMgMVxyXG4vKiBlYTRiICovICAgICAgICAgICAgICAgICAgIElOQy56cGcgKFwiYmxub25fMDBjZlwiKTsgICAgICAgLy8gc2V0IHRoZSBjdXJzb3IgYmxpbmsgcGhhc2UgdG8gMVxyXG4vKiBlYTRkICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZ2RibG5fMDBjZVwiKTsgICAgICAgLy8gc2F2ZSB0aGUgY2hhcmFjdGVyIHVuZGVyIHRoZSBjdXJzb3JcclxuLyogZWE0ZiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9lYTI0XCIpOyAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgcG9pbnRlciB0byBjb2xvdXIgUkFNXHJcbi8qIGVhNTIgKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJ1c2VyKzBfMDBmM1wiKTsgICAgICAvLyBnZXQgdGhlIGNvbG91ciBSQU0gYnl0ZVxyXG4vKiBlYTU0ICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiZ2Rjb2xfMDI4N1wiKTsgICAgICAgLy8gc2F2ZSB0aGUgY29sb3VyIHVuZGVyIHRoZSBjdXJzb3JcclxuLyogZWE1NyAqLyAgICAgICAgICAgICAgICAgICBMRFguYWJzIChcImNvbG9yXzAyODZcIik7ICAgICAgIC8vIGdldCB0aGUgY3VycmVudCBjb2xvdXIgY29kZVxyXG4vKiBlYTVhICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZ2RibG5fMDBjZVwiKTsgICAgICAgLy8gZ2V0IHRoZSBjaGFyYWN0ZXIgdW5kZXIgdGhlIGN1cnNvclxyXG4vKiBlYTVjICovICAgICAgICBfYF9lYTVjYDsgIEVPUi5pbW0gKDB4ODApOyAgICAgICAgICAgICAgIC8vIHRvZ2dsZSBiNyBvZiBjaGFyYWN0ZXIgdW5kZXIgY3Vyc29yXHJcbi8qIGVhNWUgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZWExY1wiKTsgICAgICAgICAgICAvLyBzYXZlIHRoZSBjaGFyYWN0ZXIgYW5kIGNvbG91ciB0byB0aGUgc2NyZWVuIEAgdGhlIGN1cnNvclxyXG4vKiBlYTYxICovICAgICAgICBfYF9lYTYxYDsgIExEQS56cGcgKFwicjY1MTBfMDAwMVwiKTsgICAgICAgLy8gcmVhZCB0aGUgNjUxMCBJL08gcG9ydFxyXG4vKiBlYTYzICovICAgICAgICAgICAgICAgICAgIEFORC5pbW0gKDB4MTApOyAgICAgICAgICAgICAgIC8vIG1hc2sgMDAweCAwMDAwLCB0aGUgY2Fzc2V0dGUgc3dpdGNoIHNlbnNlXHJcbi8qIGVhNjUgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZWE3MVwiKTsgICAgICAgICAgICAvLyBpZiB0aGUgY2Fzc2V0dGUgc2Vuc2UgaXMgbG93IHNraXAgdGhlIG1vdG9yIHN0b3BcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgY2Fzc2V0dGUgc2Vuc2Ugd2FzIGhpZ2gsIHRoZSBzd2l0Y2ggd2FzIG9wZW4sIHNvIHR1cm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvZmYgdGhlIG1vdG9yIGFuZCBjbGVhciB0aGUgaW50ZXJsb2NrXHJcbi8qIGVhNjcgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgWVxyXG4vKiBlYTY5ICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwiY2FzMV8wMGMwXCIpOyAgICAgICAgLy8gY2xlYXIgdGhlIHRhcGUgbW90b3IgaW50ZXJsb2NrXHJcbi8qIGVhNmIgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJyNjUxMF8wMDAxXCIpOyAgICAgICAvLyByZWFkIHRoZSA2NTEwIEkvTyBwb3J0XHJcbi8qIGVhNmQgKi8gICAgICAgICAgICAgICAgICAgT1JBLmltbSAoMHgyMCk7ICAgICAgICAgICAgICAgLy8gbWFzayB4eHh4IHh4MXgsIHR1cm4gb2ZmIHRoZSBtb3RvclxyXG4vKiBlYTZmICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2VhNzlcIik7ICAgICAgICAgICAgLy8gZ28gc2F2ZSB0aGUgcG9ydCB2YWx1ZSwgYnJhbmNoIGFsd2F5c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBjYXNzZXR0ZSBzZW5zZSB3YXMgbG93IHNvIHR1cm4gdGhlIG1vdG9yIG9uLCBwZXJoYXBzXHJcbi8qIGVhNzEgKi8gICAgICAgIF9gX2VhNzFgOyAgTERBLnpwZyAoXCJjYXMxXzAwYzBcIik7ICAgICAgICAvLyBnZXQgdGhlIHRhcGUgbW90b3IgaW50ZXJsb2NrXHJcbi8qIGVhNzMgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZWE3YlwiKTsgICAgICAgICAgICAvLyBpZiB0aGUgY2Fzc2V0dGUgaW50ZXJsb2NrIDw+IDAgZG9uJ3QgdHVybiBvbiBtb3RvclxyXG4vKiBlYTc1ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwicjY1MTBfMDAwMVwiKTsgICAgICAgLy8gcmVhZCB0aGUgNjUxMCBJL08gcG9ydFxyXG4vKiBlYTc3ICovICAgICAgICAgICAgICAgICAgIEFORC5pbW0gKDB4MWYpOyAgICAgICAgICAgICAgIC8vIG1hc2sgeHh4eCB4eDB4LCB0dXJuIG9uIHRoZSBtb3RvclxyXG4vKiBlYTc5ICovICAgICAgICBfYF9lYTc5YDsgIFNUQS56cGcgKFwicjY1MTBfMDAwMVwiKTsgICAgICAgLy8gc2F2ZSB0aGUgNjUxMCBJL08gcG9ydFxyXG4vKiBlYTdiICovICAgICAgICBfYF9lYTdiYDsgIEpTUi5hYnMgKFwic2Nua2V5X2VhODdcIik7ICAgICAgLy8gc2NhbiB0aGUga2V5Ym9hcmRcclxuLyogZWE3ZSAqLyAgICAgICAgICAgICAgICAgICBMREEuYWJzIChcImNpYWljcl9kYzBkXCIpOyAgICAgIC8vIHJlYWQgVklBIDEgSUNSLCBjbGVhciB0aGUgdGltZXIgaW50ZXJydXB0IGZsYWdcclxuLyogZWE4MSAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdWxsIFlcclxuLyogZWE4MiAqLyAgICAgICAgICAgICAgICAgICBUQVkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIFlcclxuLyogZWE4MyAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdWxsIFhcclxuLyogZWE4NCAqLyAgICAgICAgICAgICAgICAgICBUQVguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIFhcclxuLyogZWE4NSAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIEFcclxuLyogZWE4NiAqLyAgICAgICAgICAgICAgICAgICBSVEkuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzY2FuIGtleWJvYXJkIHBlcmZvcm1zIHRoZSBmb2xsb3dpbmcgLi5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMSkgY2hlY2sgaWYga2V5IHByZXNzZWQsIGlmIG5vdCB0aGVuIGV4aXQgdGhlIHJvdXRpbmVcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMikgaW5pdCBJL08gcG9ydHMgb2YgVklBID8/IGZvciBrZXlib2FyZCBzY2FuIGFuZCBzZXQgcG9pbnRlcnMgdG8gZGVjb2RlIHRhYmxlIDEuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgdGhlIGNoYXJhY3RlciBjb3VudGVyXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDMpIHNldCBvbmUgbGluZSBvZiBwb3J0IEIgbG93IGFuZCB0ZXN0IGZvciBhIGNsb3NlZCBrZXkgb24gcG9ydCBBIGJ5IHNoaWZ0aW5nIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ5dGUgcmVhZCBmcm9tIHRoZSBwb3J0LiBpZiB0aGUgY2FycnkgaXMgY2xlYXIgdGhlbiBhIGtleSBpcyBjbG9zZWQgc28gc2F2ZSB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb3VudCB3aGljaCBpcyBpbmNyZW1lbnRlZCBvbiBlYWNoIHNoaWZ0LiBjaGVjayBmb3Igc2hpZnQvc3RvcC9jYm0ga2V5cyBhbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmbGFnIGlmIGNsb3NlZFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA0KSByZXBlYXQgc3RlcCAzIGZvciB0aGUgd2hvbGUgbWF0cml4XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDUpIGV2YWx1YXRlIHRoZSBTSElGVC9DVFJML0M9IGtleXMsIHRoaXMgbWF5IGNoYW5nZSB0aGUgZGVjb2RlIHRhYmxlIHNlbGVjdGVkXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDYpIHVzZSB0aGUga2V5IGNvdW50IHNhdmVkIGluIHN0ZXAgMyBhcyBhbiBpbmRleCBpbnRvIHRoZSB0YWJsZSBzZWxlY3RlZCBpbiBzdGVwIDVcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gNykgY2hlY2sgZm9yIGtleSByZXBlYXQgb3BlcmF0aW9uXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDgpIHNhdmUgdGhlIGRlY29kZWQga2V5IHRvIHRoZSBidWZmZXIgaWYgZmlyc3QgcHJlc3Mgb3IgcmVwZWF0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2NhbiB0aGUga2V5Ym9hcmRcclxuLyogZWE4NyAqLyAgX2BzY25rZXlfZWE4N2A7ICBMREEuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBBXHJcbi8qIGVhODkgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJzaGZsYWdfMDI4ZFwiKTsgICAgICAvLyBjbGVhciB0aGUga2V5Ym9hcmQgc2hpZnQvY29udHJvbC9jPSBmbGFnXHJcbi8qIGVhOGMgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHg0MCk7ICAgICAgICAgICAgICAgLy8gc2V0IG5vIGtleVxyXG4vKiBlYThlICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwic2ZkeF8wMGNiXCIpOyAgICAgICAgLy8gc2F2ZSB3aGljaCBrZXlcclxuLyogZWE5MCAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcImNpYXByYV9kYzAwXCIpOyAgICAgIC8vIGNsZWFyIFZJQSAxIERSQSwga2V5Ym9hcmQgY29sdW1uIGRyaXZlXHJcbi8qIGVhOTMgKi8gICAgICAgICAgICAgICAgICAgTERYLmFicyAoXCJjaWFwcmJfZGMwMVwiKTsgICAgICAvLyByZWFkIFZJQSAxIERSQiwga2V5Ym9hcmQgcm93IHBvcnRcclxuLyogZWE5NiAqLyAgICAgICAgICAgICAgICAgICBDUFguaW1tICgweGZmKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggYWxsIGJpdHMgc2V0XHJcbi8qIGVhOTggKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZWFmYlwiKTsgICAgICAgICAgICAvLyBpZiBubyBrZXkgcHJlc3NlZCBjbGVhciBjdXJyZW50IGtleSBhbmQgZXhpdCAoZG9lc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZ1cnRoZXIgQkVRIHRvICRFQkJBKVxyXG4vKiBlYTlhICovICAgICAgICAgICAgICAgICAgIFRBWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIHRoZSBrZXkgY291bnRcclxuLyogZWE5YiAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDgxKTsgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGRlY29kZSB0YWJsZSBsb3cgYnl0ZVxyXG4vKiBlYTlkICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwia2V5dGFiKzBfMDBmNVwiKTsgICAgLy8gc2F2ZSB0aGUga2V5Ym9hcmQgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBlYTlmICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4ZWIpOyAgICAgICAgICAgICAgIC8vIGdldCB0aGUgZGVjb2RlIHRhYmxlIGhpZ2ggYnl0ZVxyXG4vKiBlYWExICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwia2V5dGFiKzFfMDBmNlwiKTsgICAgLy8gc2F2ZSB0aGUga2V5Ym9hcmQgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogZWFhMyAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweGZlKTsgICAgICAgICAgICAgICAvLyBzZXQgY29sdW1uIDAgbG93XHJcbi8qIGVhYTUgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJjaWFwcmFfZGMwMFwiKTsgICAgICAvLyBzYXZlIFZJQSAxIERSQSwga2V5Ym9hcmQgY29sdW1uIGRyaXZlXHJcbi8qIGVhYTggKi8gICAgICAgIF9gX2VhYThgOyAgTERYLmltbSAoMHgwOCk7ICAgICAgICAgICAgICAgLy8gc2V0IHRoZSByb3cgY291bnRcclxuLyogZWFhYSAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzYXZlIHRoZSBjb2x1bW5cclxuLyogZWFhYiAqLyAgICAgICAgX2BfZWFhYmA7ICBMREEuYWJzIChcImNpYXByYl9kYzAxXCIpOyAgICAgIC8vIHJlYWQgVklBIDEgRFJCLCBrZXlib2FyZCByb3cgcG9ydFxyXG4vKiBlYWFlICovICAgICAgICAgICAgICAgICAgIENNUC5hYnMgKFwiY2lhcHJiX2RjMDFcIik7ICAgICAgLy8gY29tcGFyZSBpdCB3aXRoIGl0c2VsZlxyXG4vKiBlYWIxICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2VhYWJcIik7ICAgICAgICAgICAgLy8gbG9vcCBpZiBjaGFuZ2luZ1xyXG4vKiBlYWIzICovICAgICAgICBfYF9lYWIzYDsgIExTUi5hY2MgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNoaWZ0IHJvdyB0byBDYlxyXG4vKiBlYWI0ICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2VhY2NcIik7ICAgICAgICAgICAgLy8gaWYgbm8ga2V5IGNsb3NlZCBvbiB0aGlzIHJvdyBnbyBkbyBuZXh0IHJvd1xyXG4vKiBlYWI2ICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgcm93XHJcbi8qIGVhYjcgKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJrZXl0YWIrMF8wMGY1XCIpOyAgICAvLyBnZXQgY2hhcmFjdGVyIGZyb20gZGVjb2RlIHRhYmxlXHJcbi8qIGVhYjkgKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHgwNSk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoICQwNSwgdGhlcmUgaXMgbm8gJDA1IGtleSBidXQgdGhlIGNvbnRyb2xcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBrZXlzIGFyZSBhbGwgbGVzcyB0aGFuICQwNVxyXG4vKiBlYWJiICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2VhYzlcIik7ICAgICAgICAgICAgLy8gaWYgbm90IHNoaWZ0L2NvbnRyb2wvYz0vc3RvcCBnbyBzYXZlIGtleSBjb3VudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2Ugd2FzIHNoaWZ0L2NvbnRyb2wvYz0vc3RvcCBrZXlcclxuLyogZWFiZCAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW1tICgweDAzKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggJDAzLCBzdG9wXHJcbi8qIGVhYmYgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZWFjOVwiKTsgICAgICAgICAgICAvLyBpZiBzdG9wIGdvIHNhdmUga2V5IGNvdW50IGFuZCBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoYXJhY3RlciBpcyAkMDEgLSBzaGlmdCwgJDAyIC0gYz0gb3IgJDA0IC0gY29udHJvbFxyXG4vKiBlYWMxICovICAgICAgICAgICAgICAgICAgIE9SQS5hYnMgKFwic2hmbGFnXzAyOGRcIik7ICAgICAgLy8gT1IgaXQgd2l0aCB0aGUga2V5Ym9hcmQgc2hpZnQvY29udHJvbC9jPSBmbGFnXHJcbi8qIGVhYzQgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJzaGZsYWdfMDI4ZFwiKTsgICAgICAvLyBzYXZlIHRoZSBrZXlib2FyZCBzaGlmdC9jb250cm9sL2M9IGZsYWdcclxuLyogZWFjNyAqLyAgICAgICAgICAgICAgICAgICBCUEwucmVsIChcIl9lYWNiXCIpOyAgICAgICAgICAgIC8vIHNraXAgc2F2ZSBrZXksIGJyYW5jaCBhbHdheXNcclxuLyogZWFjOSAqLyAgICAgICAgX2BfZWFjOWA7ICBTVFkuenBnIChcInNmZHhfMDBjYlwiKTsgICAgICAgIC8vIHNhdmUga2V5IGNvdW50XHJcbi8qIGVhY2IgKi8gICAgICAgIF9gX2VhY2JgOyAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSByb3dcclxuLyogZWFjYyAqLyAgICAgICAgX2BfZWFjY2A7ICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQga2V5IGNvdW50XHJcbi8qIGVhY2QgKi8gICAgICAgICAgICAgICAgICAgQ1BZLmltbSAoMHg0MSk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIG1heCsxXHJcbi8qIGVhY2YgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfZWFkY1wiKTsgICAgICAgICAgICAvLyBleGl0IGxvb3AgaWYgPj0gbWF4KzFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIHN0aWxsIGluIG1hdHJpeFxyXG4vKiBlYWQxICovICAgICAgICAgICAgICAgICAgIERFWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCByb3cgY291bnRcclxuLyogZWFkMiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9lYWIzXCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgbW9yZSByb3dzIHRvIGRvXHJcbi8qIGVhZDQgKi8gICAgICAgICAgICAgICAgICAgU0VDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2V0IGNhcnJ5IGZvciBrZXlib2FyZCBjb2x1bW4gc2hpZnRcclxuLyogZWFkNSAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIHRoZSBjb2x1bW5cclxuLyogZWFkNiAqLyAgICAgICAgICAgICAgICAgICBST0wuYWNjICgpOyAgICAgICAgICAgICAgICAgICAvLyBzaGlmdCB0aGUga2V5Ym9hcmQgY29sdW1uXHJcbi8qIGVhZDcgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJjaWFwcmFfZGMwMFwiKTsgICAgICAvLyBzYXZlIFZJQSAxIERSQSwga2V5Ym9hcmQgY29sdW1uIGRyaXZlXHJcbi8qIGVhZGEgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZWFhOFwiKTsgICAgICAgICAgICAvLyBsb29wIGZvciBuZXh0IGNvbHVtbiwgYnJhbmNoIGFsd2F5c1xyXG4vKiBlYWRjICovICAgICAgICBfYF9lYWRjYDsgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGR1bXAgdGhlIHNhdmVkIGNvbHVtblxyXG4vKiBlYWRkICovICAgICAgICAgICAgICAgICAgIEpNUC5pbmQgKFwia2V5bG9nKzBfMDI4ZlwiKTsgICAgLy8gZXZhbHVhdGUgdGhlIFNISUZUL0NUUkwvQz0ga2V5cywgJEVCRENcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBrZXkgZGVjb2RpbmcgY29udGludWVzIGhlcmUgYWZ0ZXIgdGhlIFNISUZUL0NUUkwvQz0ga2V5cyBhcmUgZXZhbHVhdGVkXHJcbi8qIGVhZTAgKi8gICAgICAgIF9gX2VhZTBgOyAgTERZLnpwZyAoXCJzZmR4XzAwY2JcIik7ICAgICAgICAvLyBnZXQgc2F2ZWQga2V5IGNvdW50XHJcbi8qIGVhZTIgKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJrZXl0YWIrMF8wMGY1XCIpOyAgICAvLyBnZXQgY2hhcmFjdGVyIGZyb20gZGVjb2RlIHRhYmxlXHJcbi8qIGVhZTQgKi8gICAgICAgICAgICAgICAgICAgVEFYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBjaGFyYWN0ZXIgdG8gWFxyXG4vKiBlYWU1ICovICAgICAgICAgICAgICAgICAgIENQWS56cGcgKFwibHN0eF8wMGM1XCIpOyAgICAgICAgLy8gY29tcGFyZSBrZXkgY291bnQgd2l0aCBsYXN0IGtleSBjb3VudFxyXG4vKiBlYWU3ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2VhZjBcIik7ICAgICAgICAgICAgLy8gaWYgdGhpcyBrZXkgPSBjdXJyZW50IGtleSwga2V5IGhlbGQsIGdvIHRlc3QgcmVwZWF0XHJcbi8qIGVhZTkgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgxMCk7ICAgICAgICAgICAgICAgLy8gc2V0IHRoZSByZXBlYXQgZGVsYXkgY291bnRcclxuLyogZWFlYiAqLyAgICAgICAgICAgICAgICAgICBTVFkuYWJzIChcImRlbGF5XzAyOGNcIik7ICAgICAgIC8vIHNhdmUgdGhlIHJlcGVhdCBkZWxheSBjb3VudFxyXG4vKiBlYWVlICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2ViMjZcIik7ICAgICAgICAgICAgLy8gZ28gc2F2ZSBrZXkgdG8gYnVmZmVyIGFuZCBleGl0LCBicmFuY2ggYWx3YXlzXHJcbi8qIGVhZjAgKi8gICAgICAgIF9gX2VhZjBgOyAgQU5ELmltbSAoMHg3Zik7ICAgICAgICAgICAgICAgLy8gY2xlYXIgYjdcclxuLyogZWFmMiAqLyAgICAgICAgICAgICAgICAgICBCSVQuYWJzIChcInJwdGZsZ18wMjhhXCIpOyAgICAgIC8vIHRlc3Qga2V5IHJlcGVhdFxyXG4vKiBlYWY1ICovICAgICAgICAgICAgICAgICAgIEJNSS5yZWwgKFwiX2ViMGRcIik7ICAgICAgICAgICAgLy8gaWYgcmVwZWF0IGFsbCBnbyA/P1xyXG4vKiBlYWY3ICovICAgICAgICAgICAgICAgICAgIEJWUy5yZWwgKFwiX2ViNDJcIik7ICAgICAgICAgICAgLy8gaWYgcmVwZWF0IG5vbmUgZ28gPz9cclxuLyogZWFmOSAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW1tICgweDdmKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggZW5kIG1hcmtlclxyXG4vKiBlYWZiICovICAgICAgICBfYF9lYWZiYDsgIEJFUS5yZWwgKFwiX2ViMjZcIik7ICAgICAgICAgICAgLy8gaWYgJDAwL2VuZCBtYXJrZXIgZ28gc2F2ZSBrZXkgdG8gYnVmZmVyIGFuZCBleGl0XHJcbi8qIGVhZmQgKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHgxNCk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIFtJTlNFUlRdL1tERUxFVEVdXHJcbi8qIGVhZmYgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZWIwZFwiKTsgICAgICAgICAgICAvLyBpZiBbSU5TRVJUXS9bREVMRVRFXSBnbyB0ZXN0IGZvciByZXBlYXRcclxuLyogZWIwMSAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW1tICgweDIwKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggW1NQQUNFXVxyXG4vKiBlYjAzICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2ViMGRcIik7ICAgICAgICAgICAgLy8gaWYgW1NQQUNFXSBnbyB0ZXN0IGZvciByZXBlYXRcclxuLyogZWIwNSAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW1tICgweDFkKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggW0NVUlNPUiBSSUdIVF1cclxuLyogZWIwNyAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9lYjBkXCIpOyAgICAgICAgICAgIC8vIGlmIFtDVVJTT1IgUklHSFRdIGdvIHRlc3QgZm9yIHJlcGVhdFxyXG4vKiBlYjA5ICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4MTEpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCBbQ1VSU09SIERPV05dXHJcbi8qIGViMGIgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZWI0MlwiKTsgICAgICAgICAgICAvLyBpZiBub3QgW0NVUlNPUiBET1dOXSBqdXN0IGV4aXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3YXMgb25lIG9mIHRoZSBjdXJzb3IgbW92ZW1lbnQga2V5cywgaW5zZXJ0L2RlbGV0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGtleSBvciB0aGUgc3BhY2UgYmFyIHNvIGFsd2F5cyBkbyByZXBlYXQgdGVzdHNcclxuLyogZWIwZCAqLyAgICAgICAgX2BfZWIwZGA7ICBMRFkuYWJzIChcImRlbGF5XzAyOGNcIik7ICAgICAgIC8vIGdldCB0aGUgcmVwZWF0IGRlbGF5IGNvdW50ZXJcclxuLyogZWIxMCAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9lYjE3XCIpOyAgICAgICAgICAgIC8vIGlmIGRlbGF5IGV4cGlyZWQgZ28gPz9cclxuLyogZWIxMiAqLyAgICAgICAgICAgICAgICAgICBERUMuYWJzIChcImRlbGF5XzAyOGNcIik7ICAgICAgIC8vIGVsc2UgZGVjcmVtZW50IHJlcGVhdCBkZWxheSBjb3VudGVyXHJcbi8qIGViMTUgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZWI0MlwiKTsgICAgICAgICAgICAvLyBpZiBkZWxheSBub3QgZXhwaXJlZCBnbyA/P1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlcGVhdCBkZWxheSBjb3VudGVyIGhhcyBleHBpcmVkXHJcbi8qIGViMTcgKi8gICAgICAgIF9gX2ViMTdgOyAgREVDLmFicyAoXCJrb3VudF8wMjhiXCIpOyAgICAgICAvLyBkZWNyZW1lbnQgdGhlIHJlcGVhdCBzcGVlZCBjb3VudGVyXHJcbi8qIGViMWEgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZWI0MlwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgcmVwZWF0IHNwZWVkIGNvdW50IG5vdCBleHBpcmVkXHJcbi8qIGViMWMgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgwNCk7ICAgICAgICAgICAgICAgLy8gc2V0IGZvciA0LzYwdGhzIG9mIGEgc2Vjb25kXHJcbi8qIGViMWUgKi8gICAgICAgICAgICAgICAgICAgU1RZLmFicyAoXCJrb3VudF8wMjhiXCIpOyAgICAgICAvLyBzYXZlIHRoZSByZXBlYXQgc3BlZWQgY291bnRlclxyXG4vKiBlYjIxICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwibmR4XzAwYzZcIik7ICAgICAgICAgLy8gZ2V0IHRoZSBrZXlib2FyZCBidWZmZXIgaW5kZXhcclxuLyogZWIyMyAqLyAgICAgICAgICAgICAgICAgICBERVkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBkZWNyZW1lbnQgaXRcclxuLyogZWIyNCAqLyAgICAgICAgICAgICAgICAgICBCUEwucmVsIChcIl9lYjQyXCIpOyAgICAgICAgICAgIC8vIGlmIHRoZSBidWZmZXIgaXNuJ3QgZW1wdHkganVzdCBleGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSByZXBlYXQgdGhlIGtleSBpbW1lZGlhdGVseVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBvc3NpYmx5IHNhdmUgdGhlIGtleSB0byB0aGUga2V5Ym9hcmQgYnVmZmVyLiBpZiB0aGVyZSB3YXMgbm8ga2V5IHByZXNzZWQgb3IgdGhlIGtleVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdhcyBub3QgZm91bmQgZHVyaW5nIHRoZSBzY2FuIChwb3NzaWJseSBkdWUgdG8ga2V5IGJvdW5jZSkgdGhlbiBYIHdpbGwgYmUgJEZGIGhlcmVcclxuLyogZWIyNiAqLyAgICAgICAgX2BfZWIyNmA7ICBMRFkuenBnIChcInNmZHhfMDBjYlwiKTsgICAgICAgIC8vIGdldCB0aGUga2V5IGNvdW50XHJcbi8qIGViMjggKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJsc3R4XzAwYzVcIik7ICAgICAgICAvLyBzYXZlIGl0IGFzIHRoZSBjdXJyZW50IGtleSBjb3VudFxyXG4vKiBlYjJhICovICAgICAgICAgICAgICAgICAgIExEWS5hYnMgKFwic2hmbGFnXzAyOGRcIik7ICAgICAgLy8gZ2V0IHRoZSBrZXlib2FyZCBzaGlmdC9jb250cm9sL2M9IGZsYWdcclxuLyogZWIyZCAqLyAgICAgICAgICAgICAgICAgICBTVFkuYWJzIChcImxzdHNoZl8wMjhlXCIpOyAgICAgIC8vIHNhdmUgaXQgYXMgbGFzdCBrZXlib2FyZCBzaGlmdCBwYXR0ZXJuXHJcbi8qIGViMzAgKi8gICAgICAgICAgICAgICAgICAgQ1BYLmltbSAoMHhmZik7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB0aGUgY2hhcmFjdGVyIHdpdGggdGhlIHRhYmxlIGVuZCBtYXJrZXIgb3Igbm8ga2V5XHJcbi8qIGViMzIgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZWI0MlwiKTsgICAgICAgICAgICAvLyBpZiBpdCB3YXMgdGhlIHRhYmxlIGVuZCBtYXJrZXIgb3Igbm8ga2V5IGp1c3QgZXhpdFxyXG4vKiBlYjM0ICovICAgICAgICAgICAgICAgICAgIFRYQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgdGhlIGNoYXJhY3RlciB0byBBXHJcbi8qIGViMzUgKi8gICAgICAgICAgICAgICAgICAgTERYLnpwZyAoXCJuZHhfMDBjNlwiKTsgICAgICAgICAvLyBnZXQgdGhlIGtleWJvYXJkIGJ1ZmZlciBpbmRleFxyXG4vKiBlYjM3ICovICAgICAgICAgICAgICAgICAgIENQWC5hYnMgKFwieG1heF8wMjg5XCIpOyAgICAgICAgLy8gY29tcGFyZSBpdCB3aXRoIHRoZSBrZXlib2FyZCBidWZmZXIgc2l6ZVxyXG4vKiBlYjNhICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2ViNDJcIik7ICAgICAgICAgICAgLy8gaWYgdGhlIGJ1ZmZlciBpcyBmdWxsIGp1c3QgZXhpdFxyXG4vKiBlYjNjICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnggKFwia2V5ZCswXzAyNzdcIik7ICAgICAgLy8gc2F2ZSB0aGUgY2hhcmFjdGVyIHRvIHRoZSBrZXlib2FyZCBidWZmZXJcclxuLyogZWIzZiAqLyAgICAgICAgICAgICAgICAgICBJTlguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgdGhlIGluZGV4XHJcbi8qIGViNDAgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJuZHhfMDBjNlwiKTsgICAgICAgICAvLyBzYXZlIHRoZSBrZXlib2FyZCBidWZmZXIgaW5kZXhcclxuLyogZWI0MiAqLyAgICAgICAgX2BfZWI0MmA7ICBMREEuaW1tICgweDdmKTsgICAgICAgICAgICAgICAvLyBlbmFibGUgY29sdW1uIDcgZm9yIHRoZSBzdG9wIGtleVxyXG4vKiBlYjQ0ICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiY2lhcHJhX2RjMDBcIik7ICAgICAgLy8gc2F2ZSBWSUEgMSBEUkEsIGtleWJvYXJkIGNvbHVtbiBkcml2ZVxyXG4vKiBlYjQ3ICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGV2YWx1YXRlIHRoZSBTSElGVC9DVFJML0M9IGtleXNcclxuLyogZWI0OCAqLyAgICAgICAgICAgICAgICAgICBMREEuYWJzIChcInNoZmxhZ18wMjhkXCIpOyAgICAgIC8vIGdldCB0aGUga2V5Ym9hcmQgc2hpZnQvY29udHJvbC9jPSBmbGFnXHJcbi8qIGViNGIgKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHgwMyk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIFtTSElGVF1bQz1dXHJcbi8qIGViNGQgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZWI2NFwiKTsgICAgICAgICAgICAvLyBpZiBub3QgW1NISUZUXVtDPV0gZ28gPz9cclxuLyogZWI0ZiAqLyAgICAgICAgICAgICAgICAgICBDTVAuYWJzIChcImxzdHNoZl8wMjhlXCIpOyAgICAgIC8vIGNvbXBhcmUgd2l0aCBsYXN0XHJcbi8qIGViNTIgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZWI0MlwiKTsgICAgICAgICAgICAvLyBleGl0IGlmIHN0aWxsIHRoZSBzYW1lXHJcbi8qIGViNTQgKi8gICAgICAgICAgICAgICAgICAgTERBLmFicyAoXCJtb2RlXzAyOTFcIik7ICAgICAgICAvLyBnZXQgdGhlIHNoaWZ0IG1vZGUgc3dpdGNoICQwMCA9IGVuYWJsZWQsICQ4MCA9IGxvY2tlZFxyXG4vKiBlYjU3ICovICAgICAgICAgICAgICAgICAgIEJNSS5yZWwgKFwiX2ViNzZcIik7ICAgICAgICAgICAgLy8gaWYgbG9ja2VkIGNvbnRpbnVlIGtleWJvYXJkIGRlY29kZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvZ2dsZSB0ZXh0IG1vZGVcclxuLyogZWI1OSAqLyAgICAgICAgICAgICAgICAgICBMREEuYWJzIChcInZtY3NiX2QwMThcIik7ICAgICAgIC8vIGdldCB0aGUgc3RhcnQgb2YgY2hhcmFjdGVyIG1lbW9yeSBhZGRyZXNzXHJcbi8qIGViNWMgKi8gICAgICAgICAgICAgICAgICAgRU9SLmltbSAoMHgwMik7ICAgICAgICAgICAgICAgLy8gdG9nZ2xlIGFkZHJlc3MgYjFcclxuLyogZWI1ZSAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcInZtY3NiX2QwMThcIik7ICAgICAgIC8vIHNhdmUgdGhlIHN0YXJ0IG9mIGNoYXJhY3RlciBtZW1vcnkgYWRkcmVzc1xyXG4vKiBlYjYxICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2ViNzZcIik7ICAgICAgICAgICAgLy8gY29udGludWUgdGhlIGtleWJvYXJkIGRlY29kZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlbGVjdCBrZXlib2FyZCB0YWJsZVxyXG4vKiBlYjY0ICovICAgICAgICBfYF9lYjY0YDsgIEFTTC5hY2MgKCk7ICAgICAgICAgICAgICAgICAgIC8vIDw8IDFcclxuLyogZWI2NSAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW1tICgweDA4KTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggW0NUUkxdXHJcbi8qIGViNjcgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfZWI2YlwiKTsgICAgICAgICAgICAvLyBpZiBbQ1RSTF0gaXMgbm90IHByZXNzZWQgc2tpcCB0aGUgaW5kZXggY2hhbmdlXHJcbi8qIGViNjkgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwNik7ICAgICAgICAgICAgICAgLy8gZWxzZSBbQ1RSTF0gd2FzIHByZXNzZWQgc28gbWFrZSB0aGUgaW5kZXggPSAkMDZcclxuLyogZWI2YiAqLyAgICAgICAgX2BfZWI2YmA7ICBUQVguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IHRoZSBpbmRleCB0byBYXHJcbi8qIGViNmMgKi8gICAgICAgICAgICAgICAgICAgTERBLmFieCAoXCJfZWI3OVwiKTsgICAgICAgICAgICAvLyBnZXQgdGhlIGRlY29kZSB0YWJsZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGViNmYgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJrZXl0YWIrMF8wMGY1XCIpOyAgICAvLyBzYXZlIHRoZSBkZWNvZGUgdGFibGUgcG9pbnRlciBsb3cgYnl0ZVxyXG4vKiBlYjcxICovICAgICAgICAgICAgICAgICAgIExEQS5hYnggKDB4ZWI3YSk7ICAgICAgICAgICAgIC8vIGdldCB0aGUgZGVjb2RlIHRhYmxlIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGViNzQgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJrZXl0YWIrMV8wMGY2XCIpOyAgICAvLyBzYXZlIHRoZSBkZWNvZGUgdGFibGUgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogZWI3NiAqLyAgICAgICAgX2BfZWI3NmA7ICBKTVAuYWJzIChcIl9lYWUwXCIpOyAgICAgICAgICAgIC8vIGNvbnRpbnVlIHRoZSBrZXlib2FyZCBkZWNvZGVcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gdGFibGUgYWRkcmVzc2VzXHJcbi8qIGViNzkgKi8gICAgICAgIF9gX2ViNzlgOyAgXy5ieXRlcygweDgxLCAweGViKTsgICAgICAgICAgLy8gc3RhbmRhcmRcclxuLyogZWI3YiAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4YzIsIDB4ZWIpOyAgICAgICAgICAvLyBzaGlmdFxyXG4vKiBlYjdkICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgwMywgMHhlYyk7ICAgICAgICAgIC8vIGNvbW1vZG9yZVxyXG4vKiBlYjdmICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg3OCwgMHhlYyk7ICAgICAgICAgIC8vIGNvbnRyb2xcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gc3RhbmRhcmQga2V5Ym9hcmQgdGFibGVcclxuLyogZWI4MSAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MTQsIDB4MGQsIDB4MWQsIDB4ODgsIDB4ODUsIDB4ODYsIDB4ODcsIDB4MTEpO1xyXG4vKiBlYjg5ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgzMywgMHg1NywgMHg0MSwgMHgzNCwgMHg1YSwgMHg1MywgMHg0NSwgMHgwMSk7XHJcbi8qIGViOTEgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDM1LCAweDUyLCAweDQ0LCAweDM2LCAweDQzLCAweDQ2LCAweDU0LCAweDU4KTtcclxuLyogZWI5OSAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MzcsIDB4NTksIDB4NDcsIDB4MzgsIDB4NDIsIDB4NDgsIDB4NTUsIDB4NTYpO1xyXG4vKiBlYmExICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgzOSwgMHg0OSwgMHg0YSwgMHgzMCwgMHg0ZCwgMHg0YiwgMHg0ZiwgMHg0ZSk7XHJcbi8qIGViYTkgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDJiLCAweDUwLCAweDRjLCAweDJkLCAweDJlLCAweDNhLCAweDQwLCAweDJjKTtcclxuLyogZWJiMSAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NWMsIDB4MmEsIDB4M2IsIDB4MTMsIDB4MDEsIDB4M2QsIDB4NWUsIDB4MmYpO1xyXG4vKiBlYmI5ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgzMSwgMHg1ZiwgMHgwNCwgMHgzMiwgMHgyMCwgMHgwMiwgMHg1MSwgMHgwMyk7XHJcbi8qIGViYzEgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweGZmKTtcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzaGlmdGVkIGtleWJvYXJkIHRhYmxlXHJcbi8qIGViYzIgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDk0LCAweDhkLCAweDlkLCAweDhjLCAweDg5LCAweDhhLCAweDhiLCAweDkxKTtcclxuLyogZWJjYSAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MjMsIDB4ZDcsIDB4YzEsIDB4MjQsIDB4ZGEsIDB4ZDMsIDB4YzUsIDB4MDEpO1xyXG4vKiBlYmQyICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgyNSwgMHhkMiwgMHhjNCwgMHgyNiwgMHhjMywgMHhjNiwgMHhkNCwgMHhkOCk7XHJcbi8qIGViZGEgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDI3LCAweGQ5LCAweGM3LCAweDI4LCAweGMyLCAweGM4LCAweGQ1LCAweGQ2KTtcclxuLyogZWJlMiAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MjksIDB4YzksIDB4Y2EsIDB4MzAsIDB4Y2QsIDB4Y2IsIDB4Y2YsIDB4Y2UpO1xyXG4vKiBlYmVhICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHhkYiwgMHhkMCwgMHhjYywgMHhkZCwgMHgzZSwgMHg1YiwgMHhiYSwgMHgzYyk7XHJcbi8qIGViZjIgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweGE5LCAweGMwLCAweDVkLCAweDkzLCAweDAxLCAweDNkLCAweGRlLCAweDNmKTtcclxuLyogZWJmYSAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MjEsIDB4NWYsIDB4MDQsIDB4MjIsIDB4YTAsIDB4MDIsIDB4ZDEsIDB4ODMpO1xyXG4vKiBlYzAyICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHhmZik7XHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gQ0JNIGtleSBrZXlib2FyZCB0YWJsZVxyXG4vKiBlYzAzICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg5NCwgMHg4ZCwgMHg5ZCwgMHg4YywgMHg4OSwgMHg4YSwgMHg4YiwgMHg5MSk7XHJcbi8qIGVjMGIgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDk2LCAweGIzLCAweGIwLCAweDk3LCAweGFkLCAweGFlLCAweGIxLCAweDAxKTtcclxuLyogZWMxMyAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4OTgsIDB4YjIsIDB4YWMsIDB4OTksIDB4YmMsIDB4YmIsIDB4YTMsIDB4YmQpO1xyXG4vKiBlYzFiICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg5YSwgMHhiNywgMHhhNSwgMHg5YiwgMHhiZiwgMHhiNCwgMHhiOCwgMHhiZSk7XHJcbi8qIGVjMjMgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDI5LCAweGEyLCAweGI1LCAweDMwLCAweGE3LCAweGExLCAweGI5LCAweGFhKTtcclxuLyogZWMyYiAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4YTYsIDB4YWYsIDB4YjYsIDB4ZGMsIDB4M2UsIDB4NWIsIDB4YTQsIDB4M2MpO1xyXG4vKiBlYzMzICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHhhOCwgMHhkZiwgMHg1ZCwgMHg5MywgMHgwMSwgMHgzZCwgMHhkZSwgMHgzZik7XHJcbi8qIGVjM2IgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDgxLCAweDVmLCAweDA0LCAweDk1LCAweGEwLCAweDAyLCAweGFiLCAweDgzKTtcclxuLyogZWM0MyAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4ZmYpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBjaGVjayBmb3Igc3BlY2lhbCBjaGFyYWN0ZXIgY29kZXNcclxuLyogZWM0NCAqLyAgICAgICAgX2BfZWM0NGA7ICBDTVAuaW1tICgweDBlKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggW1NXSVRDSCBUTyBMT1dFUiBDQVNFXVxyXG4vKiBlYzQ2ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2VjNGZcIik7ICAgICAgICAgICAgLy8gaWYgbm90IFtTV0lUQ0ggVE8gTE9XRVIgQ0FTRV0gc2tpcCB0aGUgc3dpdGNoXHJcbi8qIGVjNDggKi8gICAgICAgICAgICAgICAgICAgTERBLmFicyAoXCJ2bWNzYl9kMDE4XCIpOyAgICAgICAvLyBnZXQgdGhlIHN0YXJ0IG9mIGNoYXJhY3RlciBtZW1vcnkgYWRkcmVzc1xyXG4vKiBlYzRiICovICAgICAgICAgICAgICAgICAgIE9SQS5pbW0gKDB4MDIpOyAgICAgICAgICAgICAgIC8vIG1hc2sgeHh4eCB4eDF4LCBzZXQgbG93ZXIgY2FzZSBjaGFyYWN0ZXJzXHJcbi8qIGVjNGQgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZWM1OFwiKTsgICAgICAgICAgICAvLyBnbyBzYXZlIHRoZSBuZXcgdmFsdWUsIGJyYW5jaCBhbHdheXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3Igc3BlY2lhbCBjaGFyYWN0ZXIgY29kZXMgZXhjZXB0IGZybyBzd2l0Y2ggdG8gbG93ZXIgY2FzZVxyXG4vKiBlYzRmICovICAgICAgICBfYF9lYzRmYDsgIENNUC5pbW0gKDB4OGUpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCBbU1dJVENIIFRPIFVQUEVSIENBU0VdXHJcbi8qIGVjNTEgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZWM1ZVwiKTsgICAgICAgICAgICAvLyBpZiBub3QgW1NXSVRDSCBUTyBVUFBFUiBDQVNFXSBnbyBkbyB0aGUgW1NISUZUXStbQz1dIGtleVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrXHJcbi8qIGVjNTMgKi8gICAgICAgICAgICAgICAgICAgTERBLmFicyAoXCJ2bWNzYl9kMDE4XCIpOyAgICAgICAvLyBnZXQgdGhlIHN0YXJ0IG9mIGNoYXJhY3RlciBtZW1vcnkgYWRkcmVzc1xyXG4vKiBlYzU2ICovICAgICAgICAgICAgICAgICAgIEFORC5pbW0gKDB4ZmQpOyAgICAgICAgICAgICAgIC8vIG1hc2sgeHh4eCB4eDB4LCBzZXQgdXBwZXIgY2FzZSBjaGFyYWN0ZXJzXHJcbi8qIGVjNTggKi8gICAgICAgIF9gX2VjNThgOyAgU1RBLmFicyAoXCJ2bWNzYl9kMDE4XCIpOyAgICAgICAvLyBzYXZlIHRoZSBzdGFydCBvZiBjaGFyYWN0ZXIgbWVtb3J5IGFkZHJlc3NcclxuLyogZWM1YiAqLyAgICAgICAgX2BfZWM1YmA7ICBKTVAuYWJzIChcIl9lNmE4XCIpOyAgICAgICAgICAgIC8vIHJlc3RvcmUgdGhlIHJlZ2lzdGVycywgc2V0IHRoZSBxdW90ZSBmbGFnIGFuZCBleGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gdGhlIFtTSElGVF0rW0M9XSBrZXkgY2hlY2tcclxuLyogZWM1ZSAqLyAgICAgICAgX2BfZWM1ZWA7ICBDTVAuaW1tICgweDA4KTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggZGlzYWJsZSBbU0hJRlRdW0M9XVxyXG4vKiBlYzYwICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2VjNjlcIik7ICAgICAgICAgICAgLy8gaWYgbm90IGRpc2FibGUgW1NISUZUXVtDPV0gc2tpcCB0aGUgc2V0XHJcbi8qIGVjNjIgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHg4MCk7ICAgICAgICAgICAgICAgLy8gc2V0IHRvIGxvY2sgc2hpZnQgbW9kZSBzd2l0Y2hcclxuLyogZWM2NCAqLyAgICAgICAgICAgICAgICAgICBPUkEuYWJzIChcIm1vZGVfMDI5MVwiKTsgICAgICAgIC8vIE9SIGl0IHdpdGggdGhlIHNoaWZ0IG1vZGUgc3dpdGNoXHJcbi8qIGVjNjcgKi8gICAgICAgICAgICAgICAgICAgQk1JLnJlbCAoXCJfZWM3MlwiKTsgICAgICAgICAgICAvLyBnbyBzYXZlIHRoZSB2YWx1ZSwgYnJhbmNoIGFsd2F5c1xyXG4vKiBlYzY5ICovICAgICAgICBfYF9lYzY5YDsgIENNUC5pbW0gKDB4MDkpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCBlbmFibGUgW1NISUZUXVtDPV1cclxuLyogZWM2YiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9lYzViXCIpOyAgICAgICAgICAgIC8vIGV4aXQgaWYgbm90IGVuYWJsZSBbU0hJRlRdW0M9XVxyXG4vKiBlYzZkICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4N2YpOyAgICAgICAgICAgICAgIC8vIHNldCB0byB1bmxvY2sgc2hpZnQgbW9kZSBzd2l0Y2hcclxuLyogZWM2ZiAqLyAgICAgICAgICAgICAgICAgICBBTkQuYWJzIChcIm1vZGVfMDI5MVwiKTsgICAgICAgIC8vIEFORCBpdCB3aXRoIHRoZSBzaGlmdCBtb2RlIHN3aXRjaFxyXG4vKiBlYzcyICovICAgICAgICBfYF9lYzcyYDsgIFNUQS5hYnMgKFwibW9kZV8wMjkxXCIpOyAgICAgICAgLy8gc2F2ZSB0aGUgc2hpZnQgbW9kZSBzd2l0Y2ggJDAwID0gZW5hYmxlZCwgJDgwID0gbG9ja2VkXHJcbi8qIGVjNzUgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZTZhOFwiKTsgICAgICAgICAgICAvLyByZXN0b3JlIHRoZSByZWdpc3RlcnMsIHNldCB0aGUgcXVvdGUgZmxhZyBhbmQgZXhpdFxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBjb250cm9sIGtleWJvYXJkIHRhYmxlXHJcbi8qIGVjNzggKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmKTtcclxuLyogZWM4MCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MWMsIDB4MTcsIDB4MDEsIDB4OWYsIDB4MWEsIDB4MTMsIDB4MDUsIDB4ZmYpO1xyXG4vKiBlYzg4ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg5YywgMHgxMiwgMHgwNCwgMHgxZSwgMHgwMywgMHgwNiwgMHgxNCwgMHgxOCk7XHJcbi8qIGVjOTAgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDFmLCAweDE5LCAweDA3LCAweDllLCAweDAyLCAweDA4LCAweDE1LCAweDE2KTtcclxuLyogZWM5OCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MTIsIDB4MDksIDB4MGEsIDB4OTIsIDB4MGQsIDB4MGIsIDB4MGYsIDB4MGUpO1xyXG4vKiBlY2EwICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHhmZiwgMHgxMCwgMHgwYywgMHhmZiwgMHhmZiwgMHgxYiwgMHgwMCwgMHhmZik7XHJcbi8qIGVjYTggKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDFjLCAweGZmLCAweDFkLCAweGZmLCAweGZmLCAweDFmLCAweDFlLCAweGZmKTtcclxuLyogZWNiMCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4OTAsIDB4MDYsIDB4ZmYsIDB4MDUsIDB4ZmYsIDB4ZmYsIDB4MTEsIDB4ZmYpO1xyXG4vKiBlY2I4ICovICAgICAgICBfYF9lY2I4YDsgIF8uYnl0ZXMoMHhmZik7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHZpYyBpaSBjaGlwIGluaXRpYWxpc2F0aW9uIHZhbHVlc1xyXG4vKiBlY2I5ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgwMCwgMHgwMCk7ICAgICAgICAgIC8vIHNwcml0ZSAwIHgseVxyXG4vKiBlY2JiICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgwMCwgMHgwMCk7ICAgICAgICAgIC8vIHNwcml0ZSAxIHgseSBcclxuLyogZWNiZCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MDAsIDB4MDApOyAgICAgICAgICAvLyBzcHJpdGUgMiB4LHkgXHJcbi8qIGVjYmYgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDAwLCAweDAwKTsgICAgICAgICAgLy8gc3ByaXRlIDMgeCx5XHJcbi8qIGVjYzEgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDAwLCAweDAwKTsgICAgICAgICAgLy8gc3ByaXRlIDQgeCx5IFxyXG4vKiBlY2MzICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgwMCwgMHgwMCk7ICAgICAgICAgIC8vIHNwcml0ZSA1IHgseSBcclxuLyogZWNjNSAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MDAsIDB4MDApOyAgICAgICAgICAvLyBzcHJpdGUgNiB4LHkgXHJcbi8qIGVjYzcgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDAwLCAweDAwKTsgICAgICAgICAgLy8gc3ByaXRlIDcgeCx5XHJcbi8qIGVjYzkgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDAwKTsgICAgICAgICAgICAgICAgLy8gc3ByaXRlcyAwIHRvIDcgeCBiaXQgOFxyXG4vKiBlY2NhICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg5Yik7ICAgICAgICAgICAgICAgIC8vIGVuYWJsZSBzY3JlZW4sIGVuYWJsZSAyNSByb3dzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmVydGljYWwgZmluZSBzY3JvbGwgYW5kIGNvbnRyb2xcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBiaXQgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtLS0gLS0tLS0tLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICA3ICByYXN0ZXIgY29tcGFyZSBiaXQgOFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICA2ICAxID0gZW5hYmxlIGV4dGVuZGVkIGNvbG9yIHRleHQgbW9kZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICA1ICAxID0gZW5hYmxlIGJpdG1hcCBncmFwaGljcyBtb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIDQgIDEgPSBlbmFibGUgc2NyZWVuLCAwID0gYmxhbmsgc2NyZWVuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIDMgIDEgPSAyNSByb3cgZGlzcGxheSwgMCA9IDI0IHJvdyBkaXNwbGF5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMi0wIHZlcnRpY2FsIHNjcm9sbCBjb3VudFxyXG4vKiBlY2NiICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgzNyk7ICAgICAgICAgICAgICAgIC8vIHJhc3RlciBjb21wYXJlXHJcbi8qIGVjY2MgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDAwKTsgICAgICAgICAgICAgICAgLy8gbGlnaHQgcGVuIHhcclxuLyogZWNjZCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MDApOyAgICAgICAgICAgICAgICAvLyBsaWdodCBwZW4geVxyXG4vKiBlY2NlICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgwMCk7ICAgICAgICAgICAgICAgIC8vIHNwcml0ZSAwIHRvIDcgZW5hYmxlXHJcbi8qIGVjY2YgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDA4KTsgICAgICAgICAgICAgICAgLy8gZW5hYmxlIDQwIGNvbHVtbiBkaXNwbGF5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaG9yaXpvbnRhbCBmaW5lIHNjcm9sbCBhbmQgY29udHJvbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJpdCBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0tLSAtLS0tLS0tXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gNy02IHVudXNlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICA1ICAxID0gdmljIHJlc2V0LCAwID0gdmljIG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIDQgIDEgPSBlbmFibGUgbXVsdGljb2xvciBtb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIDMgIDEgPSA0MCBjb2x1bW4gZGlzcGxheSwgMCA9IDM4IGNvbHVtbiBkaXNwbGF5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMi0wIGhvcml6b250YWwgc2Nyb2xsIGNvdW50XHJcbi8qIGVjZDAgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDAwKTsgICAgICAgICAgICAgICAgLy8gc3ByaXRlIDAgdG8gNyB5IGV4cGFuZFxyXG4vKiBlY2QxICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgxNCk7ICAgICAgICAgICAgICAgIC8vIG1lbW9yeSBjb250cm9sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYml0IGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLS0tIC0tLS0tLS1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA3LTQgdmlkZW8gbWF0cml4IGJhc2UgYWRkcmVzc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDMtMSBjaGFyYWN0ZXIgZGF0YSBiYXNlIGFkZHJlc3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgMCAgdW51c2VkXHJcbi8qIGVjZDIgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDBmKTsgICAgICAgICAgICAgICAgLy8gY2xlYXIgYWxsIGludGVycnVwdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnRlcnJ1cHQgZmxhZ3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgNyAxID0gaW50ZXJydXB0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gNi00IHVudXNlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAzICAxID0gbGlnaHQgcGVuIGludGVycnVwdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAyICAxID0gc3ByaXRlIHRvIHNwcml0ZSBjb2xsaXNpb24gaW50ZXJydXB0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIDEgIDEgPSBzcHJpdGUgdG8gZm9yZWdyb3VuZCBjb2xsaXNpb24gaW50ZXJydXB0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIDAgIDEgPSByYXN0ZXIgY29tcGFyZSBpbnRlcnJ1cHRcclxuLyogZWNkMyAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MDApOyAgICAgICAgICAgICAgICAvLyBhbGwgdmljIElSUXMgZGlzYWJlbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJUlEgZW5hYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYml0IGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLS0tIC0tLS0tLS1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA3LTQgdW51c2VkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIDMgIDEgPSBlbmFibGUgbGlnaHQgcGVuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIDIgIDEgPSBlbmFibGUgc3ByaXRlIHRvIHNwcml0ZSBjb2xsaXNpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgMSAgMSA9IGVuYWJsZSBzcHJpdGUgdG8gZm9yZWdyb3VuZCBjb2xsaXNpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgMCAgMSA9IGVuYWJsZSByYXN0ZXIgY29tcGFyZVxyXG4vKiBlY2Q0ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgwMCk7ICAgICAgICAgICAgICAgIC8vIHNwcml0ZSAwIHRvIDcgZm9yZWdyb3VuZCBwcmlvcml0eVxyXG4vKiBlY2Q1ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgwMCk7ICAgICAgICAgICAgICAgIC8vIHNwcml0ZSAwIHRvIDcgbXVsdGljb2xvdXJcclxuLyogZWNkNiAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MDApOyAgICAgICAgICAgICAgICAvLyBzcHJpdGUgMCB0byA3IHggZXhwYW5kXHJcbi8qIGVjZDcgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDAwKTsgICAgICAgICAgICAgICAgLy8gc3ByaXRlIDAgdG8gNyBzcHJpdGUgY29sbGlzaW9uXHJcbi8qIGVjZDggKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDAwKTsgICAgICAgICAgICAgICAgLy8gc3ByaXRlIDAgdG8gNyBmb3JlZ3JvdW5kIGNvbGxpc2lvblxyXG4vKiBlY2Q5ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgwZSk7ICAgICAgICAgICAgICAgIC8vIGJvcmRlciBjb2xvdXJcclxuLyogZWNkYSAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MDYpOyAgICAgICAgICAgICAgICAvLyBiYWNrZ3JvdW5kIGNvbG91ciAwXHJcbi8qIGVjZGIgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDAxKTsgICAgICAgICAgICAgICAgLy8gYmFja2dyb3VuZCBjb2xvdXIgMVxyXG4vKiBlY2RjICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgwMik7ICAgICAgICAgICAgICAgIC8vIGJhY2tncm91bmQgY29sb3VyIDJcclxuLyogZWNkZCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MDMpOyAgICAgICAgICAgICAgICAvLyBiYWNrZ3JvdW5kIGNvbG91ciAzXHJcbi8qIGVjZGUgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDA0KTsgICAgICAgICAgICAgICAgLy8gc3ByaXRlIG11bHRpY29sb3VyIDBcclxuLyogZWNkZiAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MDApOyAgICAgICAgICAgICAgICAvLyBzcHJpdGUgbXVsdGljb2xvdXIgMVxyXG4vKiBlY2UwICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgwMSk7ICAgICAgICAgICAgICAgIC8vIHNwcml0ZSAwIGNvbG91clxyXG4vKiBlY2UxICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgwMik7ICAgICAgICAgICAgICAgIC8vIHNwcml0ZSAxIGNvbG91clxyXG4vKiBlY2UyICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgwMyk7ICAgICAgICAgICAgICAgIC8vIHNwcml0ZSAyIGNvbG91clxyXG4vKiBlY2UzICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgwNCk7ICAgICAgICAgICAgICAgIC8vIHNwcml0ZSAzIGNvbG91clxyXG4vKiBlY2U0ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgwNSk7ICAgICAgICAgICAgICAgIC8vIHNwcml0ZSA0IGNvbG91clxyXG4vKiBlY2U1ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgwNik7ICAgICAgICAgICAgICAgIC8vIHNwcml0ZSA1IGNvbG91clxyXG4vKiBlY2U2ICovICAgICAgICBfYF9lY2U2YDsgIF8uYnl0ZXMoMHgwNyk7ICAgICAgICAgICAgICAgIC8vIHNwcml0ZSA2IGNvbG91clxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwcml0ZSA3IGNvbG91ciBpcyBhY3R1YWxseSB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIFwiTE9BRFwiICgkNEMpXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGtleWJvYXJkIGJ1ZmZlciBmb3IgYXV0byBsb2FkL3J1blxyXG4vKiBlY2U3ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg0YywgMHg0ZiwgMHg0MSk7ICAgIC8vICdsb2FkIChjcikgcnVuIChjciknXHJcbi8qIGVjZWEgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDQ0LCAweDBkLCAweDUyLCAweDU1LCAweDRlLCAweDBkKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gbG93IGJ5dGVzIG9mIHNjcmVlbiBsaW5lIGFkZHJlc3Nlc1xyXG4vKiBlY2YwICovICAgICAgICBfYF9lY2YwYDsgIF8uYnl0ZXMoMHgwMCwgMHgyOCwgMHg1MCwgMHg3OCwgMHhhMCwgMHhjOCwgMHhmMCwgMHgxOCk7XHJcbi8qIGVjZjggKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDQwLCAweDY4LCAweDkwLCAweGI4LCAweGUwLCAweDA4LCAweDMwLCAweDU4KTtcclxuLyogZWQwMCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4ODAsIDB4YTgsIDB4ZDAsIDB4ZjgsIDB4MjAsIDB4NDgsIDB4NzAsIDB4OTgpO1xyXG4vKiBlZDA4ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHhjMCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGNvbW1hbmQgc2VyaWFsIGJ1cyBkZXZpY2UgdG8gVEFMS1xyXG4vKiBlZDA5ICovICAgIF9gdGFsa19lZDA5YDsgIE9SQS5pbW0gKDB4NDApOyAgICAgICAgICAgICAgIC8vIE9SIHdpdGggdGhlIFRBTEsgY29tbWFuZFxyXG4vKiBlZDBiICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgyYyk7ICAgICAgICAgICAgICAgIC8vIG1ha2VzIG5leHQgbGluZSBCSVQgJDIwMDlcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY29tbWFuZCBkZXZpY2VzIG9uIHRoZSBzZXJpYWwgYnVzIHRvIExJU1RFTlxyXG4vKiBlZDBjICovICBfYGxpc3Rlbl9lZDBjYDsgIE9SQS5pbW0gKDB4MjApOyAgICAgICAgICAgICAgIC8vIE9SIHdpdGggdGhlIExJU1RFTiBjb21tYW5kXHJcbi8qIGVkMGUgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZjBhNFwiKTsgICAgICAgICAgICAvLyBjaGVjayBSUzIzMiBidXMgaWRsZVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzZW5kIGEgY29udHJvbCBjaGFyYWN0ZXJcclxuLyogZWQxMSAqLyAgICAgICAgX2BfZWQxMWA7ICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzYXZlIGRldmljZSBhZGRyZXNzXHJcbi8qIGVkMTIgKi8gICAgICAgICAgICAgICAgICAgQklULnpwZyAoXCJjM3BvXzAwOTRcIik7ICAgICAgICAvLyB0ZXN0IGRlZmVycmVkIGNoYXJhY3RlciBmbGFnXHJcbi8qIGVkMTQgKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfZWQyMFwiKTsgICAgICAgICAgICAvLyBpZiBubyBkZWZlcmVkIGNoYXJhY3RlciBjb250aW51ZVxyXG4vKiBlZDE2ICovICAgICAgICAgICAgICAgICAgIFNFQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgZmxhZyBFT0lcclxuLyogZWQxNyAqLyAgICAgICAgICAgICAgICAgICBST1IuenBnIChcInRzZmNudF8wMGEzXCIpOyAgICAgIC8vIHJvdGF0ZSBpbnRvIEVPSSBmbGFnIGJ5dGVcclxuLyogZWQxOSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9lZDQwXCIpOyAgICAgICAgICAgIC8vIFR4IGJ5dGUgb24gc2VyaWFsIGJ1c1xyXG4vKiBlZDFjICovICAgICAgICAgICAgICAgICAgIExTUi56cGcgKFwiYzNwb18wMDk0XCIpOyAgICAgICAgLy8gY2xlYXIgZGVmZXJyZWQgY2hhcmFjdGVyIGZsYWdcclxuLyogZWQxZSAqLyAgICAgICAgICAgICAgICAgICBMU1IuenBnIChcInRzZmNudF8wMGEzXCIpOyAgICAgIC8vIGNsZWFyIEVPSSBmbGFnXHJcbi8qIGVkMjAgKi8gICAgICAgIF9gX2VkMjBgOyAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSB0aGUgZGV2aWNlIGFkZHJlc3NcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gZGVmZXIgYSBjb21tYW5kXHJcbi8qIGVkMjEgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJic291cl8wMDk1XCIpOyAgICAgICAvLyBzYXZlIGFzIHNlcmlhbCBkZWZlcmVkIGNoYXJhY3RlclxyXG4vKiBlZDIzICovICAgICAgICAgICAgICAgICAgIFNFSS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRpc2FibGUgdGhlIGludGVycnVwdHNcclxuLyogZWQyNCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9lZTk3XCIpOyAgICAgICAgICAgIC8vIHNldCB0aGUgc2VyaWFsIGRhdGEgb3V0IGhpZ2hcclxuLyogZWQyNyAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW1tICgweDNmKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHJlYWQgYnl0ZSB3aXRoICQzRlxyXG4vKiBlZDI5ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2VkMmVcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vdCAkM0YsIHRoaXMgYnJhbmNoIHdpbGwgYWx3YXlzIGJlIHRha2VuIGFzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWZ0ZXIgVklBIDIncyBQQ1IgaXMgcmVhZCBpdCBpcyBBTkRlZCB3aXRoICRERiwgc28gdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzdWx0IGNhbiBuZXZlciBiZSAkM0YgPz9cclxuLyogZWQyYiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9lZTg1XCIpOyAgICAgICAgICAgIC8vIHNldCB0aGUgc2VyaWFsIGNsb2NrIG91dCBoaWdoXHJcbi8qIGVkMmUgKi8gICAgICAgIF9gX2VkMmVgOyAgTERBLmFicyAoXCJjaTJwcmFfZGQwMFwiKTsgICAgICAvLyByZWFkIFZJQSAyIERSQSwgc2VyaWFsIHBvcnQgYW5kIHZpZGVvIGFkZHJlc3NcclxuLyogZWQzMSAqLyAgICAgICAgICAgICAgICAgICBPUkEuaW1tICgweDA4KTsgICAgICAgICAgICAgICAvLyBtYXNrIHh4eHggMXh4eCwgc2V0IHNlcmlhbCBBVE4gbG93XHJcbi8qIGVkMzMgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJjaTJwcmFfZGQwMFwiKTsgICAgICAvLyBzYXZlIFZJQSAyIERSQSwgc2VyaWFsIHBvcnQgYW5kIHZpZGVvIGFkZHJlc3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgY29kZSBkcm9wcyB0aHJvdWdoIHRvIGhlcmUgdGhlIHNlcmlhbCBjbG9jayBpcyBsb3cgYW5kIHRoZSBzZXJpYWwgZGF0YSBoYXMgYmVlblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbGVhc2VkIHNvIHRoZSBmb2xsb3dpbmcgY29kZSB3aWxsIGhhdmUgbm8gZWZmZWN0IGFwYXJ0IGZyb20gZGVsYXlpbmcgdGhlIGZpcnN0IGJ5dGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBieSAxbXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgdGhlIHNlcmlhbCBjbGsvZGF0YSwgd2FpdCBhbmQgVHggYnl0ZSBvbiB0aGUgc2VyaWFsIGJ1c1xyXG4vKiBlZDM2ICovICAgICAgICBfYF9lZDM2YDsgIFNFSS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRpc2FibGUgdGhlIGludGVycnVwdHNcclxuLyogZWQzNyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9lZThlXCIpOyAgICAgICAgICAgIC8vIHNldCB0aGUgc2VyaWFsIGNsb2NrIG91dCBsb3dcclxuLyogZWQzYSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9lZTk3XCIpOyAgICAgICAgICAgIC8vIHNldCB0aGUgc2VyaWFsIGRhdGEgb3V0IGhpZ2hcclxuLyogZWQzZCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9lZWIzXCIpOyAgICAgICAgICAgIC8vIDFtcyBkZWxheVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBUeCBieXRlIG9uIHNlcmlhbCBidXNcclxuLyogZWQ0MCAqLyAgICAgICAgX2BfZWQ0MGA7ICBTRUkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBkaXNhYmxlIHRoZSBpbnRlcnJ1cHRzXHJcbi8qIGVkNDEgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZWU5N1wiKTsgICAgICAgICAgICAvLyBzZXQgdGhlIHNlcmlhbCBkYXRhIG91dCBoaWdoXHJcbi8qIGVkNDQgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZWVhOVwiKTsgICAgICAgICAgICAvLyBnZXQgdGhlIHNlcmlhbCBkYXRhIHN0YXR1cyBpbiBDYlxyXG4vKiBlZDQ3ICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2VkYWRcIik7ICAgICAgICAgICAgLy8gaWYgdGhlIHNlcmlhbCBkYXRhIGlzIGhpZ2ggZ28gZG8gJ2RldmljZSBub3QgcHJlc2VudCdcclxuLyogZWQ0OSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9lZTg1XCIpOyAgICAgICAgICAgIC8vIHNldCB0aGUgc2VyaWFsIGNsb2NrIG91dCBoaWdoXHJcbi8qIGVkNGMgKi8gICAgICAgICAgICAgICAgICAgQklULnpwZyAoXCJ0c2ZjbnRfMDBhM1wiKTsgICAgICAvLyB0ZXN0IHRoZSBFT0kgZmxhZ1xyXG4vKiBlZDRlICovICAgICAgICAgICAgICAgICAgIEJQTC5yZWwgKFwiX2VkNWFcIik7ICAgICAgICAgICAgLy8gaWYgbm90IEVPSSBnbyA/P1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEkgdGhpbmsgdGhpcyBpcyB0aGUgRU9JIHNlcXVlbmNlIHNvIHRoZSBzZXJpYWwgY2xvY2sgaGFzIGJlZW4gcmVsZWFzZWQgYW5kIHRoZSBzZXJpYWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkYXRhIGlzIGJlaW5nIGhlbGQgbG93IGJ5IHRoZSBwZXJpcGhlcmFsLiBmaXJzdCB1cCB3YWl0IGZvciB0aGUgc2VyaWFsIGRhdGEgdG8gcmlzZVxyXG4vKiBlZDUwICovICAgICAgICBfYF9lZDUwYDsgIEpTUi5hYnMgKFwiX2VlYTlcIik7ICAgICAgICAgICAgLy8gZ2V0IHRoZSBzZXJpYWwgZGF0YSBzdGF0dXMgaW4gQ2JcclxuLyogZWQ1MyAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9lZDUwXCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgdGhlIGRhdGEgaXMgbG93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm93IHRoZSBkYXRhIGlzIGhpZ2gsIEVPSSBpcyBzaWduYWxsZWQgYnkgd2FpdGluZyBmb3IgYXQgbGVhc3QgMjAwdXMgd2l0aG91dCBwdWxsaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHNlcmlhbCBjbG9jayBsaW5lIGxvdyBhZ2Fpbi4gdGhlIGxpc3RlbmVyIHNob3VsZCByZXNwb25kIGJ5IHB1bGxpbmcgdGhlIHNlcmlhbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRhdGEgbGluZSBsb3dcclxuLyogZWQ1NSAqLyAgICAgICAgX2BfZWQ1NWA7ICBKU1IuYWJzIChcIl9lZWE5XCIpOyAgICAgICAgICAgIC8vIGdldCB0aGUgc2VyaWFsIGRhdGEgc3RhdHVzIGluIENiXHJcbi8qIGVkNTggKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfZWQ1NVwiKTsgICAgICAgICAgICAvLyBsb29wIGlmIHRoZSBkYXRhIGlzIGhpZ2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc2VyaWFsIGRhdGEgaGFzIGdvbmUgbG93IGVuZGluZyB0aGUgRU9JIHNlcXVlbmNlLCBub3cganVzdCB3YWl0IGZvciB0aGUgc2VyaWFsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGF0YSBsaW5lIHRvIGdvIGhpZ2ggYWdhaW4gb3IsIGlmIHRoaXMgaXNuJ3QgYW4gRU9JIHNlcXVlbmNlLCBqdXN0IHdhaXQgZm9yIHRoZSBzZXJpYWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkYXRhIHRvIGdvIGhpZ2ggdGhlIGZpcnN0IHRpbWVcclxuLyogZWQ1YSAqLyAgICAgICAgX2BfZWQ1YWA7ICBKU1IuYWJzIChcIl9lZWE5XCIpOyAgICAgICAgICAgIC8vIGdldCB0aGUgc2VyaWFsIGRhdGEgc3RhdHVzIGluIENiXHJcbi8qIGVkNWQgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfZWQ1YVwiKTsgICAgICAgICAgICAvLyBsb29wIGlmIHRoZSBkYXRhIGlzIGxvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlcmlhbCBkYXRhIGlzIGhpZ2ggbm93IHB1bGwgdGhlIGNsb2NrIGxvdywgcHJlZmVyYWJseSB3aXRoaW4gNjB1c1xyXG4vKiBlZDVmICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2VlOGVcIik7ICAgICAgICAgICAgLy8gc2V0IHRoZSBzZXJpYWwgY2xvY2sgb3V0IGxvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdyB0aGUgQzY0IGhhcyB0byBzZW5kIHRoZSBlaWdodCBiaXRzLCBMU0IgZmlyc3QuIGZpcnN0IGl0IHNldHMgdGhlIHNlcmlhbCBkYXRhIGxpbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0byByZWZsZWN0IHRoZSBiaXQgaW4gdGhlIGJ5dGUsIHRoZW4gaXQgc2V0cyB0aGUgc2VyaWFsIGNsb2NrIHRvIGhpZ2guIFRoZSBzZXJpYWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjbG9jayBpcyBsZWZ0IGhpZ2ggZm9yIDI2IGN5Y2xlcywgMjN1cyBvbiBhIFBBTCBWaWMsIGJlZm9yZSBpdCBpcyBhZ2FpbiBwdWxsZWQgbG93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRoZSBzZXJpYWwgZGF0YSBpcyBhbGxvd2VkIGhpZ2ggYWdhaW5cclxuLyogZWQ2MiAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDA4KTsgICAgICAgICAgICAgICAvLyBlaWdodCBiaXRzIHRvIGRvXHJcbi8qIGVkNjQgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJjbnRkbl8wMGE1XCIpOyAgICAgICAvLyBzZXQgc2VyaWFsIGJ1cyBiaXQgY291bnRcclxuLyogZWQ2NiAqLyAgICAgICAgX2BfZWQ2NmA7ICBMREEuYWJzIChcImNpMnByYV9kZDAwXCIpOyAgICAgIC8vIHJlYWQgVklBIDIgRFJBLCBzZXJpYWwgcG9ydCBhbmQgdmlkZW8gYWRkcmVzc1xyXG4vKiBlZDY5ICovICAgICAgICAgICAgICAgICAgIENNUC5hYnMgKFwiY2kycHJhX2RkMDBcIik7ICAgICAgLy8gY29tcGFyZSBpdCB3aXRoIGl0c2VsZlxyXG4vKiBlZDZjICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2VkNjZcIik7ICAgICAgICAgICAgLy8gaWYgY2hhbmdlZCBnbyB0cnkgYWdhaW5cclxuLyogZWQ2ZSAqLyAgICAgICAgICAgICAgICAgICBBU0wuYWNjICgpOyAgICAgICAgICAgICAgICAgICAvLyBzaGlmdCB0aGUgc2VyaWFsIGRhdGEgaW50byBDYlxyXG4vKiBlZDZmICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2VkYjBcIik7ICAgICAgICAgICAgLy8gaWYgdGhlIHNlcmlhbCBkYXRhIGlzIGxvdyBnbyBkbyBzZXJpYWwgYnVzIHRpbWVvdXRcclxuLyogZWQ3MSAqLyAgICAgICAgICAgICAgICAgICBST1IuenBnIChcImJzb3VyXzAwOTVcIik7ICAgICAgIC8vIHJvdGF0ZSB0aGUgdHJhbnNtaXQgYnl0ZVxyXG4vKiBlZDczICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2VkN2FcIik7ICAgICAgICAgICAgLy8gaWYgdGhlIGJpdCA9IDEgZ28gc2V0IHRoZSBzZXJpYWwgZGF0YSBvdXQgaGlnaFxyXG4vKiBlZDc1ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2VlYTBcIik7ICAgICAgICAgICAgLy8gZWxzZSBzZXQgdGhlIHNlcmlhbCBkYXRhIG91dCBsb3dcclxuLyogZWQ3OCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9lZDdkXCIpOyAgICAgICAgICAgIC8vIGNvbnRpbnVlLCBicmFuY2ggYWx3YXlzXHJcbi8qIGVkN2EgKi8gICAgICAgIF9gX2VkN2FgOyAgSlNSLmFicyAoXCJfZWU5N1wiKTsgICAgICAgICAgICAvLyBzZXQgdGhlIHNlcmlhbCBkYXRhIG91dCBoaWdoXHJcbi8qIGVkN2QgKi8gICAgICAgIF9gX2VkN2RgOyAgSlNSLmFicyAoXCJfZWU4NVwiKTsgICAgICAgICAgICAvLyBzZXQgdGhlIHNlcmlhbCBjbG9jayBvdXQgaGlnaFxyXG4vKiBlZDgwICovICAgICAgICAgICAgICAgICAgIE5PUC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHdhc3RlIC4uXHJcbi8qIGVkODEgKi8gICAgICAgICAgICAgICAgICAgTk9QLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gLi4gYSAuLlxyXG4vKiBlZDgyICovICAgICAgICAgICAgICAgICAgIE5PUC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIC4uIGN5Y2xlIC4uXHJcbi8qIGVkODMgKi8gICAgICAgICAgICAgICAgICAgTk9QLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gLi4gb3IgdHdvXHJcbi8qIGVkODQgKi8gICAgICAgICAgICAgICAgICAgTERBLmFicyAoXCJjaTJwcmFfZGQwMFwiKTsgICAgICAvLyByZWFkIFZJQSAyIERSQSwgc2VyaWFsIHBvcnQgYW5kIHZpZGVvIGFkZHJlc3NcclxuLyogZWQ4NyAqLyAgICAgICAgICAgICAgICAgICBBTkQuaW1tICgweGRmKTsgICAgICAgICAgICAgICAvLyBtYXNrIHh4MHggeHh4eCwgc2V0IHRoZSBzZXJpYWwgZGF0YSBvdXQgaGlnaFxyXG4vKiBlZDg5ICovICAgICAgICAgICAgICAgICAgIE9SQS5pbW0gKDB4MTApOyAgICAgICAgICAgICAgIC8vIG1hc2sgeHh4MSB4eHh4LCBzZXQgdGhlIHNlcmlhbCBjbG9jayBvdXQgbG93XHJcbi8qIGVkOGIgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJjaTJwcmFfZGQwMFwiKTsgICAgICAvLyBzYXZlIFZJQSAyIERSQSwgc2VyaWFsIHBvcnQgYW5kIHZpZGVvIGFkZHJlc3NcclxuLyogZWQ4ZSAqLyAgICAgICAgICAgICAgICAgICBERUMuenBnIChcImNudGRuXzAwYTVcIik7ICAgICAgIC8vIGRlY3JlbWVudCB0aGUgc2VyaWFsIGJ1cyBiaXQgY291bnRcclxuLyogZWQ5MCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9lZDY2XCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgbm90IGFsbCBkb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm93IGFsbCBlaWdodCBiaXRzIGhhdmUgYmVlbiBzZW50IGl0J3MgdXAgdG8gdGhlIHBlcmlwaGVyYWwgdG8gc2lnbmFsIHRoZSBieXRlIHdhc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlY2VpdmVkIGJ5IHB1bGxpbmcgdGhlIHNlcmlhbCBkYXRhIGxvdy4gdGhpcyBzaG91bGQgYmUgZG9uZSB3aXRoaW4gb25lIG1pbGlzZWNvbmRcclxuLyogZWQ5MiAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDA0KTsgICAgICAgICAgICAgICAvLyB3YWl0IGZvciB1cCB0byBhYm91dCAxbXNcclxuLyogZWQ5NCAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcInRpbWJoaV9kYzA3XCIpOyAgICAgIC8vIHNhdmUgVklBIDEgdGltZXIgQiBoaWdoIGJ5dGVcclxuLyogZWQ5NyAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDE5KTsgICAgICAgICAgICAgICAvLyBsb2FkIHRpbWVyIEIsIHRpbWVyIEIgc2luZ2xlIHNob3QsIHN0YXJ0IHRpbWVyIEJcclxuLyogZWQ5OSAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcImNpYWNyYl9kYzBmXCIpOyAgICAgIC8vIHNhdmUgVklBIDEgQ1JCXHJcbi8qIGVkOWMgKi8gICAgICAgICAgICAgICAgICAgTERBLmFicyAoXCJjaWFpY3JfZGMwZFwiKTsgICAgICAvLyByZWFkIFZJQSAxIElDUlxyXG4vKiBlZDlmICovICAgICAgICBfYF9lZDlmYDsgIExEQS5hYnMgKFwiY2lhaWNyX2RjMGRcIik7ICAgICAgLy8gcmVhZCBWSUEgMSBJQ1JcclxuLyogZWRhMiAqLyAgICAgICAgICAgICAgICAgICBBTkQuaW1tICgweDAyKTsgICAgICAgICAgICAgICAvLyBtYXNrIDAwMDAgMDB4MCwgdGltZXIgQSBpbnRlcnJ1cHRcclxuLyogZWRhNCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9lZGIwXCIpOyAgICAgICAgICAgIC8vIGlmIHRpbWVyIEEgaW50ZXJydXB0IGdvIGRvIHNlcmlhbCBidXMgdGltZW91dFxyXG4vKiBlZGE2ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2VlYTlcIik7ICAgICAgICAgICAgLy8gZ2V0IHRoZSBzZXJpYWwgZGF0YSBzdGF0dXMgaW4gQ2JcclxuLyogZWRhOSAqLyAgICAgICAgICAgICAgICAgICBCQ1MucmVsIChcIl9lZDlmXCIpOyAgICAgICAgICAgIC8vIGlmIHRoZSBzZXJpYWwgZGF0YSBpcyBoaWdoIGdvIHdhaXQgc29tZSBtb3JlXHJcbi8qIGVkYWIgKi8gICAgICAgICAgICAgICAgICAgQ0xJLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZW5hYmxlIHRoZSBpbnRlcnJ1cHRzXHJcbi8qIGVkYWMgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZXZpY2Ugbm90IHByZXNlbnRcclxuLyogZWRhZCAqLyAgICAgICAgX2BfZWRhZGA7ICBMREEuaW1tICgweDgwKTsgICAgICAgICAgICAgICAvLyBlcnJvciAkODAsIGRldmljZSBub3QgcHJlc2VudFxyXG4vKiBlZGFmICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgyYyk7ICAgICAgICAgICAgICAgIC8vIG1ha2VzIG5leHQgbGluZSBCSVQgJDAzQTlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aW1lb3V0IG9uIHNlcmlhbCBidXNcclxuLyogZWRiMCAqLyAgICAgICAgX2BfZWRiMGA7ICBMREEuaW1tICgweDAzKTsgICAgICAgICAgICAgICAvLyBlcnJvciAkMDMsIHJlYWQgdGltZW91dCwgd3JpdGUgdGltZW91dFxyXG4vKiBlZGIyICovICAgICAgICBfYF9lZGIyYDsgIEpTUi5hYnMgKFwiX2ZlMWNcIik7ICAgICAgICAgICAgLy8gT1IgaW50byB0aGUgc2VyaWFsIHN0YXR1cyBieXRlXHJcbi8qIGVkYjUgKi8gICAgICAgICAgICAgICAgICAgQ0xJLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZW5hYmxlIHRoZSBpbnRlcnJ1cHRzXHJcbi8qIGVkYjYgKi8gICAgICAgICAgICAgICAgICAgQ0xDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgZm9yIGJyYW5jaFxyXG4vKiBlZGI3ICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2VlMDNcIik7ICAgICAgICAgICAgLy8gQVROIGhpZ2gsIGRlbGF5LCBjbG9jayBoaWdoIHRoZW4gZGF0YSBoaWdoLCBicmFuY2ggYWx3YXlzXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHNlbmQgc2Vjb25kYXJ5IGFkZHJlc3MgYWZ0ZXIgTElTVEVOXHJcbi8qIGVkYjkgKi8gIF9gc2Vjb25kX2VkYjlgOyAgU1RBLnpwZyAoXCJic291cl8wMDk1XCIpOyAgICAgICAvLyBzYXZlIHRoZSBkZWZlcmVkIFR4IGJ5dGVcclxuLyogZWRiYiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9lZDM2XCIpOyAgICAgICAgICAgIC8vIHNldCB0aGUgc2VyaWFsIGNsay9kYXRhLCB3YWl0IGFuZCBUeCB0aGUgYnl0ZVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzZXQgc2VyaWFsIEFUTiBoaWdoXHJcbi8qIGVkYmUgKi8gICAgICAgIF9gX2VkYmVgOyAgTERBLmFicyAoXCJjaTJwcmFfZGQwMFwiKTsgICAgICAvLyByZWFkIFZJQSAyIERSQSwgc2VyaWFsIHBvcnQgYW5kIHZpZGVvIGFkZHJlc3NcclxuLyogZWRjMSAqLyAgICAgICAgICAgICAgICAgICBBTkQuaW1tICgweGY3KTsgICAgICAgICAgICAgICAvLyBtYXNrIHh4eHggMHh4eCwgc2V0IHNlcmlhbCBBVE4gaGlnaFxyXG4vKiBlZGMzICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiY2kycHJhX2RkMDBcIik7ICAgICAgLy8gc2F2ZSBWSUEgMiBEUkEsIHNlcmlhbCBwb3J0IGFuZCB2aWRlbyBhZGRyZXNzXHJcbi8qIGVkYzYgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gc2VuZCBzZWNvbmRhcnkgYWRkcmVzcyBhZnRlciBUQUxLXHJcbi8qIGVkYzcgKi8gICAgX2B0a3NhX2VkYzdgOyAgU1RBLnpwZyAoXCJic291cl8wMDk1XCIpOyAgICAgICAvLyBzYXZlIHRoZSBkZWZlcmVkIFR4IGJ5dGVcclxuLyogZWRjOSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9lZDM2XCIpOyAgICAgICAgICAgIC8vIHNldCB0aGUgc2VyaWFsIGNsay9kYXRhLCB3YWl0IGFuZCBUeCB0aGUgYnl0ZVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyB3YWl0IGZvciB0aGUgc2VyaWFsIGJ1cyBlbmQgYWZ0ZXIgc2VuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBhZGRyZXNzIGZyb20gcGF0Y2ggNlxyXG4vKiBlZGNjICovICAgICAgICBfYF9lZGNjYDsgIFNFSS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRpc2FibGUgdGhlIGludGVycnVwdHNcclxuLyogZWRjZCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9lZWEwXCIpOyAgICAgICAgICAgIC8vIHNldCB0aGUgc2VyaWFsIGRhdGEgb3V0IGxvd1xyXG4vKiBlZGQwICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2VkYmVcIik7ICAgICAgICAgICAgLy8gc2V0IHNlcmlhbCBBVE4gaGlnaFxyXG4vKiBlZGQzICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2VlODVcIik7ICAgICAgICAgICAgLy8gc2V0IHRoZSBzZXJpYWwgY2xvY2sgb3V0IGhpZ2hcclxuLyogZWRkNiAqLyAgICAgICAgX2BfZWRkNmA7ICBKU1IuYWJzIChcIl9lZWE5XCIpOyAgICAgICAgICAgIC8vIGdldCB0aGUgc2VyaWFsIGRhdGEgc3RhdHVzIGluIENiXHJcbi8qIGVkZDkgKi8gICAgICAgICAgICAgICAgICAgQk1JLnJlbCAoXCJfZWRkNlwiKTsgICAgICAgICAgICAvLyBsb29wIGlmIHRoZSBjbG9jayBpcyBoaWdoXHJcbi8qIGVkZGIgKi8gICAgICAgICAgICAgICAgICAgQ0xJLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZW5hYmxlIHRoZSBpbnRlcnJ1cHRzXHJcbi8qIGVkZGMgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gb3V0cHV0IGEgYnl0ZSB0byB0aGUgc2VyaWFsIGJ1c1xyXG4vKiBlZGRkICovICAgX2BjaW91dF9lZGRkYDsgIEJJVC56cGcgKFwiYzNwb18wMDk0XCIpOyAgICAgICAgLy8gdGVzdCB0aGUgZGVmZXJyZWQgY2hhcmFjdGVyIGZsYWdcclxuLyogZWRkZiAqLyAgICAgICAgICAgICAgICAgICBCTUkucmVsIChcIl9lZGU2XCIpOyAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgZGVmZXJlZCBjaGFyYWN0ZXIgZ28gc2VuZCBpdFxyXG4vKiBlZGUxICovICAgICAgICAgICAgICAgICAgIFNFQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNldCBjYXJyeVxyXG4vKiBlZGUyICovICAgICAgICAgICAgICAgICAgIFJPUi56cGcgKFwiYzNwb18wMDk0XCIpOyAgICAgICAgLy8gc2hpZnQgaW50byB0aGUgZGVmZXJyZWQgY2hhcmFjdGVyIGZsYWdcclxuLyogZWRlNCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9lZGViXCIpOyAgICAgICAgICAgIC8vIHNhdmUgdGhlIGJ5dGUgYW5kIGV4aXQsIGJyYW5jaCBhbHdheXNcclxuLyogZWRlNiAqLyAgICAgICAgX2BfZWRlNmA7ICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzYXZlIHRoZSBieXRlXHJcbi8qIGVkZTcgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZWQ0MFwiKTsgICAgICAgICAgICAvLyBUeCBieXRlIG9uIHNlcmlhbCBidXNcclxuLyogZWRlYSAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIHRoZSBieXRlXHJcbi8qIGVkZWIgKi8gICAgICAgIF9gX2VkZWJgOyAgU1RBLnpwZyAoXCJic291cl8wMDk1XCIpOyAgICAgICAvLyBzYXZlIHRoZSBkZWZlcmVkIFR4IGJ5dGVcclxuLyogZWRlZCAqLyAgICAgICAgICAgICAgICAgICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBmbGFnIG9rXHJcbi8qIGVkZWUgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY29tbWFuZCBzZXJpYWwgYnVzIHRvIFVOVEFMS1xyXG4vKiBlZGVmICovICAgX2B1bnRsa19lZGVmYDsgIFNFSS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRpc2FibGUgdGhlIGludGVycnVwdHNcclxuLyogZWRmMCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9lZThlXCIpOyAgICAgICAgICAgIC8vIHNldCB0aGUgc2VyaWFsIGNsb2NrIG91dCBsb3dcclxuLyogZWRmMyAqLyAgICAgICAgICAgICAgICAgICBMREEuYWJzIChcImNpMnByYV9kZDAwXCIpOyAgICAgIC8vIHJlYWQgVklBIDIgRFJBLCBzZXJpYWwgcG9ydCBhbmQgdmlkZW8gYWRkcmVzc1xyXG4vKiBlZGY2ICovICAgICAgICAgICAgICAgICAgIE9SQS5pbW0gKDB4MDgpOyAgICAgICAgICAgICAgIC8vIG1hc2sgeHh4eCAxeHh4LCBzZXQgdGhlIHNlcmlhbCBBVE4gbG93XHJcbi8qIGVkZjggKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJjaTJwcmFfZGQwMFwiKTsgICAgICAvLyBzYXZlIFZJQSAyIERSQSwgc2VyaWFsIHBvcnQgYW5kIHZpZGVvIGFkZHJlc3NcclxuLyogZWRmYiAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDVmKTsgICAgICAgICAgICAgICAvLyBzZXQgdGhlIFVOVEFMSyBjb21tYW5kXHJcbi8qIGVkZmQgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDJjKTsgICAgICAgICAgICAgICAgLy8gbWFrZXMgbmV4dCBsaW5lIEJJVCAkM0ZBOVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBjb21tYW5kIHNlcmlhbCBidXMgdG8gVU5MSVNURU5cclxuLyogZWRmZSAqLyAgIF9gdW5sc25fZWRmZWA7ICBMREEuaW1tICgweDNmKTsgICAgICAgICAgICAgICAvLyBzZXQgdGhlIFVOTElTVEVOIGNvbW1hbmRcclxuLyogZWUwMCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9lZDExXCIpOyAgICAgICAgICAgIC8vIHNlbmQgYSBjb250cm9sIGNoYXJhY3RlclxyXG4vKiBlZTAzICovICAgICAgICBfYF9lZTAzYDsgIEpTUi5hYnMgKFwiX2VkYmVcIik7ICAgICAgICAgICAgLy8gc2V0IHNlcmlhbCBBVE4gaGlnaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDFtcyBkZWxheSwgY2xvY2sgaGlnaCB0aGVuIGRhdGEgaGlnaFxyXG4vKiBlZTA2ICovICAgICAgICBfYF9lZTA2YDsgIFRYQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgdGhlIGRldmljZSBudW1iZXJcclxuLyogZWUwNyAqLyAgICAgICAgICAgICAgICAgICBMRFguaW1tICgweDBhKTsgICAgICAgICAgICAgICAvLyBzaG9ydCBkZWxheVxyXG4vKiBlZTA5ICovICAgICAgICBfYF9lZTA5YDsgIERFWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCB0aGUgY291bnRcclxuLyogZWUwYSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9lZTA5XCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgbm90IGFsbCBkb25lXHJcbi8qIGVlMGMgKi8gICAgICAgICAgICAgICAgICAgVEFYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSB0aGUgZGV2aWNlIG51bWJlclxyXG4vKiBlZTBkICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2VlODVcIik7ICAgICAgICAgICAgLy8gc2V0IHRoZSBzZXJpYWwgY2xvY2sgb3V0IGhpZ2hcclxuLyogZWUxMCAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9lZTk3XCIpOyAgICAgICAgICAgIC8vIHNldCB0aGUgc2VyaWFsIGRhdGEgb3V0IGhpZ2ggYW5kIHJldHVyblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBpbnB1dCBhIGJ5dGUgZnJvbSB0aGUgc2VyaWFsIGJ1c1xyXG4vKiBlZTEzICovICAgX2BhY3B0cl9lZTEzYDsgIFNFSS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRpc2FibGUgdGhlIGludGVycnVwdHNcclxuLyogZWUxNCAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBzZXQgMCBiaXRzIHRvIGRvLCB3aWxsIGZsYWcgRU9JIG9uIHRpbWVvdXJcclxuLyogZWUxNiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImNudGRuXzAwYTVcIik7ICAgICAgIC8vIHNhdmUgdGhlIHNlcmlhbCBidXMgYml0IGNvdW50XHJcbi8qIGVlMTggKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZWU4NVwiKTsgICAgICAgICAgICAvLyBzZXQgdGhlIHNlcmlhbCBjbG9jayBvdXQgaGlnaFxyXG4vKiBlZTFiICovICAgICAgICBfYF9lZTFiYDsgIEpTUi5hYnMgKFwiX2VlYTlcIik7ICAgICAgICAgICAgLy8gZ2V0IHRoZSBzZXJpYWwgZGF0YSBzdGF0dXMgaW4gQ2JcclxuLyogZWUxZSAqLyAgICAgICAgICAgICAgICAgICBCUEwucmVsIChcIl9lZTFiXCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgdGhlIHNlcmlhbCBjbG9jayBpcyBsb3dcclxuLyogZWUyMCAqLyAgICAgICAgX2BfZWUyMGA7ICBMREEuaW1tICgweDAxKTsgICAgICAgICAgICAgICAvLyBzZXQgdGhlIHRpbWVvdXQgY291bnQgaGlnaCBieXRlXHJcbi8qIGVlMjIgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJ0aW1iaGlfZGMwN1wiKTsgICAgICAvLyBzYXZlIFZJQSAxIHRpbWVyIEIgaGlnaCBieXRlXHJcbi8qIGVlMjUgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgxOSk7ICAgICAgICAgICAgICAgLy8gbG9hZCB0aW1lciBCLCB0aW1lciBCIHNpbmdsZSBzaG90LCBzdGFydCB0aW1lciBCXHJcbi8qIGVlMjcgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJjaWFjcmJfZGMwZlwiKTsgICAgICAvLyBzYXZlIFZJQSAxIENSQlxyXG4vKiBlZTJhICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2VlOTdcIik7ICAgICAgICAgICAgLy8gc2V0IHRoZSBzZXJpYWwgZGF0YSBvdXQgaGlnaFxyXG4vKiBlZTJkICovICAgICAgICAgICAgICAgICAgIExEQS5hYnMgKFwiY2lhaWNyX2RjMGRcIik7ICAgICAgLy8gcmVhZCBWSUEgMSBJQ1JcclxuLyogZWUzMCAqLyAgICAgICAgX2BfZWUzMGA7ICBMREEuYWJzIChcImNpYWljcl9kYzBkXCIpOyAgICAgIC8vIHJlYWQgVklBIDEgSUNSXHJcbi8qIGVlMzMgKi8gICAgICAgICAgICAgICAgICAgQU5ELmltbSAoMHgwMik7ICAgICAgICAgICAgICAgLy8gbWFzayAwMDAwIDAweDAsIHRpbWVyIEEgaW50ZXJydXB0XHJcbi8qIGVlMzUgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZWUzZVwiKTsgICAgICAgICAgICAvLyBpZiB0aW1lciBBIGludGVycnVwdCBnbyA/P1xyXG4vKiBlZTM3ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2VlYTlcIik7ICAgICAgICAgICAgLy8gZ2V0IHRoZSBzZXJpYWwgZGF0YSBzdGF0dXMgaW4gQ2JcclxuLyogZWUzYSAqLyAgICAgICAgICAgICAgICAgICBCTUkucmVsIChcIl9lZTMwXCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgdGhlIHNlcmlhbCBjbG9jayBpcyBsb3dcclxuLyogZWUzYyAqLyAgICAgICAgICAgICAgICAgICBCUEwucmVsIChcIl9lZTU2XCIpOyAgICAgICAgICAgIC8vIGVsc2UgZ28gc2V0IDggYml0cyB0byBkbywgYnJhbmNoIGFsd2F5c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRpbWVyIEEgdGltZWQgb3V0XHJcbi8qIGVlM2UgKi8gICAgICAgIF9gX2VlM2VgOyAgTERBLnpwZyAoXCJjbnRkbl8wMGE1XCIpOyAgICAgICAvLyBnZXQgdGhlIHNlcmlhbCBidXMgYml0IGNvdW50XHJcbi8qIGVlNDAgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZWU0N1wiKTsgICAgICAgICAgICAvLyBpZiBub3QgYWxyZWFkeSBFT0kgdGhlbiBnbyBmbGFnIEVPSVxyXG4vKiBlZTQyICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MDIpOyAgICAgICAgICAgICAgIC8vIGVsc2UgZXJyb3IgJDAyLCByZWFkIHRpbWVvdXJcclxuLyogZWU0NCAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9lZGIyXCIpOyAgICAgICAgICAgIC8vIHNldCB0aGUgc2VyaWFsIHN0YXR1cyBhbmQgZXhpdFxyXG4vKiBlZTQ3ICovICAgICAgICBfYF9lZTQ3YDsgIEpTUi5hYnMgKFwiX2VlYTBcIik7ICAgICAgICAgICAgLy8gc2V0IHRoZSBzZXJpYWwgZGF0YSBvdXQgbG93XHJcbi8qIGVlNGEgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZWU4NVwiKTsgICAgICAgICAgICAvLyBzZXQgdGhlIHNlcmlhbCBjbG9jayBvdXQgaGlnaFxyXG4vKiBlZTRkICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4NDApOyAgICAgICAgICAgICAgIC8vIHNldCBFT0lcclxuLyogZWU0ZiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mZTFjXCIpOyAgICAgICAgICAgIC8vIE9SIGludG8gdGhlIHNlcmlhbCBzdGF0dXMgYnl0ZVxyXG4vKiBlZTUyICovICAgICAgICAgICAgICAgICAgIElOQy56cGcgKFwiY250ZG5fMDBhNVwiKTsgICAgICAgLy8gaW5jcmVtZW50IHRoZSBzZXJpYWwgYnVzIGJpdCBjb3VudCwgZG8gZXJyb3Igb24gdGhlIG5leHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aW1lb3V0XHJcbi8qIGVlNTQgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZWUyMFwiKTsgICAgICAgICAgICAvLyBnbyB0cnkgYWdhaW4sIGJyYW5jaCBhbHdheXNcclxuLyogZWU1NiAqLyAgICAgICAgX2BfZWU1NmA7ICBMREEuaW1tICgweDA4KTsgICAgICAgICAgICAgICAvLyBzZXQgOCBiaXRzIHRvIGRvXHJcbi8qIGVlNTggKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJjbnRkbl8wMGE1XCIpOyAgICAgICAvLyBzYXZlIHRoZSBzZXJpYWwgYnVzIGJpdCBjb3VudFxyXG4vKiBlZTVhICovICAgICAgICBfYF9lZTVhYDsgIExEQS5hYnMgKFwiY2kycHJhX2RkMDBcIik7ICAgICAgLy8gcmVhZCBWSUEgMiBEUkEsIHNlcmlhbCBwb3J0IGFuZCB2aWRlbyBhZGRyZXNzXHJcbi8qIGVlNWQgKi8gICAgICAgICAgICAgICAgICAgQ01QLmFicyAoXCJjaTJwcmFfZGQwMFwiKTsgICAgICAvLyBjb21wYXJlIGl0IHdpdGggaXRzZWxmXHJcbi8qIGVlNjAgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZWU1YVwiKTsgICAgICAgICAgICAvLyBpZiBjaGFuZ2luZyBnbyB0cnkgYWdhaW5cclxuLyogZWU2MiAqLyAgICAgICAgICAgICAgICAgICBBU0wuYWNjICgpOyAgICAgICAgICAgICAgICAgICAvLyBzaGlmdCB0aGUgc2VyaWFsIGRhdGEgaW50byB0aGUgY2FycnlcclxuLyogZWU2MyAqLyAgICAgICAgICAgICAgICAgICBCUEwucmVsIChcIl9lZTVhXCIpOyAgICAgICAgICAgIC8vIGxvb3Agd2hpbGUgdGhlIHNlcmlhbCBjbG9jayBpcyBsb3dcclxuLyogZWU2NSAqLyAgICAgICAgICAgICAgICAgICBST1IuenBnIChcInRidGNudF8wMGE0XCIpOyAgICAgIC8vIHNoaWZ0IHRoZSBkYXRhIGJpdCBpbnRvIHRoZSByZWNlaXZlIGJ5dGVcclxuLyogZWU2NyAqLyAgICAgICAgX2BfZWU2N2A7ICBMREEuYWJzIChcImNpMnByYV9kZDAwXCIpOyAgICAgIC8vIHJlYWQgVklBIDIgRFJBLCBzZXJpYWwgcG9ydCBhbmQgdmlkZW8gYWRkcmVzc1xyXG4vKiBlZTZhICovICAgICAgICAgICAgICAgICAgIENNUC5hYnMgKFwiY2kycHJhX2RkMDBcIik7ICAgICAgLy8gY29tcGFyZSBpdCB3aXRoIGl0c2VsZlxyXG4vKiBlZTZkICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2VlNjdcIik7ICAgICAgICAgICAgLy8gaWYgY2hhbmdpbmcgZ28gdHJ5IGFnYWluXHJcbi8qIGVlNmYgKi8gICAgICAgICAgICAgICAgICAgQVNMLmFjYyAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2hpZnQgdGhlIHNlcmlhbCBkYXRhIGludG8gdGhlIGNhcnJ5XHJcbi8qIGVlNzAgKi8gICAgICAgICAgICAgICAgICAgQk1JLnJlbCAoXCJfZWU2N1wiKTsgICAgICAgICAgICAvLyBsb29wIHdoaWxlIHRoZSBzZXJpYWwgY2xvY2sgaXMgaGlnaFxyXG4vKiBlZTcyICovICAgICAgICAgICAgICAgICAgIERFQy56cGcgKFwiY250ZG5fMDBhNVwiKTsgICAgICAgLy8gZGVjcmVtZW50IHRoZSBzZXJpYWwgYnVzIGJpdCBjb3VudFxyXG4vKiBlZTc0ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2VlNWFcIik7ICAgICAgICAgICAgLy8gbG9vcCBpZiBub3QgYWxsIGRvbmVcclxuLyogZWU3NiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9lZWEwXCIpOyAgICAgICAgICAgIC8vIHNldCB0aGUgc2VyaWFsIGRhdGEgb3V0IGxvd1xyXG4vKiBlZTc5ICovICAgICAgICAgICAgICAgICAgIEJJVC56cGcgKFwic3RhdHVzXzAwOTBcIik7ICAgICAgLy8gdGVzdCB0aGUgc2VyaWFsIHN0YXR1cyBieXRlXHJcbi8qIGVlN2IgKi8gICAgICAgICAgICAgICAgICAgQlZDLnJlbCAoXCJfZWU4MFwiKTsgICAgICAgICAgICAvLyBpZiBFT0kgbm90IHNldCBza2lwIHRoZSBidXMgZW5kIHNlcXVlbmNlXHJcbi8qIGVlN2QgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZWUwNlwiKTsgICAgICAgICAgICAvLyAxbXMgZGVsYXksIGNsb2NrIGhpZ2ggdGhlbiBkYXRhIGhpZ2hcclxuLyogZWU4MCAqLyAgICAgICAgX2BfZWU4MGA7ICBMREEuenBnIChcInRidGNudF8wMGE0XCIpOyAgICAgIC8vIGdldCB0aGUgcmVjZWl2ZSBieXRlXHJcbi8qIGVlODIgKi8gICAgICAgICAgICAgICAgICAgQ0xJLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZW5hYmxlIHRoZSBpbnRlcnJ1cHRzXHJcbi8qIGVlODMgKi8gICAgICAgICAgICAgICAgICAgQ0xDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZmxhZyBva1xyXG4vKiBlZTg0ICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHNldCB0aGUgc2VyaWFsIGNsb2NrIG91dCBoaWdoXHJcbi8qIGVlODUgKi8gICAgICAgIF9gX2VlODVgOyAgTERBLmFicyAoXCJjaTJwcmFfZGQwMFwiKTsgICAgICAvLyByZWFkIFZJQSAyIERSQSwgc2VyaWFsIHBvcnQgYW5kIHZpZGVvIGFkZHJlc3NcclxuLyogZWU4OCAqLyAgICAgICAgICAgICAgICAgICBBTkQuaW1tICgweGVmKTsgICAgICAgICAgICAgICAvLyBtYXNrIHh4eDAgeHh4eCwgc2V0IHNlcmlhbCBjbG9jayBvdXQgaGlnaFxyXG4vKiBlZThhICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiY2kycHJhX2RkMDBcIik7ICAgICAgLy8gc2F2ZSBWSUEgMiBEUkEsIHNlcmlhbCBwb3J0IGFuZCB2aWRlbyBhZGRyZXNzXHJcbi8qIGVlOGQgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gc2V0IHRoZSBzZXJpYWwgY2xvY2sgb3V0IGxvd1xyXG4vKiBlZThlICovICAgICAgICBfYF9lZThlYDsgIExEQS5hYnMgKFwiY2kycHJhX2RkMDBcIik7ICAgICAgLy8gcmVhZCBWSUEgMiBEUkEsIHNlcmlhbCBwb3J0IGFuZCB2aWRlbyBhZGRyZXNzXHJcbi8qIGVlOTEgKi8gICAgICAgICAgICAgICAgICAgT1JBLmltbSAoMHgxMCk7ICAgICAgICAgICAgICAgLy8gbWFzayB4eHgxIHh4eHgsIHNldCBzZXJpYWwgY2xvY2sgb3V0IGxvd1xyXG4vKiBlZTkzICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiY2kycHJhX2RkMDBcIik7ICAgICAgLy8gc2F2ZSBWSUEgMiBEUkEsIHNlcmlhbCBwb3J0IGFuZCB2aWRlbyBhZGRyZXNzXHJcbi8qIGVlOTYgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gc2V0IHRoZSBzZXJpYWwgZGF0YSBvdXQgaGlnaFxyXG4vKiBlZTk3ICovICAgICAgICBfYF9lZTk3YDsgIExEQS5hYnMgKFwiY2kycHJhX2RkMDBcIik7ICAgICAgLy8gcmVhZCBWSUEgMiBEUkEsIHNlcmlhbCBwb3J0IGFuZCB2aWRlbyBhZGRyZXNzXHJcbi8qIGVlOWEgKi8gICAgICAgICAgICAgICAgICAgQU5ELmltbSAoMHhkZik7ICAgICAgICAgICAgICAgLy8gbWFzayB4eDB4IHh4eHgsIHNldCBzZXJpYWwgZGF0YSBvdXQgaGlnaFxyXG4vKiBlZTljICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiY2kycHJhX2RkMDBcIik7ICAgICAgLy8gc2F2ZSBWSUEgMiBEUkEsIHNlcmlhbCBwb3J0IGFuZCB2aWRlbyBhZGRyZXNzXHJcbi8qIGVlOWYgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gc2V0IHRoZSBzZXJpYWwgZGF0YSBvdXQgbG93XHJcbi8qIGVlYTAgKi8gICAgICAgIF9gX2VlYTBgOyAgTERBLmFicyAoXCJjaTJwcmFfZGQwMFwiKTsgICAgICAvLyByZWFkIFZJQSAyIERSQSwgc2VyaWFsIHBvcnQgYW5kIHZpZGVvIGFkZHJlc3NcclxuLyogZWVhMyAqLyAgICAgICAgICAgICAgICAgICBPUkEuaW1tICgweDIwKTsgICAgICAgICAgICAgICAvLyBtYXNrIHh4MXggeHh4eCwgc2V0IHNlcmlhbCBkYXRhIG91dCBsb3dcclxuLyogZWVhNSAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcImNpMnByYV9kZDAwXCIpOyAgICAgIC8vIHNhdmUgVklBIDIgRFJBLCBzZXJpYWwgcG9ydCBhbmQgdmlkZW8gYWRkcmVzc1xyXG4vKiBlZWE4ICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGdldCB0aGUgc2VyaWFsIGRhdGEgc3RhdHVzIGluIENiXHJcbi8qIGVlYTkgKi8gICAgICAgIF9gX2VlYTlgOyAgTERBLmFicyAoXCJjaTJwcmFfZGQwMFwiKTsgICAgICAvLyByZWFkIFZJQSAyIERSQSwgc2VyaWFsIHBvcnQgYW5kIHZpZGVvIGFkZHJlc3NcclxuLyogZWVhYyAqLyAgICAgICAgICAgICAgICAgICBDTVAuYWJzIChcImNpMnByYV9kZDAwXCIpOyAgICAgIC8vIGNvbXBhcmUgaXQgd2l0aCBpdHNlbGZcclxuLyogZWVhZiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9lZWE5XCIpOyAgICAgICAgICAgIC8vIGlmIGNoYW5naW5nIGdvdCB0cnkgYWdhaW5cclxuLyogZWViMSAqLyAgICAgICAgICAgICAgICAgICBBU0wuYWNjICgpOyAgICAgICAgICAgICAgICAgICAvLyBzaGlmdCB0aGUgc2VyaWFsIGRhdGEgaW50byBDYlxyXG4vKiBlZWIyICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIDFtcyBkZWxheVxyXG4vKiBlZWIzICovICAgICAgICBfYF9lZWIzYDsgIFRYQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgWFxyXG4vKiBlZWI0ICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4YjgpOyAgICAgICAgICAgICAgIC8vIHNldCB0aGUgbG9vcCBjb3VudFxyXG4vKiBlZWI2ICovICAgICAgICBfYF9lZWI2YDsgIERFWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCB0aGUgbG9vcCBjb3VudFxyXG4vKiBlZWI3ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2VlYjZcIik7ICAgICAgICAgICAgLy8gbG9vcCBpZiBtb3JlIHRvIGRvXHJcbi8qIGVlYjkgKi8gICAgICAgICAgICAgICAgICAgVEFYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBYXHJcbi8qIGVlYmEgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gUlMyMzIgVHggTk1JIHJvdXRpbmVcclxuLyogZWViYiAqLyAgICAgICAgX2BfZWViYmA7ICBMREEuenBnIChcImJpdHRzXzAwYjRcIik7ICAgICAgIC8vIGdldCBSUzIzMiBiaXQgY291bnRcclxuLyogZWViZCAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9lZjA2XCIpOyAgICAgICAgICAgIC8vIGlmIHplcm8gZ28gc2V0dXAgbmV4dCBSUzIzMiBUeCBieXRlIGFuZCByZXR1cm5cclxuLyogZWViZiAqLyAgICAgICAgICAgICAgICAgICBCTUkucmVsIChcIl9lZjAwXCIpOyAgICAgICAgICAgIC8vIGlmIC12ZSBnbyBkbyBzdG9wIGJpdChzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgYml0IGNvdW50IGlzIG5vbiB6ZXJvIGFuZCArdmVcclxuLyogZWVjMSAqLyAgICAgICAgICAgICAgICAgICBMU1IuenBnIChcInJvZGF0YV8wMGI2XCIpOyAgICAgIC8vIHNoaWZ0IFJTMjMyIG91dHB1dCBieXRlIGJ1ZmZlclxyXG4vKiBlZWMzICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIHNldCAkMDAgZm9yIGJpdCA9IDBcclxuLyogZWVjNSAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9lZWM4XCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBiaXQgd2FzIDBcclxuLyogZWVjNyAqLyAgICAgICAgICAgICAgICAgICBERVguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzZXQgJEZGIGZvciBiaXQgPSAxXHJcbi8qIGVlYzggKi8gICAgICAgIF9gX2VlYzhgOyAgVFhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBiaXQgdG8gQVxyXG4vKiBlZWM5ICovICAgICAgICAgICAgICAgICAgIEVPUi56cGcgKFwicm9wcnR5XzAwYmRcIik7ICAgICAgLy8gRU9SIHdpdGggUlMyMzIgcGFyaXR5IGJ5dGVcclxuLyogZWVjYiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInJvcHJ0eV8wMGJkXCIpOyAgICAgIC8vIHNhdmUgUlMyMzIgcGFyaXR5IGJ5dGVcclxuLyogZWVjZCAqLyAgICAgICAgICAgICAgICAgICBERUMuenBnIChcImJpdHRzXzAwYjRcIik7ICAgICAgIC8vIGRlY3JlbWVudCBSUzIzMiBiaXQgY291bnRcclxuLyogZWVjZiAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9lZWQ3XCIpOyAgICAgICAgICAgIC8vIGlmIFJTMjMyIGJpdCBjb3VudCBub3cgemVybyBnbyBkbyBwYXJpdHkgYml0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBiaXQgYW5kIGV4aXRcclxuLyogZWVkMSAqLyAgICAgICAgX2BfZWVkMWA7ICBUWEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IGJpdCB0byBBXHJcbi8qIGVlZDIgKi8gICAgICAgICAgICAgICAgICAgQU5ELmltbSAoMHgwNCk7ICAgICAgICAgICAgICAgLy8gbWFzayAwMDAwIDB4MDAsIFJTMjMyIFR4IERBVEEgYml0XHJcbi8qIGVlZDQgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJueHRiaXRfMDBiNVwiKTsgICAgICAvLyBzYXZlIHRoZSBuZXh0IFJTMjMyIGRhdGEgYml0IHRvIHNlbmRcclxuLyogZWVkNiAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBkbyBSUzIzMiBwYXJpdHkgYml0LCBlbnRlcnMgd2l0aCBSUzIzMiBiaXQgY291bnQgPSAwXHJcbi8qIGVlZDcgKi8gICAgICAgIF9gX2VlZDdgOyAgTERBLmltbSAoMHgyMCk7ICAgICAgICAgICAgICAgLy8gbWFzayAwMHgwIDAwMDAsIHBhcml0eSBlbmFibGUgYml0XHJcbi8qIGVlZDkgKi8gICAgICAgICAgICAgICAgICAgQklULmFicyAoXCJtNTFjZHJfMDI5NFwiKTsgICAgICAvLyB0ZXN0IHRoZSBwc2V1ZG8gNjU1MSBjb21tYW5kIHJlZ2lzdGVyXHJcbi8qIGVlZGMgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZWVmMlwiKTsgICAgICAgICAgICAvLyBpZiBwYXJpdHkgZGlzYWJsZWQgZ28gPz9cclxuLyogZWVkZSAqLyAgICAgICAgICAgICAgICAgICBCTUkucmVsIChcIl9lZWZjXCIpOyAgICAgICAgICAgIC8vIGlmIGZpeGVkIG1hcmsgb3Igc3BhY2UgcGFyaXR5IGdvID8/XHJcbi8qIGVlZTAgKi8gICAgICAgICAgICAgICAgICAgQlZTLnJlbCAoXCJfZWVmNlwiKTsgICAgICAgICAgICAvLyBpZiBldmVuIHBhcml0eSBnbyA/P1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2Ugb2RkIHBhcml0eVxyXG4vKiBlZWUyICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwicm9wcnR5XzAwYmRcIik7ICAgICAgLy8gZ2V0IFJTMjMyIHBhcml0eSBieXRlXHJcbi8qIGVlZTQgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZWVlN1wiKTsgICAgICAgICAgICAvLyBpZiBwYXJpdHkgbm90IHplcm8gbGVhdmUgcGFyaXR5IGJpdCA9IDBcclxuLyogZWVlNiAqLyAgICAgICAgX2BfZWVlNmA7ICBERVguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHBhcml0eSBiaXQgPSAxXHJcbi8qIGVlZTcgKi8gICAgICAgIF9gX2VlZTdgOyAgREVDLnpwZyAoXCJiaXR0c18wMGI0XCIpOyAgICAgICAvLyBkZWNyZW1lbnQgUlMyMzIgYml0IGNvdW50LCAxIHN0b3AgYml0XHJcbi8qIGVlZTkgKi8gICAgICAgICAgICAgICAgICAgTERBLmFicyAoXCJtNTFjdHJfMDI5M1wiKTsgICAgICAvLyBnZXQgcHNldWRvIDY1NTEgY29udHJvbCByZWdpc3RlclxyXG4vKiBlZWVjICovICAgICAgICAgICAgICAgICAgIEJQTC5yZWwgKFwiX2VlZDFcIik7ICAgICAgICAgICAgLy8gaWYgMSBzdG9wIGJpdCBzYXZlIHBhcml0eSBiaXQgYW5kIGV4aXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIHR3byBzdG9wIGJpdHMgLi5cclxuLyogZWVlZSAqLyAgICAgICAgICAgICAgICAgICBERUMuenBnIChcImJpdHRzXzAwYjRcIik7ICAgICAgIC8vIGRlY3JlbWVudCBSUzIzMiBiaXQgY291bnQsIDIgc3RvcCBiaXRzXHJcbi8qIGVlZjAgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZWVkMVwiKTsgICAgICAgICAgICAvLyBzYXZlIGJpdCBhbmQgZXhpdCwgYnJhbmNoIGFsd2F5c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhcml0eSBpcyBkaXNhYmxlZCBzbyB0aGUgcGFyaXR5IGJpdCBiZWNvbWVzIHRoZSBmaXJzdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcG9zc2libHkgb25seSwgc3RvcCBiaXQuIHRvIGRvIHRoaXMgaW5jcmVtZW50IHRoZSBiaXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb3VudCB3aGljaCBlZmZlY3RpdmVseSBkZWNyZW1lbnRzIHRoZSBzdG9wIGJpdCBjb3VudC5cclxuLyogZWVmMiAqLyAgICAgICAgX2BfZWVmMmA7ICBJTkMuenBnIChcImJpdHRzXzAwYjRcIik7ICAgICAgIC8vIGluY3JlbWVudCBSUzIzMiBiaXQgY291bnQsID0gLTEgc3RvcCBiaXRcclxuLyogZWVmNCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9lZWU2XCIpOyAgICAgICAgICAgIC8vIHNldCBzdG9wIGJpdCA9IDEgYW5kIGV4aXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyBldmVuIHBhcml0eVxyXG4vKiBlZWY2ICovICAgICAgICBfYF9lZWY2YDsgIExEQS56cGcgKFwicm9wcnR5XzAwYmRcIik7ICAgICAgLy8gZ2V0IFJTMjMyIHBhcml0eSBieXRlXHJcbi8qIGVlZjggKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZWVlN1wiKTsgICAgICAgICAgICAvLyBpZiBwYXJpdHkgemVybyBsZWF2ZSBwYXJpdHkgYml0ID0gMFxyXG4vKiBlZWZhICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2VlZTZcIik7ICAgICAgICAgICAgLy8gZWxzZSBtYWtlIHBhcml0eSBiaXQgPSAxLCBicmFuY2ggYWx3YXlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZml4ZWQgbWFyayBvciBzcGFjZSBwYXJpdHlcclxuLyogZWVmYyAqLyAgICAgICAgX2BfZWVmY2A7ICBCVlMucmVsIChcIl9lZWU3XCIpOyAgICAgICAgICAgIC8vIGlmIGZpeGVkIHNwYWNlIHBhcml0eSBsZWF2ZSBwYXJpdHkgYml0ID0gMFxyXG4vKiBlZWZlICovICAgICAgICAgICAgICAgICAgIEJWQy5yZWwgKFwiX2VlZTZcIik7ICAgICAgICAgICAgLy8gZWxzZSBmaXhlZCBtYXJrIHBhcml0eSBtYWtlIHBhcml0eSBiaXQgPSAxLCBicmFuY2ggYWx3YXlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVjcmVtZW50IHN0b3AgYml0IGNvdW50LCBzZXQgc3RvcCBiaXQgPSAxIGFuZCBleGl0LiAkRkYgaXMgb25lIHN0b3AgYml0LCAkRkUgaXMgdHdvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCBiaXRzXHJcbi8qIGVmMDAgKi8gICAgICAgIF9gX2VmMDBgOyAgSU5DLnpwZyAoXCJiaXR0c18wMGI0XCIpOyAgICAgICAvLyBkZWNyZW1lbnQgUlMyMzIgYml0IGNvdW50XHJcbi8qIGVmMDIgKi8gICAgICAgICAgICAgICAgICAgTERYLmltbSAoMHhmZik7ICAgICAgICAgICAgICAgLy8gc2V0IHN0b3AgYml0ID0gMVxyXG4vKiBlZjA0ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2VlZDFcIik7ICAgICAgICAgICAgLy8gc2F2ZSBzdG9wIGJpdCBhbmQgZXhpdCwgYnJhbmNoIGFsd2F5c1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzZXR1cCBuZXh0IFJTMjMyIFR4IGJ5dGVcclxuLyogZWYwNiAqLyAgICAgICAgX2BfZWYwNmA7ICBMREEuYWJzIChcIm01MWNkcl8wMjk0XCIpOyAgICAgIC8vIHJlYWQgdGhlIDY1NTEgcHNldWRvIGNvbW1hbmQgcmVnaXN0ZXJcclxuLyogZWYwOSAqLyAgICAgICAgICAgICAgICAgICBMU1IuYWNjICgpOyAgICAgICAgICAgICAgICAgICAvLyBoYW5kc2hha2UgYml0IGlub3QgQ2JcclxuLyogZWYwYSAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9lZjEzXCIpOyAgICAgICAgICAgIC8vIGlmIDMgbGluZSBpbnRlcmZhY2UgZ28gPz9cclxuLyogZWYwYyAqLyAgICAgICAgICAgICAgICAgICBCSVQuYWJzIChcImNpMnByYl9kZDAxXCIpOyAgICAgIC8vIHRlc3QgVklBIDIgRFJCLCBSUzIzMiBwb3J0XHJcbi8qIGVmMGYgKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfZWYyZVwiKTsgICAgICAgICAgICAvLyBpZiBEU1IgPSAwIHNldCBEU1Igc2lnbmFsIG5vdCBwcmVzZW50IGFuZCBleGl0XHJcbi8qIGVmMTEgKi8gICAgICAgICAgICAgICAgICAgQlZDLnJlbCAoXCJfZWYzMVwiKTsgICAgICAgICAgICAvLyBpZiBDVFMgPSAwIHNldCBDVFMgc2lnbmFsIG5vdCBwcmVzZW50IGFuZCBleGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2FzIDMgbGluZSBpbnRlcmZhY2VcclxuLyogZWYxMyAqLyAgICAgICAgX2BfZWYxM2A7ICBMREEuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBBXHJcbi8qIGVmMTUgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJyb3BydHlfMDBiZFwiKTsgICAgICAvLyBjbGVhciB0aGUgUlMyMzIgcGFyaXR5IGJ5dGVcclxuLyogZWYxNyAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcIm54dGJpdF8wMGI1XCIpOyAgICAgIC8vIGNsZWFyIHRoZSBSUzIzMiBuZXh0IGJpdCB0byBzZW5kXHJcbi8qIGVmMTkgKi8gICAgICAgICAgICAgICAgICAgTERYLmFicyAoXCJiaXRudW1fMDI5OFwiKTsgICAgICAvLyBnZXQgdGhlIG51bWJlciBvZiBiaXRzIHRvIGJlIHNlbnQvcmVjZWl2ZWRcclxuLyogZWYxYyAqLyAgICAgICAgICAgICAgICAgICBTVFguenBnIChcImJpdHRzXzAwYjRcIik7ICAgICAgIC8vIHNldCB0aGUgUlMyMzIgYml0IGNvdW50XHJcbi8qIGVmMWUgKi8gICAgICAgICAgICAgICAgICAgTERZLmFicyAoXCJyb2Ric18wMjlkXCIpOyAgICAgICAvLyBnZXQgdGhlIGluZGV4IHRvIHRoZSBUeCBidWZmZXIgc3RhcnRcclxuLyogZWYyMSAqLyAgICAgICAgICAgICAgICAgICBDUFkuYWJzIChcInJvZGJlXzAyOWVcIik7ICAgICAgIC8vIGNvbXBhcmUgaXQgd2l0aCB0aGUgaW5kZXggdG8gdGhlIFR4IGJ1ZmZlciBlbmRcclxuLyogZWYyNCAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9lZjM5XCIpOyAgICAgICAgICAgIC8vIGlmIGFsbCBkb25lIGdvIGRpc2FibGUgVD8/IGludGVycnVwdCBhbmQgcmV0dXJuXHJcbi8qIGVmMjYgKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJyb2J1ZiswXzAwZjlcIik7ICAgICAvLyBlbHNlIGdldCBhIGJ5dGUgZnJvbSB0aGUgYnVmZmVyXHJcbi8qIGVmMjggKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJyb2RhdGFfMDBiNlwiKTsgICAgICAvLyBzYXZlIGl0IHRvIHRoZSBSUzIzMiBvdXRwdXQgYnl0ZSBidWZmZXJcclxuLyogZWYyYSAqLyAgICAgICAgICAgICAgICAgICBJTkMuYWJzIChcInJvZGJzXzAyOWRcIik7ICAgICAgIC8vIGluY3JlbWVudCB0aGUgaW5kZXggdG8gdGhlIFR4IGJ1ZmZlciBzdGFydFxyXG4vKiBlZjJkICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHNldCBEU1Igc2lnbmFsIG5vdCBwcmVzZW50XHJcbi8qIGVmMmUgKi8gICAgICAgIF9gX2VmMmVgOyAgTERBLmltbSAoMHg0MCk7ICAgICAgICAgICAgICAgLy8gc2V0IERTUiBzaWduYWwgbm90IHByZXNlbnRcclxuLyogZWYzMCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MmMpOyAgICAgICAgICAgICAgICAvLyBtYWtlcyBuZXh0IGxpbmUgQklUICQxMEE5XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHNldCBDVFMgc2lnbmFsIG5vdCBwcmVzZW50XHJcbi8qIGVmMzEgKi8gICAgICAgIF9gX2VmMzFgOyAgTERBLmltbSAoMHgxMCk7ICAgICAgICAgICAgICAgLy8gc2V0IENUUyBzaWduYWwgbm90IHByZXNlbnRcclxuLyogZWYzMyAqLyAgICAgICAgICAgICAgICAgICBPUkEuYWJzIChcInJzc3RhdF8wMjk3XCIpOyAgICAgIC8vIE9SIGl0IHdpdGggdGhlIFJTMjMyIHN0YXR1cyByZWdpc3RlclxyXG4vKiBlZjM2ICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwicnNzdGF0XzAyOTdcIik7ICAgICAgLy8gc2F2ZSB0aGUgUlMyMzIgc3RhdHVzIHJlZ2lzdGVyXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGRpc2FibGUgdGltZXIgQSBpbnRlcnJ1cHRcclxuLyogZWYzOSAqLyAgICAgICAgX2BfZWYzOWA7ICBMREEuaW1tICgweDAxKTsgICAgICAgICAgICAgICAvLyBkaXNhYmxlIHRpbWVyIEEgaW50ZXJydXB0XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHNldCBWSUEgMiBJQ1IgZnJvbSBBXHJcbi8qIGVmM2IgKi8gICAgICAgIF9gX2VmM2JgOyAgU1RBLmFicyAoXCJjaTJpY3JfZGQwZFwiKTsgICAgICAvLyBzYXZlIFZJQSAyIElDUlxyXG4vKiBlZjNlICovICAgICAgICAgICAgICAgICAgIEVPUi5hYnMgKFwiZW5hYmxfMDJhMVwiKTsgICAgICAgLy8gRU9SIHdpdGggdGhlIFJTLTIzMiBpbnRlcnJ1cHQgZW5hYmxlIGJ5dGVcclxuLyogZWY0MSAqLyAgICAgICAgICAgICAgICAgICBPUkEuaW1tICgweDgwKTsgICAgICAgICAgICAgICAvLyBzZXQgdGhlIGludGVycnVwdHMgZW5hYmxlIGJpdFxyXG4vKiBlZjQzICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiZW5hYmxfMDJhMVwiKTsgICAgICAgLy8gc2F2ZSB0aGUgUlMtMjMyIGludGVycnVwdCBlbmFibGUgYnl0ZVxyXG4vKiBlZjQ2ICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiY2kyaWNyX2RkMGRcIik7ICAgICAgLy8gc2F2ZSBWSUEgMiBJQ1JcclxuLyogZWY0OSAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBjb21wdXRlIGJpdCBjb3VudFxyXG4vKiBlZjRhICovICAgICAgICBfYF9lZjRhYDsgIExEWC5pbW0gKDB4MDkpOyAgICAgICAgICAgICAgIC8vIHNldCBiaXQgY291bnQgdG8gOSwgOCBkYXRhICsgMSBzdG9wIGJpdFxyXG4vKiBlZjRjICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MjApOyAgICAgICAgICAgICAgIC8vIG1hc2sgZm9yIDgvNyBkYXRhIGJpdHNcclxuLyogZWY0ZSAqLyAgICAgICAgICAgICAgICAgICBCSVQuYWJzIChcIm01MWN0cl8wMjkzXCIpOyAgICAgIC8vIHRlc3QgcHNldWRvIDY1NTEgY29udHJvbCByZWdpc3RlclxyXG4vKiBlZjUxICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2VmNTRcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIDggYml0c1xyXG4vKiBlZjUzICovICAgICAgICAgICAgICAgICAgIERFWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgZGVjcmVtZW50IGNvdW50IGZvciA3IGRhdGEgYml0c1xyXG4vKiBlZjU0ICovICAgICAgICBfYF9lZjU0YDsgIEJWQy5yZWwgKFwiX2VmNThcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIDcgYml0c1xyXG4vKiBlZjU2ICovICAgICAgICAgICAgICAgICAgIERFWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgZGVjcmVtZW50IGNvdW50IC4uXHJcbi8qIGVmNTcgKi8gICAgICAgICAgICAgICAgICAgREVYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gLi4gZm9yIDUgZGF0YSBiaXRzXHJcbi8qIGVmNTggKi8gICAgICAgIF9gX2VmNThgOyAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gUlMyMzIgUnggTk1JXHJcbi8qIGVmNTkgKi8gICAgICAgIF9gX2VmNTlgOyAgTERYLnpwZyAoXCJyaW5vbmVfMDBhOVwiKTsgICAgICAvLyBnZXQgc3RhcnQgYml0IGNoZWNrIGZsYWdcclxuLyogZWY1YiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9lZjkwXCIpOyAgICAgICAgICAgIC8vIGlmIG5vIHN0YXJ0IGJpdCByZWNlaXZlZCBnbyA/P1xyXG4vKiBlZjVkICovICAgICAgICAgICAgICAgICAgIERFQy56cGcgKFwiYml0Y2lfMDBhOFwiKTsgICAgICAgLy8gZGVjcmVtZW50IHJlY2VpdmVyIGJpdCBjb3VudCBpblxyXG4vKiBlZjVmICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2VmOTdcIik7ICAgICAgICAgICAgLy8gaWYgdGhlIGJ5dGUgaXMgY29tcGxldGUgZ28gYWRkIGl0IHRvIHRoZSBidWZmZXJcclxuLyogZWY2MSAqLyAgICAgICAgICAgICAgICAgICBCTUkucmVsIChcIl9lZjcwXCIpO1xyXG4vKiBlZjYzICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiaW5iaXRfMDBhN1wiKTsgICAgICAgLy8gZ2V0IHRoZSBSUzIzMiByZWNlaXZlZCBkYXRhIGJpdFxyXG4vKiBlZjY1ICovICAgICAgICAgICAgICAgICAgIEVPUi56cGcgKFwicmlwcnR5XzAwYWJcIik7ICAgICAgLy8gRU9SIHdpdGggdGhlIHJlY2VpdmVyIHBhcml0eSBiaXRcclxuLyogZWY2NyAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInJpcHJ0eV8wMGFiXCIpOyAgICAgIC8vIHNhdmUgdGhlIHJlY2VpdmVyIHBhcml0eSBiaXRcclxuLyogZWY2OSAqLyAgICAgICAgICAgICAgICAgICBMU1IuenBnIChcImluYml0XzAwYTdcIik7ICAgICAgIC8vIHNoaWZ0IHRoZSBSUzIzMiByZWNlaXZlZCBkYXRhIGJpdFxyXG4vKiBlZjZiICovICAgICAgICAgICAgICAgICAgIFJPUi56cGcgKFwicmlkYXRhXzAwYWFcIik7XHJcbi8qIGVmNmQgKi8gICAgICAgIF9gX2VmNmRgOyAgUlRTLmltcCAoKTtcclxuLyogZWY2ZSAqLyAgICAgICAgX2BfZWY2ZWA7ICBERUMuenBnIChcImJpdGNpXzAwYThcIik7ICAgICAgIC8vIGRlY3JlbWVudCByZWNlaXZlciBiaXQgY291bnQgaW5cclxuLyogZWY3MCAqLyAgICAgICAgX2BfZWY3MGA7ICBMREEuenBnIChcImluYml0XzAwYTdcIik7ICAgICAgIC8vIGdldCB0aGUgUlMyMzIgcmVjZWl2ZWQgZGF0YSBiaXRcclxuLyogZWY3MiAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9lZmRiXCIpO1xyXG4vKiBlZjc0ICovICAgICAgICAgICAgICAgICAgIExEQS5hYnMgKFwibTUxY3RyXzAyOTNcIik7ICAgICAgLy8gZ2V0IHBzZXVkbyA2NTUxIGNvbnRyb2wgcmVnaXN0ZXJcclxuLyogZWY3NyAqLyAgICAgICAgICAgICAgICAgICBBU0wuYWNjICgpOyAgICAgICAgICAgICAgICAgICAvLyBzaGlmdCB0aGUgc3RvcCBiaXQgZmxhZyB0byBDYlxyXG4vKiBlZjc4ICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MDEpOyAgICAgICAgICAgICAgIC8vICsgMVxyXG4vKiBlZjdhICovICAgICAgICAgICAgICAgICAgIEFEQy56cGcgKFwiYml0Y2lfMDBhOFwiKTsgICAgICAgLy8gYWRkIHJlY2VpdmVyIGJpdCBjb3VudCBpblxyXG4vKiBlZjdjICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2VmNmRcIik7ICAgICAgICAgICAgLy8gZXhpdCwgYnJhbmNoIGFsd2F5c1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzZXR1cCB0byByZWNlaXZlIGFuIFJTMjMyIGJpdFxyXG4vKiBlZjdlICovICAgICAgICBfYF9lZjdlYDsgIExEQS5pbW0gKDB4OTApOyAgICAgICAgICAgICAgIC8vIGVuYWJsZSBGTEFHIGludGVycnVwdFxyXG4vKiBlZjgwICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiY2kyaWNyX2RkMGRcIik7ICAgICAgLy8gc2F2ZSBWSUEgMiBJQ1JcclxuLyogZWY4MyAqLyAgICAgICAgICAgICAgICAgICBPUkEuYWJzIChcImVuYWJsXzAyYTFcIik7ICAgICAgIC8vIE9SIHdpdGggdGhlIFJTLTIzMiBpbnRlcnJ1cHQgZW5hYmxlIGJ5dGVcclxuLyogZWY4NiAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcImVuYWJsXzAyYTFcIik7ICAgICAgIC8vIHNhdmUgdGhlIFJTLTIzMiBpbnRlcnJ1cHQgZW5hYmxlIGJ5dGVcclxuLyogZWY4OSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInJpbm9uZV8wMGE5XCIpOyAgICAgIC8vIHNldCBzdGFydCBiaXQgY2hlY2sgZmxhZywgc2V0IG5vIHN0YXJ0IGJpdCByZWNlaXZlZFxyXG4vKiBlZjhiICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MDIpOyAgICAgICAgICAgICAgIC8vIGRpc2FibGUgdGltZXIgQiBpbnRlcnJ1cHRcclxuLyogZWY4ZCAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9lZjNiXCIpOyAgICAgICAgICAgIC8vIHNldCBWSUEgMiBJQ1IgZnJvbSBBIGFuZCByZXR1cm5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gbm8gUlMyMzIgc3RhcnQgYml0IHJlY2VpdmVkXHJcbi8qIGVmOTAgKi8gICAgICAgIF9gX2VmOTBgOyAgTERBLnpwZyAoXCJpbmJpdF8wMGE3XCIpOyAgICAgICAvLyBnZXQgdGhlIFJTMjMyIHJlY2VpdmVkIGRhdGEgYml0XHJcbi8qIGVmOTIgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZWY3ZVwiKTsgICAgICAgICAgICAvLyBpZiA/PyBnbyBzZXR1cCB0byByZWNlaXZlIGFuIFJTMjMyIGJpdCBhbmQgcmV0dXJuXHJcbi8qIGVmOTQgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZTRkM1wiKTsgICAgICAgICAgICAvLyBmbGFnIHRoZSBSUzIzMiBzdGFydCBiaXQgYW5kIHNldCB0aGUgcGFyaXR5XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHJlY2VpdmVkIGEgd2hvbGUgYnl0ZSwgYWRkIGl0IHRvIHRoZSBidWZmZXJcclxuLyogZWY5NyAqLyAgICAgICAgX2BfZWY5N2A7ICBMRFkuYWJzIChcInJpZGJlXzAyOWJcIik7ICAgICAgIC8vIGdldCBpbmRleCB0byBSeCBidWZmZXIgZW5kXHJcbi8qIGVmOWEgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGluZGV4XHJcbi8qIGVmOWIgKi8gICAgICAgICAgICAgICAgICAgQ1BZLmFicyAoXCJyaWRic18wMjljXCIpOyAgICAgICAvLyBjb21wYXJlIHdpdGggaW5kZXggdG8gUnggYnVmZmVyIHN0YXJ0XHJcbi8qIGVmOWUgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZWZjYVwiKTsgICAgICAgICAgICAvLyBpZiBidWZmZXIgZnVsbCBnbyBkbyBSeCBvdmVycnVuIGVycm9yXHJcbi8qIGVmYTAgKi8gICAgICAgICAgICAgICAgICAgU1RZLmFicyAoXCJyaWRiZV8wMjliXCIpOyAgICAgICAvLyBzYXZlIGluZGV4IHRvIFJ4IGJ1ZmZlciBlbmRcclxuLyogZWZhMyAqLyAgICAgICAgICAgICAgICAgICBERVkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBkZWNyZW1lbnQgaW5kZXhcclxuLyogZWZhNCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInJpZGF0YV8wMGFhXCIpOyAgICAgIC8vIGdldCBhc3NlbWJsZWQgYnl0ZVxyXG4vKiBlZmE2ICovICAgICAgICAgICAgICAgICAgIExEWC5hYnMgKFwiYml0bnVtXzAyOThcIik7ICAgICAgLy8gZ2V0IGJpdCBjb3VudFxyXG4vKiBlZmE5ICovICAgICAgICBfYF9lZmE5YDsgIENQWC5pbW0gKDB4MDkpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCBieXRlICsgc3RvcFxyXG4vKiBlZmFiICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2VmYjFcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIGFsbCBuaW5lIGJpdHMgcmVjZWl2ZWRcclxuLyogZWZhZCAqLyAgICAgICAgICAgICAgICAgICBMU1IuYWNjICgpOyAgICAgICAgICAgICAgICAgICAvLyBlbHNlIHNoaWZ0IGJ5dGVcclxuLyogZWZhZSAqLyAgICAgICAgICAgICAgICAgICBJTlguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgYml0IGNvdW50XHJcbi8qIGVmYWYgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZWZhOVwiKTsgICAgICAgICAgICAvLyBsb29wLCBicmFuY2ggYWx3YXlzXHJcbi8qIGVmYjEgKi8gICAgICAgIF9gX2VmYjFgOyAgU1RBLmlueSAoXCJyaWJ1ZiswXzAwZjdcIik7ICAgICAvLyBzYXZlIHJlY2VpdmVkIGJ5dGUgdG8gUnggYnVmZmVyXHJcbi8qIGVmYjMgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgyMCk7ICAgICAgICAgICAgICAgLy8gbWFzayAwMHgwIDAwMDAsIHBhcml0eSBlbmFibGUgYml0XHJcbi8qIGVmYjUgKi8gICAgICAgICAgICAgICAgICAgQklULmFicyAoXCJtNTFjZHJfMDI5NFwiKTsgICAgICAvLyB0ZXN0IHRoZSBwc2V1ZG8gNjU1MSBjb21tYW5kIHJlZ2lzdGVyXHJcbi8qIGVmYjggKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZWY2ZVwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgcGFyaXR5IGRpc2FibGVkXHJcbi8qIGVmYmEgKi8gICAgICAgICAgICAgICAgICAgQk1JLnJlbCAoXCJfZWY2ZFwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbWFyayBvciBzcGFjZSBwYXJpdHlcclxuLyogZWZiYyAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImluYml0XzAwYTdcIik7ICAgICAgIC8vIGdldCB0aGUgUlMyMzIgcmVjZWl2ZWQgZGF0YSBiaXRcclxuLyogZWZiZSAqLyAgICAgICAgICAgICAgICAgICBFT1IuenBnIChcInJpcHJ0eV8wMGFiXCIpOyAgICAgIC8vIEVPUiB3aXRoIHRoZSByZWNlaXZlciBwYXJpdHkgYml0XHJcbi8qIGVmYzAgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZWZjNVwiKTtcclxuLyogZWZjMiAqLyAgICAgICAgICAgICAgICAgICBCVlMucmVsIChcIl9lZjZkXCIpOyAgICAgICAgICAgIC8vIGlmID8/IGp1c3QgZXhpdFxyXG4vKiBlZmM0ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgyYyk7ICAgICAgICAgICAgICAgIC8vIG1ha2VzIG5leHQgbGluZSBCSVQgJEE2NTBcclxuLyogZWZjNSAqLyAgICAgICAgX2BfZWZjNWA7ICBCVkMucmVsIChcIl9lZjZkXCIpOyAgICAgICAgICAgIC8vIGlmID8/IGp1c3QgZXhpdFxyXG4vKiBlZmM3ICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MDEpOyAgICAgICAgICAgICAgIC8vIHNldCBSeCBwYXJpdHkgZXJyb3JcclxuLyogZWZjOSAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MmMpOyAgICAgICAgICAgICAgICAvLyBtYWtlcyBuZXh0IGxpbmUgQklUICQwNEE5XHJcbi8qIGVmY2EgKi8gICAgICAgIF9gX2VmY2FgOyAgTERBLmltbSAoMHgwNCk7ICAgICAgICAgICAgICAgLy8gc2V0IFJ4IG92ZXJydW4gZXJyb3JcclxuLyogZWZjYyAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MmMpOyAgICAgICAgICAgICAgICAvLyBtYWtlcyBuZXh0IGxpbmUgQklUICQ4MEE5XHJcbi8qIGVmY2QgKi8gICAgICAgIF9gX2VmY2RgOyAgTERBLmltbSAoMHg4MCk7ICAgICAgICAgICAgICAgLy8gc2V0IFJ4IGJyZWFrIGVycm9yXHJcbi8qIGVmY2YgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDJjKTsgICAgICAgICAgICAgICAgLy8gbWFrZXMgbmV4dCBsaW5lIEJJVCAkMDJBOVxyXG4vKiBlZmQwICovICAgICAgICBfYF9lZmQwYDsgIExEQS5pbW0gKDB4MDIpOyAgICAgICAgICAgICAgIC8vIHNldCBSeCBmcmFtZSBlcnJvclxyXG4vKiBlZmQyICovICAgICAgICAgICAgICAgICAgIE9SQS5hYnMgKFwicnNzdGF0XzAyOTdcIik7ICAgICAgLy8gT1IgaXQgd2l0aCB0aGUgUlMyMzIgc3RhdHVzIGJ5dGVcclxuLyogZWZkNSAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcInJzc3RhdF8wMjk3XCIpOyAgICAgIC8vIHNhdmUgdGhlIFJTMjMyIHN0YXR1cyBieXRlXHJcbi8qIGVmZDggKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZWY3ZVwiKTsgICAgICAgICAgICAvLyBzZXR1cCB0byByZWNlaXZlIGFuIFJTMjMyIGJpdCBhbmQgcmV0dXJuXHJcbi8qIGVmZGIgKi8gICAgICAgIF9gX2VmZGJgOyAgTERBLnpwZyAoXCJyaWRhdGFfMDBhYVwiKTtcclxuLyogZWZkZCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9lZmQwXCIpOyAgICAgICAgICAgIC8vIGlmID8/IGRvIGZyYW1lIGVycm9yXHJcbi8qIGVmZGYgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZWZjZFwiKTsgICAgICAgICAgICAvLyBlbHNlIGRvIGJyZWFrIGVycm9yLCBicmFuY2ggYWx3YXlzXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIG9wZW4gUlMyMzIgY2hhbm5lbCBmb3Igb3V0cHV0XHJcbi8qIGVmZTEgKi8gICAgICAgIF9gX2VmZTFgOyAgU1RBLnpwZyAoXCJkZmx0b18wMDlhXCIpOyAgICAgICAvLyBzYXZlIHRoZSBvdXRwdXQgZGV2aWNlIG51bWJlclxyXG4vKiBlZmUzICovICAgICAgICAgICAgICAgICAgIExEQS5hYnMgKFwibTUxY2RyXzAyOTRcIik7ICAgICAgLy8gcmVhZCB0aGUgcHNldWRvIDY1NTEgY29tbWFuZCByZWdpc3RlclxyXG4vKiBlZmU2ICovICAgICAgICAgICAgICAgICAgIExTUi5hY2MgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNoaWZ0IGhhbmRzaGFrZSBiaXQgdG8gY2FycnlcclxuLyogZWZlNyAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9mMDEyXCIpOyAgICAgICAgICAgIC8vIGlmIDMgbGluZSBpbnRlcmZhY2UgZ28gPz9cclxuLyogZWZlOSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDAyKTsgICAgICAgICAgICAgICAvLyBtYXNrIDAwMDAgMDB4MCwgUlRTIG91dFxyXG4vKiBlZmViICovICAgICAgICAgICAgICAgICAgIEJJVC5hYnMgKFwiY2kycHJiX2RkMDFcIik7ICAgICAgLy8gdGVzdCBWSUEgMiBEUkIsIFJTMjMyIHBvcnRcclxuLyogZWZlZSAqLyAgICAgICAgICAgICAgICAgICBCUEwucmVsIChcIl9mMDBkXCIpOyAgICAgICAgICAgIC8vIGlmIERTUiA9IDAgc2V0IERTUiBub3QgcHJlc2VudCBhbmQgZXhpdFxyXG4vKiBlZmYwICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2YwMTJcIik7ICAgICAgICAgICAgLy8gaWYgUlRTID0gMSBqdXN0IGV4aXRcclxuLyogZWZmMiAqLyAgICAgICAgX2BfZWZmMmA7ICBMREEuYWJzIChcImVuYWJsXzAyYTFcIik7ICAgICAgIC8vIGdldCB0aGUgUlMtMjMyIGludGVycnVwdCBlbmFibGUgYnl0ZVxyXG4vKiBlZmY1ICovICAgICAgICAgICAgICAgICAgIEFORC5pbW0gKDB4MDIpOyAgICAgICAgICAgICAgIC8vIG1hc2sgMDAwMCAwMHgwLCB0aW1lciBCIGludGVycnVwdFxyXG4vKiBlZmY3ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2VmZjJcIik7ICAgICAgICAgICAgLy8gbG9vcCB3aGlsZSB0aGUgdGltZXIgQiBpbnRlcnJ1cHQgaXMgZW5lYmxlZFxyXG4vKiBlZmY5ICovICAgICAgICBfYF9lZmY5YDsgIEJJVC5hYnMgKFwiY2kycHJiX2RkMDFcIik7ICAgICAgLy8gdGVzdCBWSUEgMiBEUkIsIFJTMjMyIHBvcnRcclxuLyogZWZmYyAqLyAgICAgICAgICAgICAgICAgICBCVlMucmVsIChcIl9lZmY5XCIpOyAgICAgICAgICAgIC8vIGxvb3Agd2hpbGUgQ1RTIGhpZ2hcclxuLyogZWZmZSAqLyAgICAgICAgICAgICAgICAgICBMREEuYWJzIChcImNpMnByYl9kZDAxXCIpOyAgICAgIC8vIHJlYWQgVklBIDIgRFJCLCBSUzIzMiBwb3J0XHJcbi8qIGYwMDEgKi8gICAgICAgICAgICAgICAgICAgT1JBLmltbSAoMHgwMik7ICAgICAgICAgICAgICAgLy8gbWFzayB4eHh4IHh4MXgsIHNldCBSVFMgaGlnaFxyXG4vKiBmMDAzICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiY2kycHJiX2RkMDFcIik7ICAgICAgLy8gc2F2ZSBWSUEgMiBEUkIsIFJTMjMyIHBvcnRcclxuLyogZjAwNiAqLyAgICAgICAgX2BfZjAwNmA7ICBCSVQuYWJzIChcImNpMnByYl9kZDAxXCIpOyAgICAgIC8vIHRlc3QgVklBIDIgRFJCLCBSUzIzMiBwb3J0XHJcbi8qIGYwMDkgKi8gICAgICAgICAgICAgICAgICAgQlZTLnJlbCAoXCJfZjAxMlwiKTsgICAgICAgICAgICAvLyBleGl0IGlmIENUUyBoaWdoXHJcbi8qIGYwMGIgKi8gICAgICAgICAgICAgICAgICAgQk1JLnJlbCAoXCJfZjAwNlwiKTsgICAgICAgICAgICAvLyBsb29wIHdoaWxlIERTUiBoaWdoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IG5vIERTUiBhbmQgZXhpdFxyXG4vKiBmMDBkICovICAgICAgICBfYF9mMDBkYDsgIExEQS5pbW0gKDB4NDApOyAgICAgICAgICAgICAgIC8vIHNldCBEU1Igc2lnbmFsIG5vdCBwcmVzZW50XHJcbi8qIGYwMGYgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJyc3N0YXRfMDI5N1wiKTsgICAgICAvLyBzYXZlIHRoZSBSUzIzMiBzdGF0dXMgcmVnaXN0ZXJcclxuLyogZjAxMiAqLyAgICAgICAgX2BfZjAxMmA7ICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBmbGFnIG9rXHJcbi8qIGYwMTMgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gc2VuZCBieXRlIHRvIHRoZSBSUzIzMiBidWZmZXJcclxuLyogZjAxNCAqLyAgICAgICAgX2BfZjAxNGA7ICBKU1IuYWJzIChcIl9mMDI4XCIpOyAgICAgICAgICAgIC8vIHNldHVwIGZvciBSUzIzMiB0cmFuc21pdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlbmQgYnl0ZSB0byB0aGUgUlMyMzIgYnVmZmVyLCBubyBzZXR1cFxyXG4vKiBmMDE3ICovICAgICAgICBfYF9mMDE3YDsgIExEWS5hYnMgKFwicm9kYmVfMDI5ZVwiKTsgICAgICAgLy8gZ2V0IGluZGV4IHRvIFR4IGJ1ZmZlciBlbmRcclxuLyogZjAxYSAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyArIDFcclxuLyogZjAxYiAqLyAgICAgICAgICAgICAgICAgICBDUFkuYWJzIChcInJvZGJzXzAyOWRcIik7ICAgICAgIC8vIGNvbXBhcmUgd2l0aCBpbmRleCB0byBUeCBidWZmZXIgc3RhcnRcclxuLyogZjAxZSAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mMDE0XCIpOyAgICAgICAgICAgIC8vIGxvb3Agd2hpbGUgYnVmZmVyIGZ1bGxcclxuLyogZjAyMCAqLyAgICAgICAgICAgICAgICAgICBTVFkuYWJzIChcInJvZGJlXzAyOWVcIik7ICAgICAgIC8vIHNldCBpbmRleCB0byBUeCBidWZmZXIgZW5kXHJcbi8qIGYwMjMgKi8gICAgICAgICAgICAgICAgICAgREVZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5kZXggdG8gYXZhaWxhYmxlIGJ1ZmZlciBieXRlXHJcbi8qIGYwMjQgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJwdHIxXzAwOWVcIik7ICAgICAgICAvLyByZWFkIHRoZSBSUzIzMiBjaGFyYWN0ZXIgYnVmZmVyXHJcbi8qIGYwMjYgKi8gICAgICAgICAgICAgICAgICAgU1RBLmlueSAoXCJyb2J1ZiswXzAwZjlcIik7ICAgICAvLyBzYXZlIHRoZSBieXRlIHRvIHRoZSBidWZmZXJcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gc2V0dXAgZm9yIFJTMjMyIHRyYW5zbWl0XHJcbi8qIGYwMjggKi8gICAgICAgIF9gX2YwMjhgOyAgTERBLmFicyAoXCJlbmFibF8wMmExXCIpOyAgICAgICAvLyBnZXQgdGhlIFJTLTIzMiBpbnRlcnJ1cHQgZW5hYmxlIGJ5dGVcclxuLyogZjAyYiAqLyAgICAgICAgICAgICAgICAgICBMU1IuYWNjICgpOyAgICAgICAgICAgICAgICAgICAvLyBzaGlmdCB0aGUgZW5hYmxlIGJpdCB0byBDYlxyXG4vKiBmMDJjICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2YwNGNcIik7ICAgICAgICAgICAgLy8gaWYgaW50ZXJydXB0cyBhcmUgZW5hYmxlZCBqdXN0IGV4aXRcclxuLyogZjAyZSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDEwKTsgICAgICAgICAgICAgICAvLyBzdGFydCB0aW1lciBBXHJcbi8qIGYwMzAgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJjaTJjcmFfZGQwZVwiKTsgICAgICAvLyBzYXZlIFZJQSAyIENSQVxyXG4vKiBmMDMzICovICAgICAgICAgICAgICAgICAgIExEQS5hYnMgKFwiYmF1ZG9mKzBfMDI5OVwiKTsgICAgLy8gZ2V0IHRoZSBiYXVkIHJhdGUgYml0IHRpbWUgbG93IGJ5dGVcclxuLyogZjAzNiAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcInRpMmFsb19kZDA0XCIpOyAgICAgIC8vIHNhdmUgVklBIDIgdGltZXIgQSBsb3cgYnl0ZVxyXG4vKiBmMDM5ICovICAgICAgICAgICAgICAgICAgIExEQS5hYnMgKFwiYmF1ZG9mKzFfMDI5YVwiKTsgICAgLy8gZ2V0IHRoZSBiYXVkIHJhdGUgYml0IHRpbWUgaGlnaCBieXRlXHJcbi8qIGYwM2MgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJ0aTJhaGlfZGQwNVwiKTsgICAgICAvLyBzYXZlIFZJQSAyIHRpbWVyIEEgaGlnaCBieXRlXHJcbi8qIGYwM2YgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHg4MSk7ICAgICAgICAgICAgICAgLy8gZW5hYmxlIHRpbWVyIEEgaW50ZXJydXB0XHJcbi8qIGYwNDEgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZWYzYlwiKTsgICAgICAgICAgICAvLyBzZXQgVklBIDIgSUNSIGZyb20gQVxyXG4vKiBmMDQ0ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2VmMDZcIik7ICAgICAgICAgICAgLy8gc2V0dXAgbmV4dCBSUzIzMiBUeCBieXRlXHJcbi8qIGYwNDcgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgxMSk7ICAgICAgICAgICAgICAgLy8gbG9hZCB0aW1lciBBLCBzdGFydCB0aW1lciBBXHJcbi8qIGYwNDkgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJjaTJjcmFfZGQwZVwiKTsgICAgICAvLyBzYXZlIFZJQSAyIENSQVxyXG4vKiBmMDRjICovICAgICAgICBfYF9mMDRjYDsgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGlucHV0IGZyb20gUlMyMzIgYnVmZmVyXHJcbi8qIGYwNGQgKi8gICAgICAgIF9gX2YwNGRgOyAgU1RBLnpwZyAoXCJkZmx0bl8wMDk5XCIpOyAgICAgICAvLyBzYXZlIHRoZSBpbnB1dCBkZXZpY2UgbnVtYmVyXHJcbi8qIGYwNGYgKi8gICAgICAgICAgICAgICAgICAgTERBLmFicyAoXCJtNTFjZHJfMDI5NFwiKTsgICAgICAvLyBnZXQgcHNldWRvIDY1NTEgY29tbWFuZCByZWdpc3RlclxyXG4vKiBmMDUyICovICAgICAgICAgICAgICAgICAgIExTUi5hY2MgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNoaWZ0IHRoZSBoYW5kc2hha2UgYml0IHRvIENiXHJcbi8qIGYwNTMgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfZjA3ZFwiKTsgICAgICAgICAgICAvLyBpZiAzIGxpbmUgaW50ZXJmYWNlIGdvID8/XHJcbi8qIGYwNTUgKi8gICAgICAgICAgICAgICAgICAgQU5ELmltbSAoMHgwOCk7ICAgICAgICAgICAgICAgLy8gbWFzayB0aGUgZHVwbGV4IGJpdCwgcHNldWRvIDY1NTEgY29tbWFuZCBpcyA+PiAxXHJcbi8qIGYwNTcgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZjA3ZFwiKTsgICAgICAgICAgICAvLyBpZiBmdWxsIGR1cGxleCBnbyA/P1xyXG4vKiBmMDU5ICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MDIpOyAgICAgICAgICAgICAgIC8vIG1hc2sgMDAwMCAwMHgwLCBSVFMgb3V0XHJcbi8qIGYwNWIgKi8gICAgICAgICAgICAgICAgICAgQklULmFicyAoXCJjaTJwcmJfZGQwMVwiKTsgICAgICAvLyB0ZXN0IFZJQSAyIERSQiwgUlMyMzIgcG9ydFxyXG4vKiBmMDVlICovICAgICAgICAgICAgICAgICAgIEJQTC5yZWwgKFwiX2YwMGRcIik7ICAgICAgICAgICAgLy8gaWYgRFNSID0gMCBzZXQgbm8gRFNSIGFuZCBleGl0XHJcbi8qIGYwNjAgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZjA4NFwiKTsgICAgICAgICAgICAvLyBpZiBSVFMgPSAwIGp1c3QgZXhpdFxyXG4vKiBmMDYyICovICAgICAgICBfYF9mMDYyYDsgIExEQS5hYnMgKFwiZW5hYmxfMDJhMVwiKTsgICAgICAgLy8gZ2V0IHRoZSBSUy0yMzIgaW50ZXJydXB0IGVuYWJsZSBieXRlXHJcbi8qIGYwNjUgKi8gICAgICAgICAgICAgICAgICAgTFNSLmFjYyAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2hpZnQgdGhlIHRpbWVyIEEgaW50ZXJydXB0IGVuYWJsZSBiaXQgdG8gQ2JcclxuLyogZjA2NiAqLyAgICAgICAgICAgICAgICAgICBCQ1MucmVsIChcIl9mMDYyXCIpOyAgICAgICAgICAgIC8vIGxvb3Agd2hpbGUgdGhlIHRpbWVyIEEgaW50ZXJydXB0IGlzIGVuYWJsZWRcclxuLyogZjA2OCAqLyAgICAgICAgICAgICAgICAgICBMREEuYWJzIChcImNpMnByYl9kZDAxXCIpOyAgICAgIC8vIHJlYWQgVklBIDIgRFJCLCBSUzIzMiBwb3J0XHJcbi8qIGYwNmIgKi8gICAgICAgICAgICAgICAgICAgQU5ELmltbSAoMHhmZCk7ICAgICAgICAgICAgICAgLy8gbWFzayB4eHh4IHh4MHgsIGNsZWFyIFJUUyBvdXRcclxuLyogZjA2ZCAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcImNpMnByYl9kZDAxXCIpOyAgICAgIC8vIHNhdmUgVklBIDIgRFJCLCBSUzIzMiBwb3J0XHJcbi8qIGYwNzAgKi8gICAgICAgIF9gX2YwNzBgOyAgTERBLmFicyAoXCJjaTJwcmJfZGQwMVwiKTsgICAgICAvLyByZWFkIFZJQSAyIERSQiwgUlMyMzIgcG9ydFxyXG4vKiBmMDczICovICAgICAgICAgICAgICAgICAgIEFORC5pbW0gKDB4MDQpOyAgICAgICAgICAgICAgIC8vIG1hc2sgeHh4eCB4MXh4LCBEVFIgaW5cclxuLyogZjA3NSAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mMDcwXCIpOyAgICAgICAgICAgIC8vIGxvb3Agd2hpbGUgRFRSIGxvd1xyXG4vKiBmMDc3ICovICAgICAgICBfYF9mMDc3YDsgIExEQS5pbW0gKDB4OTApOyAgICAgICAgICAgICAgIC8vIGVuYWJsZSB0aGUgRkxBRyBpbnRlcnJ1cHRcclxuLyogZjA3OSAqLyAgICAgICAgICAgICAgICAgICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBmbGFnIG9rXHJcbi8qIGYwN2EgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZWYzYlwiKTsgICAgICAgICAgICAvLyBzZXQgVklBIDIgSUNSIGZyb20gQSBhbmQgcmV0dXJuXHJcbi8qIGYwN2QgKi8gICAgICAgIF9gX2YwN2RgOyAgTERBLmFicyAoXCJlbmFibF8wMmExXCIpOyAgICAgICAvLyBnZXQgdGhlIFJTLTIzMiBpbnRlcnJ1cHQgZW5hYmxlIGJ5dGVcclxuLyogZjA4MCAqLyAgICAgICAgICAgICAgICAgICBBTkQuaW1tICgweDEyKTsgICAgICAgICAgICAgICAvLyBtYXNrIDAwMHggMDB4MFxyXG4vKiBmMDgyICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2YwNzdcIik7ICAgICAgICAgICAgLy8gaWYgRkxBRyBvciB0aW1lciBCIGJpdHMgc2V0IGdvIGVuYWJsZSB0aGUgRkxBRyBpbmV0cnJ1cHRcclxuLyogZjA4NCAqLyAgICAgICAgX2BfZjA4NGA7ICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBmbGFnIG9rXHJcbi8qIGYwODUgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gZ2V0IGJ5dGUgZnJvbSBSUzIzMiBidWZmZXJcclxuLyogZjA4NiAqLyAgICAgICAgX2BfZjA4NmA7ICBMREEuYWJzIChcInJzc3RhdF8wMjk3XCIpOyAgICAgIC8vIGdldCB0aGUgUlMyMzIgc3RhdHVzIHJlZ2lzdGVyXHJcbi8qIGYwODkgKi8gICAgICAgICAgICAgICAgICAgTERZLmFicyAoXCJyaWRic18wMjljXCIpOyAgICAgICAvLyBnZXQgaW5kZXggdG8gUnggYnVmZmVyIHN0YXJ0XHJcbi8qIGYwOGMgKi8gICAgICAgICAgICAgICAgICAgQ1BZLmFicyAoXCJyaWRiZV8wMjliXCIpOyAgICAgICAvLyBjb21wYXJlIHdpdGggaW5kZXggdG8gUnggYnVmZmVyIGVuZFxyXG4vKiBmMDhmICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2YwOWNcIik7ICAgICAgICAgICAgLy8gcmV0dXJuIG51bGwgaWYgYnVmZmVyIGVtcHR5XHJcbi8qIGYwOTEgKi8gICAgICAgICAgICAgICAgICAgQU5ELmltbSAoMHhmNyk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgdGhlIFJ4IGJ1ZmZlciBlbXB0eSBiaXRcclxuLyogZjA5MyAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcInJzc3RhdF8wMjk3XCIpOyAgICAgIC8vIHNhdmUgdGhlIFJTMjMyIHN0YXR1cyByZWdpc3RlclxyXG4vKiBmMDk2ICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwicmlidWYrMF8wMGY3XCIpOyAgICAgLy8gZ2V0IGJ5dGUgZnJvbSBSeCBidWZmZXJcclxuLyogZjA5OCAqLyAgICAgICAgICAgICAgICAgICBJTkMuYWJzIChcInJpZGJzXzAyOWNcIik7ICAgICAgIC8vIGluY3JlbWVudCBpbmRleCB0byBSeCBidWZmZXIgc3RhcnRcclxuLyogZjA5YiAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG4vKiBmMDljICovICAgICAgICBfYF9mMDljYDsgIE9SQS5pbW0gKDB4MDgpOyAgICAgICAgICAgICAgIC8vIHNldCB0aGUgUnggYnVmZmVyIGVtcHR5IGJpdFxyXG4vKiBmMDllICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwicnNzdGF0XzAyOTdcIik7ICAgICAgLy8gc2F2ZSB0aGUgUlMyMzIgc3RhdHVzIHJlZ2lzdGVyXHJcbi8qIGYwYTEgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gcmV0dXJuIG51bGxcclxuLyogZjBhMyAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBjaGVjayBSUzIzMiBidXMgaWRsZVxyXG4vKiBmMGE0ICovICAgICAgICBfYF9mMGE0YDsgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgQVxyXG4vKiBmMGE1ICovICAgICAgICAgICAgICAgICAgIExEQS5hYnMgKFwiZW5hYmxfMDJhMVwiKTsgICAgICAgLy8gZ2V0IHRoZSBSUy0yMzIgaW50ZXJydXB0IGVuYWJsZSBieXRlXHJcbi8qIGYwYTggKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZjBiYlwiKTsgICAgICAgICAgICAvLyBpZiBubyBpbnRlcnJ1cHRzIGVuYWJsZWQganVzdCBleGl0XHJcbi8qIGYwYWEgKi8gICAgICAgIF9gX2YwYWFgOyAgTERBLmFicyAoXCJlbmFibF8wMmExXCIpOyAgICAgICAvLyBnZXQgdGhlIFJTLTIzMiBpbnRlcnJ1cHQgZW5hYmxlIGJ5dGVcclxuLyogZjBhZCAqLyAgICAgICAgICAgICAgICAgICBBTkQuaW1tICgweDAzKTsgICAgICAgICAgICAgICAvLyBtYXNrIDAwMDAgMDB4eCwgdGhlIGVycm9yIGJpdHNcclxuLyogZjBhZiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mMGFhXCIpOyAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBlcnJvcnMgbG9vcFxyXG4vKiBmMGIxICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MTApOyAgICAgICAgICAgICAgIC8vIGRpc2FibGUgRkxBRyBpbnRlcnJ1cHRcclxuLyogZjBiMyAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcImNpMmljcl9kZDBkXCIpOyAgICAgIC8vIHNhdmUgVklBIDIgSUNSXHJcbi8qIGYwYjYgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgQVxyXG4vKiBmMGI4ICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiZW5hYmxfMDJhMVwiKTsgICAgICAgLy8gY2xlYXIgdGhlIFJTLTIzMiBpbnRlcnJ1cHQgZW5hYmxlIGJ5dGVcclxuLyogZjBiYiAqLyAgICAgICAgX2BfZjBiYmA7ICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIEFcclxuLyogZjBiYyAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBrZXJuZWwgSS9PIG1lc3NhZ2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSS9PIEVSUk9SICNcclxuLyogZjBiZCAqLyAgICAgICAgX2BfZjBiZGA7ICBfLmJ5dGVzKDB4MGQsIDB4NDksIDB4MmYsIDB4NGYsIDB4MjAsIDB4NDUsIDB4NTIsIDB4NTIpO1xyXG4vKiBmMGM1ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg0ZiwgMHg1MiwgMHgyMCwgMHhhMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU0VBUkNISU5HXHJcbi8qIGYwYzkgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDBkLCAweDUzLCAweDQ1LCAweDQxLCAweDUyLCAweDQzLCAweDQ4LCAweDQ5KTtcclxuLyogZjBkMSAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NGUsIDB4NDcsIDB4YTApO1xyXG4vKiBmMGQ0ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg0NiwgMHg0ZiwgMHg1MiwgMHhhMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUFJFU1MgUExBWSBPTiBUQVBFXHJcbi8qIGYwZDggKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDBkLCAweDUwLCAweDUyLCAweDQ1LCAweDUzLCAweDUzLCAweDIwLCAweDUwKTtcclxuLyogZjBlMCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NGMsIDB4NDEsIDB4NTksIDB4MjAsIDB4NGYsIDB4NGUsIDB4MjAsIDB4NTQpO1xyXG4vKiBmMGU4ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg0MSwgMHg1MCwgMHhjNSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUFJFU1MgUkVDT1JEICYgUExBWSBPTiBUQVBFXHJcbi8qIGYwZWIgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDUwLCAweDUyLCAweDQ1LCAweDUzLCAweDUzLCAweDIwLCAweDUyLCAweDQ1KTtcclxuLyogZjBmMyAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NDMsIDB4NGYsIDB4NTIsIDB4NDQsIDB4MjAsIDB4MjYsIDB4MjAsIDB4NTApO1xyXG4vKiBmMGZiICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg0YywgMHg0MSwgMHg1OSwgMHgyMCwgMHg0ZiwgMHg0ZSwgMHgyMCwgMHg1NCk7XHJcbi8qIGYxMDMgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDQxLCAweDUwLCAweGM1KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMT0FESU5HXHJcbi8qIGYxMDYgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDBkLCAweDRjLCAweDRmLCAweDQxLCAweDQ0LCAweDQ5LCAweDRlLCAweGM3KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTQVZJTkdcclxuLyogZjEwZSAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MGQsIDB4NTMsIDB4NDEsIDB4NTYsIDB4NDksIDB4NGUsIDB4NDcsIDB4YTApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZFUklGWUlOR1xyXG4vKiBmMTE2ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgwZCwgMHg1NiwgMHg0NSwgMHg1MiwgMHg0OSwgMHg0NiwgMHg1OSwgMHg0OSk7XHJcbi8qIGYxMWUgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDRlLCAweGM3KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGT1VORFxyXG4vKiBmMTIwICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgwZCwgMHg0NiwgMHg0ZiwgMHg1NSwgMHg0ZSwgMHg0NCwgMHhhMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT0tcclxuLyogZjEyNyAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MGQsIDB4NGYsIDB4NGIsIDB4OGQpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBkaXNwbGF5IGNvbnRyb2wgSS9PIG1lc3NhZ2UgaWYgaW4gZGlyZWN0IG1vZGVcclxuLyogZjEyYiAqLyAgICAgICAgX2BfZjEyYmA7ICBCSVQuenBnIChcIm1zZ2ZsZ18wMDlkXCIpOyAgICAgIC8vIHRlc3QgbWVzc2FnZSBtb2RlIGZsYWdcclxuLyogZjEyZCAqLyAgICAgICAgICAgICAgICAgICBCUEwucmVsIChcIl9mMTNjXCIpOyAgICAgICAgICAgIC8vIGV4aXQgaWYgY29udHJvbCBtZXNzYWdlcyBvZmZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkaXNwbGF5IGtlcm5lbCBJL08gbWVzc2FnZVxyXG4vKiBmMTJmICovICAgICAgICBfYF9mMTJmYDsgIExEQS5hYnkgKFwiX2YwYmRcIik7ICAgICAgICAgICAgLy8gZ2V0IGJ5dGUgZnJvbSBtZXNzYWdlIHRhYmxlXHJcbi8qIGYxMzIgKi8gICAgICAgICAgICAgICAgICAgUEhQLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBzdGF0dXNcclxuLyogZjEzMyAqLyAgICAgICAgICAgICAgICAgICBBTkQuaW1tICgweDdmKTsgICAgICAgICAgICAgICAvLyBjbGVhciBiN1xyXG4vKiBmMTM1ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiY2hyb3V0X2ZmZDJcIik7ICAgICAgLy8gb3V0cHV0IGNoYXJhY3RlciB0byBjaGFubmVsXHJcbi8qIGYxMzggKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGluZGV4XHJcbi8qIGYxMzkgKi8gICAgICAgICAgICAgICAgICAgUExQLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBzdGF0dXNcclxuLyogZjEzYSAqLyAgICAgICAgICAgICAgICAgICBCUEwucmVsIChcIl9mMTJmXCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgbm90IGVuZCBvZiBtZXNzYWdlXHJcbi8qIGYxM2MgKi8gICAgICAgIF9gX2YxM2NgOyAgQ0xDLmltcCAoKTtcclxuLyogZjEzZCAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBnZXQgY2hhcmFjdGVyIGZyb20gdGhlIGlucHV0IGRldmljZVxyXG4vKiBmMTNlICovICAgX2BnZXRpbl9mMTNlYDsgIExEQS56cGcgKFwiZGZsdG5fMDA5OVwiKTsgICAgICAgLy8gZ2V0IHRoZSBpbnB1dCBkZXZpY2UgbnVtYmVyXHJcbi8qIGYxNDAgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZjE0YVwiKTsgICAgICAgICAgICAvLyBpZiBub3QgdGhlIGtleWJvYXJkIGdvIGhhbmRsZSBvdGhlciBkZXZpY2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGlucHV0IGRldmljZSB3YXMgdGhlIGtleWJvYXJkXHJcbi8qIGYxNDIgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJuZHhfMDBjNlwiKTsgICAgICAgICAvLyBnZXQgdGhlIGtleWJvYXJkIGJ1ZmZlciBpbmRleFxyXG4vKiBmMTQ0ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2YxNTVcIik7ICAgICAgICAgICAgLy8gaWYgdGhlIGJ1ZmZlciBpcyBlbXB0eSBnbyBmbGFnIG5vIGJ5dGUgYW5kIHJldHVyblxyXG4vKiBmMTQ2ICovICAgICAgICAgICAgICAgICAgIFNFSS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRpc2FibGUgdGhlIGludGVycnVwdHNcclxuLyogZjE0NyAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcImxwMl9lNWI0XCIpOyAgICAgICAgIC8vIGdldCBpbnB1dCBmcm9tIHRoZSBrZXlib2FyZCBidWZmZXIgYW5kIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBpbnB1dCBkZXZpY2Ugd2FzIG5vdCB0aGUga2V5Ym9hcmRcclxuLyogZjE0YSAqLyAgICAgICAgX2BfZjE0YWA7ICBDTVAuaW1tICgweDAyKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHRoZSBkZXZpY2Ugd2l0aCB0aGUgUlMyMzIgZGV2aWNlXHJcbi8qIGYxNGMgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZjE2NlwiKTsgICAgICAgICAgICAvLyBpZiBub3QgdGhlIFJTMjMyIGRldmljZSBnbyA/P1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBpbnB1dCBkZXZpY2UgaXMgdGhlIFJTMjMyIGRldmljZVxyXG4vKiBmMTRlICovICAgICAgICBfYF9mMTRlYDsgIFNUWS56cGcgKFwieHNhdl8wMDk3XCIpOyAgICAgICAgLy8gc2F2ZSBZXHJcbi8qIGYxNTAgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZjA4NlwiKTsgICAgICAgICAgICAvLyBnZXQgYSBieXRlIGZyb20gUlMyMzIgYnVmZmVyXHJcbi8qIGYxNTMgKi8gICAgICAgICAgICAgICAgICAgTERZLnpwZyAoXCJ4c2F2XzAwOTdcIik7ICAgICAgICAvLyByZXN0b3JlIFlcclxuLyogZjE1NSAqLyAgICAgICAgX2BfZjE1NWA7ICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBmbGFnIG5vIGVycm9yXHJcbi8qIGYxNTYgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gaW5wdXQgYSBjaGFyYWN0ZXIgZnJvbSBjaGFubmVsXHJcbi8qIGYxNTcgKi8gICBfYGNocmluX2YxNTdgOyAgTERBLnpwZyAoXCJkZmx0bl8wMDk5XCIpOyAgICAgICAvLyBnZXQgdGhlIGlucHV0IGRldmljZSBudW1iZXJcclxuLyogZjE1OSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mMTY2XCIpOyAgICAgICAgICAgIC8vIGlmIG5vdCB0aGUga2V5Ym9hcmQgY29udGludWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgaW5wdXQgZGV2aWNlIHdhcyB0aGUga2V5Ym9hcmRcclxuLyogZjE1YiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInBudHJfMDBkM1wiKTsgICAgICAgIC8vIGdldCB0aGUgY3Vyc29yIGNvbHVtblxyXG4vKiBmMTVkICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwibHhzcCsxXzAwY2FcIik7ICAgICAgLy8gc2V0IHRoZSBpbnB1dCBjdXJzb3IgY29sdW1uXHJcbi8qIGYxNWYgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ0Ymx4XzAwZDZcIik7ICAgICAgICAvLyBnZXQgdGhlIGN1cnNvciByb3dcclxuLyogZjE2MSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImx4c3ArMF8wMGM5XCIpOyAgICAgIC8vIHNldCB0aGUgaW5wdXQgY3Vyc29yIHJvd1xyXG4vKiBmMTYzICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2U2MzJcIik7ICAgICAgICAgICAgLy8gaW5wdXQgZnJvbSBzY3JlZW4gb3Iga2V5Ym9hcmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgaW5wdXQgZGV2aWNlIHdhcyBub3QgdGhlIGtleWJvYXJkXHJcbi8qIGYxNjYgKi8gICAgICAgIF9gX2YxNjZgOyAgQ01QLmltbSAoMHgwMyk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSBkZXZpY2UgbnVtYmVyIHdpdGggc2NyZWVuXHJcbi8qIGYxNjggKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZjE3M1wiKTsgICAgICAgICAgICAvLyBpZiBub3Qgc2NyZWVuIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGlucHV0IGRldmljZSB3YXMgdGhlIHNjcmVlblxyXG4vKiBmMTZhICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiY3Jzd18wMGQwXCIpOyAgICAgICAgLy8gaW5wdXQgZnJvbSBrZXlib2FyZCBvciBzY3JlZW4sICR4eCA9IHNjcmVlbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAkMDAgPSBrZXlib2FyZFxyXG4vKiBmMTZjICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwibG5teF8wMGQ1XCIpOyAgICAgICAgLy8gZ2V0IGN1cnJlbnQgc2NyZWVuIGxpbmUgbGVuZ3RoXHJcbi8qIGYxNmUgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJpbmR4XzAwYzhcIik7ICAgICAgICAvLyBzYXZlIGlucHV0IFtFT0xdIHBvaW50ZXJcclxuLyogZjE3MCAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9lNjMyXCIpOyAgICAgICAgICAgIC8vIGlucHV0IGZyb20gc2NyZWVuIG9yIGtleWJvYXJkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGlucHV0IGRldmljZSB3YXMgbm90IHRoZSBzY3JlZW5cclxuLyogZjE3MyAqLyAgICAgICAgX2BfZjE3M2A7ICBCQ1MucmVsIChcIl9mMWFkXCIpOyAgICAgICAgICAgIC8vIGlmIGlucHV0IGRldmljZSA+IHNjcmVlbiBnbyBkbyBJRUMgZGV2aWNlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBpbnB1dCBkZXZpY2Ugd2FzIDwgc2NyZWVuXHJcbi8qIGYxNzUgKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHgwMik7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB0aGUgZGV2aWNlIHdpdGggdGhlIFJTMjMyIGRldmljZVxyXG4vKiBmMTc3ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2YxYjhcIik7ICAgICAgICAgICAgLy8gaWYgUlMyMzIgZGV2aWNlIGdvIGdldCBhIGJ5dGUgZnJvbSB0aGUgUlMyMzIgZGV2aWNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSB0aGUgdGFwZSBkZXZpY2UgbGVmdCAuLlxyXG4vKiBmMTc5ICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwieHNhdl8wMDk3XCIpOyAgICAgICAgLy8gc2F2ZSBYXHJcbi8qIGYxN2IgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZjE5OVwiKTsgICAgICAgICAgICAvLyBnZXQgYSBieXRlIGZyb20gdGFwZVxyXG4vKiBmMTdlICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2YxOTZcIik7ICAgICAgICAgICAgLy8gaWYgZXJyb3IganVzdCBleGl0XHJcbi8qIGYxODAgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSB0aGUgYnl0ZVxyXG4vKiBmMTgxICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2YxOTlcIik7ICAgICAgICAgICAgLy8gZ2V0IHRoZSBuZXh0IGJ5dGUgZnJvbSB0YXBlXHJcbi8qIGYxODQgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfZjE5M1wiKTsgICAgICAgICAgICAvLyBpZiBlcnJvciBqdXN0IGV4aXRcclxuLyogZjE4NiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mMThkXCIpOyAgICAgICAgICAgIC8vIGlmIGVuZCByZWFjaGVkID8/XHJcbi8qIGYxODggKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHg0MCk7ICAgICAgICAgICAgICAgLy8gc2V0IEVPSVxyXG4vKiBmMThhICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2ZlMWNcIik7ICAgICAgICAgICAgLy8gT1IgaW50byB0aGUgc2VyaWFsIHN0YXR1cyBieXRlXHJcbi8qIGYxOGQgKi8gICAgICAgIF9gX2YxOGRgOyAgREVDLnpwZyAoXCJidWZwbnRfMDBhNlwiKTsgICAgICAvLyBkZWNyZW1lbnQgdGFwZSBidWZmZXIgaW5kZXhcclxuLyogZjE4ZiAqLyAgICAgICAgICAgICAgICAgICBMRFguenBnIChcInhzYXZfMDA5N1wiKTsgICAgICAgIC8vIHJlc3RvcmUgWFxyXG4vKiBmMTkxICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgdGhlIHNhdmVkIGJ5dGVcclxuLyogZjE5MiAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG4vKiBmMTkzICovICAgICAgICBfYF9mMTkzYDsgIFRBWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgdGhlIGVycm9yIGJ5dGVcclxuLyogZjE5NCAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBkdW1wIHRoZSBzYXZlZCBieXRlXHJcbi8qIGYxOTUgKi8gICAgICAgICAgICAgICAgICAgVFhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBlcnJvciBieXRlXHJcbi8qIGYxOTYgKi8gICAgICAgIF9gX2YxOTZgOyAgTERYLnpwZyAoXCJ4c2F2XzAwOTdcIik7ICAgICAgICAvLyByZXN0b3JlIFhcclxuLyogZjE5OCAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBnZXQgYnl0ZSBmcm9tIHRhcGVcclxuLyogZjE5OSAqLyAgICAgICAgX2BfZjE5OWA7ICBKU1IuYWJzIChcIl9mODBkXCIpOyAgICAgICAgICAgIC8vIGJ1bXAgdGFwZSBwb2ludGVyXHJcbi8qIGYxOWMgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZjFhOVwiKTsgICAgICAgICAgICAvLyBpZiBub3QgZW5kIGdldCBuZXh0IGJ5dGUgYW5kIGV4aXRcclxuLyogZjE5ZSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mODQxXCIpOyAgICAgICAgICAgIC8vIGluaXRpYXRlIHRhcGUgcmVhZFxyXG4vKiBmMWExICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2YxYjRcIik7ICAgICAgICAgICAgLy8gZXhpdCBpZiBlcnJvciBmbGFnZ2VkXHJcbi8qIGYxYTMgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgQVxyXG4vKiBmMWE1ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiYnVmcG50XzAwYTZcIik7ICAgICAgLy8gY2xlYXIgdGFwZSBidWZmZXIgaW5kZXhcclxuLyogZjFhNyAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mMTk5XCIpOyAgICAgICAgICAgIC8vIGxvb3AsIGJyYW5jaCBhbHdheXNcclxuLyogZjFhOSAqLyAgICAgICAgX2BfZjFhOWA7ICBMREEuaW55IChcInRhcGUxKzBfMDBiMlwiKTsgICAgIC8vIGdldCBuZXh0IGJ5dGUgZnJvbSBidWZmZXJcclxuLyogZjFhYiAqLyAgICAgICAgICAgICAgICAgICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBmbGFnIG5vIGVycm9yXHJcbi8qIGYxYWMgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnB1dCBkZXZpY2Ugd2FzIHNlcmlhbCBidXNcclxuLyogZjFhZCAqLyAgICAgICAgX2BfZjFhZGA7ICBMREEuenBnIChcInN0YXR1c18wMDkwXCIpOyAgICAgIC8vIGdldCB0aGUgc2VyaWFsIHN0YXR1cyBieXRlXHJcbi8qIGYxYWYgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZjFiNVwiKTsgICAgICAgICAgICAvLyBpZiBubyBlcnJvcnMgZmxhZ2dlZCBnbyBpbnB1dCBieXRlIGFuZCByZXR1cm5cclxuLyogZjFiMSAqLyAgICAgICAgX2BfZjFiMWA7ICBMREEuaW1tICgweDBkKTsgICAgICAgICAgICAgICAvLyBlbHNlIHJldHVybiBbRU9MXVxyXG4vKiBmMWIzICovICAgICAgICBfYF9mMWIzYDsgIENMQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGZsYWcgbm8gZXJyb3JcclxuLyogZjFiNCAqLyAgICAgICAgX2BfZjFiNGA7ICBSVFMuaW1wICgpO1xyXG4vKiBmMWI1ICovICAgICAgICBfYF9mMWI1YDsgIEpNUC5hYnMgKFwiYWNwdHJfZWUxM1wiKTsgICAgICAgLy8gaW5wdXQgYnl0ZSBmcm9tIHNlcmlhbCBidXMgYW5kIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlucHV0IGRldmljZSB3YXMgUlMyMzIgZGV2aWNlXHJcbi8qIGYxYjggKi8gICAgICAgIF9gX2YxYjhgOyAgSlNSLmFicyAoXCJfZjE0ZVwiKTsgICAgICAgICAgICAvLyBnZXQgYnl0ZSBmcm9tIFJTMjMyIGRldmljZVxyXG4vKiBmMWJiICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2YxYjRcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIGVycm9yLCB0aGlzIGRvZXNuJ3QgZ2V0IHRha2VuIGFzIHRoZSBsYXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zdHJ1Y3Rpb24gaW4gdGhlIGdldCBieXRlIGZyb20gUlMyMzIgZGV2aWNlIHJvdXRpbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBDTEMgPz9cclxuLyogZjFiZCAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggbnVsbFxyXG4vKiBmMWJmICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2YxYjNcIik7ICAgICAgICAgICAgLy8gZXhpdCBpZiBub3QgbnVsbFxyXG4vKiBmMWMxICovICAgICAgICAgICAgICAgICAgIExEQS5hYnMgKFwicnNzdGF0XzAyOTdcIik7ICAgICAgLy8gZ2V0IHRoZSBSUzIzMiBzdGF0dXMgcmVnaXN0ZXJcclxuLyogZjFjNCAqLyAgICAgICAgICAgICAgICAgICBBTkQuaW1tICgweDYwKTsgICAgICAgICAgICAgICAvLyBtYXNrIDB4eDAgMDAwMCwgRFNSIGRldGVjdGVkIGFuZCA/P1xyXG4vKiBmMWM2ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2YxYjFcIik7ICAgICAgICAgICAgLy8gaWYgPz8gcmV0dXJuIG51bGxcclxuLyogZjFjOCAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mMWI4XCIpOyAgICAgICAgICAgIC8vIGVsc2UgbG9vcCwgYnJhbmNoIGFsd2F5c1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBvdXRwdXQgY2hhcmFjdGVyIHRvIGNoYW5uZWxcclxuLyogZjFjYSAqLyAgX2BjaHJvdXRfZjFjYWA7ICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzYXZlIHRoZSBjaGFyYWN0ZXIgdG8gb3V0cHV0XHJcbi8qIGYxY2IgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJkZmx0b18wMDlhXCIpOyAgICAgICAvLyBnZXQgdGhlIG91dHB1dCBkZXZpY2UgbnVtYmVyXHJcbi8qIGYxY2QgKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHgwMyk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB0aGUgb3V0cHV0IGRldmljZSB3aXRoIHRoZSBzY3JlZW5cclxuLyogZjFjZiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mMWQ1XCIpOyAgICAgICAgICAgIC8vIGlmIG5vdCB0aGUgc2NyZWVuIGdvID8/XHJcbi8qIGYxZDEgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZWxzZSByZXN0b3JlIHRoZSBvdXRwdXQgY2hhcmFjdGVyXHJcbi8qIGYxZDIgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZTcxNlwiKTsgICAgICAgICAgICAvLyBnbyBvdXRwdXQgdGhlIGNoYXJhY3RlciB0byB0aGUgc2NyZWVuXHJcbi8qIGYxZDUgKi8gICAgICAgIF9gX2YxZDVgOyAgQkNDLnJlbCAoXCJfZjFkYlwiKTsgICAgICAgICAgICAvLyBpZiA8IHNjcmVlbiBnbyA/P1xyXG4vKiBmMWQ3ICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgcmVzdG9yZSB0aGUgb3V0cHV0IGNoYXJhY3RlclxyXG4vKiBmMWQ4ICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiY2lvdXRfZWRkZFwiKTsgICAgICAgLy8gZ28gb3V0cHV0IHRoZSBjaGFyYWN0ZXIgdG8gdGhlIHNlcmlhbCBidXNcclxuLyogZjFkYiAqLyAgICAgICAgX2BfZjFkYmA7ICBMU1IuYWNjICgpOyAgICAgICAgICAgICAgICAgICAvLyBzaGlmdCBiMCBvZiB0aGUgZGV2aWNlIGludG8gQ2JcclxuLyogZjFkYyAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIHRoZSBvdXRwdXQgY2hhcmFjdGVyXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIG91dHB1dCB0aGUgY2hhcmFjdGVyIHRvIHRoZSBjYXNzZXR0ZSBvciBSUzIzMiBkZXZpY2VcclxuLyogZjFkZCAqLyAgICAgICAgX2BfZjFkZGA7ICBTVEEuenBnIChcInB0cjFfMDA5ZVwiKTsgICAgICAgIC8vIHNhdmUgdGhlIGNoYXJhY3RlciB0byB0aGUgY2hhcmFjdGVyIGJ1ZmZlclxyXG4vKiBmMWRmICovICAgICAgICAgICAgICAgICAgIFRYQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgWFxyXG4vKiBmMWUwICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgWFxyXG4vKiBmMWUxICovICAgICAgICAgICAgICAgICAgIFRZQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgWVxyXG4vKiBmMWUyICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgWVxyXG4vKiBmMWUzICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2YyMDhcIik7ICAgICAgICAgICAgLy8gaWYgQ2IgaXMgY2xlYXIgaXQgbXVzdCBiZSB0aGUgUlMyMzIgZGV2aWNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3V0cHV0IHRoZSBjaGFyYWN0ZXIgdG8gdGhlIGNhc3NldHRlXHJcbi8qIGYxZTUgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZjgwZFwiKTsgICAgICAgICAgICAvLyBidW1wIHRoZSB0YXBlIHBvaW50ZXJcclxuLyogZjFlOCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mMWY4XCIpOyAgICAgICAgICAgIC8vIGlmIG5vdCBlbmQgc2F2ZSBuZXh0IGJ5dGUgYW5kIGV4aXRcclxuLyogZjFlYSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mODY0XCIpOyAgICAgICAgICAgIC8vIGluaXRpYXRlIHRhcGUgd3JpdGVcclxuLyogZjFlZCAqLyAgICAgICAgICAgICAgICAgICBCQ1MucmVsIChcIl9mMWZkXCIpOyAgICAgICAgICAgIC8vIGV4aXQgaWYgZXJyb3JcclxuLyogZjFlZiAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDAyKTsgICAgICAgICAgICAgICAvLyBzZXQgZGF0YSBibG9jayB0eXBlID8/XHJcbi8qIGYxZjEgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgaW5kZXhcclxuLyogZjFmMyAqLyAgICAgICAgICAgICAgICAgICBTVEEuaW55IChcInRhcGUxKzBfMDBiMlwiKTsgICAgIC8vIHNhdmUgdHlwZSB0byBidWZmZXIgPz9cclxuLyogZjFmNSAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgaW5kZXhcclxuLyogZjFmNiAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcImJ1ZnBudF8wMGE2XCIpOyAgICAgIC8vIHNhdmUgdGFwZSBidWZmZXIgaW5kZXhcclxuLyogZjFmOCAqLyAgICAgICAgX2BfZjFmOGA7ICBMREEuenBnIChcInB0cjFfMDA5ZVwiKTsgICAgICAgIC8vIHJlc3RvcmUgY2hhcmFjdGVyIGZyb20gY2hhcmFjdGVyIGJ1ZmZlclxyXG4vKiBmMWZhICovICAgICAgICAgICAgICAgICAgIFNUQS5pbnkgKFwidGFwZTErMF8wMGIyXCIpOyAgICAgLy8gc2F2ZSB0byBidWZmZXJcclxuLyogZjFmYyAqLyAgICAgICAgX2BfZjFmY2A7ICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBmbGFnIG5vIGVycm9yXHJcbi8qIGYxZmQgKi8gICAgICAgIF9gX2YxZmRgOyAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVsbCBZXHJcbi8qIGYxZmUgKi8gICAgICAgICAgICAgICAgICAgVEFZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBZXHJcbi8qIGYxZmYgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVsbCBYXHJcbi8qIGYyMDAgKi8gICAgICAgICAgICAgICAgICAgVEFYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBYXHJcbi8qIGYyMDEgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJwdHIxXzAwOWVcIik7ICAgICAgICAvLyBnZXQgdGhlIGNoYXJhY3RlciBmcm9tIHRoZSBjaGFyYWN0ZXIgYnVmZmVyXHJcbi8qIGYyMDMgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfZjIwN1wiKTsgICAgICAgICAgICAvLyBleGl0IGlmIG5vIGVycm9yXHJcbi8qIGYyMDUgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gZWxzZSBjbGVhciBBXHJcbi8qIGYyMDcgKi8gICAgICAgIF9gX2YyMDdgOyAgUlRTLmltcCAoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvdXRwdXQgdGhlIGNoYXJhY3RlciB0byB0aGUgUlMyMzIgZGV2aWNlXHJcbi8qIGYyMDggKi8gICAgICAgIF9gX2YyMDhgOyAgSlNSLmFicyAoXCJfZjAxN1wiKTsgICAgICAgICAgICAvLyBzZW5kIGJ5dGUgdG8gdGhlIFJTMjMyIGJ1ZmZlciwgbm8gc2V0dXBcclxuLyogZjIwYiAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9mMWZjXCIpOyAgICAgICAgICAgIC8vIGRvIG5vIGVycm9yIGV4aXRcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gb3BlbiBjaGFubmVsIGZvciBpbnB1dFxyXG4vKiBmMjBlICovICAgX2BjaGtpbl9mMjBlYDsgIEpTUi5hYnMgKFwiX2YzMGZcIik7ICAgICAgICAgICAgLy8gZmluZCBhIGZpbGVcclxuLyogZjIxMSAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mMjE2XCIpOyAgICAgICAgICAgIC8vIGlmIHRoZSBmaWxlIGlzIG9wZW4gY29udGludWVcclxuLyogZjIxMyAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9mNzAxXCIpOyAgICAgICAgICAgIC8vIGVsc2UgZG8gJ2ZpbGUgbm90IG9wZW4nIGVycm9yIGFuZCByZXR1cm5cclxuLyogZjIxNiAqLyAgICAgICAgX2BfZjIxNmA7ICBKU1IuYWJzIChcIl9mMzFmXCIpOyAgICAgICAgICAgIC8vIHNldCBmaWxlIGRldGFpbHMgZnJvbSB0YWJsZSxYXHJcbi8qIGYyMTkgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJmYV8wMGJhXCIpOyAgICAgICAgICAvLyBnZXQgdGhlIGRldmljZSBudW1iZXJcclxuLyogZjIxYiAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mMjMzXCIpOyAgICAgICAgICAgIC8vIGlmIHRoZSBkZXZpY2Ugd2FzIHRoZSBrZXlib2FyZCBzYXZlIHRoZSBkZXZpY2UgIywgZmxhZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9rIGFuZCBleGl0XHJcbi8qIGYyMWQgKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHgwMyk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB0aGUgZGV2aWNlIG51bWJlciB3aXRoIHRoZSBzY3JlZW5cclxuLyogZjIxZiAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mMjMzXCIpOyAgICAgICAgICAgIC8vIGlmIHRoZSBkZXZpY2Ugd2FzIHRoZSBzY3JlZW4gc2F2ZSB0aGUgZGV2aWNlICMsIGZsYWcgb2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgZXhpdFxyXG4vKiBmMjIxICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2YyMzdcIik7ICAgICAgICAgICAgLy8gaWYgdGhlIGRldmljZSB3YXMgYSBzZXJpYWwgYnVzIGRldmljZSBnbyA/P1xyXG4vKiBmMjIzICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4MDIpOyAgICAgICAgICAgICAgIC8vIGVsc2UgY29tcGFyZSB0aGUgZGV2aWNlIHdpdGggdGhlIFJTMjMyIGRldmljZVxyXG4vKiBmMjI1ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2YyMmFcIik7ICAgICAgICAgICAgLy8gaWYgbm90IHRoZSBSUzIzMiBkZXZpY2UgY29udGludWVcclxuLyogZjIyNyAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9mMDRkXCIpOyAgICAgICAgICAgIC8vIGVsc2UgZ28gZ2V0IGlucHV0IGZyb20gdGhlIFJTMjMyIGJ1ZmZlciBhbmQgcmV0dXJuXHJcbi8qIGYyMmEgKi8gICAgICAgIF9gX2YyMmFgOyAgTERYLnpwZyAoXCJzYV8wMGI5XCIpOyAgICAgICAgICAvLyBnZXQgdGhlIHNlY29uZGFyeSBhZGRyZXNzXHJcbi8qIGYyMmMgKi8gICAgICAgICAgICAgICAgICAgQ1BYLmltbSAoMHg2MCk7XHJcbi8qIGYyMmUgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZjIzM1wiKTtcclxuLyogZjIzMCAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9mNzBhXCIpOyAgICAgICAgICAgIC8vIGdvIGRvICdub3QgaW5wdXQgZmlsZScgZXJyb3IgYW5kIHJldHVyblxyXG4vKiBmMjMzICovICAgICAgICBfYF9mMjMzYDsgIFNUQS56cGcgKFwiZGZsdG5fMDA5OVwiKTsgICAgICAgLy8gc2F2ZSB0aGUgaW5wdXQgZGV2aWNlIG51bWJlclxyXG4vKiBmMjM1ICovICAgICAgICAgICAgICAgICAgIENMQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGZsYWcgb2tcclxuLyogZjIzNiAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBkZXZpY2Ugd2FzIGEgc2VyaWFsIGJ1cyBkZXZpY2VcclxuLyogZjIzNyAqLyAgICAgICAgX2BfZjIzN2A7ICBUQVguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IGRldmljZSBudW1iZXIgdG8gWFxyXG4vKiBmMjM4ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwidGFsa19lZDA5XCIpOyAgICAgICAgLy8gY29tbWFuZCBzZXJpYWwgYnVzIGRldmljZSB0byBUQUxLXHJcbi8qIGYyM2IgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJzYV8wMGI5XCIpOyAgICAgICAgICAvLyBnZXQgdGhlIHNlY29uZGFyeSBhZGRyZXNzXHJcbi8qIGYyM2QgKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfZjI0NVwiKTtcclxuLyogZjIzZiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9lZGNjXCIpOyAgICAgICAgICAgIC8vIHdhaXQgZm9yIHRoZSBzZXJpYWwgYnVzIGVuZCBhZnRlciBzZW5kXHJcbi8qIGYyNDIgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZjI0OFwiKTtcclxuLyogZjI0NSAqLyAgICAgICAgX2BfZjI0NWA7ICBKU1IuYWJzIChcInRrc2FfZWRjN1wiKTsgICAgICAgIC8vIHNlbmQgc2Vjb25kYXJ5IGFkZHJlc3MgYWZ0ZXIgVEFMS1xyXG4vKiBmMjQ4ICovICAgICAgICBfYF9mMjQ4YDsgIFRYQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgZGV2aWNlIGJhY2sgdG8gQVxyXG4vKiBmMjQ5ICovICAgICAgICAgICAgICAgICAgIEJJVC56cGcgKFwic3RhdHVzXzAwOTBcIik7ICAgICAgLy8gdGVzdCB0aGUgc2VyaWFsIHN0YXR1cyBieXRlXHJcbi8qIGYyNGIgKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfZjIzM1wiKTsgICAgICAgICAgICAvLyBpZiBkZXZpY2UgcHJlc2VudCBzYXZlIGRldmljZSBudW1iZXIgYW5kIGV4aXRcclxuLyogZjI0ZCAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9mNzA3XCIpOyAgICAgICAgICAgIC8vIGRvICdkZXZpY2Ugbm90IHByZXNlbnQnIGVycm9yIGFuZCByZXR1cm5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gb3BlbiBjaGFubmVsIGZvciBvdXRwdXRcclxuLyogZjI1MCAqLyAgX2BjaGtvdXRfZjI1MGA7ICBKU1IuYWJzIChcIl9mMzBmXCIpOyAgICAgICAgICAgIC8vIGZpbmQgYSBmaWxlXHJcbi8qIGYyNTMgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZjI1OFwiKTsgICAgICAgICAgICAvLyBpZiBmaWxlIGZvdW5kIGNvbnRpbnVlXHJcbi8qIGYyNTUgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZjcwMVwiKTsgICAgICAgICAgICAvLyBlbHNlIGRvICdmaWxlIG5vdCBvcGVuJyBlcnJvciBhbmQgcmV0dXJuXHJcbi8qIGYyNTggKi8gICAgICAgIF9gX2YyNThgOyAgSlNSLmFicyAoXCJfZjMxZlwiKTsgICAgICAgICAgICAvLyBzZXQgZmlsZSBkZXRhaWxzIGZyb20gdGFibGUsWFxyXG4vKiBmMjViICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZmFfMDBiYVwiKTsgICAgICAgICAgLy8gZ2V0IHRoZSBkZXZpY2UgbnVtYmVyXHJcbi8qIGYyNWQgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZjI2MlwiKTsgICAgICAgICAgICAvLyBpZiB0aGUgZGV2aWNlIGlzIG5vdCB0aGUga2V5Ym9hcmQgZ28gPz9cclxuLyogZjI1ZiAqLyAgICAgICAgX2BfZjI1ZmA7ICBKTVAuYWJzIChcIl9mNzBkXCIpOyAgICAgICAgICAgIC8vIGdvIGRvICdub3Qgb3V0cHV0IGZpbGUnIGVycm9yIGFuZCByZXR1cm5cclxuLyogZjI2MiAqLyAgICAgICAgX2BfZjI2MmA7ICBDTVAuaW1tICgweDAzKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHRoZSBkZXZpY2Ugd2l0aCB0aGUgc2NyZWVuXHJcbi8qIGYyNjQgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZjI3NVwiKTsgICAgICAgICAgICAvLyBpZiB0aGUgZGV2aWNlIGlzIHRoZSBzY3JlZW4gZ28gc2F2ZSBvdXRwdXQgdGhlIG91dHB1dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRldmljZSBudW1iZXIgYW5kIGV4aXRcclxuLyogZjI2NiAqLyAgICAgICAgICAgICAgICAgICBCQ1MucmVsIChcIl9mMjc5XCIpOyAgICAgICAgICAgIC8vIGlmID4gc2NyZWVuIHRoZW4gZ28gaGFuZGxlIGEgc2VyaWFsIGJ1cyBkZXZpY2VcclxuLyogZjI2OCAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW1tICgweDAyKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHRoZSBkZXZpY2Ugd2l0aCB0aGUgUlMyMzIgZGV2aWNlXHJcbi8qIGYyNmEgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZjI2ZlwiKTsgICAgICAgICAgICAvLyBpZiBub3QgdGhlIFJTMjMyIGRldmljZSB0aGVuIGl0IG11c3QgYmUgdGhlIHRhcGUgZGV2aWNlXHJcbi8qIGYyNmMgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZWZlMVwiKTsgICAgICAgICAgICAvLyBlbHNlIGdvIG9wZW4gUlMyMzIgY2hhbm5lbCBmb3Igb3V0cHV0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3BlbiBhIHRhcGUgY2hhbm5lbCBmb3Igb3V0cHV0XHJcbi8qIGYyNmYgKi8gICAgICAgIF9gX2YyNmZgOyAgTERYLnpwZyAoXCJzYV8wMGI5XCIpOyAgICAgICAgICAvLyBnZXQgdGhlIHNlY29uZGFyeSBhZGRyZXNzXHJcbi8qIGYyNzEgKi8gICAgICAgICAgICAgICAgICAgQ1BYLmltbSAoMHg2MCk7XHJcbi8qIGYyNzMgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZjI1ZlwiKTsgICAgICAgICAgICAvLyBpZiA/PyBkbyBub3Qgb3V0cHV0IGZpbGUgZXJyb3IgYW5kIHJldHVyblxyXG4vKiBmMjc1ICovICAgICAgICBfYF9mMjc1YDsgIFNUQS56cGcgKFwiZGZsdG9fMDA5YVwiKTsgICAgICAgLy8gc2F2ZSB0aGUgb3V0cHV0IGRldmljZSBudW1iZXJcclxuLyogZjI3NyAqLyAgICAgICAgICAgICAgICAgICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBmbGFnIG9rXHJcbi8qIGYyNzggKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuLyogZjI3OSAqLyAgICAgICAgX2BfZjI3OWA7ICBUQVguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IHRoZSBkZXZpY2UgbnVtYmVyXHJcbi8qIGYyN2EgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJsaXN0ZW5fZWQwY1wiKTsgICAgICAvLyBjb21tYW5kIGRldmljZXMgb24gdGhlIHNlcmlhbCBidXMgdG8gTElTVEVOXHJcbi8qIGYyN2QgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJzYV8wMGI5XCIpOyAgICAgICAgICAvLyBnZXQgdGhlIHNlY29uZGFyeSBhZGRyZXNzXHJcbi8qIGYyN2YgKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfZjI4NlwiKTsgICAgICAgICAgICAvLyBpZiBhZGRyZXNzIHRvIHNlbmQgZ28gPz9cclxuLyogZjI4MSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9lZGJlXCIpOyAgICAgICAgICAgIC8vIGVsc2Ugc2V0IHNlcmlhbCBBVE4gaGlnaFxyXG4vKiBmMjg0ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2YyODlcIik7ICAgICAgICAgICAgLy8gZ28gPz8sIGJyYW5jaCBhbHdheXNcclxuLyogZjI4NiAqLyAgICAgICAgX2BfZjI4NmA7ICBKU1IuYWJzIChcInNlY29uZF9lZGI5XCIpOyAgICAgIC8vIHNlbmQgc2Vjb25kYXJ5IGFkZHJlc3MgYWZ0ZXIgTElTVEVOXHJcbi8qIGYyODkgKi8gICAgICAgIF9gX2YyODlgOyAgVFhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBkZXZpY2UgbnVtYmVyIGJhY2sgdG8gQVxyXG4vKiBmMjhhICovICAgICAgICAgICAgICAgICAgIEJJVC56cGcgKFwic3RhdHVzXzAwOTBcIik7ICAgICAgLy8gdGVzdCB0aGUgc2VyaWFsIHN0YXR1cyBieXRlXHJcbi8qIGYyOGMgKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfZjI3NVwiKTsgICAgICAgICAgICAvLyBpZiB0aGUgZGV2aWNlIGlzIHByZXNlbnQgZ28gc2F2ZSB0aGUgb3V0cHV0IGRldmljZSBudW1iZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgZXhpdFxyXG4vKiBmMjhlICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2Y3MDdcIik7ICAgICAgICAgICAgLy8gZWxzZSBkbyAnZGV2aWNlIG5vdCBwcmVzZW50IGVycm9yJyBhbmQgcmV0dXJuXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGNsb3NlIGEgc3BlY2lmaWVkIGxvZ2ljYWwgZmlsZVxyXG4vKiBmMjkxICovICAgX2BjbG9zZV9mMjkxYDsgIEpTUi5hYnMgKFwiX2YzMTRcIik7ICAgICAgICAgICAgLy8gZmluZCBmaWxlIEFcclxuLyogZjI5NCAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mMjk4XCIpOyAgICAgICAgICAgIC8vIGlmIGZpbGUgZm91bmQgZ28gY2xvc2UgaXRcclxuLyogZjI5NiAqLyAgICAgICAgICAgICAgICAgICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBlbHNlIHRoZSBmaWxlIHdhcyBjbG9zZWQgc28ganVzdCBmbGFnIG9rXHJcbi8qIGYyOTcgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaWxlIGZvdW5kIHNvIGNsb3NlIGl0XHJcbi8qIGYyOTggKi8gICAgICAgIF9gX2YyOThgOyAgSlNSLmFicyAoXCJfZjMxZlwiKTsgICAgICAgICAgICAvLyBzZXQgZmlsZSBkZXRhaWxzIGZyb20gdGFibGUsWFxyXG4vKiBmMjliICovICAgICAgICAgICAgICAgICAgIFRYQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgZmlsZSBpbmRleCB0byBBXHJcbi8qIGYyOWMgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBmaWxlIGluZGV4XHJcbi8qIGYyOWQgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJmYV8wMGJhXCIpOyAgICAgICAgICAvLyBnZXQgdGhlIGRldmljZSBudW1iZXJcclxuLyogZjI5ZiAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mMmYxXCIpOyAgICAgICAgICAgIC8vIGlmIGl0IGlzIHRoZSBrZXlib2FyZCBnbyByZXN0b3JlIHRoZSBpbmRleCBhbmQgY2xvc2UgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmlsZVxyXG4vKiBmMmExICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4MDMpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgdGhlIGRldmljZSBudW1iZXIgd2l0aCB0aGUgc2NyZWVuXHJcbi8qIGYyYTMgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZjJmMVwiKTsgICAgICAgICAgICAvLyBpZiBpdCBpcyB0aGUgc2NyZWVuIGdvIHJlc3RvcmUgdGhlIGluZGV4IGFuZCBjbG9zZSB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaWxlXHJcbi8qIGYyYTUgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfZjJlZVwiKTsgICAgICAgICAgICAvLyBpZiA+IHNjcmVlbiBnbyBkbyBzZXJpYWwgYnVzIGRldmljZSBjbG9zZVxyXG4vKiBmMmE3ICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4MDIpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgdGhlIGRldmljZSB3aXRoIHRoZSBSUzIzMiBkZXZpY2VcclxuLyogZjJhOSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mMmM4XCIpOyAgICAgICAgICAgIC8vIGlmIG5vdCB0aGUgUlMyMzIgZGV2aWNlIGdvID8/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBjbG9zZSBSUzIzMiBkZXZpY2VcclxuLyogZjJhYiAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIGZpbGUgaW5kZXhcclxuLyogZjJhYyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mMmYyXCIpOyAgICAgICAgICAgIC8vIGNsb3NlIGZpbGUgaW5kZXggWFxyXG4vKiBmMmFmICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2Y0ODNcIik7ICAgICAgICAgICAgLy8gaW5pdGlhbGlzZSBSUzIzMiBvdXRwdXRcclxuLyogZjJiMiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mZTI3XCIpOyAgICAgICAgICAgIC8vIHJlYWQgdGhlIHRvcCBvZiBtZW1vcnlcclxuLyogZjJiNSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInJpYnVmKzFfMDBmOFwiKTsgICAgIC8vIGdldCB0aGUgUlMyMzIgaW5wdXQgYnVmZmVyIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGYyYjcgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZjJiYVwiKTsgICAgICAgICAgICAvLyBpZiBubyBSUzIzMiBpbnB1dCBidWZmZXIgZ28gPz9cclxuLyogZjJiOSAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBlbHNlIHJlY2xhaW0gUlMyMzIgaW5wdXQgYnVmZmVyIG1lbW9yeVxyXG4vKiBmMmJhICovICAgICAgICBfYF9mMmJhYDsgIExEQS56cGcgKFwicm9idWYrMV8wMGZhXCIpOyAgICAgLy8gZ2V0IHRoZSBSUzIzMiBvdXRwdXQgYnVmZmVyIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGYyYmMgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZjJiZlwiKTsgICAgICAgICAgICAvLyBpZiBubyBSUzIzMiBvdXRwdXQgYnVmZmVyIHNraXAgdGhlIHJlY2xhaW1cclxuLyogZjJiZSAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBlbHNlIHJlY2xhaW0gdGhlIFJTMjMyIG91dHB1dCBidWZmZXIgbWVtb3J5XHJcbi8qIGYyYmYgKi8gICAgICAgIF9gX2YyYmZgOyAgTERBLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgQVxyXG4vKiBmMmMxICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwicmlidWYrMV8wMGY4XCIpOyAgICAgLy8gY2xlYXIgdGhlIFJTMjMyIGlucHV0IGJ1ZmZlciBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBmMmMzICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwicm9idWYrMV8wMGZhXCIpOyAgICAgLy8gY2xlYXIgdGhlIFJTMjMyIG91dHB1dCBidWZmZXIgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogZjJjNSAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9mNDdkXCIpOyAgICAgICAgICAgIC8vIGdvIHNldCB0aGUgdG9wIG9mIG1lbW9yeSB0byBGMHh4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgbm90IHRoZSBSUzIzMiBkZXZpY2VcclxuLyogZjJjOCAqLyAgICAgICAgX2BfZjJjOGA7ICBMREEuenBnIChcInNhXzAwYjlcIik7ICAgICAgICAgIC8vIGdldCB0aGUgc2Vjb25kYXJ5IGFkZHJlc3NcclxuLyogZjJjYSAqLyAgICAgICAgICAgICAgICAgICBBTkQuaW1tICgweDBmKTsgICAgICAgICAgICAgICAvLyBtYXNrIHRoZSBkZXZpY2UgI1xyXG4vKiBmMmNjICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2YyZjFcIik7ICAgICAgICAgICAgLy8gaWYgPz8gcmVzdG9yZSBpbmRleCBhbmQgY2xvc2UgZmlsZVxyXG4vKiBmMmNlICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2Y3ZDBcIik7ICAgICAgICAgICAgLy8gZ2V0IHRhcGUgYnVmZmVyIHN0YXJ0IHBvaW50ZXIgaW4gWFlcclxuLyogZjJkMSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIgJDAwXHJcbi8qIGYyZDMgKi8gICAgICAgICAgICAgICAgICAgU0VDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZmxhZyB0aGUgdGFwZSBkZXZpY2VcclxuLyogZjJkNCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mMWRkXCIpOyAgICAgICAgICAgIC8vIG91dHB1dCB0aGUgY2hhcmFjdGVyIHRvIHRoZSBjYXNzZXR0ZSBvciBSUzIzMiBkZXZpY2VcclxuLyogZjJkNyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mODY0XCIpOyAgICAgICAgICAgIC8vIGluaXRpYXRlIHRhcGUgd3JpdGVcclxuLyogZjJkYSAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9mMmUwXCIpO1xyXG4vKiBmMmRjICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7XHJcbi8qIGYyZGQgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMCk7XHJcbi8qIGYyZGYgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuLyogZjJlMCAqLyAgICAgICAgX2BfZjJlMGA7ICBMREEuenBnIChcInNhXzAwYjlcIik7ICAgICAgICAgIC8vIGdldCB0aGUgc2Vjb25kYXJ5IGFkZHJlc3NcclxuLyogZjJlMiAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW1tICgweDYyKTtcclxuLyogZjJlNCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mMmYxXCIpOyAgICAgICAgICAgIC8vIGlmIG5vdCA/PyByZXN0b3JlIGluZGV4IGFuZCBjbG9zZSBmaWxlXHJcbi8qIGYyZTYgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwNSk7ICAgICAgICAgICAgICAgLy8gc2V0IGxvZ2ljYWwgZW5kIG9mIHRoZSB0YXBlXHJcbi8qIGYyZTggKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZjc2YVwiKTsgICAgICAgICAgICAvLyB3cml0ZSB0YXBlIGhlYWRlclxyXG4vKiBmMmViICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2YyZjFcIik7ICAgICAgICAgICAgLy8gcmVzdG9yZSBpbmRleCBhbmQgY2xvc2UgZmlsZVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzZXJpYWwgYnVzIGRldmljZSBjbG9zZVxyXG4vKiBmMmVlICovICAgICAgICBfYF9mMmVlYDsgIEpTUi5hYnMgKFwiX2Y2NDJcIik7ICAgICAgICAgICAgLy8gY2xvc2Ugc2VyaWFsIGJ1cyBkZXZpY2VcclxuLyogZjJmMSAqLyAgICAgICAgX2BfZjJmMWA7ICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIGZpbGUgaW5kZXhcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY2xvc2UgZmlsZSBpbmRleCBYXHJcbi8qIGYyZjIgKi8gICAgICAgIF9gX2YyZjJgOyAgVEFYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBpbmRleCB0byBmaWxlIHRvIGNsb3NlXHJcbi8qIGYyZjMgKi8gICAgICAgICAgICAgICAgICAgREVDLnpwZyAoXCJsZHRuZF8wMDk4XCIpOyAgICAgICAvLyBkZWNyZW1lbnQgdGhlIG9wZW4gZmlsZSBjb3VudFxyXG4vKiBmMmY1ICovICAgICAgICAgICAgICAgICAgIENQWC56cGcgKFwibGR0bmRfMDA5OFwiKTsgICAgICAgLy8gY29tcGFyZSB0aGUgaW5kZXggd2l0aCB0aGUgb3BlbiBmaWxlIGNvdW50XHJcbi8qIGYyZjcgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZjMwZFwiKTsgICAgICAgICAgICAvLyBleGl0IGlmIGVxdWFsLCBsYXN0IGVudHJ5IHdhcyBjbG9zaW5nIGZpbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIGVudHJ5IHdhcyBub3QgbGFzdCBpbiBsaXN0IHNvIGNvcHkgbGFzdCB0YWJsZSBlbnRyeVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpbGUgZGV0YWlscyBvdmVyIHRoZSBkZXRhaWxzIG9mIHRoZSBjbG9zaW5nIG9uZVxyXG4vKiBmMmY5ICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwibGR0bmRfMDA5OFwiKTsgICAgICAgLy8gZ2V0IHRoZSBvcGVuIGZpbGUgY291bnQgYXMgaW5kZXhcclxuLyogZjJmYiAqLyAgICAgICAgICAgICAgICAgICBMREEuYWJ5IChcImxhdCswXzAyNTlcIik7ICAgICAgIC8vIGdldCBsYXN0KzEgbG9naWNhbCBmaWxlIG51bWJlciBmcm9tIGxvZ2ljYWwgZmlsZSB0YWJsZVxyXG4vKiBmMmZlICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnggKFwibGF0KzBfMDI1OVwiKTsgICAgICAgLy8gc2F2ZSBsb2dpY2FsIGZpbGUgbnVtYmVyIG92ZXIgY2xvc2VkIGZpbGVcclxuLyogZjMwMSAqLyAgICAgICAgICAgICAgICAgICBMREEuYWJ5IChcImZhdCswXzAyNjNcIik7ICAgICAgIC8vIGdldCBsYXN0KzEgZGV2aWNlIG51bWJlciBmcm9tIGRldmljZSBudW1iZXIgdGFibGVcclxuLyogZjMwNCAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJ4IChcImZhdCswXzAyNjNcIik7ICAgICAgIC8vIHNhdmUgZGV2aWNlIG51bWJlciBvdmVyIGNsb3NlZCBmaWxlXHJcbi8qIGYzMDcgKi8gICAgICAgICAgICAgICAgICAgTERBLmFieSAoXCJzYXQrMF8wMjZkXCIpOyAgICAgICAvLyBnZXQgbGFzdCsxIHNlY29uZGFyeSBhZGRyZXNzIGZyb20gc2Vjb25kYXJ5IGFkZHJlc3MgdGFibGVcclxuLyogZjMwYSAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJ4IChcInNhdCswXzAyNmRcIik7ICAgICAgIC8vIHNhdmUgc2Vjb25kYXJ5IGFkZHJlc3Mgb3ZlciBjbG9zZWQgZmlsZVxyXG4vKiBmMzBkICovICAgICAgICBfYF9mMzBkYDsgIENMQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGZsYWcgb2tcclxuLyogZjMwZSAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBmaW5kIGEgZmlsZVxyXG4vKiBmMzBmICovICAgICAgICBfYF9mMzBmYDsgIExEQS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIEFcclxuLyogZjMxMSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInN0YXR1c18wMDkwXCIpOyAgICAgIC8vIGNsZWFyIHRoZSBzZXJpYWwgc3RhdHVzIGJ5dGVcclxuLyogZjMxMyAqLyAgICAgICAgICAgICAgICAgICBUWEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IHRoZSBsb2dpY2FsIGZpbGUgbnVtYmVyIHRvIEFcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gZmluZCBmaWxlIEFcclxuLyogZjMxNCAqLyAgICAgICAgX2BfZjMxNGA7ICBMRFguenBnIChcImxkdG5kXzAwOThcIik7ICAgICAgIC8vIGdldCB0aGUgb3BlbiBmaWxlIGNvdW50XHJcbi8qIGYzMTYgKi8gICAgICAgIF9gX2YzMTZgOyAgREVYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZGVjcmVtZW1udCB0aGUgY291bnQgdG8gZ2l2ZSB0aGUgaW5kZXhcclxuLyogZjMxNyAqLyAgICAgICAgICAgICAgICAgICBCTUkucmVsIChcIl9mMzJlXCIpOyAgICAgICAgICAgIC8vIGlmIG5vIGZpbGVzIGp1c3QgZXhpdFxyXG4vKiBmMzE5ICovICAgICAgICAgICAgICAgICAgIENNUC5hYnggKFwibGF0KzBfMDI1OVwiKTsgICAgICAgLy8gY29tcGFyZSB0aGUgbG9naWNhbCBmaWxlIG51bWJlciB3aXRoIHRoZSB0YWJsZSBsb2dpY2FsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmlsZSBudW1iZXJcclxuLyogZjMxYyAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mMzE2XCIpOyAgICAgICAgICAgIC8vIGlmIG5vIG1hdGNoIGdvIHRyeSBhZ2FpblxyXG4vKiBmMzFlICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHNldCBmaWxlIGRldGFpbHMgZnJvbSB0YWJsZSxYXHJcbi8qIGYzMWYgKi8gICAgICAgIF9gX2YzMWZgOyAgTERBLmFieCAoXCJsYXQrMF8wMjU5XCIpOyAgICAgICAvLyBnZXQgbG9naWNhbCBmaWxlIGZyb20gbG9naWNhbCBmaWxlIHRhYmxlXHJcbi8qIGYzMjIgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJsYV8wMGI4XCIpOyAgICAgICAgICAvLyBzYXZlIHRoZSBsb2dpY2FsIGZpbGVcclxuLyogZjMyNCAqLyAgICAgICAgICAgICAgICAgICBMREEuYWJ4IChcImZhdCswXzAyNjNcIik7ICAgICAgIC8vIGdldCBkZXZpY2UgbnVtYmVyIGZyb20gZGV2aWNlIG51bWJlciB0YWJsZVxyXG4vKiBmMzI3ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZmFfMDBiYVwiKTsgICAgICAgICAgLy8gc2F2ZSB0aGUgZGV2aWNlIG51bWJlclxyXG4vKiBmMzI5ICovICAgICAgICAgICAgICAgICAgIExEQS5hYnggKFwic2F0KzBfMDI2ZFwiKTsgICAgICAgLy8gZ2V0IHNlY29uZGFyeSBhZGRyZXNzIGZyb20gc2Vjb25kYXJ5IGFkZHJlc3MgdGFibGVcclxuLyogZjMyYyAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInNhXzAwYjlcIik7ICAgICAgICAgIC8vIHNhdmUgdGhlIHNlY29uZGFyeSBhZGRyZXNzXHJcbi8qIGYzMmUgKi8gICAgICAgIF9gX2YzMmVgOyAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY2xvc2UgYWxsIGNoYW5uZWxzIGFuZCBmaWxlc1xyXG4vKiBmMzJmICovICAgX2BjbGFsbF9mMzJmYDsgIExEQS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIEFcclxuLyogZjMzMSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImxkdG5kXzAwOThcIik7ICAgICAgIC8vIGNsZWFyIHRoZSBvcGVuIGZpbGUgY291bnRcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY2xvc2UgaW5wdXQgYW5kIG91dHB1dCBjaGFubmVsc1xyXG4vKiBmMzMzICovICBfYGNscmNobl9mMzMzYDsgIExEWC5pbW0gKDB4MDMpOyAgICAgICAgICAgICAgIC8vIHNldCB0aGUgc2NyZWVuIGRldmljZVxyXG4vKiBmMzM1ICovICAgICAgICAgICAgICAgICAgIENQWC56cGcgKFwiZGZsdG9fMDA5YVwiKTsgICAgICAgLy8gY29tcGFyZSB0aGUgc2NyZWVuIHdpdGggdGhlIG91dHB1dCBkZXZpY2UgbnVtYmVyXHJcbi8qIGYzMzcgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfZjMzY1wiKTsgICAgICAgICAgICAvLyBpZiA8PSBzY3JlZW4gc2tpcCB0aGUgc2VyaWFsIGJ1cyB1bmxpc3RlblxyXG4vKiBmMzM5ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwidW5sc25fZWRmZVwiKTsgICAgICAgLy8gZWxzZSBjb21tYW5kIHRoZSBzZXJpYWwgYnVzIHRvIFVOTElTVEVOXHJcbi8qIGYzM2MgKi8gICAgICAgIF9gX2YzM2NgOyAgQ1BYLnpwZyAoXCJkZmx0bl8wMDk5XCIpOyAgICAgICAvLyBjb21wYXJlIHRoZSBzY3JlZW4gd2l0aCB0aGUgaW5wdXQgZGV2aWNlIG51bWJlclxyXG4vKiBmMzNlICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2YzNDNcIik7ICAgICAgICAgICAgLy8gaWYgPD0gc2NyZWVuIHNraXAgdGhlIHNlcmlhbCBidXMgdW50YWxrXHJcbi8qIGYzNDAgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJ1bnRsa19lZGVmXCIpOyAgICAgICAvLyBlbHNlIGNvbW1hbmQgdGhlIHNlcmlhbCBidXMgdG8gVU5UQUxLXHJcbi8qIGYzNDMgKi8gICAgICAgIF9gX2YzNDNgOyAgU1RYLnpwZyAoXCJkZmx0b18wMDlhXCIpOyAgICAgICAvLyBzYXZlIHRoZSBzY3JlZW4gYXMgdGhlIG91dHB1dCBkZXZpY2UgbnVtYmVyXHJcbi8qIGYzNDUgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gc2V0IHRoZSBrZXlib2FyZCBhcyB0aGUgaW5wdXQgZGV2aWNlXHJcbi8qIGYzNDcgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJkZmx0bl8wMDk5XCIpOyAgICAgICAvLyBzYXZlIHRoZSBpbnB1dCBkZXZpY2UgbnVtYmVyXHJcbi8qIGYzNDkgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gb3BlbiBhIGxvZ2ljYWwgZmlsZVxyXG4vKiBmMzRhICovICAgIF9gb3Blbl9mMzRhYDsgIExEWC56cGcgKFwibGFfMDBiOFwiKTsgICAgICAgICAgLy8gZ2V0IHRoZSBsb2dpY2FsIGZpbGVcclxuLyogZjM0YyAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mMzUxXCIpOyAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgZmlsZSBjb250aW51ZVxyXG4vKiBmMzRlICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2Y3MGFcIik7ICAgICAgICAgICAgLy8gZWxzZSBkbyAnbm90IGlucHV0IGZpbGUgZXJyb3InIGFuZCByZXR1cm5cclxuLyogZjM1MSAqLyAgICAgICAgX2BfZjM1MWA7ICBKU1IuYWJzIChcIl9mMzBmXCIpOyAgICAgICAgICAgIC8vIGZpbmQgYSBmaWxlXHJcbi8qIGYzNTQgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZjM1OVwiKTsgICAgICAgICAgICAvLyBpZiBmaWxlIG5vdCBmb3VuZCBjb250aW51ZVxyXG4vKiBmMzU2ICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2Y2ZmVcIik7ICAgICAgICAgICAgLy8gZWxzZSBkbyAnZmlsZSBhbHJlYWR5IG9wZW4nIGVycm9yIGFuZCByZXR1cm5cclxuLyogZjM1OSAqLyAgICAgICAgX2BfZjM1OWA7ICBMRFguenBnIChcImxkdG5kXzAwOThcIik7ICAgICAgIC8vIGdldCB0aGUgb3BlbiBmaWxlIGNvdW50XHJcbi8qIGYzNWIgKi8gICAgICAgICAgICAgICAgICAgQ1BYLmltbSAoMHgwYSk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSBpdCB3aXRoIHRoZSBtYXhpbXVtICsgMVxyXG4vKiBmMzVkICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2YzNjJcIik7ICAgICAgICAgICAgLy8gaWYgbGVzcyB0aGFuIG1heGltdW0gKyAxIGdvIG9wZW4gdGhlIGZpbGVcclxuLyogZjM1ZiAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9mNmZiXCIpOyAgICAgICAgICAgIC8vIGVsc2UgZG8gJ3RvbyBtYW55IGZpbGVzIGVycm9yJyBhbmQgcmV0dXJuXHJcbi8qIGYzNjIgKi8gICAgICAgIF9gX2YzNjJgOyAgSU5DLnpwZyAoXCJsZHRuZF8wMDk4XCIpOyAgICAgICAvLyBpbmNyZW1lbnQgdGhlIG9wZW4gZmlsZSBjb3VudFxyXG4vKiBmMzY0ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwibGFfMDBiOFwiKTsgICAgICAgICAgLy8gZ2V0IHRoZSBsb2dpY2FsIGZpbGVcclxuLyogZjM2NiAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJ4IChcImxhdCswXzAyNTlcIik7ICAgICAgIC8vIHNhdmUgaXQgdG8gdGhlIGxvZ2ljYWwgZmlsZSB0YWJsZVxyXG4vKiBmMzY5ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwic2FfMDBiOVwiKTsgICAgICAgICAgLy8gZ2V0IHRoZSBzZWNvbmRhcnkgYWRkcmVzc1xyXG4vKiBmMzZiICovICAgICAgICAgICAgICAgICAgIE9SQS5pbW0gKDB4NjApOyAgICAgICAgICAgICAgIC8vIE9SIHdpdGggdGhlIE9QRU4gQ0hBTk5FTCBjb21tYW5kXHJcbi8qIGYzNmQgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJzYV8wMGI5XCIpOyAgICAgICAgICAvLyBzYXZlIHRoZSBzZWNvbmRhcnkgYWRkcmVzc1xyXG4vKiBmMzZmICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnggKFwic2F0KzBfMDI2ZFwiKTsgICAgICAgLy8gc2F2ZSBpdCB0byB0aGUgc2Vjb25kYXJ5IGFkZHJlc3MgdGFibGVcclxuLyogZjM3MiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZhXzAwYmFcIik7ICAgICAgICAgIC8vIGdldCB0aGUgZGV2aWNlIG51bWJlclxyXG4vKiBmMzc0ICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnggKFwiZmF0KzBfMDI2M1wiKTsgICAgICAgLy8gc2F2ZSBpdCB0byB0aGUgZGV2aWNlIG51bWJlciB0YWJsZVxyXG4vKiBmMzc3ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2YzZDNcIik7ICAgICAgICAgICAgLy8gaWYgaXQgaXMgdGhlIGtleWJvYXJkIGdvIGRvIHRoZSBvayBleGl0XHJcbi8qIGYzNzkgKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHgwMyk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB0aGUgZGV2aWNlIG51bWJlciB3aXRoIHRoZSBzY3JlZW5cclxuLyogZjM3YiAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mM2QzXCIpOyAgICAgICAgICAgIC8vIGlmIGl0IGlzIHRoZSBzY3JlZW4gZ28gZG8gdGhlIG9rIGV4aXRcclxuLyogZjM3ZCAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9mMzg0XCIpOyAgICAgICAgICAgIC8vIGlmIHRhcGUgb3IgUlMyMzIgZGV2aWNlIGdvID8/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBpdCBpcyBhIHNlcmlhbCBidXMgZGV2aWNlXHJcbi8qIGYzN2YgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZjNkNVwiKTsgICAgICAgICAgICAvLyBzZW5kIHRoZSBzZWNvbmRhcnkgYWRkcmVzcyBhbmQgZmlsZW5hbWVcclxuLyogZjM4MiAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9mM2QzXCIpOyAgICAgICAgICAgIC8vIGdvIGRvIG9rIGV4aXQsIGJyYW5jaCBhbHdheXNcclxuLyogZjM4NCAqLyAgICAgICAgX2BfZjM4NGA7ICBDTVAuaW1tICgweDAyKTtcclxuLyogZjM4NiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mMzhiXCIpO1xyXG4vKiBmMzg4ICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2Y0MDlcIik7ICAgICAgICAgICAgLy8gZ28gb3BlbiBSUzIzMiBkZXZpY2UgYW5kIHJldHVyblxyXG4vKiBmMzhiICovICAgICAgICBfYF9mMzhiYDsgIEpTUi5hYnMgKFwiX2Y3ZDBcIik7ICAgICAgICAgICAgLy8gZ2V0IHRhcGUgYnVmZmVyIHN0YXJ0IHBvaW50ZXIgaW4gWFlcclxuLyogZjM4ZSAqLyAgICAgICAgICAgICAgICAgICBCQ1MucmVsIChcIl9mMzkzXCIpOyAgICAgICAgICAgIC8vIGlmID49ICQwMjAwIGdvID8/XHJcbi8qIGYzOTAgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZjcxM1wiKTsgICAgICAgICAgICAvLyBlbHNlIGRvICdpbGxlZ2FsIGRldmljZSBudW1iZXInIGFuZCByZXR1cm5cclxuLyogZjM5MyAqLyAgICAgICAgX2BfZjM5M2A7ICBMREEuenBnIChcInNhXzAwYjlcIik7ICAgICAgICAgIC8vIGdldCB0aGUgc2Vjb25kYXJ5IGFkZHJlc3NcclxuLyogZjM5NSAqLyAgICAgICAgICAgICAgICAgICBBTkQuaW1tICgweDBmKTtcclxuLyogZjM5NyAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mM2I4XCIpO1xyXG4vKiBmMzk5ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2Y4MTdcIik7ICAgICAgICAgICAgLy8gd2FpdCBmb3IgUExBWVxyXG4vKiBmMzljICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2YzZDRcIik7ICAgICAgICAgICAgLy8gZXhpdCBpZiBTVE9QIHdhcyBwcmVzc2VkXHJcbi8qIGYzOWUgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZjVhZlwiKTsgICAgICAgICAgICAvLyBwcmludCBcIlNlYXJjaGluZy4uLlwiXHJcbi8qIGYzYTEgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJmbmxlbl8wMGI3XCIpOyAgICAgICAvLyBnZXQgZmlsZSBuYW1lIGxlbmd0aFxyXG4vKiBmM2EzICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2YzYWZcIik7ICAgICAgICAgICAgLy8gaWYgbnVsbCBmaWxlIG5hbWUganVzdCBnbyBmaW5kIGhlYWRlclxyXG4vKiBmM2E1ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2Y3ZWFcIik7ICAgICAgICAgICAgLy8gZmluZCBzcGVjaWZpYyB0YXBlIGhlYWRlclxyXG4vKiBmM2E4ICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2YzYzJcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vIGVycm9yXHJcbi8qIGYzYWEgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZjNkNFwiKTsgICAgICAgICAgICAvLyBleGl0IGlmID8/XHJcbi8qIGYzYWMgKi8gICAgICAgIF9gX2YzYWNgOyAgSk1QLmFicyAoXCJfZjcwNFwiKTsgICAgICAgICAgICAvLyBkbyBmaWxlIG5vdCBmb3VuZCBlcnJvciBhbmQgcmV0dXJuXHJcbi8qIGYzYWYgKi8gICAgICAgIF9gX2YzYWZgOyAgSlNSLmFicyAoXCJfZjcyY1wiKTsgICAgICAgICAgICAvLyBmaW5kIHRhcGUgaGVhZGVyLCBleGl0IHdpdGggaGVhZGVyIGluIGJ1ZmZlclxyXG4vKiBmM2IyICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2YzZDRcIik7ICAgICAgICAgICAgLy8gZXhpdCBpZiBlbmQgb2YgdGFwZSBmb3VuZFxyXG4vKiBmM2I0ICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2YzYzJcIik7XHJcbi8qIGYzYjYgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfZjNhY1wiKTtcclxuLyogZjNiOCAqLyAgICAgICAgX2BfZjNiOGA7ICBKU1IuYWJzIChcIl9mODM4XCIpOyAgICAgICAgICAgIC8vIHdhaXQgZm9yIFBMQVkvUkVDT1JEXHJcbi8qIGYzYmIgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfZjNkNFwiKTsgICAgICAgICAgICAvLyBleGl0IGlmIFNUT1Agd2FzIHByZXNzZWRcclxuLyogZjNiZCAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDA0KTsgICAgICAgICAgICAgICAvLyBzZXQgZGF0YSBmaWxlIGhlYWRlclxyXG4vKiBmM2JmICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2Y3NmFcIik7ICAgICAgICAgICAgLy8gd3JpdGUgdGFwZSBoZWFkZXJcclxuLyogZjNjMiAqLyAgICAgICAgX2BfZjNjMmA7ICBMREEuaW1tICgweGJmKTtcclxuLyogZjNjNCAqLyAgICAgICAgICAgICAgICAgICBMRFkuenBnIChcInNhXzAwYjlcIik7ICAgICAgICAgIC8vIGdldCB0aGUgc2Vjb25kYXJ5IGFkZHJlc3NcclxuLyogZjNjNiAqLyAgICAgICAgICAgICAgICAgICBDUFkuaW1tICgweDYwKTtcclxuLyogZjNjOCAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mM2QxXCIpO1xyXG4vKiBmM2NhICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIGluZGV4XHJcbi8qIGYzY2MgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMik7XHJcbi8qIGYzY2UgKi8gICAgICAgICAgICAgICAgICAgU1RBLmlueSAoXCJ0YXBlMSswXzAwYjJcIik7ICAgICAvLyBzYXZlIHRvIHRhcGUgYnVmZmVyXHJcbi8qIGYzZDAgKi8gICAgICAgICAgICAgICAgICAgVFlBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgQVxyXG4vKiBmM2QxICovICAgICAgICBfYF9mM2QxYDsgIFNUQS56cGcgKFwiYnVmcG50XzAwYTZcIik7ICAgICAgLy8gc2F2ZSB0YXBlIGJ1ZmZlciBpbmRleFxyXG4vKiBmM2QzICovICAgICAgICBfYF9mM2QzYDsgIENMQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGZsYWcgb2tcclxuLyogZjNkNCAqLyAgICAgICAgX2BfZjNkNGA7ICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzZW5kIHNlY29uZGFyeSBhZGRyZXNzIGFuZCBmaWxlbmFtZVxyXG4vKiBmM2Q1ICovICAgICAgICBfYF9mM2Q1YDsgIExEQS56cGcgKFwic2FfMDBiOVwiKTsgICAgICAgICAgLy8gZ2V0IHRoZSBzZWNvbmRhcnkgYWRkcmVzc1xyXG4vKiBmM2Q3ICovICAgICAgICAgICAgICAgICAgIEJNSS5yZWwgKFwiX2YzZDNcIik7ICAgICAgICAgICAgLy8gb2sgZXhpdCBpZiAtdmVcclxuLyogZjNkOSAqLyAgICAgICAgICAgICAgICAgICBMRFkuenBnIChcImZubGVuXzAwYjdcIik7ICAgICAgIC8vIGdldCBmaWxlIG5hbWUgbGVuZ3RoXHJcbi8qIGYzZGIgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZjNkM1wiKTsgICAgICAgICAgICAvLyBvayBleGl0IGlmIG51bGxcclxuLyogZjNkZCAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBBXHJcbi8qIGYzZGYgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJzdGF0dXNfMDA5MFwiKTsgICAgICAvLyBjbGVhciB0aGUgc2VyaWFsIHN0YXR1cyBieXRlXHJcbi8qIGYzZTEgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJmYV8wMGJhXCIpOyAgICAgICAgICAvLyBnZXQgdGhlIGRldmljZSBudW1iZXJcclxuLyogZjNlMyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImxpc3Rlbl9lZDBjXCIpOyAgICAgIC8vIGNvbW1hbmQgZGV2aWNlcyBvbiB0aGUgc2VyaWFsIGJ1cyB0byBMSVNURU5cclxuLyogZjNlNiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInNhXzAwYjlcIik7ICAgICAgICAgIC8vIGdldCB0aGUgc2Vjb25kYXJ5IGFkZHJlc3NcclxuLyogZjNlOCAqLyAgICAgICAgICAgICAgICAgICBPUkEuaW1tICgweGYwKTsgICAgICAgICAgICAgICAvLyBPUiB3aXRoIHRoZSBPUEVOIGNvbW1hbmRcclxuLyogZjNlYSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcInNlY29uZF9lZGI5XCIpOyAgICAgIC8vIHNlbmQgc2Vjb25kYXJ5IGFkZHJlc3MgYWZ0ZXIgTElTVEVOXHJcbi8qIGYzZWQgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJzdGF0dXNfMDA5MFwiKTsgICAgICAvLyBnZXQgdGhlIHNlcmlhbCBzdGF0dXMgYnl0ZVxyXG4vKiBmM2VmICovICAgICAgICAgICAgICAgICAgIEJQTC5yZWwgKFwiX2YzZjZcIik7ICAgICAgICAgICAgLy8gaWYgZGV2aWNlIHByZXNlbnQgc2tpcCB0aGUgJ2RldmljZSBub3QgcHJlc2VudCcgZXJyb3JcclxuLyogZjNmMSAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBlbHNlIGR1bXAgY2FsbGluZyBhZGRyZXNzIGxvdyBieXRlXHJcbi8qIGYzZjIgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZHVtcCBjYWxsaW5nIGFkZHJlc3MgaGlnaCBieXRlXHJcbi8qIGYzZjMgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZjcwN1wiKTsgICAgICAgICAgICAvLyBkbyAnZGV2aWNlIG5vdCBwcmVzZW50JyBlcnJvciBhbmQgcmV0dXJuXHJcbi8qIGYzZjYgKi8gICAgICAgIF9gX2YzZjZgOyAgTERBLnpwZyAoXCJmbmxlbl8wMGI3XCIpOyAgICAgICAvLyBnZXQgZmlsZSBuYW1lIGxlbmd0aFxyXG4vKiBmM2Y4ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2Y0MDZcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG51bGwgbmFtZVxyXG4vKiBmM2ZhICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIGluZGV4XHJcbi8qIGYzZmMgKi8gICAgICAgIF9gX2YzZmNgOyAgTERBLmlueSAoXCJmbmFkciswXzAwYmJcIik7ICAgICAvLyBnZXQgZmlsZSBuYW1lIGJ5dGVcclxuLyogZjNmZSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImNpb3V0X2VkZGRcIik7ICAgICAgIC8vIG91dHB1dCBieXRlIHRvIHNlcmlhbCBidXNcclxuLyogZjQwMSAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgaW5kZXhcclxuLyogZjQwMiAqLyAgICAgICAgICAgICAgICAgICBDUFkuenBnIChcImZubGVuXzAwYjdcIik7ICAgICAgIC8vIGNvbXBhcmUgd2l0aCBmaWxlIG5hbWUgbGVuZ3RoXHJcbi8qIGY0MDQgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZjNmY1wiKTsgICAgICAgICAgICAvLyBsb29wIGlmIG5vdCBhbGwgZG9uZVxyXG4vKiBmNDA2ICovICAgICAgICBfYF9mNDA2YDsgIEpNUC5hYnMgKFwiX2Y2NTRcIik7ICAgICAgICAgICAgLy8gY29tbWFuZCBzZXJpYWwgYnVzIHRvIFVOTElTVEVOIGFuZCByZXR1cm5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gb3BlbiBSUzIzMiBkZXZpY2VcclxuLyogZjQwOSAqLyAgICAgICAgX2BfZjQwOWA7ICBKU1IuYWJzIChcIl9mNDgzXCIpOyAgICAgICAgICAgIC8vIGluaXRpYWxpc2UgUlMyMzIgb3V0cHV0XHJcbi8qIGY0MGMgKi8gICAgICAgICAgICAgICAgICAgU1RZLmFicyAoXCJyc3N0YXRfMDI5N1wiKTsgICAgICAvLyBzYXZlIHRoZSBSUzIzMiBzdGF0dXMgcmVnaXN0ZXJcclxuLyogZjQwZiAqLyAgICAgICAgX2BfZjQwZmA7ICBDUFkuenBnIChcImZubGVuXzAwYjdcIik7ICAgICAgIC8vIGNvbXBhcmUgd2l0aCBmaWxlIG5hbWUgbGVuZ3RoXHJcbi8qIGY0MTEgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZjQxZFwiKTsgICAgICAgICAgICAvLyBleGl0IGxvb3AgaWYgZG9uZVxyXG4vKiBmNDEzICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwiZm5hZHIrMF8wMGJiXCIpOyAgICAgLy8gZ2V0IGZpbGUgbmFtZSBieXRlXHJcbi8qIGY0MTUgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFieSAoXCJtNTFjdHJfMDI5M1wiKTsgICAgICAvLyBjb3B5IHRvIDY1NTEgcmVnaXN0ZXIgc2V0XHJcbi8qIGY0MTggKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGluZGV4XHJcbi8qIGY0MTkgKi8gICAgICAgICAgICAgICAgICAgQ1BZLmltbSAoMHgwNCk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoICQwNFxyXG4vKiBmNDFiICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2Y0MGZcIik7ICAgICAgICAgICAgLy8gbG9vcCBpZiBub3QgdG8gNCB5ZXRcclxuLyogZjQxZCAqLyAgICAgICAgX2BfZjQxZGA7ICBKU1IuYWJzIChcIl9lZjRhXCIpOyAgICAgICAgICAgIC8vIGNvbXB1dGUgYml0IGNvdW50XHJcbi8qIGY0MjAgKi8gICAgICAgICAgICAgICAgICAgU1RYLmFicyAoXCJiaXRudW1fMDI5OFwiKTsgICAgICAvLyBzYXZlIGJpdCBjb3VudFxyXG4vKiBmNDIzICovICAgICAgICAgICAgICAgICAgIExEQS5hYnMgKFwibTUxY3RyXzAyOTNcIik7ICAgICAgLy8gZ2V0IHBzZXVkbyA2NTUxIGNvbnRyb2wgcmVnaXN0ZXJcclxuLyogZjQyNiAqLyAgICAgICAgICAgICAgICAgICBBTkQuaW1tICgweDBmKTsgICAgICAgICAgICAgICAvLyBtYXNrIDAwMDAgeHh4eCwgYmF1ZCByYXRlXHJcbi8qIGY0MjggKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZjQ0NlwiKTsgICAgICAgICAgICAvLyBpZiB6ZXJvIHNraXAgdGhlIGJhdWQgcmF0ZSBzZXR1cFxyXG4vKiBmNDJhICovICAgICAgICAgICAgICAgICAgIEFTTC5hY2MgKCk7ICAgICAgICAgICAgICAgICAgIC8vICogMiBieXRlcyBwZXIgZW50cnlcclxuLyogZjQyYiAqLyAgICAgICAgICAgICAgICAgICBUQVguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IHRvIHRoZSBpbmRleFxyXG4vKiBmNDJjICovICAgICAgICAgICAgICAgICAgIExEQS5hYnMgKFwidHZzZmxnXzAyYTZcIik7ICAgICAgLy8gZ2V0IHRoZSBQQUwvTlRTQyBmbGFnXHJcbi8qIGY0MmYgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZjQzYVwiKTsgICAgICAgICAgICAvLyBpZiBQQUwgZ28gc2V0IFBBTCB0aW1pbmdcclxuLyogZjQzMSAqLyAgICAgICAgICAgICAgICAgICBMRFkuYWJ4IChcIl9mZWMxXCIpOyAgICAgICAgICAgIC8vIGdldCB0aGUgTlRTQyBiYXVkIHJhdGUgdmFsdWUgaGlnaCBieXRlXHJcbi8qIGY0MzQgKi8gICAgICAgICAgICAgICAgICAgTERBLmFieCAoXCJfZmVjMFwiKTsgICAgICAgICAgICAvLyBnZXQgdGhlIE5UU0MgYmF1ZCByYXRlIHZhbHVlIGxvdyBieXRlXHJcbi8qIGY0MzcgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZjQ0MFwiKTsgICAgICAgICAgICAvLyBnbyBzYXZlIHRoZSBiYXVkIHJhdGUgdmFsdWVzXHJcbi8qIGY0M2EgKi8gICAgICAgIF9gX2Y0M2FgOyAgTERZLmFieCAoXCJfZTRlYlwiKTsgICAgICAgICAgICAvLyBnZXQgdGhlIFBBTCBiYXVkIHJhdGUgdmFsdWUgaGlnaCBieXRlXHJcbi8qIGY0M2QgKi8gICAgICAgICAgICAgICAgICAgTERBLmFieCAoMHhlNGVhKTsgICAgICAgICAgICAgLy8gZ2V0IHRoZSBQQUwgYmF1ZCByYXRlIHZhbHVlIGxvdyBieXRlXHJcbi8qIGY0NDAgKi8gICAgICAgIF9gX2Y0NDBgOyAgU1RZLmFicyAoXCJtNTFhamIrMV8wMjk2XCIpOyAgICAvLyBzYXZlIHRoZSBub25zdGFuZGFyZCBiaXQgdGltaW5nIGhpZ2ggYnl0ZVxyXG4vKiBmNDQzICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwibTUxYWpiKzBfMDI5NVwiKTsgICAgLy8gc2F2ZSB0aGUgbm9uc3RhbmRhcmQgYml0IHRpbWluZyBsb3cgYnl0ZVxyXG4vKiBmNDQ2ICovICAgICAgICBfYF9mNDQ2YDsgIExEQS5hYnMgKFwibTUxYWpiKzBfMDI5NVwiKTsgICAgLy8gZ2V0IHRoZSBub25zdGFuZGFyZCBiaXQgdGltaW5nIGxvdyBieXRlXHJcbi8qIGY0NDkgKi8gICAgICAgICAgICAgICAgICAgQVNMLmFjYyAoKTsgICAgICAgICAgICAgICAgICAgLy8gKiAyXHJcbi8qIGY0NGEgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZmYyZVwiKTtcclxuLyogZjQ0ZCAqLyAgICAgICAgICAgICAgICAgICBMREEuYWJzIChcIm01MWNkcl8wMjk0XCIpOyAgICAgIC8vIHJlYWQgdGhlIHBzZXVkbyA2NTUxIGNvbW1hbmQgcmVnaXN0ZXJcclxuLyogZjQ1MCAqLyAgICAgICAgICAgICAgICAgICBMU1IuYWNjICgpOyAgICAgICAgICAgICAgICAgICAvLyBzaGlmdCB0aGUgWCBsaW5lLzMgbGluZSBiaXQgaW50byBDYlxyXG4vKiBmNDUxICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2Y0NWNcIik7ICAgICAgICAgICAgLy8gaWYgMyBsaW5lIHNraXAgdGhlIERSUyB0ZXN0XHJcbi8qIGY0NTMgKi8gICAgICAgICAgICAgICAgICAgTERBLmFicyAoXCJjaTJwcmJfZGQwMVwiKTsgICAgICAvLyByZWFkIFZJQSAyIERSQiwgUlMyMzIgcG9ydFxyXG4vKiBmNDU2ICovICAgICAgICAgICAgICAgICAgIEFTTC5hY2MgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNoaWZ0IERTUiBpbiBpbnRvIENiXHJcbi8qIGY0NTcgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfZjQ1Y1wiKTsgICAgICAgICAgICAvLyBpZiBEU1IgcHJlc2VudCBza2lwIHRoZSBlcnJvciBzZXRcclxuLyogZjQ1OSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mMDBkXCIpOyAgICAgICAgICAgIC8vIHNldCBubyBEU1JcclxuLyogZjQ1YyAqLyAgICAgICAgX2BfZjQ1Y2A7ICBMREEuYWJzIChcInJpZGJlXzAyOWJcIik7ICAgICAgIC8vIGdldCBpbmRleCB0byBSeCBidWZmZXIgZW5kXHJcbi8qIGY0NWYgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJyaWRic18wMjljXCIpOyAgICAgICAvLyBzZXQgaW5kZXggdG8gUnggYnVmZmVyIHN0YXJ0LCBjbGVhciBSeCBidWZmZXJcclxuLyogZjQ2MiAqLyAgICAgICAgICAgICAgICAgICBMREEuYWJzIChcInJvZGJlXzAyOWVcIik7ICAgICAgIC8vIGdldCBpbmRleCB0byBUeCBidWZmZXIgZW5kXHJcbi8qIGY0NjUgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJyb2Ric18wMjlkXCIpOyAgICAgICAvLyBzZXQgaW5kZXggdG8gVHggYnVmZmVyIHN0YXJ0LCBjbGVhciBUeCBidWZmZXJcclxuLyogZjQ2OCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mZTI3XCIpOyAgICAgICAgICAgIC8vIHJlYWQgdGhlIHRvcCBvZiBtZW1vcnlcclxuLyogZjQ2YiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInJpYnVmKzFfMDBmOFwiKTsgICAgIC8vIGdldCB0aGUgUlMyMzIgaW5wdXQgYnVmZmVyIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGY0NmQgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZjQ3NFwiKTsgICAgICAgICAgICAvLyBpZiBidWZmZXIgYWxyZWFkeSBzZXQgc2tpcCB0aGUgc2F2ZVxyXG4vKiBmNDZmICovICAgICAgICAgICAgICAgICAgIERFWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCB0b3Agb2YgbWVtb3J5IGhpZ2ggYnl0ZSwgMjU2IGJ5dGUgYnVmZmVyXHJcbi8qIGY0NzAgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJyaWJ1ZisxXzAwZjhcIik7ICAgICAvLyBzYXZlIHRoZSBSUzIzMiBpbnB1dCBidWZmZXIgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogZjQ3MiAqLyAgICAgICAgICAgICAgICAgICBTVFguenBnIChcInJpYnVmKzBfMDBmN1wiKTsgICAgIC8vIHNhdmUgdGhlIFJTMjMyIGlucHV0IGJ1ZmZlciBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGY0NzQgKi8gICAgICAgIF9gX2Y0NzRgOyAgTERBLnpwZyAoXCJyb2J1ZisxXzAwZmFcIik7ICAgICAvLyBnZXQgdGhlIFJTMjMyIG91dHB1dCBidWZmZXIgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogZjQ3NiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mNDdkXCIpOyAgICAgICAgICAgIC8vIGlmID8/IGdvIHNldCB0aGUgdG9wIG9mIG1lbW9yeSB0byBGMHh4XHJcbi8qIGY0NzggKi8gICAgICAgICAgICAgICAgICAgREVZLmltcCAoKTtcclxuLyogZjQ3OSAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcInJvYnVmKzFfMDBmYVwiKTsgICAgIC8vIHNhdmUgdGhlIFJTMjMyIG91dHB1dCBidWZmZXIgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogZjQ3YiAqLyAgICAgICAgICAgICAgICAgICBTVFguenBnIChcInJvYnVmKzBfMDBmOVwiKTsgICAgIC8vIHNhdmUgdGhlIFJTMjMyIG91dHB1dCBidWZmZXIgcG9pbnRlciBsb3cgYnl0ZVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzZXQgdGhlIHRvcCBvZiBtZW1vcnkgdG8gRjB4eFxyXG4vKiBmNDdkICovICAgICAgICBfYF9mNDdkYDsgIFNFQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHJlYWQgdGhlIHRvcCBvZiBtZW1vcnlcclxuLyogZjQ3ZSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweGYwKTsgICAgICAgICAgICAgICAvLyBzZXQgJEYwMDBcclxuLyogZjQ4MCAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9mZTJkXCIpOyAgICAgICAgICAgIC8vIHNldCB0aGUgdG9wIG9mIG1lbW9yeSBhbmQgcmV0dXJuXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGluaXRpYWxpc2UgUlMyMzIgb3V0cHV0XHJcbi8qIGY0ODMgKi8gICAgICAgIF9gX2Y0ODNgOyAgTERBLmltbSAoMHg3Zik7ICAgICAgICAgICAgICAgLy8gZGlzYWJsZSBhbGwgaW50ZXJydXB0c1xyXG4vKiBmNDg1ICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiY2kyaWNyX2RkMGRcIik7ICAgICAgLy8gc2F2ZSBWSUEgMiBJQ1JcclxuLyogZjQ4OCAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDA2KTsgICAgICAgICAgICAgICAvLyBzZXQgUlMyMzIgRFRSIG91dHB1dCwgUlMyMzIgUlRTIG91dHB1dFxyXG4vKiBmNDhhICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiYzJkZHJiX2RkMDNcIik7ICAgICAgLy8gc2F2ZSBWSUEgMiBERFJCLCBSUzIzMiBwb3J0XHJcbi8qIGY0OGQgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJjaTJwcmJfZGQwMVwiKTsgICAgICAvLyBzYXZlIFZJQSAyIERSQiwgUlMyMzIgcG9ydFxyXG4vKiBmNDkwICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MDQpOyAgICAgICAgICAgICAgIC8vIG1hc2sgeHh4eCB4MXh4LCBzZXQgUlMyMzIgVHggREFUQSBoaWdoXHJcbi8qIGY0OTIgKi8gICAgICAgICAgICAgICAgICAgT1JBLmFicyAoXCJjaTJwcmFfZGQwMFwiKTsgICAgICAvLyBPUiBpdCB3aXRoIFZJQSAyIERSQSwgc2VyaWFsIHBvcnQgYW5kIHZpZGVvIGFkZHJlc3NcclxuLyogZjQ5NSAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcImNpMnByYV9kZDAwXCIpOyAgICAgIC8vIHNhdmUgVklBIDIgRFJBLCBzZXJpYWwgcG9ydCBhbmQgdmlkZW8gYWRkcmVzc1xyXG4vKiBmNDk4ICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIFlcclxuLyogZjQ5YSAqLyAgICAgICAgICAgICAgICAgICBTVFkuYWJzIChcImVuYWJsXzAyYTFcIik7ICAgICAgIC8vIGNsZWFyIHRoZSBSUy0yMzIgaW50ZXJydXB0IGVuYWJsZSBieXRlXHJcbi8qIGY0OWQgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gbG9hZCBSQU0gZnJvbSBhIGRldmljZVxyXG4vKiBmNDllICovICAgIF9gbG9hZF9mNDllYDsgIFNUWC56cGcgKFwibWVtdXNzKzBfMDBjM1wiKTsgICAgLy8gc2V0IGtlcm5hbCBzZXR1cCBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGY0YTAgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJtZW11c3MrMV8wMGM0XCIpOyAgICAvLyBzZXQga2VybmFsIHNldHVwIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGY0YTIgKi8gICAgICAgICAgICAgICAgICAgSk1QLmluZCAoXCJpbG9hZCswXzAzMzBcIik7ICAgICAvLyBkbyBMT0FEIHZlY3RvciwgdXN1YWxseSBwb2ludHMgdG8gJEY0QTVcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gbG9hZFxyXG4vKiBmNGE1ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwidmVyY2tfMDA5M1wiKTsgICAgICAgLy8gc2F2ZSBsb2FkL3ZlcmlmeSBmbGFnXHJcbi8qIGY0YTcgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgQVxyXG4vKiBmNGE5ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwic3RhdHVzXzAwOTBcIik7ICAgICAgLy8gY2xlYXIgdGhlIHNlcmlhbCBzdGF0dXMgYnl0ZVxyXG4vKiBmNGFiICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZmFfMDBiYVwiKTsgICAgICAgICAgLy8gZ2V0IHRoZSBkZXZpY2UgbnVtYmVyXHJcbi8qIGY0YWQgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZjRiMlwiKTsgICAgICAgICAgICAvLyBpZiBub3QgdGhlIGtleWJvYXJkIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gJ2lsbGVnYWwgZGV2aWNlIG51bWJlcidcclxuLyogZjRhZiAqLyAgICAgICAgX2BfZjRhZmA7ICBKTVAuYWJzIChcIl9mNzEzXCIpOyAgICAgICAgICAgIC8vIGVsc2UgZG8gJ2lsbGVnYWwgZGV2aWNlIG51bWJlcicgYW5kIHJldHVyblxyXG4vKiBmNGIyICovICAgICAgICBfYF9mNGIyYDsgIENNUC5pbW0gKDB4MDMpO1xyXG4vKiBmNGI0ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2Y0YWZcIik7XHJcbi8qIGY0YjYgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfZjUzM1wiKTtcclxuLyogZjRiOCAqLyAgICAgICAgICAgICAgICAgICBMRFkuenBnIChcImZubGVuXzAwYjdcIik7ICAgICAgIC8vIGdldCBmaWxlIG5hbWUgbGVuZ3RoXHJcbi8qIGY0YmEgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZjRiZlwiKTsgICAgICAgICAgICAvLyBpZiBub3QgbnVsbCBuYW1lIGdvID8/XHJcbi8qIGY0YmMgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZjcxMFwiKTsgICAgICAgICAgICAvLyBlbHNlIGRvICdtaXNzaW5nIGZpbGUgbmFtZScgZXJyb3IgYW5kIHJldHVyblxyXG4vKiBmNGJmICovICAgICAgICBfYF9mNGJmYDsgIExEWC56cGcgKFwic2FfMDBiOVwiKTsgICAgICAgICAgLy8gZ2V0IHRoZSBzZWNvbmRhcnkgYWRkcmVzc1xyXG4vKiBmNGMxICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2Y1YWZcIik7ICAgICAgICAgICAgLy8gcHJpbnQgXCJTZWFyY2hpbmcuLi5cIlxyXG4vKiBmNGM0ICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4NjApO1xyXG4vKiBmNGM2ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwic2FfMDBiOVwiKTsgICAgICAgICAgLy8gc2F2ZSB0aGUgc2Vjb25kYXJ5IGFkZHJlc3NcclxuLyogZjRjOCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mM2Q1XCIpOyAgICAgICAgICAgIC8vIHNlbmQgc2Vjb25kYXJ5IGFkZHJlc3MgYW5kIGZpbGVuYW1lXHJcbi8qIGY0Y2IgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJmYV8wMGJhXCIpOyAgICAgICAgICAvLyBnZXQgdGhlIGRldmljZSBudW1iZXJcclxuLyogZjRjZCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcInRhbGtfZWQwOVwiKTsgICAgICAgIC8vIGNvbW1hbmQgc2VyaWFsIGJ1cyBkZXZpY2UgdG8gVEFMS1xyXG4vKiBmNGQwICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwic2FfMDBiOVwiKTsgICAgICAgICAgLy8gZ2V0IHRoZSBzZWNvbmRhcnkgYWRkcmVzc1xyXG4vKiBmNGQyICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwidGtzYV9lZGM3XCIpOyAgICAgICAgLy8gc2VuZCBzZWNvbmRhcnkgYWRkcmVzcyBhZnRlciBUQUxLXHJcbi8qIGY0ZDUgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJhY3B0cl9lZTEzXCIpOyAgICAgICAvLyBpbnB1dCBieXRlIGZyb20gc2VyaWFsIGJ1c1xyXG4vKiBmNGQ4ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZWFsKzBfMDBhZVwiKTsgICAgICAgLy8gc2F2ZSBwcm9ncmFtIHN0YXJ0IGFkZHJlc3MgbG93IGJ5dGVcclxuLyogZjRkYSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInN0YXR1c18wMDkwXCIpOyAgICAgIC8vIGdldCB0aGUgc2VyaWFsIHN0YXR1cyBieXRlXHJcbi8qIGY0ZGMgKi8gICAgICAgICAgICAgICAgICAgTFNSLmFjYyAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2hpZnQgdGltZSBvdXQgcmVhZCAuLlxyXG4vKiBmNGRkICovICAgICAgICAgICAgICAgICAgIExTUi5hY2MgKCk7ICAgICAgICAgICAgICAgICAgIC8vIC4uIGludG8gY2FycnkgYml0XHJcbi8qIGY0ZGUgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfZjUzMFwiKTsgICAgICAgICAgICAvLyBpZiB0aW1lZCBvdXQgZ28gZG8gZmlsZSBub3QgZm91bmQgZXJyb3IgYW5kIHJldHVyblxyXG4vKiBmNGUwICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiYWNwdHJfZWUxM1wiKTsgICAgICAgLy8gaW5wdXQgYnl0ZSBmcm9tIHNlcmlhbCBidXNcclxuLyogZjRlMyAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImVhbCsxXzAwYWZcIik7ICAgICAgIC8vIHNhdmUgcHJvZ3JhbSBzdGFydCBhZGRyZXNzIGhpZ2ggYnl0ZVxyXG4vKiBmNGU1ICovICAgICAgICAgICAgICAgICAgIFRYQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgc2Vjb25kYXJ5IGFkZHJlc3NcclxuLyogZjRlNiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mNGYwXCIpOyAgICAgICAgICAgIC8vIGxvYWQgbG9jYXRpb24gbm90IHNldCBpbiBMT0FEIGNhbGwsIHNvIGNvbnRpbnVlIHdpdGggdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9hZFxyXG4vKiBmNGU4ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwibWVtdXNzKzBfMDBjM1wiKTsgICAgLy8gZ2V0IHRoZSBsb2FkIGFkZHJlc3MgbG93IGJ5dGVcclxuLyogZjRlYSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImVhbCswXzAwYWVcIik7ICAgICAgIC8vIHNhdmUgdGhlIHByb2dyYW0gc3RhcnQgYWRkcmVzcyBsb3cgYnl0ZVxyXG4vKiBmNGVjICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwibWVtdXNzKzFfMDBjNFwiKTsgICAgLy8gZ2V0IHRoZSBsb2FkIGFkZHJlc3MgaGlnaCBieXRlXHJcbi8qIGY0ZWUgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJlYWwrMV8wMGFmXCIpOyAgICAgICAvLyBzYXZlIHRoZSBwcm9ncmFtIHN0YXJ0IGFkZHJlc3MgaGlnaCBieXRlXHJcbi8qIGY0ZjAgKi8gICAgICAgIF9gX2Y0ZjBgOyAgSlNSLmFicyAoXCJfZjVkMlwiKTtcclxuLyogZjRmMyAqLyAgICAgICAgX2BfZjRmM2A7ICBMREEuaW1tICgweGZkKTsgICAgICAgICAgICAgICAvLyBtYXNrIHh4eHggeHgweCwgY2xlYXIgdGltZSBvdXQgcmVhZCBiaXRcclxuLyogZjRmNSAqLyAgICAgICAgICAgICAgICAgICBBTkQuenBnIChcInN0YXR1c18wMDkwXCIpOyAgICAgIC8vIG1hc2sgdGhlIHNlcmlhbCBzdGF0dXMgYnl0ZVxyXG4vKiBmNGY3ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwic3RhdHVzXzAwOTBcIik7ICAgICAgLy8gc2V0IHRoZSBzZXJpYWwgc3RhdHVzIGJ5dGVcclxuLyogZjRmOSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcInN0b3BfZmZlMVwiKTsgICAgICAgIC8vIHNjYW4gc3RvcCBrZXksIHJldHVybiBaYiA9IDEgPSBbU1RPUF1cclxuLyogZjRmYyAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mNTAxXCIpOyAgICAgICAgICAgIC8vIGlmIG5vdCBbU1RPUF0gZ28gPz9cclxuLyogZjRmZSAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9mNjMzXCIpOyAgICAgICAgICAgIC8vIGVsc2UgY2xvc2UgdGhlIHNlcmlhbCBidXMgZGV2aWNlIGFuZCBmbGFnIHN0b3BcclxuLyogZjUwMSAqLyAgICAgICAgX2BfZjUwMWA7ICBKU1IuYWJzIChcImFjcHRyX2VlMTNcIik7ICAgICAgIC8vIGlucHV0IGJ5dGUgZnJvbSBzZXJpYWwgYnVzXHJcbi8qIGY1MDQgKi8gICAgICAgICAgICAgICAgICAgVEFYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBieXRlXHJcbi8qIGY1MDUgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJzdGF0dXNfMDA5MFwiKTsgICAgICAvLyBnZXQgdGhlIHNlcmlhbCBzdGF0dXMgYnl0ZVxyXG4vKiBmNTA3ICovICAgICAgICAgICAgICAgICAgIExTUi5hY2MgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNoaWZ0IHRpbWUgb3V0IHJlYWQgLi5cclxuLyogZjUwOCAqLyAgICAgICAgICAgICAgICAgICBMU1IuYWNjICgpOyAgICAgICAgICAgICAgICAgICAvLyAuLiBpbnRvIGNhcnJ5IGJpdFxyXG4vKiBmNTA5ICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2Y0ZjNcIik7ICAgICAgICAgICAgLy8gaWYgdGltZWQgb3V0IGdvIHRyeSBhZ2FpblxyXG4vKiBmNTBiICovICAgICAgICAgICAgICAgICAgIFRYQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgcmVjZWl2ZWQgYnl0ZSBiYWNrXHJcbi8qIGY1MGMgKi8gICAgICAgICAgICAgICAgICAgTERZLnpwZyAoXCJ2ZXJja18wMDkzXCIpOyAgICAgICAvLyBnZXQgbG9hZC92ZXJpZnkgZmxhZ1xyXG4vKiBmNTBlICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2Y1MWNcIik7ICAgICAgICAgICAgLy8gaWYgbG9hZCBnbyBsb2FkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBpcyB2ZXJpZnlcclxuLyogZjUxMCAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBpbmRleFxyXG4vKiBmNTEyICovICAgICAgICAgICAgICAgICAgIENNUC5pbnkgKFwiZWFsKzBfMDBhZVwiKTsgICAgICAgLy8gY29tcGFyZSBieXRlIHdpdGggcHJldmlvdXNseSBsb2FkZWQgYnl0ZVxyXG4vKiBmNTE0ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2Y1MWVcIik7ICAgICAgICAgICAgLy8gaWYgbWF0Y2ggZ28gPz9cclxuLyogZjUxNiAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDEwKTsgICAgICAgICAgICAgICAvLyBmbGFnIHJlYWQgZXJyb3JcclxuLyogZjUxOCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mZTFjXCIpOyAgICAgICAgICAgIC8vIE9SIGludG8gdGhlIHNlcmlhbCBzdGF0dXMgYnl0ZVxyXG4vKiBmNTFiICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgyYyk7ICAgICAgICAgICAgICAgIC8vIG1ha2VzIG5leHQgbGluZSBCSVQgJEFFOTFcclxuLyogZjUxYyAqLyAgICAgICAgX2BfZjUxY2A7ICBTVEEuaW55IChcImVhbCswXzAwYWVcIik7ICAgICAgIC8vIHNhdmUgYnl0ZSB0byBtZW1vcnlcclxuLyogZjUxZSAqLyAgICAgICAgX2BfZjUxZWA7ICBJTkMuenBnIChcImVhbCswXzAwYWVcIik7ICAgICAgIC8vIGluY3JlbWVudCBzYXZlIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogZjUyMCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mNTI0XCIpOyAgICAgICAgICAgIC8vIGlmIG5vIHJvbGxvdmVyIGdvID8/XHJcbi8qIGY1MjIgKi8gICAgICAgICAgICAgICAgICAgSU5DLnpwZyAoXCJlYWwrMV8wMGFmXCIpOyAgICAgICAvLyBlbHNlIGluY3JlbWVudCBzYXZlIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGY1MjQgKi8gICAgICAgIF9gX2Y1MjRgOyAgQklULnpwZyAoXCJzdGF0dXNfMDA5MFwiKTsgICAgICAvLyB0ZXN0IHRoZSBzZXJpYWwgc3RhdHVzIGJ5dGVcclxuLyogZjUyNiAqLyAgICAgICAgICAgICAgICAgICBCVkMucmVsIChcIl9mNGYzXCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgbm90IGVuZCBvZiBmaWxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2xvc2UgZmlsZSBhbmQgZXhpdFxyXG4vKiBmNTI4ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwidW50bGtfZWRlZlwiKTsgICAgICAgLy8gY29tbWFuZCBzZXJpYWwgYnVzIHRvIFVOVEFMS1xyXG4vKiBmNTJiICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2Y2NDJcIik7ICAgICAgICAgICAgLy8gY2xvc2Ugc2VyaWFsIGJ1cyBkZXZpY2VcclxuLyogZjUyZSAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9mNWE5XCIpOyAgICAgICAgICAgIC8vIGlmID8/IGdvIGZsYWcgb2sgYW5kIGV4aXRcclxuLyogZjUzMCAqLyAgICAgICAgX2BfZjUzMGA7ICBKTVAuYWJzIChcIl9mNzA0XCIpOyAgICAgICAgICAgIC8vIGRvIGZpbGUgbm90IGZvdW5kIGVycm9yIGFuZCByZXR1cm5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gPz9cclxuLyogZjUzMyAqLyAgICAgICAgX2BfZjUzM2A7ICBMU1IuYWNjICgpO1xyXG4vKiBmNTM0ICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2Y1MzlcIik7XHJcbi8qIGY1MzYgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZjcxM1wiKTsgICAgICAgICAgICAvLyBlbHNlIGRvICdpbGxlZ2FsIGRldmljZSBudW1iZXInIGFuZCByZXR1cm5cclxuLyogZjUzOSAqLyAgICAgICAgX2BfZjUzOWA7ICBKU1IuYWJzIChcIl9mN2QwXCIpOyAgICAgICAgICAgIC8vIGdldCB0YXBlIGJ1ZmZlciBzdGFydCBwb2ludGVyIGluIFhZXHJcbi8qIGY1M2MgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfZjU0MVwiKTsgICAgICAgICAgICAvLyBpZiA/P1xyXG4vKiBmNTNlICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2Y3MTNcIik7ICAgICAgICAgICAgLy8gZWxzZSBkbyAnaWxsZWdhbCBkZXZpY2UgbnVtYmVyJyBhbmQgcmV0dXJuXHJcbi8qIGY1NDEgKi8gICAgICAgIF9gX2Y1NDFgOyAgSlNSLmFicyAoXCJfZjgxN1wiKTsgICAgICAgICAgICAvLyB3YWl0IGZvciBQTEFZXHJcbi8qIGY1NDQgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfZjVhZVwiKTsgICAgICAgICAgICAvLyBleGl0IGlmIFNUT1Agd2FzIHByZXNzZWRcclxuLyogZjU0NiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mNWFmXCIpOyAgICAgICAgICAgIC8vIHByaW50IFwiU2VhcmNoaW5nLi4uXCJcclxuLyogZjU0OSAqLyAgICAgICAgX2BfZjU0OWA7ICBMREEuenBnIChcImZubGVuXzAwYjdcIik7ICAgICAgIC8vIGdldCBmaWxlIG5hbWUgbGVuZ3RoXHJcbi8qIGY1NGIgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZjU1NlwiKTtcclxuLyogZjU0ZCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mN2VhXCIpOyAgICAgICAgICAgIC8vIGZpbmQgc3BlY2lmaWMgdGFwZSBoZWFkZXJcclxuLyogZjU1MCAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9mNTVkXCIpOyAgICAgICAgICAgIC8vIGlmIG5vIGVycm9yIGNvbnRpbnVlXHJcbi8qIGY1NTIgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZjVhZVwiKTsgICAgICAgICAgICAvLyBleGl0IGlmID8/XHJcbi8qIGY1NTQgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfZjUzMFwiKTsgICAgICAgICAgICAvLyAsIGJyYW5jaCBhbHdheXNcclxuLyogZjU1NiAqLyAgICAgICAgX2BfZjU1NmA7ICBKU1IuYWJzIChcIl9mNzJjXCIpOyAgICAgICAgICAgIC8vIGZpbmQgdGFwZSBoZWFkZXIsIGV4aXQgd2l0aCBoZWFkZXIgaW4gYnVmZmVyXHJcbi8qIGY1NTkgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZjVhZVwiKTsgICAgICAgICAgICAvLyBleGl0IGlmID8/XHJcbi8qIGY1NWIgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfZjUzMFwiKTtcclxuLyogZjU1ZCAqLyAgICAgICAgX2BfZjU1ZGA7ICBMREEuenBnIChcInN0YXR1c18wMDkwXCIpOyAgICAgIC8vIGdldCB0aGUgc2VyaWFsIHN0YXR1cyBieXRlXHJcbi8qIGY1NWYgKi8gICAgICAgICAgICAgICAgICAgQU5ELmltbSAoMHgxMCk7ICAgICAgICAgICAgICAgLy8gbWFzayAwMDB4IDAwMDAsIHJlYWQgZXJyb3JcclxuLyogZjU2MSAqLyAgICAgICAgICAgICAgICAgICBTRUMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBmbGFnIGZhaWxcclxuLyogZjU2MiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mNWFlXCIpOyAgICAgICAgICAgIC8vIGlmIHJlYWQgZXJyb3IganVzdCBleGl0XHJcbi8qIGY1NjQgKi8gICAgICAgICAgICAgICAgICAgQ1BYLmltbSAoMHgwMSk7XHJcbi8qIGY1NjYgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZjU3OVwiKTtcclxuLyogZjU2OCAqLyAgICAgICAgICAgICAgICAgICBDUFguaW1tICgweDAzKTtcclxuLyogZjU2YSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mNTQ5XCIpO1xyXG4vKiBmNTZjICovICAgICAgICBfYF9mNTZjYDsgIExEWS5pbW0gKDB4MDEpO1xyXG4vKiBmNTZlICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwidGFwZTErMF8wMGIyXCIpO1xyXG4vKiBmNTcwICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwibWVtdXNzKzBfMDBjM1wiKTtcclxuLyogZjU3MiAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpO1xyXG4vKiBmNTczICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwidGFwZTErMF8wMGIyXCIpO1xyXG4vKiBmNTc1ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwibWVtdXNzKzFfMDBjNFwiKTtcclxuLyogZjU3NyAqLyAgICAgICAgICAgICAgICAgICBCQ1MucmVsIChcIl9mNTdkXCIpO1xyXG4vKiBmNTc5ICovICAgICAgICBfYF9mNTc5YDsgIExEQS56cGcgKFwic2FfMDBiOVwiKTsgICAgICAgICAgLy8gZ2V0IHRoZSBzZWNvbmRhcnkgYWRkcmVzc1xyXG4vKiBmNTdiICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2Y1NmNcIik7XHJcbi8qIGY1N2QgKi8gICAgICAgIF9gX2Y1N2RgOyAgTERZLmltbSAoMHgwMyk7XHJcbi8qIGY1N2YgKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJ0YXBlMSswXzAwYjJcIik7XHJcbi8qIGY1ODEgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgwMSk7XHJcbi8qIGY1ODMgKi8gICAgICAgICAgICAgICAgICAgU0JDLmlueSAoXCJ0YXBlMSswXzAwYjJcIik7XHJcbi8qIGY1ODUgKi8gICAgICAgICAgICAgICAgICAgVEFYLmltcCAoKTtcclxuLyogZjU4NiAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDA0KTtcclxuLyogZjU4OCAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcInRhcGUxKzBfMDBiMlwiKTtcclxuLyogZjU4YSAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAyKTtcclxuLyogZjU4YyAqLyAgICAgICAgICAgICAgICAgICBTQkMuaW55IChcInRhcGUxKzBfMDBiMlwiKTtcclxuLyogZjU4ZSAqLyAgICAgICAgICAgICAgICAgICBUQVkuaW1wICgpO1xyXG4vKiBmNThmICovICAgICAgICAgICAgICAgICAgIENMQy5pbXAgKCk7XHJcbi8qIGY1OTAgKi8gICAgICAgICAgICAgICAgICAgVFhBLmltcCAoKTtcclxuLyogZjU5MSAqLyAgICAgICAgICAgICAgICAgICBBREMuenBnIChcIm1lbXVzcyswXzAwYzNcIik7XHJcbi8qIGY1OTMgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJlYWwrMF8wMGFlXCIpO1xyXG4vKiBmNTk1ICovICAgICAgICAgICAgICAgICAgIFRZQS5pbXAgKCk7XHJcbi8qIGY1OTYgKi8gICAgICAgICAgICAgICAgICAgQURDLnpwZyAoXCJtZW11c3MrMV8wMGM0XCIpO1xyXG4vKiBmNTk4ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZWFsKzFfMDBhZlwiKTtcclxuLyogZjU5YSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcIm1lbXVzcyswXzAwYzNcIik7XHJcbi8qIGY1OWMgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJzdGFsKzBfMDBjMVwiKTsgICAgICAvLyBzZXQgSS9PIHN0YXJ0IGFkZHJlc3NlcyBsb3cgYnl0ZVxyXG4vKiBmNTllICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwibWVtdXNzKzFfMDBjNFwiKTtcclxuLyogZjVhMCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInN0YWwrMV8wMGMyXCIpOyAgICAgIC8vIHNldCBJL08gc3RhcnQgYWRkcmVzc2VzIGhpZ2ggYnl0ZVxyXG4vKiBmNWEyICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2Y1ZDJcIik7ICAgICAgICAgICAgLy8gZGlzcGxheSBcIkxPQURJTkdcIiBvciBcIlZFUklGWUlOR1wiXHJcbi8qIGY1YTUgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZjg0YVwiKTsgICAgICAgICAgICAvLyBkbyB0aGUgdGFwZSByZWFkXHJcbi8qIGY1YTggKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDI0KTsgICAgICAgICAgICAgICAgLy8gbWFrZXMgbmV4dCBsaW5lIEJJVCAkMTgsIGtlZXAgdGhlIGVycm9yIGZsYWcgaW4gQ2JcclxuLyogZjVhOSAqLyAgICAgICAgX2BfZjVhOWA7ICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBmbGFnIG9rXHJcbi8qIGY1YWEgKi8gICAgICAgICAgICAgICAgICAgTERYLnpwZyAoXCJlYWwrMF8wMGFlXCIpOyAgICAgICAvLyBnZXQgdGhlIExPQUQgZW5kIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogZjVhYyAqLyAgICAgICAgICAgICAgICAgICBMRFkuenBnIChcImVhbCsxXzAwYWZcIik7ICAgICAgIC8vIGdldCB0aGUgTE9BRCBlbmQgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogZjVhZSAqLyAgICAgICAgX2BfZjVhZWA7ICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBwcmludCBcIlNlYXJjaGluZy4uLlwiXHJcbi8qIGY1YWYgKi8gICAgICAgIF9gX2Y1YWZgOyAgTERBLnpwZyAoXCJtc2dmbGdfMDA5ZFwiKTsgICAgICAvLyBnZXQgbWVzc2FnZSBtb2RlIGZsYWdcclxuLyogZjViMSAqLyAgICAgICAgICAgICAgICAgICBCUEwucmVsIChcIl9mNWQxXCIpOyAgICAgICAgICAgIC8vIGV4aXQgaWYgY29udHJvbCBtZXNzYWdlcyBvZmZcclxuLyogZjViMyAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDBjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmRleCB0byBcIlNFQVJDSElORyBcIlxyXG4vKiBmNWI1ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2YxMmZcIik7ICAgICAgICAgICAgLy8gZGlzcGxheSBrZXJuZWwgSS9PIG1lc3NhZ2VcclxuLyogZjViOCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZubGVuXzAwYjdcIik7ICAgICAgIC8vIGdldCBmaWxlIG5hbWUgbGVuZ3RoXHJcbi8qIGY1YmEgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZjVkMVwiKTsgICAgICAgICAgICAvLyBleGl0IGlmIG51bGwgbmFtZVxyXG4vKiBmNWJjICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4MTcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgaW5kZXggdG8gXCJGT1IgXCJcclxuLyogZjViZSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mMTJmXCIpOyAgICAgICAgICAgIC8vIGRpc3BsYXkga2VybmVsIEkvTyBtZXNzYWdlXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHByaW50IGZpbGUgbmFtZVxyXG4vKiBmNWMxICovICAgICAgICBfYF9mNWMxYDsgIExEWS56cGcgKFwiZm5sZW5fMDBiN1wiKTsgICAgICAgLy8gZ2V0IGZpbGUgbmFtZSBsZW5ndGhcclxuLyogZjVjMyAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mNWQxXCIpOyAgICAgICAgICAgIC8vIGV4aXQgaWYgbnVsbCBmaWxlIG5hbWVcclxuLyogZjVjNSAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBpbmRleFxyXG4vKiBmNWM3ICovICAgICAgICBfYF9mNWM3YDsgIExEQS5pbnkgKFwiZm5hZHIrMF8wMGJiXCIpOyAgICAgLy8gZ2V0IGZpbGUgbmFtZSBieXRlXHJcbi8qIGY1YzkgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJjaHJvdXRfZmZkMlwiKTsgICAgICAvLyBvdXRwdXQgY2hhcmFjdGVyIHRvIGNoYW5uZWxcclxuLyogZjVjYyAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgaW5kZXhcclxuLyogZjVjZCAqLyAgICAgICAgICAgICAgICAgICBDUFkuenBnIChcImZubGVuXzAwYjdcIik7ICAgICAgIC8vIGNvbXBhcmUgd2l0aCBmaWxlIG5hbWUgbGVuZ3RoXHJcbi8qIGY1Y2YgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZjVjN1wiKTsgICAgICAgICAgICAvLyBsb29wIGlmIG1vcmUgdG8gZG9cclxuLyogZjVkMSAqLyAgICAgICAgX2BfZjVkMWA7ICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBkaXNwbGF5IFwiTE9BRElOR1wiIG9yIFwiVkVSSUZZSU5HXCJcclxuLyogZjVkMiAqLyAgICAgICAgX2BfZjVkMmA7ICBMRFkuaW1tICgweDQ5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludCB0byBcIkxPQURJTkdcIlxyXG4vKiBmNWQ0ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwidmVyY2tfMDA5M1wiKTsgICAgICAgLy8gZ2V0IGxvYWQvdmVyaWZ5IGZsYWdcclxuLyogZjVkNiAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mNWRhXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBsb2FkXHJcbi8qIGY1ZDggKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHg1OSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnQgdG8gXCJWRVJJRllJTkdcIlxyXG4vKiBmNWRhICovICAgICAgICBfYF9mNWRhYDsgIEpNUC5hYnMgKFwiX2YxMmJcIik7ICAgICAgICAgICAgLy8gZGlzcGxheSBrZXJuZWwgSS9PIG1lc3NhZ2UgaWYgaW4gZGlyZWN0IG1vZGUgYW5kIHJldHVyblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzYXZlIFJBTSB0byBkZXZpY2UsIEEgPSBpbmRleCB0byBzdGFydCBhZGRyZXNzLCBYWSA9IGVuZCBhZGRyZXNzIGxvdy9oaWdoXHJcbi8qIGY1ZGQgKi8gICAgX2BzYXZlX2Y1ZGRgOyAgU1RYLnpwZyAoXCJlYWwrMF8wMGFlXCIpOyAgICAgICAvLyBzYXZlIGVuZCBhZGRyZXNzIGxvdyBieXRlXHJcbi8qIGY1ZGYgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJlYWwrMV8wMGFmXCIpOyAgICAgICAvLyBzYXZlIGVuZCBhZGRyZXNzIGhpZ2ggYnl0ZVxyXG4vKiBmNWUxICovICAgICAgICAgICAgICAgICAgIFRBWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgaW5kZXggdG8gc3RhcnQgcG9pbnRlclxyXG4vKiBmNWUyICovICAgICAgICAgICAgICAgICAgIExEQS56cHggKDB4MDApOyAgICAgICAgICAgICAgIC8vIGdldCBzdGFydCBhZGRyZXNzIGxvdyBieXRlXHJcbi8qIGY1ZTQgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJzdGFsKzBfMDBjMVwiKTsgICAgICAvLyBzZXQgSS9PIHN0YXJ0IGFkZHJlc3NlcyBsb3cgYnl0ZVxyXG4vKiBmNWU2ICovICAgICAgICAgICAgICAgICAgIExEQS56cHggKDB4MDEpOyAgICAgICAgICAgICAgIC8vIGdldCBzdGFydCBhZGRyZXNzIGhpZ2ggYnl0ZVxyXG4vKiBmNWU4ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwic3RhbCsxXzAwYzJcIik7ICAgICAgLy8gc2V0IEkvTyBzdGFydCBhZGRyZXNzZXMgaGlnaCBieXRlXHJcbi8qIGY1ZWEgKi8gICAgICAgICAgICAgICAgICAgSk1QLmluZCAoXCJpc2F2ZSswXzAzMzJcIik7ICAgICAvLyBnbyBzYXZlLCB1c3VhbGx5IHBvaW50cyB0byAkRjY4NVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzYXZlXHJcbi8qIGY1ZWQgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJmYV8wMGJhXCIpOyAgICAgICAgICAvLyBnZXQgdGhlIGRldmljZSBudW1iZXJcclxuLyogZjVlZiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mNWY0XCIpOyAgICAgICAgICAgIC8vIGlmIG5vdCBrZXlib2FyZCBnbyA/P1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgLi5cclxuLyogZjVmMSAqLyAgICAgICAgX2BfZjVmMWA7ICBKTVAuYWJzIChcIl9mNzEzXCIpOyAgICAgICAgICAgIC8vIGVsc2UgZG8gJ2lsbGVnYWwgZGV2aWNlIG51bWJlcicgYW5kIHJldHVyblxyXG4vKiBmNWY0ICovICAgICAgICBfYF9mNWY0YDsgIENNUC5pbW0gKDB4MDMpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgZGV2aWNlIG51bWJlciB3aXRoIHNjcmVlblxyXG4vKiBmNWY2ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2Y1ZjFcIik7ICAgICAgICAgICAgLy8gaWYgc2NyZWVuIGRvIGlsbGVnYWwgZGV2aWNlIG51bWJlciBhbmQgcmV0dXJuXHJcbi8qIGY1ZjggKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfZjY1OVwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgPCBzY3JlZW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBncmVhdGVyIHRoYW4gc2NyZWVuIHNvIGlzIHNlcmlhbCBidXNcclxuLyogZjVmYSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDYxKTsgICAgICAgICAgICAgICAvLyBzZXQgc2Vjb25kYXJ5IGFkZHJlc3MgdG8gJDAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBhIHNlY29uZGFyeSBhZGRyZXNzIGlzIHRvIGJlIHNlbnQgdG8gYSBkZXZpY2Ugb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc2VyaWFsIGJ1cyB0aGUgYWRkcmVzcyBtdXN0IGZpcnN0IGJlIE9SZWQgd2l0aCAkNjBcclxuLyogZjVmYyAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInNhXzAwYjlcIik7ICAgICAgICAgIC8vIHNhdmUgdGhlIHNlY29uZGFyeSBhZGRyZXNzXHJcbi8qIGY1ZmUgKi8gICAgICAgICAgICAgICAgICAgTERZLnpwZyAoXCJmbmxlbl8wMGI3XCIpOyAgICAgICAvLyBnZXQgdGhlIGZpbGUgbmFtZSBsZW5ndGhcclxuLyogZjYwMCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mNjA1XCIpOyAgICAgICAgICAgIC8vIGlmIGZpbGVuYW1lIG5vdCBudWxsIGNvbnRpbnVlXHJcbi8qIGY2MDIgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZjcxMFwiKTsgICAgICAgICAgICAvLyBlbHNlIGRvICdtaXNzaW5nIGZpbGUgbmFtZScgZXJyb3IgYW5kIHJldHVyblxyXG4vKiBmNjA1ICovICAgICAgICBfYF9mNjA1YDsgIEpTUi5hYnMgKFwiX2YzZDVcIik7ICAgICAgICAgICAgLy8gc2VuZCBzZWNvbmRhcnkgYWRkcmVzcyBhbmQgZmlsZW5hbWVcclxuLyogZjYwOCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mNjhmXCIpOyAgICAgICAgICAgIC8vIHByaW50IHNhdmluZyA8ZmlsZSBuYW1lPlxyXG4vKiBmNjBiICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZmFfMDBiYVwiKTsgICAgICAgICAgLy8gZ2V0IHRoZSBkZXZpY2UgbnVtYmVyXHJcbi8qIGY2MGQgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJsaXN0ZW5fZWQwY1wiKTsgICAgICAvLyBjb21tYW5kIGRldmljZXMgb24gdGhlIHNlcmlhbCBidXMgdG8gTElTVEVOXHJcbi8qIGY2MTAgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJzYV8wMGI5XCIpOyAgICAgICAgICAvLyBnZXQgdGhlIHNlY29uZGFyeSBhZGRyZXNzXHJcbi8qIGY2MTIgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJzZWNvbmRfZWRiOVwiKTsgICAgICAvLyBzZW5kIHNlY29uZGFyeSBhZGRyZXNzIGFmdGVyIExJU1RFTlxyXG4vKiBmNjE1ICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIGluZGV4XHJcbi8qIGY2MTcgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZmI4ZVwiKTsgICAgICAgICAgICAvLyBjb3B5IEkvTyBzdGFydCBhZGRyZXNzIHRvIGJ1ZmZlciBhZGRyZXNzXHJcbi8qIGY2MWEgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJzYWwrMF8wMGFjXCIpOyAgICAgICAvLyBnZXQgYnVmZmVyIGFkZHJlc3MgbG93IGJ5dGVcclxuLyogZjYxYyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImNpb3V0X2VkZGRcIik7ICAgICAgIC8vIG91dHB1dCBieXRlIHRvIHNlcmlhbCBidXNcclxuLyogZjYxZiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInNhbCsxXzAwYWRcIik7ICAgICAgIC8vIGdldCBidWZmZXIgYWRkcmVzcyBoaWdoIGJ5dGVcclxuLyogZjYyMSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImNpb3V0X2VkZGRcIik7ICAgICAgIC8vIG91dHB1dCBieXRlIHRvIHNlcmlhbCBidXNcclxuLyogZjYyNCAqLyAgICAgICAgX2BfZjYyNGA7ICBKU1IuYWJzIChcIl9mY2QxXCIpOyAgICAgICAgICAgIC8vIGNoZWNrIHJlYWQvd3JpdGUgcG9pbnRlciwgcmV0dXJuIENiID0gMSBpZiBwb2ludGVyID49IGVuZFxyXG4vKiBmNjI3ICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2Y2M2ZcIik7ICAgICAgICAgICAgLy8gZ28gZG8gVU5MSVNURU4gaWYgYXQgZW5kXHJcbi8qIGY2MjkgKi8gICAgICAgICAgICAgICAgICAgTERBLmlueSAoXCJzYWwrMF8wMGFjXCIpOyAgICAgICAvLyBnZXQgYnl0ZSBmcm9tIGJ1ZmZlclxyXG4vKiBmNjJiICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiY2lvdXRfZWRkZFwiKTsgICAgICAgLy8gb3V0cHV0IGJ5dGUgdG8gc2VyaWFsIGJ1c1xyXG4vKiBmNjJlICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwic3RvcF9mZmUxXCIpOyAgICAgICAgLy8gc2NhbiBzdG9wIGtleVxyXG4vKiBmNjMxICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2Y2M2FcIik7ICAgICAgICAgICAgLy8gaWYgc3RvcCBub3QgcHJlc3NlZCBnbyBpbmNyZW1lbnQgcG9pbnRlciBhbmQgbG9vcCBmb3IgbmV4dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgLi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjbG9zZSB0aGUgc2VyaWFsIGJ1cyBkZXZpY2UgYW5kIGZsYWcgc3RvcFxyXG4vKiBmNjMzICovICAgICAgICBfYF9mNjMzYDsgIEpTUi5hYnMgKFwiX2Y2NDJcIik7ICAgICAgICAgICAgLy8gY2xvc2Ugc2VyaWFsIGJ1cyBkZXZpY2VcclxuLyogZjYzNiAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDAwKTtcclxuLyogZjYzOCAqLyAgICAgICAgICAgICAgICAgICBTRUMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBmbGFnIHN0b3BcclxuLyogZjYzOSAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG4vKiBmNjNhICovICAgICAgICBfYF9mNjNhYDsgIEpTUi5hYnMgKFwiX2ZjZGJcIik7ICAgICAgICAgICAgLy8gaW5jcmVtZW50IHJlYWQvd3JpdGUgcG9pbnRlclxyXG4vKiBmNjNkICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2Y2MjRcIik7ICAgICAgICAgICAgLy8gbG9vcCwgYnJhbmNoIGFsd2F5c1xyXG4vKiBmNjNmICovICAgICAgICBfYF9mNjNmYDsgIEpTUi5hYnMgKFwidW5sc25fZWRmZVwiKTsgICAgICAgLy8gY29tbWFuZCBzZXJpYWwgYnVzIHRvIFVOTElTVEVOXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2xvc2Ugc2VyaWFsIGJ1cyBkZXZpY2VcclxuLyogZjY0MiAqLyAgICAgICAgX2BfZjY0MmA7ICBCSVQuenBnIChcInNhXzAwYjlcIik7ICAgICAgICAgIC8vIHRlc3QgdGhlIHNlY29uZGFyeSBhZGRyZXNzXHJcbi8qIGY2NDQgKi8gICAgICAgICAgICAgICAgICAgQk1JLnJlbCAoXCJfZjY1N1wiKTsgICAgICAgICAgICAvLyBpZiBhbHJlYWR5IGNsb3NlZCBqdXN0IGV4aXRcclxuLyogZjY0NiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZhXzAwYmFcIik7ICAgICAgICAgIC8vIGdldCB0aGUgZGV2aWNlIG51bWJlclxyXG4vKiBmNjQ4ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwibGlzdGVuX2VkMGNcIik7ICAgICAgLy8gY29tbWFuZCBkZXZpY2VzIG9uIHRoZSBzZXJpYWwgYnVzIHRvIExJU1RFTlxyXG4vKiBmNjRiICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwic2FfMDBiOVwiKTsgICAgICAgICAgLy8gZ2V0IHRoZSBzZWNvbmRhcnkgYWRkcmVzc1xyXG4vKiBmNjRkICovICAgICAgICAgICAgICAgICAgIEFORC5pbW0gKDB4ZWYpOyAgICAgICAgICAgICAgIC8vIG1hc2sgdGhlIGNoYW5uZWwgbnVtYmVyXHJcbi8qIGY2NGYgKi8gICAgICAgICAgICAgICAgICAgT1JBLmltbSAoMHhlMCk7ICAgICAgICAgICAgICAgLy8gT1Igd2l0aCB0aGUgQ0xPU0UgY29tbWFuZFxyXG4vKiBmNjUxICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwic2Vjb25kX2VkYjlcIik7ICAgICAgLy8gc2VuZCBzZWNvbmRhcnkgYWRkcmVzcyBhZnRlciBMSVNURU5cclxuLyogZjY1NCAqLyAgICAgICAgX2BfZjY1NGA7ICBKU1IuYWJzIChcInVubHNuX2VkZmVcIik7ICAgICAgIC8vIGNvbW1hbmQgc2VyaWFsIGJ1cyB0byBVTkxJU1RFTlxyXG4vKiBmNjU3ICovICAgICAgICBfYF9mNjU3YDsgIENMQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGZsYWcgb2tcclxuLyogZjY1OCAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG4vKiBmNjU5ICovICAgICAgICBfYF9mNjU5YDsgIExTUi5hY2MgKCk7XHJcbi8qIGY2NWEgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfZjY1ZlwiKTsgICAgICAgICAgICAvLyBpZiBub3QgUlMyMzIgZGV2aWNlID8/XHJcbi8qIGY2NWMgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZjcxM1wiKTsgICAgICAgICAgICAvLyBlbHNlIGRvICdpbGxlZ2FsIGRldmljZSBudW1iZXInIGFuZCByZXR1cm5cclxuLyogZjY1ZiAqLyAgICAgICAgX2BfZjY1ZmA7ICBKU1IuYWJzIChcIl9mN2QwXCIpOyAgICAgICAgICAgIC8vIGdldCB0YXBlIGJ1ZmZlciBzdGFydCBwb2ludGVyIGluIFhZXHJcbi8qIGY2NjIgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfZjVmMVwiKTsgICAgICAgICAgICAvLyBpZiA8ICQwMjAwIGRvIGlsbGVnYWwgZGV2aWNlIG51bWJlciBhbmQgcmV0dXJuXHJcbi8qIGY2NjQgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZjgzOFwiKTsgICAgICAgICAgICAvLyB3YWl0IGZvciBQTEFZL1JFQ09SRFxyXG4vKiBmNjY3ICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2Y2OGVcIik7ICAgICAgICAgICAgLy8gZXhpdCBpZiBTVE9QIHdhcyBwcmVzc2VkXHJcbi8qIGY2NjkgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZjY4ZlwiKTsgICAgICAgICAgICAvLyBwcmludCBzYXZpbmcgPGZpbGUgbmFtZT5cclxuLyogZjY2YyAqLyAgICAgICAgICAgICAgICAgICBMRFguaW1tICgweDAzKTsgICAgICAgICAgICAgICAvLyBzZXQgaGVhZGVyIGZvciBhIG5vbiByZWxvY2F0YWJsZSBwcm9ncmFtIGZpbGVcclxuLyogZjY2ZSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInNhXzAwYjlcIik7ICAgICAgICAgIC8vIGdldCB0aGUgc2Vjb25kYXJ5IGFkZHJlc3NcclxuLyogZjY3MCAqLyAgICAgICAgICAgICAgICAgICBBTkQuaW1tICgweDAxKTsgICAgICAgICAgICAgICAvLyBtYXNrIG5vbiByZWxvY2F0YWJsZSBiaXRcclxuLyogZjY3MiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mNjc2XCIpOyAgICAgICAgICAgIC8vIGlmIG5vbiByZWxvY2F0YWJsZSBwcm9ncmFtIGdvID8/XHJcbi8qIGY2NzQgKi8gICAgICAgICAgICAgICAgICAgTERYLmltbSAoMHgwMSk7ICAgICAgICAgICAgICAgLy8gZWxzZSBzZXQgaGVhZGVyIGZvciBhIHJlbG9jYXRhYmxlIHByb2dyYW0gZmlsZVxyXG4vKiBmNjc2ICovICAgICAgICBfYF9mNjc2YDsgIFRYQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgaGVhZGVyIHR5cGUgdG8gQVxyXG4vKiBmNjc3ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2Y3NmFcIik7ICAgICAgICAgICAgLy8gd3JpdGUgdGFwZSBoZWFkZXJcclxuLyogZjY3YSAqLyAgICAgICAgICAgICAgICAgICBCQ1MucmVsIChcIl9mNjhlXCIpOyAgICAgICAgICAgIC8vIGV4aXQgaWYgZXJyb3JcclxuLyogZjY3YyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mODY3XCIpOyAgICAgICAgICAgIC8vIGRvIHRhcGUgd3JpdGUsIDIwIGN5Y2xlIGNvdW50XHJcbi8qIGY2N2YgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfZjY4ZVwiKTsgICAgICAgICAgICAvLyBleGl0IGlmIGVycm9yXHJcbi8qIGY2ODEgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJzYV8wMGI5XCIpOyAgICAgICAgICAvLyBnZXQgdGhlIHNlY29uZGFyeSBhZGRyZXNzXHJcbi8qIGY2ODMgKi8gICAgICAgICAgICAgICAgICAgQU5ELmltbSAoMHgwMik7ICAgICAgICAgICAgICAgLy8gbWFzayBlbmQgb2YgdGFwZSBmbGFnXHJcbi8qIGY2ODUgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZjY4ZFwiKTsgICAgICAgICAgICAvLyBpZiBub3QgZW5kIG9mIHRhcGUgZ28gPz9cclxuLyogZjY4NyAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDA1KTsgICAgICAgICAgICAgICAvLyBlbHNlIHNldCBsb2dpY2FsIGVuZCBvZiB0aGUgdGFwZVxyXG4vKiBmNjg5ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2Y3NmFcIik7ICAgICAgICAgICAgLy8gd3JpdGUgdGFwZSBoZWFkZXJcclxuLyogZjY4YyAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MjQpOyAgICAgICAgICAgICAgICAvLyBtYWtlcyBuZXh0IGxpbmUgQklUICQxOCBzbyBDYiBpcyBub3QgY2hhbmdlZFxyXG4vKiBmNjhkICovICAgICAgICBfYF9mNjhkYDsgIENMQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGZsYWcgb2tcclxuLyogZjY4ZSAqLyAgICAgICAgX2BfZjY4ZWA7ICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBwcmludCBzYXZpbmcgPGZpbGUgbmFtZT5cclxuLyogZjY4ZiAqLyAgICAgICAgX2BfZjY4ZmA7ICBMREEuenBnIChcIm1zZ2ZsZ18wMDlkXCIpOyAgICAgIC8vIGdldCBtZXNzYWdlIG1vZGUgZmxhZ1xyXG4vKiBmNjkxICovICAgICAgICAgICAgICAgICAgIEJQTC5yZWwgKFwiX2Y2OGVcIik7ICAgICAgICAgICAgLy8gZXhpdCBpZiBjb250cm9sIG1lc3NhZ2VzIG9mZlxyXG4vKiBmNjkzICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4NTEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluZGV4IHRvIFwiU0FWSU5HIFwiXHJcbi8qIGY2OTUgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZjEyZlwiKTsgICAgICAgICAgICAvLyBkaXNwbGF5IGtlcm5lbCBJL08gbWVzc2FnZVxyXG4vKiBmNjk4ICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2Y1YzFcIik7ICAgICAgICAgICAgLy8gcHJpbnQgZmlsZSBuYW1lIGFuZCByZXR1cm5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gaW5jcmVtZW50IHRoZSByZWFsIHRpbWUgY2xvY2tcclxuLyogZjY5YiAqLyAgIF9gdWR0aW1fZjY5YmA7ICBMRFguaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBYXHJcbi8qIGY2OWQgKi8gICAgICAgICAgICAgICAgICAgSU5DLnpwZyAoXCJ0aW1lKzJfMDBhMlwiKTsgICAgICAvLyBpbmNyZW1lbnQgdGhlIGppZmZ5IGNsb2NrIGxvdyBieXRlXHJcbi8qIGY2OWYgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZjZhN1wiKTsgICAgICAgICAgICAvLyBpZiBubyByb2xsb3ZlciA/P1xyXG4vKiBmNmExICovICAgICAgICAgICAgICAgICAgIElOQy56cGcgKFwidGltZSsxXzAwYTFcIik7ICAgICAgLy8gaW5jcmVtZW50IHRoZSBqaWZmeSBjbG9jayBtaWQgYnl0ZVxyXG4vKiBmNmEzICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2Y2YTdcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vIHJvbGxvdmVyXHJcbi8qIGY2YTUgKi8gICAgICAgICAgICAgICAgICAgSU5DLnpwZyAoXCJ0aW1lKzBfMDBhMFwiKTsgICAgICAvLyBpbmNyZW1lbnQgdGhlIGppZmZ5IGNsb2NrIGhpZ2ggYnl0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdyBzdWJ0cmFjdCBhIGRheXMgd29ydGggb2YgamlmZmllcyBmcm9tIGN1cnJlbnQgY291bnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcmVtZW1iZXIgb25seSB0aGUgQ2IgcmVzdWx0XHJcbi8qIGY2YTcgKi8gICAgICAgIF9gX2Y2YTdgOyAgU0VDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2V0IGNhcnJ5IGZvciBzdWJ0cmFjdFxyXG4vKiBmNmE4ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwidGltZSsyXzAwYTJcIik7ICAgICAgLy8gZ2V0IHRoZSBqaWZmeSBjbG9jayBsb3cgYnl0ZVxyXG4vKiBmNmFhICovICAgICAgICAgICAgICAgICAgIFNCQy5pbW0gKDB4MDEpOyAgICAgICAgICAgICAgIC8vIHN1YnRyYWN0ICQ0RjFBMDEgbG93IGJ5dGVcclxuLyogZjZhYyAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInRpbWUrMV8wMGExXCIpOyAgICAgIC8vIGdldCB0aGUgamlmZnkgY2xvY2sgbWlkIGJ5dGVcclxuLyogZjZhZSAqLyAgICAgICAgICAgICAgICAgICBTQkMuaW1tICgweDFhKTsgICAgICAgICAgICAgICAvLyBzdWJ0cmFjdCAkNEYxQTAxIG1pZCBieXRlXHJcbi8qIGY2YjAgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ0aW1lKzBfMDBhMFwiKTsgICAgICAvLyBnZXQgdGhlIGppZmZ5IGNsb2NrIGhpZ2ggYnl0ZVxyXG4vKiBmNmIyICovICAgICAgICAgICAgICAgICAgIFNCQy5pbW0gKDB4NGYpOyAgICAgICAgICAgICAgIC8vIHN1YnRyYWN0ICQ0RjFBMDEgaGlnaCBieXRlXHJcbi8qIGY2YjQgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfZjZiY1wiKTsgICAgICAgICAgICAvLyBpZiBsZXNzIHRoYW4gJDRGMUEwMSBqaWZmaWVzIHNraXAgdGhlIGNsb2NrIHJlc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSAuLlxyXG4vKiBmNmI2ICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwidGltZSswXzAwYTBcIik7ICAgICAgLy8gY2xlYXIgdGhlIGppZmZ5IGNsb2NrIGhpZ2ggYnl0ZVxyXG4vKiBmNmI4ICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwidGltZSsxXzAwYTFcIik7ICAgICAgLy8gY2xlYXIgdGhlIGppZmZ5IGNsb2NrIG1pZCBieXRlXHJcbi8qIGY2YmEgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJ0aW1lKzJfMDBhMlwiKTsgICAgICAvLyBjbGVhciB0aGUgamlmZnkgY2xvY2sgbG93IGJ5dGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHdyb25nLCB0aGVyZSBhcmUgJDRGMUEwMCBqaWZmaWVzIGluIGEgZGF5IHNvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJlc2V0IHRvIHplcm8gc2hvdWxkIG9jY3VyIHdoZW4gdGhlIHZhbHVlIHJlYWNoZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAkNEYxQTAwIGFuZCBub3QgJDRGMUEwMS4gdGhpcyB3b3VsZCBnaXZlIGFuIGV4dHJhIGppZmZ5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXZlcnkgZGF5IGFuZCBhIHBvc3NpYmxlIFRJIHZhbHVlIG9mIDI0OjAwOjAwXHJcbi8qIGY2YmMgKi8gICAgICAgIF9gX2Y2YmNgOyAgTERBLmFicyAoXCJjaWFwcmJfZGMwMVwiKTsgICAgICAvLyByZWFkIFZJQSAxIERSQiwga2V5Ym9hcmQgcm93IHBvcnRcclxuLyogZjZiZiAqLyAgICAgICAgICAgICAgICAgICBDTVAuYWJzIChcImNpYXByYl9kYzAxXCIpOyAgICAgIC8vIGNvbXBhcmUgaXQgd2l0aCBpdHNlbGZcclxuLyogZjZjMiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mNmJjXCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgY2hhbmdpbmdcclxuLyogZjZjNCAqLyAgICAgICAgICAgICAgICAgICBUQVguaW1wICgpO1xyXG4vKiBmNmM1ICovICAgICAgICAgICAgICAgICAgIEJNSS5yZWwgKFwiX2Y2ZGFcIik7XHJcbi8qIGY2YzcgKi8gICAgICAgICAgICAgICAgICAgTERYLmltbSAoMHhiZCk7ICAgICAgICAgICAgICAgLy8gc2V0IGM2XHJcbi8qIGY2YzkgKi8gICAgICAgICAgICAgICAgICAgU1RYLmFicyAoXCJjaWFwcmFfZGMwMFwiKTsgICAgICAvLyBzYXZlIFZJQSAxIERSQSwga2V5Ym9hcmQgY29sdW1uIGRyaXZlXHJcbi8qIGY2Y2MgKi8gICAgICAgIF9gX2Y2Y2NgOyAgTERYLmFicyAoXCJjaWFwcmJfZGMwMVwiKTsgICAgICAvLyByZWFkIFZJQSAxIERSQiwga2V5Ym9hcmQgcm93IHBvcnRcclxuLyogZjZjZiAqLyAgICAgICAgICAgICAgICAgICBDUFguYWJzIChcImNpYXByYl9kYzAxXCIpOyAgICAgIC8vIGNvbXBhcmUgaXQgd2l0aCBpdHNlbGZcclxuLyogZjZkMiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mNmNjXCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgY2hhbmdpbmdcclxuLyogZjZkNCAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcImNpYXByYV9kYzAwXCIpOyAgICAgIC8vIHNhdmUgVklBIDEgRFJBLCBrZXlib2FyZCBjb2x1bW4gZHJpdmVcclxuLyogZjZkNyAqLyAgICAgICAgICAgICAgICAgICBJTlguaW1wICgpO1xyXG4vKiBmNmQ4ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2Y2ZGNcIik7XHJcbi8qIGY2ZGEgKi8gICAgICAgIF9gX2Y2ZGFgOyAgU1RBLnpwZyAoXCJzdGtleV8wMDkxXCIpOyAgICAgICAvLyBzYXZlIHRoZSBzdG9wIGtleSBjb2x1bW5cclxuLyogZjZkYyAqLyAgICAgICAgX2BfZjZkY2A7ICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyByZWFkIHRoZSByZWFsIHRpbWUgY2xvY2tcclxuLyogZjZkZCAqLyAgIF9gcmR0aW1fZjZkZGA7ICBTRUkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBkaXNhYmxlIHRoZSBpbnRlcnJ1cHRzXHJcbi8qIGY2ZGUgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ0aW1lKzJfMDBhMlwiKTsgICAgICAvLyBnZXQgdGhlIGppZmZ5IGNsb2NrIGxvdyBieXRlXHJcbi8qIGY2ZTAgKi8gICAgICAgICAgICAgICAgICAgTERYLnpwZyAoXCJ0aW1lKzFfMDBhMVwiKTsgICAgICAvLyBnZXQgdGhlIGppZmZ5IGNsb2NrIG1pZCBieXRlXHJcbi8qIGY2ZTIgKi8gICAgICAgICAgICAgICAgICAgTERZLnpwZyAoXCJ0aW1lKzBfMDBhMFwiKTsgICAgICAvLyBnZXQgdGhlIGppZmZ5IGNsb2NrIGhpZ2ggYnl0ZVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzZXQgdGhlIHJlYWwgdGltZSBjbG9ja1xyXG4vKiBmNmU0ICovICBfYHNldHRpbV9mNmU0YDsgIFNFSS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRpc2FibGUgdGhlIGludGVycnVwdHNcclxuLyogZjZlNSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInRpbWUrMl8wMGEyXCIpOyAgICAgIC8vIHNhdmUgdGhlIGppZmZ5IGNsb2NrIGxvdyBieXRlXHJcbi8qIGY2ZTcgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJ0aW1lKzFfMDBhMVwiKTsgICAgICAvLyBzYXZlIHRoZSBqaWZmeSBjbG9jayBtaWQgYnl0ZVxyXG4vKiBmNmU5ICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwidGltZSswXzAwYTBcIik7ICAgICAgLy8gc2F2ZSB0aGUgamlmZnkgY2xvY2sgaGlnaCBieXRlXHJcbi8qIGY2ZWIgKi8gICAgICAgICAgICAgICAgICAgQ0xJLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZW5hYmxlIHRoZSBpbnRlcnJ1cHRzXHJcbi8qIGY2ZWMgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gc2NhbiB0aGUgc3RvcCBrZXksIHJldHVybiBaYiA9IDEgPSBbU1RPUF1cclxuLyogZjZlZCAqLyAgICBfYHN0b3BfZjZlZGA7ICBMREEuenBnIChcInN0a2V5XzAwOTFcIik7ICAgICAgIC8vIHJlYWQgdGhlIHN0b3Aga2V5IGNvbHVtblxyXG4vKiBmNmVmICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4N2YpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCBbU1RQXSBkb3duXHJcbi8qIGY2ZjEgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZjZmYVwiKTsgICAgICAgICAgICAvLyBpZiBub3QgW1NUUF0gb3Igbm90IGp1c3QgW1NUUF0gZXhpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgW1NUUF0gd2FzIHByZXNzZWRcclxuLyogZjZmMyAqLyAgICAgICAgICAgICAgICAgICBQSFAuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzYXZlIHN0YXR1c1xyXG4vKiBmNmY0ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiY2xyY2huX2ZmY2NcIik7ICAgICAgLy8gY2xvc2UgaW5wdXQgYW5kIG91dHB1dCBjaGFubmVsc1xyXG4vKiBmNmY3ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwibmR4XzAwYzZcIik7ICAgICAgICAgLy8gc2F2ZSB0aGUga2V5Ym9hcmQgYnVmZmVyIGluZGV4XHJcbi8qIGY2ZjkgKi8gICAgICAgICAgICAgICAgICAgUExQLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBzdGF0dXNcclxuLyogZjZmYSAqLyAgICAgICAgX2BfZjZmYWA7ICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBmaWxlIGVycm9yIG1lc3NhZ2VzXHJcbi8qIGY2ZmIgKi8gICAgICAgIF9gX2Y2ZmJgOyAgTERBLmltbSAoMHgwMSk7ICAgICAgICAgICAgICAgLy8gJ3RvbyBtYW55IGZpbGVzJyBlcnJvclxyXG4vKiBmNmZkICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgyYyk7ICAgICAgICAgICAgICAgIC8vIG1ha2VzIG5leHQgbGluZSBCSVQgJDAyQTlcclxuLyogZjZmZSAqLyAgICAgICAgX2BfZjZmZWA7ICBMREEuaW1tICgweDAyKTsgICAgICAgICAgICAgICAvLyAnZmlsZSBhbHJlYWR5IG9wZW4nIGVycm9yXHJcbi8qIGY3MDAgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDJjKTsgICAgICAgICAgICAgICAgLy8gbWFrZXMgbmV4dCBsaW5lIEJJVCAkMDNBOVxyXG4vKiBmNzAxICovICAgICAgICBfYF9mNzAxYDsgIExEQS5pbW0gKDB4MDMpOyAgICAgICAgICAgICAgIC8vICdmaWxlIG5vdCBvcGVuJyBlcnJvclxyXG4vKiBmNzAzICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgyYyk7ICAgICAgICAgICAgICAgIC8vIG1ha2VzIG5leHQgbGluZSBCSVQgJDA0QTlcclxuLyogZjcwNCAqLyAgICAgICAgX2BfZjcwNGA7ICBMREEuaW1tICgweDA0KTsgICAgICAgICAgICAgICAvLyAnZmlsZSBub3QgZm91bmQnIGVycm9yXHJcbi8qIGY3MDYgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDJjKTsgICAgICAgICAgICAgICAgLy8gbWFrZXMgbmV4dCBsaW5lIEJJVCAkMDVBOVxyXG4vKiBmNzA3ICovICAgICAgICBfYF9mNzA3YDsgIExEQS5pbW0gKDB4MDUpOyAgICAgICAgICAgICAgIC8vICdkZXZpY2Ugbm90IHByZXNlbnQnIGVycm9yXHJcbi8qIGY3MDkgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDJjKTsgICAgICAgICAgICAgICAgLy8gbWFrZXMgbmV4dCBsaW5lIEJJVCAkMDZBOVxyXG4vKiBmNzBhICovICAgICAgICBfYF9mNzBhYDsgIExEQS5pbW0gKDB4MDYpOyAgICAgICAgICAgICAgIC8vICdub3QgaW5wdXQgZmlsZScgZXJyb3JcclxuLyogZjcwYyAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MmMpOyAgICAgICAgICAgICAgICAvLyBtYWtlcyBuZXh0IGxpbmUgQklUICQwN0E5XHJcbi8qIGY3MGQgKi8gICAgICAgIF9gX2Y3MGRgOyAgTERBLmltbSAoMHgwNyk7ICAgICAgICAgICAgICAgLy8gJ25vdCBvdXRwdXQgZmlsZScgZXJyb3JcclxuLyogZjcwZiAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MmMpOyAgICAgICAgICAgICAgICAvLyBtYWtlcyBuZXh0IGxpbmUgQklUICQwOEE5XHJcbi8qIGY3MTAgKi8gICAgICAgIF9gX2Y3MTBgOyAgTERBLmltbSAoMHgwOCk7ICAgICAgICAgICAgICAgLy8gJ21pc3NpbmcgZmlsZSBuYW1lJyBlcnJvclxyXG4vKiBmNzEyICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgyYyk7ICAgICAgICAgICAgICAgIC8vIG1ha2VzIG5leHQgbGluZSBCSVQgJDA5QTlcclxuLyogZjcxMyAqLyAgICAgICAgX2BfZjcxM2A7ICBMREEuaW1tICgweDA5KTsgICAgICAgICAgICAgICAvLyBkbyAnaWxsZWdhbCBkZXZpY2UgbnVtYmVyJ1xyXG4vKiBmNzE1ICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgdGhlIGVycm9yICNcclxuLyogZjcxNiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImNscmNobl9mZmNjXCIpOyAgICAgIC8vIGNsb3NlIGlucHV0IGFuZCBvdXRwdXQgY2hhbm5lbHNcclxuLyogZjcxOSAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmRleCB0byBcIkkvTyBFUlJPUiAjXCJcclxuLyogZjcxYiAqLyAgICAgICAgICAgICAgICAgICBCSVQuenBnIChcIm1zZ2ZsZ18wMDlkXCIpOyAgICAgIC8vIHRlc3QgbWVzc2FnZSBtb2RlIGZsYWdcclxuLyogZjcxZCAqLyAgICAgICAgICAgICAgICAgICBCVkMucmVsIChcIl9mNzI5XCIpOyAgICAgICAgICAgIC8vIGV4aXQgaWYga2VybmFsIG1lc3NhZ2VzIG9mZlxyXG4vKiBmNzFmICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2YxMmZcIik7ICAgICAgICAgICAgLy8gZGlzcGxheSBrZXJuZWwgSS9PIG1lc3NhZ2VcclxuLyogZjcyMiAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIGVycm9yICNcclxuLyogZjcyMyAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IGVycm9yICNcclxuLyogZjcyNCAqLyAgICAgICAgICAgICAgICAgICBPUkEuaW1tICgweDMwKTsgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHRvIEFTQ0lJXHJcbi8qIGY3MjYgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJjaHJvdXRfZmZkMlwiKTsgICAgICAvLyBvdXRwdXQgY2hhcmFjdGVyIHRvIGNoYW5uZWxcclxuLyogZjcyOSAqLyAgICAgICAgX2BfZjcyOWA7ICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdWxsIGVycm9yIG51bWJlclxyXG4vKiBmNzJhICovICAgICAgICAgICAgICAgICAgIFNFQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGZsYWcgZXJyb3JcclxuLyogZjcyYiAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBmaW5kIHRoZSB0YXBlIGhlYWRlciwgZXhpdCB3aXRoIGhlYWRlciBpbiBidWZmZXJcclxuLyogZjcyYyAqLyAgICAgICAgX2BfZjcyY2A7ICBMREEuenBnIChcInZlcmNrXzAwOTNcIik7ICAgICAgIC8vIGdldCBsb2FkL3ZlcmlmeSBmbGFnXHJcbi8qIGY3MmUgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBsb2FkL3ZlcmlmeSBmbGFnXHJcbi8qIGY3MmYgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZjg0MVwiKTsgICAgICAgICAgICAvLyBpbml0aWF0ZSB0YXBlIHJlYWRcclxuLyogZjczMiAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIGxvYWQvdmVyaWZ5IGZsYWdcclxuLyogZjczMyAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInZlcmNrXzAwOTNcIik7ICAgICAgIC8vIHNhdmUgbG9hZC92ZXJpZnkgZmxhZ1xyXG4vKiBmNzM1ICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2Y3NjlcIik7ICAgICAgICAgICAgLy8gZXhpdCBpZiBlcnJvclxyXG4vKiBmNzM3ICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIHRoZSBpbmRleFxyXG4vKiBmNzM5ICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwidGFwZTErMF8wMGIyXCIpOyAgICAgLy8gcmVhZCBmaXJzdCBieXRlIGZyb20gdGFwZSBidWZmZXJcclxuLyogZjczYiAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW1tICgweDA1KTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggbG9naWNhbCBlbmQgb2YgdGhlIHRhcGVcclxuLyogZjczZCAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mNzY5XCIpOyAgICAgICAgICAgIC8vIGlmIGVuZCBvZiB0aGUgdGFwZSBleGl0XHJcbi8qIGY3M2YgKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHgwMSk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIGhlYWRlciBmb3IgYSByZWxvY2F0YWJsZSBwcm9ncmFtIGZpbGVcclxuLyogZjc0MSAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mNzRiXCIpOyAgICAgICAgICAgIC8vIGlmIHByb2dyYW0gZmlsZSBoZWFkZXIgZ28gPz9cclxuLyogZjc0MyAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW1tICgweDAzKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggaGVhZGVyIGZvciBhIG5vbiByZWxvY2F0YWJsZSBwcm9ncmFtIGZpbGVcclxuLyogZjc0NSAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mNzRiXCIpOyAgICAgICAgICAgIC8vIGlmIHByb2dyYW0gZmlsZSBoZWFkZXIgZ28gID8/XHJcbi8qIGY3NDcgKi8gICAgICAgICAgICAgICAgICAgQ01QLmltbSAoMHgwNCk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIGRhdGEgZmlsZSBoZWFkZXJcclxuLyogZjc0OSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mNzJjXCIpOyAgICAgICAgICAgIC8vIGlmIGRhdGEgZmlsZSBsb29wIHRvIGZpbmQgdGhlIHRhcGUgaGVhZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2FzIGEgcHJvZ3JhbSBmaWxlIGhlYWRlclxyXG4vKiBmNzRiICovICAgICAgICBfYF9mNzRiYDsgIFRBWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgaGVhZGVyIHR5cGVcclxuLyogZjc0YyAqLyAgICAgICAgICAgICAgICAgICBCSVQuenBnIChcIm1zZ2ZsZ18wMDlkXCIpOyAgICAgIC8vIGdldCBtZXNzYWdlIG1vZGUgZmxhZ1xyXG4vKiBmNzRlICovICAgICAgICAgICAgICAgICAgIEJQTC5yZWwgKFwiX2Y3NjdcIik7ICAgICAgICAgICAgLy8gZXhpdCBpZiBjb250cm9sIG1lc3NhZ2VzIG9mZlxyXG4vKiBmNzUwICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4NjMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluZGV4IHRvIFwiRk9VTkQgXCJcclxuLyogZjc1MiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mMTJmXCIpOyAgICAgICAgICAgIC8vIGRpc3BsYXkga2VybmVsIEkvTyBtZXNzYWdlXHJcbi8qIGY3NTUgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgwNSk7ICAgICAgICAgICAgICAgLy8gaW5kZXggdG8gdGhlIHRhcGUgZmlsZW5hbWVcclxuLyogZjc1NyAqLyAgICAgICAgX2BfZjc1N2A7ICBMREEuaW55IChcInRhcGUxKzBfMDBiMlwiKTsgICAgIC8vIGdldCBieXRlIGZyb20gdGFwZSBidWZmZXJcclxuLyogZjc1OSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImNocm91dF9mZmQyXCIpOyAgICAgIC8vIG91dHB1dCBjaGFyYWN0ZXIgdG8gY2hhbm5lbFxyXG4vKiBmNzVjICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCB0aGUgaW5kZXhcclxuLyogZjc1ZCAqLyAgICAgICAgICAgICAgICAgICBDUFkuaW1tICgweDE1KTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIGl0IHdpdGggZW5kKzFcclxuLyogZjc1ZiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mNzU3XCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgbW9yZSB0byBkb1xyXG4vKiBmNzYxICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwidGltZSsxXzAwYTFcIik7ICAgICAgLy8gZ2V0IHRoZSBqaWZmeSBjbG9jayBtaWQgYnl0ZVxyXG4vKiBmNzYzICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2U0ZTBcIik7ICAgICAgICAgICAgLy8gd2FpdCB+OC41IHNlY29uZHMgZm9yIGFueSBrZXkgZnJvbSB0aGUgU1RPUCBrZXkgY29sdW1uXHJcbi8qIGY3NjYgKi8gICAgICAgICAgICAgICAgICAgTk9QLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gd2FzdGUgY3ljbGVzXHJcbi8qIGY3NjcgKi8gICAgICAgIF9gX2Y3NjdgOyAgQ0xDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZmxhZyBubyBlcnJvclxyXG4vKiBmNzY4ICovICAgICAgICAgICAgICAgICAgIERFWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCB0aGUgaW5kZXhcclxuLyogZjc2OSAqLyAgICAgICAgX2BfZjc2OWA7ICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyB3cml0ZSB0aGUgdGFwZSBoZWFkZXJcclxuLyogZjc2YSAqLyAgICAgICAgX2BfZjc2YWA7ICBTVEEuenBnIChcInB0cjFfMDA5ZVwiKTsgICAgICAgIC8vIHNhdmUgaGVhZGVyIHR5cGVcclxuLyogZjc2YyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mN2QwXCIpOyAgICAgICAgICAgIC8vIGdldCB0YXBlIGJ1ZmZlciBzdGFydCBwb2ludGVyIGluIFhZXHJcbi8qIGY3NmYgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfZjdjZlwiKTsgICAgICAgICAgICAvLyBpZiA8ICQwMjAwIGp1c3QgZXhpdCA/P1xyXG4vKiBmNzcxICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwic3RhbCsxXzAwYzJcIik7ICAgICAgLy8gZ2V0IEkvTyBzdGFydCBhZGRyZXNzIGhpZ2ggYnl0ZVxyXG4vKiBmNzczICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgaXRcclxuLyogZjc3NCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInN0YWwrMF8wMGMxXCIpOyAgICAgIC8vIGdldCBJL08gc3RhcnQgYWRkcmVzcyBsb3cgYnl0ZVxyXG4vKiBmNzc2ICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgaXRcclxuLyogZjc3NyAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImVhbCsxXzAwYWZcIik7ICAgICAgIC8vIGdldCB0YXBlIGVuZCBhZGRyZXNzIGhpZ2ggYnl0ZVxyXG4vKiBmNzc5ICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgaXRcclxuLyogZjc3YSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImVhbCswXzAwYWVcIik7ICAgICAgIC8vIGdldCB0YXBlIGVuZCBhZGRyZXNzIGxvdyBieXRlXHJcbi8qIGY3N2MgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBpdFxyXG4vKiBmNzdkICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4YmYpOyAgICAgICAgICAgICAgIC8vIGluZGV4IHRvIGhlYWRlciBlbmRcclxuLyogZjc3ZiAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDIwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBieXRlLCBbU1BBQ0VdXHJcbi8qIGY3ODEgKi8gICAgICAgIF9gX2Y3ODFgOyAgU1RBLmlueSAoXCJ0YXBlMSswXzAwYjJcIik7ICAgICAvLyBjbGVhciBoZWFkZXIgYnl0ZVxyXG4vKiBmNzgzICovICAgICAgICAgICAgICAgICAgIERFWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCBpbmRleFxyXG4vKiBmNzg0ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2Y3ODFcIik7ICAgICAgICAgICAgLy8gbG9vcCBpZiBtb3JlIHRvIGRvXHJcbi8qIGY3ODYgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJwdHIxXzAwOWVcIik7ICAgICAgICAvLyBnZXQgdGhlIGhlYWRlciB0eXBlIGJhY2tcclxuLyogZjc4OCAqLyAgICAgICAgICAgICAgICAgICBTVEEuaW55IChcInRhcGUxKzBfMDBiMlwiKTsgICAgIC8vIHdyaXRlIGl0IHRvIGhlYWRlclxyXG4vKiBmNzhhICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCB0aGUgaW5kZXhcclxuLyogZjc4YiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInN0YWwrMF8wMGMxXCIpOyAgICAgIC8vIGdldCB0aGUgSS9PIHN0YXJ0IGFkZHJlc3MgbG93IGJ5dGVcclxuLyogZjc4ZCAqLyAgICAgICAgICAgICAgICAgICBTVEEuaW55IChcInRhcGUxKzBfMDBiMlwiKTsgICAgIC8vIHdyaXRlIGl0IHRvIGhlYWRlclxyXG4vKiBmNzhmICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCB0aGUgaW5kZXhcclxuLyogZjc5MCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInN0YWwrMV8wMGMyXCIpOyAgICAgIC8vIGdldCB0aGUgSS9PIHN0YXJ0IGFkZHJlc3MgaGlnaCBieXRlXHJcbi8qIGY3OTIgKi8gICAgICAgICAgICAgICAgICAgU1RBLmlueSAoXCJ0YXBlMSswXzAwYjJcIik7ICAgICAvLyB3cml0ZSBpdCB0byBoZWFkZXJcclxuLyogZjc5NCAqLyAgICAgICAgICAgICAgICAgICBJTlkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgdGhlIGluZGV4XHJcbi8qIGY3OTUgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJlYWwrMF8wMGFlXCIpOyAgICAgICAvLyBnZXQgdGhlIHRhcGUgZW5kIGFkZHJlc3MgbG93IGJ5dGVcclxuLyogZjc5NyAqLyAgICAgICAgICAgICAgICAgICBTVEEuaW55IChcInRhcGUxKzBfMDBiMlwiKTsgICAgIC8vIHdyaXRlIGl0IHRvIGhlYWRlclxyXG4vKiBmNzk5ICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCB0aGUgaW5kZXhcclxuLyogZjc5YSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImVhbCsxXzAwYWZcIik7ICAgICAgIC8vIGdldCB0aGUgdGFwZSBlbmQgYWRkcmVzcyBoaWdoIGJ5dGVcclxuLyogZjc5YyAqLyAgICAgICAgICAgICAgICAgICBTVEEuaW55IChcInRhcGUxKzBfMDBiMlwiKTsgICAgIC8vIHdyaXRlIGl0IHRvIGhlYWRlclxyXG4vKiBmNzllICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCB0aGUgaW5kZXhcclxuLyogZjc5ZiAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcInB0cjJfMDA5ZlwiKTsgICAgICAgIC8vIHNhdmUgdGhlIGluZGV4XHJcbi8qIGY3YTEgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgWVxyXG4vKiBmN2EzICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwicHRyMV8wMDllXCIpOyAgICAgICAgLy8gY2xlYXIgdGhlIG5hbWUgaW5kZXhcclxuLyogZjdhNSAqLyAgICAgICAgX2BfZjdhNWA7ICBMRFkuenBnIChcInB0cjFfMDA5ZVwiKTsgICAgICAgIC8vIGdldCBuYW1lIGluZGV4XHJcbi8qIGY3YTcgKi8gICAgICAgICAgICAgICAgICAgQ1BZLnpwZyAoXCJmbmxlbl8wMGI3XCIpOyAgICAgICAvLyBjb21wYXJlIHdpdGggZmlsZSBuYW1lIGxlbmd0aFxyXG4vKiBmN2E5ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2Y3YjdcIik7ICAgICAgICAgICAgLy8gaWYgYWxsIGRvbmUgZXhpdCB0aGUgbG9vcFxyXG4vKiBmN2FiICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwiZm5hZHIrMF8wMGJiXCIpOyAgICAgLy8gZ2V0IGZpbGUgbmFtZSBieXRlXHJcbi8qIGY3YWQgKi8gICAgICAgICAgICAgICAgICAgTERZLnpwZyAoXCJwdHIyXzAwOWZcIik7ICAgICAgICAvLyBnZXQgYnVmZmVyIGluZGV4XHJcbi8qIGY3YWYgKi8gICAgICAgICAgICAgICAgICAgU1RBLmlueSAoXCJ0YXBlMSswXzAwYjJcIik7ICAgICAvLyBzYXZlIGZpbGUgbmFtZSBieXRlIHRvIGJ1ZmZlclxyXG4vKiBmN2IxICovICAgICAgICAgICAgICAgICAgIElOQy56cGcgKFwicHRyMV8wMDllXCIpOyAgICAgICAgLy8gaW5jcmVtZW50IGZpbGUgbmFtZSBpbmRleFxyXG4vKiBmN2IzICovICAgICAgICAgICAgICAgICAgIElOQy56cGcgKFwicHRyMl8wMDlmXCIpOyAgICAgICAgLy8gaW5jcmVtZW50IHRhcGUgYnVmZmVyIGluZGV4XHJcbi8qIGY3YjUgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZjdhNVwiKTsgICAgICAgICAgICAvLyBsb29wLCBicmFuY2ggYWx3YXlzXHJcbi8qIGY3YjcgKi8gICAgICAgIF9gX2Y3YjdgOyAgSlNSLmFicyAoXCJfZjdkN1wiKTsgICAgICAgICAgICAvLyBzZXQgdGFwZSBidWZmZXIgc3RhcnQgYW5kIGVuZCBwb2ludGVyc1xyXG4vKiBmN2JhICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4NjkpOyAgICAgICAgICAgICAgIC8vIHNldCB3cml0ZSBsZWFkIGN5Y2xlIGNvdW50XHJcbi8qIGY3YmMgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJyaXBydHlfMDBhYlwiKTsgICAgICAvLyBzYXZlIHdyaXRlIGxlYWQgY3ljbGUgY291bnRcclxuLyogZjdiZSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mODZiXCIpOyAgICAgICAgICAgIC8vIGRvIHRhcGUgd3JpdGUsIG5vIGN5Y2xlIGNvdW50IHNldFxyXG4vKiBmN2MxICovICAgICAgICAgICAgICAgICAgIFRBWS5pbXAgKCk7XHJcbi8qIGY3YzIgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVsbCB0YXBlIGVuZCBhZGRyZXNzIGxvdyBieXRlXHJcbi8qIGY3YzMgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJlYWwrMF8wMGFlXCIpOyAgICAgICAvLyByZXN0b3JlIGl0XHJcbi8qIGY3YzUgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVsbCB0YXBlIGVuZCBhZGRyZXNzIGhpZ2ggYnl0ZVxyXG4vKiBmN2M2ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZWFsKzFfMDBhZlwiKTsgICAgICAgLy8gcmVzdG9yZSBpdFxyXG4vKiBmN2M4ICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHB1bGwgSS9PIHN0YXJ0IGFkZHJlc3NlcyBsb3cgYnl0ZVxyXG4vKiBmN2M5ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwic3RhbCswXzAwYzFcIik7ICAgICAgLy8gcmVzdG9yZSBpdFxyXG4vKiBmN2NiICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHB1bGwgSS9PIHN0YXJ0IGFkZHJlc3NlcyBoaWdoIGJ5dGVcclxuLyogZjdjYyAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInN0YWwrMV8wMGMyXCIpOyAgICAgIC8vIHJlc3RvcmUgaXRcclxuLyogZjdjZSAqLyAgICAgICAgICAgICAgICAgICBUWUEuaW1wICgpO1xyXG4vKiBmN2NmICovICAgICAgICBfYF9mN2NmYDsgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGdldCB0aGUgdGFwZSBidWZmZXIgc3RhcnQgcG9pbnRlclxyXG4vKiBmN2QwICovICAgICAgICBfYF9mN2QwYDsgIExEWC56cGcgKFwidGFwZTErMF8wMGIyXCIpOyAgICAgLy8gZ2V0IHRhcGUgYnVmZmVyIHN0YXJ0IHBvaW50ZXIgbG93IGJ5dGVcclxuLyogZjdkMiAqLyAgICAgICAgICAgICAgICAgICBMRFkuenBnIChcInRhcGUxKzFfMDBiM1wiKTsgICAgIC8vIGdldCB0YXBlIGJ1ZmZlciBzdGFydCBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBmN2Q0ICovICAgICAgICAgICAgICAgICAgIENQWS5pbW0gKDB4MDIpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgaGlnaCBieXRlIHdpdGggJDAyeHhcclxuLyogZjdkNiAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzZXQgdGhlIHRhcGUgYnVmZmVyIHN0YXJ0IGFuZCBlbmQgcG9pbnRlcnNcclxuLyogZjdkNyAqLyAgICAgICAgX2BfZjdkN2A7ICBKU1IuYWJzIChcIl9mN2QwXCIpOyAgICAgICAgICAgIC8vIGdldCB0YXBlIGJ1ZmZlciBzdGFydCBwb2ludGVyIGluIFhZXHJcbi8qIGY3ZGEgKi8gICAgICAgICAgICAgICAgICAgVFhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSB0YXBlIGJ1ZmZlciBzdGFydCBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGY3ZGIgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJzdGFsKzBfMDBjMVwiKTsgICAgICAvLyBzYXZlIGFzIEkvTyBhZGRyZXNzIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogZjdkZCAqLyAgICAgICAgICAgICAgICAgICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBjYXJyeSBmb3IgYWRkXHJcbi8qIGY3ZGUgKi8gICAgICAgICAgICAgICAgICAgQURDLmltbSAoMHhjMCk7ICAgICAgICAgICAgICAgLy8gYWRkIGJ1ZmZlciBsZW5ndGggbG93IGJ5dGVcclxuLyogZjdlMCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImVhbCswXzAwYWVcIik7ICAgICAgIC8vIHNhdmUgdGFwZSBidWZmZXIgZW5kIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogZjdlMiAqLyAgICAgICAgICAgICAgICAgICBUWUEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IHRhcGUgYnVmZmVyIHN0YXJ0IHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGY3ZTMgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJzdGFsKzFfMDBjMlwiKTsgICAgICAvLyBzYXZlIGFzIEkvTyBhZGRyZXNzIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGY3ZTUgKi8gICAgICAgICAgICAgICAgICAgQURDLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gYWRkIGJ1ZmZlciBsZW5ndGggaGlnaCBieXRlXHJcbi8qIGY3ZTcgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJlYWwrMV8wMGFmXCIpOyAgICAgICAvLyBzYXZlIHRhcGUgYnVmZmVyIGVuZCBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBmN2U5ICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGZpbmQgc3BlY2lmaWMgdGFwZSBoZWFkZXJcclxuLyogZjdlYSAqLyAgICAgICAgX2BfZjdlYWA7ICBKU1IuYWJzIChcIl9mNzJjXCIpOyAgICAgICAgICAgIC8vIGZpbmQgdGFwZSBoZWFkZXIsIGV4aXQgd2l0aCBoZWFkZXIgaW4gYnVmZmVyXHJcbi8qIGY3ZWQgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfZjgwY1wiKTsgICAgICAgICAgICAvLyBqdXN0IGV4aXQgaWYgZXJyb3JcclxuLyogZjdlZiAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDA1KTsgICAgICAgICAgICAgICAvLyBpbmRleCB0byBuYW1lXHJcbi8qIGY3ZjEgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJwdHIyXzAwOWZcIik7ICAgICAgICAvLyBzYXZlIGFzIHRhcGUgYnVmZmVyIGluZGV4XHJcbi8qIGY3ZjMgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgWVxyXG4vKiBmN2Y1ICovICAgICAgICAgICAgICAgICAgIFNUWS56cGcgKFwicHRyMV8wMDllXCIpOyAgICAgICAgLy8gc2F2ZSBhcyBuYW1lIGJ1ZmZlciBpbmRleFxyXG4vKiBmN2Y3ICovICAgICAgICBfYF9mN2Y3YDsgIENQWS56cGcgKFwiZm5sZW5fMDBiN1wiKTsgICAgICAgLy8gY29tcGFyZSB3aXRoIGZpbGUgbmFtZSBsZW5ndGhcclxuLyogZjdmOSAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mODBiXCIpOyAgICAgICAgICAgIC8vIG9rIGV4aXQgaWYgbWF0Y2hcclxuLyogZjdmYiAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcImZuYWRyKzBfMDBiYlwiKTsgICAgIC8vIGdldCBmaWxlIG5hbWUgYnl0ZVxyXG4vKiBmN2ZkICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwicHRyMl8wMDlmXCIpOyAgICAgICAgLy8gZ2V0IGluZGV4IHRvIHRhcGUgYnVmZmVyXHJcbi8qIGY3ZmYgKi8gICAgICAgICAgICAgICAgICAgQ01QLmlueSAoXCJ0YXBlMSswXzAwYjJcIik7ICAgICAvLyBjb21wYXJlIHdpdGggdGFwZSBoZWFkZXIgbmFtZSBieXRlXHJcbi8qIGY4MDEgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZjdlYVwiKTsgICAgICAgICAgICAvLyBpZiBubyBtYXRjaCBnbyBnZXQgbmV4dCBoZWFkZXJcclxuLyogZjgwMyAqLyAgICAgICAgICAgICAgICAgICBJTkMuenBnIChcInB0cjFfMDA5ZVwiKTsgICAgICAgIC8vIGVsc2UgaW5jcmVtZW50IG5hbWUgYnVmZmVyIGluZGV4XHJcbi8qIGY4MDUgKi8gICAgICAgICAgICAgICAgICAgSU5DLnpwZyAoXCJwdHIyXzAwOWZcIik7ICAgICAgICAvLyBpbmNyZW1lbnQgdGFwZSBidWZmZXIgaW5kZXhcclxuLyogZjgwNyAqLyAgICAgICAgICAgICAgICAgICBMRFkuenBnIChcInB0cjFfMDA5ZVwiKTsgICAgICAgIC8vIGdldCBuYW1lIGJ1ZmZlciBpbmRleFxyXG4vKiBmODA5ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2Y3ZjdcIik7ICAgICAgICAgICAgLy8gbG9vcCwgYnJhbmNoIGFsd2F5c1xyXG4vKiBmODBiICovICAgICAgICBfYF9mODBiYDsgIENMQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGZsYWcgb2tcclxuLyogZjgwYyAqLyAgICAgICAgX2BfZjgwY2A7ICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBidW1wIHRhcGUgcG9pbnRlclxyXG4vKiBmODBkICovICAgICAgICBfYF9mODBkYDsgIEpTUi5hYnMgKFwiX2Y3ZDBcIik7ICAgICAgICAgICAgLy8gZ2V0IHRhcGUgYnVmZmVyIHN0YXJ0IHBvaW50ZXIgaW4gWFlcclxuLyogZjgxMCAqLyAgICAgICAgICAgICAgICAgICBJTkMuenBnIChcImJ1ZnBudF8wMGE2XCIpOyAgICAgIC8vIGluY3JlbWVudCB0YXBlIGJ1ZmZlciBpbmRleFxyXG4vKiBmODEyICovICAgICAgICAgICAgICAgICAgIExEWS56cGcgKFwiYnVmcG50XzAwYTZcIik7ICAgICAgLy8gZ2V0IHRhcGUgYnVmZmVyIGluZGV4XHJcbi8qIGY4MTQgKi8gICAgICAgICAgICAgICAgICAgQ1BZLmltbSAoMHhjMCk7ICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIGJ1ZmZlciBsZW5ndGhcclxuLyogZjgxNiAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyB3YWl0IGZvciBQTEFZXHJcbi8qIGY4MTcgKi8gICAgICAgIF9gX2Y4MTdgOyAgSlNSLmFicyAoXCJfZjgyZVwiKTsgICAgICAgICAgICAvLyByZXR1cm4gY2Fzc2V0dGUgc2Vuc2UgaW4gWmJcclxuLyogZjgxYSAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mODM2XCIpOyAgICAgICAgICAgIC8vIGlmIHN3aXRjaCBjbG9zZWQganVzdCBleGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2Fzc2V0dGUgc3dpdGNoIHdhcyBvcGVuXHJcbi8qIGY4MWMgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgxYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5kZXggdG8gXCJQUkVTUyBQTEFZIE9OIFRBUEVcIlxyXG4vKiBmODFlICovICAgICAgICBfYF9mODFlYDsgIEpTUi5hYnMgKFwiX2YxMmZcIik7ICAgICAgICAgICAgLy8gZGlzcGxheSBrZXJuZWwgSS9PIG1lc3NhZ2VcclxuLyogZjgyMSAqLyAgICAgICAgX2BfZjgyMWA7ICBKU1IuYWJzIChcIl9mOGQwXCIpOyAgICAgICAgICAgIC8vIHNjYW4gc3RvcCBrZXkgYW5kIGZsYWcgYWJvcnQgaWYgcHJlc3NlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdGUgaWYgU1RPUCB3YXMgcHJlc3NlZCB0aGUgcmV0dXJuIGlzIHRvIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJvdXRpbmUgdGhhdCBjYWxsZWQgdGhpcyBvbmUgYW5kIG5vdCBoZXJlXHJcbi8qIGY4MjQgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZjgyZVwiKTsgICAgICAgICAgICAvLyByZXR1cm4gY2Fzc2V0dGUgc2Vuc2UgaW4gWmJcclxuLyogZjgyNyAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mODIxXCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgdGhlIGNhc3NldHRlIHN3aXRjaCBpcyBvcGVuXHJcbi8qIGY4MjkgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHg2YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5kZXggdG8gXCJPS1wiXHJcbi8qIGY4MmIgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZjEyZlwiKTsgICAgICAgICAgICAvLyBkaXNwbGF5IGtlcm5lbCBJL08gbWVzc2FnZSBhbmQgcmV0dXJuXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHJldHVybiBjYXNzZXR0ZSBzZW5zZSBpbiBaYlxyXG4vKiBmODJlICovICAgICAgICBfYF9mODJlYDsgIExEQS5pbW0gKDB4MTApOyAgICAgICAgICAgICAgIC8vIHNldCB0aGUgbWFzayBmb3IgdGhlIGNhc3NldHRlIHN3aXRjaFxyXG4vKiBmODMwICovICAgICAgICAgICAgICAgICAgIEJJVC56cGcgKFwicjY1MTBfMDAwMVwiKTsgICAgICAgLy8gdGVzdCB0aGUgNjUxMCBJL08gcG9ydFxyXG4vKiBmODMyICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2Y4MzZcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIGNhc3NldHRlIHNlbnNlIGhpZ2hcclxuLyogZjgzNCAqLyAgICAgICAgICAgICAgICAgICBCSVQuenBnIChcInI2NTEwXzAwMDFcIik7ICAgICAgIC8vIHRlc3QgdGhlIDY1MTAgSS9PIHBvcnRcclxuLyogZjgzNiAqLyAgICAgICAgX2BfZjgzNmA7ICBDTEMuaW1wICgpO1xyXG4vKiBmODM3ICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHdhaXQgZm9yIFBMQVkvUkVDT1JEXHJcbi8qIGY4MzggKi8gICAgICAgIF9gX2Y4MzhgOyAgSlNSLmFicyAoXCJfZjgyZVwiKTsgICAgICAgICAgICAvLyByZXR1cm4gdGhlIGNhc3NldHRlIHNlbnNlIGluIFpiXHJcbi8qIGY4M2IgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZjgzNlwiKTsgICAgICAgICAgICAvLyBleGl0IGlmIHN3aXRjaCBjbG9zZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNzZXR0ZSBzd2l0Y2ggd2FzIG9wZW5cclxuLyogZjgzZCAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDJlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmRleCB0byBcIlBSRVNTIFJFQ09SRCAmIFBMQVkgT04gVEFQRVwiXHJcbi8qIGY4M2YgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZjgxZVwiKTsgICAgICAgICAgICAvLyBkaXNwbGF5IG1lc3NhZ2UgYW5kIHdhaXQgZm9yIHN3aXRjaCwgYnJhbmNoIGFsd2F5c1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBpbml0aWF0ZSBhIHRhcGUgcmVhZFxyXG4vKiBmODQxICovICAgICAgICBfYF9mODQxYDsgIExEQS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIEFcclxuLyogZjg0MyAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInN0YXR1c18wMDkwXCIpOyAgICAgIC8vIGNsZWFyIHNlcmlhbCBzdGF0dXMgYnl0ZVxyXG4vKiBmODQ1ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwidmVyY2tfMDA5M1wiKTsgICAgICAgLy8gY2xlYXIgdGhlIGxvYWQvdmVyaWZ5IGZsYWdcclxuLyogZjg0NyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mN2Q3XCIpOyAgICAgICAgICAgIC8vIHNldCB0aGUgdGFwZSBidWZmZXIgc3RhcnQgYW5kIGVuZCBwb2ludGVyc1xyXG4vKiBmODRhICovICAgICAgICBfYF9mODRhYDsgIEpTUi5hYnMgKFwiX2Y4MTdcIik7ICAgICAgICAgICAgLy8gd2FpdCBmb3IgUExBWVxyXG4vKiBmODRkICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2Y4NmVcIik7ICAgICAgICAgICAgLy8gZXhpdCBpZiBTVE9QIHdhcyBwcmVzc2VkLCB1c2VzIGEgZnVydGhlciBCQ1MgYXQgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGFyZ2V0IGFkZHJlc3MgdG8gcmVhY2ggZmluYWwgdGFyZ2V0IGF0ICRGOERDXHJcbi8qIGY4NGYgKi8gICAgICAgICAgICAgICAgICAgU0VJLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZGlzYWJsZSBpbnRlcnJ1cHRzXHJcbi8qIGY4NTAgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgQVxyXG4vKiBmODUyICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwicmlkYXRhXzAwYWFcIik7XHJcbi8qIGY4NTQgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJiaXR0c18wMGI0XCIpO1xyXG4vKiBmODU2ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiY21wMCswXzAwYjBcIik7ICAgICAgLy8gY2xlYXIgdGFwZSB0aW1pbmcgY29uc3RhbnQgbWluIGJ5dGVcclxuLyogZjg1OCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInB0cjFfMDA5ZVwiKTsgICAgICAgIC8vIGNsZWFyIHRhcGUgcGFzcyAxIGVycm9yIGxvZy9jaGFyIGJ1ZmZlclxyXG4vKiBmODVhICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwicHRyMl8wMDlmXCIpOyAgICAgICAgLy8gY2xlYXIgdGFwZSBwYXNzIDIgZXJyb3IgbG9nIGNvcnJlY3RlZFxyXG4vKiBmODVjICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZHBzd18wMDljXCIpOyAgICAgICAgLy8gY2xlYXIgYnl0ZSByZWNlaXZlZCBmbGFnXHJcbi8qIGY4NWUgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHg5MCk7ICAgICAgICAgICAgICAgLy8gZW5hYmxlIENBMSBpbnRlcnJ1cHQgPz9cclxuLyogZjg2MCAqLyAgICAgICAgICAgICAgICAgICBMRFguaW1tICgweDBlKTsgICAgICAgICAgICAgICAvLyBzZXQgaW5kZXggZm9yIHRhcGUgcmVhZCB2ZWN0b3JcclxuLyogZjg2MiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mODc1XCIpOyAgICAgICAgICAgIC8vIGdvIGRvIHRhcGUgcmVhZC93cml0ZSwgYnJhbmNoIGFsd2F5c1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBpbml0aWF0ZSBhIHRhcGUgd3JpdGVcclxuLyogZjg2NCAqLyAgICAgICAgX2BfZjg2NGA7ICBKU1IuYWJzIChcIl9mN2Q3XCIpOyAgICAgICAgICAgIC8vIHNldCB0YXBlIGJ1ZmZlciBzdGFydCBhbmQgZW5kIHBvaW50ZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gdGFwZSB3cml0ZSwgMjAgY3ljbGUgY291bnRcclxuLyogZjg2NyAqLyAgICAgICAgX2BfZjg2N2A7ICBMREEuaW1tICgweDE0KTsgICAgICAgICAgICAgICAvLyBzZXQgd3JpdGUgbGVhZCBjeWNsZSBjb3VudFxyXG4vKiBmODY5ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwicmlwcnR5XzAwYWJcIik7ICAgICAgLy8gc2F2ZSB3cml0ZSBsZWFkIGN5Y2xlIGNvdW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gdGFwZSB3cml0ZSwgbm8gY3ljbGUgY291bnQgc2V0XHJcbi8qIGY4NmIgKi8gICAgICAgIF9gX2Y4NmJgOyAgSlNSLmFicyAoXCJfZjgzOFwiKTsgICAgICAgICAgICAvLyB3YWl0IGZvciBQTEFZL1JFQ09SRFxyXG4vKiBmODZlICovICAgICAgICBfYF9mODZlYDsgIEJDUy5yZWwgKFwiX2Y4ZGNcIik7ICAgICAgICAgICAgLy8gaWYgU1RPUHBlZCBjbGVhciBzYXZlIElSUSBhZGRyZXNzIGFuZCBleGl0XHJcbi8qIGY4NzAgKi8gICAgICAgICAgICAgICAgICAgU0VJLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZGlzYWJsZSBpbnRlcnJ1cHRzXHJcbi8qIGY4NzEgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHg4Mik7ICAgICAgICAgICAgICAgLy8gZW5hYmxlID8/IGludGVycnVwdFxyXG4vKiBmODczICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4MDgpOyAgICAgICAgICAgICAgIC8vIHNldCBpbmRleCBmb3IgdGFwZSB3cml0ZSB0YXBlIGxlYWRlciB2ZWN0b3JcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gdGFwZSByZWFkL3dyaXRlXHJcbi8qIGY4NzUgKi8gICAgICAgIF9gX2Y4NzVgOyAgTERZLmltbSAoMHg3Zik7ICAgICAgICAgICAgICAgLy8gZGlzYWJsZSBhbGwgaW50ZXJydXB0c1xyXG4vKiBmODc3ICovICAgICAgICAgICAgICAgICAgIFNUWS5hYnMgKFwiY2lhaWNyX2RjMGRcIik7ICAgICAgLy8gc2F2ZSBWSUEgMSBJQ1IsIGRpc2FibGUgYWxsIGludGVycnVwdHNcclxuLyogZjg3YSAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcImNpYWljcl9kYzBkXCIpOyAgICAgIC8vIHNhdmUgVklBIDEgSUNSLCBlbmFibGUgaW50ZXJydXB0cyBhY2NvcmRpbmcgdG8gQVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIFJTMjMyIGJ1cyBpZGxlXHJcbi8qIGY4N2QgKi8gICAgICAgICAgICAgICAgICAgTERBLmFicyAoXCJjaWFjcmFfZGMwZVwiKTsgICAgICAvLyByZWFkIFZJQSAxIENSQVxyXG4vKiBmODgwICovICAgICAgICAgICAgICAgICAgIE9SQS5pbW0gKDB4MTkpOyAgICAgICAgICAgICAgIC8vIGxvYWQgdGltZXIgQiwgdGltZXIgQiBzaW5nbGUgc2hvdCwgc3RhcnQgdGltZXIgQlxyXG4vKiBmODgyICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiY2lhY3JiX2RjMGZcIik7ICAgICAgLy8gc2F2ZSBWSUEgMSBDUkJcclxuLyogZjg4NSAqLyAgICAgICAgICAgICAgICAgICBBTkQuaW1tICgweDkxKTsgICAgICAgICAgICAgICAvLyBtYXNrIHgwMHggMDAweCwgVE9EIGNsb2NrLCBsb2FkIHRpbWVyIEEsIHN0YXJ0IHRpbWVyIEFcclxuLyogZjg4NyAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcInRvZHNuc18wMmEyXCIpOyAgICAgIC8vIHNhdmUgVklBIDEgQ1JCIHNoYWRvdyBjb3B5XHJcbi8qIGY4OGEgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZjBhNFwiKTtcclxuLyogZjg4ZCAqLyAgICAgICAgICAgICAgICAgICBMREEuYWJzIChcInNjcm9seV9kMDExXCIpOyAgICAgIC8vIHJlYWQgdGhlIHZlcnRpY2FsIGZpbmUgc2Nyb2xsIGFuZCBjb250cm9sIHJlZ2lzdGVyXHJcbi8qIGY4OTAgKi8gICAgICAgICAgICAgICAgICAgQU5ELmltbSAoMHhlZik7ICAgICAgICAgICAgICAgLy8gbWFzayB4eHgwIHh4eHgsIGJsYW5rIHRoZSBzY3JlZW5cclxuLyogZjg5MiAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcInNjcm9seV9kMDExXCIpOyAgICAgIC8vIHNhdmUgdGhlIHZlcnRpY2FsIGZpbmUgc2Nyb2xsIGFuZCBjb250cm9sIHJlZ2lzdGVyXHJcbi8qIGY4OTUgKi8gICAgICAgICAgICAgICAgICAgTERBLmFicyAoXCJjaW52KzBfMDMxNFwiKTsgICAgICAvLyBnZXQgSVJRIHZlY3RvciBsb3cgYnl0ZVxyXG4vKiBmODk4ICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiaXJxdG1wKzBfMDI5ZlwiKTsgICAgLy8gc2F2ZSBJUlEgdmVjdG9yIGxvdyBieXRlXHJcbi8qIGY4OWIgKi8gICAgICAgICAgICAgICAgICAgTERBLmFicyAoXCJjaW52KzFfMDMxNVwiKTsgICAgICAvLyBnZXQgSVJRIHZlY3RvciBoaWdoIGJ5dGVcclxuLyogZjg5ZSAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcImlycXRtcCsxXzAyYTBcIik7ICAgIC8vIHNhdmUgSVJRIHZlY3RvciBoaWdoIGJ5dGVcclxuLyogZjhhMSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mY2JkXCIpOyAgICAgICAgICAgIC8vIHNldCB0aGUgdGFwZSB2ZWN0b3JcclxuLyogZjhhNCAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDAyKTsgICAgICAgICAgICAgICAvLyBzZXQgY29waWVzIGNvdW50LiB0aGUgZmlyc3QgY29weSBpcyB0aGUgbG9hZCBjb3B5LCB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWNvbmQgY29weSBpcyB0aGUgdmVyaWZ5IGNvcHlcclxuLyogZjhhNiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImZzYmxrXzAwYmVcIik7ICAgICAgIC8vIHNhdmUgY29waWVzIGNvdW50XHJcbi8qIGY4YTggKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZmI5N1wiKTsgICAgICAgICAgICAvLyBuZXcgdGFwZSBieXRlIHNldHVwXHJcbi8qIGY4YWIgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJyNjUxMF8wMDAxXCIpOyAgICAgICAvLyByZWFkIHRoZSA2NTEwIEkvTyBwb3J0XHJcbi8qIGY4YWQgKi8gICAgICAgICAgICAgICAgICAgQU5ELmltbSAoMHgxZik7ICAgICAgICAgICAgICAgLy8gbWFzayAwMDB4IHh4eHgsIGNhc3NldHRlIG1vdG9yIG9uID8/XHJcbi8qIGY4YWYgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJyNjUxMF8wMDAxXCIpOyAgICAgICAvLyBzYXZlIHRoZSA2NTEwIEkvTyBwb3J0XHJcbi8qIGY4YjEgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJjYXMxXzAwYzBcIik7ICAgICAgICAvLyBzZXQgdGhlIHRhcGUgbW90b3IgaW50ZXJsb2NrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMzI2NjU2IGN5Y2xlIGRlbGF5LCBhbGxvdyB0YXBlIG1vdG9yIHNwZWVkIHRvIHN0YWJpbGlzZVxyXG4vKiBmOGIzICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4ZmYpOyAgICAgICAgICAgICAgIC8vIG91dGVyIGxvb3AgY291bnRcclxuLyogZjhiNSAqLyAgICAgICAgX2BfZjhiNWA7ICBMRFkuaW1tICgweGZmKTsgICAgICAgICAgICAgICAvLyBpbm5lciBsb29wIGNvdW50XHJcbi8qIGY4YjcgKi8gICAgICAgIF9gX2Y4YjdgOyAgREVZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZGVjcmVtZW50IGlubmVyIGxvb3AgY291bnRcclxuLyogZjhiOCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mOGI3XCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgbW9yZSB0byBkb1xyXG4vKiBmOGJhICovICAgICAgICAgICAgICAgICAgIERFWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCBvdXRlciBsb29wIGNvdW50XHJcbi8qIGY4YmIgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZjhiNVwiKTsgICAgICAgICAgICAvLyBsb29wIGlmIG1vcmUgdG8gZG9cclxuLyogZjhiZCAqLyAgICAgICAgICAgICAgICAgICBDTEkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBlbmFibGUgdGFwZSBpbnRlcnJ1cHRzXHJcbi8qIGY4YmUgKi8gICAgICAgIF9gX2Y4YmVgOyAgTERBLmFicyAoXCJpcnF0bXArMV8wMmEwXCIpOyAgICAvLyBnZXQgc2F2ZWQgSVJRIGhpZ2ggYnl0ZVxyXG4vKiBmOGMxICovICAgICAgICAgICAgICAgICAgIENNUC5hYnMgKFwiY2ludisxXzAzMTVcIik7ICAgICAgLy8gY29tcGFyZSB3aXRoIHRoZSBjdXJyZW50IElSUSBoaWdoIGJ5dGVcclxuLyogZjhjNCAqLyAgICAgICAgICAgICAgICAgICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBmbGFnIG9rXHJcbi8qIGY4YzUgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZjhkY1wiKTsgICAgICAgICAgICAvLyBpZiB0YXBlIHdyaXRlIGRvbmUgZ28gY2xlYXIgc2F2ZWQgSVJRIGFkZHJlc3MgYW5kIGV4aXRcclxuLyogZjhjNyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mOGQwXCIpOyAgICAgICAgICAgIC8vIHNjYW4gc3RvcCBrZXkgYW5kIGZsYWcgYWJvcnQgaWYgcHJlc3NlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdGUgaWYgU1RPUCB3YXMgcHJlc3NlZCB0aGUgcmV0dXJuIGlzIHRvIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJvdXRpbmUgdGhhdCBjYWxsZWQgdGhpcyBvbmUgYW5kIG5vdCBoZXJlXHJcbi8qIGY4Y2EgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZjZiY1wiKTsgICAgICAgICAgICAvLyBpbmNyZW1lbnQgcmVhbCB0aW1lIGNsb2NrXHJcbi8qIGY4Y2QgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZjhiZVwiKTsgICAgICAgICAgICAvLyBsb29wXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHNjYW4gc3RvcCBrZXkgYW5kIGZsYWcgYWJvcnQgaWYgcHJlc3NlZFxyXG4vKiBmOGQwICovICAgICAgICBfYF9mOGQwYDsgIEpTUi5hYnMgKFwic3RvcF9mZmUxXCIpOyAgICAgICAgLy8gc2NhbiBzdG9wIGtleVxyXG4vKiBmOGQzICovICAgICAgICAgICAgICAgICAgIENMQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGZsYWcgbm8gc3RvcFxyXG4vKiBmOGQ0ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2Y4ZTFcIik7ICAgICAgICAgICAgLy8gZXhpdCBpZiBubyBzdG9wXHJcbi8qIGY4ZDYgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZmM5M1wiKTsgICAgICAgICAgICAvLyByZXN0b3JlIGV2ZXJ5dGhpbmcgZm9yIFNUT1BcclxuLyogZjhkOSAqLyAgICAgICAgICAgICAgICAgICBTRUMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBmbGFnIHN0b3BwZWRcclxuLyogZjhkYSAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBkdW1wIHJldHVybiBhZGRyZXNzIGxvdyBieXRlXHJcbi8qIGY4ZGIgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZHVtcCByZXR1cm4gYWRkcmVzcyBoaWdoIGJ5dGVcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY2xlYXIgc2F2ZWQgSVJRIGFkZHJlc3NcclxuLyogZjhkYyAqLyAgICAgICAgX2BfZjhkY2A7ICBMREEuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBBXHJcbi8qIGY4ZGUgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJpcnF0bXArMV8wMmEwXCIpOyAgICAvLyBjbGVhciBzYXZlZCBJUlEgYWRkcmVzcyBoaWdoIGJ5dGVcclxuLyogZjhlMSAqLyAgICAgICAgX2BfZjhlMWA7ICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyAjIHNldCB0aW1pbmdcclxuLyogZjhlMiAqLyAgICAgICAgX2BfZjhlMmA7ICBTVFguenBnIChcImNtcDArMV8wMGIxXCIpOyAgICAgIC8vIHNhdmUgdGFwZSB0aW1pbmcgY29uc3RhbnQgbWF4IGJ5dGVcclxuLyogZjhlNCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImNtcDArMF8wMGIwXCIpOyAgICAgIC8vIGdldCB0YXBlIHRpbWluZyBjb25zdGFudCBtaW4gYnl0ZVxyXG4vKiBmOGU2ICovICAgICAgICAgICAgICAgICAgIEFTTC5hY2MgKCk7ICAgICAgICAgICAgICAgICAgIC8vICoyXHJcbi8qIGY4ZTcgKi8gICAgICAgICAgICAgICAgICAgQVNMLmFjYyAoKTsgICAgICAgICAgICAgICAgICAgLy8gKjRcclxuLyogZjhlOCAqLyAgICAgICAgICAgICAgICAgICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBjYXJyeSBmb3IgYWRkXHJcbi8qIGY4ZTkgKi8gICAgICAgICAgICAgICAgICAgQURDLnpwZyAoXCJjbXAwKzBfMDBiMFwiKTsgICAgICAvLyBhZGQgdGFwZSB0aW1pbmcgY29uc3RhbnQgbWluIGJ5dGUgKjVcclxuLyogZjhlYiAqLyAgICAgICAgICAgICAgICAgICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBjYXJyeSBmb3IgYWRkXHJcbi8qIGY4ZWMgKi8gICAgICAgICAgICAgICAgICAgQURDLnpwZyAoXCJjbXAwKzFfMDBiMVwiKTsgICAgICAvLyBhZGQgdGFwZSB0aW1pbmcgY29uc3RhbnQgbWF4IGJ5dGVcclxuLyogZjhlZSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImNtcDArMV8wMGIxXCIpOyAgICAgIC8vIHNhdmUgdGFwZSB0aW1pbmcgY29uc3RhbnQgbWF4IGJ5dGVcclxuLyogZjhmMCAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDAwKTtcclxuLyogZjhmMiAqLyAgICAgICAgICAgICAgICAgICBCSVQuenBnIChcImNtcDArMF8wMGIwXCIpOyAgICAgIC8vIHRlc3QgdGFwZSB0aW1pbmcgY29uc3RhbnQgbWluIGJ5dGVcclxuLyogZjhmNCAqLyAgICAgICAgICAgICAgICAgICBCTUkucmVsIChcIl9mOGY3XCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBiNyBzZXRcclxuLyogZjhmNiAqLyAgICAgICAgICAgICAgICAgICBST0wuYWNjICgpOyAgICAgICAgICAgICAgICAgICAvLyBlbHNlIHNoaWZ0IGNhcnJ5IGludG8gPz9cclxuLyogZjhmNyAqLyAgICAgICAgX2BfZjhmN2A7ICBBU0wuenBnIChcImNtcDArMV8wMGIxXCIpOyAgICAgIC8vIHNoaWZ0IHRhcGUgdGltaW5nIGNvbnN0YW50IG1heCBieXRlXHJcbi8qIGY4ZjkgKi8gICAgICAgICAgICAgICAgICAgUk9MLmFjYyAoKTtcclxuLyogZjhmYSAqLyAgICAgICAgICAgICAgICAgICBBU0wuenBnIChcImNtcDArMV8wMGIxXCIpOyAgICAgIC8vIHNoaWZ0IHRhcGUgdGltaW5nIGNvbnN0YW50IG1heCBieXRlXHJcbi8qIGY4ZmMgKi8gICAgICAgICAgICAgICAgICAgUk9MLmFjYyAoKTtcclxuLyogZjhmZCAqLyAgICAgICAgICAgICAgICAgICBUQVguaW1wICgpO1xyXG4vKiBmOGZlICovICAgICAgICBfYF9mOGZlYDsgIExEQS5hYnMgKFwidGltYmxvX2RjMDZcIik7ICAgICAgLy8gZ2V0IFZJQSAxIHRpbWVyIEIgbG93IGJ5dGVcclxuLyogZjkwMSAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW1tICgweDE2KTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggPz9cclxuLyogZjkwMyAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9mOGZlXCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgbGVzc1xyXG4vKiBmOTA1ICovICAgICAgICAgICAgICAgICAgIEFEQy56cGcgKFwiY21wMCsxXzAwYjFcIik7ICAgICAgLy8gYWRkIHRhcGUgdGltaW5nIGNvbnN0YW50IG1heCBieXRlXHJcbi8qIGY5MDcgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJ0aW1hbG9fZGMwNFwiKTsgICAgICAvLyBzYXZlIFZJQSAxIHRpbWVyIEEgbG93IGJ5dGVcclxuLyogZjkwYSAqLyAgICAgICAgICAgICAgICAgICBUWEEuaW1wICgpO1xyXG4vKiBmOTBiICovICAgICAgICAgICAgICAgICAgIEFEQy5hYnMgKFwidGltYmhpX2RjMDdcIik7ICAgICAgLy8gYWRkIFZJQSAxIHRpbWVyIEIgaGlnaCBieXRlXHJcbi8qIGY5MGUgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJ0aW1haGlfZGMwNVwiKTsgICAgICAvLyBzYXZlIFZJQSAxIHRpbWVyIEEgaGlnaCBieXRlXHJcbi8qIGY5MTEgKi8gICAgICAgICAgICAgICAgICAgTERBLmFicyAoXCJ0b2RzbnNfMDJhMlwiKTsgICAgICAvLyByZWFkIFZJQSAxIENSQiBzaGFkb3cgY29weVxyXG4vKiBmOTE0ICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiY2lhY3JhX2RjMGVcIik7ICAgICAgLy8gc2F2ZSBWSUEgMSBDUkFcclxuLyogZjkxNyAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcInRkMWlycV8wMmE0XCIpOyAgICAgIC8vIHNhdmUgVklBIDEgQ1JBIHNoYWRvdyBjb3B5XHJcbi8qIGY5MWEgKi8gICAgICAgICAgICAgICAgICAgTERBLmFicyAoXCJjaWFpY3JfZGMwZFwiKTsgICAgICAvLyByZWFkIFZJQSAxIElDUlxyXG4vKiBmOTFkICovICAgICAgICAgICAgICAgICAgIEFORC5pbW0gKDB4MTApOyAgICAgICAgICAgICAgIC8vIG1hc2sgMDAweCAwMDAwLCBGTEFHIGludGVycnVwdFxyXG4vKiBmOTFmICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2Y5MmFcIik7ICAgICAgICAgICAgLy8gaWYgbm8gRkxBRyBpbnRlcnJ1cHQganVzdCBleGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBmaXJzdCBjYWxsIHRoZSBJUlEgcm91dGluZVxyXG4vKiBmOTIxICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4ZjkpOyAgICAgICAgICAgICAgIC8vIHNldCB0aGUgcmV0dXJuIGFkZHJlc3MgaGlnaCBieXRlXHJcbi8qIGY5MjMgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVzaCB0aGUgcmV0dXJuIGFkZHJlc3MgaGlnaCBieXRlXHJcbi8qIGY5MjQgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgyYSk7ICAgICAgICAgICAgICAgLy8gc2V0IHRoZSByZXR1cm4gYWRkcmVzcyBsb3cgYnl0ZVxyXG4vKiBmOTI2ICovICAgICAgICAgICAgICAgICAgIFBIQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggdGhlIHJldHVybiBhZGRyZXNzIGxvdyBieXRlXHJcbi8qIGY5MjcgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZmY0M1wiKTsgICAgICAgICAgICAvLyBzYXZlIHRoZSBzdGF0dXMgYW5kIGRvIHRoZSBJUlEgcm91dGluZVxyXG4vKiBmOTJhICovICAgICAgICBfYF9mOTJhYDsgIENMSS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGVuYWJsZSBpbnRlcnJ1cHRzXHJcbi8qIGY5MmIgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gT24gQ29tbW9kb3JlIGNvbXB1dGVycywgdGhlIHN0cmVhbXMgY29uc2lzdCBvZiBmb3VyIGtpbmRzIG9mIHN5bWJvbHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IGRlbm90ZSBkaWZmZXJlbnQga2luZHMgb2YgbG93LXRvLWhpZ2gtdG8tbG93IHRyYW5zaXRpb25zIG9uIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlYWQgb3Igd3JpdGUgc2lnbmFscyBvZiB0aGUgQ29tbW9kb3JlIGNhc3NldHRlIGludGVyZmFjZS5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSBBIGJyZWFrIGluIHRoZSBjb21tdW5pY2F0aW9ucywgb3IgYSBwdWxzZSB3aXRoIHZlcnkgbG9uZyBjeWNsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgdGltZS5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQiBBIHNob3J0IHB1bHNlLCB3aG9zZSBjeWNsZSB0aW1lIHR5cGljYWxseSByYW5nZXMgZnJvbSAyOTYgdG8gNDI0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBtaWNyb3NlY29uZHMsIGRlcGVuZGluZyBvbiB0aGUgY29tcHV0ZXIgbW9kZWwuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEMgQSBtZWRpdW0tbGVuZ3RoIHB1bHNlLCB3aG9zZSBjeWNsZSB0aW1lIHR5cGljYWxseSByYW5nZXMgZnJvbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgNDQwIHRvIDU3NiBtaWNyb3NlY29uZHMsIGRlcGVuZGluZyBvbiB0aGUgY29tcHV0ZXIgbW9kZWwuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEQgQSBsb25nIHB1bHNlLCB3aG9zZSBjeWNsZSB0aW1lIHR5cGljYWxseSByYW5nZXMgZnJvbSA2MDAgdG8gNzQ0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBtaWNyb3NlY29uZHMsIGRlcGVuZGluZyBvbiB0aGUgY29tcHV0ZXIgbW9kZWwuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBUaGUgYWN0dWFsIGludGVycHJldGF0aW9uIG9mIHRoZSBzZXJpYWwgZGF0YSB0YWtlcyBhIGxpdHRsZSBtb3JlIHdvcmsgdG8gZXhwbGFpbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdHlwaWNhbCBST00gdGFwZSBsb2FkZXIgKGFuZCB0aGUgdHVyYm8gbG9hZGVycykgd2lsbCBpbml0aWFsaXplIGEgdGltZXIgd2l0aCBhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIHZhbHVlIGFuZCBzdGFydCBpdCBjb3VudGluZyBkb3duLiBJZiBlaXRoZXIgdGhlIHRhcGUgZGF0YSBjaGFuZ2VzIG9yIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRpbWVyIHJ1bnMgb3V0LCBhbiBJUlEgd2lsbCBvY2N1ci4gVGhlIGxvYWRlciB3aWxsIGRldGVybWluZSB3aGljaCBjb25kaXRpb24gY2F1c2VkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIElSUS4gSWYgdGhlIHRhcGUgZGF0YSBjaGFuZ2VkIGJlZm9yZSB0aGUgdGltZXIgcmFuIG91dCwgd2UgaGF2ZSBhIHNob3J0IHB1bHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIGEgXCIwXCIgYml0LiBJZiB0aGUgdGltZXIgcmFuIG91dCBmaXJzdCwgd2UgaGF2ZSBhIGxvbmcgcHVsc2UsIG9yIGEgXCIxXCIgYml0LiBEb2luZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY29udGludW91c2x5IGFuZCB3ZSBkZWNvZGUgdGhlIGVudGlyZSBmaWxlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlYWQgdGFwZSBiaXRzLCBJUlEgcm91dGluZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlYWQgVDJDIHdoaWNoIGhhcyBiZWVuIGNvdW50aW5nIGRvd24gZnJvbSAkRkZGRi4gc3VidHJhY3QgdGhpcyBmcm9tICRGRkZGXHJcbi8qIGY5MmMgKi8gICAgICAgIF9gX2Y5MmNgOyAgTERYLmFicyAoXCJ0aW1iaGlfZGMwN1wiKTsgICAgICAvLyByZWFkIFZJQSAxIHRpbWVyIEIgaGlnaCBieXRlXHJcbi8qIGY5MmYgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHhmZik7ICAgICAgICAgICAgICAgLy8gc2V0ICRGRlxyXG4vKiBmOTMxICovICAgICAgICAgICAgICAgICAgIFRZQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIEEgPSAkRkZcclxuLyogZjkzMiAqLyAgICAgICAgICAgICAgICAgICBTQkMuYWJzIChcInRpbWJsb19kYzA2XCIpOyAgICAgIC8vIHN1YnRyYWN0IFZJQSAxIHRpbWVyIEIgbG93IGJ5dGVcclxuLyogZjkzNSAqLyAgICAgICAgICAgICAgICAgICBDUFguYWJzIChcInRpbWJoaV9kYzA3XCIpOyAgICAgIC8vIGNvbXBhcmUgaXQgd2l0aCBWSUEgMSB0aW1lciBCIGhpZ2ggYnl0ZVxyXG4vKiBmOTM4ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2Y5MmNcIik7ICAgICAgICAgICAgLy8gaWYgdGltZXIgbG93IGJ5dGUgcm9sbGVkIG92ZXIgbG9vcFxyXG4vKiBmOTNhICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwiY21wMCsxXzAwYjFcIik7ICAgICAgLy8gc2F2ZSB0YXBlIHRpbWluZyBjb25zdGFudCBtYXggYnl0ZVxyXG4vKiBmOTNjICovICAgICAgICAgICAgICAgICAgIFRBWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgJEZGIC0gVDJDX2xcclxuLyogZjkzZCAqLyAgICAgICAgICAgICAgICAgICBTVFkuYWJzIChcInRpbWJsb19kYzA2XCIpOyAgICAgIC8vIHNhdmUgVklBIDEgdGltZXIgQiBsb3cgYnl0ZVxyXG4vKiBmOTQwICovICAgICAgICAgICAgICAgICAgIFNUWS5hYnMgKFwidGltYmhpX2RjMDdcIik7ICAgICAgLy8gc2F2ZSBWSUEgMSB0aW1lciBCIGhpZ2ggYnl0ZVxyXG4vKiBmOTQzICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MTkpOyAgICAgICAgICAgICAgIC8vIGxvYWQgdGltZXIgQiwgdGltZXIgQiBzaW5nbGUgc2hvdCwgc3RhcnQgdGltZXIgQlxyXG4vKiBmOTQ1ICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiY2lhY3JiX2RjMGZcIik7ICAgICAgLy8gc2F2ZSBWSUEgMSBDUkJcclxuLyogZjk0OCAqLyAgICAgICAgICAgICAgICAgICBMREEuYWJzIChcImNpYWljcl9kYzBkXCIpOyAgICAgIC8vIHJlYWQgVklBIDEgSUNSXHJcbi8qIGY5NGIgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJ0cmR0bXBfMDJhM1wiKTsgICAgICAvLyBzYXZlIFZJQSAxIElDUiBzaGFkb3cgY29weVxyXG4vKiBmOTRlICovICAgICAgICAgICAgICAgICAgIFRZQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHkgPSAkRkZcclxuLyogZjk0ZiAqLyAgICAgICAgICAgICAgICAgICBTQkMuenBnIChcImNtcDArMV8wMGIxXCIpOyAgICAgIC8vIHN1YnRyYWN0IHRhcGUgdGltaW5nIGNvbnN0YW50IG1heCBieXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSA9ICRGRiAtIFQyQ19oXHJcbi8qIGY5NTEgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJjbXAwKzFfMDBiMVwiKTsgICAgICAvLyBzYXZlIHRhcGUgdGltaW5nIGNvbnN0YW50IG1heCBieXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJEIxID0gJEZGIC0gVDJDX2xcclxuLyogZjk1MyAqLyAgICAgICAgICAgICAgICAgICBMU1IuYWNjICgpOyAgICAgICAgICAgICAgICAgICAvLyBBID0gJEZGIC0gVDJDX2ggPj4gMVxyXG4vKiBmOTU0ICovICAgICAgICAgICAgICAgICAgIFJPUi56cGcgKFwiY21wMCsxXzAwYjFcIik7ICAgICAgLy8gc2hpZnQgdGFwZSB0aW1pbmcgY29uc3RhbnQgbWF4IGJ5dGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAkQjEgPSAkRkYgLSBUMkNfbCA+PiAxXHJcbi8qIGY5NTYgKi8gICAgICAgICAgICAgICAgICAgTFNSLmFjYyAoKTsgICAgICAgICAgICAgICAgICAgLy8gQSA9ICRGRiAtIFQyQ19oID4+IDFcclxuLyogZjk1NyAqLyAgICAgICAgICAgICAgICAgICBST1IuenBnIChcImNtcDArMV8wMGIxXCIpOyAgICAgIC8vIHNoaWZ0IHRhcGUgdGltaW5nIGNvbnN0YW50IG1heCBieXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJEIxID0gJEZGIC0gVDJDX2wgPj4gMVxyXG4vKiBmOTU5ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiY21wMCswXzAwYjBcIik7ICAgICAgLy8gZ2V0IHRhcGUgdGltaW5nIGNvbnN0YW50IG1pbiBieXRlXHJcbi8qIGY5NWIgKi8gICAgICAgICAgICAgICAgICAgQ0xDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgY2FycnkgZm9yIGFkZFxyXG4vKiBmOTVjICovICAgICAgICAgICAgICAgICAgIEFEQy5pbW0gKDB4M2MpO1xyXG4vKiBmOTVlICovICAgICAgICAgICAgICAgICAgIENNUC56cGcgKFwiY21wMCsxXzAwYjFcIik7ICAgICAgLy8gY29tcGFyZSB3aXRoIHRhcGUgdGltaW5nIGNvbnN0YW50IG1heCBieXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoICgkRkZGRiAtIFQyQykgPj4gMlxyXG4vKiBmOTYwICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2Y5YWNcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG1pbiArICQzQyA+PSAoJEZGRkYgLSBUMkMpID4+IDJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtaW4gKyAkM0MgPCAoJEZGRkYgLSBUMkMpID4+IDJcclxuLyogZjk2MiAqLyAgICAgICAgICAgICAgICAgICBMRFguenBnIChcImRwc3dfMDA5Y1wiKTsgICAgICAgIC8vIGdldCBieXRlIHJlY2VpdmVkIGZsYWdcclxuLyogZjk2NCAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mOTY5XCIpOyAgICAgICAgICAgIC8vICBpZiBub3QgYnl0ZSByZWNlaXZlZCA/P1xyXG4vKiBmOTY2ICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2ZhNjBcIik7ICAgICAgICAgICAgLy8gc3RvcmUgdGhlIHRhcGUgY2hhcmFjdGVyXHJcbi8qIGY5NjkgKi8gICAgICAgIF9gX2Y5NjlgOyAgTERYLnpwZyAoXCJ0c2ZjbnRfMDBhM1wiKTsgICAgICAvLyBnZXQgRU9JIGZsYWcgYnl0ZVxyXG4vKiBmOTZiICovICAgICAgICAgICAgICAgICAgIEJNSS5yZWwgKFwiX2Y5ODhcIik7XHJcbi8qIGY5NmQgKi8gICAgICAgICAgICAgICAgICAgTERYLmltbSAoMHgwMCk7XHJcbi8qIGY5NmYgKi8gICAgICAgICAgICAgICAgICAgQURDLmltbSAoMHgzMCk7XHJcbi8qIGY5NzEgKi8gICAgICAgICAgICAgICAgICAgQURDLnpwZyAoXCJjbXAwKzBfMDBiMFwiKTsgICAgICAvLyBhZGQgdGFwZSB0aW1pbmcgY29uc3RhbnQgbWluIGJ5dGVcclxuLyogZjk3MyAqLyAgICAgICAgICAgICAgICAgICBDTVAuenBnIChcImNtcDArMV8wMGIxXCIpOyAgICAgIC8vIGNvbXBhcmUgd2l0aCB0YXBlIHRpbWluZyBjb25zdGFudCBtYXggYnl0ZVxyXG4vKiBmOTc1ICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2Y5OTNcIik7XHJcbi8qIGY5NzcgKi8gICAgICAgICAgICAgICAgICAgSU5YLmltcCAoKTtcclxuLyogZjk3OCAqLyAgICAgICAgICAgICAgICAgICBBREMuaW1tICgweDI2KTtcclxuLyogZjk3YSAqLyAgICAgICAgICAgICAgICAgICBBREMuenBnIChcImNtcDArMF8wMGIwXCIpOyAgICAgIC8vIGFkZCB0YXBlIHRpbWluZyBjb25zdGFudCBtaW4gYnl0ZVxyXG4vKiBmOTdjICovICAgICAgICAgICAgICAgICAgIENNUC56cGcgKFwiY21wMCsxXzAwYjFcIik7ICAgICAgLy8gY29tcGFyZSB3aXRoIHRhcGUgdGltaW5nIGNvbnN0YW50IG1heCBieXRlXHJcbi8qIGY5N2UgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfZjk5N1wiKTtcclxuLyogZjk4MCAqLyAgICAgICAgICAgICAgICAgICBBREMuaW1tICgweDJjKTtcclxuLyogZjk4MiAqLyAgICAgICAgICAgICAgICAgICBBREMuenBnIChcImNtcDArMF8wMGIwXCIpOyAgICAgIC8vIGFkZCB0YXBlIHRpbWluZyBjb25zdGFudCBtaW4gYnl0ZVxyXG4vKiBmOTg0ICovICAgICAgICAgICAgICAgICAgIENNUC56cGcgKFwiY21wMCsxXzAwYjFcIik7ICAgICAgLy8gY29tcGFyZSB3aXRoIHRhcGUgdGltaW5nIGNvbnN0YW50IG1heCBieXRlXHJcbi8qIGY5ODYgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfZjk4YlwiKTtcclxuLyogZjk4OCAqLyAgICAgICAgX2BfZjk4OGA7ICBKTVAuYWJzIChcIl9mYTEwXCIpO1xyXG4vKiBmOThiICovICAgICAgICBfYF9mOThiYDsgIExEQS56cGcgKFwiYml0dHNfMDBiNFwiKTsgICAgICAgLy8gZ2V0IHRoZSBiaXQgY291bnRcclxuLyogZjk4ZCAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mOWFjXCIpOyAgICAgICAgICAgIC8vIGlmIGFsbCBkb25lIGdvID8/XHJcbi8qIGY5OGYgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJiaXRjaV8wMGE4XCIpOyAgICAgICAvLyBzYXZlIHJlY2VpdmVyIGJpdCBjb3VudCBpblxyXG4vKiBmOTkxICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2Y5YWNcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGFsd2F5c1xyXG4vKiBmOTkzICovICAgICAgICBfYF9mOTkzYDsgIElOQy56cGcgKFwicmlub25lXzAwYTlcIik7ICAgICAgLy8gaW5jcmVtZW50ID8/IHN0YXJ0IGJpdCBjaGVjayBmbGFnXHJcbi8qIGY5OTUgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfZjk5OVwiKTtcclxuLyogZjk5NyAqLyAgICAgICAgX2BfZjk5N2A7ICBERUMuenBnIChcInJpbm9uZV8wMGE5XCIpOyAgICAgIC8vIGRlY3JlbWVudCA/PyBzdGFydCBiaXQgY2hlY2sgZmxhZ1xyXG4vKiBmOTk5ICovICAgICAgICBfYF9mOTk5YDsgIFNFQy5pbXAgKCk7XHJcbi8qIGY5OWEgKi8gICAgICAgICAgICAgICAgICAgU0JDLmltbSAoMHgxMyk7XHJcbi8qIGY5OWMgKi8gICAgICAgICAgICAgICAgICAgU0JDLnpwZyAoXCJjbXAwKzFfMDBiMVwiKTsgICAgICAvLyBzdWJ0cmFjdCB0YXBlIHRpbWluZyBjb25zdGFudCBtYXggYnl0ZVxyXG4vKiBmOTllICovICAgICAgICAgICAgICAgICAgIEFEQy56cGcgKFwic3Z4dF8wMDkyXCIpOyAgICAgICAgLy8gYWRkIHRpbWluZyBjb25zdGFudCBmb3IgdGFwZVxyXG4vKiBmOWEwICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwic3Z4dF8wMDkyXCIpOyAgICAgICAgLy8gc2F2ZSB0aW1pbmcgY29uc3RhbnQgZm9yIHRhcGVcclxuLyogZjlhMiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInRidGNudF8wMGE0XCIpOyAgICAgIC8vIGdldCB0YXBlIGJpdCBjeWNsZSBwaGFzZVxyXG4vKiBmOWE0ICovICAgICAgICAgICAgICAgICAgIEVPUi5pbW0gKDB4MDEpO1xyXG4vKiBmOWE2ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwidGJ0Y250XzAwYTRcIik7ICAgICAgLy8gc2F2ZSB0YXBlIGJpdCBjeWNsZSBwaGFzZVxyXG4vKiBmOWE4ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2Y5ZDVcIik7XHJcbi8qIGY5YWEgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJzY2hhcl8wMGQ3XCIpO1xyXG4vKiBmOWFjICovICAgICAgICBfYF9mOWFjYDsgIExEQS56cGcgKFwiYml0dHNfMDBiNFwiKTsgICAgICAgLy8gZ2V0IHRoZSBiaXQgY291bnRcclxuLyogZjlhZSAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mOWQyXCIpOyAgICAgICAgICAgIC8vIGlmIGFsbCBkb25lIGdvID8/XHJcbi8qIGY5YjAgKi8gICAgICAgICAgICAgICAgICAgTERBLmFicyAoXCJ0cmR0bXBfMDJhM1wiKTsgICAgICAvLyByZWFkIFZJQSAxIElDUiBzaGFkb3cgY29weVxyXG4vKiBmOWIzICovICAgICAgICAgICAgICAgICAgIEFORC5pbW0gKDB4MDEpOyAgICAgICAgICAgICAgIC8vIG1hc2sgMDAwMCAwMDB4LCB0aW1lciBBIGludGVycnVwdCBlbmFibGVkXHJcbi8qIGY5YjUgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZjliY1wiKTsgICAgICAgICAgICAvLyBpZiB0aW1lciBBIGlzIGVuYWJsZWQgZ28gPz9cclxuLyogZjliNyAqLyAgICAgICAgICAgICAgICAgICBMREEuYWJzIChcInRkMWlycV8wMmE0XCIpOyAgICAgIC8vIHJlYWQgVklBIDEgQ1JBIHNoYWRvdyBjb3B5XHJcbi8qIGY5YmEgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZjlkMlwiKTsgICAgICAgICAgICAvLyBpZiA/PyBqdXN0IGV4aXRcclxuLyogZjliYyAqLyAgICAgICAgX2BfZjliY2A7ICBMREEuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBBXHJcbi8qIGY5YmUgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJ0YnRjbnRfMDBhNFwiKTsgICAgICAvLyBjbGVhciB0aGUgdGFwZSBiaXQgY3ljbGUgcGhhc2VcclxuLyogZjljMCAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcInRkMWlycV8wMmE0XCIpOyAgICAgIC8vIHNhdmUgVklBIDEgQ1JBIHNoYWRvdyBjb3B5XHJcbi8qIGY5YzMgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ0c2ZjbnRfMDBhM1wiKTsgICAgICAvLyBnZXQgRU9JIGZsYWcgYnl0ZVxyXG4vKiBmOWM1ICovICAgICAgICAgICAgICAgICAgIEJQTC5yZWwgKFwiX2Y5ZjdcIik7XHJcbi8qIGY5YzcgKi8gICAgICAgICAgICAgICAgICAgQk1JLnJlbCAoXCJfZjk4OFwiKTtcclxuLyogZjljOSAqLyAgICAgICAgX2BfZjljOWA7ICBMRFguaW1tICgweGE2KTsgICAgICAgICAgICAgICAvLyBzZXQgdGltaW1nIG1heCBieXRlXHJcbi8qIGY5Y2IgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZjhlMlwiKTsgICAgICAgICAgICAvLyBzZXQgdGltaW5nXHJcbi8qIGY5Y2UgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJwcnR5XzAwOWJcIik7XHJcbi8qIGY5ZDAgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZjk4YlwiKTtcclxuLyogZjlkMiAqLyAgICAgICAgX2BfZjlkMmA7ICBKTVAuYWJzIChcIl9mZWJjXCIpOyAgICAgICAgICAgIC8vIHJlc3RvcmUgcmVnaXN0ZXJzIGFuZCBleGl0IGludGVycnVwdFxyXG4vKiBmOWQ1ICovICAgICAgICBfYF9mOWQ1YDsgIExEQS56cGcgKFwic3Z4dF8wMDkyXCIpOyAgICAgICAgLy8gZ2V0IHRpbWluZyBjb25zdGFudCBmb3IgdGFwZVxyXG4vKiBmOWQ3ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2Y5ZTBcIik7XHJcbi8qIGY5ZDkgKi8gICAgICAgICAgICAgICAgICAgQk1JLnJlbCAoXCJfZjlkZVwiKTtcclxuLyogZjlkYiAqLyAgICAgICAgICAgICAgICAgICBERUMuenBnIChcImNtcDArMF8wMGIwXCIpOyAgICAgIC8vIGRlY3JlbWVudCB0YXBlIHRpbWluZyBjb25zdGFudCBtaW4gYnl0ZVxyXG4vKiBmOWRkICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgyYyk7ICAgICAgICAgICAgICAgIC8vIG1ha2VzIG5leHQgbGluZSBCSVQgJEIwRTZcclxuLyogZjlkZSAqLyAgICAgICAgX2BfZjlkZWA7ICBJTkMuenBnIChcImNtcDArMF8wMGIwXCIpOyAgICAgIC8vIGluY3JlbWVudCB0YXBlIHRpbWluZyBjb25zdGFudCBtaW4gYnl0ZVxyXG4vKiBmOWUwICovICAgICAgICBfYF9mOWUwYDsgIExEQS5pbW0gKDB4MDApO1xyXG4vKiBmOWUyICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwic3Z4dF8wMDkyXCIpOyAgICAgICAgLy8gY2xlYXIgdGltaW5nIGNvbnN0YW50IGZvciB0YXBlXHJcbi8qIGY5ZTQgKi8gICAgICAgICAgICAgICAgICAgQ1BYLnpwZyAoXCJzY2hhcl8wMGQ3XCIpO1xyXG4vKiBmOWU2ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2Y5ZjdcIik7XHJcbi8qIGY5ZTggKi8gICAgICAgICAgICAgICAgICAgVFhBLmltcCAoKTtcclxuLyogZjllOSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mOThiXCIpO1xyXG4vKiBmOWViICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwicmlub25lXzAwYTlcIik7ICAgICAgLy8gZ2V0IHN0YXJ0IGJpdCBjaGVjayBmbGFnXHJcbi8qIGY5ZWQgKi8gICAgICAgICAgICAgICAgICAgQk1JLnJlbCAoXCJfZjlhY1wiKTtcclxuLyogZjllZiAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW1tICgweDEwKTtcclxuLyogZjlmMSAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9mOWFjXCIpO1xyXG4vKiBmOWYzICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwic3lub18wMDk2XCIpOyAgICAgICAgLy8gc2F2ZSBjYXNzZXR0ZSBibG9jayBzeW5jaHJvbml6YXRpb24gbnVtYmVyXHJcbi8qIGY5ZjUgKi8gICAgICAgICAgICAgICAgICAgQkNTLnJlbCAoXCJfZjlhY1wiKTtcclxuLyogZjlmNyAqLyAgICAgICAgX2BfZjlmN2A7ICBUWEEuaW1wICgpO1xyXG4vKiBmOWY4ICovICAgICAgICAgICAgICAgICAgIEVPUi56cGcgKFwicHJ0eV8wMDliXCIpO1xyXG4vKiBmOWZhICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwicHJ0eV8wMDliXCIpO1xyXG4vKiBmOWZjICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiYml0dHNfMDBiNFwiKTtcclxuLyogZjlmZSAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mOWQyXCIpO1xyXG4vKiBmYTAwICovICAgICAgICAgICAgICAgICAgIERFQy56cGcgKFwidHNmY250XzAwYTNcIik7ICAgICAgLy8gZGVjcmVtZW50IEVPSSBmbGFnIGJ5dGVcclxuLyogZmEwMiAqLyAgICAgICAgICAgICAgICAgICBCTUkucmVsIChcIl9mOWM5XCIpO1xyXG4vKiBmYTA0ICovICAgICAgICAgICAgICAgICAgIExTUi56cGcgKFwic2NoYXJfMDBkN1wiKTtcclxuLyogZmEwNiAqLyAgICAgICAgICAgICAgICAgICBST1IuenBnIChcIm15Y2hfMDBiZlwiKTsgICAgICAgIC8vIHBhcml0eSBjb3VudFxyXG4vKiBmYTA4ICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4ZGEpOyAgICAgICAgICAgICAgIC8vIHNldCB0aW1pbWcgbWF4IGJ5dGVcclxuLyogZmEwYSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mOGUyXCIpOyAgICAgICAgICAgIC8vIHNldCB0aW1pbmdcclxuLyogZmEwZCAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9mZWJjXCIpOyAgICAgICAgICAgIC8vIHJlc3RvcmUgcmVnaXN0ZXJzIGFuZCBleGl0IGludGVycnVwdFxyXG4vKiBmYTEwICovICAgICAgICBfYF9mYTEwYDsgIExEQS56cGcgKFwic3lub18wMDk2XCIpOyAgICAgICAgLy8gZ2V0IGNhc3NldHRlIGJsb2NrIHN5bmNocm9uaXphdGlvbiBudW1iZXJcclxuLyogZmExMiAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mYTE4XCIpO1xyXG4vKiBmYTE0ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiYml0dHNfMDBiNFwiKTtcclxuLyogZmExNiAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mYTFmXCIpO1xyXG4vKiBmYTE4ICovICAgICAgICBfYF9mYTE4YDsgIExEQS56cGcgKFwidHNmY250XzAwYTNcIik7ICAgICAgLy8gZ2V0IEVPSSBmbGFnIGJ5dGVcclxuLyogZmExYSAqLyAgICAgICAgICAgICAgICAgICBCTUkucmVsIChcIl9mYTFmXCIpO1xyXG4vKiBmYTFjICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2Y5OTdcIik7XHJcbi8qIGZhMWYgKi8gICAgICAgIF9gX2ZhMWZgOyAgTFNSLnpwZyAoXCJjbXAwKzFfMDBiMVwiKTsgICAgICAvLyBzaGlmdCB0YXBlIHRpbWluZyBjb25zdGFudCBtYXggYnl0ZVxyXG4vKiBmYTIxICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4OTMpO1xyXG4vKiBmYTIzICovICAgICAgICAgICAgICAgICAgIFNFQy5pbXAgKCk7XHJcbi8qIGZhMjQgKi8gICAgICAgICAgICAgICAgICAgU0JDLnpwZyAoXCJjbXAwKzFfMDBiMVwiKTsgICAgICAvLyBzdWJ0cmFjdCB0YXBlIHRpbWluZyBjb25zdGFudCBtYXggYnl0ZVxyXG4vKiBmYTI2ICovICAgICAgICAgICAgICAgICAgIEFEQy56cGcgKFwiY21wMCswXzAwYjBcIik7ICAgICAgLy8gYWRkIHRhcGUgdGltaW5nIGNvbnN0YW50IG1pbiBieXRlXHJcbi8qIGZhMjggKi8gICAgICAgICAgICAgICAgICAgQVNMLmFjYyAoKTtcclxuLyogZmEyOSAqLyAgICAgICAgICAgICAgICAgICBUQVguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IHRpbWltZyBoaWdoIGJ5dGVcclxuLyogZmEyYSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mOGUyXCIpOyAgICAgICAgICAgIC8vIHNldCB0aW1pbmdcclxuLyogZmEyZCAqLyAgICAgICAgICAgICAgICAgICBJTkMuenBnIChcImRwc3dfMDA5Y1wiKTtcclxuLyogZmEyZiAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImJpdHRzXzAwYjRcIik7XHJcbi8qIGZhMzEgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZmE0NFwiKTtcclxuLyogZmEzMyAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInN5bm9fMDA5NlwiKTsgICAgICAgIC8vIGdldCBjYXNzZXR0ZSBibG9jayBzeW5jaHJvbml6YXRpb24gbnVtYmVyXHJcbi8qIGZhMzUgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZmE1ZFwiKTtcclxuLyogZmEzNyAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImJpdGNpXzAwYThcIik7ICAgICAgIC8vIHNhdmUgcmVjZWl2ZXIgYml0IGNvdW50IGluXHJcbi8qIGZhMzkgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgQVxyXG4vKiBmYTNiICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwic3lub18wMDk2XCIpOyAgICAgICAgLy8gY2xlYXIgY2Fzc2V0dGUgYmxvY2sgc3luY2hyb25pemF0aW9uIG51bWJlclxyXG4vKiBmYTNkICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4ODEpOyAgICAgICAgICAgICAgIC8vIGVuYWJsZSB0aW1lciBBIGludGVycnVwdFxyXG4vKiBmYTNmICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiY2lhaWNyX2RjMGRcIik7ICAgICAgLy8gc2F2ZSBWSUEgMSBJQ1JcclxuLyogZmE0MiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImJpdHRzXzAwYjRcIik7XHJcbi8qIGZhNDQgKi8gICAgICAgIF9gX2ZhNDRgOyAgTERBLnpwZyAoXCJzeW5vXzAwOTZcIik7ICAgICAgICAvLyBnZXQgY2Fzc2V0dGUgYmxvY2sgc3luY2hyb25pemF0aW9uIG51bWJlclxyXG4vKiBmYTQ2ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwibnh0Yml0XzAwYjVcIik7XHJcbi8qIGZhNDggKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZmE1M1wiKTtcclxuLyogZmE0YSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDAwKTtcclxuLyogZmE0YyAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImJpdHRzXzAwYjRcIik7XHJcbi8qIGZhNGUgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMSk7ICAgICAgICAgICAgICAgLy8gZGlzYWJsZSB0aW1lciBBIGludGVycnVwdFxyXG4vKiBmYTUwICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiY2lhaWNyX2RjMGRcIik7ICAgICAgLy8gc2F2ZSBWSUEgMSBJQ1JcclxuLyogZmE1MyAqLyAgICAgICAgX2BfZmE1M2A7ICBMREEuenBnIChcIm15Y2hfMDBiZlwiKTsgICAgICAgIC8vIHBhcml0eSBjb3VudFxyXG4vKiBmYTU1ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwicm9wcnR5XzAwYmRcIik7ICAgICAgLy8gc2F2ZSBSUzIzMiBwYXJpdHkgYnl0ZVxyXG4vKiBmYTU3ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiYml0Y2lfMDBhOFwiKTsgICAgICAgLy8gZ2V0IHJlY2VpdmVyIGJpdCBjb3VudCBpblxyXG4vKiBmYTU5ICovICAgICAgICAgICAgICAgICAgIE9SQS56cGcgKFwicmlub25lXzAwYTlcIik7ICAgICAgLy8gT1Igd2l0aCBzdGFydCBiaXQgY2hlY2sgZmxhZ1xyXG4vKiBmYTViICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwicm9kYXRhXzAwYjZcIik7XHJcbi8qIGZhNWQgKi8gICAgICAgIF9gX2ZhNWRgOyAgSk1QLmFicyAoXCJfZmViY1wiKTsgICAgICAgICAgICAvLyByZXN0b3JlIHJlZ2lzdGVycyBhbmQgZXhpdCBpbnRlcnJ1cHRcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gIyBzdG9yZSBjaGFyYWN0ZXJcclxuLyogZmE2MCAqLyAgICAgICAgX2BfZmE2MGA7ICBKU1IuYWJzIChcIl9mYjk3XCIpOyAgICAgICAgICAgIC8vIG5ldyB0YXBlIGJ5dGUgc2V0dXBcclxuLyogZmE2MyAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcImRwc3dfMDA5Y1wiKTsgICAgICAgIC8vIGNsZWFyIGJ5dGUgcmVjZWl2ZWQgZmxhZ1xyXG4vKiBmYTY1ICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4ZGEpOyAgICAgICAgICAgICAgIC8vIHNldCB0aW1pbWcgbWF4IGJ5dGVcclxuLyogZmE2NyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mOGUyXCIpOyAgICAgICAgICAgIC8vIHNldCB0aW1pbmdcclxuLyogZmE2YSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImZzYmxrXzAwYmVcIik7ICAgICAgIC8vIGdldCBjb3BpZXMgY291bnRcclxuLyogZmE2YyAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mYTcwXCIpO1xyXG4vKiBmYTZlICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiaW5iaXRfMDBhN1wiKTsgICAgICAgLy8gc2F2ZSByZWNlaXZlciBpbnB1dCBiaXQgdGVtcG9yYXJ5IHN0b3JhZ2VcclxuLyogZmE3MCAqLyAgICAgICAgX2BfZmE3MGA7ICBMREEuaW1tICgweDBmKTtcclxuLyogZmE3MiAqLyAgICAgICAgICAgICAgICAgICBCSVQuenBnIChcInJpZGF0YV8wMGFhXCIpO1xyXG4vKiBmYTc0ICovICAgICAgICAgICAgICAgICAgIEJQTC5yZWwgKFwiX2ZhOGRcIik7XHJcbi8qIGZhNzYgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJueHRiaXRfMDBiNVwiKTtcclxuLyogZmE3OCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mYTg2XCIpO1xyXG4vKiBmYTdhICovICAgICAgICAgICAgICAgICAgIExEWC56cGcgKFwiZnNibGtfMDBiZVwiKTsgICAgICAgLy8gZ2V0IGNvcGllcyBjb3VudFxyXG4vKiBmYTdjICovICAgICAgICAgICAgICAgICAgIERFWC5pbXAgKCk7XHJcbi8qIGZhN2QgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZmE4YVwiKTsgICAgICAgICAgICAvLyBpZiA/PyByZXN0b3JlIHJlZ2lzdGVycyBhbmQgZXhpdCBpbnRlcnJ1cHRcclxuLyogZmE3ZiAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDA4KTsgICAgICAgICAgICAgICAvLyBzZXQgc2hvcnQgYmxvY2tcclxuLyogZmE4MSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mZTFjXCIpOyAgICAgICAgICAgIC8vIE9SIGludG8gc2VyaWFsIHN0YXR1cyBieXRlXHJcbi8qIGZhODQgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZmE4YVwiKTsgICAgICAgICAgICAvLyByZXN0b3JlIHJlZ2lzdGVycyBhbmQgZXhpdCBpbnRlcnJ1cHQsIGJyYW5jaCBhbHdheXNcclxuLyogZmE4NiAqLyAgICAgICAgX2BfZmE4NmA7ICBMREEuaW1tICgweDAwKTtcclxuLyogZmE4OCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInJpZGF0YV8wMGFhXCIpO1xyXG4vKiBmYThhICovICAgICAgICBfYF9mYThhYDsgIEpNUC5hYnMgKFwiX2ZlYmNcIik7ICAgICAgICAgICAgLy8gcmVzdG9yZSByZWdpc3RlcnMgYW5kIGV4aXQgaW50ZXJydXB0XHJcbi8qIGZhOGQgKi8gICAgICAgIF9gX2ZhOGRgOyAgQlZTLnJlbCAoXCJfZmFjMFwiKTtcclxuLyogZmE4ZiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mYWE5XCIpO1xyXG4vKiBmYTkxICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwibnh0Yml0XzAwYjVcIik7XHJcbi8qIGZhOTMgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZmE4YVwiKTtcclxuLyogZmE5NSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInJvZGF0YV8wMGI2XCIpO1xyXG4vKiBmYTk3ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2ZhOGFcIik7XHJcbi8qIGZhOTkgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJpbmJpdF8wMGE3XCIpOyAgICAgICAvLyBnZXQgcmVjZWl2ZXIgaW5wdXQgYml0IHRlbXBvcmFyeSBzdG9yYWdlXHJcbi8qIGZhOWIgKi8gICAgICAgICAgICAgICAgICAgTFNSLmFjYyAoKTtcclxuLyogZmE5YyAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInJvcHJ0eV8wMGJkXCIpOyAgICAgIC8vIGdldCBSUzIzMiBwYXJpdHkgYnl0ZVxyXG4vKiBmYTllICovICAgICAgICAgICAgICAgICAgIEJNSS5yZWwgKFwiX2ZhYTNcIik7XHJcbi8qIGZhYTAgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfZmFiYVwiKTtcclxuLyogZmFhMiAqLyAgICAgICAgICAgICAgICAgICBDTEMuaW1wICgpO1xyXG4vKiBmYWEzICovICAgICAgICBfYF9mYWEzYDsgIEJDUy5yZWwgKFwiX2ZhYmFcIik7XHJcbi8qIGZhYTUgKi8gICAgICAgICAgICAgICAgICAgQU5ELmltbSAoMHgwZik7XHJcbi8qIGZhYTcgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJyaWRhdGFfMDBhYVwiKTtcclxuLyogZmFhOSAqLyAgICAgICAgX2BfZmFhOWA7ICBERUMuenBnIChcInJpZGF0YV8wMGFhXCIpO1xyXG4vKiBmYWFiICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2ZhOGFcIik7XHJcbi8qIGZhYWQgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHg0MCk7XHJcbi8qIGZhYWYgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJyaWRhdGFfMDBhYVwiKTtcclxuLyogZmFiMSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mYjhlXCIpOyAgICAgICAgICAgIC8vIGNvcHkgSS9PIHN0YXJ0IGFkZHJlc3MgdG8gYnVmZmVyIGFkZHJlc3NcclxuLyogZmFiNCAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDAwKTtcclxuLyogZmFiNiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInJpcHJ0eV8wMGFiXCIpO1xyXG4vKiBmYWI4ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2ZhOGFcIik7XHJcbi8qIGZhYmEgKi8gICAgICAgIF9gX2ZhYmFgOyAgTERBLmltbSAoMHg4MCk7XHJcbi8qIGZhYmMgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJyaWRhdGFfMDBhYVwiKTtcclxuLyogZmFiZSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mYThhXCIpOyAgICAgICAgICAgIC8vIHJlc3RvcmUgcmVnaXN0ZXJzIGFuZCBleGl0IGludGVycnVwdCwgYnJhbmNoIGFsd2F5c1xyXG4vKiBmYWMwICovICAgICAgICBfYF9mYWMwYDsgIExEQS56cGcgKFwibnh0Yml0XzAwYjVcIik7XHJcbi8qIGZhYzIgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZmFjZVwiKTtcclxuLyogZmFjNCAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDA0KTtcclxuLyogZmFjNiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mZTFjXCIpOyAgICAgICAgICAgIC8vIE9SIGludG8gc2VyaWFsIHN0YXR1cyBieXRlXHJcbi8qIGZhYzkgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMCk7XHJcbi8qIGZhY2IgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZmI0YVwiKTtcclxuLyogZmFjZSAqLyAgICAgICAgX2BfZmFjZWA7ICBKU1IuYWJzIChcIl9mY2QxXCIpOyAgICAgICAgICAgIC8vIGNoZWNrIHJlYWQvd3JpdGUgcG9pbnRlciwgcmV0dXJuIENiID0gMSBpZiBwb2ludGVyID49IGVuZFxyXG4vKiBmYWQxICovICAgICAgICAgICAgICAgICAgIEJDQy5yZWwgKFwiX2ZhZDZcIik7XHJcbi8qIGZhZDMgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZmI0OFwiKTtcclxuLyogZmFkNiAqLyAgICAgICAgX2BfZmFkNmA7ICBMRFguenBnIChcImluYml0XzAwYTdcIik7ICAgICAgIC8vIGdldCByZWNlaXZlciBpbnB1dCBiaXQgdGVtcG9yYXJ5IHN0b3JhZ2VcclxuLyogZmFkOCAqLyAgICAgICAgICAgICAgICAgICBERVguaW1wICgpO1xyXG4vKiBmYWQ5ICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2ZiMDhcIik7XHJcbi8qIGZhZGIgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ2ZXJja18wMDkzXCIpOyAgICAgICAvLyBnZXQgbG9hZC92ZXJpZnkgZmxhZ1xyXG4vKiBmYWRkICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2ZhZWJcIik7ICAgICAgICAgICAgLy8gaWYgbG9hZCBnbyA/P1xyXG4vKiBmYWRmICovICAgICAgICAgICAgICAgICAgIExEWS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIGluZGV4XHJcbi8qIGZhZTEgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJyb3BydHlfMDBiZFwiKTsgICAgICAvLyBnZXQgUlMyMzIgcGFyaXR5IGJ5dGVcclxuLyogZmFlMyAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW55IChcInNhbCswXzAwYWNcIik7XHJcbi8qIGZhZTUgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZmFlYlwiKTtcclxuLyogZmFlNyAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDAxKTtcclxuLyogZmFlOSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInJvZGF0YV8wMGI2XCIpO1xyXG4vKiBmYWViICovICAgICAgICBfYF9mYWViYDsgIExEQS56cGcgKFwicm9kYXRhXzAwYjZcIik7XHJcbi8qIGZhZWQgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZmIzYVwiKTtcclxuLyogZmFlZiAqLyAgICAgICAgICAgICAgICAgICBMRFguaW1tICgweDNkKTtcclxuLyogZmFmMSAqLyAgICAgICAgICAgICAgICAgICBDUFguenBnIChcInB0cjFfMDA5ZVwiKTtcclxuLyogZmFmMyAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9mYjMzXCIpO1xyXG4vKiBmYWY1ICovICAgICAgICAgICAgICAgICAgIExEWC56cGcgKFwicHRyMV8wMDllXCIpO1xyXG4vKiBmYWY3ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwic2FsKzFfMDBhZFwiKTtcclxuLyogZmFmOSAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJ4IChcImJhZCsxXzAxMDFcIik7XHJcbi8qIGZhZmMgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJzYWwrMF8wMGFjXCIpO1xyXG4vKiBmYWZlICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnggKFwiYmFkKzBfMDEwMFwiKTtcclxuLyogZmIwMSAqLyAgICAgICAgICAgICAgICAgICBJTlguaW1wICgpO1xyXG4vKiBmYjAyICovICAgICAgICAgICAgICAgICAgIElOWC5pbXAgKCk7XHJcbi8qIGZiMDMgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJwdHIxXzAwOWVcIik7XHJcbi8qIGZiMDUgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZmIzYVwiKTtcclxuLyogZmIwOCAqLyAgICAgICAgX2BfZmIwOGA7ICBMRFguenBnIChcInB0cjJfMDA5ZlwiKTtcclxuLyogZmIwYSAqLyAgICAgICAgICAgICAgICAgICBDUFguenBnIChcInB0cjFfMDA5ZVwiKTtcclxuLyogZmIwYyAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mYjQzXCIpO1xyXG4vKiBmYjBlICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwic2FsKzBfMDBhY1wiKTtcclxuLyogZmIxMCAqLyAgICAgICAgICAgICAgICAgICBDTVAuYWJ4IChcImJhZCswXzAxMDBcIik7XHJcbi8qIGZiMTMgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZmI0M1wiKTtcclxuLyogZmIxNSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInNhbCsxXzAwYWRcIik7XHJcbi8qIGZiMTcgKi8gICAgICAgICAgICAgICAgICAgQ01QLmFieCAoXCJiYWQrMV8wMTAxXCIpO1xyXG4vKiBmYjFhICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2ZiNDNcIik7XHJcbi8qIGZiMWMgKi8gICAgICAgICAgICAgICAgICAgSU5DLnpwZyAoXCJwdHIyXzAwOWZcIik7XHJcbi8qIGZiMWUgKi8gICAgICAgICAgICAgICAgICAgSU5DLnpwZyAoXCJwdHIyXzAwOWZcIik7XHJcbi8qIGZiMjAgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ2ZXJja18wMDkzXCIpOyAgICAgICAvLyBnZXQgbG9hZC92ZXJpZnkgZmxhZ1xyXG4vKiBmYjIyICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2ZiMmZcIik7ICAgICAgICAgICAgLy8gaWYgbG9hZCA/P1xyXG4vKiBmYjI0ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwicm9wcnR5XzAwYmRcIik7ICAgICAgLy8gZ2V0IFJTMjMyIHBhcml0eSBieXRlXHJcbi8qIGZiMjYgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgwMCk7XHJcbi8qIGZiMjggKi8gICAgICAgICAgICAgICAgICAgQ01QLmlueSAoXCJzYWwrMF8wMGFjXCIpO1xyXG4vKiBmYjJhICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2ZiNDNcIik7XHJcbi8qIGZiMmMgKi8gICAgICAgICAgICAgICAgICAgSU5ZLmltcCAoKTtcclxuLyogZmIyZCAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcInJvZGF0YV8wMGI2XCIpO1xyXG4vKiBmYjJmICovICAgICAgICBfYF9mYjJmYDsgIExEQS56cGcgKFwicm9kYXRhXzAwYjZcIik7XHJcbi8qIGZiMzEgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZmIzYVwiKTtcclxuLyogZmIzMyAqLyAgICAgICAgX2BfZmIzM2A7ICBMREEuaW1tICgweDEwKTtcclxuLyogZmIzNSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mZTFjXCIpOyAgICAgICAgICAgIC8vIE9SIGludG8gc2VyaWFsIHN0YXR1cyBieXRlXHJcbi8qIGZiMzggKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZmI0M1wiKTtcclxuLyogZmIzYSAqLyAgICAgICAgX2BfZmIzYWA7ICBMREEuenBnIChcInZlcmNrXzAwOTNcIik7ICAgICAgIC8vIGdldCBsb2FkL3ZlcmlmeSBmbGFnXHJcbi8qIGZiM2MgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZmI0M1wiKTsgICAgICAgICAgICAvLyBpZiB2ZXJpZnkgZ28gPz9cclxuLyogZmIzZSAqLyAgICAgICAgICAgICAgICAgICBUQVkuaW1wICgpO1xyXG4vKiBmYjNmICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwicm9wcnR5XzAwYmRcIik7ICAgICAgLy8gZ2V0IFJTMjMyIHBhcml0eSBieXRlXHJcbi8qIGZiNDEgKi8gICAgICAgICAgICAgICAgICAgU1RBLmlueSAoXCJzYWwrMF8wMGFjXCIpO1xyXG4vKiBmYjQzICovICAgICAgICBfYF9mYjQzYDsgIEpTUi5hYnMgKFwiX2ZjZGJcIik7ICAgICAgICAgICAgLy8gaW5jcmVtZW50IHJlYWQvd3JpdGUgcG9pbnRlclxyXG4vKiBmYjQ2ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2ZiOGJcIik7ICAgICAgICAgICAgLy8gcmVzdG9yZSByZWdpc3RlcnMgYW5kIGV4aXQgaW50ZXJydXB0LCBicmFuY2ggYWx3YXlzXHJcbi8qIGZiNDggKi8gICAgICAgIF9gX2ZiNDhgOyAgTERBLmltbSAoMHg4MCk7XHJcbi8qIGZiNGEgKi8gICAgICAgIF9gX2ZiNGFgOyAgU1RBLnpwZyAoXCJyaWRhdGFfMDBhYVwiKTtcclxuLyogZmI0YyAqLyAgICAgICAgICAgICAgICAgICBTRUkuaW1wICgpO1xyXG4vKiBmYjRkICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4MDEpOyAgICAgICAgICAgICAgIC8vIGRpc2FibGUgdGltZXIgQSBpbnRlcnJ1cHRcclxuLyogZmI0ZiAqLyAgICAgICAgICAgICAgICAgICBTVFguYWJzIChcImNpYWljcl9kYzBkXCIpOyAgICAgIC8vIHNhdmUgVklBIDEgSUNSXHJcbi8qIGZiNTIgKi8gICAgICAgICAgICAgICAgICAgTERYLmFicyAoXCJjaWFpY3JfZGMwZFwiKTsgICAgICAvLyByZWFkIFZJQSAxIElDUlxyXG4vKiBmYjU1ICovICAgICAgICAgICAgICAgICAgIExEWC56cGcgKFwiZnNibGtfMDBiZVwiKTsgICAgICAgLy8gZ2V0IGNvcGllcyBjb3VudFxyXG4vKiBmYjU3ICovICAgICAgICAgICAgICAgICAgIERFWC5pbXAgKCk7XHJcbi8qIGZiNTggKi8gICAgICAgICAgICAgICAgICAgQk1JLnJlbCAoXCJfZmI1Y1wiKTtcclxuLyogZmI1YSAqLyAgICAgICAgICAgICAgICAgICBTVFguenBnIChcImZzYmxrXzAwYmVcIik7ICAgICAgIC8vIHNhdmUgY29waWVzIGNvdW50XHJcbi8qIGZiNWMgKi8gICAgICAgIF9gX2ZiNWNgOyAgREVDLnpwZyAoXCJpbmJpdF8wMGE3XCIpOyAgICAgICAvLyBkZWNyZW1lbnQgcmVjZWl2ZXIgaW5wdXQgYml0IHRlbXBvcmFyeSBzdG9yYWdlXHJcbi8qIGZiNWUgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZmI2OFwiKTtcclxuLyogZmI2MCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInB0cjFfMDA5ZVwiKTtcclxuLyogZmI2MiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mYjhiXCIpOyAgICAgICAgICAgIC8vIGlmID8/IHJlc3RvcmUgcmVnaXN0ZXJzIGFuZCBleGl0IGludGVycnVwdFxyXG4vKiBmYjY0ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZnNibGtfMDBiZVwiKTsgICAgICAgLy8gc2F2ZSBjb3BpZXMgY291bnRcclxuLyogZmI2NiAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mYjhiXCIpOyAgICAgICAgICAgIC8vIHJlc3RvcmUgcmVnaXN0ZXJzIGFuZCBleGl0IGludGVycnVwdCwgYnJhbmNoIGFsd2F5c1xyXG4vKiBmYjY4ICovICAgICAgICBfYF9mYjY4YDsgIEpTUi5hYnMgKFwiX2ZjOTNcIik7ICAgICAgICAgICAgLy8gcmVzdG9yZSBldmVyeXRoaW5nIGZvciBTVE9QXHJcbi8qIGZiNmIgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZmI4ZVwiKTsgICAgICAgICAgICAvLyBjb3B5IEkvTyBzdGFydCBhZGRyZXNzIHRvIGJ1ZmZlciBhZGRyZXNzXHJcbi8qIGZiNmUgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgaW5kZXhcclxuLyogZmI3MCAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcInJpcHJ0eV8wMGFiXCIpOyAgICAgIC8vIGNsZWFyIGNoZWNrc3VtXHJcbi8qIGZiNzIgKi8gICAgICAgIF9gX2ZiNzJgOyAgTERBLmlueSAoXCJzYWwrMF8wMGFjXCIpOyAgICAgICAvLyBnZXQgYnl0ZSBmcm9tIGJ1ZmZlclxyXG4vKiBmYjc0ICovICAgICAgICAgICAgICAgICAgIEVPUi56cGcgKFwicmlwcnR5XzAwYWJcIik7ICAgICAgLy8gWE9SIHdpdGggY2hlY2tzdW1cclxuLyogZmI3NiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInJpcHJ0eV8wMGFiXCIpOyAgICAgIC8vIHNhdmUgbmV3IGNoZWNrc3VtXHJcbi8qIGZiNzggKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZmNkYlwiKTsgICAgICAgICAgICAvLyBpbmNyZW1lbnQgcmVhZC93cml0ZSBwb2ludGVyXHJcbi8qIGZiN2IgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZmNkMVwiKTsgICAgICAgICAgICAvLyBjaGVjayByZWFkL3dyaXRlIHBvaW50ZXIsIHJldHVybiBDYiA9IDEgaWYgcG9pbnRlciA+PSBlbmRcclxuLyogZmI3ZSAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9mYjcyXCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgbm90IGF0IGVuZFxyXG4vKiBmYjgwICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwicmlwcnR5XzAwYWJcIik7ICAgICAgLy8gZ2V0IGNvbXB1dGVkIGNoZWNrc3VtXHJcbi8qIGZiODIgKi8gICAgICAgICAgICAgICAgICAgRU9SLnpwZyAoXCJyb3BydHlfMDBiZFwiKTsgICAgICAvLyBjb21wYXJlIHdpdGggc3RvcmVkIGNoZWNrc3VtID8/XHJcbi8qIGZiODQgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZmI4YlwiKTsgICAgICAgICAgICAvLyBpZiBjaGVja3N1bSBvayByZXN0b3JlIHJlZ2lzdGVycyBhbmQgZXhpdCBpbnRlcnJ1cHRcclxuLyogZmI4NiAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDIwKTsgICAgICAgICAgICAgICAvLyBlbHNlIHNldCBjaGVja3N1bSBlcnJvclxyXG4vKiBmYjg4ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2ZlMWNcIik7ICAgICAgICAgICAgLy8gT1IgaW50byB0aGUgc2VyaWFsIHN0YXR1cyBieXRlXHJcbi8qIGZiOGIgKi8gICAgICAgIF9gX2ZiOGJgOyAgSk1QLmFicyAoXCJfZmViY1wiKTsgICAgICAgICAgICAvLyByZXN0b3JlIHJlZ2lzdGVycyBhbmQgZXhpdCBpbnRlcnJ1cHRcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY29weSBJL08gc3RhcnQgYWRkcmVzcyB0byBidWZmZXIgYWRkcmVzc1xyXG4vKiBmYjhlICovICAgICAgICBfYF9mYjhlYDsgIExEQS56cGcgKFwic3RhbCsxXzAwYzJcIik7ICAgICAgLy8gZ2V0IEkvTyBzdGFydCBhZGRyZXNzIGhpZ2ggYnl0ZVxyXG4vKiBmYjkwICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwic2FsKzFfMDBhZFwiKTsgICAgICAgLy8gc2V0IGJ1ZmZlciBhZGRyZXNzIGhpZ2ggYnl0ZVxyXG4vKiBmYjkyICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwic3RhbCswXzAwYzFcIik7ICAgICAgLy8gZ2V0IEkvTyBzdGFydCBhZGRyZXNzIGxvdyBieXRlXHJcbi8qIGZiOTQgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJzYWwrMF8wMGFjXCIpOyAgICAgICAvLyBzZXQgYnVmZmVyIGFkZHJlc3MgbG93IGJ5dGVcclxuLyogZmI5NiAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBuZXcgdGFwZSBieXRlIHNldHVwXHJcbi8qIGZiOTcgKi8gICAgICAgIF9gX2ZiOTdgOyAgTERBLmltbSAoMHgwOCk7ICAgICAgICAgICAgICAgLy8gZWlnaHQgYml0cyB0byBkb1xyXG4vKiBmYjk5ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwidHNmY250XzAwYTNcIik7ICAgICAgLy8gc2V0IGJpdCBjb3VudFxyXG4vKiBmYjliICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MDApOyAgICAgICAgICAgICAgIC8vIGNsZWFyIEFcclxuLyogZmI5ZCAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInRidGNudF8wMGE0XCIpOyAgICAgIC8vIGNsZWFyIHRhcGUgYml0IGN5Y2xlIHBoYXNlXHJcbi8qIGZiOWYgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJiaXRjaV8wMGE4XCIpOyAgICAgICAvLyBjbGVhciBzdGFydCBiaXQgZmlyc3QgY3ljbGUgZG9uZSBmbGFnXHJcbi8qIGZiYTEgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJwcnR5XzAwOWJcIik7ICAgICAgICAvLyBjbGVhciBieXRlIHBhcml0eVxyXG4vKiBmYmEzICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwicmlub25lXzAwYTlcIik7ICAgICAgLy8gY2xlYXIgc3RhcnQgYml0IGNoZWNrIGZsYWcsIHNldCBubyBzdGFydCBiaXQgeWV0XHJcbi8qIGZiYTUgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gc2VuZCBsc2IgZnJvbSB0YXBlIHdyaXRlIGJ5dGUgdG8gdGFwZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgcm91dGluZSB0ZXN0cyB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0IGluIHRoZSB0YXBlIHdyaXRlIGJ5dGUgYW5kIHNldHMgVklBIDIgVDJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZXBlbmRpbmcgb24gdGhlIHN0YXRlIG9mIHRoZSBiaXQuIGlmIHRoZSBiaXQgaXMgYSAxIGEgdGltZSBvZiAkMDBCMCBjeWNsZXMgaXMgc2V0LCBpZlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBib3QgaXMgYSAwIGEgdGltZSBvZiAkMDA2MCBjeWNsZXMgaXMgc2V0LiBub3RlIHRoYXQgdGhpcyByb3V0aW5lIGRvZXMgbm90IHNoaWZ0IHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJpdHMgb2YgdGhlIHRhcGUgd3JpdGUgYnl0ZSBidXQgdXNlcyBhIGNvcHkgb2YgdGhhdCBieXRlLCB0aGUgYnl0ZSBpdHNlbGYgaXMgc2hpZnRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2V3aGVyZVxyXG4vKiBmYmE2ICovICAgICAgICBfYF9mYmE2YDsgIExEQS56cGcgKFwicm9wcnR5XzAwYmRcIik7ICAgICAgLy8gZ2V0IHRhcGUgd3JpdGUgYnl0ZVxyXG4vKiBmYmE4ICovICAgICAgICAgICAgICAgICAgIExTUi5hY2MgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNoaWZ0IGxzYiBpbnRvIENiXHJcbi8qIGZiYTkgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHg2MCk7ICAgICAgICAgICAgICAgLy8gc2V0IHRpbWUgY29uc3RhbnQgbG93IGJ5dGUgZm9yIGJpdCA9IDBcclxuLyogZmJhYiAqLyAgICAgICAgICAgICAgICAgICBCQ0MucmVsIChcIl9mYmFmXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBiaXQgd2FzIDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgdGltZSBjb25zdGFudCBmb3IgYml0ID0gMSBhbmQgdG9nZ2xlIHRhcGVcclxuLyogZmJhZCAqLyAgICAgICAgX2BfZmJhZGA7ICBMREEuaW1tICgweGIwKTsgICAgICAgICAgICAgICAvLyBzZXQgdGltZSBjb25zdGFudCBsb3cgYnl0ZSBmb3IgYml0ID0gMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdyaXRlIHRpbWUgY29uc3RhbnQgYW5kIHRvZ2dsZSB0YXBlXHJcbi8qIGZiYWYgKi8gICAgICAgIF9gX2ZiYWZgOyAgTERYLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gc2V0IHRpbWUgY29uc3RhbnQgaGlnaCBieXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd3JpdGUgdGltZSBjb25zdGFudCBhbmQgdG9nZ2xlIHRhcGVcclxuLyogZmJiMSAqLyAgICAgICAgX2BfZmJiMWA7ICBTVEEuYWJzIChcInRpbWJsb19kYzA2XCIpOyAgICAgIC8vIHNhdmUgVklBIDEgdGltZXIgQiBsb3cgYnl0ZVxyXG4vKiBmYmI0ICovICAgICAgICAgICAgICAgICAgIFNUWC5hYnMgKFwidGltYmhpX2RjMDdcIik7ICAgICAgLy8gc2F2ZSBWSUEgMSB0aW1lciBCIGhpZ2ggYnl0ZVxyXG4vKiBmYmI3ICovICAgICAgICAgICAgICAgICAgIExEQS5hYnMgKFwiY2lhaWNyX2RjMGRcIik7ICAgICAgLy8gcmVhZCBWSUEgMSBJQ1JcclxuLyogZmJiYSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDE5KTsgICAgICAgICAgICAgICAvLyBsb2FkIHRpbWVyIEIsIHRpbWVyIEIgc2luZ2xlIHNob3QsIHN0YXJ0IHRpbWVyIEJcclxuLyogZmJiYyAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcImNpYWNyYl9kYzBmXCIpOyAgICAgIC8vIHNhdmUgVklBIDEgQ1JCXHJcbi8qIGZiYmYgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJyNjUxMF8wMDAxXCIpOyAgICAgICAvLyByZWFkIHRoZSA2NTEwIEkvTyBwb3J0XHJcbi8qIGZiYzEgKi8gICAgICAgICAgICAgICAgICAgRU9SLmltbSAoMHgwOCk7ICAgICAgICAgICAgICAgLy8gdG9nZ2xlIHRhcGUgb3V0IGJpdFxyXG4vKiBmYmMzICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwicjY1MTBfMDAwMVwiKTsgICAgICAgLy8gc2F2ZSB0aGUgNjUxMCBJL08gcG9ydFxyXG4vKiBmYmM1ICovICAgICAgICAgICAgICAgICAgIEFORC5pbW0gKDB4MDgpOyAgICAgICAgICAgICAgIC8vIG1hc2sgdGFwZSBvdXQgYml0XHJcbi8qIGZiYzcgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gZmxhZyBibG9jayBkb25lIGFuZCBleGl0IGludGVycnVwdFxyXG4vKiBmYmM4ICovICAgICAgICBfYF9mYmM4YDsgIFNFQy5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNldCBjYXJyeSBmbGFnXHJcbi8qIGZiYzkgKi8gICAgICAgICAgICAgICAgICAgUk9SLnpwZyAoXCJyb2RhdGFfMDBiNlwiKTsgICAgICAvLyBzZXQgYnVmZmVyIGFkZHJlc3MgaGlnaCBieXRlIG5lZ2F0aXZlLCBmbGFnIGFsbCBzeW5jLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRhdGEgYW5kIGNoZWNrc3VtIGJ5dGVzIHdyaXR0ZW5cclxuLyogZmJjYiAqLyAgICAgICAgICAgICAgICAgICBCTUkucmVsIChcIl9mYzA5XCIpOyAgICAgICAgICAgIC8vIHJlc3RvcmUgcmVnaXN0ZXJzIGFuZCBleGl0IGludGVycnVwdCwgYnJhbmNoIGFsd2F5c1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyB0YXBlIHdyaXRlIElSUSByb3V0aW5lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgcm91dGluZSB0aGF0IHdyaXRlcyB0aGUgYml0cyB0byB0aGUgdGFwZS4gaXQgaXMgY2FsbGVkIGVhY2ggdGltZSBWSUEgMiBUMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRpbWVzIG91dCBhbmQgY2hlY2tzIGlmIHRoZSBzdGFydCBiaXQgaXMgZG9uZSwgaWYgc28gY2hlY2tzIGlmIHRoZSBkYXRhIGJpdHMgYXJlIGRvbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgc28gaXQgY2hlY2tzIGlmIHRoZSBieXRlIGlzIGRvbmUsIGlmIHNvIGl0IGNoZWNrcyBpZiB0aGUgc3luY2hyb25pc2F0aW9uIGJ5dGVzIGFyZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbmUsIGlmIHNvIGl0IGNoZWNrcyBpZiB0aGUgZGF0YSBieXRlcyBhcmUgZG9uZSwgaWYgc28gaXQgY2hlY2tzIGlmIHRoZSBjaGVja3N1bSBieXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgZG9uZSwgaWYgc28gaXQgY2hlY2tzIGlmIGJvdGggdGhlIGxvYWQgYW5kIHZlcmlmeSBjb3BpZXMgaGF2ZSBiZWVuIGRvbmUsIGlmIHNvIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RvcHMgdGhlIHRhcGVcclxuLyogZmJjZCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcImJpdGNpXzAwYThcIik7ICAgICAgIC8vIGdldCBzdGFydCBiaXQgZmlyc3QgY3ljbGUgZG9uZSBmbGFnXHJcbi8qIGZiY2YgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZmJlM1wiKTsgICAgICAgICAgICAvLyBpZiBmaXJzdCBjeWNsZSBkb25lIGdvIGRvIHJlc3Qgb2YgYnl0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVhY2ggYnl0ZSBzZW50IHN0YXJ0cyB3aXRoIHR3byBoYWxmIGN5Y2xlcyBvZiAkMDExMCBzdHN0ZW0gY2xvY2tzIGFuZCB0aGUgd2hvbGUgYmxvY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbmRzIHdpdGggdHdvIG1vcmUgc3VjaCBoYWxmIGN5Y2xlc1xyXG4vKiBmYmQxICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MTApOyAgICAgICAgICAgICAgIC8vIHNldCBmaXJzdCBzdGFydCBjeWNsZSB0aW1lIGNvbnN0YW50IGxvdyBieXRlXHJcbi8qIGZiZDMgKi8gICAgICAgICAgICAgICAgICAgTERYLmltbSAoMHgwMSk7ICAgICAgICAgICAgICAgLy8gc2V0IGZpcnN0IHN0YXJ0IGN5Y2xlIHRpbWUgY29uc3RhbnQgaGlnaCBieXRlXHJcbi8qIGZiZDUgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZmJiMVwiKTsgICAgICAgICAgICAvLyB3cml0ZSB0aW1lIGNvbnN0YW50IGFuZCB0b2dnbGUgdGFwZVxyXG4vKiBmYmQ4ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2ZjMDlcIik7ICAgICAgICAgICAgLy8gaWYgZmlyc3QgaGFsZiBjeWNsZSBnbyByZXN0b3JlIHJlZ2lzdGVycyBhbmQgZXhpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGludGVycnVwdFxyXG4vKiBmYmRhICovICAgICAgICAgICAgICAgICAgIElOQy56cGcgKFwiYml0Y2lfMDBhOFwiKTsgICAgICAgLy8gc2V0IHN0YXJ0IGJpdCBmaXJzdCBzdGFydCBjeWNsZSBkb25lIGZsYWdcclxuLyogZmJkYyAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInJvZGF0YV8wMGI2XCIpOyAgICAgIC8vIGdldCBidWZmZXIgYWRkcmVzcyBoaWdoIGJ5dGVcclxuLyogZmJkZSAqLyAgICAgICAgICAgICAgICAgICBCUEwucmVsIChcIl9mYzA5XCIpOyAgICAgICAgICAgIC8vIGlmIGJsb2NrIG5vdCBjb21wbGV0ZSBnbyByZXN0b3JlIHJlZ2lzdGVycyBhbmQgZXhpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGludGVycnVwdC4gdGhlIGVuZCBvZiBhIGJsb2NrIGlzIGluZGljYXRlZCBieSB0aGUgdGFwZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1ZmZlciBoaWdoIGJ5dGUgYjcgYmVpbmcgc2V0IHRvIDFcclxuLyogZmJlMCAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9mYzU3XCIpOyAgICAgICAgICAgIC8vIGVsc2UgZG8gdGFwZSByb3V0aW5lLCBibG9jayBjb21wbGV0ZSBleGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udGludWUgdGFwZSBieXRlIHdyaXRlLiB0aGUgZmlyc3Qgc3RhcnQgY3ljbGUsIGJvdGggaGFsZiBjeWNsZXMgb2YgaXQsIGlzIGNvbXBsZXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gdGhlIHJvdXRpbmUgZHJvcHMgc3RyYWlnaHQgdGhyb3VnaCB0byBoZXJlXHJcbi8qIGZiZTMgKi8gICAgICAgIF9gX2ZiZTNgOyAgTERBLnpwZyAoXCJyaW5vbmVfMDBhOVwiKTsgICAgICAvLyBnZXQgc3RhcnQgYml0IGNoZWNrIGZsYWdcclxuLyogZmJlNSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mYmYwXCIpOyAgICAgICAgICAgIC8vIGlmIHRoZSBzdGFydCBiaXQgaXMgY29tcGxldGUgZ28gc2VuZCB0aGUgYnl0ZSBiaXRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWZ0ZXIgdGhlIHR3byBoYWxmIGN5Y2xlcyBvZiAkMDExMCBzdHN0ZW0gY2xvY2tzIHRoZSBzdGFydCBiaXQgaXMgY29tcGxldGVkIHdpdGggdHdvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFsZiBjeWNsZXMgb2YgJDAwQjAgc3lzdGVtIGNsb2Nrcy4gdGhpcyBpcyB0aGUgc2FtZSBhcyB0aGUgZmlyc3QgcGFydCBvZiBhIDEgYml0XHJcbi8qIGZiZTcgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZmJhZFwiKTsgICAgICAgICAgICAvLyBzZXQgdGltZSBjb25zdGFudCBmb3IgYml0ID0gMSBhbmQgdG9nZ2xlIHRhcGVcclxuLyogZmJlYSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mYzA5XCIpOyAgICAgICAgICAgIC8vIGlmIGZpcnN0IGhhbGYgY3ljbGUgZ28gcmVzdG9yZSByZWdpc3RlcnMgYW5kIGV4aXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnRlcnJ1cHRcclxuLyogZmJlYyAqLyAgICAgICAgICAgICAgICAgICBJTkMuenBnIChcInJpbm9uZV8wMGE5XCIpOyAgICAgIC8vIHNldCBzdGFydCBiaXQgY2hlY2sgZmxhZ1xyXG4vKiBmYmVlICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2ZjMDlcIik7ICAgICAgICAgICAgLy8gcmVzdG9yZSByZWdpc3RlcnMgYW5kIGV4aXQgaW50ZXJydXB0LCBicmFuY2ggYWx3YXlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udGludWUgdGFwZSBieXRlIHdyaXRlLiB0aGUgc3RhcnQgYml0LCBib3RoIGN5Y2xlcyBvZiBpdCwgaXMgY29tcGxldGUgc28gdGhlIHJvdXRpbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkcm9wcyBzdHJhaWdodCB0aHJvdWdoIHRvIGhlcmUuIG5vdyB0aGUgY3ljbGUgcGFpcnMgZm9yIGVhY2ggYml0LCBhbmQgdGhlIHBhcml0eSBiaXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJlIHNlbnRcclxuLyogZmJmMCAqLyAgICAgICAgX2BfZmJmMGA7ICBKU1IuYWJzIChcIl9mYmE2XCIpOyAgICAgICAgICAgIC8vIHNlbmQgbHNiIGZyb20gdGFwZSB3cml0ZSBieXRlIHRvIHRhcGVcclxuLyogZmJmMyAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mYzA5XCIpOyAgICAgICAgICAgIC8vIGlmIGZpcnN0IGhhbGYgY3ljbGUgZ28gcmVzdG9yZSByZWdpc3RlcnMgYW5kIGV4aXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnRlcnJ1cHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIHR3byBoYWxmIGN5Y2xlcyBoYXZlIGJlZW4gZG9uZVxyXG4vKiBmYmY1ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwidGJ0Y250XzAwYTRcIik7ICAgICAgLy8gZ2V0IHRhcGUgYml0IGN5Y2xlIHBoYXNlXHJcbi8qIGZiZjcgKi8gICAgICAgICAgICAgICAgICAgRU9SLmltbSAoMHgwMSk7ICAgICAgICAgICAgICAgLy8gdG9nZ2xlIGIwXHJcbi8qIGZiZjkgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJ0YnRjbnRfMDBhNFwiKTsgICAgICAvLyBzYXZlIHRhcGUgYml0IGN5Y2xlIHBoYXNlXHJcbi8qIGZiZmIgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZmMwY1wiKTsgICAgICAgICAgICAvLyBpZiBiaXQgY3ljbGUgcGhhc2UgY29tcGxldGUgZ28gc2V0dXAgZm9yIG5leHQgYml0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWFjaCBiaXQgaXMgd3JpdHRlbiBhcyB0d28gZnVsbCBjeWNsZXMuIGEgMSBpcyBzZW50IGFzIGEgZnVsbCBjeWNsZSBvZiAkMDE2MCBzeXN0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjbG9ja3MgdGhlbiBhIGZ1bGwgY3ljbGUgb2YgJDAwQzAgc3lzdGVtIGNsb2Nrcy4gYSAwIGlzIHNlbnQgYXMgYSBmdWxsIGN5Y2xlIG9mICQwMEMwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3lzdGVtIGNsb2NrcyB0aGVuIGEgZnVsbCBjeWNsZSBvZiAkMDE2MCBzeXN0ZW0gY2xvY2tzLiB0byBkbyB0aGlzIGVhY2ggYml0IGZyb20gdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd3JpdGUgYnl0ZSBpcyBpbnZlcnRlZCBkdXJpbmcgdGhlIHNlY29uZCBiaXQgY3ljbGUgcGhhc2UuIGFzIHRoZSBiaXQgaXMgaW52ZXJ0ZWQgaXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBhbHNvIGFkZGVkIHRvIHRoZSwgb25lIGJpdCwgcGFyaXR5IGNvdW50IGZvciB0aGlzIGJ5dGVcclxuLyogZmJmZCAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInJvcHJ0eV8wMGJkXCIpOyAgICAgIC8vIGdldCB0YXBlIHdyaXRlIGJ5dGVcclxuLyogZmJmZiAqLyAgICAgICAgICAgICAgICAgICBFT1IuaW1tICgweDAxKTsgICAgICAgICAgICAgICAvLyBpbnZlcnQgYml0IGJlaW5nIHNlbnRcclxuLyogZmMwMSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInJvcHJ0eV8wMGJkXCIpOyAgICAgIC8vIHNhdmUgdGFwZSB3cml0ZSBieXRlXHJcbi8qIGZjMDMgKi8gICAgICAgICAgICAgICAgICAgQU5ELmltbSAoMHgwMSk7ICAgICAgICAgICAgICAgLy8gbWFzayBiMFxyXG4vKiBmYzA1ICovICAgICAgICAgICAgICAgICAgIEVPUi56cGcgKFwicHJ0eV8wMDliXCIpOyAgICAgICAgLy8gRU9SIHdpdGggdGFwZSB3cml0ZSBieXRlIHBhcml0eSBiaXRcclxuLyogZmMwNyAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInBydHlfMDA5YlwiKTsgICAgICAgIC8vIHNhdmUgdGFwZSB3cml0ZSBieXRlIHBhcml0eSBiaXRcclxuLyogZmMwOSAqLyAgICAgICAgX2BfZmMwOWA7ICBKTVAuYWJzIChcIl9mZWJjXCIpOyAgICAgICAgICAgIC8vIHJlc3RvcmUgcmVnaXN0ZXJzIGFuZCBleGl0IGludGVycnVwdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBiaXQgY3ljbGUgcGhhc2UgaXMgY29tcGxldGUgc28gc2hpZnQgb3V0IHRoZSBqdXN0IHdyaXR0ZW4gYml0IGFuZCB0ZXN0IGZvciBieXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5kXHJcbi8qIGZjMGMgKi8gICAgICAgIF9gX2ZjMGNgOyAgTFNSLnpwZyAoXCJyb3BydHlfMDBiZFwiKTsgICAgICAvLyBzaGlmdCBiaXQgb3V0IG9mIHRhcGUgd3JpdGUgYnl0ZVxyXG4vKiBmYzBlICovICAgICAgICAgICAgICAgICAgIERFQy56cGcgKFwidHNmY250XzAwYTNcIik7ICAgICAgLy8gZGVjcmVtZW50IHRhcGUgd3JpdGUgYml0IGNvdW50XHJcbi8qIGZjMTAgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJ0c2ZjbnRfMDBhM1wiKTsgICAgICAvLyBnZXQgdGFwZSB3cml0ZSBiaXQgY291bnRcclxuLyogZmMxMiAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mYzRlXCIpOyAgICAgICAgICAgIC8vIGlmIGFsbCB0aGUgZGF0YSBiaXRzIGhhdmUgYmVlbiB3cml0dGVuIGdvIHNldHVwIGZvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlbmRpbmcgdGhlIHBhcml0eSBiaXQgbmV4dCBhbmQgZXhpdCB0aGUgaW50ZXJydXB0XHJcbi8qIGZjMTQgKi8gICAgICAgICAgICAgICAgICAgQlBMLnJlbCAoXCJfZmMwOVwiKTsgICAgICAgICAgICAvLyBpZiBhbGwgdGhlIGRhdGEgYml0cyBhcmUgbm90IHlldCBzZW50IGp1c3QgcmVzdG9yZSB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWdpc3RlcnMgYW5kIGV4aXQgdGhlIGludGVycnVwdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvIG5leHQgdGFwZSBieXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGJ5dGUgaXMgY29tcGxldGUuIHRoZSBzdGFydCBiaXQsIGRhdGEgYml0cyBhbmQgcGFyaXR5IGJpdCBoYXZlIGJlZW4gd3JpdHRlbiB0b1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSB0YXBlIHNvIHNldHVwIGZvciB0aGUgbmV4dCBieXRlXHJcbi8qIGZjMTYgKi8gICAgICAgIF9gX2ZjMTZgOyAgSlNSLmFicyAoXCJfZmI5N1wiKTsgICAgICAgICAgICAvLyBuZXcgdGFwZSBieXRlIHNldHVwXHJcbi8qIGZjMTkgKi8gICAgICAgICAgICAgICAgICAgQ0xJLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZW5hYmxlIHRoZSBpbnRlcnJ1cHRzXHJcbi8qIGZjMWEgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJjbnRkbl8wMGE1XCIpOyAgICAgICAvLyBnZXQgY2Fzc2V0dGUgc3luY2hyb25pemF0aW9uIGNoYXJhY3RlciBjb3VudFxyXG4vKiBmYzFjICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2ZjMzBcIik7ICAgICAgICAgICAgLy8gaWYgc3luY2hyb25pc2F0aW9uIGNoYXJhY3RlcnMgZG9uZSBnbyBkbyBibG9jayBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXQgdGhlIHN0YXJ0IG9mIGVhY2ggYmxvY2sgc2VudCB0byB0YXBlIHRoZXJlIGFyZSBhIG51bWJlciBvZiBzeW5jaHJvbmlzYXRpb24gYnl0ZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IGNvdW50IGRvd24gdG8gdGhlIGFjdHVhbCBkYXRhLiB0aGUgY29tbW9kb3JlIHRhcGUgc3lzdGVtIHNhdmVzIHR3byBjb3BpZXMgb2YgYWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHRhcGUgZGF0YSwgdGhlIGZpcnN0IGlzIGxvYWRlZCBhbmQgaXMgaW5kaWNhdGVkIGJ5IHRoZSBzeW5jaHJvbmlzYXRpb24gYnl0ZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoYXZpbmcgYjcgc2V0LCBhbmQgdGhlIHNlY29uZCBjb3B5IGlzIGluZGljYXRlZCBieSB0aGUgc3luY2hyb25pc2F0aW9uIGJ5dGVzIGhhdmluZyBiN1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyLiB0aGUgc2VxdWVuY2UgZ29lcyAkMDksICQwOCwgLi4uLi4gJDAyLCAkMDEsIGRhdGEgYnl0ZXNcclxuLyogZmMxZSAqLyAgICAgICAgICAgICAgICAgICBMRFguaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBYXHJcbi8qIGZjMjAgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJzY2hhcl8wMGQ3XCIpOyAgICAgICAvLyBjbGVhciBjaGVja3N1bSBieXRlXHJcbi8qIGZjMjIgKi8gICAgICAgICAgICAgICAgICAgREVDLnpwZyAoXCJjbnRkbl8wMGE1XCIpOyAgICAgICAvLyBkZWNyZW1lbnQgY2Fzc2V0dGUgc3luY2hyb25pemF0aW9uIGJ5dGUgY291bnRcclxuLyogZmMyNCAqLyAgICAgICAgICAgICAgICAgICBMRFguenBnIChcImZzYmxrXzAwYmVcIik7ICAgICAgIC8vIGdldCBjYXNzZXR0ZSBjb3BpZXMgY291bnRcclxuLyogZmMyNiAqLyAgICAgICAgICAgICAgICAgICBDUFguaW1tICgweDAyKTsgICAgICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggbG9hZCBibG9jayBpbmRpY2F0b3JcclxuLyogZmMyOCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mYzJjXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBub3QgdGhlIGxvYWQgYmxvY2tcclxuLyogZmMyYSAqLyAgICAgICAgICAgICAgICAgICBPUkEuaW1tICgweDgwKTsgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBsb2FkIGJsb2NrIHNvIG1ha2UgdGhlIHN5bmNocm9uaXNhdGlvbiBjb3VudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdvICQ4OSwgJDg4LCAuLi4uLiAkODIsICQ4MVxyXG4vKiBmYzJjICovICAgICAgICBfYF9mYzJjYDsgIFNUQS56cGcgKFwicm9wcnR5XzAwYmRcIik7ICAgICAgLy8gc2F2ZSB0aGUgc3luY2hyb25pc2F0aW9uIGJ5dGUgYXMgdGhlIHRhcGUgd3JpdGUgYnl0ZVxyXG4vKiBmYzJlICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2ZjMDlcIik7ICAgICAgICAgICAgLy8gcmVzdG9yZSByZWdpc3RlcnMgYW5kIGV4aXQgaW50ZXJydXB0LCBicmFuY2ggYWx3YXlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHN5bmNocm9uaXphdGlvbiBieXRlcyBoYXZlIGJlZW4gZG9uZSBzbyBub3cgY2hlY2sgYW5kIGRvIHRoZSBhY3R1YWwgYmxvY2sgZGF0YVxyXG4vKiBmYzMwICovICAgICAgICBfYF9mYzMwYDsgIEpTUi5hYnMgKFwiX2ZjZDFcIik7ICAgICAgICAgICAgLy8gY2hlY2sgcmVhZC93cml0ZSBwb2ludGVyLCByZXR1cm4gQ2IgPSAxIGlmIHBvaW50ZXIgPj0gZW5kXHJcbi8qIGZjMzMgKi8gICAgICAgICAgICAgICAgICAgQkNDLnJlbCAoXCJfZmMzZlwiKTsgICAgICAgICAgICAvLyBpZiBub3QgYWxsIGRvbmUgeWV0IGdvIGdldCB0aGUgYnl0ZSB0byBzZW5kXHJcbi8qIGZjMzUgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZmJjOFwiKTsgICAgICAgICAgICAvLyBpZiBwb2ludGVyID4gZW5kIGdvIGZsYWcgYmxvY2sgZG9uZSBhbmQgZXhpdCBpbnRlcnJ1cHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIHRoZSBibG9jayBpcyBjb21wbGV0ZSwgaXQgb25seSByZW1haW5zIHRvIHdyaXRlIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrc3VtIGJ5dGUgdG8gdGhlIHRhcGUgc28gc2V0dXAgZm9yIHRoYXRcclxuLyogZmMzNyAqLyAgICAgICAgICAgICAgICAgICBJTkMuenBnIChcInNhbCsxXzAwYWRcIik7ICAgICAgIC8vIGluY3JlbWVudCBidWZmZXIgcG9pbnRlciBoaWdoIGJ5dGUsIHRoaXMgbWVhbnMgdGhlIGJsb2NrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uZSBicmFuY2ggd2lsbCBhbHdheXMgYmUgdGFrZW4gbmV4dCB0aW1lIHdpdGhvdXQgaGF2aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gd29ycnkgYWJvdXQgdGhlIGxvdyBieXRlIHdyYXBwaW5nIHRvIHplcm9cclxuLyogZmMzOSAqLyAgICAgICAgICAgICAgICAgICBMREEuenBnIChcInNjaGFyXzAwZDdcIik7ICAgICAgIC8vIGdldCBjaGVja3N1bSBieXRlXHJcbi8qIGZjM2IgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJyb3BydHlfMDBiZFwiKTsgICAgICAvLyBzYXZlIGNoZWNrc3VtIGFzIHRhcGUgd3JpdGUgYnl0ZVxyXG4vKiBmYzNkICovICAgICAgICAgICAgICAgICAgIEJDUy5yZWwgKFwiX2ZjMDlcIik7ICAgICAgICAgICAgLy8gcmVzdG9yZSByZWdpc3RlcnMgYW5kIGV4aXQgaW50ZXJydXB0LCBicmFuY2ggYWx3YXlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGJsb2NrIGlzbid0IGZpbmlzaGVkIHNvIGdldCB0aGUgbmV4dCBieXRlIHRvIHdyaXRlIHRvIHRhcGVcclxuLyogZmMzZiAqLyAgICAgICAgX2BfZmMzZmA7ICBMRFkuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBjbGVhciBpbmRleFxyXG4vKiBmYzQxICovICAgICAgICAgICAgICAgICAgIExEQS5pbnkgKFwic2FsKzBfMDBhY1wiKTsgICAgICAgLy8gZ2V0IGJ5dGUgZnJvbSBidWZmZXJcclxuLyogZmM0MyAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInJvcHJ0eV8wMGJkXCIpOyAgICAgIC8vIHNhdmUgYXMgdGFwZSB3cml0ZSBieXRlXHJcbi8qIGZjNDUgKi8gICAgICAgICAgICAgICAgICAgRU9SLnpwZyAoXCJzY2hhcl8wMGQ3XCIpOyAgICAgICAvLyBYT1Igd2l0aCBjaGVja3N1bSBieXRlXHJcbi8qIGZjNDcgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJzY2hhcl8wMGQ3XCIpOyAgICAgICAvLyBzYXZlIG5ldyBjaGVja3N1bSBieXRlXHJcbi8qIGZjNDkgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZmNkYlwiKTsgICAgICAgICAgICAvLyBpbmNyZW1lbnQgcmVhZC93cml0ZSBwb2ludGVyXHJcbi8qIGZjNGMgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZmMwOVwiKTsgICAgICAgICAgICAvLyByZXN0b3JlIHJlZ2lzdGVycyBhbmQgZXhpdCBpbnRlcnJ1cHQsIGJyYW5jaCBhbHdheXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgcGFyaXR5IGFzIG5leHQgYml0IGFuZCBleGl0IGludGVycnVwdFxyXG4vKiBmYzRlICovICAgICAgICBfYF9mYzRlYDsgIExEQS56cGcgKFwicHJ0eV8wMDliXCIpOyAgICAgICAgLy8gZ2V0IHBhcml0eSBiaXRcclxuLyogZmM1MCAqLyAgICAgICAgICAgICAgICAgICBFT1IuaW1tICgweDAxKTsgICAgICAgICAgICAgICAvLyB0b2dnbGUgaXRcclxuLyogZmM1MiAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInJvcHJ0eV8wMGJkXCIpOyAgICAgIC8vIHNhdmUgYXMgdGFwZSB3cml0ZSBieXRlXHJcbi8qIGZjNTQgKi8gICAgICAgIF9gX2ZjNTRgOyAgSk1QLmFicyAoXCJfZmViY1wiKTsgICAgICAgICAgICAvLyByZXN0b3JlIHJlZ2lzdGVycyBhbmQgZXhpdCBpbnRlcnJ1cHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0YXBlIHJvdXRpbmUsIGJsb2NrIGNvbXBsZXRlIGV4aXRcclxuLyogZmM1NyAqLyAgICAgICAgX2BfZmM1N2A7ICBERUMuenBnIChcImZzYmxrXzAwYmVcIik7ICAgICAgIC8vIGRlY3JlbWVudCBjb3BpZXMgcmVtYWluaW5nIHRvIHJlYWQvd3JpdGVcclxuLyogZmM1OSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mYzVlXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBtb3JlIHRvIGRvXHJcbi8qIGZjNWIgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZmNjYVwiKTsgICAgICAgICAgICAvLyBzdG9wIHRoZSBjYXNzZXR0ZSBtb3RvclxyXG4vKiBmYzVlICovICAgICAgICBfYF9mYzVlYDsgIExEQS5pbW0gKDB4NTApOyAgICAgICAgICAgICAgIC8vIHNldCB0YXBlIHdyaXRlIGxlYWRlciBjb3VudFxyXG4vKiBmYzYwICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiaW5iaXRfMDBhN1wiKTsgICAgICAgLy8gc2F2ZSB0YXBlIHdyaXRlIGxlYWRlciBjb3VudFxyXG4vKiBmYzYyICovICAgICAgICAgICAgICAgICAgIExEWC5pbW0gKDB4MDgpOyAgICAgICAgICAgICAgIC8vIHNldCBpbmRleCBmb3Igd3JpdGUgdGFwZSBsZWFkZXIgdmVjdG9yXHJcbi8qIGZjNjQgKi8gICAgICAgICAgICAgICAgICAgU0VJLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZGlzYWJsZSB0aGUgaW50ZXJydXB0c1xyXG4vKiBmYzY1ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2ZjYmRcIik7ICAgICAgICAgICAgLy8gc2V0IHRoZSB0YXBlIHZlY3RvclxyXG4vKiBmYzY4ICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2ZjNTRcIik7ICAgICAgICAgICAgLy8gcmVzdG9yZSByZWdpc3RlcnMgYW5kIGV4aXQgaW50ZXJydXB0LCBicmFuY2ggYWx3YXlzXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHdyaXRlIHRhcGUgbGVhZGVyIElSUSByb3V0aW5lXHJcbi8qIGZjNmEgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHg3OCk7ICAgICAgICAgICAgICAgLy8gc2V0IHRpbWUgY29uc3RhbnQgbG93IGJ5dGUgZm9yIGJpdCA9IGxlYWRlclxyXG4vKiBmYzZjICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2ZiYWZcIik7ICAgICAgICAgICAgLy8gd3JpdGUgdGltZSBjb25zdGFudCBhbmQgdG9nZ2xlIHRhcGVcclxuLyogZmM2ZiAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mYzU0XCIpOyAgICAgICAgICAgIC8vIGlmIHRhcGUgYml0IGhpZ2ggcmVzdG9yZSByZWdpc3RlcnMgYW5kIGV4aXQgaW50ZXJydXB0XHJcbi8qIGZjNzEgKi8gICAgICAgICAgICAgICAgICAgREVDLnpwZyAoXCJpbmJpdF8wMGE3XCIpOyAgICAgICAvLyBkZWNyZW1lbnQgY3ljbGUgY291bnRcclxuLyogZmM3MyAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mYzU0XCIpOyAgICAgICAgICAgIC8vIGlmIG5vdCBhbGwgZG9uZSByZXN0b3JlIHJlZ2lzdGVycyBhbmQgZXhpdCBpbnRlcnJ1cHRcclxuLyogZmM3NSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mYjk3XCIpOyAgICAgICAgICAgIC8vIG5ldyB0YXBlIGJ5dGUgc2V0dXBcclxuLyogZmM3OCAqLyAgICAgICAgICAgICAgICAgICBERUMuenBnIChcInJpcHJ0eV8wMGFiXCIpOyAgICAgIC8vIGRlY3JlbWVudCBjYXNzZXR0ZSBsZWFkZXIgY291bnRcclxuLyogZmM3YSAqLyAgICAgICAgICAgICAgICAgICBCUEwucmVsIChcIl9mYzU0XCIpOyAgICAgICAgICAgIC8vIGlmIG5vdCBhbGwgZG9uZSByZXN0b3JlIHJlZ2lzdGVycyBhbmQgZXhpdCBpbnRlcnJ1cHRcclxuLyogZmM3YyAqLyAgICAgICAgICAgICAgICAgICBMRFguaW1tICgweDBhKTsgICAgICAgICAgICAgICAvLyBzZXQgaW5kZXggZm9yIHRhcGUgd3JpdGUgdmVjdG9yXHJcbi8qIGZjN2UgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZmNiZFwiKTsgICAgICAgICAgICAvLyBzZXQgdGhlIHRhcGUgdmVjdG9yXHJcbi8qIGZjODEgKi8gICAgICAgICAgICAgICAgICAgQ0xJLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gZW5hYmxlIHRoZSBpbnRlcnJ1cHRzXHJcbi8qIGZjODIgKi8gICAgICAgICAgICAgICAgICAgSU5DLnpwZyAoXCJyaXBydHlfMDBhYlwiKTsgICAgICAvLyBjbGVhciBjYXNzZXR0ZSBsZWFkZXIgY291bnRlciwgd2FzICRGRlxyXG4vKiBmYzg0ICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwiZnNibGtfMDBiZVwiKTsgICAgICAgLy8gZ2V0IGNhc3NldHRlIGJsb2NrIGNvdW50XHJcbi8qIGZjODYgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZmNiOFwiKTsgICAgICAgICAgICAvLyBpZiBhbGwgZG9uZSByZXN0b3JlIGV2ZXJ5dGhpbmcgZm9yIFNUT1AgYW5kIGV4aXQgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW50ZXJydXB0XHJcbi8qIGZjODggKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZmI4ZVwiKTsgICAgICAgICAgICAvLyBjb3B5IEkvTyBzdGFydCBhZGRyZXNzIHRvIGJ1ZmZlciBhZGRyZXNzXHJcbi8qIGZjOGIgKi8gICAgICAgICAgICAgICAgICAgTERYLmltbSAoMHgwOSk7ICAgICAgICAgICAgICAgLy8gc2V0IG5pbmUgc3luY2hyb25pc2F0aW9uIGJ5dGVzXHJcbi8qIGZjOGQgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJjbnRkbl8wMGE1XCIpOyAgICAgICAvLyBzYXZlIGNhc3NldHRlIHN5bmNocm9uaXphdGlvbiBieXRlIGNvdW50XHJcbi8qIGZjOGYgKi8gICAgICAgICAgICAgICAgICAgU1RYLnpwZyAoXCJyb2RhdGFfMDBiNlwiKTtcclxuLyogZmM5MSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mYzE2XCIpOyAgICAgICAgICAgIC8vIGdvIGRvIHRoZSBuZXh0IHRhcGUgYnl0ZSwgYnJhbmNoIGFsd2F5c1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyByZXN0b3JlIGV2ZXJ5dGhpbmcgZm9yIFNUT1BcclxuLyogZmM5MyAqLyAgICAgICAgX2BfZmM5M2A7ICBQSFAuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzYXZlIHN0YXR1c1xyXG4vKiBmYzk0ICovICAgICAgICAgICAgICAgICAgIFNFSS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRpc2FibGUgdGhlIGludGVycnVwdHNcclxuLyogZmM5NSAqLyAgICAgICAgICAgICAgICAgICBMREEuYWJzIChcInNjcm9seV9kMDExXCIpOyAgICAgIC8vIHJlYWQgdGhlIHZlcnRpY2FsIGZpbmUgc2Nyb2xsIGFuZCBjb250cm9sIHJlZ2lzdGVyXHJcbi8qIGZjOTggKi8gICAgICAgICAgICAgICAgICAgT1JBLmltbSAoMHgxMCk7ICAgICAgICAgICAgICAgLy8gbWFzayB4eHgxIHh4eHgsIHVuYmxhbmsgdGhlIHNjcmVlblxyXG4vKiBmYzlhICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwic2Nyb2x5X2QwMTFcIik7ICAgICAgLy8gc2F2ZSB0aGUgdmVydGljYWwgZmluZSBzY3JvbGwgYW5kIGNvbnRyb2wgcmVnaXN0ZXJcclxuLyogZmM5ZCAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mY2NhXCIpOyAgICAgICAgICAgIC8vIHN0b3AgdGhlIGNhc3NldHRlIG1vdG9yXHJcbi8qIGZjYTAgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHg3Zik7ICAgICAgICAgICAgICAgLy8gZGlzYWJsZSBhbGwgaW50ZXJydXB0c1xyXG4vKiBmY2EyICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiY2lhaWNyX2RjMGRcIik7ICAgICAgLy8gc2F2ZSBWSUEgMSBJQ1JcclxuLyogZmNhNSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mZGRkXCIpO1xyXG4vKiBmY2E4ICovICAgICAgICAgICAgICAgICAgIExEQS5hYnMgKFwiaXJxdG1wKzFfMDJhMFwiKTsgICAgLy8gZ2V0IHNhdmVkIElSUSB2ZWN0b3IgaGlnaCBieXRlXHJcbi8qIGZjYWIgKi8gICAgICAgICAgICAgICAgICAgQkVRLnJlbCAoXCJfZmNiNlwiKTsgICAgICAgICAgICAvLyBicmFuY2ggaWYgbnVsbFxyXG4vKiBmY2FkICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiY2ludisxXzAzMTVcIik7ICAgICAgLy8gcmVzdG9yZSBJUlEgdmVjdG9yIGhpZ2ggYnl0ZVxyXG4vKiBmY2IwICovICAgICAgICAgICAgICAgICAgIExEQS5hYnMgKFwiaXJxdG1wKzBfMDI5ZlwiKTsgICAgLy8gZ2V0IHNhdmVkIElSUSB2ZWN0b3IgbG93IGJ5dGVcclxuLyogZmNiMyAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcImNpbnYrMF8wMzE0XCIpOyAgICAgIC8vIHJlc3RvcmUgSVJRIHZlY3RvciBsb3cgYnl0ZVxyXG4vKiBmY2I2ICovICAgICAgICBfYF9mY2I2YDsgIFBMUC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgc3RhdHVzXHJcbi8qIGZjYjcgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcmVzZXQgdmVjdG9yXHJcbi8qIGZjYjggKi8gICAgICAgIF9gX2ZjYjhgOyAgSlNSLmFicyAoXCJfZmM5M1wiKTsgICAgICAgICAgICAvLyByZXN0b3JlIGV2ZXJ5dGhpbmcgZm9yIFNUT1BcclxuLyogZmNiYiAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mYzU0XCIpOyAgICAgICAgICAgIC8vIHJlc3RvcmUgcmVnaXN0ZXJzIGFuZCBleGl0IGludGVycnVwdCwgYnJhbmNoIGFsd2F5c1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzZXQgdGFwZSB2ZWN0b3JcclxuLyogZmNiZCAqLyAgICAgICAgX2BfZmNiZGA7ICBMREEuYWJ4ICgweGZkOTMpOyAgICAgICAgICAgICAvLyBnZXQgdGFwZSBJUlEgdmVjdG9yIGxvdyBieXRlXHJcbi8qIGZjYzAgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJjaW52KzBfMDMxNFwiKTsgICAgICAvLyBzZXQgSVJRIHZlY3RvciBsb3cgYnl0ZVxyXG4vKiBmY2MzICovICAgICAgICAgICAgICAgICAgIExEQS5hYnggKDB4ZmQ5NCk7ICAgICAgICAgICAgIC8vIGdldCB0YXBlIElSUSB2ZWN0b3IgaGlnaCBieXRlXHJcbi8qIGZjYzYgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJjaW52KzFfMDMxNVwiKTsgICAgICAvLyBzZXQgSVJRIHZlY3RvciBoaWdoIGJ5dGVcclxuLyogZmNjOSAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzdG9wIHRoZSBjYXNzZXR0ZSBtb3RvclxyXG4vKiBmY2NhICovICAgICAgICBfYF9mY2NhYDsgIExEQS56cGcgKFwicjY1MTBfMDAwMVwiKTsgICAgICAgLy8gcmVhZCB0aGUgNjUxMCBJL08gcG9ydFxyXG4vKiBmY2NjICovICAgICAgICAgICAgICAgICAgIE9SQS5pbW0gKDB4MjApOyAgICAgICAgICAgICAgIC8vIG1hc2sgeHh4eCB4eDF4LCB0dXJuIHRoZSBjYXNzZXR0ZSBtb3RvciBvZmZcclxuLyogZmNjZSAqLyAgICAgICAgICAgICAgICAgICBTVEEuenBnIChcInI2NTEwXzAwMDFcIik7ICAgICAgIC8vIHNhdmUgdGhlIDY1MTAgSS9PIHBvcnRcclxuLyogZmNkMCAqLyAgICAgICAgICAgICAgICAgICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBjaGVjayByZWFkL3dyaXRlIHBvaW50ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gQ2IgPSAxIGlmIHBvaW50ZXIgPj0gZW5kXHJcbi8qIGZjZDEgKi8gICAgICAgIF9gX2ZjZDFgOyAgU0VDLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2V0IGNhcnJ5IGZvciBzdWJ0cmFjdFxyXG4vKiBmY2QyICovICAgICAgICAgICAgICAgICAgIExEQS56cGcgKFwic2FsKzBfMDBhY1wiKTsgICAgICAgLy8gZ2V0IGJ1ZmZlciBhZGRyZXNzIGxvdyBieXRlXHJcbi8qIGZjZDQgKi8gICAgICAgICAgICAgICAgICAgU0JDLnpwZyAoXCJlYWwrMF8wMGFlXCIpOyAgICAgICAvLyBzdWJ0cmFjdCBidWZmZXIgZW5kIGxvdyBieXRlXHJcbi8qIGZjZDYgKi8gICAgICAgICAgICAgICAgICAgTERBLnpwZyAoXCJzYWwrMV8wMGFkXCIpOyAgICAgICAvLyBnZXQgYnVmZmVyIGFkZHJlc3MgaGlnaCBieXRlXHJcbi8qIGZjZDggKi8gICAgICAgICAgICAgICAgICAgU0JDLnpwZyAoXCJlYWwrMV8wMGFmXCIpOyAgICAgICAvLyBzdWJ0cmFjdCBidWZmZXIgZW5kIGhpZ2ggYnl0ZVxyXG4vKiBmY2RhICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGluY3JlbWVudCByZWFkL3dyaXRlIHBvaW50ZXJcclxuLyogZmNkYiAqLyAgICAgICAgX2BfZmNkYmA7ICBJTkMuenBnIChcInNhbCswXzAwYWNcIik7ICAgICAgIC8vIGluY3JlbWVudCBidWZmZXIgYWRkcmVzcyBsb3cgYnl0ZVxyXG4vKiBmY2RkICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2ZjZTFcIik7ICAgICAgICAgICAgLy8gYnJhbmNoIGlmIG5vIG92ZXJmbG93XHJcbi8qIGZjZGYgKi8gICAgICAgICAgICAgICAgICAgSU5DLnpwZyAoXCJzYWwrMV8wMGFkXCIpOyAgICAgICAvLyBpbmNyZW1lbnQgYnVmZmVyIGFkZHJlc3MgbG93IGJ5dGVcclxuLyogZmNlMSAqLyAgICAgICAgX2BfZmNlMWA7ICBSVFMuaW1wICgpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBSRVNFVCwgaGFyZHdhcmUgcmVzZXQgc3RhcnRzIGhlcmVcclxuLyogZmNlMiAqLyAgICAgICAgICAgICAgICAgICBMRFguaW1tICgweGZmKTsgICAgICAgICAgICAgICAvLyBzZXQgWCBmb3Igc3RhY2tcclxuLyogZmNlNCAqLyAgICAgICAgICAgICAgICAgICBTRUkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBkaXNhYmxlIHRoZSBpbnRlcnJ1cHRzXHJcbi8qIGZjZTUgKi8gICAgICAgICAgICAgICAgICAgVFhTLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgc3RhY2tcclxuLyogZmNlNiAqLyAgICAgICAgICAgICAgICAgICBDTEQuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBkZWNpbWFsIG1vZGVcclxuLyogZmNlNyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mZDAyXCIpOyAgICAgICAgICAgIC8vIHNjYW4gZm9yIGF1dG9zdGFydCBST00gYXQgJDgwMDBcclxuLyogZmNlYSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mY2VmXCIpOyAgICAgICAgICAgIC8vIGlmIG5vdCB0aGVyZSBjb250aW51ZSBzdGFydHVwXHJcbi8qIGZjZWMgKi8gICAgICAgICAgICAgICAgICAgSk1QLmluZCAoXCJfODAwMFwiKTsgICAgICAgICAgICAvLyBlbHNlIGNhbGwgUk9NIHN0YXJ0IGNvZGVcclxuLyogZmNlZiAqLyAgICAgICAgX2BfZmNlZmA7ICBTVFguYWJzIChcInNjcm9seF9kMDE2XCIpOyAgICAgIC8vIHJlYWQgdGhlIGhvcml6b250YWwgZmluZSBzY3JvbGwgYW5kIGNvbnRyb2wgcmVnaXN0ZXJcclxuLyogZmNmMiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImlvaW5pdF9mZGEzXCIpOyAgICAgIC8vIGluaXRpYWxpc2UgU0lELCBDSUEgYW5kIElSUVxyXG4vKiBmY2Y1ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwicmFtdGFzX2ZkNTBcIik7ICAgICAgLy8gUkFNIHRlc3QgYW5kIGZpbmQgUkFNIGVuZFxyXG4vKiBmY2Y4ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwicmVzdG9yX2ZkMTVcIik7ICAgICAgLy8gcmVzdG9yZSBkZWZhdWx0IEkvTyB2ZWN0b3JzXHJcbi8qIGZjZmIgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJjaW50X2ZmNWJcIik7ICAgICAgICAvLyBpbml0aWFsaXNlIFZJQyBhbmQgc2NyZWVuIGVkaXRvclxyXG4vKiBmY2ZlICovICAgICAgICAgICAgICAgICAgIENMSS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGVuYWJsZSB0aGUgaW50ZXJydXB0c1xyXG4vKiBmY2ZmICovICAgICAgICAgICAgICAgICAgIEpNUC5pbmQgKFwicmVzdGFydF9hMDAwXCIpOyAgICAgLy8gZXhlY3V0ZSBCQVNJQ1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzY2FuIGZvciBhdXRvc3RhcnQgUk9NIGF0ICQ4MDAwLCByZXR1cm5zIFpiPTEgaWYgUk9NIGZvdW5kXHJcbi8qIGZkMDIgKi8gICAgICAgIF9gX2ZkMDJgOyAgTERYLmltbSAoMHgwNSk7ICAgICAgICAgICAgICAgLy8gZml2ZSBjaGFyYWN0ZXJzIHRvIHRlc3RcclxuLyogZmQwNCAqLyAgICAgICAgX2BfZmQwNGA7ICBMREEuYWJ4IChcIl9mZDBmXCIpOyAgICAgICAgICAgIC8vIGdldCB0ZXN0IGNoYXJhY3RlclxyXG4vKiBmZDA3ICovICAgICAgICAgICAgICAgICAgIENNUC5hYnggKFwiXzgwMDNcIik7ICAgICAgICAgICAgLy8gY29tcGFyZSB3aWl0aCBieXRlIGluIFJPTSBzcGFjZVxyXG4vKiBmZDBhICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2ZkMGZcIik7ICAgICAgICAgICAgLy8gZXhpdCBpZiBubyBtYXRjaFxyXG4vKiBmZDBjICovICAgICAgICAgICAgICAgICAgIERFWC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCBpbmRleFxyXG4vKiBmZDBkICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2ZkMDRcIik7ICAgICAgICAgICAgLy8gbG9vcCBpZiBub3QgYWxsIGRvbmVcclxuLyogZmQwZiAqLyAgICAgICAgX2BfZmQwZmA7ICBSVFMuaW1wICgpO1xyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGF1dG9zdGFydCBST00gc2lnbmF0dXJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ0NCTTgw4oCZXHJcbi8qIGZkMTAgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweGMzLCAweGMyLCAweGNkLCAweDM4LCAweDMwKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcmVzdG9yZSBkZWZhdWx0IEkvTyB2ZWN0b3JzXHJcbi8qIGZkMTUgKi8gIF9gcmVzdG9yX2ZkMTVgOyAgTERYLmltbSAoMHgzMCk7ICAgICAgICAgICAgICAgLy8gcG9pbnRlciB0byB2ZWN0b3IgdGFibGUgbG93IGJ5dGVcclxuLyogZmQxNyAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweGZkKTsgICAgICAgICAgICAgICAvLyBwb2ludGVyIHRvIHZlY3RvciB0YWJsZSBoaWdoIGJ5dGVcclxuLyogZmQxOSAqLyAgICAgICAgICAgICAgICAgICBDTEMuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBmbGFnIHNldCB2ZWN0b3JzXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHNldC9yZWFkIHZlY3RvcmVkIEkvTyBmcm9tIChYWSksIENiID0gMSB0byByZWFkLCBDYiA9IDAgdG8gc2V0XHJcbi8qIGZkMWEgKi8gIF9gdmVjdG9yX2ZkMWFgOyAgU1RYLnpwZyAoXCJtZW11c3MrMF8wMGMzXCIpOyAgICAvLyBzYXZlIHBvaW50ZXIgbG93IGJ5dGVcclxuLyogZmQxYyAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcIm1lbXVzcysxXzAwYzRcIik7ICAgIC8vIHNhdmUgcG9pbnRlciBoaWdoIGJ5dGVcclxuLyogZmQxZSAqLyAgICAgICAgICAgICAgICAgICBMRFkuaW1tICgweDFmKTsgICAgICAgICAgICAgICAvLyBzZXQgYnl0ZSBjb3VudFxyXG4vKiBmZDIwICovICAgICAgICBfYF9mZDIwYDsgIExEQS5hYnkgKFwiY2ludiswXzAzMTRcIik7ICAgICAgLy8gcmVhZCB2ZWN0b3IgYnl0ZSBmcm9tIHZlY3RvcnNcclxuLyogZmQyMyAqLyAgICAgICAgICAgICAgICAgICBCQ1MucmVsIChcIl9mZDI3XCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiByZWFkIHZlY3RvcnNcclxuLyogZmQyNSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW55IChcIm1lbXVzcyswXzAwYzNcIik7ICAgIC8vIHJlYWQgdmVjdG9yIGJ5dGUgZnJvbSAoWFkpXHJcbi8qIGZkMjcgKi8gICAgICAgIF9gX2ZkMjdgOyAgU1RBLmlueSAoXCJtZW11c3MrMF8wMGMzXCIpOyAgICAvLyBzYXZlIGJ5dGUgdG8gKFhZKVxyXG4vKiBmZDI5ICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnkgKFwiY2ludiswXzAzMTRcIik7ICAgICAgLy8gc2F2ZSBieXRlIHRvIHZlY3RvclxyXG4vKiBmZDJjICovICAgICAgICAgICAgICAgICAgIERFWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlbWVudCBpbmRleFxyXG4vKiBmZDJkICovICAgICAgICAgICAgICAgICAgIEJQTC5yZWwgKFwiX2ZkMjBcIik7ICAgICAgICAgICAgLy8gbG9vcCBpZiBtb3JlIHRvIGRvXHJcbi8qIGZkMmYgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgVGhlIGFib3ZlIGNvZGUgd29ya3MgYnV0IGl0IHRyaWVzIHRvIHdyaXRlIHRvIHRoZSBST00uIHdoaWxlIHRoaXMgaXMgdXN1YWxseSBoYXJtbGVzc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBzeXN0ZW1zIHRoYXQgdXNlIGZsYXNoIFJPTSBtYXkgc3VmZmVyLiBIZXJlIGlzIGEgdmVyc2lvbiB0aGF0IG1ha2VzIHRoZSBleHRyYSB3cml0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICB0byBSQU0gaW5zdGVhZCBidXQgaXMgb3RoZXJ3aXNlIGlkZW50aWNhbCBpbiBmdW5jdGlvbi4gIyNcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIHNldC9yZWFkIHZlY3RvcmVkIEkvTyBmcm9tIChYWSksIENiID0gMSB0byByZWFkLCBDYiA9IDAgdG8gc2V0XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNUWCAkQzMgICAgICAgICA7IHNhdmUgcG9pbnRlciBsb3cgYnl0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNUWSAkQzQgICAgICAgICA7IHNhdmUgcG9pbnRlciBoaWdoIGJ5dGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMRFkgIyQxRiAgICAgICAgOyBzZXQgYnl0ZSBjb3VudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExEQSAoJEMzKSxZICAgICA7IHJlYWQgdmVjdG9yIGJ5dGUgZnJvbSAoWFkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQkNDICRGRDI5ICAgICAgIDsgYnJhbmNoIGlmIHNldCB2ZWN0b3JzXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExEQSAkMDMxNCxZICAgICA7IGVsc2UgcmVhZCB2ZWN0b3IgYnl0ZSBmcm9tIHZlY3RvcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTVEEgKCRDMyksWSAgICAgOyBzYXZlIGJ5dGUgdG8gKFhZKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNUQSAkMDMxNCxZICAgICA7IHNhdmUgYnl0ZSB0byB2ZWN0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBERVkgICAgICAgICAgICAgOyBkZWNyZW1lbnQgaW5kZXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCUEwgJEZEMjAgICAgICAgOyBsb29wIGlmIG1vcmUgdG8gZG9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUlRTXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGtlcm5hbCB2ZWN0b3JzXHJcbi8qIGZkMzAgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDMxLCAweGVhKTsgICAgICAgICAgLy8gJDAzMTQgSVJRIHZlY3RvclxyXG4vKiBmZDMyICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg2NiwgMHhmZSk7ICAgICAgICAgIC8vICQwMzE2IEJSSyB2ZWN0b3JcclxuLyogZmQzNCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NDcsIDB4ZmUpOyAgICAgICAgICAvLyAkMDMxOCBOTUkgdmVjdG9yXHJcbi8qIGZkMzYgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDRhLCAweGYzKTsgICAgICAgICAgLy8gJDAzMUEgb3BlbiBhIGxvZ2ljYWwgZmlsZVxyXG4vKiBmZDM4ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg5MSwgMHhmMik7ICAgICAgICAgIC8vICQwMzFDIGNsb3NlIGEgc3BlY2lmaWVkIGxvZ2ljYWwgZmlsZVxyXG4vKiBmZDNhICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgwZSwgMHhmMik7ICAgICAgICAgIC8vICQwMzFFIG9wZW4gY2hhbm5lbCBmb3IgaW5wdXRcclxuLyogZmQzYyAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NTAsIDB4ZjIpOyAgICAgICAgICAvLyAkMDMyMCBvcGVuIGNoYW5uZWwgZm9yIG91dHB1dFxyXG4vKiBmZDNlICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgzMywgMHhmMyk7ICAgICAgICAgIC8vICQwMzIyIGNsb3NlIGlucHV0IGFuZCBvdXRwdXQgY2hhbm5lbHNcclxuLyogZmQ0MCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NTcsIDB4ZjEpOyAgICAgICAgICAvLyAkMDMyNCBpbnB1dCBjaGFyYWN0ZXIgZnJvbSBjaGFubmVsXHJcbi8qIGZkNDIgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweGNhLCAweGYxKTsgICAgICAgICAgLy8gJDAzMjYgb3V0cHV0IGNoYXJhY3RlciB0byBjaGFubmVsXHJcbi8qIGZkNDQgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweGVkLCAweGY2KTsgICAgICAgICAgLy8gJDAzMjggc2NhbiBzdG9wIGtleVxyXG4vKiBmZDQ2ICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgzZSwgMHhmMSk7ICAgICAgICAgIC8vICQwMzJBIGdldCBjaGFyYWN0ZXIgZnJvbSB0aGUgaW5wdXQgZGV2aWNlXHJcbi8qIGZkNDggKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDJmLCAweGYzKTsgICAgICAgICAgLy8gJDAzMkMgY2xvc2UgYWxsIGNoYW5uZWxzIGFuZCBmaWxlc1xyXG4vKiBmZDRhICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg2NiwgMHhmZSk7ICAgICAgICAgIC8vICQwMzJFIHVzZXIgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBWZWN0b3IgdG8gdXNlciBkZWZpbmVkIGNvbW1hbmQsIGN1cnJlbnRseSBwb2ludHMgdG8gQlJLLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgYXBwZWFycyB0byBiZSBhIGhvbGRvdmVyIGZyb20gUEVUIGRheXMsIHdoZW4gdGhlIGJ1aWx0LWluIG1hY2hpbmUgbGFuZ3VhZ2UgbW9uaXRvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdvdWxkIGp1bXAgdGhyb3VnaCB0aGUgJDAzMkUgdmVjdG9yIHdoZW4gaXQgZW5jb3VudGVyZWQgYSBjb21tYW5kIHRoYXQgaXQgZGlkIG5vdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVuZGVyc3RhbmQsIGFsbG93aW5nIHRoZSB1c2VyIHRvIGFkZCBuZXcgY29tbWFuZHMgdG8gdGhlIG1vbml0b3IuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWx0aG91Z2ggdGhpcyB2ZWN0b3IgaXMgaW5pdGlhbGl6ZWQgdG8gcG9pbnQgdG8gdGhlIHJvdXRpbmUgY2FsbGVkIGJ5IFNUT1AvUkVTVE9SRSBhbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgQlJLIGludGVycnVwdCwgYW5kIGlzIHVwZGF0ZWQgYnkgdGhlIGtlcm5hbCB2ZWN0b3Igcm91dGluZSBhdCAkRkQ1NywgaXQgbm8gbG9uZ2VyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFzIGFueSBmdW5jdGlvbi5cclxuLyogZmQ0YyAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4YTUsIDB4ZjQpOyAgICAgICAgICAvLyAkMDMzMCBsb2FkXHJcbi8qIGZkNGUgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweGVkLCAweGY1KTsgICAgICAgICAgLy8gJDAzMzIgc2F2ZVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyB0ZXN0IFJBTSBhbmQgZmluZCBSQU0gZW5kXHJcbi8qIGZkNTAgKi8gIF9gcmFtdGFzX2ZkNTBgOyAgTERBLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgQVxyXG4vKiBmZDUyICovICAgICAgICAgICAgICAgICAgIFRBWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIGluZGV4XHJcbi8qIGZkNTMgKi8gICAgICAgIF9gX2ZkNTNgOyAgU1RBLmFieSAoXCJfMDAwMlwiKTsgICAgICAgICAgICAvLyBjbGVhciBwYWdlIDAsIGRvbid0IGRvICQwMDAwIG9yICQwMDAxXHJcbi8qIGZkNTYgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFieSAoXCJidWYrMF8wMjAwXCIpOyAgICAgICAvLyBjbGVhciBwYWdlIDJcclxuLyogZmQ1OSAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJ5IChcImllcnJvciswXzAzMDBcIik7ICAgIC8vIGNsZWFyIHBhZ2UgM1xyXG4vKiBmZDVjICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBpbmRleFxyXG4vKiBmZDVkICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2ZkNTNcIik7ICAgICAgICAgICAgLy8gbG9vcCBpZiBtb3JlIHRvIGRvXHJcbi8qIGZkNWYgKi8gICAgICAgICAgICAgICAgICAgTERYLmltbSAoMHgzYyk7ICAgICAgICAgICAgICAgLy8gc2V0IGNhc3NldHRlIGJ1ZmZlciBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGZkNjEgKi8gICAgICAgICAgICAgICAgICAgTERZLmltbSAoMHgwMyk7ICAgICAgICAgICAgICAgLy8gc2V0IGNhc3NldHRlIGJ1ZmZlciBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBmZDYzICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwidGFwZTErMF8wMGIyXCIpOyAgICAgLy8gc2F2ZSB0YXBlIGJ1ZmZlciBzdGFydCBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGZkNjUgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJ0YXBlMSsxXzAwYjNcIik7ICAgICAvLyBzYXZlIHRhcGUgYnVmZmVyIHN0YXJ0IHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGZkNjcgKi8gICAgICAgICAgICAgICAgICAgVEFZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgWVxyXG4vKiBmZDY4ICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MDMpOyAgICAgICAgICAgICAgIC8vIHNldCBSQU0gdGVzdCBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBmZDZhICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwic3RhbCsxXzAwYzJcIik7ICAgICAgLy8gc2F2ZSBSQU0gdGVzdCBwb2ludGVyIGhpZ2ggYnl0ZVxyXG4vKiBmZDZjICovICAgICAgICBfYF9mZDZjYDsgIElOQy56cGcgKFwic3RhbCsxXzAwYzJcIik7ICAgICAgLy8gaW5jcmVtZW50IFJBTSB0ZXN0IHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGZkNmUgKi8gICAgICAgIF9gX2ZkNmVgOyAgTERBLmlueSAoXCJzdGFsKzBfMDBjMVwiKTtcclxuLyogZmQ3MCAqLyAgICAgICAgICAgICAgICAgICBUQVguaW1wICgpO1xyXG4vKiBmZDcxICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4NTUpO1xyXG4vKiBmZDczICovICAgICAgICAgICAgICAgICAgIFNUQS5pbnkgKFwic3RhbCswXzAwYzFcIik7XHJcbi8qIGZkNzUgKi8gICAgICAgICAgICAgICAgICAgQ01QLmlueSAoXCJzdGFsKzBfMDBjMVwiKTtcclxuLyogZmQ3NyAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mZDg4XCIpO1xyXG4vKiBmZDc5ICovICAgICAgICAgICAgICAgICAgIFJPTC5hY2MgKCk7XHJcbi8qIGZkN2EgKi8gICAgICAgICAgICAgICAgICAgU1RBLmlueSAoXCJzdGFsKzBfMDBjMVwiKTtcclxuLyogZmQ3YyAqLyAgICAgICAgICAgICAgICAgICBDTVAuaW55IChcInN0YWwrMF8wMGMxXCIpO1xyXG4vKiBmZDdlICovICAgICAgICAgICAgICAgICAgIEJORS5yZWwgKFwiX2ZkODhcIik7XHJcbi8qIGZkODAgKi8gICAgICAgICAgICAgICAgICAgVFhBLmltcCAoKTtcclxuLyogZmQ4MSAqLyAgICAgICAgICAgICAgICAgICBTVEEuaW55IChcInN0YWwrMF8wMGMxXCIpO1xyXG4vKiBmZDgzICovICAgICAgICAgICAgICAgICAgIElOWS5pbXAgKCk7XHJcbi8qIGZkODQgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZmQ2ZVwiKTtcclxuLyogZmQ4NiAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mZDZjXCIpO1xyXG4vKiBmZDg4ICovICAgICAgICBfYF9mZDg4YDsgIFRZQS5pbXAgKCk7XHJcbi8qIGZkODkgKi8gICAgICAgICAgICAgICAgICAgVEFYLmltcCAoKTtcclxuLyogZmQ4YSAqLyAgICAgICAgICAgICAgICAgICBMRFkuenBnIChcInN0YWwrMV8wMGMyXCIpO1xyXG4vKiBmZDhjICovICAgICAgICAgICAgICAgICAgIENMQy5pbXAgKCk7XHJcbi8qIGZkOGQgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZmUyZFwiKTsgICAgICAgICAgICAvLyBzZXQgdGhlIHRvcCBvZiBtZW1vcnlcclxuLyogZmQ5MCAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDA4KTtcclxuLyogZmQ5MiAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcIm1lbXN0cisxXzAyODJcIik7ICAgIC8vIHNhdmUgdGhlIE9TIHN0YXJ0IG9mIG1lbW9yeSBoaWdoIGJ5dGVcclxuLyogZmQ5NSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDA0KTtcclxuLyogZmQ5NyAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcImhpYmFzZV8wMjg4XCIpOyAgICAgIC8vIHNhdmUgdGhlIHNjcmVlbiBtZW1vcnkgcGFnZVxyXG4vKiBmZDlhICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHRhcGUgSVJRIHZlY3RvcnNcclxuLyogZmQ5YiAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NmEsIDB4ZmMpOyAgICAgICAgICAvLyAkMDggd3JpdGUgdGFwZSBsZWFkZXIgSVJRIHJvdXRpbmVcclxuLyogZmQ5ZCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4Y2QsIDB4ZmIpOyAgICAgICAgICAvLyAkMEEgdGFwZSB3cml0ZSBJUlEgcm91dGluZVxyXG4vKiBmZDlmICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgzMSwgMHhlYSk7ICAgICAgICAgIC8vICQwQyBub3JtYWwgSVJRIHZlY3RvclxyXG4vKiBmZGExICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHgyYywgMHhmOSk7ICAgICAgICAgIC8vICQwRSByZWFkIHRhcGUgYml0cyBJUlEgcm91dGluZVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBpbml0aWFsaXNlIFNJRCwgQ0lBIGFuZCBJUlFcclxuLyogZmRhMyAqLyAgX2Bpb2luaXRfZmRhM2A7ICBMREEuaW1tICgweDdmKTsgICAgICAgICAgICAgICAvLyBkaXNhYmxlIGFsbCBpbnRlcnJ1cHRzXHJcbi8qIGZkYTUgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJjaWFpY3JfZGMwZFwiKTsgICAgICAvLyBzYXZlIFZJQSAxIElDUlxyXG4vKiBmZGE4ICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiY2kyaWNyX2RkMGRcIik7ICAgICAgLy8gc2F2ZSBWSUEgMiBJQ1JcclxuLyogZmRhYiAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcImNpYXByYV9kYzAwXCIpOyAgICAgIC8vIHNhdmUgVklBIDEgRFJBLCBrZXlib2FyZCBjb2x1bW4gZHJpdmVcclxuLyogZmRhZSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDA4KTsgICAgICAgICAgICAgICAvLyBzZXQgdGltZXIgc2luZ2xlIHNob3RcclxuLyogZmRiMCAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcImNpYWNyYV9kYzBlXCIpOyAgICAgIC8vIHNhdmUgVklBIDEgQ1JBXHJcbi8qIGZkYjMgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJjaTJjcmFfZGQwZVwiKTsgICAgICAvLyBzYXZlIFZJQSAyIENSQVxyXG4vKiBmZGI2ICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiY2lhY3JiX2RjMGZcIik7ICAgICAgLy8gc2F2ZSBWSUEgMSBDUkJcclxuLyogZmRiOSAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcImNpMmNyYl9kZDBmXCIpOyAgICAgIC8vIHNhdmUgVklBIDIgQ1JCXHJcbi8qIGZkYmMgKi8gICAgICAgICAgICAgICAgICAgTERYLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gc2V0IGFsbCBpbnB1dHNcclxuLyogZmRiZSAqLyAgICAgICAgICAgICAgICAgICBTVFguYWJzIChcImNpZGRyYl9kYzAzXCIpOyAgICAgIC8vIHNhdmUgVklBIDEgRERSQiwga2V5Ym9hcmQgcm93XHJcbi8qIGZkYzEgKi8gICAgICAgICAgICAgICAgICAgU1RYLmFicyAoXCJjMmRkcmJfZGQwM1wiKTsgICAgICAvLyBzYXZlIFZJQSAyIEREUkIsIFJTMjMyIHBvcnRcclxuLyogZmRjNCAqLyAgICAgICAgICAgICAgICAgICBTVFguYWJzIChcInNpZ3ZvbF9kNDE4XCIpOyAgICAgIC8vIGNsZWFyIHRoZSB2b2x1bWUgYW5kIGZpbHRlciBzZWxlY3QgcmVnaXN0ZXJcclxuLyogZmRjNyAqLyAgICAgICAgICAgICAgICAgICBERVguaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzZXQgWCA9ICRGRlxyXG4vKiBmZGM4ICovICAgICAgICAgICAgICAgICAgIFNUWC5hYnMgKFwiY2lkZHJhX2RjMDJcIik7ICAgICAgLy8gc2F2ZSBWSUEgMSBERFJBLCBrZXlib2FyZCBjb2x1bW5cclxuLyogZmRjYiAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDA3KTsgICAgICAgICAgICAgICAvLyBEQVRBIG91dCBoaWdoLCBDTEsgb3V0IGhpZ2gsIEFUTiBvdXQgaGlnaCwgUkUyMzIgVHggREFUQVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhpZ2gsIHZpZGVvIGFkZHJlc3MgMTUgPSAxLCB2aWRlbyBhZGRyZXNzIDE0ID0gMVxyXG4vKiBmZGNkICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiY2kycHJhX2RkMDBcIik7ICAgICAgLy8gc2F2ZSBWSUEgMiBEUkEsIHNlcmlhbCBwb3J0IGFuZCB2aWRlbyBhZGRyZXNzXHJcbi8qIGZkZDAgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgzZik7ICAgICAgICAgICAgICAgLy8gc2V0IHNlcmlhbCBEQVRBIGlucHV0LCBzZXJpYWwgQ0xLIGlucHV0XHJcbi8qIGZkZDIgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJjMmRkcmFfZGQwMlwiKTsgICAgICAvLyBzYXZlIFZJQSAyIEREUkEsIHNlcmlhbCBwb3J0IGFuZCB2aWRlbyBhZGRyZXNzXHJcbi8qIGZkZDUgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHhlNyk7ICAgICAgICAgICAgICAgLy8gc2V0IDExMTAgMDExMSwgbW90b3Igb2ZmLCBlbmFibGUgSS9PLCBlbmFibGUgS0VSTkFMLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVuYWJsZSBCQVNJQ1xyXG4vKiBmZGQ3ICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwicjY1MTBfMDAwMVwiKTsgICAgICAgLy8gc2F2ZSB0aGUgNjUxMCBJL08gcG9ydFxyXG4vKiBmZGQ5ICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4MmYpOyAgICAgICAgICAgICAgIC8vIHNldCAwMDEwIDExMTEsIDAgPSBpbnB1dCwgMSA9IG91dHB1dFxyXG4vKiBmZGRiICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwiZDY1MTBfMDAwMFwiKTsgICAgICAgLy8gc2F2ZSB0aGUgNjUxMCBJL08gcG9ydCBkaXJlY3Rpb24gcmVnaXN0ZXJcclxuLyogZmRkZCAqLyAgICAgICAgX2BfZmRkZGA7ICBMREEuYWJzIChcInR2c2ZsZ18wMmE2XCIpOyAgICAgIC8vIGdldCB0aGUgUEFML05UU0MgZmxhZ1xyXG4vKiBmZGUwICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2ZkZWNcIik7ICAgICAgICAgICAgLy8gaWYgTlRTQyBnbyBzZXQgTlRTQyB0aW1pbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIHNldCBQQUwgdGltaW5nXHJcbi8qIGZkZTIgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgyNSk7XHJcbi8qIGZkZTQgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJ0aW1hbG9fZGMwNFwiKTsgICAgICAvLyBzYXZlIFZJQSAxIHRpbWVyIEEgbG93IGJ5dGVcclxuLyogZmRlNyAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDQwKTtcclxuLyogZmRlOSAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9mZGYzXCIpO1xyXG4vKiBmZGVjICovICAgICAgICBfYF9mZGVjYDsgIExEQS5pbW0gKDB4OTUpO1xyXG4vKiBmZGVlICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwidGltYWxvX2RjMDRcIik7ICAgICAgLy8gc2F2ZSBWSUEgMSB0aW1lciBBIGxvdyBieXRlXHJcbi8qIGZkZjEgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHg0Mik7XHJcbi8qIGZkZjMgKi8gICAgICAgIF9gX2ZkZjNgOyAgU1RBLmFicyAoXCJ0aW1haGlfZGMwNVwiKTsgICAgICAvLyBzYXZlIFZJQSAxIHRpbWVyIEEgaGlnaCBieXRlXHJcbi8qIGZkZjYgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZmY2ZVwiKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gc2V0IGZpbGVuYW1lXHJcbi8qIGZkZjkgKi8gIF9gc2V0bmFtX2ZkZjlgOyAgU1RBLnpwZyAoXCJmbmxlbl8wMGI3XCIpOyAgICAgICAvLyBzZXQgZmlsZSBuYW1lIGxlbmd0aFxyXG4vKiBmZGZiICovICAgICAgICAgICAgICAgICAgIFNUWC56cGcgKFwiZm5hZHIrMF8wMGJiXCIpOyAgICAgLy8gc2V0IGZpbGUgbmFtZSBwb2ludGVyIGxvdyBieXRlXHJcbi8qIGZkZmQgKi8gICAgICAgICAgICAgICAgICAgU1RZLnpwZyAoXCJmbmFkcisxXzAwYmNcIik7ICAgICAvLyBzZXQgZmlsZSBuYW1lIHBvaW50ZXIgaGlnaCBieXRlXHJcbi8qIGZkZmYgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gc2V0IGxvZ2ljYWwsIGZpcnN0IGFuZCBzZWNvbmQgYWRkcmVzc2VzXHJcbi8qIGZlMDAgKi8gIF9gc2V0bGZzX2ZlMDBgOyAgU1RBLnpwZyAoXCJsYV8wMGI4XCIpOyAgICAgICAgICAvLyBzYXZlIHRoZSBsb2dpY2FsIGZpbGVcclxuLyogZmUwMiAqLyAgICAgICAgICAgICAgICAgICBTVFguenBnIChcImZhXzAwYmFcIik7ICAgICAgICAgIC8vIHNhdmUgdGhlIGRldmljZSBudW1iZXJcclxuLyogZmUwNCAqLyAgICAgICAgICAgICAgICAgICBTVFkuenBnIChcInNhXzAwYjlcIik7ICAgICAgICAgIC8vIHNhdmUgdGhlIHNlY29uZGFyeSBhZGRyZXNzXHJcbi8qIGZlMDYgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcmVhZCBJL08gc3RhdHVzIHdvcmRcclxuLyogZmUwNyAqLyAgX2ByZWFkc3RfZmUwN2A7ICBMREEuenBnIChcImZhXzAwYmFcIik7ICAgICAgICAgIC8vIGdldCB0aGUgZGV2aWNlIG51bWJlclxyXG4vKiBmZTA5ICovICAgICAgICAgICAgICAgICAgIENNUC5pbW0gKDB4MDIpOyAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgZGV2aWNlIHdpdGggUlMyMzIgZGV2aWNlXHJcbi8qIGZlMGIgKi8gICAgICAgICAgICAgICAgICAgQk5FLnJlbCAoXCJfZmUxYVwiKTsgICAgICAgICAgICAvLyBpZiBub3QgUlMyMzIgZGV2aWNlIGdvID8/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IFJTMjMyIGRldmljZSBzdGF0dXNcclxuLyogZmUwZCAqLyAgICAgICAgICAgICAgICAgICBMREEuYWJzIChcInJzc3RhdF8wMjk3XCIpOyAgICAgIC8vIGdldCB0aGUgUlMyMzIgc3RhdHVzIHJlZ2lzdGVyXHJcbi8qIGZlMTAgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSB0aGUgUlMyMzIgc3RhdHVzIHZhbHVlXHJcbi8qIGZlMTEgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgwMCk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgQVxyXG4vKiBmZTEzICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwicnNzdGF0XzAyOTdcIik7ICAgICAgLy8gY2xlYXIgdGhlIFJTMjMyIHN0YXR1cyByZWdpc3RlclxyXG4vKiBmZTE2ICovICAgICAgICAgICAgICAgICAgIFBMQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgdGhlIFJTMjMyIHN0YXR1cyB2YWx1ZVxyXG4vKiBmZTE3ICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGNvbnRyb2wga2VybmFsIG1lc3NhZ2VzXHJcbi8qIGZlMTggKi8gIF9gc2V0bXNnX2ZlMThgOyAgU1RBLnpwZyAoXCJtc2dmbGdfMDA5ZFwiKTsgICAgICAvLyBzZXQgbWVzc2FnZSBtb2RlIGZsYWdcclxuLyogZmUxYSAqLyAgICAgICAgX2BfZmUxYWA7ICBMREEuenBnIChcInN0YXR1c18wMDkwXCIpOyAgICAgIC8vIHJlYWQgdGhlIHNlcmlhbCBzdGF0dXMgYnl0ZVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBPUiBpbnRvIHRoZSBzZXJpYWwgc3RhdHVzIGJ5dGVcclxuLyogZmUxYyAqLyAgICAgICAgX2BfZmUxY2A7ICBPUkEuenBnIChcInN0YXR1c18wMDkwXCIpOyAgICAgIC8vIE9SIHdpdGggdGhlIHNlcmlhbCBzdGF0dXMgYnl0ZVxyXG4vKiBmZTFlICovICAgICAgICAgICAgICAgICAgIFNUQS56cGcgKFwic3RhdHVzXzAwOTBcIik7ICAgICAgLy8gc2F2ZSB0aGUgc2VyaWFsIHN0YXR1cyBieXRlXHJcbi8qIGZlMjAgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gc2V0IHRpbWVvdXQgb24gc2VyaWFsIGJ1c1xyXG4vKiBmZTIxICovICBfYHNldHRtb19mZTIxYDsgIFNUQS5hYnMgKFwidGltb3V0XzAyODVcIik7ICAgICAgLy8gc2F2ZSBzZXJpYWwgYnVzIHRpbWVvdXQgZmxhZ1xyXG4vKiBmZTI0ICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHJlYWQvc2V0IHRoZSB0b3Agb2YgbWVtb3J5LCBDYiA9IDEgdG8gcmVhZCwgQ2IgPSAwIHRvIHNldFxyXG4vKiBmZTI1ICovICBfYG1lbXRvcF9mZTI1YDsgIEJDQy5yZWwgKFwiX2ZlMmRcIik7ICAgICAgICAgICAgLy8gaWYgQ2IgY2xlYXIgZ28gc2V0IHRoZSB0b3Agb2YgbWVtb3J5XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHJlYWQgdGhlIHRvcCBvZiBtZW1vcnlcclxuLyogZmUyNyAqLyAgICAgICAgX2BfZmUyN2A7ICBMRFguYWJzIChcIm1lbXNpeiswXzAyODNcIik7ICAgIC8vIGdldCBtZW1vcnkgdG9wIGxvdyBieXRlXHJcbi8qIGZlMmEgKi8gICAgICAgICAgICAgICAgICAgTERZLmFicyAoXCJtZW1zaXorMV8wMjg0XCIpOyAgICAvLyBnZXQgbWVtb3J5IHRvcCBoaWdoIGJ5dGVcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gc2V0IHRoZSB0b3Agb2YgbWVtb3J5XHJcbi8qIGZlMmQgKi8gICAgICAgIF9gX2ZlMmRgOyAgU1RYLmFicyAoXCJtZW1zaXorMF8wMjgzXCIpOyAgICAvLyBzZXQgbWVtb3J5IHRvcCBsb3cgYnl0ZVxyXG4vKiBmZTMwICovICAgICAgICAgICAgICAgICAgIFNUWS5hYnMgKFwibWVtc2l6KzFfMDI4NFwiKTsgICAgLy8gc2V0IG1lbW9yeSB0b3AgaGlnaCBieXRlXHJcbi8qIGZlMzMgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcmVhZC9zZXQgdGhlIGJvdHRvbSBvZiBtZW1vcnksIENiID0gMSB0byByZWFkLCBDYiA9IDAgdG8gc2V0XHJcbi8qIGZlMzQgKi8gIF9gbWVtYm90X2ZlMzRgOyAgQkNDLnJlbCAoXCJfZmUzY1wiKTsgICAgICAgICAgICAvLyBpZiBDYiBjbGVhciBnbyBzZXQgdGhlIGJvdHRvbSBvZiBtZW1vcnlcclxuLyogZmUzNiAqLyAgICAgICAgICAgICAgICAgICBMRFguYWJzIChcIm1lbXN0ciswXzAyODFcIik7ICAgIC8vIGdldCB0aGUgT1Mgc3RhcnQgb2YgbWVtb3J5IGxvdyBieXRlXHJcbi8qIGZlMzkgKi8gICAgICAgICAgICAgICAgICAgTERZLmFicyAoXCJtZW1zdHIrMV8wMjgyXCIpOyAgICAvLyBnZXQgdGhlIE9TIHN0YXJ0IG9mIG1lbW9yeSBoaWdoIGJ5dGVcclxuLyogZmUzYyAqLyAgICAgICAgX2BfZmUzY2A7ICBTVFguYWJzIChcIm1lbXN0ciswXzAyODFcIik7ICAgIC8vIHNhdmUgdGhlIE9TIHN0YXJ0IG9mIG1lbW9yeSBsb3cgYnl0ZVxyXG4vKiBmZTNmICovICAgICAgICAgICAgICAgICAgIFNUWS5hYnMgKFwibWVtc3RyKzFfMDI4MlwiKTsgICAgLy8gc2F2ZSB0aGUgT1Mgc3RhcnQgb2YgbWVtb3J5IGhpZ2ggYnl0ZVxyXG4vKiBmZTQyICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIE5NSSB2ZWN0b3JcclxuLyogZmU0MyAqLyAgICAgICAgICAgICAgICAgICBTRUkuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBkaXNhYmxlIHRoZSBpbnRlcnJ1cHRzXHJcbi8qIGZlNDQgKi8gICAgICAgICAgICAgICAgICAgSk1QLmluZCAoXCJubWludiswXzAzMThcIik7ICAgICAvLyBkbyBOTUkgdmVjdG9yXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIE5NSSBoYW5kbGVyXHJcbi8qIGZlNDcgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBBXHJcbi8qIGZlNDggKi8gICAgICAgICAgICAgICAgICAgVFhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBYXHJcbi8qIGZlNDkgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBYXHJcbi8qIGZlNGEgKi8gICAgICAgICAgICAgICAgICAgVFlBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gY29weSBZXHJcbi8qIGZlNGIgKi8gICAgICAgICAgICAgICAgICAgUEhBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBZXHJcbi8qIGZlNGMgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHg3Zik7ICAgICAgICAgICAgICAgLy8gZGlzYWJsZSBhbGwgaW50ZXJydXB0c1xyXG4vKiBmZTRlICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiY2kyaWNyX2RkMGRcIik7ICAgICAgLy8gc2F2ZSBWSUEgMiBJQ1JcclxuLyogZmU1MSAqLyAgICAgICAgICAgICAgICAgICBMRFkuYWJzIChcImNpMmljcl9kZDBkXCIpOyAgICAgIC8vIHNhdmUgVklBIDIgSUNSXHJcbi8qIGZlNTQgKi8gICAgICAgICAgICAgICAgICAgQk1JLnJlbCAoXCJfZmU3MlwiKTtcclxuLyogZmU1NiAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcIl9mZDAyXCIpOyAgICAgICAgICAgIC8vIHNjYW4gZm9yIGF1dG9zdGFydCBST00gYXQgJDgwMDBcclxuLyogZmU1OSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mZTVlXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBubyBhdXRvc3RhcnQgUk9NXHJcbi8qIGZlNWIgKi8gICAgICAgICAgICAgICAgICAgSk1QLmluZCAoXCJfODAwMlwiKTsgICAgICAgICAgICAvLyBlbHNlIGRvIGF1dG9zdGFydCBST00gYnJlYWsgZW50cnlcclxuLyogZmU1ZSAqLyAgICAgICAgX2BfZmU1ZWA7ICBKU1IuYWJzIChcIl9mNmJjXCIpOyAgICAgICAgICAgIC8vIGluY3JlbWVudCByZWFsIHRpbWUgY2xvY2tcclxuLyogZmU2MSAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcInN0b3BfZmZlMVwiKTsgICAgICAgIC8vIHNjYW4gc3RvcCBrZXlcclxuLyogZmU2NCAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mZTcyXCIpOyAgICAgICAgICAgIC8vIGlmIG5vdCBbU1RPUF0gcmVzdG9yZSByZWdpc3RlcnMgYW5kIGV4aXQgaW50ZXJydXB0XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHVzZXIgZnVuY3Rpb24gZGVmYXVsdCB2ZWN0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCUksgaGFuZGxlclxyXG4vKiBmZTY2ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwicmVzdG9yX2ZkMTVcIik7ICAgICAgLy8gcmVzdG9yZSBkZWZhdWx0IEkvTyB2ZWN0b3JzXHJcbi8qIGZlNjkgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJpb2luaXRfZmRhM1wiKTsgICAgICAvLyBpbml0aWFsaXNlIFNJRCwgQ0lBIGFuZCBJUlFcclxuLyogZmU2YyAqLyAgICAgICAgICAgICAgICAgICBKU1IuYWJzIChcImNpbnQxX2U1MThcIik7ICAgICAgIC8vIGluaXRpYWxpc2UgdGhlIHNjcmVlbiBhbmQga2V5Ym9hcmRcclxuLyogZmU2ZiAqLyAgICAgICAgICAgICAgICAgICBKTVAuaW5kIChcIl9hMDAyXCIpOyAgICAgICAgICAgIC8vIGRvIEJBU0lDIGJyZWFrIGVudHJ5XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIFJTMjMyIE5NSSByb3V0aW5lXHJcbi8qIGZlNzIgKi8gICAgICAgIF9gX2ZlNzJgOyAgVFlBLmltcCAoKTtcclxuLyogZmU3MyAqLyAgICAgICAgICAgICAgICAgICBBTkQuYWJzIChcImVuYWJsXzAyYTFcIik7ICAgICAgIC8vIEFORCB3aXRoIHRoZSBSUy0yMzIgaW50ZXJydXB0IGVuYWJsZSBieXRlXHJcbi8qIGZlNzYgKi8gICAgICAgICAgICAgICAgICAgVEFYLmltcCAoKTtcclxuLyogZmU3NyAqLyAgICAgICAgICAgICAgICAgICBBTkQuaW1tICgweDAxKTtcclxuLyogZmU3OSAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mZWEzXCIpO1xyXG4vKiBmZTdiICovICAgICAgICAgICAgICAgICAgIExEQS5hYnMgKFwiY2kycHJhX2RkMDBcIik7ICAgICAgLy8gcmVhZCBWSUEgMiBEUkEsIHNlcmlhbCBwb3J0IGFuZCB2aWRlbyBhZGRyZXNzXHJcbi8qIGZlN2UgKi8gICAgICAgICAgICAgICAgICAgQU5ELmltbSAoMHhmYik7ICAgICAgICAgICAgICAgLy8gbWFzayB4eHh4IHgweHgsIGNsZWFyIFJTMjMyIFR4IERBVEFcclxuLyogZmU4MCAqLyAgICAgICAgICAgICAgICAgICBPUkEuenBnIChcIm54dGJpdF8wMGI1XCIpOyAgICAgIC8vIE9SIGluIHRoZSBSUzIzMiB0cmFuc21pdCBkYXRhIGJpdFxyXG4vKiBmZTgyICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiY2kycHJhX2RkMDBcIik7ICAgICAgLy8gc2F2ZSBWSUEgMiBEUkEsIHNlcmlhbCBwb3J0IGFuZCB2aWRlbyBhZGRyZXNzXHJcbi8qIGZlODUgKi8gICAgICAgICAgICAgICAgICAgTERBLmFicyAoXCJlbmFibF8wMmExXCIpOyAgICAgICAvLyBnZXQgdGhlIFJTLTIzMiBpbnRlcnJ1cHQgZW5hYmxlIGJ5dGVcclxuLyogZmU4OCAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcImNpMmljcl9kZDBkXCIpOyAgICAgIC8vIHNhdmUgVklBIDIgSUNSXHJcbi8qIGZlOGIgKi8gICAgICAgICAgICAgICAgICAgVFhBLmltcCAoKTtcclxuLyogZmU4YyAqLyAgICAgICAgICAgICAgICAgICBBTkQuaW1tICgweDEyKTtcclxuLyogZmU4ZSAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mZTlkXCIpO1xyXG4vKiBmZTkwICovICAgICAgICAgICAgICAgICAgIEFORC5pbW0gKDB4MDIpO1xyXG4vKiBmZTkyICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2ZlOWFcIik7XHJcbi8qIGZlOTQgKi8gICAgICAgICAgICAgICAgICAgSlNSLmFicyAoXCJfZmVkNlwiKTtcclxuLyogZmU5NyAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9mZTlkXCIpO1xyXG4vKiBmZTlhICovICAgICAgICBfYF9mZTlhYDsgIEpTUi5hYnMgKFwiX2ZmMDdcIik7XHJcbi8qIGZlOWQgKi8gICAgICAgIF9gX2ZlOWRgOyAgSlNSLmFicyAoXCJfZWViYlwiKTtcclxuLyogZmVhMCAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9mZWI2XCIpO1xyXG4vKiBmZWEzICovICAgICAgICBfYF9mZWEzYDsgIFRYQS5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIGdldCBhY3RpdmUgaW50ZXJydXB0cyBiYWNrXHJcbi8qIGZlYTQgKi8gICAgICAgICAgICAgICAgICAgQU5ELmltbSAoMHgwMik7ICAgICAgICAgICAgICAgLy8gbWFzayA/PyBpbnRlcnJ1cHRcclxuLyogZmVhNiAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mZWFlXCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBub3QgPz8gaW50ZXJydXB0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2FzID8/IGludGVycnVwdFxyXG4vKiBmZWE4ICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2ZlZDZcIik7XHJcbi8qIGZlYWIgKi8gICAgICAgICAgICAgICAgICAgSk1QLmFicyAoXCJfZmViNlwiKTtcclxuLyogZmVhZSAqLyAgICAgICAgX2BfZmVhZWA7ICBUWEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBnZXQgYWN0aXZlIGludGVycnVwdHMgYmFja1xyXG4vKiBmZWFmICovICAgICAgICAgICAgICAgICAgIEFORC5pbW0gKDB4MTApOyAgICAgICAgICAgICAgIC8vIG1hc2sgQ0IxIGludGVycnVwdCwgUnggZGF0YSBiaXQgdHJhbnNpdGlvblxyXG4vKiBmZWIxICovICAgICAgICAgICAgICAgICAgIEJFUS5yZWwgKFwiX2ZlYjZcIik7ICAgICAgICAgICAgLy8gaWYgbm8gYml0IHJlc3RvcmUgcmVnaXN0ZXJzIGFuZCBleGl0IGludGVycnVwdFxyXG4vKiBmZWIzICovICAgICAgICAgICAgICAgICAgIEpTUi5hYnMgKFwiX2ZmMDdcIik7XHJcbi8qIGZlYjYgKi8gICAgICAgIF9gX2ZlYjZgOyAgTERBLmFicyAoXCJlbmFibF8wMmExXCIpOyAgICAgICAvLyBnZXQgdGhlIFJTLTIzMiBpbnRlcnJ1cHQgZW5hYmxlIGJ5dGVcclxuLyogZmViOSAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcImNpMmljcl9kZDBkXCIpOyAgICAgIC8vIHNhdmUgVklBIDIgSUNSXHJcbi8qIGZlYmMgKi8gICAgICAgIF9gX2ZlYmNgOyAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVsbCBZXHJcbi8qIGZlYmQgKi8gICAgICAgICAgICAgICAgICAgVEFZLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBZXHJcbi8qIGZlYmUgKi8gICAgICAgICAgICAgICAgICAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcHVsbCBYXHJcbi8qIGZlYmYgKi8gICAgICAgICAgICAgICAgICAgVEFYLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBYXHJcbi8qIGZlYzAgKi8gICAgICAgIF9gX2ZlYzBgOyAgUExBLmltcCAoKTsgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBBXHJcbi8qIGZlYzEgKi8gICAgICAgIF9gX2ZlYzFgOyAgUlRJLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gYmF1ZCByYXRlIHdvcmQgaXMgY2FsY3VsYXRlZCBmcm9tIC4uXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIChzeXN0ZW0gY2xvY2sgLyBiYXVkIHJhdGUpIC8gMiAtIDEwMFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgc3lzdGVtIGNsb2NrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIC0tLS0tLS0tLS0tLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBBTCAgICAgICAgOTg1MjQ4IEh6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTlRTQyAgICAgMTAyMjcyNyBIelxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJhdWQgcmF0ZSB0YWJsZXMgZm9yIE5UU0MgQzY0XHJcbi8qIGZlYzIgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweGMxLCAweDI3KTsgICAgICAgICAgLy8gICA1MCAgIGJhdWQgICAxMDI3NzAwXHJcbi8qIGZlYzQgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDNlLCAweDFhKTsgICAgICAgICAgLy8gICA3NSAgIGJhdWQgICAxMDIyNzAwXHJcbi8qIGZlYzYgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweGM1LCAweDExKTsgICAgICAgICAgLy8gIDExMCAgIGJhdWQgICAxMDIyNzgwXHJcbi8qIGZlYzggKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDc0LCAweDBlKTsgICAgICAgICAgLy8gIDEzNC41IGJhdWQgICAxMDIyMjAwXHJcbi8qIGZlY2EgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweGVkLCAweDBjKTsgICAgICAgICAgLy8gIDE1MCAgIGJhdWQgICAxMDIyNzAwXHJcbi8qIGZlY2MgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDQ1LCAweDA2KTsgICAgICAgICAgLy8gIDMwMCAgIGJhdWQgICAxMDIzMDAwXHJcbi8qIGZlY2UgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweGYwLCAweDAyKTsgICAgICAgICAgLy8gIDYwMCAgIGJhdWQgICAxMDIyNDAwXHJcbi8qIGZlZDAgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDQ2LCAweDAxKTsgICAgICAgICAgLy8gMTIwMCAgIGJhdWQgICAxMDIyNDAwXHJcbi8qIGZlZDIgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweGI4LCAweDAwKTsgICAgICAgICAgLy8gMTgwMCAgIGJhdWQgICAxMDIyNDAwXHJcbi8qIGZlZDQgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDcxLCAweDAwKTsgICAgICAgICAgLy8gMjQwMCAgIGJhdWQgICAxMDIyNDAwXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vID8/XHJcbi8qIGZlZDYgKi8gICAgICAgIF9gX2ZlZDZgOyAgTERBLmFicyAoXCJjaTJwcmJfZGQwMVwiKTsgICAgICAvLyByZWFkIFZJQSAyIERSQiwgUlMyMzIgcG9ydFxyXG4vKiBmZWQ5ICovICAgICAgICAgICAgICAgICAgIEFORC5pbW0gKDB4MDEpOyAgICAgICAgICAgICAgIC8vIG1hc2sgMDAwMCAwMDB4LCBSUzIzMiBSeCBEQVRBXHJcbi8qIGZlZGIgKi8gICAgICAgICAgICAgICAgICAgU1RBLnpwZyAoXCJpbmJpdF8wMGE3XCIpOyAgICAgICAvLyBzYXZlIHRoZSBSUzIzMiByZWNlaXZlZCBkYXRhIGJpdFxyXG4vKiBmZWRkICovICAgICAgICAgICAgICAgICAgIExEQS5hYnMgKFwidGkyYmxvX2RkMDZcIik7ICAgICAgLy8gZ2V0IFZJQSAyIHRpbWVyIEIgbG93IGJ5dGVcclxuLyogZmVlMCAqLyAgICAgICAgICAgICAgICAgICBTQkMuaW1tICgweDFjKTtcclxuLyogZmVlMiAqLyAgICAgICAgICAgICAgICAgICBBREMuYWJzIChcImJhdWRvZiswXzAyOTlcIik7XHJcbi8qIGZlZTUgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJ0aTJibG9fZGQwNlwiKTsgICAgICAvLyBzYXZlIFZJQSAyIHRpbWVyIEIgbG93IGJ5dGVcclxuLyogZmVlOCAqLyAgICAgICAgICAgICAgICAgICBMREEuYWJzIChcInRpMmJoaV9kZDA3XCIpOyAgICAgIC8vIGdldCBWSUEgMiB0aW1lciBCIGhpZ2ggYnl0ZVxyXG4vKiBmZWViICovICAgICAgICAgICAgICAgICAgIEFEQy5hYnMgKFwiYmF1ZG9mKzFfMDI5YVwiKTtcclxuLyogZmVlZSAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcInRpMmJoaV9kZDA3XCIpOyAgICAgIC8vIHNhdmUgVklBIDIgdGltZXIgQiBoaWdoIGJ5dGVcclxuLyogZmVmMSAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweDExKTsgICAgICAgICAgICAgICAvLyBzZXQgdGltZXIgQiBzaW5nbGUgc2hvdCwgc3RhcnQgdGltZXIgQlxyXG4vKiBmZWYzICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiY2kyY3JiX2RkMGZcIik7ICAgICAgLy8gc2F2ZSBWSUEgMiBDUkJcclxuLyogZmVmNiAqLyAgICAgICAgICAgICAgICAgICBMREEuYWJzIChcImVuYWJsXzAyYTFcIik7ICAgICAgIC8vIGdldCB0aGUgUlMtMjMyIGludGVycnVwdCBlbmFibGUgYnl0ZVxyXG4vKiBmZWY5ICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiY2kyaWNyX2RkMGRcIik7ICAgICAgLy8gc2F2ZSBWSUEgMiBJQ1JcclxuLyogZmVmYyAqLyAgICAgICAgICAgICAgICAgICBMREEuaW1tICgweGZmKTtcclxuLyogZmVmZSAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcInRpMmJsb19kZDA2XCIpOyAgICAgIC8vIHNhdmUgVklBIDIgdGltZXIgQiBsb3cgYnl0ZVxyXG4vKiBmZjAxICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwidGkyYmhpX2RkMDdcIik7ICAgICAgLy8gc2F2ZSBWSUEgMiB0aW1lciBCIGhpZ2ggYnl0ZVxyXG4vKiBmZjA0ICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2VmNTlcIik7XHJcbi8qIGZmMDcgKi8gICAgICAgIF9gX2ZmMDdgOyAgTERBLmFicyAoXCJtNTFhamIrMF8wMjk1XCIpOyAgICAvLyBub25zdGFuZGFyZCBiaXQgdGltaW5nIGxvdyBieXRlXHJcbi8qIGZmMGEgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJ0aTJibG9fZGQwNlwiKTsgICAgICAvLyBzYXZlIFZJQSAyIHRpbWVyIEIgbG93IGJ5dGVcclxuLyogZmYwZCAqLyAgICAgICAgICAgICAgICAgICBMREEuYWJzIChcIm01MWFqYisxXzAyOTZcIik7ICAgIC8vIG5vbnN0YW5kYXJkIGJpdCB0aW1pbmcgaGlnaCBieXRlXHJcbi8qIGZmMTAgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJ0aTJiaGlfZGQwN1wiKTsgICAgICAvLyBzYXZlIFZJQSAyIHRpbWVyIEIgaGlnaCBieXRlXHJcbi8qIGZmMTMgKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgxMSk7ICAgICAgICAgICAgICAgLy8gc2V0IHRpbWVyIEIgc2luZ2xlIHNob3QsIHN0YXJ0IHRpbWVyIEJcclxuLyogZmYxNSAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcImNpMmNyYl9kZDBmXCIpOyAgICAgIC8vIHNhdmUgVklBIDIgQ1JCXHJcbi8qIGZmMTggKi8gICAgICAgICAgICAgICAgICAgTERBLmltbSAoMHgxMik7XHJcbi8qIGZmMWEgKi8gICAgICAgICAgICAgICAgICAgRU9SLmFicyAoXCJlbmFibF8wMmExXCIpOyAgICAgICAvLyBFT1Igd2l0aCB0aGUgUlMtMjMyIGludGVycnVwdCBlbmFibGUgYnl0ZVxyXG4vKiBmZjFkICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiZW5hYmxfMDJhMVwiKTsgICAgICAgLy8gc2F2ZSB0aGUgUlMtMjMyIGludGVycnVwdCBlbmFibGUgYnl0ZVxyXG4vKiBmZjIwICovICAgICAgICAgICAgICAgICAgIExEQS5pbW0gKDB4ZmYpO1xyXG4vKiBmZjIyICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwidGkyYmxvX2RkMDZcIik7ICAgICAgLy8gc2F2ZSBWSUEgMiB0aW1lciBCIGxvdyBieXRlXHJcbi8qIGZmMjUgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJ0aTJiaGlfZGQwN1wiKTsgICAgICAvLyBzYXZlIFZJQSAyIHRpbWVyIEIgaGlnaCBieXRlXHJcbi8qIGZmMjggKi8gICAgICAgICAgICAgICAgICAgTERYLmFicyAoXCJiaXRudW1fMDI5OFwiKTtcclxuLyogZmYyYiAqLyAgICAgICAgICAgICAgICAgICBTVFguenBnIChcImJpdGNpXzAwYThcIik7XHJcbi8qIGZmMmQgKi8gICAgICAgICAgICAgICAgICAgUlRTLmltcCAoKTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gPz9cclxuLyogZmYyZSAqLyAgICAgICAgX2BfZmYyZWA7ICBUQVguaW1wICgpO1xyXG4vKiBmZjJmICovICAgICAgICAgICAgICAgICAgIExEQS5hYnMgKFwibTUxYWpiKzFfMDI5NlwiKTsgICAgLy8gbm9uc3RhbmRhcmQgYml0IHRpbWluZyBoaWdoIGJ5dGVcclxuLyogZmYzMiAqLyAgICAgICAgICAgICAgICAgICBST0wuYWNjICgpO1xyXG4vKiBmZjMzICovICAgICAgICAgICAgICAgICAgIFRBWS5pbXAgKCk7XHJcbi8qIGZmMzQgKi8gICAgICAgICAgICAgICAgICAgVFhBLmltcCAoKTtcclxuLyogZmYzNSAqLyAgICAgICAgICAgICAgICAgICBBREMuaW1tICgweGM4KTtcclxuLyogZmYzNyAqLyAgICAgICAgICAgICAgICAgICBTVEEuYWJzIChcImJhdWRvZiswXzAyOTlcIik7XHJcbi8qIGZmM2EgKi8gICAgICAgICAgICAgICAgICAgVFlBLmltcCAoKTtcclxuLyogZmYzYiAqLyAgICAgICAgICAgICAgICAgICBBREMuaW1tICgweDAwKTsgICAgICAgICAgICAgICAvLyBhZGQgYW55IGNhcnJ5XHJcbi8qIGZmM2QgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJiYXVkb2YrMV8wMjlhXCIpO1xyXG4vKiBmZjQwICovICAgICAgICAgICAgICAgICAgIFJUUy5pbXAgKCk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHVudXNlZCBieXRlc1xyXG4vKiBmZjQxICovICAgICAgICAgICAgICAgICAgIE5PUC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHdhc3RlIGN5Y2xlc1xyXG4vKiBmZjQyICovICAgICAgICAgICAgICAgICAgIE5PUC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHdhc3RlIGN5Y2xlc1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzYXZlIHRoZSBzdGF0dXMgYW5kIGRvIHRoZSBJUlEgcm91dGluZVxyXG4vKiBmZjQzICovICAgICAgICBfYF9mZjQzYDsgIFBIUC5pbXAgKCk7ICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgdGhlIHByb2Nlc3NvciBzdGF0dXNcclxuLyogZmY0NCAqLyAgICAgICAgICAgICAgICAgICBQTEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBwdWxsIHRoZSBwcm9jZXNzb3Igc3RhdHVzXHJcbi8qIGZmNDUgKi8gICAgICAgICAgICAgICAgICAgQU5ELmltbSAoMHhlZik7ICAgICAgICAgICAgICAgLy8gbWFzayB4eHgwIHh4eHgsIGNsZWFyIHRoZSBicmVhayBiaXRcclxuLyogZmY0NyAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzYXZlIHRoZSBtb2RpZmllZCBwcm9jZXNzb3Igc3RhdHVzXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIElSUSB2ZWN0b3JcclxuLyogZmY0OCAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzYXZlIEFcclxuLyogZmY0OSAqLyAgICAgICAgICAgICAgICAgICBUWEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IFhcclxuLyogZmY0YSAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzYXZlIFhcclxuLyogZmY0YiAqLyAgICAgICAgICAgICAgICAgICBUWUEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IFlcclxuLyogZmY0YyAqLyAgICAgICAgICAgICAgICAgICBQSEEuaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBzYXZlIFlcclxuLyogZmY0ZCAqLyAgICAgICAgICAgICAgICAgICBUU1guaW1wICgpOyAgICAgICAgICAgICAgICAgICAvLyBjb3B5IHN0YWNrIHBvaW50ZXJcclxuLyogZmY0ZSAqLyAgICAgICAgICAgICAgICAgICBMREEuYWJ4IChcImJhZCs0XzAxMDRcIik7ICAgICAgIC8vIGdldCBzdGFja2VkIHN0YXR1cyByZWdpc3RlclxyXG4vKiBmZjUxICovICAgICAgICAgICAgICAgICAgIEFORC5pbW0gKDB4MTApOyAgICAgICAgICAgICAgIC8vIG1hc2sgQlJLIGZsYWdcclxuLyogZmY1MyAqLyAgICAgICAgICAgICAgICAgICBCRVEucmVsIChcIl9mZjU4XCIpOyAgICAgICAgICAgIC8vIGJyYW5jaCBpZiBub3QgQlJLXHJcbi8qIGZmNTUgKi8gICAgICAgICAgICAgICAgICAgSk1QLmluZCAoXCJjYmludiswXzAzMTZcIik7ICAgICAvLyBlbHNlIGRvIEJSSyB2ZWN0b3IgKGlCUkspXHJcbi8qIGZmNTggKi8gICAgICAgIF9gX2ZmNThgOyAgSk1QLmluZCAoXCJjaW52KzBfMDMxNFwiKTsgICAgICAvLyBkbyBJUlEgdmVjdG9yIChpSVJRKVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBpbml0aWFsaXNlIFZJQyBhbmQgc2NyZWVuIGVkaXRvclxyXG4vKiBmZjViICovICAgIF9gY2ludF9mZjViYDsgIEpTUi5hYnMgKFwiY2ludDFfZTUxOFwiKTsgICAgICAgLy8gaW5pdGlhbGlzZSB0aGUgc2NyZWVuIGFuZCBrZXlib2FyZFxyXG4vKiBmZjVlICovICAgICAgICBfYF9mZjVlYDsgIExEQS5hYnMgKFwicmFzdGVyX2QwMTJcIik7ICAgICAgLy8gcmVhZCB0aGUgcmFzdGVyIGNvbXBhcmUgcmVnaXN0ZXJcclxuLyogZmY2MSAqLyAgICAgICAgICAgICAgICAgICBCTkUucmVsIChcIl9mZjVlXCIpOyAgICAgICAgICAgIC8vIGxvb3AgaWYgbm90IHJhc3RlciBsaW5lICQwMFxyXG4vKiBmZjYzICovICAgICAgICAgICAgICAgICAgIExEQS5hYnMgKFwidmljaXJxX2QwMTlcIik7ICAgICAgLy8gcmVhZCB0aGUgdmljIGludGVycnVwdCBmbGFnIHJlZ2lzdGVyXHJcbi8qIGZmNjYgKi8gICAgICAgICAgICAgICAgICAgQU5ELmltbSAoMHgwMSk7ICAgICAgICAgICAgICAgLy8gbWFzayB0aGUgcmFzdGVyIGNvbXBhcmUgZmxhZ1xyXG4vKiBmZjY4ICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwidHZzZmxnXzAyYTZcIik7ICAgICAgLy8gc2F2ZSB0aGUgUEFML05UU0MgZmxhZ1xyXG4vKiBmZjZiICovICAgICAgICAgICAgICAgICAgIEpNUC5hYnMgKFwiX2ZkZGRcIik7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vID8/XHJcbi8qIGZmNmUgKi8gICAgICAgIF9gX2ZmNmVgOyAgTERBLmltbSAoMHg4MSk7ICAgICAgICAgICAgICAgLy8gZW5hYmxlIHRpbWVyIEEgaW50ZXJydXB0XHJcbi8qIGZmNzAgKi8gICAgICAgICAgICAgICAgICAgU1RBLmFicyAoXCJjaWFpY3JfZGMwZFwiKTsgICAgICAvLyBzYXZlIFZJQSAxIElDUlxyXG4vKiBmZjczICovICAgICAgICAgICAgICAgICAgIExEQS5hYnMgKFwiY2lhY3JhX2RjMGVcIik7ICAgICAgLy8gcmVhZCBWSUEgMSBDUkFcclxuLyogZmY3NiAqLyAgICAgICAgICAgICAgICAgICBBTkQuaW1tICgweDgwKTsgICAgICAgICAgICAgICAvLyBtYXNrIHgwMDAgMDAwMCwgVE9EIGNsb2NrXHJcbi8qIGZmNzggKi8gICAgICAgICAgICAgICAgICAgT1JBLmltbSAoMHgxMSk7ICAgICAgICAgICAgICAgLy8gbWFzayB4eHgxIHh4eDEsIGxvYWQgdGltZXIgQSwgc3RhcnQgdGltZXIgQVxyXG4vKiBmZjdhICovICAgICAgICAgICAgICAgICAgIFNUQS5hYnMgKFwiY2lhY3JhX2RjMGVcIik7ICAgICAgLy8gc2F2ZSBWSUEgMSBDUkFcclxuLyogZmY3ZCAqLyAgICAgICAgICAgICAgICAgICBKTVAuYWJzIChcIl9lZThlXCIpOyAgICAgICAgICAgIC8vIHNldCB0aGUgc2VyaWFsIGNsb2NrIG91dCBsb3cgYW5kIHJldHVyblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyB1bnVzZWRcclxuLyogZmY4MCAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4MDMpO1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBpbml0aWFsaXNlIFZJQyBhbmQgc2NyZWVuIGVkaXRvclxyXG4vKiBmZjgxICovICAgIF9gY2ludF9mZjgxYDsgIEpNUC5hYnMgKFwiY2ludF9mZjViXCIpOyAgICAgICAgLy8gaW5pdGlhbGlzZSBWSUMgYW5kIHNjcmVlbiBlZGl0b3JcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gaW5pdGlhbGlzZSBTSUQsIENJQSBhbmQgSVJRLCB1bnVzZWRcclxuLyogZmY4NCAqLyAgX2Bpb2luaXRfZmY4NGA7ICBKTVAuYWJzIChcImlvaW5pdF9mZGEzXCIpOyAgICAgIC8vIGluaXRpYWxpc2UgU0lELCBDSUEgYW5kIElSUVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBSQU0gdGVzdCBhbmQgZmluZCBSQU0gZW5kXHJcbi8qIGZmODcgKi8gIF9gcmFtdGFzX2ZmODdgOyAgSk1QLmFicyAoXCJyYW10YXNfZmQ1MFwiKTsgICAgICAvLyBSQU0gdGVzdCBhbmQgZmluZCBSQU0gZW5kXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHJlc3RvcmUgZGVmYXVsdCBJL08gdmVjdG9yc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgcm91dGluZSByZXN0b3JlcyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgYWxsIHN5c3RlbSB2ZWN0b3JzIHVzZWQgaW4gS0VSTkFMIGFuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJBU0lDIHJvdXRpbmVzIGFuZCBpbnRlcnJ1cHRzLlxyXG4vKiBmZjhhICovICBfYHJlc3Rvcl9mZjhhYDsgIEpNUC5hYnMgKFwicmVzdG9yX2ZkMTVcIik7ICAgICAgLy8gcmVzdG9yZSBkZWZhdWx0IEkvTyB2ZWN0b3JzXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHJlYWQvc2V0IHZlY3RvcmVkIEkvT1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgcm91dGluZSBtYW5hZ2VzIGFsbCBzeXN0ZW0gdmVjdG9yIGp1bXAgYWRkcmVzc2VzIHN0b3JlZCBpbiBSQU0uIENhbGxpbmcgdGhpc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJvdXRpbmUgd2l0aCB0aGUgY2FycnkgYml0IHNldCB3aWxsIHN0b3JlIHRoZSBjdXJyZW50IGNvbnRlbnRzIG9mIHRoZSBSQU0gdmVjdG9yc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIGEgbGlzdCBwb2ludGVkIHRvIGJ5IHRoZSBYIGFuZCBZIHJlZ2lzdGVycy4gV2hlbiB0aGlzIHJvdXRpbmUgaXMgY2FsbGVkIHdpdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgY2FycnkgYml0IGNsZWFyLCB0aGUgdXNlciBsaXN0IHBvaW50ZWQgdG8gYnkgdGhlIFggYW5kIFkgcmVnaXN0ZXJzIGlzIGNvcGllZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBzeXN0ZW0gUkFNIHZlY3RvcnMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogVGhpcyByb3V0aW5lIHJlcXVpcmVzIGNhdXRpb24gaW4gaXRzIHVzZS4gVGhlIGJlc3Qgd2F5IHRvIHVzZSBpdCBpcyB0byBmaXJzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlYWQgdGhlIGVudGlyZSB2ZWN0b3IgY29udGVudHMgaW50byB0aGUgdXNlciBhcmVhLCBhbHRlciB0aGUgZGVzaXJlZCB2ZWN0b3JzIGFuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gY29weSB0aGUgY29udGVudHMgYmFjayB0byB0aGUgc3lzdGVtIHZlY3RvcnMuXHJcbi8qIGZmOGQgKi8gIF9gdmVjdG9yX2ZmOGRgOyAgSk1QLmFicyAoXCJ2ZWN0b3JfZmQxYVwiKTsgICAgICAvLyByZWFkL3NldCB2ZWN0b3JlZCBJL09cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY29udHJvbCBrZXJuYWwgbWVzc2FnZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHJvdXRpbmUgY29udHJvbHMgdGhlIHByaW50aW5nIG9mIGVycm9yIGFuZCBjb250cm9sIG1lc3NhZ2VzIGJ5IHRoZSBLRVJOQUwuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWl0aGVyIHByaW50IGVycm9yIG1lc3NhZ2VzIG9yIHByaW50IGNvbnRyb2wgbWVzc2FnZXMgY2FuIGJlIHNlbGVjdGVkIGJ5IHNldHRpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgYWNjdW11bGF0b3Igd2hlbiB0aGUgcm91dGluZSBpcyBjYWxsZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklMRSBOT1QgRk9VTkQgaXMgYW4gZXhhbXBsZSBvZiBhbiBlcnJvciBtZXNzYWdlLiBQUkVTUyBQTEFZIE9OIENBU1NFVFRFIGlzIGFuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhhbXBsZSBvZiBhIGNvbnRyb2wgbWVzc2FnZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBiaXRzIDYgYW5kIDcgb2YgdGhpcyB2YWx1ZSBkZXRlcm1pbmUgd2hlcmUgdGhlIG1lc3NhZ2Ugd2lsbCBjb21lIGZyb20uIElmIGJpdCA3XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgc2V0IG9uZSBvZiB0aGUgZXJyb3IgbWVzc2FnZXMgZnJvbSB0aGUgS0VSTkFMIHdpbGwgYmUgcHJpbnRlZC4gSWYgYml0IDYgaXMgc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBjb250cm9sIG1lc3NhZ2Ugd2lsbCBiZSBwcmludGVkLlxyXG4vKiBmZjkwICovICBfYHNldG1zZ19mZjkwYDsgIEpNUC5hYnMgKFwic2V0bXNnX2ZlMThcIik7ICAgICAgLy8gY29udHJvbCBrZXJuYWwgbWVzc2FnZXNcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gc2VuZCBzZWNvbmRhcnkgYWRkcmVzcyBhZnRlciBMSVNURU5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHJvdXRpbmUgaXMgdXNlZCB0byBzZW5kIGEgc2Vjb25kYXJ5IGFkZHJlc3MgdG8gYW4gSS9PIGRldmljZSBhZnRlciBhIGNhbGwgdG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgTElTVEVOIHJvdXRpbmUgaXMgbWFkZSBhbmQgdGhlIGRldmljZSBjb21tYW5kZWQgdG8gTElTVEVOLiBUaGUgcm91dGluZSBjYW5ub3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBiZSB1c2VkIHRvIHNlbmQgYSBzZWNvbmRhcnkgYWRkcmVzcyBhZnRlciBhIGNhbGwgdG8gdGhlIFRBTEsgcm91dGluZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHNlY29uZGFyeSBhZGRyZXNzIGlzIHVzdWFsbHkgdXNlZCB0byBnaXZlIHNldC11cCBpbmZvcm1hdGlvbiB0byBhIGRldmljZSBiZWZvcmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJL08gb3BlcmF0aW9ucyBiZWdpbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGEgc2Vjb25kYXJ5IGFkZHJlc3MgaXMgdG8gYmUgc2VudCB0byBhIGRldmljZSBvbiB0aGUgc2VyaWFsIGJ1cyB0aGUgYWRkcmVzc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG11c3QgZmlyc3QgYmUgT1JlZCB3aXRoICQ2MC5cclxuLyogZmY5MyAqLyAgX2BzZWNvbmRfZmY5M2A7ICBKTVAuYWJzIChcInNlY29uZF9lZGI5XCIpOyAgICAgIC8vIHNlbmQgc2Vjb25kYXJ5IGFkZHJlc3MgYWZ0ZXIgTElTVEVOXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHNlbmQgc2Vjb25kYXJ5IGFkZHJlc3MgYWZ0ZXIgVEFMS1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgcm91dGluZSB0cmFuc21pdHMgYSBzZWNvbmRhcnkgYWRkcmVzcyBvbiB0aGUgc2VyaWFsIGJ1cyBmb3IgYSBUQUxLIGRldmljZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHJvdXRpbmUgbXVzdCBiZSBjYWxsZWQgd2l0aCBhIG51bWJlciBiZXR3ZWVuIDQgYW5kIDMxIGluIHRoZSBhY2N1bXVsYXRvci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcm91dGluZSB3aWxsIHNlbmQgdGhpcyBudW1iZXIgYXMgYSBzZWNvbmRhcnkgYWRkcmVzcyBjb21tYW5kIG92ZXIgdGhlIHNlcmlhbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1cy4gVGhpcyByb3V0aW5lIGNhbiBvbmx5IGJlIGNhbGxlZCBhZnRlciBhIGNhbGwgdG8gdGhlIFRBTEsgcm91dGluZS4gSXQgd2lsbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCB3b3JrIGFmdGVyIGEgTElTVEVOLlxyXG4vKiBmZjk2ICovICAgIF9gdGtzYV9mZjk2YDsgIEpNUC5hYnMgKFwidGtzYV9lZGM3XCIpOyAgICAgICAgLy8gc2VuZCBzZWNvbmRhcnkgYWRkcmVzcyBhZnRlciBUQUxLXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHJlYWQvc2V0IHRoZSB0b3Agb2YgbWVtb3J5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyByb3V0aW5lIGlzIHVzZWQgdG8gcmVhZCBhbmQgc2V0IHRoZSB0b3Agb2YgUkFNLiBXaGVuIHRoaXMgcm91dGluZSBpcyBjYWxsZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIHRoZSBjYXJyeSBiaXQgc2V0IHRoZSBwb2ludGVyIHRvIHRoZSB0b3Agb2YgUkFNIHdpbGwgYmUgbG9hZGVkIGludG8gWFkuIFdoZW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHJvdXRpbmUgaXMgY2FsbGVkIHdpdGggdGhlIGNhcnJ5IGJpdCBjbGVhciBYWSB3aWxsIGJlIHNhdmVkIGFzIHRoZSB0b3Agb2ZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtZW1vcnkgcG9pbnRlciBjaGFuZ2luZyB0aGUgdG9wIG9mIG1lbW9yeS5cclxuLyogZmY5OSAqLyAgX2BtZW10b3BfZmY5OWA7ICBKTVAuYWJzIChcIm1lbXRvcF9mZTI1XCIpOyAgICAgIC8vIHJlYWQvc2V0IHRoZSB0b3Agb2YgbWVtb3J5XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHJlYWQvc2V0IHRoZSBib3R0b20gb2YgbWVtb3J5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyByb3V0aW5lIGlzIHVzZWQgdG8gcmVhZCBhbmQgc2V0IHRoZSBib3R0b20gb2YgUkFNLiBXaGVuIHRoaXMgcm91dGluZSBpc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGxlZCB3aXRoIHRoZSBjYXJyeSBiaXQgc2V0IHRoZSBwb2ludGVyIHRvIHRoZSBib3R0b20gb2YgUkFNIHdpbGwgYmUgbG9hZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW50byBYWS4gV2hlbiB0aGlzIHJvdXRpbmUgaXMgY2FsbGVkIHdpdGggdGhlIGNhcnJ5IGJpdCBjbGVhciBYWSB3aWxsIGJlIHNhdmVkIGFzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGJvdHRvbSBvZiBtZW1vcnkgcG9pbnRlciBjaGFuZ2luZyB0aGUgYm90dG9tIG9mIG1lbW9yeS5cclxuLyogZmY5YyAqLyAgX2BtZW1ib3RfZmY5Y2A7ICBKTVAuYWJzIChcIm1lbWJvdF9mZTM0XCIpOyAgICAgIC8vIHJlYWQvc2V0IHRoZSBib3R0b20gb2YgbWVtb3J5XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHNjYW4gdGhlIGtleWJvYXJkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyByb3V0aW5lIHdpbGwgc2NhbiB0aGUga2V5Ym9hcmQgYW5kIGNoZWNrIGZvciBwcmVzc2VkIGtleXMuIEl0IGlzIHRoZSBzYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcm91dGluZSBjYWxsZWQgYnkgdGhlIGludGVycnVwdCBoYW5kbGVyLiBJZiBhIGtleSBpcyBkb3duLCBpdHMgQVNDSUkgdmFsdWUgaXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwbGFjZWQgaW4gdGhlIGtleWJvYXJkIHF1ZXVlLlxyXG4vKiBmZjlmICovICBfYHNjbmtleV9mZjlmYDsgIEpNUC5hYnMgKFwic2Nua2V5X2VhODdcIik7ICAgICAgLy8gc2NhbiBrZXlib2FyZFxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzZXQgdGltZW91dCBvbiBzZXJpYWwgYnVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyByb3V0aW5lIHNldHMgdGhlIHRpbWVvdXQgZmxhZyBmb3IgdGhlIHNlcmlhbCBidXMuIFdoZW4gdGhlIHRpbWVvdXQgZmxhZyBpc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCwgdGhlIGNvbXB1dGVyIHdpbGwgd2FpdCBmb3IgYSBkZXZpY2Ugb24gdGhlIHNlcmlhbCBwb3J0IGZvciA2NCBtaWxsaXNlY29uZHMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGRldmljZSBkb2VzIG5vdCByZXNwb25kIHRvIHRoZSBjb21wdXRlcidzIERBViBzaWduYWwgd2l0aGluIHRoYXQgdGltZSB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21wdXRlciB3aWxsIHJlY29nbml6ZSBhbiBlcnJvciBjb25kaXRpb24gYW5kIGxlYXZlIHRoZSBoYW5kc2hha2Ugc2VxdWVuY2UuIFdoZW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHJvdXRpbmUgaXMgY2FsbGVkIGFuZCB0aGUgYWNjdW11bGF0b3IgY29udGFpbnMgYSAwIGluIGJpdCA3LCB0aW1lb3V0cyBhcmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbmFibGVkLiBBIDEgaW4gYml0IDcgd2lsbCBkaXNhYmxlIHRoZSB0aW1lb3V0cy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBUaGUgdGhlIHRpbWVvdXQgZmVhdHVyZSBpcyB1c2VkIHRvIGNvbW11bmljYXRlIHRoYXQgYSBkaXNrIGZpbGUgaXMgbm90IGZvdW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb24gYW4gYXR0ZW1wdCB0byBPUEVOIGEgZmlsZS5cclxuLyogZmZhMiAqLyAgX2BzZXR0bW9fZmZhMmA7ICBKTVAuYWJzIChcInNldHRtb19mZTIxXCIpOyAgICAgIC8vIHNldCB0aW1lb3V0IG9uIHNlcmlhbCBidXNcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gaW5wdXQgYnl0ZSBmcm9tIHNlcmlhbCBidXNcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyByb3V0aW5lIHJlYWRzIGEgYnl0ZSBvZiBkYXRhIGZyb20gdGhlIHNlcmlhbCBidXMgdXNpbmcgZnVsbCBoYW5kc2hha2luZy4gdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGF0YSBpcyByZXR1cm5lZCBpbiB0aGUgYWNjdW11bGF0b3IuIGJlZm9yZSB1c2luZyB0aGlzIHJvdXRpbmUgdGhlIFRBTEsgcm91dGluZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAkRkZCNCwgbXVzdCBoYXZlIGJlZW4gY2FsbGVkIGZpcnN0IHRvIGNvbW1hbmQgdGhlIGRldmljZSBvbiB0aGUgc2VyaWFsIGJ1cyB0b1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlbmQgZGF0YSBvbiB0aGUgYnVzLiBpZiB0aGUgaW5wdXQgZGV2aWNlIG5lZWRzIGEgc2Vjb25kYXJ5IGNvbW1hbmQgaXQgbXVzdCBiZSBzZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnkgdXNpbmcgdGhlIFRLU0Egcm91dGluZSwgJEZGOTYsIGJlZm9yZSBjYWxsaW5nIHRoaXMgcm91dGluZS5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXJyb3JzIGFyZSByZXR1cm5lZCBpbiB0aGUgc3RhdHVzIHdvcmQgd2hpY2ggY2FuIGJlIHJlYWQgYnkgY2FsbGluZyB0aGUgUkVBRFNUXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcm91dGluZSwgJEZGQjcuXHJcbi8qIGZmYTUgKi8gICBfYGFjcHRyX2ZmYTVgOyAgSk1QLmFicyAoXCJhY3B0cl9lZTEzXCIpOyAgICAgICAvLyBpbnB1dCBieXRlIGZyb20gc2VyaWFsIGJ1c1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBvdXRwdXQgYSBieXRlIHRvIHNlcmlhbCBidXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHJvdXRpbmUgaXMgdXNlZCB0byBzZW5kIGluZm9ybWF0aW9uIHRvIGRldmljZXMgb24gdGhlIHNlcmlhbCBidXMuIEEgY2FsbCB0b1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgcm91dGluZSB3aWxsIHB1dCBhIGRhdGEgYnl0ZSBvbnRvIHRoZSBzZXJpYWwgYnVzIHVzaW5nIGZ1bGwgaGFuZHNoYWtpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmVmb3JlIHRoaXMgcm91dGluZSBpcyBjYWxsZWQgdGhlIExJU1RFTiByb3V0aW5lLCAkRkZCMSwgbXVzdCBiZSB1c2VkIHRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tbWFuZCBhIGRldmljZSBvbiB0aGUgc2VyaWFsIGJ1cyB0byBnZXQgcmVhZHkgdG8gcmVjZWl2ZSBkYXRhLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBhY2N1bXVsYXRvciBpcyBsb2FkZWQgd2l0aCBhIGJ5dGUgdG8gb3V0cHV0IGFzIGRhdGEgb24gdGhlIHNlcmlhbCBidXMuIEFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZXZpY2UgbXVzdCBiZSBsaXN0ZW5pbmcgb3IgdGhlIHN0YXR1cyB3b3JkIHdpbGwgcmV0dXJuIGEgdGltZW91dC4gVGhpcyByb3V0aW5lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWx3YXlzIGJ1ZmZlcnMgb25lIGNoYXJhY3Rlci4gU28gd2hlbiBhIGNhbGwgdG8gdGhlIFVOTElTVEVOIHJvdXRpbmUsICRGRkFFLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIG1hZGUgdG8gZW5kIHRoZSBkYXRhIHRyYW5zbWlzc2lvbiwgdGhlIGJ1ZmZlcmVkIGNoYXJhY3RlciBpcyBzZW50IHdpdGggRU9JXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0LiBUaGVuIHRoZSBVTkxJU1RFTiBjb21tYW5kIGlzIHNlbnQgdG8gdGhlIGRldmljZS5cclxuLyogZmZhOCAqLyAgIF9gY2lvdXRfZmZhOGA7ICBKTVAuYWJzIChcImNpb3V0X2VkZGRcIik7ICAgICAgIC8vIG91dHB1dCBieXRlIHRvIHNlcmlhbCBidXNcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY29tbWFuZCBzZXJpYWwgYnVzIHRvIFVOVEFMS1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgcm91dGluZSB3aWxsIHRyYW5zbWl0IGFuIFVOVEFMSyBjb21tYW5kIG9uIHRoZSBzZXJpYWwgYnVzLiBBbGwgZGV2aWNlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzbHkgc2V0IHRvIFRBTEsgd2lsbCBzdG9wIHNlbmRpbmcgZGF0YSB3aGVuIHRoaXMgY29tbWFuZCBpcyByZWNlaXZlZC5cclxuLyogZmZhYiAqLyAgIF9gdW50bGtfZmZhYmA7ICBKTVAuYWJzIChcInVudGxrX2VkZWZcIik7ICAgICAgIC8vIGNvbW1hbmQgc2VyaWFsIGJ1cyB0byBVTlRBTEtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY29tbWFuZCBzZXJpYWwgYnVzIHRvIFVOTElTVEVOXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyByb3V0aW5lIGNvbW1hbmRzIGFsbCBkZXZpY2VzIG9uIHRoZSBzZXJpYWwgYnVzIHRvIHN0b3AgcmVjZWl2aW5nIGRhdGEgZnJvbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBjb21wdXRlci4gQ2FsbGluZyB0aGlzIHJvdXRpbmUgcmVzdWx0cyBpbiBhbiBVTkxJU1RFTiBjb21tYW5kIGJlaW5nIHRyYW5zbWl0dGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb24gdGhlIHNlcmlhbCBidXMuIE9ubHkgZGV2aWNlcyBwcmV2aW91c2x5IGNvbW1hbmRlZCB0byBsaXN0ZW4gd2lsbCBiZSBhZmZlY3RlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHJvdXRpbmUgaXMgbm9ybWFsbHkgdXNlZCBhZnRlciB0aGUgY29tcHV0ZXIgaXMgZmluaXNoZWQgc2VuZGluZyBkYXRhIHRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXh0ZXJuYWwgZGV2aWNlcy4gU2VuZGluZyB0aGUgVU5MSVNURU4gd2lsbCBjb21tYW5kIHRoZSBsaXN0ZW5pbmcgZGV2aWNlcyB0byBnZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvZmYgdGhlIHNlcmlhbCBidXMgc28gaXQgY2FuIGJlIHVzZWQgZm9yIG90aGVyIHB1cnBvc2VzLlxyXG4vKiBmZmFlICovICAgX2B1bmxzbl9mZmFlYDsgIEpNUC5hYnMgKFwidW5sc25fZWRmZVwiKTsgICAgICAgLy8gY29tbWFuZCBzZXJpYWwgYnVzIHRvIFVOTElTVEVOXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGNvbW1hbmQgZGV2aWNlcyBvbiB0aGUgc2VyaWFsIGJ1cyB0byBMSVNURU5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHJvdXRpbmUgd2lsbCBjb21tYW5kIGEgZGV2aWNlIG9uIHRoZSBzZXJpYWwgYnVzIHRvIHJlY2VpdmUgZGF0YS4gVGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWNjdW11bGF0b3IgbXVzdCBiZSBsb2FkZWQgd2l0aCBhIGRldmljZSBudW1iZXIgYmV0d2VlbiA0IGFuZCAzMSBiZWZvcmUgY2FsbGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgcm91dGluZS4gTElTVEVOIGNvbnZlcnQgdGhpcyB0byBhIGxpc3RlbiBhZGRyZXNzIHRoZW4gdHJhbnNtaXQgdGhpcyBkYXRhIGFzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBjb21tYW5kIG9uIHRoZSBzZXJpYWwgYnVzLiBUaGUgc3BlY2lmaWVkIGRldmljZSB3aWxsIHRoZW4gZ28gaW50byBsaXN0ZW4gbW9kZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBiZSByZWFkeSB0byBhY2NlcHQgaW5mb3JtYXRpb24uXHJcbi8qIGZmYjEgKi8gIF9gbGlzdGVuX2ZmYjFgOyAgSk1QLmFicyAoXCJsaXN0ZW5fZWQwY1wiKTsgICAgICAvLyBjb21tYW5kIGRldmljZXMgb24gdGhlIHNlcmlhbCBidXMgdG8gTElTVEVOXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGNvbW1hbmQgc2VyaWFsIGJ1cyBkZXZpY2UgdG8gVEFMS1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIHVzZSB0aGlzIHJvdXRpbmUgdGhlIGFjY3VtdWxhdG9yIG11c3QgZmlyc3QgYmUgbG9hZGVkIHdpdGggYSBkZXZpY2UgbnVtYmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmV0d2VlbiA0IGFuZCAzMC4gV2hlbiBjYWxsZWQgdGhpcyByb3V0aW5lIGNvbnZlcnRzIHRoaXMgZGV2aWNlIG51bWJlciB0byBhIHRhbGtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGRyZXNzLiBUaGVuIHRoaXMgZGF0YSBpcyB0cmFuc21pdHRlZCBhcyBhIGNvbW1hbmQgb24gdGhlIFNlcmlhbCBidXMuXHJcbi8qIGZmYjQgKi8gICAgX2B0YWxrX2ZmYjRgOyAgSk1QLmFicyAoXCJ0YWxrX2VkMDlcIik7ICAgICAgICAvLyBjb21tYW5kIHNlcmlhbCBidXMgZGV2aWNlIHRvIFRBTEtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcmVhZCBJL08gc3RhdHVzIHdvcmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHJvdXRpbmUgcmV0dXJucyB0aGUgY3VycmVudCBzdGF0dXMgb2YgdGhlIEkvTyBkZXZpY2UgaW4gdGhlIGFjY3VtdWxhdG9yLiBUaGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByb3V0aW5lIGlzIHVzdWFsbHkgY2FsbGVkIGFmdGVyIG5ldyBjb21tdW5pY2F0aW9uIHRvIGFuIEkvTyBkZXZpY2UuIFRoZSByb3V0aW5lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCBnaXZlIGluZm9ybWF0aW9uIGFib3V0IGRldmljZSBzdGF0dXMsIG9yIGVycm9ycyB0aGF0IGhhdmUgb2NjdXJyZWQgZHVyaW5nIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEkvTyBvcGVyYXRpb24uXHJcbi8qIGZmYjcgKi8gIF9gcmVhZHN0X2ZmYjdgOyAgSk1QLmFicyAoXCJyZWFkc3RfZmUwN1wiKTsgICAgICAvLyByZWFkIEkvTyBzdGF0dXMgd29yZFxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzZXQgbG9naWNhbCwgZmlyc3QgYW5kIHNlY29uZCBhZGRyZXNzZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHJvdXRpbmUgd2lsbCBzZXQgdGhlIGxvZ2ljYWwgZmlsZSBudW1iZXIsIGRldmljZSBhZGRyZXNzLCBhbmQgc2Vjb25kYXJ5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkcmVzcywgY29tbWFuZCBudW1iZXIsIGZvciBvdGhlciBLRVJOQUwgcm91dGluZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGxvZ2ljYWwgZmlsZSBudW1iZXIgaXMgdXNlZCBieSB0aGUgc3lzdGVtIGFzIGEga2V5IHRvIHRoZSBmaWxlIHRhYmxlIGNyZWF0ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBieSB0aGUgT1BFTiBmaWxlIHJvdXRpbmUuIERldmljZSBhZGRyZXNzZXMgY2FuIHJhbmdlIGZyb20gMCB0byAzMC4gVGhlIGZvbGxvd2luZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvZGVzIGFyZSB1c2VkIGJ5IHRoZSBjb21wdXRlciB0byBzdGFuZCBmb3IgdGhlIGZvbGxvd2luZyBDQk0gZGV2aWNlczpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBRERSRVNTIERFVklDRVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vID09PT09PT0gPT09PT09XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIDAgICAgICBLZXlib2FyZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAxICAgICAgQ2Fzc2V0dGUgIzFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgMiAgICAgIFJTLTIzMkMgZGV2aWNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIDMgICAgICBDUlQgZGlzcGxheVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICA0ICAgICAgU2VyaWFsIGJ1cyBwcmludGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIDggICAgICBDQk0gU2VyaWFsIGJ1cyBkaXNrIGRyaXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGV2aWNlIG51bWJlcnMgb2YgZm91ciBvciBncmVhdGVyIGF1dG9tYXRpY2FsbHkgcmVmZXIgdG8gZGV2aWNlcyBvbiB0aGUgc2VyaWFsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnVzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgY29tbWFuZCB0byB0aGUgZGV2aWNlIGlzIHNlbnQgYXMgYSBzZWNvbmRhcnkgYWRkcmVzcyBvbiB0aGUgc2VyaWFsIGJ1cyBhZnRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBkZXZpY2UgbnVtYmVyIGlzIHNlbnQgZHVyaW5nIHRoZSBzZXJpYWwgYXR0ZW50aW9uIGhhbmRzaGFraW5nIHNlcXVlbmNlLiBJZlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIHNlY29uZGFyeSBhZGRyZXNzIGlzIHRvIGJlIHNlbnQgWSBzaG91bGQgYmUgc2V0IHRvICRGRi5cclxuLyogZmZiYSAqLyAgX2BzZXRsZnNfZmZiYWA7ICBKTVAuYWJzIChcInNldGxmc19mZTAwXCIpOyAgICAgIC8vIHNldCBsb2dpY2FsLCBmaXJzdCBhbmQgc2Vjb25kIGFkZHJlc3Nlc1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBzZXQgdGhlIGZpbGVuYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyByb3V0aW5lIGlzIHVzZWQgdG8gc2V0IHVwIHRoZSBmaWxlIG5hbWUgZm9yIHRoZSBPUEVOLCBTQVZFLCBvciBMT0FEIHJvdXRpbmVzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBhY2N1bXVsYXRvciBtdXN0IGJlIGxvYWRlZCB3aXRoIHRoZSBsZW5ndGggb2YgdGhlIGZpbGUgYW5kIFhZIHdpdGggdGhlIHBvaW50ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBmaWxlIG5hbWUsIFggYmVpbmcgdGggbG93IGJ5dGUuIFRoZSBhZGRyZXNzIGNhbiBiZSBhbnkgdmFsaWQgbWVtb3J5IGFkZHJlc3MgaW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc3lzdGVtIHdoZXJlIGEgc3RyaW5nIG9mIGNoYXJhY3RlcnMgZm9yIHRoZSBmaWxlIG5hbWUgaXMgc3RvcmVkLiBJZiBubyBmaWxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmFtZSBkZXNpcmVkIHRoZSBhY2N1bXVsYXRvciBtdXN0IGJlIHNldCB0byAwLCByZXByZXNlbnRpbmcgYSB6ZXJvIGZpbGUgbGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIHRoYXQgY2FzZSAgWFkgbWF5IGJlIHNldCB0byBhbnkgbWVtb3J5IGFkZHJlc3MuXHJcbi8qIGZmYmQgKi8gIF9gc2V0bmFtX2ZmYmRgOyAgSk1QLmFicyAoXCJzZXRuYW1fZmRmOVwiKTsgICAgICAvLyBzZXQgdGhlIGZpbGVuYW1lXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIG9wZW4gYSBsb2dpY2FsIGZpbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHJvdXRpbmUgaXMgdXNlZCB0byBvcGVuIGEgbG9naWNhbCBmaWxlLiBPbmNlIHRoZSBsb2dpY2FsIGZpbGUgaXMgc2V0IHVwIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FuIGJlIHVzZWQgZm9yIGlucHV0L291dHB1dCBvcGVyYXRpb25zLiBNb3N0IG9mIHRoZSBJL08gS0VSTkFMIHJvdXRpbmVzIGNhbGwgb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHJvdXRpbmUgdG8gY3JlYXRlIHRoZSBsb2dpY2FsIGZpbGVzIHRvIG9wZXJhdGUgb24uIE5vIGFyZ3VtZW50cyBuZWVkIHRvIGJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHVwIHRvIHVzZSB0aGlzIHJvdXRpbmUsIGJ1dCBib3RoIHRoZSBTRVRMRlMsICRGRkJBLCBhbmQgU0VUTkFNLCAkRkZCRCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBLRVJOQUwgcm91dGluZXMgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIHVzaW5nIHRoaXMgcm91dGluZS5cclxuLyogZmZjMCAqLyAgICBfYG9wZW5fZmZjMGA7ICBKTVAuaW5kIChcImlvcGVuKzBfMDMxYVwiKTsgICAgIC8vIGRvIG9wZW4gYSBsb2dpY2FsIGZpbGVcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY2xvc2UgYSBzcGVjaWZpZWQgbG9naWNhbCBmaWxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyByb3V0aW5lIGlzIHVzZWQgdG8gY2xvc2UgYSBsb2dpY2FsIGZpbGUgYWZ0ZXIgYWxsIEkvTyBvcGVyYXRpb25zIGhhdmUgYmVlblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbXBsZXRlZCBvbiB0aGF0IGZpbGUuIFRoaXMgcm91dGluZSBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGFjY3VtdWxhdG9yIGlzIGxvYWRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpdGggdGhlIGxvZ2ljYWwgZmlsZSBudW1iZXIgdG8gYmUgY2xvc2VkLCB0aGUgc2FtZSBudW1iZXIgdXNlZCB3aGVuIHRoZSBmaWxlIHdhc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9wZW5lZCB1c2luZyB0aGUgT1BFTiByb3V0aW5lLlxyXG4vKiBmZmMzICovICAgX2BjbG9zZV9mZmMzYDsgIEpNUC5pbmQgKFwiaWNsb3NlKzBfMDMxY1wiKTsgICAgLy8gZG8gY2xvc2UgYSBzcGVjaWZpZWQgbG9naWNhbCBmaWxlXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIG9wZW4gY2hhbm5lbCBmb3IgaW5wdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbnkgbG9naWNhbCBmaWxlIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBvcGVuZWQgYnkgdGhlIE9QRU4gcm91dGluZSwgJEZGQzAsIGNhbiBiZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZmluZWQgYXMgYW4gaW5wdXQgY2hhbm5lbCBieSB0aGlzIHJvdXRpbmUuIHRoZSBkZXZpY2Ugb24gdGhlIGNoYW5uZWwgbXVzdCBiZSBhblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlucHV0IGRldmljZSBvciBhbiBlcnJvciB3aWxsIG9jY3VyIGFuZCB0aGUgcm91dGluZSB3aWxsIGFib3J0LlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB5b3UgYXJlIGdldHRpbmcgZGF0YSBmcm9tIGFueXdoZXJlIG90aGVyIHRoYW4gdGhlIGtleWJvYXJkLCB0aGlzIHJvdXRpbmUgbXVzdCBiZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGxlZCBiZWZvcmUgdXNpbmcgZWl0aGVyIHRoZSBDSFJJTiByb3V0aW5lLCAkRkZDRiwgb3IgdGhlIEdFVElOIHJvdXRpbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJEZGRTQuIGlmIHlvdSBhcmUgZ2V0dGluZyBkYXRhIGZyb20gdGhlIGtleWJvYXJkIGFuZCBubyBvdGhlciBpbnB1dCBjaGFubmVscyBhcmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvcGVuIHRoZW4gdGhlIGNhbGxzIHRvIHRoaXMgcm91dGluZSBhbmQgdG8gdGhlIE9QRU4gcm91dGluZSwgJEZGQzAsIGFyZSBub3QgbmVlZGVkLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHVzZWQgd2l0aCBhIGRldmljZSBvbiB0aGUgc2VyaWFsIGJ1cyB0aGlzIHJvdXRpbmUgd2lsbCBhdXRvbWF0aWNhbGx5IHNlbmQgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGlzdGVuIGFkZHJlc3Mgc3BlY2lmaWVkIGJ5IHRoZSBPUEVOIHJvdXRpbmUsICRGRkMwLCBhbmQgYW55IHNlY29uZGFyeSBhZGRyZXNzLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwb3NzaWJsZSBlcnJvcnMgYXJlOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAzIDogZmlsZSBub3Qgb3BlblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDUgOiBkZXZpY2Ugbm90IHByZXNlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA2IDogZmlsZSBpcyBub3QgYW4gaW5wdXQgZmlsZVxyXG4vKiBmZmM2ICovICAgX2BjaGtpbl9mZmM2YDsgIEpNUC5pbmQgKFwiaWNoa2luKzBfMDMxZVwiKTsgICAgLy8gZG8gb3BlbiBjaGFubmVsIGZvciBpbnB1dFxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBvcGVuIGNoYW5uZWwgZm9yIG91dHB1dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFueSBsb2dpY2FsIGZpbGUgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIG9wZW5lZCBieSB0aGUgT1BFTiByb3V0aW5lLCAkRkZDMCwgY2FuIGJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVmaW5lZCBhcyBhbiBvdXRwdXQgY2hhbm5lbCBieSB0aGlzIHJvdXRpbmUgdGhlIGRldmljZSBvbiB0aGUgY2hhbm5lbCBtdXN0IGJlIGFuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3V0cHV0IGRldmljZSBvciBhbiBlcnJvciB3aWxsIG9jY3VyIGFuZCB0aGUgcm91dGluZSB3aWxsIGFib3J0LlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB5b3UgYXJlIHNlbmRpbmcgZGF0YSB0byBhbnl3aGVyZSBvdGhlciB0aGFuIHRoZSBzY3JlZW4gdGhpcyByb3V0aW5lIG11c3QgYmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWxsZWQgYmVmb3JlIHVzaW5nIHRoZSBDSFJPVVQgcm91dGluZSwgJEZGRDIuIGlmIHlvdSBhcmUgc2VuZGluZyBkYXRhIHRvIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNjcmVlbiBhbmQgbm8gb3RoZXIgb3V0cHV0IGNoYW5uZWxzIGFyZSBvcGVuIHRoZW4gdGhlIGNhbGxzIHRvIHRoaXMgcm91dGluZSBhbmQgdG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgT1BFTiByb3V0aW5lLCAkRkZDMCwgYXJlIG5vdCBuZWVkZWQuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdXNlZCB3aXRoIGEgZGV2aWNlIG9uIHRoZSBzZXJpYWwgYnVzIHRoaXMgcm91dGluZSB3aWxsIGF1dG9tYXRpY2FsbHkgc2VuZCB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsaXN0ZW4gYWRkcmVzcyBzcGVjaWZpZWQgYnkgdGhlIE9QRU4gcm91dGluZSwgJEZGQzAsIGFuZCBhbnkgc2Vjb25kYXJ5IGFkZHJlc3MuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBvc3NpYmxlIGVycm9ycyBhcmU6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDMgOiBmaWxlIG5vdCBvcGVuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gNSA6IGRldmljZSBub3QgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDcgOiBmaWxlIGlzIG5vdCBhbiBvdXRwdXQgZmlsZVxyXG4vKiBmZmM5ICovICBfYGNoa291dF9mZmM5YDsgIEpNUC5pbmQgKFwiaWNrb3V0KzBfMDMyMFwiKTsgICAgLy8gZG8gb3BlbiBjaGFubmVsIGZvciBvdXRwdXRcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gY2xvc2UgaW5wdXQgYW5kIG91dHB1dCBjaGFubmVsc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgcm91dGluZSBpcyBjYWxsZWQgdG8gY2xlYXIgYWxsIG9wZW4gY2hhbm5lbHMgYW5kIHJlc3RvcmUgdGhlIEkvTyBjaGFubmVscyB0b1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZWlyIG9yaWdpbmFsIGRlZmF1bHQgdmFsdWVzLiBJdCBpcyB1c3VhbGx5IGNhbGxlZCBhZnRlciBvcGVuaW5nIG90aGVyIEkvT1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoYW5uZWxzIGFuZCB1c2luZyB0aGVtIGZvciBpbnB1dC9vdXRwdXQgb3BlcmF0aW9ucy4gVGhlIGRlZmF1bHQgaW5wdXQgZGV2aWNlIGlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCwgdGhlIGtleWJvYXJkLiBUaGUgZGVmYXVsdCBvdXRwdXQgZGV2aWNlIGlzIDMsIHRoZSBzY3JlZW4uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgb25lIG9mIHRoZSBjaGFubmVscyB0byBiZSBjbG9zZWQgaXMgdG8gdGhlIHNlcmlhbCBwb3J0LCBhbiBVTlRBTEsgc2lnbmFsIGlzIHNlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaXJzdCB0byBjbGVhciB0aGUgaW5wdXQgY2hhbm5lbCBvciBhbiBVTkxJU1RFTiBpcyBzZW50IHRvIGNsZWFyIHRoZSBvdXRwdXQgY2hhbm5lbC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCeSBub3QgY2FsbGluZyB0aGlzIHJvdXRpbmUgYW5kIGxlYXZpbmcgbGlzdGVuZXIocykgYWN0aXZlIG9uIHRoZSBzZXJpYWwgYnVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldmVyYWwgZGV2aWNlcyBjYW4gcmVjZWl2ZSB0aGUgc2FtZSBkYXRhIGZyb20gdGhlIFZJQyBhdCB0aGUgc2FtZSB0aW1lLiBPbmUgd2F5IHRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGFrZSBhZHZhbnRhZ2Ugb2YgdGhpcyB3b3VsZCBiZSB0byBjb21tYW5kIHRoZSBwcmludGVyIHRvIFRBTEsgYW5kIHRoZSBkaXNrIHRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTElTVEVOLiBUaGlzIHdvdWxkIGFsbG93IGRpcmVjdCBwcmludGluZyBvZiBhIGRpc2sgZmlsZS5cclxuLyogZmZjYyAqLyAgX2BjbHJjaG5fZmZjY2A7ICBKTVAuaW5kIChcImljbHJjaCswXzAzMjJcIik7ICAgIC8vIGRvIGNsb3NlIGlucHV0IGFuZCBvdXRwdXQgY2hhbm5lbHNcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gaW5wdXQgY2hhcmFjdGVyIGZyb20gY2hhbm5lbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgcm91dGluZSB3aWxsIGdldCBhIGJ5dGUgb2YgZGF0YSBmcm9tIHRoZSBjaGFubmVsIGFscmVhZHkgc2V0IHVwIGFzIHRoZSBpbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoYW5uZWwgYnkgdGhlIENIS0lOIHJvdXRpbmUsICRGRkM2LlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBDSEtJTiwgJEZGQzYsIGhhcyBub3QgYmVlbiB1c2VkIHRvIGRlZmluZSBhbm90aGVyIGlucHV0IGNoYW5uZWwgdGhlIGRhdGEgaXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBleHBlY3RlZCB0byBiZSBmcm9tIHRoZSBrZXlib2FyZC4gdGhlIGRhdGEgYnl0ZSBpcyByZXR1cm5lZCBpbiB0aGUgYWNjdW11bGF0b3IuIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoYW5uZWwgcmVtYWlucyBvcGVuIGFmdGVyIHRoZSBjYWxsLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnB1dCBmcm9tIHRoZSBrZXlib2FyZCBpcyBoYW5kbGVkIGluIGEgc3BlY2lhbCB3YXkuIGZpcnN0LCB0aGUgY3Vyc29yIGlzIHR1cm5lZCBvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBpdCB3aWxsIGJsaW5rIHVudGlsIGEgY2FycmlhZ2UgcmV0dXJuIGlzIHR5cGVkIG9uIHRoZSBrZXlib2FyZC4gYWxsIGNoYXJhY3RlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvbiB0aGUgbG9naWNhbCBsaW5lLCB1cCB0byA4MCBjaGFyYWN0ZXJzLCB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgQkFTSUMgaW5wdXQgYnVmZmVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gdGhlIGNoYXJhY3RlcnMgY2FuIGJlIHJldHVybmVkIG9uZSBhdCBhIHRpbWUgYnkgY2FsbGluZyB0aGlzIHJvdXRpbmUgb25jZSBmb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlYWNoIGNoYXJhY3Rlci4gd2hlbiB0aGUgY2FycmlhZ2UgcmV0dXJuIGlzIHJldHVybmVkIHRoZSBlbnRpcmUgbGluZSBoYXMgYmVlblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb2Nlc3NlZC4gdGhlIG5leHQgdGltZSB0aGlzIHJvdXRpbmUgaXMgY2FsbGVkIHRoZSB3aG9sZSBwcm9jZXNzIGJlZ2lucyBhZ2Fpbi5cclxuLyogZmZjZiAqLyAgIF9gY2hyaW5fZmZjZmA7ICBKTVAuaW5kIChcImliYXNpbiswXzAzMjRcIik7ICAgIC8vIGRvIGlucHV0IGNoYXJhY3RlciBmcm9tIGNoYW5uZWxcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gb3V0cHV0IGNoYXJhY3RlciB0byBjaGFubmVsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyByb3V0aW5lIHdpbGwgb3V0cHV0IGEgY2hhcmFjdGVyIHRvIGFuIGFscmVhZHkgb3BlbmVkIGNoYW5uZWwuIFVzZSB0aGUgT1BFTlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJvdXRpbmUsICRGRkMwLCBhbmQgdGhlIENIS09VVCByb3V0aW5lLCAkRkZDOSwgdG8gc2V0IHVwIHRoZSBvdXRwdXQgY2hhbm5lbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlZm9yZSBjYWxsaW5nIHRoaXMgcm91dGluZS4gSWYgdGhlc2UgY2FsbHMgYXJlIG9taXR0ZWQsIGRhdGEgd2lsbCBiZSBzZW50IHRvIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgb3V0cHV0IGRldmljZSwgZGV2aWNlIDMsIHRoZSBzY3JlZW4uIFRoZSBkYXRhIGJ5dGUgdG8gYmUgb3V0cHV0IGlzIGxvYWRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGludG8gdGhlIGFjY3VtdWxhdG9yLCBhbmQgdGhpcyByb3V0aW5lIGlzIGNhbGxlZC4gVGhlIGRhdGEgaXMgdGhlbiBzZW50IHRvIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZCBvdXRwdXQgZGV2aWNlLiBUaGUgY2hhbm5lbCBpcyBsZWZ0IG9wZW4gYWZ0ZXIgdGhlIGNhbGwuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogQ2FyZSBtdXN0IGJlIHRha2VuIHdoZW4gdXNpbmcgcm91dGluZSB0byBzZW5kIGRhdGEgdG8gYSBzZXJpYWwgZGV2aWNlIHNpbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGF0YSB3aWxsIGJlIHNlbnQgdG8gYWxsIG9wZW4gb3V0cHV0IGNoYW5uZWxzIG9uIHRoZSBidXMuIFVubGVzcyB0aGlzIGlzIGRlc2lyZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxsIG9wZW4gb3V0cHV0IGNoYW5uZWxzIG9uIHRoZSBzZXJpYWwgYnVzIG90aGVyIHRoYW4gdGhlIGFjdHVhbGx5IGludGVuZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVzdGluYXRpb24gY2hhbm5lbCBtdXN0IGJlIGNsb3NlZCBieSBhIGNhbGwgdG8gdGhlIEtFUk5BTCBjbG9zZSBjaGFubmVsIHJvdXRpbmUuXHJcbi8qIGZmZDIgKi8gIF9gY2hyb3V0X2ZmZDJgOyAgSk1QLmluZCAoXCJpYnNvdXQrMF8wMzI2XCIpOyAgICAvLyBkbyBvdXRwdXQgY2hhcmFjdGVyIHRvIGNoYW5uZWxcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gbG9hZCBSQU0gZnJvbSBhIGRldmljZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgcm91dGluZSB3aWxsIGxvYWQgZGF0YSBieXRlcyBmcm9tIGFueSBpbnB1dCBkZXZpY2UgZGlyZWN0bHkgaW50byB0aGUgbWVtb3J5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhlIGNvbXB1dGVyLiBJdCBjYW4gYWxzbyBiZSB1c2VkIGZvciBhIHZlcmlmeSBvcGVyYXRpb24gY29tcGFyaW5nIGRhdGEgZnJvbSBhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGV2aWNlIHdpdGggdGhlIGRhdGEgYWxyZWFkeSBpbiBtZW1vcnksIGxlYXZpbmcgdGhlIGRhdGEgc3RvcmVkIGluIFJBTSB1bmNoYW5nZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGFjY3VtdWxhdG9yIG11c3QgYmUgc2V0IHRvIDAgZm9yIGEgbG9hZCBvcGVyYXRpb24gb3IgMSBmb3IgYSB2ZXJpZnkuIElmIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlucHV0IGRldmljZSB3YXMgT1BFTmVkIHdpdGggYSBzZWNvbmRhcnkgYWRkcmVzcyBvZiAwIHRoZSBoZWFkZXIgaW5mb3JtYXRpb24gZnJvbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRldmljZSB3aWxsIGJlIGlnbm9yZWQuIEluIHRoaXMgY2FzZSBYWSBtdXN0IGNvbnRhaW4gdGhlIHN0YXJ0aW5nIGFkZHJlc3MgZm9yIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvYWQuIElmIHRoZSBkZXZpY2Ugd2FzIGFkZHJlc3NlZCB3aXRoIGEgc2Vjb25kYXJ5IGFkZHJlc3Mgb2YgMSBvciAyIHRoZSBkYXRhIHdpbGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsb2FkIGludG8gbWVtb3J5IHN0YXJ0aW5nIGF0IHRoZSBsb2NhdGlvbiBzcGVjaWZpZWQgYnkgdGhlIGhlYWRlci4gVGhpcyByb3V0aW5lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyB0aGUgYWRkcmVzcyBvZiB0aGUgaGlnaGVzdCBSQU0gbG9jYXRpb24gd2hpY2ggd2FzIGxvYWRlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCZWZvcmUgdGhpcyByb3V0aW5lIGNhbiBiZSBjYWxsZWQsIHRoZSBTRVRMRlMsICRGRkJBLCBhbmQgU0VUTkFNLCAkRkZCRCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByb3V0aW5lcyBtdXN0IGJlIGNhbGxlZC5cclxuLyogZmZkNSAqLyAgICBfYGxvYWRfZmZkNWA7ICBKTVAuYWJzIChcImxvYWRfZjQ5ZVwiKTsgICAgICAgIC8vIGxvYWQgUkFNIGZyb20gYSBkZXZpY2VcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gc2F2ZSBSQU0gdG8gYSBkZXZpY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHJvdXRpbmUgc2F2ZXMgYSBzZWN0aW9uIG9mIG1lbW9yeS4gTWVtb3J5IGlzIHNhdmVkIGZyb20gYW4gaW5kaXJlY3QgYWRkcmVzc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9uIHBhZ2UgMCBzcGVjaWZpZWQgYnkgQSwgdG8gdGhlIGFkZHJlc3Mgc3RvcmVkIGluIFhZLCB0byBhIGxvZ2ljYWwgZmlsZS4gVGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU0VUTEZTLCAkRkZCQSwgYW5kIFNFVE5BTSwgJEZGQkQsIHJvdXRpbmVzIG11c3QgYmUgdXNlZCBiZWZvcmUgY2FsbGluZyB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcm91dGluZS4gSG93ZXZlciwgYSBmaWxlIG5hbWUgaXMgbm90IHJlcXVpcmVkIHRvIFNBVkUgdG8gZGV2aWNlIDEsIHRoZSBjYXNzZXR0ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbnkgYXR0ZW1wdCB0byBzYXZlIHRvIG90aGVyIGRldmljZXMgd2l0aG91dCB1c2luZyBhIGZpbGUgbmFtZSByZXN1bHRzIGluIGFuIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IGRldmljZSAwLCB0aGUga2V5Ym9hcmQsIGFuZCBkZXZpY2UgMywgdGhlIHNjcmVlbiwgY2Fubm90IGJlIFNBVkVkIHRvLiBJZlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBhdHRlbXB0IGlzIG1hZGUsIGFuIGVycm9yIHdpbGwgb2NjdXIsIGFuZCB0aGUgU0FWRSBzdG9wcGVkLlxyXG4vKiBmZmQ4ICovICAgIF9gc2F2ZV9mZmQ4YDsgIEpNUC5hYnMgKFwic2F2ZV9mNWRkXCIpOyAgICAgICAgLy8gc2F2ZSBSQU0gdG8gZGV2aWNlXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIHNldCB0aGUgcmVhbCB0aW1lIGNsb2NrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHN5c3RlbSBjbG9jayBpcyBtYWludGFpbmVkIGJ5IGFuIGludGVycnVwdCByb3V0aW5lIHRoYXQgdXBkYXRlcyB0aGUgY2xvY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBldmVyeSAxLzYwdGggb2YgYSBzZWNvbmQuIFRoZSBjbG9jayBpcyB0aHJlZSBieXRlcyBsb25nIHdoaWNoIGdpdmVzIHRoZSBjYXBhYmlsaXR5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gY291bnQgZnJvbSB6ZXJvIHVwIHRvIDUsMTg0LDAwMCBqaWZmaWVzIC0gMjQgaG91cnMgcGx1cyBvbmUgamlmZnkuIEF0IHRoYXQgcG9pbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgY2xvY2sgcmVzZXRzIHRvIHplcm8uIEJlZm9yZSBjYWxsaW5nIHRoaXMgcm91dGluZSB0byBzZXQgdGhlIGNsb2NrIHRoZSBuZXcgdGltZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBqaWZmaWVzLCBzaG91bGQgYmUgaW4gWVhBLCB0aGUgYWNjdW11bGF0b3IgY29udGFpbmluZyB0aGUgbW9zdCBzaWduaWZpY2FudCBieXRlLlxyXG4vKiBmZmRiICovICBfYHNldHRpbV9mZmRiYDsgIEpNUC5hYnMgKFwic2V0dGltX2Y2ZTRcIik7ICAgICAgLy8gc2V0IHJlYWwgdGltZSBjbG9ja1xyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyByZWFkIHRoZSByZWFsIHRpbWUgY2xvY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHJvdXRpbmUgcmV0dXJucyB0aGUgdGltZSwgaW4gamlmZmllcywgaW4gQVhZLiBUaGUgYWNjdW11bGF0b3IgY29udGFpbnMgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW9zdCBzaWduaWZpY2FudCBieXRlLlxyXG4vKiBmZmRlICovICAgX2ByZHRpbV9mZmRlYDsgIEpNUC5hYnMgKFwicmR0aW1fZjZkZFwiKTsgICAgICAgLy8gcmVhZCByZWFsIHRpbWUgY2xvY2tcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gc2NhbiB0aGUgc3RvcCBrZXlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgU1RPUCBrZXkgb24gdGhlIGtleWJvYXJkIGlzIHByZXNzZWQgd2hlbiB0aGlzIHJvdXRpbmUgaXMgY2FsbGVkIHRoZSBaIGZsYWdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIGJlIHNldC4gQWxsIG90aGVyIGZsYWdzIHJlbWFpbiB1bmNoYW5nZWQuIElmIHRoZSBTVE9QIGtleSBpcyBub3QgcHJlc3NlZCB0aGVuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGFjY3VtdWxhdG9yIHdpbGwgY29udGFpbiBhIGJ5dGUgcmVwcmVzZW50aW5nIHRoZSBsYXN0IHJvdyBvZiB0aGUga2V5Ym9hcmQgc2Nhbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdXNlciBjYW4gYWxzbyBjaGVjayBmb3IgY2VydGFpbiBvdGhlciBrZXlzIHRoaXMgd2F5LlxyXG4vKiBmZmUxICovICAgIF9gc3RvcF9mZmUxYDsgIEpNUC5pbmQgKFwiaXN0b3ArMF8wMzI4XCIpOyAgICAgLy8gZG8gc2NhbiBzdG9wIGtleVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBnZXQgY2hhcmFjdGVyIGZyb20gaW5wdXQgZGV2aWNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gcHJhY3RpY2UgdGhpcyByb3V0aW5lIG9wZXJhdGVzIGlkZW50aWNhbGx5IHRvIHRoZSBDSFJJTiByb3V0aW5lLCAkRkZDRixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgYWxsIGRldmljZXMgZXhjZXB0IGZvciB0aGUga2V5Ym9hcmQuIElmIHRoZSBrZXlib2FyZCBpcyB0aGUgY3VycmVudCBpbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRldmljZSB0aGlzIHJvdXRpbmUgd2lsbCBnZXQgb25lIGNoYXJhY3RlciBmcm9tIHRoZSBrZXlib2FyZCBidWZmZXIuIEl0IGRlcGVuZHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvbiB0aGUgSVJRIHJvdXRpbmUgdG8gcmVhZCB0aGUga2V5Ym9hcmQgYW5kIHB1dCBjaGFyYWN0ZXJzIGludG8gdGhlIGJ1ZmZlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUga2V5Ym9hcmQgYnVmZmVyIGlzIGVtcHR5IHRoZSB2YWx1ZSByZXR1cm5lZCBpbiB0aGUgYWNjdW11bGF0b3Igd2lsbCBiZSB6ZXJvLlxyXG4vKiBmZmU0ICovICAgX2BnZXRpbl9mZmU0YDsgIEpNUC5pbmQgKFwiaWdldGluKzBfMDMyYVwiKTsgICAgLy8gZG8gZ2V0IGNoYXJhY3RlciBmcm9tIGlucHV0IGRldmljZVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyBjbG9zZSBhbGwgY2hhbm5lbHMgYW5kIGZpbGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyByb3V0aW5lIGNsb3NlcyBhbGwgb3BlbiBmaWxlcy4gV2hlbiB0aGlzIHJvdXRpbmUgaXMgY2FsbGVkLCB0aGUgcG9pbnRlcnMgaW50b1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBvcGVuIGZpbGUgdGFibGUgYXJlIHJlc2V0LCBjbG9zaW5nIGFsbCBmaWxlcy4gQWxzbyB0aGUgcm91dGluZSBhdXRvbWF0aWNhbGx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXRzIHRoZSBJL08gY2hhbm5lbHMuXHJcbi8qIGZmZTcgKi8gICBfYGNsYWxsX2ZmZTdgOyAgSk1QLmluZCAoXCJpY2xhbGwrMF8wMzJjXCIpOyAgICAvLyBkbyBjbG9zZSBhbGwgY2hhbm5lbHMgYW5kIGZpbGVzXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vIGluY3JlbWVudCByZWFsIHRpbWUgY2xvY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHJvdXRpbmUgdXBkYXRlcyB0aGUgc3lzdGVtIGNsb2NrLiBOb3JtYWxseSB0aGlzIHJvdXRpbmUgaXMgY2FsbGVkIGJ5IHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vcm1hbCBLRVJOQUwgaW50ZXJydXB0IHJvdXRpbmUgZXZlcnkgMS82MHRoIG9mIGEgc2Vjb25kLiBJZiB0aGUgdXNlciBwcm9ncmFtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvY2Vzc2VzIGl0cyBvd24gaW50ZXJydXB0cyB0aGlzIHJvdXRpbmUgbXVzdCBiZSBjYWxsZWQgdG8gdXBkYXRlIHRoZSB0aW1lLiBBbHNvLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBTVE9QIGtleSByb3V0aW5lIG11c3QgYmUgY2FsbGVkIGlmIHRoZSBzdG9wIGtleSBpcyB0byByZW1haW4gZnVuY3Rpb25hbC5cclxuLyogZmZlYSAqLyAgIF9gdWR0aW1fZmZlYWA7ICBKTVAuYWJzIChcInVkdGltX2Y2OWJcIik7ICAgICAgIC8vIGluY3JlbWVudCByZWFsIHRpbWUgY2xvY2tcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcmV0dXJuIFgsWSBvcmdhbml6YXRpb24gb2Ygc2NyZWVuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyByb3V0aW5lIHJldHVybnMgdGhlIHgseSBvcmdhbmlzYXRpb24gb2YgdGhlIHNjcmVlbiBpbiBYLFlcclxuLyogZmZlZCAqLyAgX2BzY3JlZW5fZmZlZGA7ICBKTVAuYWJzIChcInNjcmVlbl9lNTA1XCIpOyAgICAgIC8vIHJldHVybiBYLFkgb3JnYW5pemF0aW9uIG9mIHNjcmVlblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvLyByZWFkL3NldCBYLFkgY3Vyc29yIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyByb3V0aW5lLCB3aGVuIGNhbGxlZCB3aXRoIHRoZSBjYXJyeSBmbGFnIHNldCwgbG9hZHMgdGhlIGN1cnJlbnQgcG9zaXRpb24gb2ZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgY3Vyc29yIG9uIHRoZSBzY3JlZW4gaW50byB0aGUgWCBhbmQgWSByZWdpc3RlcnMuIFggaXMgdGhlIGNvbHVtbiBudW1iZXIgb2ZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgY3Vyc29yIGxvY2F0aW9uIGFuZCBZIGlzIHRoZSByb3cgbnVtYmVyIG9mIHRoZSBjdXJzb3IuIEEgY2FsbCB3aXRoIHRoZSBjYXJyeVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJpdCBjbGVhciBtb3ZlcyB0aGUgY3Vyc29yIHRvIHRoZSBwb3NpdGlvbiBkZXRlcm1pbmVkIGJ5IHRoZSBYIGFuZCBZIHJlZ2lzdGVycy5cclxuLyogZmZmMCAqLyAgICBfYHBsb3RfZmZmMGA7ICBKTVAuYWJzIChcInBsb3RfZTUwYVwiKTsgICAgICAgIC8vIHJlYWQvc2V0IFgsWSBjdXJzb3IgcG9zaXRpb25cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gcmV0dXJuIHRoZSBiYXNlIGFkZHJlc3Mgb2YgdGhlIEkvTyBkZXZpY2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyByb3V0aW5lIHdpbGwgc2V0IFhZIHRvIHRoZSBhZGRyZXNzIG9mIHRoZSBtZW1vcnkgc2VjdGlvbiB3aGVyZSB0aGUgbWVtb3J5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFwcGVkIEkvTyBkZXZpY2VzIGFyZSBsb2NhdGVkLiBUaGlzIGFkZHJlc3MgY2FuIHRoZW4gYmUgdXNlZCB3aXRoIGFuIG9mZnNldCB0b1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFjY2VzcyB0aGUgbWVtb3J5IG1hcHBlZCBJL08gZGV2aWNlcyBpbiB0aGUgY29tcHV0ZXIuXHJcbi8qIGZmZjMgKi8gIF9gaW9iYXNlX2ZmZjNgOyAgSk1QLmFicyAoXCJpb2Jhc2VfZTUwMFwiKTsgICAgICAvLyByZXR1cm4gdGhlIGJhc2UgYWRkcmVzcyBvZiB0aGUgSS9PIGRldmljZXNcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSUkJZXHJcbi8qIGZmZjYgKi8gICAgICAgICAgICAgICAgICAgXy5ieXRlcygweDUyLCAweDUyLCAweDQyLCAweDU5KTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy8gaGFyZHdhcmUgdmVjdG9yc1xyXG4vKiBmZmZhICovICAgICAgICAgICAgICAgICAgIF8uYnl0ZXMoMHg0MywgMHhmZSk7ICAgICAgICAgIC8vIE5NSSBWZWt0b3JcclxuLyogZmZmYyAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4ZTIsIDB4ZmMpOyAgICAgICAgICAvLyBSRVNFVCBWZWt0b3JcclxuLyogZmZmZSAqLyAgICAgICAgICAgICAgICAgICBfLmJ5dGVzKDB4NDgsIDB4ZmYpOyAgICAgICAgICAvLyBJUlEgVmVrdG9yXHJcbiAgfVxyXG4pO1xyXG4iLCIvKlxyXG4gICBza2lwUmFtVGVzdCAtIGV4cG9ydHMgYSBwYXRjaGVkIEtlcm5hbCB0aGF0IHNraXBzIHRoZSBSQU0gdGVzdCBvbiBib290LCBqdXN0XHJcbiAgIHRvIHNwZWVkIHVwIHRoZSBkZXYgYnVpbGRzLlxyXG4qL1xyXG5cclxuaW1wb3J0IHsgYXNzZW1ibGUgfSBmcm9tIFwiLi4vLi4vdG9vbHMvYXNzZW1ibGVyXCI7XHJcbmltcG9ydCBrZXJuYWwgICAgICAgZnJvbSBcIi4va2VybmFsXCI7XHJcblxyXG5jb25zdCBLRVJOQUxfU1RBUlQgPSAweGUwMDA7XHJcbmNvbnN0IFBBVENIX1NUQVJUICA9IDB4ZmQ2NztcclxuXHJcbmNvbnN0IHBhdGNoID0gYXNzZW1ibGUoXHJcbiAgUEFUQ0hfU1RBUlQsXHJcbiAgKHsgTERBLCBTVEEsIEpNUCwgXyB9KSA9PiB7XHJcblxyXG4gICAgXy5sYWJlbCgweGEwMDAsIFwibWVtdG9wXCIpO1xyXG5cclxuICAgIExEQS5pbW0gKF8ubGBtZW10b3BgKTtcclxuICAgIFNUQS5hYnMgKDB4MjgzKTsgICAgICAgIC8vIHN0b3JlIG1lbW9yeSB0b3AgbG93IGJ5dGVcclxuICAgIExEQS5pbW0gKF8uaGBtZW10b3BgKTtcclxuICAgIFNUQS5hYnMgKDB4Mjg0KTsgICAgICAgIC8vIHN0b3JlIG1lbW9yeSB0b3AgbG93IGJ5dGVcclxuICAgIEpNUC5hYnMgKDB4ZmQ5MCk7ICAgICAgIC8vIGZpcnN0IGluc3RydWN0aW9uIGFmdGVyIFJBTSB0ZXN0XHJcbiAgfVxyXG4pO1xyXG5cclxuY29uc3QgcGF0Y2hlZEtlcm5hbCA9IFsuLi5rZXJuYWxdO1xyXG5cclxuZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRjaC5sZW5ndGg7IGkrKykge1xyXG4gIHBhdGNoZWRLZXJuYWxbaSArIFBBVENIX1NUQVJUIC0gS0VSTkFMX1NUQVJUXSA9IHBhdGNoW2ldO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBwYXRjaGVkS2VybmFsO1xyXG4iLCIvKlxyXG4gICBydW5sb29wOiBwZXJmb3JtcyBvcGVyYXRpb25zIGxpa2UgdGljaywgc2VyaWFsaXplIGFuZCBkZXNlcmlhbGl6ZSBvbiB0aGVcclxuICAgdGFyZ2V0IHN5c3RlbSBhcyBhIHdob2xlLCBhbmQgcnVucyB0aGUgc2ltdWxhdGlvbiBpbiBhIHRpbWUtdGhyb3R0bGVkIGxvb3AsXHJcbiAgIHdpdGggYW4gb3B0aW9uYWwgaG9vayBmb3IgYnJlYWtwb2ludHNcclxuKi9cclxuXHJcbmltcG9ydCB7XHJcbiAgS0VZQk9BUkRfQlVGRkVSX0FERFIsXHJcbiAgS0VZQk9BUkRfQlVGRkVSX0lOREVYLFxyXG4gIEtFWUJPQVJEX0JVRkZFUl9MRU5HVEgsXHJcbn0gZnJvbSBcIi4uL3Rvb2xzL3JvbUxvY2F0aW9uc1wiO1xyXG5cclxuLy8gTm9kZS5qcyBkb2Vzbid0IGhhdmUgYHBlcmZvcm1hbmNlYCBsb2FkZWQgYnkgZGVmYXVsdC4gTm90IHRoYXQgd2UgbWFrZSB1c2VcclxuLy8gb2YgaXQgaW4gdGhhdCB2ZXJzaW9uLCBidXQgdGhlIHJ1bmxvb3AgZXhwZWN0cyBpdCB0byBiZSB0aGVyZS5cclxuaWYgKCFnbG9iYWxUaGlzLnBlcmZvcm1hbmNlKSB7XHJcbiAgZ2xvYmFsVGhpcy5wZXJmb3JtYW5jZSA9IHsgbm93OiAoKSA9PiAwIH07XHJcbn1cclxuXHJcbi8vIEhvdyBtYW55IGZyYW1lcyB0byBydW4gZm9yIGEgc2luZ2xlIGZyYW1lcy1wZXItc2Vjb25kIHNhbXBsZVxyXG5jb25zdCBGUkFNRVNfUEVSX1dBWVBPSU5UID0gNTA7XHJcblxyXG4vLyBCb3VuZCBieSBhdHRhY2hcclxubGV0IGM2NDtcclxuXHJcbi8vIGNvbmZpZ3VyZSBieSBzZXREZXZpY2VzXHJcbmxldCB3aXJlcztcclxubGV0IGNwdTtcclxubGV0IHZpYztcclxubGV0IGNpYXM7XHJcbmxldCBzaWQ7XHJcbmxldCB0YXBlO1xyXG5cclxubGV0IHN0YXRlO1xyXG5sZXQgbWFzdGVyU3RvcCA9IGZhbHNlO1xyXG5sZXQgZnJhbWVTdG9wICA9IGZhbHNlO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGF0dGFjaChuYXNjZW50QzY0KSB7XHJcbiAgYzY0ID0gbmFzY2VudEM2NDtcclxuXHJcbiAgd2lyZXMgPSBjNjQud2lyZXM7XHJcbiAgY3B1ICAgPSBjNjQuY3B1O1xyXG4gIHZpYyAgID0gYzY0LnZpYztcclxuICBjaWFzICA9IGM2NC5jaWFzO1xyXG4gIHNpZCAgID0gYzY0LnNpZDtcclxuICB0YXBlICA9IGM2NC50YXBlO1xyXG5cclxuICByZXNldCgpO1xyXG5cclxuICBjNjQucnVubG9vcCA9IHtcclxuICAgIC8vIENvbnRyb2xcclxuICAgIHJ1bixcclxuICAgIHN0b3AsXHJcbiAgICBzdG9wQWZ0ZXJGcmFtZSxcclxuICAgIGlzUnVubmluZyxcclxuICAgIHR5cGUsXHJcbiAgICB1bnRpbFBjLFxyXG4gICAgcmVzZXQsXHJcbiAgICBzZXJpYWxpemUsXHJcbiAgICBkZXNlcmlhbGl6ZSxcclxuICAgIC8vIERlYnVnXHJcbiAgICBnZXRTdGF0ZSxcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXNldCgpIHtcclxuICBzdGF0ZSA9IHtcclxuICAgIGN5Y2xlOiAwLFxyXG4gIH07XHJcbiAgXHJcbiAgYzY0LndpcmVzLnJlc2V0KCk7XHJcbiAgYzY0LnJhbSAgLnJlc2V0KCk7XHJcbiAgYzY0LnZpYyAgLnJlc2V0KCk7XHJcbiAgYzY0LnNpZCAgLnJlc2V0KCk7IFxyXG4gIGM2NC5jcHUgIC5yZXNldCgpO1xyXG4gIGM2NC5jaWFzIC5yZXNldCgpO1xyXG4gIGM2NC50YXBlIC5yZXNldCgpO1xyXG5cclxuICBpZiAoYzY0Lmhvb2tzLnNldFRpdGxlKSB7XHJcbiAgICBjNjQuaG9va3Muc2V0VGl0bGUoXCJcIik7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRTdGF0ZSgpIHtcclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0b3AoKSB7XHJcbiAgbWFzdGVyU3RvcCA9IHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0b3BBZnRlckZyYW1lKCkge1xyXG4gIGZyYW1lU3RvcCA9IHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzUnVubmluZygpIHtcclxuICByZXR1cm4gIW1hc3RlclN0b3A7XHJcbn1cclxuXHJcbmxldCB0aW1lcjtcclxuXHJcbmZ1bmN0aW9uIHJ1bihwcm9maWxlKSB7XHJcblxyXG4gIC8vIEFwcGx5IGRlZmF1bHQgcnVuIHByb2ZpbGVcclxuICBwcm9maWxlID0ge1xyXG4gICAgdGljazogKCkgPT4gZmFsc2UsXHJcbiAgICBmcHM6IDUwLFxyXG4gICAgLi4ucHJvZmlsZSxcclxuICB9XHJcblxyXG4gIGxldCByZXNvbHZlQnJlYWtQcm9taXNlO1xyXG4gIGNvbnN0IGJyZWFrUHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4geyByZXNvbHZlQnJlYWtQcm9taXNlID0gcmVzb2x2ZTsgfSk7XHJcblxyXG4gIGlmICh0aW1lciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICBtYXN0ZXJTdG9wID0gdHJ1ZTtcclxuICAgIGNsZWFySW50ZXJ2YWwodGltZXIpO1xyXG4gIH1cclxuXHJcbiAgbWFzdGVyU3RvcCA9IGZhbHNlO1xyXG4gIGZyYW1lU3RvcCAgPSBmYWxzZTtcclxuXHJcbiAgY29uc3QgY2xlYW5VcE9uQnJlYWsgPSAoKSA9PiB7XHJcbiAgICBjbGVhckludGVydmFsKHRpbWVyKTtcclxuICAgIGlmIChjNjQuaG9va3MuZGlkU3RvcCkgYzY0Lmhvb2tzLmRpZFN0b3AoKTtcclxuICAgIHRpbWVyID0gdW5kZWZpbmVkO1xyXG4gICAgcmVzb2x2ZUJyZWFrUHJvbWlzZSgpO1xyXG4gIH07XHJcblxyXG4gIGxldCB0aW1lQXRXYXlwb2ludCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gIGxldCBmcmFtZXNTaW5jZVdheXBvaW50ID0gMDtcclxuXHJcbiAgdGltZXIgPSBzZXRJbnRlcnZhbChcclxuICAgICgpID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBXZSdsbCBsb29wIGZvciBvbmUgdmlkZW8gZnJhbWUgYXQgYSB0aW1lLiBUaGF0IGlzLFxyXG4gICAgICAgIC8vIDMxMiByb3dzIG9mIDYzIGN5Y2xlcyBwZXIgcm93XHJcbiAgICAgICAgLy8gKFdoaWNoIHdvdWxkIGJlIGRpZmZlcmVudCBpZiB3ZSBzdXBwb3J0IE5UU0MgaW4gZnV0dXJlKVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgKDYzICogMzEyKTsgaSsrKSB7XHJcbiAgICAgICAgICBzdGF0ZS5jeWNsZSsrO1xyXG5cclxuICAgICAgICAgIGNwdSAudGljaygpO1xyXG4gICAgICAgICAgdmljIC50aWNrKCk7XHJcbiAgICAgICAgICBjaWFzLnRpY2soKTtcclxuICAgICAgICAgIHNpZCAudGljaygpO1xyXG4gICAgICAgICAgdGFwZS50aWNrKCk7XHJcblxyXG4gICAgICAgICAgaWYgKG1hc3RlclN0b3AgfHwgcHJvZmlsZS50aWNrKCkpIHtcclxuICAgICAgICAgICAgY2xlYW5VcE9uQnJlYWsoKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGcmFtZXMtcGVyLXNlY29uZCBjb3VudGVyXHJcbiAgICAgICAgaWYgKCsrZnJhbWVzU2luY2VXYXlwb2ludCA9PT0gRlJBTUVTX1BFUl9XQVlQT0lOVCkge1xyXG4gICAgICAgICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcblxyXG4gICAgICAgICAgaWYgKGM2NC5ob29rcy51cGRhdGVGcHMpIHtcclxuICAgICAgICAgICAgYzY0Lmhvb2tzLnVwZGF0ZUZwcyhcclxuICAgICAgICAgICAgICBNYXRoLnJvdW5kKCgxMDAwICogRlJBTUVTX1BFUl9XQVlQT0lOVCkgLyAobm93IC0gdGltZUF0V2F5cG9pbnQpKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRpbWVBdFdheXBvaW50ID0gbm93O1xyXG4gICAgICAgICAgZnJhbWVzU2luY2VXYXlwb2ludCA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGcmFtZSBzdG9wXHJcbiAgICAgICAgaWYgKGZyYW1lU3RvcCkgY2xlYW5VcE9uQnJlYWsoKTtcclxuICAgICAgfVxyXG4gICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYXVnaHQgZXhjZXB0aW9uOlwiLCBlKTtcclxuICAgICAgICBjbGVhblVwT25CcmVhaygpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgMTAwMCAvIHByb2ZpbGUuZnBzXHJcbiAgKTtcclxuXHJcbiAgaWYgKGM2NC5ob29rcy5kaWRTdGFydCkgYzY0Lmhvb2tzLmRpZFN0YXJ0KCk7XHJcblxyXG4gIHJldHVybiBicmVha1Byb21pc2U7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIHVudGlsUGMocGMsIGZhc3QgPSBmYWxzZSkge1xyXG5cclxuICBjb25zdCByZWdzID0gYzY0LmNwdS5nZXRTdGF0ZSgpO1xyXG5cclxuICBpZiAocGMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgLy8gVE9ETzogdGhyb3cgaW5zdGVhZD9cclxuICAgIGNvbnNvbGUuZXJyb3IoXCJNaXNzaW5nIGFyZ3VtZW50OiBQQyBhZGRyZXNzXCIpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgLy8gSWYgdGhlIFBDIHdhcyBjdXJyZW50bHkgYXQgdGhlIGFkZHJlc3Mgd2Ugd2VyZSB3YWl0aW5nIGZvcixcclxuICAvLyBhZHZhbmNlIHBhc3QgaXQuIFlvdSB3YW50IHRvIGJlIGFibGUgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uXHJcbiAgLy8gbXVsdHBsZSB0aW1lcyB0byByZS1ydW4uXHJcbiAgYXdhaXQgcnVuKHtcclxuICAgIHRpY2s6ICgpID0+IHJlZ3MucGMgIT09IHBjLFxyXG4gIH0pO1xyXG5cclxuICBjb25zdCBwcm9maWxlID0ge1xyXG4gICAgdGljazogKCkgPT4gcmVncy5wYyA9PT0gcGMsXHJcbiAgfTtcclxuXHJcbiAgaWYgKGZhc3QpIHByb2ZpbGUuZnBzID0gSW5maW5pdHk7XHJcblxyXG4gIHJldHVybiBydW4ocHJvZmlsZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHR5cGUoc3RyKSB7XHJcbiAgbGV0IGJ1ZkxlbiA9IGM2NC53aXJlcy5jcHVSZWFkKEtFWUJPQVJEX0JVRkZFUl9JTkRFWCk7XHJcblxyXG4gIGZvciAobGV0IGNoYXIgb2Ygc3RyKSB7XHJcblxyXG4gICAgaWYgKGJ1ZkxlbiA+PSBLRVlCT0FSRF9CVUZGRVJfTEVOR1RIKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk92ZXJmbG93IGZvciBLZXJuYWwga2V5Ym9hcmQgYnVmZmVyXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGM2NC53aXJlcy5jcHVXcml0ZShLRVlCT0FSRF9CVUZGRVJfQUREUiArIGJ1ZkxlbiwgY2hhci5jaGFyQ29kZUF0KDApKTtcclxuICAgIGM2NC53aXJlcy5jcHVXcml0ZShLRVlCT0FSRF9CVUZGRVJfSU5ERVgsICsrYnVmTGVuKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcclxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoXHJcbiAgICB7XHJcbiAgICAgIHZlcnNpb246IHtcclxuICAgICAgICBjcmVhdG9yOiBcInZpY2lpb3VzXCIsXHJcbiAgICAgICAgbWFqb3I6IDAsXHJcbiAgICAgICAgbWlub3I6IDEsXHJcbiAgICAgIH0sXHJcbiAgICAgIHJ1bmxvb3A6IEpTT04uc3RyaW5naWZ5KHN0YXRlKSxcclxuICAgICAgd2lyZXM6ICAgYzY0LndpcmVzLnNlcmlhbGl6ZSgpLFxyXG4gICAgICByYW06ICAgICBjNjQucmFtICAuc2VyaWFsaXplKCksXHJcbiAgICAgIHZpYzogICAgIGM2NC52aWMgIC5zZXJpYWxpemUoKSxcclxuICAgICAgc2lkOiAgICAgYzY0LnNpZCAgLnNlcmlhbGl6ZSgpLFxyXG4gICAgICBjcHU6ICAgICBjNjQuY3B1ICAuc2VyaWFsaXplKCksXHJcbiAgICAgIGNpYXM6ICAgIGM2NC5jaWFzIC5zZXJpYWxpemUoKSxcclxuICAgICAgdGFwZTogICAgYzY0LnRhcGUgLnNlcmlhbGl6ZSgpLFxyXG4gICAgfVxyXG4gICk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlc2VyaWFsaXplKGpzb24pIHtcclxuICBjb25zdCBvYmogPSBKU09OLnBhcnNlKGpzb24pO1xyXG5cclxuICBzdGF0ZSA9IEpTT04ucGFyc2Uob2JqLnJ1bmxvb3ApO1xyXG5cclxuICBjNjQud2lyZXMuZGVzZXJpYWxpemUob2JqLndpcmVzKTtcclxuICBjNjQucmFtICAuZGVzZXJpYWxpemUob2JqLnJhbSAgKTtcclxuICBjNjQudmljICAuZGVzZXJpYWxpemUob2JqLnZpYyAgKTtcclxuICBjNjQuc2lkICAuZGVzZXJpYWxpemUob2JqLnNpZCAgKTtcclxuICBjNjQuY3B1ICAuZGVzZXJpYWxpemUob2JqLmNwdSAgKTtcclxuICBjNjQuY2lhcyAuZGVzZXJpYWxpemUob2JqLmNpYXMgKTtcclxuICBjNjQudGFwZSAuZGVzZXJpYWxpemUob2JqLnRhcGUgKTtcclxufVxyXG4iLCIvKlxyXG4gICBzaWQ6IGVtdWxhdGVzIHRoZSA2NTgxIChTSUQpIHNvdW5kIHN5bnRoZXNpemVyXHJcblxyXG4gICBUaGlzIGVtdWxhdGlvbiBpcyBhIHByZXR0eSBtaW5pbWFsIGltcGxlbWVudGF0aW9uIG9mIHRoZSBTSUQuIEl0IHJlbGllcyBvbiBhXHJcbiAgIG5ldHdvcmsgb2YgT3NjaWxsYXRvck5vZGUgbm9kZXMgb24gdGhlIGhvc3Qgc2lkZSB0byBhY3R1YWxseSBkbyB0aGUgc291bmRcclxuICAgc3ludGhlc2lzLiBUaGlzIGlzIHF1aXJreSBmb3IgYW4gZW11bGF0b3I6IGl0IGhhcyB0aGUgYWR2YW50YWdlIHRoYXQgaWYgdGhlXHJcbiAgIGVtdWxhdGlvbiBpcyBwYXVzZWQgb3Igc2xvdywgdGhlIHNvdW5kIHdpbGwgY29udGludWUgd2l0aG91dCBzdHV0dGVyaW5nIGFcclxuICAgYnVmZmVyIGxvb3A7IGJ1dCBpdCBoYXMgbWFuaWZlc3QgbGltaXRhdGlvbnMuXHJcblxyXG4gICBFc3NlbnRpYWxseSwgdGhpcyBjb2RlIGlzIGp1c3QgZW11bGF0aW5nIHRoZSBBRFNSIGVudmVsb3BlIGdlbmVyYXRvciAoYW5kXHJcbiAgIGNlcnRhaW5seSBoYXMgYnVncyBpbiBkb2luZyBzbyksIGFuZCBoYW5kcyBldmVyeXRoaW5nIGVsc2Ugb2ZmIHRvIHRoZSBob3N0LlxyXG5cclxuICAgQXMgZm9yIHRob3NlIGxpbWl0YXRpb25zOlxyXG5cclxuICAgLSBubyBzeW5jaHJvbml6YXRpb24gZnVuY3Rpb25hbGl0eSAoYXMgaW4gdm9pY2UgY29udHJvbCByZWdpc3RlcnMgYml0IDEpXHJcbiAgIC0gdm9pY2UgMyB3YXZlZm9ybSBvdXRwdXQgaXMgbm9pc2Ugb25seSAod2hpY2ggbGlrZWx5IGlzIGl0cyBtYWluIHB1cnBvc2UpXHJcbiAgIC0gbm8gdGltaW5nIGFjY3VyYWN5IHdpdGhpbiBhIGZyYW1lLiBUaGUgY29yZSBsb29wIG9mIHRoZSBlbXVsYXRvciBydW5zIGFcclxuICAgICBmcmFtZSdzIHdvcnRoIG9mIHNpbXVsYXRpb24gaW4gb25lIGdvLCB0aGVuIHdhaXRzIGZvciBhIHRpbWVvdXQgdG8gY3VlIHRoZVxyXG4gICAgIG5leHQgZnJhbWUgb2Ygc2ltdWxhdGlvbi4gQXMgU0lEIHJlZ2lzdGVyIHdyaXRlcyBhcmUgc2VudCB0byB0aGUgaG9zdCBhc1xyXG4gICAgIHNvb24gYXMgdGhleSdyZSBlbmNvdW50ZXJlZCwgdGhpcyBlZmZlY3RpdmVseSBtZWFucyB0aGF0IHNvdW5kIGNvbW1hbmRzXHJcbiAgICAgYXJlIGJhdGNoZWQgaW5zdGVhZCBvZiBzdGFnZ2VyZWQgaW4gcmVhbCB0aW1lLiBTaW5jZSBtb3N0IHNvdW5kIGNvbW1hbmRzXHJcbiAgICAgYXJlIHRyaWdnZXJlZCBmcm9tIGEgNTAgb3IgNjBIeiBpbnRlcnJ1cHQgYW55d2F5cywgdGhpcyBpc24ndCBhIGJpZ1xyXG4gICAgIHByb2JsZW0uIEJ1dCBzYW1wbGVzLCBvbiB0aGUgb3RoZXIgaGFuZCwgd2lsbCBnZXQgYmFkbHkgZGlzdG9ydGVkXHJcbiAgICAgdGVtcG9yYWxseS4gKE5vdCB0aGF0IHRoZSBob3N0IGhhcyBhIGdvb2Qgd2F5IG9mIHBsYXlpbmcgdGhlbSBiYWNrLCB3aXRoXHJcbiAgICAgdGhlIE9zY2lsbGF0b3JOb2RlIG5ldHdvcmssIGV2ZW4gaWYgdGltaW5nIGNvdWxkIGJlIGd1YXJhbnRlZWQpLlxyXG4qL1xyXG5cclxuaW1wb3J0IHsgJHh4LCAkeHh4eCwgdW5pbXBsZW1lbnRlZFdhcm5pbmcgfSBmcm9tIFwiLi4vZGVidWdcIjtcclxuXHJcbi8vIEp1c3QgZm9yIGRpYWdub3N0aWNzXHJcbmltcG9ydCB7IGRpYWcgfSBmcm9tIFwiLi9zaWRfZGlhZ1wiO1xyXG5cclxuLy8gRm9yIHByZS1nZW5lcmF0aW5nIGV4cG9uZW50aWFsIGF0dGFjay9kZWNheSBjdXJ2ZXNcclxuY29uc3QgQVNZTVBUT1RFID0gMS4xO1xyXG5cclxuLy8gMTAwMCBDUFUgY3ljbGVzICg9IDFtcykgcGVyIEFEU1IgY29uc2lkZXJhdGlvbiB0aWNrXHJcbmNvbnN0IENZQ0xFU19QRVJfQURTUl9USUNLID0gMTAwO1xyXG5cclxuLy8gU28gdGljayBkdXJhdGlvbiBpcyBhYm91dCAxbXNcclxuY29uc3QgTVNfUEVSX0FEU1JfVElDSyA9ICgxIC8gMWU2KSAqIENZQ0xFU19QRVJfQURTUl9USUNLICogMTAwMDtcclxuXHJcbmZ1bmN0aW9uIGdldE11bHRpcGxpZXIoYXN5bXB0b3RlLCBzdGVwcykge1xyXG4gIC8vIFJldHVybnMgdGhlIG11bHRpcGxpZXIgeW91J2QgbmVlZCBmb3IgYW4gYXR0YWNrIG11bHRpcGxpZXIsXHJcbiAgLy8gRm9yIGFuIHVwc2lkZS1kb3duIGV4cG9uZW50aWFsIHNpZ25hbCB0aGF0IHdvdWxkIGFwcHJvYWNoIGBhc3ltcHRvdGVgLFxyXG4gIC8vIGFuZCB3b3VsZCByZWFjaCAxLjAgYWZ0ZXIgYHN0ZXBzYCBzdGVwcy5cclxuXHJcbiAgLy8gVGhhdCBpcywgZm9yIHkgPSAoYXN5bXB0b3RlKS4obXVsdGlwbGllcileeCxcclxuICAvLyB0aGlzIHJldHVybnMgbXVsdGlwbGllclxyXG5cclxuICByZXR1cm4gKE1hdGguRSAqKiAoTWF0aC5sb2coKGFzeW1wdG90ZSAtIDEpIC8gYXN5bXB0b3RlKSAvIHN0ZXBzKSk7XHJcbn1cclxuXHJcbmNvbnN0IGF0dGFja011bHRpcGxpZXJGb3JEdXJhdGlvbiA9IFtcclxuICAgICAyLFxyXG4gICAgIDgsXHJcbiAgICAxNixcclxuICAgIDI0LFxyXG4gICAgMzgsXHJcbiAgICA1NixcclxuICAgIDY4LFxyXG4gICAgODAsXHJcbiAgIDEwMCxcclxuICAgMjQwLFxyXG4gICA1MDAsXHJcbiAgIDgwMCxcclxuICAxMDAwLFxyXG4gIDMwMDAsXHJcbiAgNTAwMCxcclxuICA4MDAwLFxyXG5dLm1hcChcclxuICBtcyA9PiBnZXRNdWx0aXBsaWVyKEFTWU1QVE9URSwgbXMgLyBNU19QRVJfQURTUl9USUNLKVxyXG4pO1xyXG5cclxuY29uc3QgZGVjYXlNdWx0aXBsaWVyRm9yRHVyYXRpb24gPSBbXHJcbiAgICAgIDYsXHJcbiAgICAgMjQsXHJcbiAgICAgNDgsXHJcbiAgICAgNzIsXHJcbiAgICAxMTQsXHJcbiAgICAxNjgsXHJcbiAgICAyMDQsXHJcbiAgICAyNDAsXHJcbiAgICAzMDAsXHJcbiAgICA3NTAsXHJcbiAgIDE1MDAsXHJcbiAgIDI0MDAsXHJcbiAgIDMwMDAsXHJcbiAgIDkwMDAsXHJcbiAgMTUwMDAsXHJcbiAgMjQwMDAsXHJcbl0ubWFwKFxyXG4gIG1zID0+IGdldE11bHRpcGxpZXIoQVNZTVBUT1RFLCBtcyAvIE1TX1BFUl9BRFNSX1RJQ0spXHJcbik7XHJcblxyXG5sZXQgc3RhdGU7XHJcblxyXG4vLyBCb3VuZCBieSBhdHRhY2hcclxubGV0IHJlZ1dyaXRlVG9Ib3N0ID0gKCkgPT4ge307XHJcbmxldCBzZXRWb2x1bWVUb0hvc3QgPSAoKSA9PiB7fTtcclxuXHJcbmZ1bmN0aW9uIHRvQnJpZGdlKGFkc3IpIHtcclxuICAvLyBTYW5pdHktY2hlY2tpbmcgYXNzZXJ0aW9uc1xyXG4gIGlmIChcclxuICAgIChhZHNyLnZvaWNlICE9PSAwKSAmJlxyXG4gICAgKGFkc3Iudm9pY2UgIT09IDEpICYmXHJcbiAgICAoYWRzci52b2ljZSAhPT0gMilcclxuICApIGRlYnVnZ2VyO1xyXG5cclxuICBpZiAoYWRzci52YWx1ZSAhPT0gYWRzci52YWx1ZSkgZGVidWdnZXI7XHJcblxyXG4gIHNldFZvbHVtZVRvSG9zdChhZHNyLnZvaWNlLCBhZHNyLnZhbHVlKTtcclxufVxyXG5cclxuXHJcbmNvbnN0IGluaXRpYWxBZHNyID0ge1xyXG4gIHBoYXNlOiBcIm9mZlwiLFxyXG4gIHZhbHVlOiAwLFxyXG5cclxuICBjdXJ2ZVNjYWxlOiAxLFxyXG4gIG11bHRpcGxpZXI6IDAsXHJcblxyXG4gIGF0dGFja0R1cmF0aW9uOiAwLFxyXG4gIGRlY2F5RHVyYXRpb246IDAsXHJcbiAgc3VzdGFpblZvbHVtZTogMCxcclxuICByZWxlYXNlRHVyYXRpb246IDAsXHJcbn07XHJcblxyXG5mdW5jdGlvbiByZXNldCgpIHtcclxuICBzdGF0ZSA9IHtcclxuICAgIHJlZ3M6IG5ldyBVaW50OEFycmF5KDB4MjApLFxyXG4gICAgYWRzcjogW1xyXG4gICAgICB7IC4uLmluaXRpYWxBZHNyLCB2b2ljZTogMCB9LFxyXG4gICAgICB7IC4uLmluaXRpYWxBZHNyLCB2b2ljZTogMSB9LFxyXG4gICAgICB7IC4uLmluaXRpYWxBZHNyLCB2b2ljZTogMiB9LFxyXG4gICAgXSxcclxuICAgIGN5Y2xlc1VudGlsQWRzclRpY2s6IENZQ0xFU19QRVJfQURTUl9USUNLLFxyXG4gIH07XHJcblxyXG4gIC8vIFRPRE86IHNob3VsZCB3ZSB0ZWxsIHRoZSBicmlkZ2UgdG8gcmVzZXQgdGhpbmdzIHRvbywgb3Igc2hvdWxkIHdlXHJcbiAgLy8gcmVseSBvbiB0aGUgYnJpZGdlIGdldHRpbmcgaXRzIG93biByZXNldD9cclxufVxyXG5cclxuZnVuY3Rpb24gdGlja19hZHNyKGFkc3IpIHtcclxuXHJcbiAgLy8gTmFOIGF1ZGl0aW5nXHJcbiAgaWYgKGFkc3IudmFsdWUgIT09IGFkc3IudmFsdWUpIGRlYnVnZ2VyO1xyXG5cclxuICBzd2l0Y2ggKGFkc3IucGhhc2UpIHtcclxuXHJcbiAgICBjYXNlIFwib2ZmXCI6XHJcbiAgICAgIC8vIERvIG5vdGhpbmdcclxuICAgICAgLy8gdG9CcmlkZ2UoYWRzcik7ICAgICAvLyBKVVNUIEZPUiBJTExVU1RSQVRJT05cclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgY2FzZSBcImF0dGFja1wiOlxyXG4gICAgICB7XHJcbiAgICAgICAgbGV0IHZhbHVlO1xyXG5cclxuICAgICAgICAvLyBjdXJ2ZSBoZXJlIEkgdGhpbmsgaXMgYWx3YXlzIG9mZnNldCAwIHNjYWxlIDFcclxuXHJcbiAgICAgICAgdmFsdWUgPSBhZHNyLnZhbHVlO1xyXG5cclxuICAgICAgICB2YWx1ZSA9IDEgLSB2YWx1ZTtcclxuICAgICAgICB2YWx1ZSArPSAoQVNZTVBUT1RFIC0gMSk7XHJcblxyXG4gICAgICAgIHZhbHVlICo9IGFkc3IubXVsdGlwbGllcjtcclxuXHJcbiAgICAgICAgdmFsdWUgLT0gKEFTWU1QVE9URSAtIDEpO1xyXG4gICAgICAgIHZhbHVlID0gMSAtIHZhbHVlO1xyXG5cclxuICAgICAgICB2YWx1ZSA9IE1hdGgubWluKHZhbHVlLCAxKTtcclxuXHJcbiAgICAgICAgaWYgKHZhbHVlID09PSAxKSB7XHJcbiAgICAgICAgICBhZHNyLnBoYXNlID0gXCJkZWNheVwiO1xyXG4gICAgICAgICAgYWRzci5tdWx0aXBsaWVyID0gZGVjYXlNdWx0aXBsaWVyRm9yRHVyYXRpb25bYWRzci5kZWNheUR1cmF0aW9uXTtcclxuICAgICAgICAgIGFkc3IuY3VydmVPZmZzZXQgPSBhZHNyLnN1c3RhaW5Wb2x1bWU7XHJcbiAgICAgICAgICBhZHNyLmN1cnZlU2NhbGUgPSAxIC0gYWRzci5zdXN0YWluVm9sdW1lO1xyXG5cclxuICAgICAgICAgIGlmICghYWRzci5jdXJ2ZVNjYWxlKSBhZHNyLmN1cnZlU2NhbGUgPSAwLjAwMTsgLy8gVE9ETyEgVG8gYXZvaWQgYSBOYU4sIGJ1dC4uLlxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYWRzci52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRvQnJpZGdlKGFkc3IpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBicmVhaztcclxuXHJcbiAgICBjYXNlIFwiZGVjYXlcIjpcclxuICAgICAge1xyXG4gICAgICAgIGxldCB2YWx1ZTtcclxuXHJcbiAgICAgICAgdmFsdWUgPSBhZHNyLnZhbHVlO1xyXG5cclxuICAgICAgICAvLyBjdXJ2ZSBpczpcclxuICAgICAgICAvLyAgICBvZmZzZXQgPSBzdXN0YWluIHZvbHVtZSlcclxuICAgICAgICAvLyAgICBzY2FsZSAgPSAxIC0gc3VzdGFpbiB2b2x1bWVcclxuXHJcbiAgICAgICAgdmFsdWUgLT0gYWRzci5jdXJ2ZU9mZnNldDtcclxuICAgICAgICB2YWx1ZSAvPSBhZHNyLmN1cnZlU2NhbGU7XHJcbiAgICAgICAgdmFsdWUgKz0gKEFTWU1QVE9URSAtIDEpO1xyXG4gICAgICAgIHZhbHVlICo9IGFkc3IubXVsdGlwbGllcjtcclxuICAgICAgICB2YWx1ZSAtPSAoQVNZTVBUT1RFIC0gMSk7XHJcbiAgICAgICAgdmFsdWUgKj0gYWRzci5jdXJ2ZVNjYWxlO1xyXG4gICAgICAgIHZhbHVlICs9IGFkc3IuY3VydmVPZmZzZXQ7XHJcblxyXG4gICAgICAgIHZhbHVlID0gTWF0aC5tYXgodmFsdWUsIGFkc3IuY3VydmVPZmZzZXQpO1xyXG5cclxuICAgICAgICBpZiAodmFsdWUgPT09IGFkc3IuY3VydmVPZmZzZXQpIHtcclxuICAgICAgICAgIGFkc3IucGhhc2UgPSBcInN1c3RhaW5cIjtcclxuICAgICAgICAgIC8vIG5vIHBhcmFtZXRlcnMgbmVlZGVkIGZvciB0aGF0IG9uZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYWRzci52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwidmFsdWUgPVwiLCB2YWx1ZSk7XHJcbiAgICAgICAgdG9CcmlkZ2UoYWRzcik7XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgY2FzZSBcInN1c3RhaW5cIjpcclxuICAgICAgLy8gZG8gbm90aGluZ1xyXG4gICAgICAvLyB0b0JyaWRnZShhZHNyKTsgICAgIC8vIEpVU1QgRk9SIElMTFVTVFJBVElPTlxyXG4gICAgICBicmVhaztcclxuXHJcbiAgICBjYXNlIFwicmVsZWFzZVwiOlxyXG5cclxuICAgICAgLy8gY3VydmUgaXM6XHJcbiAgICAgIC8vICAgIG9mZnNldCA9IDBcclxuICAgICAgLy8gICAgc2NhbGUgID0gc3VzdGFpbiB2b2x1bWVcclxuXHJcbiAgICAgIHtcclxuICAgICAgICBsZXQgdmFsdWUgPSBhZHNyLnZhbHVlO1xyXG5cclxuICAgICAgICB2YWx1ZSAvPSBhZHNyLmN1cnZlU2NhbGU7XHJcbiAgICAgICAgdmFsdWUgKz0gKEFTWU1QVE9URSAtIDEpO1xyXG4gICAgICAgIHZhbHVlICo9IGFkc3IubXVsdGlwbGllcjtcclxuICAgICAgICB2YWx1ZSAtPSAoQVNZTVBUT1RFIC0gMSk7XHJcbiAgICAgICAgdmFsdWUgKj0gYWRzci5jdXJ2ZVNjYWxlO1xyXG5cclxuICAgICAgICB2YWx1ZSA9IE1hdGgubWF4KHZhbHVlLCAwKTsgICAgLy8gdGltZXMgdm9pY2UgdmFsdWVcclxuXHJcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgYWRzci5waGFzZSA9IFwib2ZmXCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhZHNyLnZhbHVlID0gdmFsdWU7XHJcblxyXG4gICAgICAgIHRvQnJpZGdlKGFkc3IpO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc3RvcChhZHNyKSB7XHJcbiAgYWRzci5waGFzZSA9IFwib2ZmXCI7XHJcbiAgYWRzci52YWx1ZSA9IDA7XHJcbiAgdG9CcmlkZ2UoYWRzcik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGtleW9uKGFkc3IpIHtcclxuICBhZHNyLnBoYXNlID0gXCJhdHRhY2tcIjtcclxuICBhZHNyLm11bHRpcGxpZXIgPSBhdHRhY2tNdWx0aXBsaWVyRm9yRHVyYXRpb25bYWRzci5hdHRhY2tEdXJhdGlvbl07XHJcblxyXG4gIHRpY2tfYWRzcihhZHNyKTtcclxuXHJcbiAgLy8gTGV0J3Mgbm90IHNldCB2YWx1ZS4gV2UgY291bGQgYmUgcHVtcGluZyBpdC5cclxuICAvLyB0b0JyaWRnZShhZHNyKTtcclxufVxyXG5cclxuZnVuY3Rpb24ga2V5b2ZmKGFkc3IpIHtcclxuICBhZHNyLnBoYXNlID0gXCJyZWxlYXNlXCI7XHJcbiAgYWRzci5tdWx0aXBsaWVyID0gZGVjYXlNdWx0aXBsaWVyRm9yRHVyYXRpb25bYWRzci5yZWxlYXNlRHVyYXRpb25dO1xyXG4gIGFkc3IuY3VydmVTY2FsZSA9IGFkc3Iuc3VzdGFpblZvbHVtZTtcclxuICBpZiAoIWFkc3IuY3VydmVTY2FsZSkgYWRzci5jdXJ2ZVNjYWxlID0gMC4wMDE7IC8vIFRPRE8hIFRvIGF2b2lkIGEgTmFOLCBidXQuLi5cclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHRpY2soKSB7XHJcblxyXG4gIGlmICghc3RhdGUuY3ljbGVzVW50aWxBZHNyVGljay0tKSB7XHJcbiAgICBzdGF0ZS5jeWNsZXNVbnRpbEFkc3JUaWNrID0gQ1lDTEVTX1BFUl9BRFNSX1RJQ0s7XHJcbiAgICB0aWNrX2Fkc3Ioc3RhdGUuYWRzclswXSk7XHJcbiAgICB0aWNrX2Fkc3Ioc3RhdGUuYWRzclsxXSk7XHJcbiAgICB0aWNrX2Fkc3Ioc3RhdGUuYWRzclsyXSk7XHJcblxyXG4gICAgLy8gZGlhZyhjNjQsIHN0YXRlKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWRfZDQwMF9kN2ZmKGFkZHIpIHtcclxuICBjb25zdCByZWcgPSBhZGRyICYgMHgxZjtcclxuXHJcbiAgc3dpdGNoIChyZWcpIHtcclxuXHJcbiAgICBjYXNlIDB4MTk6XHJcbiAgICBjYXNlIDB4MWE6XHJcbiAgICAgIHVuaW1wbGVtZW50ZWRXYXJuaW5nKFwicGFkZGxlc1wiKTtcclxuICAgICAgcmV0dXJuIDB4ZmY7IC8vIHZlcmlmaWVkXHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgMHgxYjpcclxuICAgICAgdW5pbXBsZW1lbnRlZFdhcm5pbmcoXCJ2b2ljZSAzIHdhdmVmb3JtIG91dHB1dFwiKTtcclxuICAgICAgLy8gV2UgY2FuJ3QgZ2l2ZSB0aGVtIHdhdmVmb3JtIGRhdGEsIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBpdC4gQnV0XHJcbiAgICAgIC8vIGNoYW5jZXMgYXJlIHRoZXkncmUgdXNpbmcgd2hpdGUgbm9pc2UgYXMgYSByYW5kb20gbnVtYmVyIGdlbmVyYXRvclxyXG4gICAgICAvLyAoZWcuIGZvciB0aGUgc21va2UtZmFkZXMgaW4gTWFzdGVyIG9mIHRoZSBMYW1wcycgdGl0bGUgc2NyZWVuKS4gU29cclxuICAgICAgLy8gbGV0J3MganVzdCBnaXZlIHJldHVybiByYW5kb20gbnVtYmVycy4uLlxyXG4gICAgICByZXR1cm4gKE1hdGgucmFuZG9tKCkgKiAyNTYpICYgMHhmZjtcclxuICAgICAgXHJcbiAgICBjYXNlIDB4MWM6XHJcbiAgICAgIHVuaW1wbGVtZW50ZWRXYXJuaW5nKFwidm9pY2UgMyBBRFNSIG91dHB1dFwiKTtcclxuICAgICAgYnJlYWs7XHJcbiAgfVxyXG5cclxuICAvLyBWZXJpZmllZCBvbiByZWFsIGhhcmR3YXJlIHRoYXQgeW91IHJlYWxseSBkbyBnZXQgemVybyBoZXJlXHJcbiAgcmV0dXJuIDB4MDA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdyaXRlX2Q0MDBfZDdmZihhZGRyLCBieXRlKSB7XHJcbiAgXHJcbiAgY29uc3QgcmVnID0gYWRkciAmIDB4MWY7XHJcbiAgY29uc3Qgdm9pY2UgPSBNYXRoLmZsb29yKHJlZyAvIDcpO1xyXG5cclxuICBzd2l0Y2ggKHJlZykge1xyXG5cclxuICAgIGNhc2UgMHgwNDogICAgICAvLyAkZDQwNDogVm9pY2UgMSBjb250cm9sIHJlZ2lzdGVyXHJcbiAgICBjYXNlIDB4MGI6ICAgICAgLy8gJGQ0MGI6IFZvaWNlIDIgY29udHJvbCByZWdpc3RlclxyXG4gICAgY2FzZSAweDEyOiAgICAgIC8vICRkNDEyOiBWb2ljZSAzIGNvbnRyb2wgcmVnaXN0ZXJcclxuICAgICAge1xyXG4gICAgICAgIGNvbnN0IGFkc3IgPSBzdGF0ZS5hZHNyW3ZvaWNlXTtcclxuXHJcbiAgICAgICAgaWYgKGJ5dGUgJiAweDgpIHtcclxuICAgICAgICAgIHN0b3AoYWRzcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgaWYgKGJ5dGUgJiAweDEpIGtleW9uKGFkc3IpO1xyXG4gICAgICAgICAgZWxzZSAgICAgICAgICAgIGtleW9mZihhZHNyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgY2FzZSAweDA1OiAgICAgIC8vICRkNDA1OiBWb2ljZSAxIGF0dGFjayBhbmQgZGVjYXkgbGVuZ3RoXHJcbiAgICBjYXNlIDB4MGM6ICAgICAgLy8gJGQ0MGM6IFZvaWNlIDIgYXR0YWNrIGFuZCBkZWNheSBsZW5ndGhcclxuICAgIGNhc2UgMHgxMzogICAgICAvLyAkZDQxMzogVm9pY2UgMyBhdHRhY2sgYW5kIGRlY2F5IGxlbmd0aFxyXG5cclxuICAgICAgLy8gRG8gd2UgZG8gdGhlc2U/IFllcywgd2UgZG8gdGhlc2UgYWxsIHRoZSB0aW1lLlxyXG4gICAgICAvLyBpZiAoc3RhdGUuYWRzclt2b2ljZV0ucGhhc2UgPT09IFwiYXR0YWNrXCIpIGRlYnVnZ2VyO1xyXG4gICAgICAvLyBpZiAoc3RhdGUuYWRzclt2b2ljZV0ucGhhc2UgPT09IFwiZGVjYXlcIikgZGVidWdnZXI7XHJcblxyXG4gICAgICAvLyBTdG9yZSBhcyBhIGNvZGVcclxuICAgICAgc3RhdGUuYWRzclt2b2ljZV0uIGRlY2F5RHVyYXRpb24gPSBieXRlICYgMHhmO1xyXG4gICAgICBzdGF0ZS5hZHNyW3ZvaWNlXS5hdHRhY2tEdXJhdGlvbiA9IGJ5dGUgPj4gNDtcclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgY2FzZSAweDA2OiAgICAgIC8vICRkNDA2OiBWb2ljZSAxIHN1c3RhaW4gdm9sdW1lIGFuZCByZWxlYXNlIGxlbmd0aFxyXG4gICAgY2FzZSAweDBkOiAgICAgIC8vICRkNDBkOiBWb2ljZSAyIHN1c3RhaW4gdm9sdW1lIGFuZCByZWxlYXNlIGxlbmd0aFxyXG4gICAgY2FzZSAweDE0OiAgICAgIC8vICRkNDE0OiBWb2ljZSAzIHN1c3RhaW4gdm9sdW1lIGFuZCByZWxlYXNlIGxlbmd0aFxyXG5cclxuICAgICAgLy8gU3RvcmUgYXMgYSBjb2RlXHJcbiAgICAgIHN0YXRlLmFkc3Jbdm9pY2VdLnJlbGVhc2VEdXJhdGlvbiA9IGJ5dGUgJiAweGY7XHJcblxyXG4gICAgICAvLyBTdG9yZSBhcyBhIHJhdGlvXHJcbiAgICAgIHN0YXRlLmFkc3Jbdm9pY2VdLnN1c3RhaW5Wb2x1bWUgPSAoYnl0ZSA+PiA0KSAvIDE1O1xyXG4gICAgICBicmVhaztcclxuXHJcbiAgICBjYXNlIDB4MTg6ICAgICAgLy8gJGQ0MTQ6IE1hc3RlciB2b2x1bWUsIGZpbHRlciBtb2Rlcywgdm9pY2UgMyBkaXNhYmxlXHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgMHgxYjogICAgICAvLyAkZDQxYjogVm9pY2UgMyB3YXZlZm9ybSBvdXRwdXRcclxuICAgIGNhc2UgMHgxYzogICAgICAvLyAkZDQxYjogVm9pY2UgMyBBRFNSIG91dHB1dFxyXG4gICAgICBicmVhaztcclxuICB9XHJcblxyXG4gIHN0YXRlLnJlZ3NbcmVnXSA9IGJ5dGU7XHJcbiAgcmVnV3JpdGVUb0hvc3QocmVnLCBieXRlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2VyaWFsaXplKCkge1xyXG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlc2VyaWFsaXplKGpzb24pIHtcclxuICBzdGF0ZSA9IEpTT04ucGFyc2UoanNvbik7XHJcblxyXG4gIC8vIFRoaXMgaGFzIG5vdCBiZWVuIGNhcmVmdWxseSBjb25zaWRlcmVkLCBidXQsIGRhcmUgSSBzYXkgaXQsIHNlZW1zIHRvIHdvcmsuXHJcbiAgLy8gVGhlIHJ1bmxvb3AncyByZXNldCBmdW5jdGlvbiBkb2Vzbid0IGN1cnJlbnRseSByZXNldCBhbGwgb2YgdGhlIGhvc3RcclxuICAvLyBkZXZpY2VzLiBTaG91bGQgaXQ/XHJcbiAgZm9yIChsZXQgcmVnID0gMDsgcmVnIDw9IDB4MTg7IHJlZysrKSB7XHJcbiAgICByZWdXcml0ZVRvSG9zdChyZWcsIHN0YXRlLnJlZ3NbcmVnXSk7XHJcbiAgfVxyXG5cclxuICB0b0JyaWRnZShzdGF0ZS5hZHNyWzBdKTtcclxuICB0b0JyaWRnZShzdGF0ZS5hZHNyWzFdKTtcclxuICB0b0JyaWRnZShzdGF0ZS5hZHNyWzJdKTtcclxufVxyXG5cclxuLy8gaG9va3Vwcy4uLlxyXG5cclxubGV0IGM2NDtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhdHRhY2gobmFzY2VudEM2NCkge1xyXG4gIGM2NCA9IG5hc2NlbnRDNjQ7XHJcblxyXG4gIHJlZ1dyaXRlVG9Ib3N0ICA9IGM2NC5hdWRpby5vblJlZ1dyaXRlO1xyXG4gIHNldFZvbHVtZVRvSG9zdCA9IGM2NC5hdWRpby5zZXRWb2ljZVZvbHVtZTtcclxuXHJcbiAgYzY0LnNpZCA9IHtcclxuICAgIC8vIENvbnRyb2xcclxuICAgIHRpY2ssXHJcbiAgICByZXNldCxcclxuICAgIHNlcmlhbGl6ZSxcclxuICAgIGRlc2VyaWFsaXplLFxyXG4gICAgLy8gTU1JT1xyXG4gICAgcmVhZF9kNDAwX2Q3ZmYsXHJcbiAgICB3cml0ZV9kNDAwX2Q3ZmYsXHJcbiAgfTtcclxuXHJcbiAgcmVzZXQoKTtcclxufVxyXG4iLCIvKlxyXG4gICBGb3IgZGVidWdnaW5nIG9ubHkgLSBwcmludHMsIGludG8gQzY0IHNjcmVlbiBtZW1vcnksIGRpYWdub3N0aWMgaW5mbyBhYm91dFxyXG4gICB3aGF0IHRoZSB2aXJ0dWFsIFNJRCBpcyBkb2luZy5cclxuKi9cclxuXHJcbmltcG9ydCB7XHJcbiAgY2hhclRvQzY0Rm9udENvZGVQb2ludCxcclxuICBoZXhEaWdpdFRvQzY0Rm9udENvZGVQb2ludFxyXG59IGZyb20gXCIuLi90b29scy9jNjRGb250Q29kZVBvaW50c1wiO1xyXG5cclxuY29uc3QgICAgTEVGVF9DT0xVTU4gPSA3O1xyXG5jb25zdCBST1dTX1BFUl9WT0lDRSA9IDc7XHJcblxyXG5jb25zdCAgICBGUkVRX1JPVyA9IDE7XHJcbmNvbnN0ICAgICBQV01fUk9XID0gMTtcclxuY29uc3QgQ09OVFJPTF9ST1cgPSAyO1xyXG5jb25zdCAgICBBRFNSX1JPVyA9IDM7XHJcbmNvbnN0ICAgICBCQVJfUk9XID0gNTtcclxuXHJcbmNvbnN0ICBGSUxURVJfUk9XID0gMjE7XHJcbmNvbnN0ICBWT0xVTUVfUk9XID0gMjI7XHJcblxyXG5jb25zdCBzZXEgPSBbXHJcbiAgMHgyMCwgICAgICAgICAvLyBzcGFjZVxyXG4gIDB4NjUsICAgICAgICAgLy8gMiBsZWZ0XHJcbiAgMHg2MSwgICAgICAgICAvLyBldmVuXHJcbiAgMHg2NyB8IDB4ODAsICAvLyAyIHJpZ2h0LCBpbnZlcnRlZFxyXG5dO1xyXG5cclxubGV0IGdldFJ1bmxvb3BTdGF0ZTtcclxubGV0IGNwdVdyaXRlO1xyXG5sZXQgc3RhdGU7XHJcblxyXG5mdW5jdGlvbiB3cml0ZUNoYXIocm93LCBjb2wsIGNoYXIpIHtcclxuICBjb25zdCBvZmZzZXQgPSAocm93ICogNDApICsgY29sO1xyXG5cclxuICBjcHVXcml0ZSggMHg0MDAgKyBvZmZzZXQsIGNoYXIpO1xyXG4gIGNwdVdyaXRlKDB4ZDgwMCArIG9mZnNldCwgMSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdyaXRlWChyb3csIGNvbCwgbnliYmxlKSB7XHJcbiAgd3JpdGVDaGFyKHJvdywgY29sLCBoZXhEaWdpdFRvQzY0Rm9udENvZGVQb2ludFtueWJibGVdKTtcclxufVxyXG5cclxuZnVuY3Rpb24gd3JpdGVYeChyb3csIGNvbCwgYnl0ZSkge1xyXG4gIHdyaXRlQ2hhcihyb3csIGNvbCArIDAsIGhleERpZ2l0VG9DNjRGb250Q29kZVBvaW50W2J5dGUgPj4gNF0pO1xyXG4gIHdyaXRlQ2hhcihyb3csIGNvbCArIDEsIGhleERpZ2l0VG9DNjRGb250Q29kZVBvaW50W2J5dGUgJiAweGZdKTtcclxufVxyXG5cclxuZnVuY3Rpb24gd3JpdGVTdHIocm93LCBjb2wsIHN0cikge1xyXG4gIHN0ciA9IHN0ci50b1VwcGVyQ2FzZSgpO1xyXG5cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xyXG4gICAgd3JpdGVDaGFyKHJvdywgY29sICsgaSwgc3RyLmNoYXJDb2RlQXQoaSkgLSAweDQwKVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gd3JpdGVCaXQocm93LCBjb2wsIGNoYXIsIGNvbmRpdGlvbikge1xyXG4gIHdyaXRlQ2hhcihyb3csIGNvbCwgY2hhclRvQzY0Rm9udENvZGVQb2ludChjaGFyKSArIChjb25kaXRpb24gPyAweDgwIDogMCkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzaG93QWRzclN0YXRlKHZvaWNlKSB7XHJcbiAgY29uc3Qgcm93ID0gQURTUl9ST1cgKyAodm9pY2UgKiBST1dTX1BFUl9WT0lDRSk7XHJcbiAgY29uc3QgcGhhc2UgPSBzdGF0ZS5hZHNyW3ZvaWNlXS5waGFzZTtcclxuXHJcbiAgd3JpdGVCaXQocm93LCBMRUZUX0NPTFVNTiAtIDUgKyAwLCBcImFcIiwgcGhhc2UgPT09IFwiYXR0YWNrXCIgKTtcclxuICB3cml0ZUJpdChyb3csIExFRlRfQ09MVU1OIC0gNSArIDEsIFwiZFwiLCBwaGFzZSA9PT0gXCJkZWNheVwiICApO1xyXG4gIHdyaXRlQml0KHJvdywgTEVGVF9DT0xVTU4gLSA1ICsgMiwgXCJzXCIsIHBoYXNlID09PSBcInN1c3RhaW5cIik7XHJcbiAgd3JpdGVCaXQocm93LCBMRUZUX0NPTFVNTiAtIDUgKyAzLCBcInJcIiwgcGhhc2UgPT09IFwicmVsZWFzZVwiKTtcclxuXHJcbiAgY29uc3QgYWQgPSBzdGF0ZS5yZWdzWyh2b2ljZSAqIDcpICsgNV07XHJcbiAgY29uc3Qgc3IgPSBzdGF0ZS5yZWdzWyh2b2ljZSAqIDcpICsgNl07XHJcblxyXG4gIHdyaXRlWChyb3csIExFRlRfQ09MVU1OICsgMCwgYWQgPj4gNCk7XHJcbiAgd3JpdGVYKHJvdywgTEVGVF9DT0xVTU4gKyAxLCBhZCAmIDB4Zik7XHJcblxyXG4gIHdyaXRlWChyb3csIExFRlRfQ09MVU1OICsgMiwgc3IgPj4gNCk7XHJcbiAgd3JpdGVYKHJvdywgTEVGVF9DT0xVTU4gKyAzLCBzciAmIDB4Zik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVudmVsb3BlQmFyKHZvaWNlKSB7XHJcbiAgY29uc3Qgcm93ID0gQkFSX1JPVyArICh2b2ljZSAqIFJPV1NfUEVSX1ZPSUNFKTtcclxuICBjb25zdCBsZW5ndGggPSBNYXRoLmZsb29yKHN0YXRlLmFkc3Jbdm9pY2VdLnZhbHVlICogNDApO1xyXG5cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IDQwOyBpKyspIHtcclxuICAgIHdyaXRlQ2hhcihyb3csIGksIDB4MjAgKyAoaSA8IGxlbmd0aCA/IDB4ODAgOiAwKSk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBzdWJDaGFyID0gKHN0YXRlLmFkc3Jbdm9pY2VdLnZhbHVlICogNDApIC0gbGVuZ3RoO1xyXG5cclxuICBpZiAoc3ViQ2hhcikge1xyXG4gICAgd3JpdGVDaGFyKHJvdywgbGVuZ3RoLCBzZXFbTWF0aC5mbG9vcihzdWJDaGFyICogc2VxLmxlbmd0aCldKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNob3dGcmVxKHZvaWNlKSB7XHJcbiAgY29uc3Qgcm93ID0gRlJFUV9ST1cgKyAoUk9XU19QRVJfVk9JQ0UgKiB2b2ljZSk7XHJcblxyXG4gIHdyaXRlU3RyKHJvdywgTEVGVF9DT0xVTU4gLSA1LCBcImZyZXFcIik7XHJcbiAgd3JpdGVYeCAocm93LCBMRUZUX0NPTFVNTiArIDAsIHN0YXRlLnJlZ3NbKHZvaWNlICogNykgKyAxXSk7XHJcbiAgd3JpdGVYeCAocm93LCBMRUZUX0NPTFVNTiArIDIsIHN0YXRlLnJlZ3NbKHZvaWNlICogNykgKyAwXSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNob3dQd20odm9pY2UpIHtcclxuICBjb25zdCByb3cgPSBQV01fUk9XICsgKFJPV1NfUEVSX1ZPSUNFICogdm9pY2UpO1xyXG5cclxuICB3cml0ZVN0cihyb3csMjAsIFwicHdtXCIpO1xyXG4gIHdyaXRlWHgocm93LCAyNSwgc3RhdGUucmVnc1sodm9pY2UgKiA3KSArIDNdKTtcclxuICB3cml0ZVh4KHJvdywgMjcsIHN0YXRlLnJlZ3NbKHZvaWNlICogNykgKyAyXSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNob3dDb250cm9sKHZvaWNlKSB7XHJcbiAgY29uc3Qgcm93ID0gQ09OVFJPTF9ST1cgKyAoUk9XU19QRVJfVk9JQ0UgKiB2b2ljZSk7XHJcbiAgY29uc3QgYnl0ZSA9IHN0YXRlLnJlZ3NbKHZvaWNlICogNykgKyA0XTtcclxuXHJcbiAgd3JpdGVTdHIocm93LCBMRUZUX0NPTFVNTiAtIDUsIFwiY3RybFwiKTtcclxuXHJcbiAgd3JpdGVCaXQocm93LCBMRUZUX0NPTFVNTiArIDAsICBcIlZcIiwgYnl0ZSAmIDB4MDEpO1xyXG4gIHdyaXRlQml0KHJvdywgTEVGVF9DT0xVTU4gKyAyLCAgXCJTXCIsIGJ5dGUgJiAweDAyKTtcclxuICB3cml0ZUJpdChyb3csIExFRlRfQ09MVU1OICsgMywgIFwiUlwiLCBieXRlICYgMHgwNCk7XHJcbiAgd3JpdGVCaXQocm93LCBMRUZUX0NPTFVNTiArIDUsICBcIkRcIiwgYnl0ZSAmIDB4MDgpO1xyXG4gIHdyaXRlQml0KHJvdywgTEVGVF9DT0xVTU4gKyA3LCAgXCJUXCIsIGJ5dGUgJiAweDEwKTtcclxuICB3cml0ZUJpdChyb3csIExFRlRfQ09MVU1OICsgOCwgIFwiU1wiLCBieXRlICYgMHgyMCk7XHJcbiAgd3JpdGVCaXQocm93LCBMRUZUX0NPTFVNTiArIDksICBcIlJcIiwgYnl0ZSAmIDB4NDApO1xyXG4gIHdyaXRlQml0KHJvdywgTEVGVF9DT0xVTU4gKyAxMCwgXCJOXCIsIGJ5dGUgJiAweDgwKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2hvd0ZpbHRlcigpIHtcclxuICBjb25zdCByb3cgPSBGSUxURVJfUk9XO1xyXG4gIGNvbnN0IGQ0MTcgPSBzdGF0ZS5yZWdzWzB4MTddO1xyXG4gIGNvbnN0IGQ0MTggPSBzdGF0ZS5yZWdzWzB4MThdO1xyXG5cclxuICB3cml0ZVN0cihyb3csIExFRlRfQ09MVU1OIC0gNSwgXCJmbHRyXCIpO1xyXG5cclxuICB3cml0ZUJpdChyb3csIExFRlRfQ09MVU1OICsgMCwgXCIxXCIsIGQ0MTcgJiAweDAxKTtcclxuICB3cml0ZUJpdChyb3csIExFRlRfQ09MVU1OICsgMSwgXCIyXCIsIGQ0MTcgJiAweDAyKTtcclxuICB3cml0ZUJpdChyb3csIExFRlRfQ09MVU1OICsgMiwgXCIzXCIsIGQ0MTcgJiAweDA0KTtcclxuICB3cml0ZUJpdChyb3csIExFRlRfQ09MVU1OICsgMywgXCJFXCIsIGQ0MTcgJiAweDA4KTtcclxuXHJcbiAgLy8gUmVzb25hbmNlXHJcbiAgd3JpdGVYKHJvdywgTEVGVF9DT0xVTU4gKyA1LCBkNDE3ID4+IDQpO1xyXG5cclxuICB3cml0ZUJpdChyb3csIExFRlRfQ09MVU1OICsgNywgIFwiTFwiLCBkNDE4ICYgMHgxMCk7XHJcbiAgd3JpdGVCaXQocm93LCBMRUZUX0NPTFVNTiArIDgsICBcIkJcIiwgZDQxOCAmIDB4MjApO1xyXG4gIHdyaXRlQml0KHJvdywgTEVGVF9DT0xVTU4gKyA5LCAgXCJIXCIsIGQ0MTggJiAweDQwKTtcclxuICB3cml0ZUJpdChyb3csIExFRlRfQ09MVU1OICsgMTAsIFwiM1wiLCBkNDE4ICYgMHg4MCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNob3dWb2x1bWUoKSB7XHJcbiAgY29uc3Qgcm93ID0gVk9MVU1FX1JPVztcclxuICBjb25zdCBkNDE4ID0gc3RhdGUucmVnc1sweDE4XTtcclxuXHJcbiAgd3JpdGVTdHIocm93LCBMRUZUX0NPTFVNTiAtIDQsIFwidm9sXCIpO1xyXG4gIHdyaXRlWCAgKHJvdywgTEVGVF9DT0xVTU4gKyAwLCBkNDE4ICYgMHhmKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2hvd0N5Y2xlKCkge1xyXG4gIGNvbnN0IGN5Y2xlU3RyID0gU3RyaW5nKGdldFJ1bmxvb3BTdGF0ZSgpLmN5Y2xlKTtcclxuXHJcbiAgQXJyYXkuZnJvbShjeWNsZVN0cikuZm9yRWFjaChcclxuICAgIChkaWdpdCwgaW5kZXgpID0+IHtcclxuICAgICAgd3JpdGVDaGFyKDIzLCAzOSAtIGN5Y2xlU3RyLmxlbmd0aCArIGluZGV4LCBjaGFyVG9DNjRGb250Q29kZVBvaW50KGRpZ2l0KSk7XHJcbiAgICB9XHJcbiAgKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRpYWcoYzY0LCBzaWRTdGF0ZSkge1xyXG4gIGdldFJ1bmxvb3BTdGF0ZSA9IGM2NC5ydW5sb29wLmdldFN0YXRlO1xyXG4gIGNwdVdyaXRlICAgICAgICA9IGM2NC53aXJlcy5jcHVXcml0ZTtcclxuICBzdGF0ZSAgICAgICAgICAgPSBzaWRTdGF0ZTtcclxuXHJcbiAgLy8gQ2xlYXIgdGhlIHNjcmVlblxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwMDsgaSsrKSB7XHJcbiAgICBjcHVXcml0ZSgweDQwMCArIGksIDB4MjApO1xyXG4gIH1cclxuXHJcbiAgLy8gUGVyLXZvaWNlIHJlZ2lzdGVyc1xyXG4gIGZvciAobGV0IHZvaWNlID0gMDsgdm9pY2UgPCAzOyB2b2ljZSsrKSB7XHJcbiAgICBlbnZlbG9wZUJhcih2b2ljZSk7XHJcbiAgICBzaG93QWRzclN0YXRlKHZvaWNlKTtcclxuICAgIHNob3dGcmVxKHZvaWNlKTtcclxuICAgIHNob3dQd20odm9pY2UpO1xyXG4gICAgc2hvd0NvbnRyb2wodm9pY2UpO1xyXG4gIH1cclxuXHJcbiAgLy8gU0lELXdpZGUgcmVnaXN0ZXJzXHJcbiAgc2hvd0ZpbHRlcigpO1xyXG4gIHNob3dWb2x1bWUoKTtcclxuICBzaG93Q3ljbGUoKTtcclxufVxyXG4iLCIvKlxyXG4gICB0YXBlOiBlbXVsYXRlcyBhIDE1MzAgJ0RhdGFzZXR0ZScgY2Fzc2V0dGUgZGVja1xyXG5cclxuICAgQmFzaWNhbGx5IGp1c3QgZmVlZHMgLnRhcCBmaWxlIGZvcm1hdCBkYXRhIGludG8gdGhlIENJQTEuIERvZXMgbm90IHN1cHBvcnRcclxuICAgc2F2aW5nLlxyXG5cclxuICAgUmVmZXJlbmNlczpcclxuXHJcbiAgIC0gaHR0cDovL3dhdi1wcmcuc291cmNlZm9yZ2UubmV0L3RhcGUuaHRtbFxyXG4gICAtIGh0dHA6Ly91bnVzZWRpbm8uZGUvZWM2NC90ZWNobmljYWwvZm9ybWF0cy90YXAuaHRtbFxyXG4qL1xyXG5cclxuXHJcbi8vIEJvdW5kIGJ5IGF0dGFjaFxyXG5sZXQgcmFpc2VUYXBlSW50ZXJydXB0O1xyXG5sZXQgYzY0OyAvLyBidXQgZG8gd2UgbmVlZCBpdD9cclxuXHJcbmxldCBzdGF0ZTtcclxuXHJcbmZ1bmN0aW9uIHNldFRhcGVNb3Rvcihpc09uKSB7XHJcbiAgc3RhdGUubW90b3JFbmFibGVkID0gaXNPbjtcclxufVxyXG5cclxuZnVuY3Rpb24gc2NoZWR1bGVOZXh0SW50ZXJydXB0KCkge1xyXG4gIC8vIFdlJ3JlIHVzaW5nIHRoZSAudGFwIGZpbGUgZm9ybWF0IGFzLWlzIHRvIHBlZWwgb2ZmIHRoZSBpbnRlcnJ1cHQgdGltaW5ncy5cclxuICAvLyAoTWludXMgdGhlIGhlYWRlciwgd2hpY2ggZ290IHN0cmlwcGVkIG9mZiBieSB0aGUgaW5nZXN0b3IpXHJcblxyXG4gIC8vIFRPRE86IGJvdW5kcyBjaGVjayBmb3IgdGhlIGltYWdlXHJcbiAgY29uc3QgdmFsID0gc3RhdGUuaW1hZ2Vbc3RhdGUuaW1hZ2VPZmZzZXQrK107XHJcblxyXG4gIGlmICh2YWwgPT09IDApIHtcclxuICAgIHN0YXRlLnRpY2tzVW50aWxJbnRlcnJ1cHQgID0gc3RhdGUuaW1hZ2Vbc3RhdGUuaW1hZ2VPZmZzZXQrK107XHJcbiAgICBzdGF0ZS50aWNrc1VudGlsSW50ZXJydXB0IHw9IHN0YXRlLmltYWdlW3N0YXRlLmltYWdlT2Zmc2V0KytdIDw8IDg7XHJcbiAgICBzdGF0ZS50aWNrc1VudGlsSW50ZXJydXB0IHw9IHN0YXRlLmltYWdlW3N0YXRlLmltYWdlT2Zmc2V0KytdIDw8IDE2O1xyXG4gIH1cclxuXHJcbiAgZWxzZSBzdGF0ZS50aWNrc1VudGlsSW50ZXJydXB0ID0gdmFsICogODtcclxufVxyXG5cclxuZnVuY3Rpb24gdGljaygpIHtcclxuICBpZiAoc3RhdGUucGxheVByZXNzZWQgJiYgc3RhdGUubW90b3JFbmFibGVkKSB7XHJcblxyXG4gICAgaWYgKHN0YXRlLnRpY2tzVW50aWxJbnRlcnJ1cHQpIHN0YXRlLnRpY2tzVW50aWxJbnRlcnJ1cHQtLTtcclxuICAgIGVsc2Uge1xyXG4gICAgICByYWlzZVRhcGVJbnRlcnJ1cHQoKTtcclxuICAgICAgc2NoZWR1bGVOZXh0SW50ZXJydXB0KCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGF0dGFjaChuYXNjZW50QzY0KSB7XHJcbiAgYzY0ID0gbmFzY2VudEM2NDtcclxuICByYWlzZVRhcGVJbnRlcnJ1cHQgPSBjNjQud2lyZXMucmFpc2VUYXBlSW50ZXJydXB0O1xyXG5cclxuICByZXNldCgpO1xyXG5cclxuICBjNjQudGFwZSA9IHtcclxuICAgIC8vIENvbnRyb2xcclxuICAgIHRpY2ssXHJcbiAgICByZXNldCxcclxuICAgIHNlcmlhbGl6ZSxcclxuICAgIGRlc2VyaWFsaXplLFxyXG4gICAgLy8gVE9ETzogd2hhdCBkaWQgd2UgY2FsbCB0aGlzIHNlY3Rpb24gYWdhaW4/XHJcbiAgICBzZXRUYXBlTW90b3IsXHJcbiAgICBpc0FueUJ1dHRvblByZXNzZWQsXHJcblxyXG4gICAgc2V0SW1hZ2UsXHJcbiAgICBwcmVzc1BsYXksXHJcbiAgICBwcmVzc1N0b3AsXHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVzZXQoKSB7XHJcbiAgc3RhdGUgPSB7XHJcbiAgICB0aWNrc1VudGlsSW50ZXJydXB0OiBJbmZpbml0eSxcclxuICAgIGltYWdlOiBudWxsLFxyXG4gICAgaW1hZ2VPZmZzZXQ6IDAsXHJcbiAgICBwbGF5UHJlc3NlZDogZmFsc2UsXHJcbiAgICBtb3RvckVuYWJsZWQ6IGZhbHNlLFxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcclxuICAvLyBUT0RPXHJcbiAgLy8gKElmIHRoaXMgZ2V0cyBzdXBwb3J0ZWQgaW4gZnV0dXJlLCBleHBlY3QgdGhlIHNuYXBzaG90IGZpbGVzIHRvIGdldCBodWdlKVxyXG59XHJcblxyXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZSgpIHtcclxuICAvLyBUT0RPXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzQW55QnV0dG9uUHJlc3NlZCgpIHtcclxuICByZXR1cm4gc3RhdGUucGxheVByZXNzZWQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldEltYWdlKGJ5dGVzKSB7XHJcbiAgc3RhdGUuaW1hZ2UgPSBieXRlcztcclxuICBzdGF0ZS5pbWFnZU9mZnNldCA9IDA7XHJcblxyXG4gIC8vIFNjaGVkdWxlIGFuIGludGVycnVwdDsgaXQgd29uJ3QgYWN0dWFsbHkgaGFwcGVuIHVubGVzcyB0aGUgcGxheSBidXR0b24nc1xyXG4gIC8vIHByZXNzZWQgYW5kIHRoZSBtb3RvcidzIGVuYWJsZWQuXHJcbiAgc2NoZWR1bGVOZXh0SW50ZXJydXB0KCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByZXNzUGxheSgpIHtcclxuICBzdGF0ZS5wbGF5UHJlc3NlZCA9IHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByZXNzU3RvcCgpIHtcclxuICBzdGF0ZS5wbGF5UHJlc3NlZCA9IGZhbHNlO1xyXG59XHJcbiIsIi8qXHJcbiAgIHZpYzogZW11bGF0ZXMgdGhlIDY1NjkgKFZJQy1JSTsgUEFMKSBncmFwaGljcyBwcm9jZXNzb3JcclxuXHJcbiAgIC4uLmEgYmlnIHByb29mLW9mLWNvbmNlcHQgdGhhdCBncmV3IHRvIGVuY29tcGFzcyBhbGwgb2YgdGhlIGNoaXAnc1xyXG4gICBmdW5jdGlvbmFsaXR5LCBhbmQgcmVhbGx5IG5lZWRzIHRvIGJlIHJlLWRvbmUuIEluIHBhcnRpY3VsYXIsIGl0cyB0aW1pbmdcclxuICAgaXMganVzdCBwbGFjZWhvbGRlciwgYW5kIGl0IGRvZXNuJ3QgdHJ5IHN0dW4gdGhlIENQVSBmb3IgYmFkIGxpbmVzICh0aGUgQkFcclxuICAgbGluZSkgc28gcmFzdGVyLXN0YWJsZSByb3V0aW5lcyBhcmVuJ3QgZ29pbmcgdG8gd29yaywgdG8gc2F5IG5vdGhpbmcgb2ZcclxuICAgdHJpY2tzIGxpa2UgRE1BIGRlbGF5LlxyXG5cclxuICAgKFdlJ3JlIGEgbGl0dGxlIGxvb3NlIHdpdGggdGVybWlub2xvZ3kgdG9vKVxyXG5cclxuICAgVGhlIFZpYyBzaW11bGF0aW9uIHRha2VzIGJ5IGZhciB0aGUgYnVsayBvZiB0aGUgZW11bGF0aW9uIHRpbWUsIHdoaWNoIHdlJ2RcclxuICAgZXhwZWN0IGdpdmVuIGhvdyBtdWNoIHdvcmsgaXQgZG9lcyBjb21wYXJlZCB0byB0aGUgQ1BVLiBCdXQgc3RpbGwsIGl0J3MgcmlwZVxyXG4gICBmb3Igb3B0aW1pemF0aW9uLlxyXG5cclxuICAgUmVmZXJlbmNlczpcclxuXHJcbiAgIOKAoDEgaHR0cDovL3d3dy56aW1tZXJzLm5ldC9jYm1waWNzL2NibS9jNjQvdmljLWlpLnR4dFxyXG4gICDigKAyIHN0YTY0IG1lbW9yeSBtYXA6IGh0dHBzOi8vc3RhLmM2NC5vcmcvY2JtNjRtZW0uaHRtbFxyXG4gICAgLSBodHRwOi8vdW51c2VkaW5vLmRlL2VjNjQvdGVjaG5pY2FsL3Byb2plY3Q2NC9tYXBwaW5nX2M2NC5odG1sIFxyXG4qL1xyXG5cclxuaW1wb3J0IHsgJHh4LCAkeHh4eCwgdW5pbXBsZW1lbnRlZFdhcm5pbmcgfSBmcm9tIFwiLi4vZGVidWdcIjtcclxuaW1wb3J0IHtcclxuICBzeXN0ZW1QYWxldHRlLFxyXG4gIGdyYXlzY2FsZVBhbGV0dGUsXHJcbiAgaGlnaGxpZ2h0UGFsZXR0ZXMsXHJcbiAgY29sb3JDb2xvclBhbGV0dGVzXHJcbn0gZnJvbSBcIi4uL3Rvb2xzL3BhbGV0dGVzXCI7XHJcblxyXG4vLyBCb3VuZCBieSBhdHRhY2hcclxubGV0IGM2NDtcclxubGV0IHZpY1JlYWQ7XHJcbmxldCBzZXRWaWNJcnE7XHJcbmxldCBzZXRQaXhlbDtcclxubGV0IGJsaXQ7XHJcblxyXG5sZXQgc3RhdGUgPSB7fTtcclxuY29uc3QgY29uZmlnID0ge1xyXG4gIGlnbm9yZVNwclNwckNvbGxpc2lvbnM6IGZhbHNlLFxyXG4gIGlnbm9yZVNwckJnQ29sbGlzaW9uczogIGZhbHNlLFxyXG4gIHNjb3BlU3ByaXRlczogICAgICAgICAgIGZhbHNlLFxyXG4gIHNjb3BlQmFja2dyb3VuZDogICAgICAgIGZhbHNlLFxyXG4gIHNjb3BlQ29sbGlzaW9uOiAgICAgICAgIGZhbHNlLFxyXG4gIHNjb3BlQ29sb3JSYW06ICAgICAgICAgIGZhbHNlLFxyXG59O1xyXG5cclxuY29uc3Qgc3BlY2lhbFN0YXRlVmFsdWVzID0gW1xyXG4gIFtcImNoYXJCdWZmZXJcIiwgICAgICAgVWludDhBcnJheSwgIDQwICAgIF0sXHJcbiAgW1wiY29sb3JCdWZmZXJcIiwgICAgICBVaW50OEFycmF5LCAgNDAgICAgXSxcclxuICBbXCJiZ1JnYlF1ZXVlXCIsICAgICAgIFVpbnQzMkFycmF5LCA4ICAgICBdLFxyXG4gIFtcImJnTWFza1F1ZXVlXCIsICAgICAgVWludDhBcnJheSwgIDggICAgIF0sXHJcbiAgW1wiYmdDb2xsaXNpb25RdWV1ZVwiLCBVaW50OEFycmF5LCAgOCAgICAgXSxcclxuICBbXCJjb2xvclwiLCAgICAgICAgICAgIFVpbnQ4QXJyYXksICAweDQwMCBdLFxyXG5dO1xyXG5cclxuLy8gVGltaW5nIGNvbnN0YW50cyAoUEFMKVxyXG5cclxuY29uc3QgICAgIEJPUkRFUl9PRkZfTElORV8yNV9ST1dTID0gNTE7XHJcbmNvbnN0ICAgICBCT1JERVJfT0ZGX0xJTkVfMjRfUk9XUyA9IDU1O1xyXG5jb25zdCAgICAgIEJPUkRFUl9PTl9MSU5FXzI1X1JPV1MgPSAyNTE7XHJcbmNvbnN0ICAgICAgQk9SREVSX09OX0xJTkVfMjRfUk9XUyA9IDI0NztcclxuXHJcbmNvbnN0ICAgICAgICAgICAgTEFTVF9SQVNURVJfTElORSA9IDMxMTtcclxuXHJcbi8vIFRoZSBmaXJzdCBjeWNsZSB3aXRoaW4gYSBsaW5lIG9uIHdoaWNoIGNoYXJhY3RlciBwb2ludGVyIGlzIHJlYWRcclxuY29uc3QgQ0hBUl9GRVRDSF9DWUNMRSA9IDE2O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGF0dGFjaChuYXNjZW50QzY0KSB7XHJcbiAgYzY0ID0gbmFzY2VudEM2NDtcclxuXHJcbiAgdmljUmVhZCAgID0gYzY0LndpcmVzLnZpY1JlYWQ7XHJcbiAgc2V0VmljSXJxID0gYzY0LndpcmVzLnNldFZpY0lycTtcclxuICBzZXRQaXhlbCAgPSBjNjQudmlkZW8uc2V0UGl4ZWw7XHJcbiAgYmxpdCAgICAgID0gYzY0LnZpZGVvLmJsaXQ7XHJcblxyXG4gIGM2NC52aWMgPSB7XHJcbiAgICAvLyBDb250cm9sXHJcbiAgICB0aWNrLFxyXG4gICAgcmVzZXQsXHJcbiAgICBzZXJpYWxpemUsXHJcbiAgICBkZXNlcmlhbGl6ZSxcclxuICAgIC8vIE1NSU9cclxuICAgIHJlYWRfZDAwMF9kM2ZmLFxyXG4gICAgcmVhZF9kODAwX2RiZmYsXHJcbiAgICB3cml0ZV9kMDAwX2QzZmYsXHJcbiAgICB3cml0ZV9kODAwX2RiZmYsXHJcbiAgICAvLyBTY29wZXNcclxuICAgIHNldElnbm9yZVNwckJnQ29sLFxyXG4gICAgc2V0SWdub3JlU3ByU3ByQ29sLFxyXG4gICAgc2V0U2NvcGUsXHJcbiAgICAvLyBHaW1taWNrc1xyXG4gICAgc2hvd1N0YXRpYyxcclxuICB9O1xyXG5cclxuICByZXNldCgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXNldCgpIHtcclxuXHJcbiAgY29uc3QgbWFrZURlZmF1bHRTcHJpdGUgPSAoKSA9PiAoe1xyXG4gICAgeDogICAgICAgMCwgICAgICAgICAvLyAkZDAwMCwgJGQwMDIsICRkMDA0LCAuLi4sIHdpdGggJGQwMTBcclxuICAgIHk6ICAgICAgIDAsICAgICAgICAgLy8gJGQwMDEsICRkMDAzLCAkZDAwNSwgLi4uXHJcbiAgICB4Mmg6ICAgICBmYWxzZSwgICAgIC8vICRkMDE3XHJcbiAgICB4Mnc6ICAgICBmYWxzZSwgICAgIC8vICRkMDFkXHJcbiAgICBjb2xvcjogICAwLCAgICAgICAgIC8vICRkMDI3LCAkZDAyOCwgJGQwMjksIC4uLlxyXG4gICAgbWNtOiAgICAgMCwgICAgICAgICAvLyAkZDAxY1xyXG4gICAgYmVoaW5kOiAgZmFsc2UsICAgICAvLyAkZDAxYlxyXG4gICAgZW5hYmxlZDogZmFsc2UsICAgICAvLyAkZDAxNVxyXG5cclxuICAgIC8vIHNlcXVlbmNlIGZvciBuZXh0IHNjYW5saW5lOlxyXG5cclxuICAgIGNvbG9yUXVldWU6ICAgICBuZXcgQXJyYXkoNDgpLFxyXG4gICAgbWFza1F1ZXVlOiAgICAgIG5ldyBBcnJheSg0OCksXHJcbiAgICBjb2xsaXNpb25RdWV1ZTogbmV3IEFycmF5KDQ4KSxcclxuXHJcbiAgICB4U3RhcnQ6IHVuZGVmaW5lZCxcclxuICAgIHhFbmQ6ICAgdW5kZWZpbmVkLFxyXG4gIH0pO1xyXG5cclxuICBzdGF0ZSA9IHtcclxuICAgIGN5Y2xlc1VudGlsUmFzdGVySW5jOiA2MixcclxuICAgIGN5Y2xlT2ZMaW5lOiAwLFxyXG4gICAgbGluZU9mUmFzdGVyOiAwLFxyXG4gICAgZGZsYWc6IHRydWUsICAgICAgICAgICAgICAgIC8vIHRvcC9ib3R0b20gYm9yZGVyXHJcbiAgICB2ZmxhZzogdHJ1ZSwgICAgICAgICAgICAgICAgLy8gbGVmdC9yaWdodCBib3JkZXJcclxuICAgIGJhZGxpbmU6IDAsICAgICAgICAgICAgICAgICAvLyBqdXN0IGZvciBkZXZcclxuXHJcbiAgICByYXN0ZXI6IDAsICAgICAgICAgICAgICAgICAgLy8gJGQwMTEtMiByZWFkXHJcbiAgICByYXN0ZXJJcnE6IDAsICAgICAgICAgICAgICAgLy8gJGQwMTEtMiB3cml0ZVxyXG4gICAgbWVtb3J5U2V0dXA6IDAsICAgICAgICAgICAgIC8vICRkMDE4XHJcbiAgICBpbnRlcnJ1cHRTdGF0dXM6IDAsICAgICAgICAgLy8gJGQwMTksIGJ1dCBub3QgYnV0IDcgKGRlcml2ZSB0aGF0IGZyb20gaXJxKVxyXG4gICAgaW50ZXJydXB0Q29udHJvbDogMCwgICAgICAgIC8vICRkMDFhXHJcbiAgICBpcnE6IGZhbHNlLCAgICAgICAgICAgICAgICAgLy8gZGVyaXZlZCBmcm9tIGludGVycnVwdFN0YXR1cyBhbmQgaW50ZXJydXB0Q29udHJvbFxyXG5cclxuICAgIHhzY3JvbGw6IDAsICAgICAgICAgICAgICAgICAvLyAkZDAxNlxyXG4gICAgeXNjcm9sbDogMCwgICAgICAgICAgICAgICAgIC8vICRkMDExXHJcblxyXG4gICAgZm9ydHlDb2x1bW5zOiAgIHRydWUsICAgICAgIC8vICRkMDE2XHJcbiAgICB0d2VudHlGaXZlUm93czogdHJ1ZSwgICAgICAgLy8gJGQwMTFcclxuICAgIGRpc3BsYXlFbmFibGU6ICB0cnVlLCAgICAgICAvLyAkZDAxMVxyXG5cclxuICAgIC8vIFRoZXNlIGFyZSBhbGwgNC1iaXQgY29sb3IgY29kZXM6XHJcbiAgICBib3JkZXJDb2xvcjogICAgICAgICAgICAwLCAgLy8gJGQwMjBcclxuICAgIGJhY2tncm91bmRDb2xvcjogICAgICAgIDAsICAvLyAkZDAyMVxyXG4gICAgZXh0cmFCZ0NvbG9yMTogICAgICAgICAgMCwgIC8vICRkMDIyXHJcbiAgICBleHRyYUJnQ29sb3IyOiAgICAgICAgICAwLCAgLy8gJGQwMjNcclxuICAgIGV4dHJhQmdDb2xvcjM6ICAgICAgICAgIDAsICAvLyAkZDAyNFxyXG4gICAgc3ByaXRlTXVsdGljb2xvckNvbG9yMDogMCwgIC8vICRkMDI1XHJcbiAgICBzcHJpdGVNdWx0aWNvbG9yQ29sb3IxOiAwLCAgLy8gJGQwMjZcclxuXHJcbiAgICAvLyBTY3JlZW4gbW9kZXNcclxuICAgIG11bHRpY29sb3I6IGZhbHNlLCAgICAgICAgICAvLyAkZDAxNlxyXG4gICAgYml0bWFwOiAgICAgZmFsc2UsICAgICAgICAgIC8vICRkMDExXHJcbiAgICBleHRlbmRlZEJnOiBmYWxzZSwgICAgICAgICAgLy8gJGQwMTFcclxuXHJcbiAgICAvLyBDb2xsaXNpb25zXHJcbiAgICBzcHJTcHJDb2w6IDAsICAgICAgICAgICAgICAgLy8gJGQwMWVcclxuICAgIHNwckJnQ29sOiAgMCwgICAgICAgICAgICAgICAvLyAkZDAxZlxyXG5cclxuICAgIGNoYXJCdWZmZXI6ICBuZXcgVWludDhBcnJheSg0MCksXHJcbiAgICBjb2xvckJ1ZmZlcjogbmV3IFVpbnQ4QXJyYXkoNDApLFxyXG5cclxuICAgIC8vIFRoZSAnc2VxdWVuY2Vycycgb2YgdGhlIGJhY2tncm91bmQgcGl4ZWxzIChjaGFyL2JpdG1hcClcclxuICAgIGJnUXVldWVQb3M6ICAgICAgIDAsXHJcbiAgICBiZ1JnYlF1ZXVlOiAgICAgICBuZXcgVWludDMyQXJyYXkoOCksXHJcbiAgICBiZ01hc2tRdWV1ZTogICAgICBuZXcgVWludDhBcnJheSg4KSxcclxuICAgIGJnQ29sbGlzaW9uUXVldWU6IG5ldyBVaW50OEFycmF5KDgpLFxyXG5cclxuICAgIG5leHRDaGFyQ29kZTogMCxcclxuICAgIG5leHRCZ0J5dGU6ICAgMCxcclxuICAgIG5leHRGZ0NvbDogICAgMCxcclxuXHJcbiAgICAvLyBDb2xvciBSQU1cclxuICAgIGNvbG9yOiBuZXcgVWludDhBcnJheSgweDQwMCksIC8vIHNlZSAkZDgwMC4gT25seSBvbmUgbnliYmxlIHBlciBhZGRyZXNzXHJcblxyXG4gICAgc3ByaXRlczogW1xyXG4gICAgICBtYWtlRGVmYXVsdFNwcml0ZSgpLFxyXG4gICAgICBtYWtlRGVmYXVsdFNwcml0ZSgpLFxyXG4gICAgICBtYWtlRGVmYXVsdFNwcml0ZSgpLFxyXG4gICAgICBtYWtlRGVmYXVsdFNwcml0ZSgpLFxyXG4gICAgICBtYWtlRGVmYXVsdFNwcml0ZSgpLFxyXG4gICAgICBtYWtlRGVmYXVsdFNwcml0ZSgpLFxyXG4gICAgICBtYWtlRGVmYXVsdFNwcml0ZSgpLFxyXG4gICAgICBtYWtlRGVmYXVsdFNwcml0ZSgpLFxyXG4gICAgXSxcclxuXHJcbiAgICAvLyBHaW1taWNrc1xyXG4gICAgc3RhdGljOiBmYWxzZSxcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBvbk5ld0xpbmUoKSB7XHJcblxyXG4gIC8vIHN0YXRlLmxpbmVPZlJhc3RlciBoYXMgYmVlbiB1cGRhdGVkXHJcblxyXG4gIGNvbnN0IGxpbmVPZkNoYXIgPSAoc3RhdGUucmFzdGVyIC0gc3RhdGUueXNjcm9sbCkgJiAweDc7XHJcbiAgc3RhdGUuYmFkbGluZSA9IGxpbmVPZkNoYXIgPT09IDc7XHJcblxyXG4gIGlmIChzdGF0ZS50d2VudHlGaXZlUm93cykge1xyXG4gICAgaWYgICAgICAoc3RhdGUubGluZU9mUmFzdGVyID09PSBCT1JERVJfT0ZGX0xJTkVfMjVfUk9XUykgc3RhdGUuZGZsYWcgPSBmYWxzZTtcclxuICAgIGVsc2UgaWYgKHN0YXRlLmxpbmVPZlJhc3RlciA9PT0gIEJPUkRFUl9PTl9MSU5FXzI1X1JPV1MpIHN0YXRlLmRmbGFnID0gdHJ1ZTtcclxuICB9XHJcbiAgZWxzZSB7XHJcbiAgICBpZiAgICAgIChzdGF0ZS5saW5lT2ZSYXN0ZXIgPT09IEJPUkRFUl9PRkZfTElORV8yNF9ST1dTKSBzdGF0ZS5kZmxhZyA9IGZhbHNlO1xyXG4gICAgZWxzZSBpZiAoc3RhdGUubGluZU9mUmFzdGVyID09PSAgQk9SREVSX09OX0xJTkVfMjRfUk9XUykgc3RhdGUuZGZsYWcgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgaWYgKHN0YXRlLmxpbmVPZlJhc3RlciA+IExBU1RfUkFTVEVSX0xJTkUpIHtcclxuICAgIHN0YXRlLmxpbmVPZlJhc3RlciA9IDA7XHJcbiAgICBibGl0KCk7XHJcbiAgICBpZiAoYzY0Lmhvb2tzLm9uRnJhbWVFbmQpIGM2NC5ob29rcy5vbkZyYW1lRW5kKCk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBsb2FkTmV4dEJnQnl0ZSgpIHtcclxuXHJcbiAgbGV0IGluZGV4T2ZDaGFyQnVmZmVyID0gc3RhdGUuY3ljbGVPZkxpbmUgLSAxNztcclxuXHJcbiAgaWYgKHN0YXRlLmJpdG1hcCkge1xyXG5cclxuICAgIGxldCBjaGFyID0gc3RhdGUuY2hhckJ1ZmZlcltpbmRleE9mQ2hhckJ1ZmZlcl07XHJcblxyXG4gICAgLy8gcm93cyBhcmUgOCBsaW5lcy4gV2Ugc2hvdWxkIGZvcm1hbGl6ZSB0aGUgdGVybWlub2xvZ3kuXHJcbiAgICBjb25zdCByb3cgPSBNYXRoLmZsb29yKChzdGF0ZS5yYXN0ZXIgLSBzdGF0ZS55c2Nyb2xsICsgMyAtIEJPUkRFUl9PRkZfTElORV8yNV9ST1dTKSAvIDgpO1xyXG4gICAgY29uc3QgbGluZU9mQ2hhciA9IChzdGF0ZS5yYXN0ZXIgLSBzdGF0ZS55c2Nyb2xsKSAmIDB4NztcclxuXHJcbiAgICBjb25zdCBiaXRtYXBNZW1CYXNlID0gKChzdGF0ZS5tZW1vcnlTZXR1cCAmIDBiMTAwMCkgPj4gMykgKiAweDIwMDA7XHJcblxyXG4gICAgbGV0IGJtQnl0ZSA9IHZpY1JlYWQoXHJcbiAgICAgIGJpdG1hcE1lbUJhc2UgK1xyXG4gICAgICAoKChyb3cgKiA0MCkgKyBpbmRleE9mQ2hhckJ1ZmZlcikgKiA4KSArIGxpbmVPZkNoYXJcclxuICAgICk7XHJcblxyXG4gICAgLy8gbmV4dEZnQ29sIG9ubHkgbmVjZXNzYXJ5IGluIGJpdG1hcCBtb2RlXHJcbiAgICBzdGF0ZS5uZXh0Q2hhckNvZGUgPSBjaGFyO1xyXG4gICAgc3RhdGUubmV4dEJnQnl0ZSAgID0gYm1CeXRlO1xyXG4gICAgc3RhdGUubmV4dEZnQ29sICAgID0gc3RhdGUuY29sb3JCdWZmZXJbaW5kZXhPZkNoYXJCdWZmZXJdICYgMHhmO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgZWxzZSB7XHJcblxyXG4gICAgbGV0IGNoYXIgPSBzdGF0ZS5jaGFyQnVmZmVyW2luZGV4T2ZDaGFyQnVmZmVyXTtcclxuICAgIGNvbnN0IGZnQ29sb3IgPSBzdGF0ZS5jb2xvckJ1ZmZlcltpbmRleE9mQ2hhckJ1ZmZlcl0gJiAweGY7XHJcblxyXG4gICAgLy8gSW4gZXh0ZW5kZWQgYmFja2dyb3VuZCBjb2xvciBtb2RlLCB0aGUgbW9zdCBzaWduaWZpY2FudCB0aHJlZSBiaXRzIG9mIHRoZVxyXG4gICAgLy8gY2hhcmFjdGVyIGNvZGUgd2lsbCBkZXRlcm1pbmUgdGhlIGJhY2tncm91bmQgY29sb3IgaW5zdGVhZCBvZiB0aGVcclxuICAgIC8vIGNoYXJhY3RlciBzaGFwZS5cclxuICAgIGxldCBjaGFyU2hhcGVCYXNlID0gKHN0YXRlLmV4dGVuZGVkQmcgPyAoY2hhciAmIDBiMDAxMTExMTEpIDogY2hhcikgKiA4O1xyXG5cclxuICAgIGxldCBjaGFyQnl0ZTtcclxuICAgIGNvbnN0IGxpbmVPZkNoYXIgPSAoc3RhdGUucmFzdGVyIC0gc3RhdGUueXNjcm9sbCkgJiAweDc7XHJcblxyXG5cclxuICAgIGxldCBjaGFyTWVtQmFzZSA9ICgoc3RhdGUubWVtb3J5U2V0dXAgJiAwYjExMTApID4+IDEpICogMHg4MDA7XHJcblxyXG4gICAgY2hhckJ5dGUgPSB2aWNSZWFkKGNoYXJNZW1CYXNlICsgKGNoYXJTaGFwZUJhc2UgKyBsaW5lT2ZDaGFyKSk7XHJcblxyXG4gICAgc3RhdGUubmV4dENoYXJDb2RlID0gY2hhcjtcclxuICAgIHN0YXRlLm5leHRCZ0J5dGUgICA9IGNoYXJCeXRlO1xyXG4gICAgc3RhdGUubmV4dEZnQ29sICAgID0gc3RhdGUuY29sb3JCdWZmZXJbaW5kZXhPZkNoYXJCdWZmZXJdICYgMHhmO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gbG9hZEJnUXVldWVzKCkge1xyXG5cclxuICBsZXQgcmdiUGFsZXR0ZSA9IChcclxuICAgIGNvbmZpZy5zY29wZVNwcml0ZXMgfHxcclxuICAgIGNvbmZpZy5zY29wZUNvbGxpc2lvblxyXG4gIClcclxuICAgID8gZ3JheXNjYWxlUGFsZXR0ZVxyXG4gICAgOiBzeXN0ZW1QYWxldHRlXHJcbiAgO1xyXG5cclxuICBsZXQgY2hhckJ5dGUgPSBzdGF0ZS5uZXh0QmdCeXRlO1xyXG4gIGxldCBmZ0NvbG9yID0gc3RhdGUubmV4dEZnQ29sO1xyXG5cclxuICBpZiAoY29uZmlnLnNjb3BlQ29sb3JSYW0pIHtcclxuICAgIHJnYlBhbGV0dGUgPSBjb2xvckNvbG9yUGFsZXR0ZXNbZmdDb2xvcl07XHJcbiAgfVxyXG5cclxuICBzdGF0ZS5iZ1F1ZXVlUG9zID0gMDtcclxuXHJcbiAgLy8gSWxsZWdhbCBtb2Rlc1xyXG4gIGlmIChzdGF0ZS5leHRlbmRlZEJnICYmIChzdGF0ZS5tdWx0aWNvbG9yIHx8IHN0YXRlLmJpdG1hcCkpIHtcclxuXHJcbiAgICBpZiAoY29uZmlnLnNjb3BlQmFja2dyb3VuZCkge1xyXG4gICAgICByZ2JQYWxldHRlID0gaGlnaGxpZ2h0UGFsZXR0ZXNbXHJcbiAgICAgICAgKHN0YXRlLm11bHRpY29sb3IgPyAwYjEwMCA6IDApIHxcclxuICAgICAgICAoc3RhdGUuZXh0ZW5kZWRCZyA/IDBiMDEwIDogMCkgfFxyXG4gICAgICAgIChzdGF0ZS5iaXRtYXAgICAgID8gMGIwMDEgOiAwKVxyXG4gICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRlLmJnUmdiUXVldWUgICAgICAuZmlsbChyZ2JQYWxldHRlWzBdKTsgIC8vIGNvbG9yIGNvZGUgMCBiZWluZyBibGFja1xyXG4gICAgc3RhdGUuYmdNYXNrUXVldWUgICAgIC5maWxsKDApO1xyXG4gICAgc3RhdGUuYmdDb2xsaXNpb25RdWV1ZS5maWxsKDApO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKHN0YXRlLmJpdG1hcCkge1xyXG4gICAgXHJcbiAgICBpZiAoc3RhdGUubXVsdGljb2xvcikge1xyXG5cclxuICAgICAgaWYgKGNvbmZpZy5zY29wZUJhY2tncm91bmQpIHJnYlBhbGV0dGUgPSBoaWdobGlnaHRQYWxldHRlc1swYjEwMV07XHJcblxyXG4gICAgICBjb25zdCBwYWxldHRlID0gW1xyXG4gICAgICAgIHN0YXRlLmJhY2tncm91bmRDb2xvcixcclxuICAgICAgICBzdGF0ZS5uZXh0Q2hhckNvZGUgPj4gNCxcclxuICAgICAgICBzdGF0ZS5uZXh0Q2hhckNvZGUgJiAweGYsXHJcbiAgICAgICAgZmdDb2xvciAmIDB4ZixcclxuICAgICAgXTtcclxuXHJcbiAgICAgIGxldCBuZXh0QmdCeXRlID0gc3RhdGUubmV4dEJnQnl0ZTtcclxuXHJcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgNDsgeCsrKSB7XHJcblxyXG4gICAgICAgIGNvbnN0IGluZGV4ICAgICA9IChuZXh0QmdCeXRlICYgMGIxMTAwMDAwMCkgPj4gNjtcclxuICAgICAgICBjb25zdCBjb2xvckNvZGUgPSBwYWxldHRlW2luZGV4XTtcclxuICAgICAgICBjb25zdCByZ2JDb2RlICAgPSByZ2JQYWxldHRlW2NvbG9yQ29kZV07XHJcblxyXG4gICAgICAgIHN0YXRlLmJnUmdiUXVldWVbKDIgKiB4KSArIDBdID0gcmdiQ29kZTtcclxuICAgICAgICBzdGF0ZS5iZ1JnYlF1ZXVlWygyICogeCkgKyAxXSA9IHJnYkNvZGU7XHJcblxyXG4gICAgICAgIHN0YXRlLmJnTWFza1F1ZXVlWygyICogeCkgKyAwXSA9IGluZGV4ID4gMDtcclxuICAgICAgICBzdGF0ZS5iZ01hc2tRdWV1ZVsoMiAqIHgpICsgMV0gPSBpbmRleCA+IDA7XHJcblxyXG4gICAgICAgIHN0YXRlLmJnQ29sbGlzaW9uUXVldWVbKDIgKiB4KSArIDBdID0gaW5kZXggPiAxO1xyXG4gICAgICAgIHN0YXRlLmJnQ29sbGlzaW9uUXVldWVbKDIgKiB4KSArIDFdID0gaW5kZXggPiAxO1xyXG5cclxuICAgICAgICBuZXh0QmdCeXRlIDw8PSAyO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuXHJcbiAgICAgIGlmIChjb25maWcuc2NvcGVCYWNrZ3JvdW5kKSByZ2JQYWxldHRlID0gaGlnaGxpZ2h0UGFsZXR0ZXNbMGIwMDFdO1xyXG5cclxuICAgICAgY29uc3QgY29sMCA9IHN0YXRlLm5leHRDaGFyQ29kZSAmIDB4ZjtcclxuICAgICAgY29uc3QgY29sMSA9IHN0YXRlLm5leHRDaGFyQ29kZSA+PiA0O1xyXG5cclxuICAgICAgY29uc3QgcmdiQ29sMCA9IHJnYlBhbGV0dGVbY29sMF07XHJcbiAgICAgIGNvbnN0IHJnYkNvbDEgPSByZ2JQYWxldHRlW2NvbDFdO1xyXG5cclxuICAgICAgbGV0IG5leHRCZ0J5dGUgPSBzdGF0ZS5uZXh0QmdCeXRlO1xyXG5cclxuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCA4OyB4KyspIHtcclxuXHJcbiAgICAgICAgc3RhdGUuYmdSZ2JRdWV1ZVt4XSA9IChuZXh0QmdCeXRlICYgMGIxMDAwMDAwMCkgPyByZ2JDb2wxIDogcmdiQ29sMDtcclxuICAgICAgICBzdGF0ZS5iZ01hc2tRdWV1ZVt4XSA9IHN0YXRlLmJnQ29sbGlzaW9uUXVldWVbeF0gPSAobmV4dEJnQnl0ZSAmIDBiMTAwMDAwMDApID8gMSA6IDA7XHJcblxyXG4gICAgICAgIG5leHRCZ0J5dGUgPDw9IDE7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpZiAoc3RhdGUuZXh0ZW5kZWRCZykge1xyXG5cclxuICAgIGlmIChjb25maWcuc2NvcGVCYWNrZ3JvdW5kKSByZ2JQYWxldHRlID0gaGlnaGxpZ2h0UGFsZXR0ZXNbMGIwMTBdO1xyXG5cclxuICAgIGxldCBiZ0NvbG9yO1xyXG5cclxuICAgIGlmICAgICAgKHN0YXRlLm5leHRDaGFyQ29kZSA8IDY0KSAgYmdDb2xvciA9IHN0YXRlLmJhY2tncm91bmRDb2xvcjtcclxuICAgIGVsc2UgaWYgKHN0YXRlLm5leHRDaGFyQ29kZSA8IDEyOCkgYmdDb2xvciA9IHN0YXRlLmV4dHJhQmdDb2xvcjE7XHJcbiAgICBlbHNlIGlmIChzdGF0ZS5uZXh0Q2hhckNvZGUgPCAxOTIpIGJnQ29sb3IgPSBzdGF0ZS5leHRyYUJnQ29sb3IyO1xyXG4gICAgZWxzZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZ0NvbG9yID0gc3RhdGUuZXh0cmFCZ0NvbG9yMztcclxuXHJcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDg7IHgrKykge1xyXG5cclxuICAgICAgY29uc3QgY29sb3JDb2RlID0gKGNoYXJCeXRlICYgMGIxMDAwMDAwMCkgPyBmZ0NvbG9yIDogYmdDb2xvcjtcclxuICAgICAgc3RhdGUuYmdSZ2JRdWV1ZVt4XSA9IHJnYlBhbGV0dGVbY29sb3JDb2RlXTtcclxuXHJcbiAgICAgIC8vIFRPRE86IEknbSBwcmVzdW1pbmcgaGVyZS4gQ2hlY2sgdGhpcy5cclxuICAgICAgc3RhdGUuYmdNYXNrUXVldWVbeF0gPSBzdGF0ZS5iZ0NvbGxpc2lvblF1ZXVlW3hdID0gKGNoYXJCeXRlICYgMGIxMDAwMDAwMCkgPyAxIDogMDtcclxuXHJcbiAgICAgIGNoYXJCeXRlIDw8PSAxO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZWxzZSBpZiAoc3RhdGUubXVsdGljb2xvciAmJiAoZmdDb2xvciA+IDcpKSB7XHJcblxyXG4gICAgaWYgKGNvbmZpZy5zY29wZUJhY2tncm91bmQpIHJnYlBhbGV0dGUgPSBoaWdobGlnaHRQYWxldHRlc1swYjEwMF07XHJcblxyXG4gICAgY29uc3QgcGFsZXR0ZSA9IFtcclxuICAgICAgc3RhdGUuYmFja2dyb3VuZENvbG9yLFxyXG4gICAgICBzdGF0ZS5leHRyYUJnQ29sb3IxLFxyXG4gICAgICBzdGF0ZS5leHRyYUJnQ29sb3IyLFxyXG4gICAgICBmZ0NvbG9yICYgMHg3LFxyXG4gICAgXTtcclxuXHJcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDQ7IHgrKykge1xyXG5cclxuICAgICAgbGV0IGluZGV4ID0gKGNoYXJCeXRlICYgMGIxMTAwMDAwMCkgPj4gNjtcclxuXHJcbiAgICAgIGNvbnN0IGNvbG9yQ29kZSA9IHBhbGV0dGVbaW5kZXhdO1xyXG4gICAgICBjb25zdCByZ2JDb2RlID0gcmdiUGFsZXR0ZVtjb2xvckNvZGVdO1xyXG5cclxuICAgICAgc3RhdGUuYmdSZ2JRdWV1ZVsoMiAqIHgpICsgMF0gPSByZ2JDb2RlO1xyXG4gICAgICBzdGF0ZS5iZ1JnYlF1ZXVlWygyICogeCkgKyAxXSA9IHJnYkNvZGU7XHJcblxyXG4gICAgICBzdGF0ZS5iZ01hc2tRdWV1ZVsoMiAqIHgpICsgMF0gPSBpbmRleCA+IDA7XHJcbiAgICAgIHN0YXRlLmJnTWFza1F1ZXVlWygyICogeCkgKyAxXSA9IGluZGV4ID4gMDtcclxuXHJcbiAgICAgIHN0YXRlLmJnQ29sbGlzaW9uUXVldWVbKDIgKiB4KSArIDBdID0gaW5kZXggPiAxO1xyXG4gICAgICBzdGF0ZS5iZ0NvbGxpc2lvblF1ZXVlWygyICogeCkgKyAxXSA9IGluZGV4ID4gMTtcclxuXHJcbiAgICAgIGNoYXJCeXRlIDw8PSAyO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZWxzZSB7XHJcbiAgICAvLyBSZWd1bGFyLCBuby1jb2xvci10cmlja3MgYmFja2dyb3VuZCBtb2RlXHJcblxyXG4gICAgaWYgKGNvbmZpZy5zY29wZUJhY2tncm91bmQpIHtcclxuICAgICAgLy8gU2luY2UgdGhlIG11bHRpY29sb3IgbW9kZSB3aXRoIGNvbG9yIGNvZGUgPCA4IGZhbGxzIHRocm91Z2ggdG8gdGhpcyBjYXNlXHJcbiAgICAgIGlmIChzdGF0ZS5tdWx0aWNvbG9yKSByZ2JQYWxldHRlID0gaGlnaGxpZ2h0UGFsZXR0ZXNbMGIxMDBdO1xyXG4gICAgICBlbHNlIHJnYlBhbGV0dGUgPSBoaWdobGlnaHRQYWxldHRlc1swYjAwMF07XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCA4OyB4KyspIHtcclxuXHJcbiAgICAgIC8vIEkgZmVlbCB3ZSBzaG91bGQganVzdCBwYWludCB0aGVtIGFsbCBhcyB0aGUgZm9yZWdyb3VuZCBjb2xvciwgYW5kIG1ha2VcclxuICAgICAgLy8gdGhlIGJnTWFza1F1ZXVlIHByb2Nlc3NvciB0YWtlIGl0IG91dC5cclxuICAgICAgY29uc3QgY29sb3JDb2RlID0gKGNoYXJCeXRlICYgMGIxMDAwMDAwMCkgPyBmZ0NvbG9yIDogc3RhdGUuYmFja2dyb3VuZENvbG9yO1xyXG4gICAgICBcclxuICAgICAgc3RhdGUuYmdSZ2JRdWV1ZSAgICAgIFt4XSA9IHJnYlBhbGV0dGVbY29sb3JDb2RlXTtcclxuICAgICAgc3RhdGUuYmdNYXNrUXVldWUgICAgIFt4XSA9IChjaGFyQnl0ZSAmIDBiMTAwMDAwMDApO1xyXG4gICAgICBzdGF0ZS5iZ0NvbGxpc2lvblF1ZXVlW3hdID0gKGNoYXJCeXRlICYgMGIxMDAwMDAwMCk7XHJcblxyXG4gICAgICBjaGFyQnl0ZSA8PD0gMTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBnZXQ4QmFja2dyb3VuZFBpeGVscyh4YywgeSwgY29sb3IsIG1hc2ssIGNvbGxpc2lvbikge1xyXG4gIFxyXG4gIGNvbnN0IGFib3ZlVG9wID0gKFxyXG4gICAgKChzdGF0ZS5yYXN0ZXIgLSBzdGF0ZS55c2Nyb2xsKSA+PiAzKSA8IFxyXG4gICAgKEJPUkRFUl9PRkZfTElORV8yNV9ST1dTID4+IDMpXHJcbiAgKTtcclxuXHJcbiAgY29uc3QgYmVsb3dCb3R0b20gPSAoXHJcbiAgICAoKHN0YXRlLnJhc3RlciAtIHN0YXRlLnlzY3JvbGwpID4+IDMpID4gXHJcbiAgICAoQk9SREVSX09OX0xJTkVfMjRfUk9XUyA+PiAzKVxyXG4gICk7XHJcblxyXG4gIGlmIChhYm92ZVRvcCB8fCBiZWxvd0JvdHRvbSkge1xyXG5cclxuICAgIC8vIFRPRE86IHRoZSByZWFsIFZJQyBzZXJ2ZXMgY2hhciBkYXRhIGZyb20gJDNmZmYgaGVyZVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHtcclxuXHJcbiAgICAgIC8vIFRPRE86IFdlJ3JlIG1hcHBpbmcgc2NvcGUgdG8gcGFsZXR0ZXMgaW4gdG9vIG1hbnkgZGlmZmVyZW50IHBsYWNlcy5cclxuICAgICAgLy8gVGhpcyBuZWVkcyBhIG1vcmUgZWxlZ2FudCBzb2x1dGlvbi5cclxuICAgICAgY29uc3QgcmdiUGFsZXR0ZSA9IChcclxuICAgICAgICBjb25maWcuc2NvcGVTcHJpdGVzICAgIHx8XHJcbiAgICAgICAgY29uZmlnLnNjb3BlQmFja2dyb3VuZCB8fFxyXG4gICAgICAgIGNvbmZpZy5zY29wZUNvbGxpc2lvbiAgfHxcclxuICAgICAgICBjb25maWcuc2NvcGVDb2xvclJhbVxyXG4gICAgICApXHJcbiAgICAgICAgPyBncmF5c2NhbGVQYWxldHRlXHJcbiAgICAgICAgOiBzeXN0ZW1QYWxldHRlXHJcbiAgICAgIDtcclxuXHJcbiAgICAgIGNvbG9yW2ldICAgICA9IHJnYlBhbGV0dGVbc3RhdGUuYmFja2dyb3VuZENvbG9yXTtcclxuICAgICAgbWFzayBbaV0gICAgID0gZmFsc2U7XHJcbiAgICAgIGNvbGxpc2lvbltpXSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuICBlbHNlIHtcclxuICAgIGNvbnN0IHJldCA9IFtdO1xyXG5cclxuICAgIGZvciAobGV0IHggPSAwOyB4IDwgODsgeCsrKSB7XHJcblxyXG4gICAgICAvLyBUaGlzIGxvYWRzIHRoZSBkb3QgcXVldWUgZm9yIHRoZSBuZXh0IGNoYXJhY3RlciBuZWVkZWQsIGJ1dFxyXG4gICAgICAvLyAtIFRPRE8gLSB3ZSBuZWVkIHRvIHdpcGUgaXQgYmVmb3JlIHRoZSBmaXJzdCBvbmUuXHJcbiAgICAgIGlmICh4ID09PSBzdGF0ZS54c2Nyb2xsKSB7XHJcbiAgICAgICAgbG9hZEJnUXVldWVzKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbG9yICAgIFt4XSA9ICAgICAgICAgc3RhdGUuYmdSZ2JRdWV1ZSAgICAgIFtzdGF0ZS5iZ1F1ZXVlUG9zXTtcclxuICAgICAgbWFzayAgICAgW3hdID0gQm9vbGVhbihzdGF0ZS5iZ01hc2tRdWV1ZSAgICAgW3N0YXRlLmJnUXVldWVQb3NdKTtcclxuICAgICAgY29sbGlzaW9uW3hdID0gQm9vbGVhbihzdGF0ZS5iZ0NvbGxpc2lvblF1ZXVlW3N0YXRlLmJnUXVldWVQb3NdKTtcclxuXHJcbiAgICAgIC8vIFZpc3VhbGl6aW5nIGRlYnVnIGFpZFxyXG4gICAgICAvLyBjb2xvclt4XSA9IG1hc2tbeF0gPyAweGZmMDAwMCA6IDB4MDAwMDAwO1xyXG5cclxuICAgICAgaWYgKGNvbmZpZy5zY29wZUNvbGxpc2lvbikge1xyXG4gICAgICAgIC8vIFNhZGx5IHdlJ3ZlIGxvc3QgdGhlIG9yaWdpbmFsIGNvbG9yIGNvZGUgYnkgdGhpcyBwb2ludFxyXG4gICAgICAgIGlmIChjb2xsaXNpb25beF0pIGNvbG9yW3hdID0gaGlnaGxpZ2h0UGFsZXR0ZXNbM11bMTVdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzdGF0ZS5iZ1F1ZXVlUG9zKys7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gcmVjb25zaWRlclZpY0lycSgpIHtcclxuICBzdGF0ZS5pcnEgPSBCb29sZWFuKHN0YXRlLmludGVycnVwdFN0YXR1cyAmIHN0YXRlLmludGVycnVwdENvbnRyb2wpO1xyXG4gIHNldFZpY0lycShzdGF0ZS5pcnEpO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gc3ByU3ByQ29sbGlzaW9uKGEsIGIpIHtcclxuICBpZiAoY29uZmlnLmlnbm9yZVNwclNwckNvbGxpc2lvbnMpIHJldHVybjtcclxuXHJcbiAgLy8gU3ByaXRlICNhIGNvbGxpZGVkIHdpdGggc3ByaXRlICNiXHJcblxyXG4gIC8vIFRPRE86IHF1ZXN0aW9uczpcclxuICAvLyAxKSBpZiBzcHJpdGUtdG8tc3ByaXRlIGNvbGxpc2lvbiBpbnRlcnJ1cHRzIGFyZW4ndCByZXF1ZXN0ZWQsIGRvZXMgdGhpc1xyXG4gIC8vICAgIHJlZ2lzdGVyIHN0aWxsIGdldCB1cGRhdGVkPyAoYXNzdW1pbmcgeWVzKVxyXG4gIC8vIDIpIG9uY2UgYSBjb2xsaXNpb24gaGFzIGhhcHBlbmVkIHRvIHJhaXNlIGFuIGludGVycnVwdCwgZG8gdGhleSBjb250aW51ZVxyXG4gIC8vICAgIHRvIHN0YWNrIHVwIGFzIG1vcmUgc3ByaXRlcyBjb2xsaWRlPyAoYXNzdW1pbmcgeWVzKS5cclxuXHJcbiAgY29uc3QgZW1wdHlPbkVudHJ5ID0gc3RhdGUuc3ByU3ByQ29sO1xyXG5cclxuICBzdGF0ZS5zcHJTcHJDb2wgPSBzdGF0ZS5zcHJTcHJDb2xcclxuICAgIHwgKDEgPDwgYSlcclxuICAgIHwgKDEgPDwgYilcclxuICA7XHJcblxyXG4gIC8vIE1vcmUgaW50ZXJydXB0cyBkb24ndCBmaXJlIGlmIHRoZSByZWdpc3RlciBoYXNuJ3QgYmVlbiByZWFkXHJcbiAgaWYgKCFlbXB0eU9uRW50cnkpIHJldHVybjtcclxuXHJcbiAgLy8gU2V0IHRoZSBhbmQgJ3Nwci1zcHIgY29sbGlzaW9uJyBmbGFnXHJcbiAgc3RhdGUuaW50ZXJydXB0U3RhdHVzIHw9IDBiMTAwO1xyXG5cclxuICByZWNvbnNpZGVyVmljSXJxKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNwckJnQ29sbGlzaW9uKHNwcml0ZU51bSkge1xyXG4gIGlmIChjb25maWcuaWdub3JlU3ByQmdDb2xsaXNpb25zKSByZXR1cm47XHJcblxyXG4gIGNvbnN0IGVtcHR5T25FbnRyeSA9IHN0YXRlLnNwckJnQ29sO1xyXG5cclxuICBzdGF0ZS5zcHJCZ0NvbCB8PSAxIDw8IHNwcml0ZU51bTtcclxuXHJcbiAgLy8gTW9yZSBpbnRlcnJ1cHRzIGRvbid0IGZpcmUgaWYgdGhlIHJlZ2lzdGVyIGhhc24ndCBiZWVuIHJlYWRcclxuICBpZiAoIWVtcHR5T25FbnRyeSkgcmV0dXJuO1xyXG5cclxuICAvLyBTZXQgdGhlICdzcHItYmcgY29sbGlzaW9uJyBmbGFnXHJcbiAgc3RhdGUuaW50ZXJydXB0U3RhdHVzIHw9IDBiMTA7XHJcblxyXG4gIHJlY29uc2lkZXJWaWNJcnEoKTtcclxufVxyXG5cclxuLy8gS2luZGEgd2FudCBhIGJldHRlciBuYW1lIGZvciB0aGlzIGZ1bmN0aW9uLiBUaGUgcG9pbnQgaXMgdGhlIHJhc3RlciBsaW5lIGhhc1xyXG4vLyByZWFjaGVkIHRoZSBudW1iZXIgdGhhdCB0cmlnZ2VycyBhbiBJUlEsIHRob3VnaCBpZiByYXN0ZXIgSVJRJ3MgYXJlbid0XHJcbi8vIGVuYWJsZWQsIHRoZXJlJ2xsIGJlIG5vIElSUS5cclxuZnVuY3Rpb24gcmFzdGVyTWlnaHRJcnEoKSB7XHJcblxyXG4gIC8vIFNvIHRoaXMgaXMgd2hhdCBJIHRoaW5rIEkgbGVhcm5lZCByZWNlbnRseS4uLiB0aGF0IHRoZSBiaXQgZ2V0cyB3cml0dGVuIFxyXG4gIC8vIHRvICRkMDE5IHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgaW50ZXJydXB0cyBhcmUgZW5hYmxlZC5cclxuXHJcbiAgc3RhdGUuaW50ZXJydXB0U3RhdHVzIHw9IDE7XHJcbiAgcmVjb25zaWRlclZpY0lycSgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXQ4UGl4ZWxzKHhjLCB5KSB7XHJcbiAgY29uc3QgZGVmYXVsdFBhbGV0dGUgPSAoXHJcbiAgICAoXHJcbiAgICAgIGNvbmZpZy5zY29wZVNwcml0ZXMgICAgfHxcclxuICAgICAgY29uZmlnLnNjb3BlQmFja2dyb3VuZCB8fFxyXG4gICAgICBjb25maWcuc2NvcGVDb2xsaXNpb24gIHx8XHJcbiAgICAgIGNvbmZpZy5zY29wZUNvbG9yUmFtXHJcbiAgICApXHJcbiAgICA/IGdyYXlzY2FsZVBhbGV0dGVcclxuICAgIDogc3lzdGVtUGFsZXR0ZVxyXG4gICk7XHJcblxyXG4gIC8vIERpc3BsYXkgb2ZmP1xyXG4gIGlmICghc3RhdGUuZGlzcGxheUVuYWJsZSkgcmV0dXJuIG5ldyBBcnJheSg4KS5maWxsKGRlZmF1bHRQYWxldHRlW3N0YXRlLmJvcmRlckNvbG9yXSk7XHJcblxyXG4gIC8vIElmIHdlJ3JlIG9uIHRoZSB0b3AvYm90dG9tIGJvcmRlciwgb3V0cHV0IHRoZSBib3JkZXIgY29sb3JcclxuICBpZiAoc3RhdGUuZGZsYWcpIHtcclxuICAgIHJldHVybiBuZXcgQXJyYXkoOCkuZmlsbChkZWZhdWx0UGFsZXR0ZVtzdGF0ZS5ib3JkZXJDb2xvcl0pO1xyXG4gIH1cclxuXHJcbiAgLy8gVE9ETzogd2Ugc2hvdWxkIHByb2JhYmx5IGF2b2lkIHJlYWxsb2NhdGluZyB0aGVzZSBlYWNoIHRpbWVcclxuICBsZXQgY29sb3IgICAgID0gbmV3IEFycmF5KDgpO1xyXG4gIGxldCBtYXNrICAgICAgPSBuZXcgQXJyYXkoOCk7XHJcbiAgbGV0IGNvbGxpc2lvbiA9IG5ldyBBcnJheSg4KTtcclxuXHJcbiAgLy8gU29tZSBuYXN0eSBtYWdpYyBudW1iZXJzIHRoYXQgaGF2ZW4ndCBiZWVuIHRob3VnaHQgdGhyb3VnaCBhbmQgYXJlIGp1c3QgYVxyXG4gIC8vIGJhbmQtYWlkIG9wdGltaXphdGlvbi5cclxuICBpZiAoKHN0YXRlLmN5Y2xlT2ZMaW5lID49IDE2KSAmJiAoc3RhdGUuY3ljbGVPZkxpbmUgPD0gNTcpKSB7XHJcbiAgICBnZXQ4QmFja2dyb3VuZFBpeGVscyh4YywgeSwgY29sb3IsIG1hc2ssIGNvbGxpc2lvbik7XHJcbiAgfVxyXG5cclxuICAvLyBJZiB3ZSdyZSBvbiB0aGUgbGVmdC9yaWdodCBib3JkZXIsIG91dHB1dCB0aGUgYm9yZGVyIGNvbG9yLCBub3cgdGhhdCB3ZSd2ZVxyXG4gIC8vIGRvbmUgdGhlIGJhY2tncm91bmQgcGl4ZWwgZmV0Y2ggYXQgbGVhc3QuXHJcbiAgLy8gKEhhZCB3ZSBub3QsIHRoZSBjaGFyYWN0ZXIgdGlsZXMgd291bGRuJ3QgaGF2ZSBsb2FkZWQgY29ycmVjdGx5KVxyXG4gIGlmIChzdGF0ZS52ZmxhZykge1xyXG5cclxuICAgIC8vIG9oIHRoaXMgd29uJ3Qgd29yay4gVGhlIHJpZ2h0IGJvcmRlciBnZXRzIGJyb3VnaHQgaW4gOSBwaXhlbHMgaW4gMzgtY29sdW1uIG1vZGUuXHJcbiAgICByZXR1cm4gbmV3IEFycmF5KDgpLmZpbGwoZGVmYXVsdFBhbGV0dGVbc3RhdGUuYm9yZGVyQ29sb3JdKTtcclxuICB9XHJcblxyXG4gIGZvciAobGV0IHBpeGVsID0gMDsgcGl4ZWwgPCA4OyBwaXhlbCsrKSB7XHJcblxyXG4gICAgLy8gSnVzdCBmb3IgdGhlIGNvbGxpc2lvbiBzY29wZVxyXG4gICAgbGV0IGlzQW55U3ByQ29sUGl4ID0gZmFsc2U7XHJcblxyXG4gICAgbGV0IHggPSAoeGMgKiA4KSArIHBpeGVsO1xyXG5cclxuICAgIGxldCBkb21pbmFudFNwcml0ZTsgICAvLyBTcHJpdGUgbnVtYmVyIG9mIGRvbWluYW50IHNwcml0ZVxyXG4gICAgbGV0IHNwcml0ZUNvbDsgICAgICAgIC8vIENvbG9yIGNvZGUgZm9yIGRvbWluYW50IHNwcml0ZVxyXG4gICAgbGV0IGNvbGxpZGVkU3ByaXRlO1xyXG5cclxuICAgIC8vIEl0ZXJhdGUgYmFja3dhcmRzIHRocm91Z2ggdGhlIHNwcml0ZXMsIGFzIHNwcml0ZSAwIGdldHMgZHJhd24gYWJvdmUgYWxsXHJcbiAgICAvLyB0aGUgb3RoZXJzLlxyXG4gICAgZm9yIChsZXQgc3ByaXRlTnVtID0gNzsgc3ByaXRlTnVtID49IDA7IHNwcml0ZU51bS0tKSB7XHJcblxyXG4gICAgICBjb25zdCBzcHJPYmogPSBzdGF0ZS5zcHJpdGVzW3Nwcml0ZU51bV07XHJcblxyXG4gICAgICBpZiAoc3ByT2JqLnhTdGFydCA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcclxuXHJcbiAgICAgIGlmICgoeCA+PSBzcHJPYmoueFN0YXJ0KSAmJiAoeCA8IHNwck9iai54RW5kKSkge1xyXG5cclxuICAgICAgICBjb25zdCBzeCA9IHggLSBzcHJPYmoueFN0YXJ0O1xyXG5cclxuICAgICAgICBpZiAoc3ByT2JqLm1hc2tRdWV1ZVtzeF0pIHtcclxuXHJcbiAgICAgICAgICAvLyBPdmVyd3JpdGUgdGhlIHByZXZpb3VzLCB3aGljaCwgYXMgYSBoaWdoZXIgbnVtYmVyZWQgc3ByaXRlLFxyXG4gICAgICAgICAgLy8gd291bGQgaGF2ZSBhIGxvd2VyIHByaW9yaXR5XHJcbiAgICAgICAgICBzcHJpdGVDb2wgPSBzcHJPYmouY29sb3JRdWV1ZVtzeF07XHJcbiAgICAgICAgICBkb21pbmFudFNwcml0ZSA9IHNwcml0ZU51bTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE1pZ2h0IGJlIGV4cGVuc2l2ZSB0byBkbyBpdCB0aGlzIHdheVxyXG4gICAgICAgIGlmIChzcHJPYmouY29sbGlzaW9uUXVldWVbc3hdKSB7XHJcblxyXG4gICAgICAgICAgaXNBbnlTcHJDb2xQaXggPSB0cnVlO1xyXG5cclxuICAgICAgICAgIC8vIExvb2sgZm9yIHNwcml0ZS1iYWNrZ3JvdW5kIGNvbGxpc2lvbnNcclxuICAgICAgICAgIGlmIChjb2xsaXNpb25bcGl4ZWxdKSBzcHJCZ0NvbGxpc2lvbihzcHJpdGVOdW0pO1xyXG5cclxuICAgICAgICAgIC8vIExvb2sgZm9yIHNwcml0ZS1zcHJpdGUgY29sbGlzaW9uc1xyXG4gICAgICAgICAgaWYgKGNvbGxpZGVkU3ByaXRlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgc3ByU3ByQ29sbGlzaW9uKGNvbGxpZGVkU3ByaXRlLCBzcHJpdGVOdW0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY29sbGlkZWRTcHJpdGUgPSBzcHJpdGVOdW07XHJcbiAgICAgICAgfSAgICAgICAgXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBXZSd2ZSBub3cgZ29uZSB0aHJvdWdoIGFsbCB0aGUgc3ByaXRlcyB0byBzZWUgd2hpY2gsIGlmIGFueSwgaXMgb24gdG9wLlxyXG4gICAgLy8gSWYgdGhlcmUgd2FzIGEgc3ByaXRlIG9uIHRvcCwgYW5kIHRoZSBwcmlvcml0eSBvZiB0aGF0IHNwcml0ZSBpcyBhYm92ZVxyXG4gICAgLy8gdGhlIGJhY2tncm91bmQsIHBhaW50IGl0LlxyXG5cclxuICAgIGlmIChkb21pbmFudFNwcml0ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGlmICghc3RhdGUuc3ByaXRlc1tkb21pbmFudFNwcml0ZV0uYmVoaW5kIHx8ICFtYXNrW3BpeGVsXSkge1xyXG5cclxuICAgICAgICBpZiAoY29uZmlnLnNjb3BlU3ByaXRlcykge1xyXG4gICAgICAgICAgY29sb3JbcGl4ZWxdID0gaGlnaGxpZ2h0UGFsZXR0ZXNbZG9taW5hbnRTcHJpdGVdW3Nwcml0ZUNvbF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbmZpZy5zY29wZUNvbGxpc2lvbiAmJiBpc0FueVNwckNvbFBpeCkge1xyXG4gICAgICAgICAgY29sb3JbcGl4ZWxdID0gaGlnaGxpZ2h0UGFsZXR0ZXNbMF1bc3ByaXRlQ29sXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBjb2xvcltwaXhlbF0gPSBkZWZhdWx0UGFsZXR0ZVtzcHJpdGVDb2xdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBjb2xvcjtcclxufVxyXG5cclxuZnVuY3Rpb24gZmV0Y2hOZXh0Um93T2ZDaGFyTWF0cml4KCkge1xyXG4gIC8vIHN0YXJ0IHB1bGxpbmcgaW4gdGhlIGNoYXIgYnVmZmVyIGZvciB0aGUgbmV4dCBsaW5lXHJcbiAgaWYgKFxyXG4gICAgKHN0YXRlLmN5Y2xlT2ZMaW5lID49IENIQVJfRkVUQ0hfQ1lDTEUpICYmXHJcbiAgICAoc3RhdGUuY3ljbGVPZkxpbmUgPD0gKENIQVJfRkVUQ0hfQ1lDTEUgKyA0MCkpXHJcbiAgKSB7XHJcblxyXG4gICAgLy8gU2V0IHRoZSBwb2ludGVyIHVwIHdpdGggdGhlIHguLi5cclxuICAgIGxldCBwdHIgPSBzdGF0ZS5jeWNsZU9mTGluZSAtIENIQVJfRkVUQ0hfQ1lDTEU7XHJcblxyXG4gICAgLy8gYWRkIHRoZSB5Li4uXHJcbiAgICBwdHIgKz0gKChzdGF0ZS5yYXN0ZXIgPj4gMykgLSA2KSAqIDQwO1xyXG5cclxuICAgIC8vIERvbid0IHJlYWQgbWVtb3J5IG91dCBvZiBib3VuZHNcclxuICAgIGlmICgocHRyID49IDApICYmIChwdHIgPCAxMDAwKSkge1xyXG5cclxuICAgICAgLy8gV2hpY2ggY2hhcmFjdGVyIG9mIHRoaXMgcm93IG9mIHRleHQgYXJlIHdlIGxvYWRpbmdcclxuICAgICAgY29uc3QgYnVmZmVySW5kZXggPSBzdGF0ZS5jeWNsZU9mTGluZSAtIENIQVJfRkVUQ0hfQ1lDTEU7XHJcblxyXG4gICAgICBsZXQgc2NyZWVuQmFzZSA9IChzdGF0ZS5tZW1vcnlTZXR1cCA+PiA0KSAqIDB4NDAwO1xyXG5cclxuICAgICAgc3RhdGUuY2hhckJ1ZmZlcltidWZmZXJJbmRleF0gPSB2aWNSZWFkKHNjcmVlbkJhc2UgKyBwdHIpO1xyXG4gICAgICBzdGF0ZS5jb2xvckJ1ZmZlcltidWZmZXJJbmRleF0gPSBzdGF0ZS5jb2xvcltwdHJdO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZmV0Y2hTcHJpdGVTZXF1ZW5jZXNGb3JMaW5lKCkge1xyXG5cclxuICAvLyBXaGF0J3Mgbm90IGFjY3VyYXRlIGFib3V0IHRoaXMgaXMgd2hlbiBpdCBkb2VzIHRoZSBmZXRjaGluZ1xyXG5cclxuICBjb25zdCBzY3JlZW5CYXNlID0gKHN0YXRlLm1lbW9yeVNldHVwID4+IDQpICogMHg0MDA7XHJcbiAgY29uc3Qgc3ByUHRyc0FkZHIgPSBzY3JlZW5CYXNlICsgKDEwMjQgLSA4KTtcclxuXHJcbiAgLy8gV29yayB0aHJvdWdoIHRoZSBzcHJpdGVzIGJhY2t3YXJkcywgYXMgMCBoYXMgcHJpb3JpdHlcclxuICBmb3IgKGxldCBzcHJpdGVOdW0gPSA3OyBzcHJpdGVOdW0gPj0gMDsgc3ByaXRlTnVtLS0pIHtcclxuXHJcbiAgICBjb25zdCBzcHJPYmogPSBzdGF0ZS5zcHJpdGVzW3Nwcml0ZU51bV07XHJcblxyXG4gICAgc3ByT2JqLnhTdGFydCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICBpZiAoIXNwck9iai5lbmFibGVkKSBjb250aW51ZTtcclxuXHJcbiAgICBjb25zdCBkb3VibGVXaWR0aCA9IHNwck9iai54Mnc7XHJcblxyXG4gICAgbGV0IHggPSBzcHJPYmoueDtcclxuICAgIGxldCB5ID0gc3ByT2JqLnk7XHJcblxyXG4gICAgLy8gdG8gYmUgYXQgdGhpcyByYXN0ZXIsIHdoYXQgd291bGQgdGhlIHNwcml0ZSdzIHkgaGF2ZSBuZWVkZWQgdG8gYmU/XHJcbiAgICBsZXQgbGluZU9mU3ByaXRlID0gc3RhdGUubGluZU9mUmFzdGVyIC0geTtcclxuXHJcbiAgICBpZiAoc3ByT2JqLngyaCkge1xyXG4gICAgICBsaW5lT2ZTcHJpdGUgPSBNYXRoLmZsb29yKGxpbmVPZlNwcml0ZSAvIDIpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChsaW5lT2ZTcHJpdGUgIDwgMCkgY29udGludWU7XHJcbiAgICBpZiAobGluZU9mU3ByaXRlID49IDIxKSBjb250aW51ZTtcclxuXHJcbiAgICBjb25zdCBzcHJpdGVQdHIgPSBzcHJQdHJzQWRkciArIHNwcml0ZU51bTtcclxuXHJcbiAgICBsZXQgc3ByaXRlRGF0YVB0ciA9IHZpY1JlYWQoc3ByaXRlUHRyKTtcclxuICAgIFxyXG4gICAgc3ByaXRlRGF0YVB0ciAqPSA2NDtcclxuICAgIHNwcml0ZURhdGFQdHIgKz0gKGxpbmVPZlNwcml0ZSAqIDMpO1xyXG5cclxuICAgIGNvbnN0IGJ5dGUwID0gdmljUmVhZChzcHJpdGVEYXRhUHRyICsgMCk7XHJcbiAgICBjb25zdCBieXRlMSA9IHZpY1JlYWQoc3ByaXRlRGF0YVB0ciArIDEpO1xyXG4gICAgY29uc3QgYnl0ZTIgPSB2aWNSZWFkKHNwcml0ZURhdGFQdHIgKyAyKTtcclxuXHJcbiAgICAvLyBObyBuZWVkIHRvIGNsZWFyIG91dCB0aGUgb2xkIHN0cnVjdHVyZXM7IHdlJ2xsIGp1c3Qgd3JpdGUgb3ZlciB0aGVtXHJcbiAgICBsZXQgICAgIHNwcml0ZUNvbG9yUXVldWUgPSBzcHJPYmouICAgIGNvbG9yUXVldWU7XHJcbiAgICBsZXQgICAgICBzcHJpdGVNYXNrUXVldWUgPSBzcHJPYmouICAgICBtYXNrUXVldWU7XHJcbiAgICBsZXQgc3ByaXRlQ29sbGlzaW9uUXVldWUgPSBzcHJPYmouY29sbGlzaW9uUXVldWU7XHJcblxyXG4gICAgY29uc3Qgc3ByaXRlQ29sb3IgPSBzcHJPYmouY29sb3I7XHJcblxyXG4gICAgbGV0IHNwcml0ZTI0Yml0cyA9IChieXRlMCA8PCAxNikgfCAoYnl0ZTEgPDwgOCkgfCAoYnl0ZTIgPDwgMCk7XHJcblxyXG4gICAgaWYgKHNwck9iai5tY20pIHtcclxuXHJcbiAgICAgIGNvbnN0IGNvbG9yQ29kZXMgPSBbXHJcbiAgICAgICAgMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXJyZWxldmFudDsgbWFza2VkIG91dFxyXG4gICAgICAgIHN0YXRlLnNwcml0ZU11bHRpY29sb3JDb2xvcjAsXHJcbiAgICAgICAgc3ByaXRlQ29sb3IsXHJcbiAgICAgICAgc3RhdGUuc3ByaXRlTXVsdGljb2xvckNvbG9yMSxcclxuICAgICAgXTtcclxuXHJcbiAgICAgIGxldCBxUG9zID0gMDtcclxuXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTI7IGkrKykge1xyXG4gICAgICAgIGxldCBpbmRleCA9IChzcHJpdGUyNGJpdHMgJiAoMGIxMSA8PCAyMikpID4+IDIyO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgKGRvdWJsZVdpZHRoID8gNCA6IDIpOyBqKyspIHtcclxuICAgICAgICAgICAgICAgc3ByaXRlTWFza1F1ZXVlW3FQb3NdID0gaW5kZXggIT09IDA7XHJcbiAgICAgICAgICAgICAgc3ByaXRlQ29sb3JRdWV1ZVtxUG9zXSA9IGNvbG9yQ29kZXNbaW5kZXhdO1xyXG4gICAgICAgICAgc3ByaXRlQ29sbGlzaW9uUXVldWVbcVBvc10gPSBpbmRleCA+IDE7XHJcblxyXG4gICAgICAgICAgcVBvcysrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3ByaXRlMjRiaXRzIDw8PSAyO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuXHJcbiAgICAgIGxldCBxUG9zID0gMDtcclxuXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjQ7IGkrKykge1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgKGRvdWJsZVdpZHRoID8gMiA6IDEpOyBqKyspIHtcclxuXHJcbiAgICAgICAgICBsZXQgaXNPbiA9IChzcHJpdGUyNGJpdHMgJiAoMSA8PCAyMykpID8gdHJ1ZSA6IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgc3ByaXRlTWFza1F1ZXVlW3FQb3NdID0gaXNPbjtcclxuICAgICAgICAgICAgICBzcHJpdGVDb2xvclF1ZXVlW3FQb3NdID0gc3ByaXRlQ29sb3I7XHJcbiAgICAgICAgICBzcHJpdGVDb2xsaXNpb25RdWV1ZVtxUG9zXSA9IGlzT247XHJcblxyXG4gICAgICAgICAgcVBvcysrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3ByaXRlMjRiaXRzIDw8PSAxO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3ByT2JqLnhTdGFydCA9IHNwck9iai54ICsgMTEyO1xyXG4gICAgc3ByT2JqLnhFbmQgICA9IHNwck9iai54U3RhcnQgKyAoZG91YmxlV2lkdGggPyA0OCA6IDI0KTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRpY2soKSB7XHJcblxyXG4gIHtcclxuICAgIGNvbnN0IHhjID0gc3RhdGUuY3ljbGVPZkxpbmUrKztcclxuICAgIGNvbnN0IHkgPSBzdGF0ZS5saW5lT2ZSYXN0ZXI7XHJcblxyXG4gICAgY29uc3Qgc2VxdWVuY2UgPSBnZXQ4UGl4ZWxzKHhjLCB5KTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlcXVlbmNlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIFxyXG4gICAgICBsZXQgcmdiID0gc2VxdWVuY2VbaV07XHJcblxyXG4gICAgICBpZiAoc3RhdGUuc3RhdGljKSB7XHJcbiAgICAgICAgY29uc3QgcmFuZCA9IE1hdGgucmFuZG9tKCk7XHJcbiAgICAgICAgaWYgICAgICAocmFuZCA8IDAuNikgcmdiID0gMHgwMDAwMDA7XHJcbiAgICAgICAgZWxzZSBpZiAocmFuZCA8IDAuNykgcmdiID0gMHg0NDQ0NDQ7XHJcbiAgICAgICAgZWxzZSBpZiAocmFuZCA8IDAuOCkgcmdiID0gMHg4ODg4ODg7XHJcbiAgICAgICAgZWxzZSBpZiAocmFuZCA8IDAuOSkgcmdiID0gMHhjY2NjY2M7XHJcbiAgICAgICAgZWxzZSAgICAgICAgICAgICAgICAgcmdiID0gMHhmZmZmZmY7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHggPSAoeGMgKiA4KSArIGk7XHJcbiAgICAgIFxyXG4gICAgICBzZXRQaXhlbChcclxuICAgICAgICB4LFxyXG4gICAgICAgIHksXHJcbiAgICAgICAgKChyZ2IgJiAweGZmMDAwMCkgPj4gMTYpLFxyXG4gICAgICAgICgocmdiICYgMHgwMGZmMDApID4+ICA4KSxcclxuICAgICAgICAoKHJnYiAmIDB4MDAwMGZmKSA+PiAgMCksXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTGluZSB1cCBsb2dpYyBmb3IgbmV4dCBjeWNsZVxyXG5cclxuICAgIGlmIChzdGF0ZS5iYWRsaW5lKSBmZXRjaE5leHRSb3dPZkNoYXJNYXRyaXgoKTtcclxuXHJcbiAgICAvLyBMb2FkIGJsYWNrIHdoZXJlIHdlIGRvbid0IGhhdmUgYW55dGhpbmcgZWxzZSB0byBsb2FkLiBUaGlzIGlzIGJhZC5cclxuICAgIC8vIFNldCBpdCB0byB3aGl0ZSAoMHgxMTExMTExMSkgYW5kIHlvdSdsbCBzZWUgaXQgYmxlZWQgdGhyb3VnaCBpbiBXaXpiYWxsLlxyXG4gICAgaWYgKHN0YXRlLmN5Y2xlT2ZMaW5lID09PSAxNikge1xyXG4gICAgICBzdGF0ZS5iZ1F1ZXVlUG9zID0gMDtcclxuICAgICAgc3RhdGUuYmdSZ2JRdWV1ZSAuZmlsbCgwKTsgLy8gY29sb3IgY29kZSAwID0gYmxhY2tcclxuICAgICAgc3RhdGUuYmdNYXNrUXVldWUuZmlsbCgwKTtcclxuICAgIH1cclxuXHJcbiAgICBlbHNlIGlmICgoc3RhdGUuY3ljbGVPZkxpbmUgPj0gMTcpICYmIChzdGF0ZS5jeWNsZU9mTGluZSA8IDU3KSkge1xyXG4gICAgICBsb2FkTmV4dEJnQnl0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdGF0ZS5jeWNsZU9mTGluZSA9PT0gMTcpIHtcclxuICAgICAgaWYgKHN0YXRlLmZvcnR5Q29sdW1ucykgc3RhdGUudmZsYWcgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGVsc2UgaWYgKHN0YXRlLmN5Y2xlT2ZMaW5lID09PSAxOCkge1xyXG4gICAgICBpZiAoIXN0YXRlLmZvcnR5Q29sdW1ucykgc3RhdGUudmZsYWcgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGVsc2UgaWYgKHN0YXRlLmN5Y2xlT2ZMaW5lID09PSA1Nikge1xyXG4gICAgICBpZiAoIXN0YXRlLmZvcnR5Q29sdW1ucykgc3RhdGUudmZsYWcgPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIGVsc2UgaWYgKHN0YXRlLmN5Y2xlT2ZMaW5lID09PSA1Nykge1xyXG4gICAgICBpZiAoc3RhdGUuZm9ydHlDb2x1bW5zKSBzdGF0ZS52ZmxhZyA9IDE7XHJcbiAgICB9XHJcblxyXG4gICAgZWxzZSBpZiAoc3RhdGUuY3ljbGVPZkxpbmUgPj0gNjMpIHtcclxuXHJcbiAgICAgIGZldGNoU3ByaXRlU2VxdWVuY2VzRm9yTGluZSgpO1xyXG5cclxuICAgICAgc3RhdGUuY3ljbGVPZkxpbmUgPSAwO1xyXG4gICAgICBzdGF0ZS5saW5lT2ZSYXN0ZXIrKztcclxuICAgICAgb25OZXdMaW5lKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoIXN0YXRlLmN5Y2xlc1VudGlsUmFzdGVySW5jLS0pIHtcclxuXHJcbiAgICAvLyBXZSdyZSBvbiBhIG5ldyByYXN0ZXIgbGluZS4gVXBkYXRlIG91ciBjb3VudCwgYW5kIG1heWJlIHRyaWdnZXIgYW4gaW50ZXJydXB0XHJcblxyXG4gICAgaWYgKCsrc3RhdGUucmFzdGVyID49IDMxMikge1xyXG4gICAgICBzdGF0ZS5yYXN0ZXIgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdGF0ZS5yYXN0ZXIgPT09IHN0YXRlLnJhc3RlcklycSkge1xyXG4gICAgICByYXN0ZXJNaWdodElycSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRlLmN5Y2xlc1VudGlsUmFzdGVySW5jID0gNjI7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBtYWtlUmVhZCgpIHtcclxuXHJcbiAgY29uc3QgZm5zID0ge307XHJcblxyXG4gIC8vIE9uZS1ieXRlLXBlci1zcHJpdGUgcmVnaXN0ZXJzXHJcbiAgZm9yIChsZXQgc3ByaXRlID0gMDsgc3ByaXRlIDwgODsgc3ByaXRlKyspIHtcclxuXHJcbiAgICAvLyBYIGNvLW9yZCBiaXRzIDAtNyAoJGQwMDAsICRkMDAyLCAkZDAwNCwgLi4uKVxyXG4gICAgZm5zWyhzcHJpdGUgKiAyKSArIDBdID0gKCkgPT4gc3RhdGUuc3ByaXRlc1tzcHJpdGVdLnggJiAweGZmO1xyXG5cclxuICAgIC8vIFkgY28tb3JkICgkZDAwMSwgJGQwMDMsICRkMDA1LCAuLi4pXHJcbiAgICBmbnNbKHNwcml0ZSAqIDIpICsgMV0gPSAoKSA9PiBzdGF0ZS5zcHJpdGVzW3Nwcml0ZV0ueTtcclxuXHJcbiAgICAvLyBDb2xvciAoJGQwMjcsICRkMDI4LCAkZDAyOSwgLi4uKVxyXG4gICAgZm5zWyhzcHJpdGUgKiAxKSArIDB4MjddID0gKCkgPT4gc3RhdGUuc3ByaXRlc1tzcHJpdGVdLmNvbG9yO1xyXG4gIH1cclxuXHJcbiAgLy8gT25lLWJpdC1wZXItc3ByaXRlIHJlZ2lzdGVyc1xyXG4gIGNvbnN0IG9uZUJpdFBlclNwcml0ZSA9IChmbikgPT4gKCkgPT4ge1xyXG4gICAgbGV0IHJldCA9IDA7XHJcbiAgICBmb3IgKGxldCBzcHJpdGVOdW0gPSAwOyBzcHJpdGVOdW0gPCA4OyBzcHJpdGVOdW0rKykge1xyXG4gICAgICByZXQgfD0gKGZuKHN0YXRlLnNwcml0ZXNbc3ByaXRlTnVtXSkgPyAoMSA8PCBzcHJpdGVOdW0pIDogMCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG4gIH07XHJcblxyXG4gIC8vICRkMDEwIC0gYml0IDggb2YgWCBjby1vcmRzXHJcbiAgZm5zWzB4MTBdID0gb25lQml0UGVyU3ByaXRlKChzcHJpdGUpID0+IHNwcml0ZS54ICYgMHgxMDApO1xyXG5cclxuICAvLyAkZDAxNSAtIGVuYWJsZVxyXG4gIGZuc1sweDE1XSA9IG9uZUJpdFBlclNwcml0ZSgoc3ByaXRlKSA9PiBzcHJpdGUuZW5hYmxlZCk7XHJcblxyXG4gIC8vICRkMDE3IC0gZG91YmxlIGhlaWdodFxyXG4gIGZuc1sweDE3XSA9IG9uZUJpdFBlclNwcml0ZSgoc3ByaXRlKSA9PiBzcHJpdGUueDJoKTtcclxuXHJcbiAgLy8gJGQwMWIgLSBwcmlvdGl5XHJcbiAgZm5zWzB4MWJdID0gb25lQml0UGVyU3ByaXRlKChzcHJpdGUpID0+IHNwcml0ZS5iZWhpbmQpO1xyXG5cclxuICAvLyAkZDAxYyAtIG11bHRpY29sb3IgbW9kZVxyXG4gIGZuc1sweDFjXSA9IG9uZUJpdFBlclNwcml0ZSgoc3ByaXRlKSA9PiBzcHJpdGUubWNtKTtcclxuXHJcbiAgLy8gJGQwMWQgLSBkb3VibGUgd2lkdGhcclxuICBmbnNbMHgxZF0gPSBvbmVCaXRQZXJTcHJpdGUoKHNwcml0ZSkgPT4gc3ByaXRlLngydyk7XHJcblxyXG4gIC8vICRkMDFlIC0gc3ByaXRlLXNwcml0ZSBjb2xsaXNpb25cclxuICBmbnNbMHgxZV0gPSAoKSA9PiB7XHJcbiAgICAvLyDigKAxIHNheXM6XHJcbiAgICAvL1xyXG4gICAgLy8gICAgXCJUaGUgcmVnaXN0ZXJzICRkMDFlIGFuZCAkZDAxZiBjYW5ub3QgYmUgd3JpdHRlbiBhbmQgYXJlIGF1dG9tYXRpY2FsbHlcclxuICAgIC8vICAgIGNsZWFyZWQgb24gcmVhZGluZ1wiXHJcbiAgICAvL1xyXG4gICAgLy8g4oCgMiBzYXlzOlxyXG4gICAgLy9cclxuICAgIC8vICAgIFwiV3JpdGU6IEVuYWJsZSBmdXJ0aGVyIGRldGVjdGlvbiBvZiBzcHJpdGUtc3ByaXRlIGNvbGxpc2lvbnMuXCJcclxuICAgIC8vXHJcbiAgICAvLyBJJ20gZ29pbmcgd2l0aCDigKAxXHJcbiAgICBjb25zdCByZXQgPSBzdGF0ZS5zcHJTcHJDb2w7XHJcbiAgICBzdGF0ZS5zcHJTcHJDb2wgPSAwO1xyXG4gICAgcmV0dXJuIHJldDtcclxuICB9XHJcblxyXG4gIC8vICRkMDFmIC0gc3ByaXRlLWJhY2tncm91bmQgY29sbGlzaW9uXHJcbiAgZm5zWzB4MWZdID0gKCkgPT4ge1xyXG4gICAgY29uc3QgcmV0ID0gc3RhdGUuc3ByQmdDb2w7XHJcbiAgICBzdGF0ZS5zcHJCZ0NvbCA9IDA7XHJcbiAgICByZXR1cm4gcmV0O1xyXG4gIH1cclxuXHJcbiAgLy8gJGQwMjA6IEJvcmRlciBjb2xvclxyXG4gIGZuc1sweDIwXSA9ICgpID0+IDB4ZjAgfCBzdGF0ZS5ib3JkZXJDb2xvcjtcclxuXHJcbiAgLy8gJGQwMjE6IEJhY2tncm91bmQgY29sb3JcclxuICBmbnNbMHgyMV0gPSAoKSA9PiAweGYwIHwgc3RhdGUuYmFja2dyb3VuZENvbG9yO1xyXG5cclxuICAvLyAkZDAyMjogRXh0cmEgYmFja2dyb3VuZCBjb2xvciAxXHJcbiAgZm5zWzB4MjJdID0gKCkgPT4gMHhmMCB8IHN0YXRlLmV4dHJhQmdDb2xvcjE7XHJcblxyXG4gIC8vICRkMDIzOiBFeHRyYSBiYWNrZ3JvdW5kIGNvbG9yIDJcclxuICBmbnNbMHgyM10gPSAoKSA9PiAweGYwIHwgc3RhdGUuZXh0cmFCZ0NvbG9yMjtcclxuXHJcbiAgLy8gJGQwMjQ6IEV4dHJhIGJhY2tncm91bmQgY29sb3IgM1xyXG4gIGZuc1sweDI0XSA9ICgpID0+IDB4ZjAgfCBzdGF0ZS5leHRyYUJnQ29sb3IzO1xyXG5cclxuICAvLyAkZDAyNTogU3ByaXRlIG11bHRpY29sb3IgY29sb3IgMFxyXG4gIGZuc1sweDI1XSA9ICgpID0+IHN0YXRlLnNwcml0ZU11bHRpY29sb3JDb2xvcjA7XHJcblxyXG4gIC8vICRkMDI2OiBTcHJpdGUgZXh0cmEgY29sb3IgMlxyXG4gIGZuc1sweDI2XSA9ICgpID0+IHN0YXRlLnNwcml0ZU11bHRpY29sb3JDb2xvcjE7XHJcblxyXG5cclxuICAvLyAkZDAxODogTWVtb3J5IHNldHVwXHJcbiAgZm5zWzB4MThdID0gKCkgPT4gc3RhdGUubWVtb3J5U2V0dXA7XHJcblxyXG4gIC8vICRkMDE5OiBJbnRlcnJ1cHQgc3RhdHVzXHJcbiAgLy8gVE9ETzogZG9lcyByZWFsIGhhcmR3YXJlIHNldCB1bnVzZWQgYml0cyBoaWdoP1xyXG4gIGZuc1sweDE5XSA9ICgpID0+IHN0YXRlLmludGVycnVwdFN0YXR1cyB8IChzdGF0ZS5pcnEgPyAwYjEwMDAwMDAwIDogMCk7XHJcblxyXG4gIC8vICRkMDFhOiBJbnRlcnJ1cHQgY29udHJvbFxyXG4gIC8vIFRPRE86IGRvZXMgcmVhbCBoYXJkd2FyZSBzZXQgdW51c2VkIGJpdHMgaGlnaD9cclxuICBmbnNbMHgxYV0gPSAoKSA9PiBzdGF0ZS5pbnRlcnJ1cHRDb250cm9sIHwgMHhmMDtcclxuXHJcblxyXG4gIC8vICRkMDEzOiAoUmVhZC1vbmx5KSBsaWdodCBwZW4gWFxyXG4gIGZuc1sweDEzXSA9ICgpID0+IHtcclxuICAgIC8vIFdpdGggbm90aGluZyBjb25uZWN0ZWQsIHJlYWwgaGFyZHdhcmUganVzdCBzZWVtcyB0byBlbWl0IG5vaXNlIGZvciB0aGVcclxuICAgIC8vIGxpZ2h0IHBlbiByZWdpc3RlcnMuIFByZXZpb3VzbHksIHdlJ2Qgc291bmQgYSB3YXJuaW5nIGFib3V0XHJcbiAgICAvLyB1bmltcGxlbWVudGVkIGZ1bmN0aW9uYWxpdHkgb24gYWNjZXNzZXMsIGJ1dCBsb3RzIG9mIHNvZnR3YXJlIHNlZW1zIHRvXHJcbiAgICAvLyB0b3VjaCB0aGVtIGZvciBubyBhcHBhcmVudCByZWFzb24sIHNvIGhlcmUgd2UncmUganVzdCByZXR1cm5pbmcgb25lIG9mXHJcbiAgICAvLyBtYW55IHZhbHVlcyB0aGF0IEkndmUgc2VlbiBhcHBlYXIgb24gcmVhbCBoYXJkd2FyZS5cclxuICAgIHJldHVybiAyMTM7XHJcbiAgfVxyXG5cclxuICAvLyAkZDAxNDogKFJlYWQtb25seSkgbGlnaHQgcGVuIFlcclxuICBmbnNbMHgxNF0gPSAoKSA9PiB7XHJcbiAgICAvLyBBcyBhYm92ZVxyXG4gICAgcmV0dXJuIDEyMDtcclxuICB9XHJcblxyXG4gIC8vICRkMDExOiBjdXJyZW50IHJhc3RlciBsaW5lIGJpdCA4XHJcbiAgZm5zWzB4MTFdID0gKCkgPT4gKFxyXG4gICAgLy8gYml0IDc6IGJpdCA4IG9mIHRoZSByYXN0ZXIgbGluZSBudW1iZXJcclxuICAgICgoc3RhdGUucmFzdGVyICYgMHgxMDApID8gMHg4MCA6IDB4MDApIHxcclxuXHJcbiAgICAvLyBiaXQgNjogZXh0ZW5kZWQgYmFja2dyb3VuZCBtb2RlXHJcbiAgICAoc3RhdGUuZXh0ZW5kZWRCZyA/ICgxIDw8IDYpIDogMCkgfFxyXG5cclxuICAgIC8vIGJpdCA1OiBiaXRtYXAgbW9kZVxyXG4gICAgKHN0YXRlLmJpdG1hcCA/ICgxIDw8IDUpIDogMCkgfFxyXG5cclxuICAgIC8vIGJpdCA0OiBkaXNwbGF5IGVuYWJsZVxyXG4gICAgKHN0YXRlLmRpc3BsYXlFbmFibGUgPyAoMSA8PCA0KSA6IDApIHxcclxuXHJcbiAgICAvLyBiaXQgMzogMjUtcm93IG1vZGVcclxuICAgIChzdGF0ZS50d2VudHlGaXZlUm93cyA/ICgxIDw8IDMpIDogMCkgfFxyXG5cclxuICAgIC8vIGJpdHMgMC0yOiB2ZXJ0aWNhbCByYXN0ZXIgc2Nyb2xsXHJcbiAgICBzdGF0ZS55c2Nyb2xsXHJcblxyXG4gICAgLy8gVE9ETzogYW5kIHRoZXJlJ3MgbW9yZVxyXG4gICk7XHJcblxyXG4gIC8vICRkMDEyLCBjdXJyZW50IHJhc3RlciBsaW5lIGJpdHMgMC03XHJcbiAgZm5zWzB4MTJdID0gKCkgPT4gc3RhdGUucmFzdGVyICYgMHhmZjtcclxuXHJcbiAgLy8gJGQwMTYsIFNjcmVlbiBjb250cm9sIHJlZ2lzdGVyICMyXHJcbiAgZm5zWzB4MTZdID0gKCkgPT4gKFxyXG4gICAgc3RhdGUueHNjcm9sbCB8XHJcbiAgICAoc3RhdGUubXVsdGljb2xvciAgID8gMHgxMCA6IDB4MDApIHxcclxuICAgIChzdGF0ZS5mb3J0eUNvbHVtbnMgPyAweDA4IDogMHgwMCkgfFxyXG5cclxuICAgIC8vIFRPRE86IOKAoDIgc2F5cyBkZWZhdWx0IGlzICUxMTAwMTAwMC4gQnV0IGJpdCA1IGRvZXNuJ3Qgc2VlbSB0byBiZVxyXG4gICAgLy8gYW55dGhpbmcuIElzIHRoYXQgY29ycmVjdD8gQ2hlY2sgb24gcmVhbCBoYXJkd2FyZVxyXG4gICAgMGIxMTEwMDAwMFxyXG4gICk7XHJcblxyXG4gIC8vICRkMDJmIC0gJGQwM2Y6IHVubWFwcGVkXHJcbiAgZm9yIChsZXQgcmVnID0gMHgyZjsgcmVnIDw9IDB4M2Y7IHJlZysrKSB7XHJcbiAgICAvLyBUT0RPOiBwcmV0dHkgc3VyZSwgYnV0IGRvdWJsZS1jaGVjayBpdCdzIDB4ZmYuXHJcbiAgICBmbnNbcmVnXSA9ICgpID0+IDB4ZmY7XHJcbiAgfVxyXG5cclxuICAvLyBSZWdzIGFyZSBmcm9tICRkMDAwLSRkMDNmLCB3aXRoIGRlZ2VuZXJhdGUgY29waWVzIHRocm91Z2ggJGQzZmZcclxuICByZXR1cm4gKGFkZHIpID0+IGZuc1thZGRyICYgMHgzZl0oKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbWFrZVdyaXRlKCkge1xyXG4gIGNvbnN0IGZucyA9IHt9O1xyXG5cclxuICAvLyBPbmUtYnl0ZS1wZXItc3ByaXRlIHJlZ2lzdGVyc1xyXG4gIGZvciAobGV0IHNwcml0ZSA9IDA7IHNwcml0ZSA8IDg7IHNwcml0ZSsrKSB7XHJcblxyXG4gICAgLy8gWCBjby1vcmQgYml0cyAwLTcgKCRkMDAwLCAkZDAwMiwgJGQwMDQsIC4uLilcclxuICAgIGZuc1soc3ByaXRlICogMikgKyAwXSA9IChieXRlKSA9PiBzdGF0ZS5zcHJpdGVzW3Nwcml0ZV0ueCA9IChzdGF0ZS5zcHJpdGVzW3Nwcml0ZV0ueCAmIDB4MTAwKSB8IGJ5dGU7XHJcblxyXG4gICAgLy8gWSBjby1vcmQgKCRkMDAxLCAkZDAwMywgJGQwMDUsIC4uLilcclxuICAgIGZuc1soc3ByaXRlICogMikgKyAxXSA9IChieXRlKSA9PiBzdGF0ZS5zcHJpdGVzW3Nwcml0ZV0ueSA9IGJ5dGU7XHJcblxyXG4gICAgLy8gQ29sb3IgKCRkMDI3LCAkZDAyOCwgJGQwMjksIC4uLilcclxuICAgIGZuc1soc3ByaXRlICogMSkgKyAweDI3XSA9IChieXRlKSA9PiBzdGF0ZS5zcHJpdGVzW3Nwcml0ZV0uY29sb3IgPSBieXRlICYgMHhmO1xyXG4gIH1cclxuXHJcbiAgLy8gT25lLWJpdC1wZXItc3ByaXRlIHJlZ2lzdGVyc1xyXG4gIGNvbnN0IG9uZUJpdFBlclNwcml0ZSA9IChmbikgPT4gKGJ5dGUpID0+IHtcclxuICAgIGxldCByZXQgPSAwO1xyXG4gICAgZm9yIChsZXQgc3ByaXRlTnVtID0gMDsgc3ByaXRlTnVtIDwgODsgc3ByaXRlTnVtKyspIHtcclxuICAgICAgZm4oc3RhdGUuc3ByaXRlc1tzcHJpdGVOdW1dLCBCb29sZWFuKGJ5dGUgJiAoMSA8PCBzcHJpdGVOdW0pKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG4gIH07XHJcblxyXG4gIC8vICRkMDEwIC0gYml0IDggb2YgWCBjby1vcmRzXHJcbiAgZm5zWzB4MTBdID0gb25lQml0UGVyU3ByaXRlKChzcHJpdGUsIGJpdCkgPT4gc3ByaXRlLnggPSBiaXQgPyAoc3ByaXRlLnggfCAweDEwMCkgOiAoc3ByaXRlLnggJiAweGZmKSk7XHJcbiAgZm5zWzB4MTVdID0gb25lQml0UGVyU3ByaXRlKChzcHJpdGUsIGJpdCkgPT4gc3ByaXRlLmVuYWJsZWQgPSBiaXQpOyAgLy8gJGQwMTUgLSBlbmFibGVcclxuICBmbnNbMHgxN10gPSBvbmVCaXRQZXJTcHJpdGUoKHNwcml0ZSwgYml0KSA9PiBzcHJpdGUueDJoICAgICA9IGJpdCk7ICAvLyAkZDAxNyAtIGRvdWJsZSBoZWlnaHRcclxuICBmbnNbMHgxYl0gPSBvbmVCaXRQZXJTcHJpdGUoKHNwcml0ZSwgYml0KSA9PiBzcHJpdGUuYmVoaW5kICA9IGJpdCk7ICAvLyAkZDAxYiAtIHByaW9yaXR5XHJcbiAgZm5zWzB4MWNdID0gb25lQml0UGVyU3ByaXRlKChzcHJpdGUsIGJpdCkgPT4gc3ByaXRlLm1jbSAgICAgPSBiaXQpOyAgLy8gJGQwMWMgLSBtdWx0aWNvbG9yIG1vZGVcclxuICBmbnNbMHgxZF0gPSBvbmVCaXRQZXJTcHJpdGUoKHNwcml0ZSwgYml0KSA9PiBzcHJpdGUueDJ3ICAgICA9IGJpdCk7ICAvLyAkZDAxZCAtIGRvdWJsZSB3aWR0aFxyXG5cclxuXHJcbiAgLy8gJGQwMWUgLSBzcHJpdGUtc3ByaXRlIGNvbGxpc2lvblxyXG4gIGZuc1sweDFlXSA9IChieXRlKSA9PiBzdGF0ZS5zcHJTcHJDb2wgPSBieXRlO1xyXG5cclxuICAvLyAkZDAxZiAtIHNwcml0ZS1iYWNrZ3JvdW5kIGNvbGxpc2lvblxyXG4gIGZuc1sweDFmXSA9IChieXRlKSA9PiBzdGF0ZS5zcHJCZ0NvbCA9IGJ5dGU7XHJcblxyXG5cclxuICAvLyAkZDAxMSwgc2NyZWVuIGNvbnRyb2wgcmVnaXN0ZXIgMSwgY3VycmVudCByYXN0ZXIgbGluZSBiaXQgOFxyXG4gIGZuc1sweDExXSA9IChieXRlKSA9PiB7XHJcbiAgICAvLyB1cGRhdGUgb3VyIHZpZXcgb2YgcmFzdGVyIElSUSBsaW5lIHNldHRpbmcsXHJcbiAgICAvLyBhbmQgZmFsbCB0aHJvdWdoIHRvIHVwZGF0ZSB0aGUgcmVzdCBvZiB0aGUgcmVnaXN0ZXJcclxuICAgIGNvbnN0IHJhc3RlckJpdDggPSAoYnl0ZSAmIDB4ODApIDw8IDE7XHJcblxyXG4gICAgc3RhdGUucmFzdGVySXJxICY9IDB4ZmY7XHJcbiAgICBzdGF0ZS5yYXN0ZXJJcnEgfD0gcmFzdGVyQml0ODtcclxuXHJcbiAgICBzdGF0ZS55c2Nyb2xsICAgICAgICA9ICAgICAgICAgYnl0ZSAmIDBiMDAwMDAxMTE7XHJcbiAgICBzdGF0ZS50d2VudHlGaXZlUm93cyA9IEJvb2xlYW4oYnl0ZSAmIDBiMDAwMDEwMDApO1xyXG4gICAgc3RhdGUuZGlzcGxheUVuYWJsZSAgPSBCb29sZWFuKGJ5dGUgJiAwYjAwMDEwMDAwKTtcclxuICAgIHN0YXRlLmJpdG1hcCAgICAgICAgID0gQm9vbGVhbihieXRlICYgMGIwMDEwMDAwMCk7XHJcbiAgICBzdGF0ZS5leHRlbmRlZEJnICAgICA9IEJvb2xlYW4oYnl0ZSAmIDBiMDEwMDAwMDApO1xyXG4gIH07XHJcblxyXG4gIC8vICRkMDEyLCBjdXJyZW50IHJhc3RlciBsaW5lIGJpdHMgMC03XHJcbiAgZm5zWzB4MTJdID0gKGJ5dGUpID0+IHtcclxuICAgIGNvbnN0IHJhc3RlckJpdDggPSBzdGF0ZS5yYXN0ZXJJcnEgJiAweDEwMDtcclxuICAgIHN0YXRlLnJhc3RlcklycSA9IGJ5dGUgfCByYXN0ZXJCaXQ4O1xyXG4gIH07XHJcblxyXG4gIC8vICRkMDEzLCBMaWdodCBwZW4gWC1jb29yZGluYXRlIChyZWFkLW9ubHkpXHJcbiAgLy8gJGQwMTQsIExpZ2h0IHBlbiBZLWNvb3JkaW5hdGUgKHJlYWQtb25seSlcclxuICBmbnNbMHgxM10gPSAoKSA9PiB7fTtcclxuICBmbnNbMHgxNF0gPSAoKSA9PiB7fTtcclxuXHJcbiAgLy8gJGQwMTYsIFNjcmVlbiBjb250cm9sIHJlZ2lzdGVyICMyXHJcbiAgZm5zWzB4MTZdID0gKGJ5dGUpID0+IHsgICAgXHJcbiAgICBzdGF0ZS54c2Nyb2xsICAgICAgPSBieXRlICYgMHg3O1xyXG4gICAgc3RhdGUubXVsdGljb2xvciAgID0gQm9vbGVhbihieXRlICYgMHgxMCk7XHJcbiAgICBzdGF0ZS5mb3J0eUNvbHVtbnMgPSBCb29sZWFuKGJ5dGUgJiAweDA4KTtcclxuICAgIC8vIFRPRE86IGFuZCB0aGVyZSdzIG90aGVyIGJpdHNcclxuICB9O1xyXG5cclxuICAvLyAkZDAxOCwgTWVtb3J5IHNldHVwXHJcbiAgZm5zWzB4MThdID0gKGJ5dGUpID0+IHN0YXRlLm1lbW9yeVNldHVwID0gYnl0ZTtcclxuICBcclxuICAvLyAkZDAxOTogSW50ZXJydXB0IGFja25vd2xlZGdlXHJcbiAgZm5zWzB4MTldID0gKGJ5dGUpID0+IHtcclxuXHJcbiAgICAvLyBjbGVhciB0aGUgYml0cyB0aGF0IHRoZSB3cml0ZXIncyBhc2tpbmcgdXMgdG9cclxuICAgIHN0YXRlLmludGVycnVwdFN0YXR1cyAmPSB+Ynl0ZTtcclxuICAgIHN0YXRlLmludGVycnVwdFN0YXR1cyAmPSAweDBmO1xyXG5cclxuICAgIHJlY29uc2lkZXJWaWNJcnEoKTtcclxuICB9O1xyXG5cclxuICAvLyAkZDAxYSwgSW50ZXJydXB0IGNvbnRyb2wgcmVnaXN0ZXJcclxuICBmbnNbMHgxYV0gPSAoYnl0ZSkgPT4geyAgICBcclxuICAgIHN0YXRlLmludGVycnVwdENvbnRyb2wgPSBieXRlICYgMHhmO1xyXG5cclxuICAgIGlmIChieXRlICYgMHg4KSB1bmltcGxlbWVudGVkV2FybmluZyhcImxpZ2h0IHBlbiBpbnRlcnJ1cHRzXCIpO1xyXG5cclxuICAgIC8vIFRPRE86IGlmIGFuIGludGVycnVwdCBpc24ndCBlbmFibGVkIG5vdywgYnV0IHdhcyByZXNwb25zaWJsZSBmb3IgcHVsbGluZ1xyXG4gICAgLy8gdGhlIElSUSBsaW5lIGxvdywgSSBndWVzcyB0aGF0IG1lYW5zIGl0J2xsIG5vIGxvbmdlciBiZSBwdWxsaW5nIHRoZSBJUlFcclxuICAgIC8vIGxpbmUgbG93PyBJcyB0aGlzIGhvdyByZWFsIGhhcmR3YXJlIG9wZXJhdGVzP1xyXG5cclxuICAgIHJlY29uc2lkZXJWaWNJcnEoKTtcclxuICB9O1xyXG5cclxuICBmbnNbMHgyMF0gPSAoYnl0ZSkgPT4gc3RhdGUuYm9yZGVyQ29sb3IgICAgICAgICAgICA9IGJ5dGUgJiAweGY7ICAvLyAkZDAyMCwgQm9yZGVyIGNvbG9yXHJcbiAgZm5zWzB4MjFdID0gKGJ5dGUpID0+IHN0YXRlLmJhY2tncm91bmRDb2xvciAgICAgICAgPSBieXRlICYgMHhmOyAgLy8gJGQwMjEsIEJhY2tncm91bmQgY29sb3JcclxuICBmbnNbMHgyMl0gPSAoYnl0ZSkgPT4gc3RhdGUuZXh0cmFCZ0NvbG9yMSAgICAgICAgICA9IGJ5dGUgJiAweGY7ICAvLyAkZDAyMiwgRXh0cmEgYmFja2dyb3VuZCBjb2xvciAxXHJcbiAgZm5zWzB4MjNdID0gKGJ5dGUpID0+IHN0YXRlLmV4dHJhQmdDb2xvcjIgICAgICAgICAgPSBieXRlICYgMHhmOyAgLy8gJGQwMjMsIEV4dHJhIGJhY2tncm91bmQgY29sb3IgMlxyXG4gIGZuc1sweDI0XSA9IChieXRlKSA9PiBzdGF0ZS5leHRyYUJnQ29sb3IzICAgICAgICAgID0gYnl0ZSAmIDB4ZjsgIC8vICRkMDI0LCBFeHRyYSBiYWNrZ3JvdW5kIGNvbG9yIDNcclxuICBmbnNbMHgyNV0gPSAoYnl0ZSkgPT4gc3RhdGUuc3ByaXRlTXVsdGljb2xvckNvbG9yMCA9IGJ5dGUgJiAweGY7ICAvLyAkZDAyNTogU3ByaXRlIG11bHRpY29sb3IgY29sb3IgMFxyXG4gIGZuc1sweDI2XSA9IChieXRlKSA9PiBzdGF0ZS5zcHJpdGVNdWx0aWNvbG9yQ29sb3IxID0gYnl0ZSAmIDB4ZjsgIC8vICRkMDI2OiBTcHJpdGUgZXh0cmEgY29sb3IgMlxyXG5cclxuICAvLyAkZDAyZiAtICRkMDNmOiB1bm1hcHBlZFxyXG4gIGZvciAobGV0IHJlZyA9IDB4MmY7IHJlZyA8PSAweDNmOyByZWcrKykge1xyXG4gICAgZm5zW3JlZ10gPSAoKSA9PiB7fTtcclxuICB9XHJcblxyXG4gIC8vIHJlZ3MgYXJlIGZyb20gJGQwMDAtJGQwM2YsIHdpdGggZGVnZW5lcmF0ZSBjb3BpZXMgdGhyb3VnaCAkZDNmZlxyXG4gIHJldHVybiAoYWRkciwgYnl0ZSkgPT4gZm5zW2FkZHIgJiAweDNmXShieXRlKTtcclxufTtcclxuXHJcbmNvbnN0IHJlYWRfZDAwMF9kM2ZmID0gbWFrZVJlYWQoKTtcclxuXHJcbmZ1bmN0aW9uIHJlYWRfZDgwMF9kYmZmKGFkZHIpIHtcclxuICByZXR1cm4gc3RhdGUuY29sb3JbYWRkciAtIDB4ZDgwMF0gfCAweGYwO1xyXG59XHJcblxyXG5jb25zdCB3cml0ZV9kMDAwX2QzZmYgPSBtYWtlV3JpdGUoKTtcclxuXHJcbmZ1bmN0aW9uIHdyaXRlX2Q4MDBfZGJmZihhZGRyLCBieXRlKSB7XHJcbiAgc3RhdGUuY29sb3JbYWRkciAtIDB4ZDgwMF0gPSBieXRlICYgMHhmO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzaG93U3RhdGljKCkge1xyXG4gIHN0YXRlLnN0YXRpYyA9IHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldElnbm9yZVNwckJnQ29sKGlnbm9yZSkge1xyXG4gIGNvbmZpZy5pZ25vcmVTcHJCZ0NvbGxpc2lvbnMgPSBpZ25vcmU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldElnbm9yZVNwclNwckNvbChpZ25vcmUpIHtcclxuICBjb25maWcuaWdub3JlU3ByU3ByQ29sbGlzaW9ucyA9IGlnbm9yZTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0U2NvcGUoa2V5KSB7XHJcbiAgLy8gTm90IHRoZSBtb3N0IGVsZWdhbnQuLi5cclxuICBmb3IgKGxldCBpIGluIGNvbmZpZykge1xyXG4gICAgaWYgKC9ec2NvcGUvLnRlc3QoaSkpIHtcclxuICAgICAgY29uZmlnW2ldID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIGlmIChrZXkpIGNvbmZpZ1trZXldID0gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2VyaWFsaXplKCkge1xyXG4gIC8vIFRyYW5zZmVyIHRoZSBzcGVjaWFsIGFycmF5cyB0byByZWd1bGFyIGFycmF5c1xyXG4gIC8vIChPdGhlcndpc2UgdGhleSdsbCBnZXQgc2VyaWFsaXplZCBhcyB7IDA6Li4uLCAxOi4uLiwgMjouLi4sIC4uLn0pXHJcbiAgY29uc3Qgc3RhdGVDb3B5ID0gey4uLnN0YXRlfTtcclxuXHJcbiAgZm9yIChsZXQgW2tleSwgdHlwZSwgc2l6ZV0gb2Ygc3BlY2lhbFN0YXRlVmFsdWVzKSB7XHJcbiAgICBzdGF0ZUNvcHlba2V5XSA9IFtdO1xyXG5cclxuICAgIGZvciAobGV0IGkgaW4gc3RhdGVba2V5XSkge1xyXG4gICAgICAvLyBTaG91bGQgd2FybiBpZiB3ZSBzZWUgdW5leHBlY3RlZCBrZXlzXHJcbiAgICAgIHN0YXRlQ29weVtrZXldW2ldID0gc3RhdGVba2V5XVtpXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0ZUNvcHkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZShqc29uKSB7XHJcbiAgc3RhdGUgPSBKU09OLnBhcnNlKGpzb24pO1xyXG5cclxuICAvLyBUcmFuc2ZlciB0aGUgYXJyYXlzIHRvIHNwZWNpYWwgYXJyYXlzXHJcbiAgZm9yIChsZXQgW2tleSwgdHlwZSwgc2l6ZV0gb2Ygc3BlY2lhbFN0YXRlVmFsdWVzKSB7XHJcbiAgICBjb25zdCBhcnIgPSBuZXcgdHlwZShzaXplKTtcclxuXHJcbiAgICAvLyBTaG91bGQgd2FybiBpZiBzaXplcyBkb24ndCBtYXRjaCFcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGVba2V5XS5sZW5ndGg7IGkrKykge1xyXG4gICAgICBhcnJbaV0gPSBzdGF0ZVtrZXldW2ldO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRlW2tleV0gPSBhcnI7XHJcbiAgfVxyXG59XHJcbiIsIi8qXHJcbiAgIHdpcmVzOiBwcm92aWRlcyBhIHN5c3RlbSBmb3IgaW50ZXJjb25uZWN0aW5nIHRoZSBoYXJkd2FyZSBkZXZpY2VzXHJcblxyXG4gICB3aXJlcyBpcyB0aGUgb25lIHBhcnQgb2YgdGhlIHN5c3RlbSB0aGF0IHRoZSBicmluZ3VwIHByb2Nlc3MgZ3VhcmFudGVlcyBpc1xyXG4gICBpbiBwbGFjZSB3aGVuIHRoZSBoYXJkd2FyZSBkZXZpY2VzIGF0dGFjaCwgYW5kIHRob3NlIGRldmljZXMgZ2VuZXJhbGx5XHJcbiAgIHNob3VsZCB1c2Ugd2lyZXMgYXMgYSBtZWFucyB0byB0YWxrIHRvIGVhY2ggb3RoZXIsIHJhdGhlciB0aGFuIGFjY2Vzc2luZ1xyXG4gICBvdGhlciBkZXZpY2VzJyBlbnRyaWVzIGluIHRoZSBjNjQgc3RydWN0dXJlIGRpcmVjdGx5LlxyXG5cclxuICAgV2lyZXMgc2ltdWxhdGVzIGxpdGVyYWwgd2lyZXMsIGxpa2UgdGhlIElSUSBhbmQgTk1JIGxpbmVzLCB3aGljaCBjYW4gYmVcclxuICAgZHJpdmVuIGZyb20gbXVsdGlwbGUgc291cmNlcywgYnV0IGFycml2ZSBhdCB0aGUgQ1BVIGFzIGEgd2lyZWQtT1Igc2luZ2xlXHJcbiAgIHZhbHVlLiBJdCBwcm92aWRlcyBidXMgYWNjZXNzZXMsIHNpbXVsYXRpbmcgdGhlIG1lbW9yeS1tYXBwaW5nIFBMQSB0aGF0J3NcclxuICAgZHJpdmVuIGJ5IHRoZSBwcm9jZXNzb3IgcG9ydCwgYW5kIGNvbm5lY3RpbmcgdGhlIFZpYyB0byBSQU0gb3IgY2hhcmFjdGVyXHJcbiAgIFJPTSB1c2luZyB0aGUgVmljIGJhbmsgb3V0cHV0IGZyb20gQ0lBMiBwb3J0IEEuIEl0IGFsc28gc2ltdWxhdGVzIHRoZVxyXG4gICBwcm9jZXNzb3IgcG9ydCwgd2hpY2ggaXMgcmVhbGx5IHBhcnQgb2YgdGhlIENQVSwgYnV0IGl0IHdhcyBjb252ZW5pZW50IHRvXHJcbiAgIG1vdmUgaXQgaGVyZSBzaW5jZSBpdCdzIGFjY2Vzc2VkIHRocm91Z2ggTU1JTyBsaWtlIHRoZSBoYXJkd2FyZSBkZXZpY2VzLlxyXG5cclxuICAgQ29udHJhcnkgdG8gd2hhdCB0aGUgbmFtZSBpbXBsaWVzLCB3aXJlcyBkb2VzIG1haW50YWluIHN0YXRlOiBpdCBuZWVkcyB0aGlzXHJcbiAgIGZvciB0aGUgcHJvY2Vzc29yIHBvcnQsIGJ1dCBpdCBhbHNvIGNhY2hlcyB2YWx1ZXMgdGhhdCBjb3VsZCBiZSBkZXJpdmVkIGZyb21cclxuICAgb3RoZXIgc291cmNlcywgbGlrZSB0aGUgaW50ZXJydXB0IGxpbmVzIGFuZCBWaWMgYmFuay5cclxuKi9cclxuXHJcbi8vIFJlZmVyZW5jZXM6XHJcbi8vIFN1cGVyIGhlbHBmdWwgbWVtb3J5IG1hcDogaHR0cHM6Ly9zdGEuYzY0Lm9yZy9jYm02NG1lbS5odG1sXHJcblxyXG5pbXBvcnQgeyB2ZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2RlYnVnXCI7XHJcbmltcG9ydCB7XHJcbiAgYWRkVG9TZXJpYWxpemVyUmVnaXN0cnksXHJcbiAgZnVuY3Rpb25Ub1JlZmVyZW5jZSxcclxuICByZWZlcmVuY2VUb0Z1bmN0aW9uLFxyXG59IGZyb20gXCIuLi90b29scy9zZXJpYWxpemVyU3VwcG9ydFwiO1xyXG5cclxuLy8gQ29uZmlndXJlZCBieSBhdHRhY2hcclxubGV0IGM2NDtcclxubGV0IGJhc2ljLCBjaGFyYWN0ZXIsIGtlcm5hbDtcclxubGV0IHJlYWRSYW0sIHdyaXRlUmFtLCB2aWNSZWFkUmFtO1xyXG5cclxubGV0IHN0YXRlO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGF0dGFjaChuYXNjZW50QzY0KSB7XHJcbiAgYzY0ID0gbmFzY2VudEM2NDtcclxuXHJcbiAgYmFzaWMgICAgICA9IGM2NC5yb20uYmFzaWM7XHJcbiAga2VybmFsICAgICA9IGM2NC5yb20ua2VybmFsO1xyXG4gIGNoYXJhY3RlciAgPSBjNjQucm9tLmNoYXJhY3RlcjtcclxuICByZWFkUmFtICAgID0gYzY0LnJhbS5yZWFkUmFtO1xyXG4gIHdyaXRlUmFtICAgPSBjNjQucmFtLndyaXRlUmFtO1xyXG4gIHZpY1JlYWRSYW0gPSBjNjQucmFtLnZpY1JlYWRSYW07XHJcblxyXG4gIGFkZFRvU2VyaWFsaXplclJlZ2lzdHJ5KHtcclxuICAgIHJlYWRSYW0sXHJcbiAgICB3cml0ZVJhbSxcclxuICB9KTtcclxuXHJcbiAgcmVzZXQoKTtcclxuXHJcbiAgYzY0LndpcmVzID0ge1xyXG4gICAgLy8gQ29udHJvbFxyXG4gICAgcmVzZXQsXHJcbiAgICBzZXJpYWxpemUsXHJcbiAgICBkZXNlcmlhbGl6ZSxcclxuICAgIC8vIFN0YXRlXHJcbiAgICBzdGF0ZSxcclxuICAgIC8vIFdpcmVzXHJcbiAgICBjcHVSZWFkLFxyXG4gICAgY3B1V3JpdGUsXHJcbiAgICB2aWNSZWFkLFxyXG4gICAgZ2V0SXJxLFxyXG4gICAgZ2V0Tm1pLFxyXG4gICAgc2V0VmljSXJxLFxyXG4gICAgc2V0Q2lhMUlycSxcclxuICAgIHNldENpYTJObWksXHJcbiAgICBzZXRWaWNCYW5rLFxyXG4gICAgcmFpc2VUYXBlSW50ZXJydXB0LFxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlc2V0KCkge1xyXG4gIHN0YXRlID0ge1xyXG4gICAgLy8gSW50ZXJydXB0IGlucHV0c1xyXG4gICAgLy8gKHVzZSBzZXRWaWNJcnEsIHNldENpYTFJcnEsIHNldENpYTJObWkgdG8gc2V0IHRoZW0pXHJcbiAgICBpcnFfdmljOiAgZmFsc2UsXHJcbiAgICBpcnFfY2lhMTogZmFsc2UsXHJcbiAgICBubWlfY2lhMjogZmFsc2UsXHJcblxyXG4gICAgLy8gSW50ZXJydXB0IG91dHB1dHNcclxuICAgIGlycTogZmFsc2UsXHJcbiAgICBubWk6IGZhbHNlLFxyXG5cclxuICAgIC8vIFByb2Nlc3NvciBwb3J0XHJcbiAgICBwb3J0OiAgICAgICAgICAweDM3LFxyXG4gICAgcG9ydExhc3RXcml0ZTogMHgzNyxcclxuICAgIHBvcnREaXJlY3Rpb246IDB4MmYsXHJcblxyXG4gICAgLy8gQ1BVIG1lbW9yeSBtYXBcclxuICAgIC8vIChhcyBkZXRlcm1pbmVkIGJ5IHRoZSBwcm9jZXNzb3IgcG9ydClcclxuICAgIHJlYWRBeHh4OiByZWFkQXh4eEJhc2ljLFxyXG4gICAgcmVhZER4eHg6IHJlYWREeHh4SW8sXHJcbiAgICByZWFkRXh4eDogcmVhZEV4eHhLZXJuYWwsXHJcblxyXG4gICAgd3JpdGVBeHh4OiB3cml0ZVJhbSxcclxuICAgIHdyaXRlRHh4eDogd3JpdGVEeHh4SW8sXHJcbiAgICB3cml0ZUV4eHg6IHdyaXRlUmFtLFxyXG5cclxuICAgIC8vIFZJQyBtZW1vcnkgbWFwXHJcbiAgICAvLyAoZnJvbSBDSUEyLCB0cmFuc2xhdGVkIHRvIGEgcG9pbnRlci4gVXNlIHNldFZpY0JhbmsgdG8gc2V0KVxyXG4gICAgdmljQmFua0Jhc2U6IDB4MDAwMCxcclxuXHJcbiAgICAvLyBUYXBlXHJcbiAgICBsYXN0VGFwZU1vdG9yOiBmYWxzZSxcclxuICB9O1xyXG5cclxuICBtYXBNZW1vcnlGcm9tUG9ydE91dHB1dCgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkQXh4eEJhc2ljICAgICAoYWRkcikgeyByZXR1cm4gICAgIGJhc2ljW2FkZHIgLSAweGEwMDBdOyB9XHJcbmZ1bmN0aW9uIHJlYWREeHh4Q2hhcmFjdGVyIChhZGRyKSB7IHJldHVybiBjaGFyYWN0ZXJbYWRkciAtIDB4ZDAwMF07IH1cclxuZnVuY3Rpb24gcmVhZEV4eHhLZXJuYWwgICAgKGFkZHIpIHsgcmV0dXJuICAgIGtlcm5hbFthZGRyIC0gMHhlMDAwXTsgfVxyXG5cclxuZnVuY3Rpb24gcmVldmFsdWF0ZUlycSgpIHtcclxuICBzdGF0ZS5pcnEgPSBzdGF0ZS5pcnFfdmljIHx8IHN0YXRlLmlycV9jaWExO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWV2YWx1YXRlTm1pKCkge1xyXG4gIC8vIFRPRE86IHRoZXJlIGFyZSBvdGhlciBzb3VyY2VzLiBSRVNUT1JFIGtleSBpcyBvbmUuIEFueSBvdGhlcnM/XHJcbiAgc3RhdGUubm1pID0gc3RhdGUubm1pX2NpYTI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldElycSgpIHsgcmV0dXJuIHN0YXRlLmlycTsgfVxyXG5mdW5jdGlvbiBnZXRObWkoKSB7IHJldHVybiBzdGF0ZS5ubWk7IH1cclxuXHJcbmZ1bmN0aW9uIHNldFZpY0lycShzdGF0dXMpICB7IHN0YXRlLmlycV92aWMgID0gc3RhdHVzOyByZWV2YWx1YXRlSXJxKCk7IH1cclxuZnVuY3Rpb24gc2V0Q2lhMUlycShzdGF0dXMpIHsgc3RhdGUuaXJxX2NpYTEgPSBzdGF0dXM7IHJlZXZhbHVhdGVJcnEoKTsgfVxyXG5mdW5jdGlvbiBzZXRDaWEyTm1pKHN0YXR1cykgeyBzdGF0ZS5ubWlfY2lhMiA9IHN0YXR1czsgcmVldmFsdWF0ZU5taSgpOyB9XHJcblxyXG5mdW5jdGlvbiBzZXRWaWNCYW5rKGJhbmtOdW1iZXIpIHtcclxuICBzdGF0ZS52aWNCYW5rQmFzZSA9IGJhbmtOdW1iZXIgKiAweDQwMDA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHZpY1JlYWQoYWRkcikge1xyXG4gIGNvbnN0IHsgdmljQmFua0Jhc2UgfSA9IHN0YXRlO1xyXG5cclxuICAvLyBXZSdyZSB0cmFuc2xhdGluZyB0byBnZXQgY2hhcmFjdGVyIFJBTSBoZXJlLiBJJ20gZ3Vlc3NpbmcgdGhhdFxyXG4gIC8vIGFsbCBWSUMgcmVhZHMgdG8gdGhvc2UgYWRkcmVzc2VzIHdpdGhpbiBpdHMgYmFuayBnZXQgdGhlIGNoYXJhY3RlclxyXG4gIC8vIFJPTSwgbm90IGp1c3QgY2hhcmFjdGVyIHJlYWRzLlxyXG5cclxuICBpZiAoKHZpY0JhbmtCYXNlID09PSAweDAwMDApIHx8ICh2aWNCYW5rQmFzZSA9PT0gMHg4MDAwKSkge1xyXG4gICAgaWYgKChhZGRyID49IDB4MTAwMCkgJiYgKGFkZHIgPCAweDIwMDApKSB7XHJcbiAgICAgIHJldHVybiBjaGFyYWN0ZXJbYWRkciAtIDB4MTAwMF07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdmljUmVhZFJhbSh2aWNCYW5rQmFzZSArIGFkZHIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcHVSZWFkKGFkZHIpIHtcclxuICB2ZXRBZGRyZXNzKGFkZHIpO1xyXG5cclxuICBmdW5jdGlvbiByZWFsUmVhZCgpIHtcclxuXHJcbiAgICBpZiAoKGFkZHIgPT09IDApKSAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZFBvcnREaXJlY3Rpb24oKTtcclxuICAgIGlmICgoYWRkciA9PT0gMSkpICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkUG9ydCgpO1xyXG5cclxuICAgIGlmICgoYWRkciA+PSAweGEwMDApICYmIChhZGRyIDw9IDB4YmZmZikpIHJldHVybiBzdGF0ZS5yZWFkQXh4eChhZGRyKTtcclxuICAgIGlmICgoYWRkciA+PSAweGQwMDApICYmIChhZGRyIDw9IDB4ZGZmZikpIHJldHVybiBzdGF0ZS5yZWFkRHh4eChhZGRyKTtcclxuICAgIGlmICgoYWRkciA+PSAweGUwMDApICYmIChhZGRyIDw9IDB4ZmZmZikpIHJldHVybiBzdGF0ZS5yZWFkRXh4eChhZGRyKTtcclxuXHJcbiAgICByZXR1cm4gcmVhZFJhbShhZGRyKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHJldCA9IHJlYWxSZWFkKCk7XHJcblxyXG4gIGlmICghKChyZXQgPj0gMCkgJiYgKHJldCA8PSAyNTUpKSkge1xyXG4gICAgZGVidWdnZXI7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCdXMgcmVhZCBnb3QgYmFkIHZhbHVlIGZvciBhZGRyID0gXCIgKyBhZGRyKTtcclxuICB9XHJcblxyXG4gIHJldHVybiByZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWRQb3J0RGlyZWN0aW9uKCkge1xyXG4gIHJldHVybiBzdGF0ZS5wb3J0RGlyZWN0aW9uO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkUG9ydCgpIHtcclxuICAvLyBUT0RPOiB3aGF0IGhhcHBlbnMgaWYgYSBwb3J0IGlucHV0IGxpbmUgaXMgc2V0IHRvIHJlYWQvXHJcbiAgLy8gd3JpdGU/IElmIHdlIHJlYWQgaXRzIHZhbHVlIGRvIHdlIG5vdyBnZXQgdGhlIGxhc3QgYml0IHdlIHRyaWVkIHRvIHdyaXRlXHJcbiAgLy8gdG8gaXQ/IEkgZ3Vlc3MgdGhlIENQVSBvdXRwdXQgd291bGQgYmUgZmlnaHRpbmcgdGhlIGV4dGVybmFsIGRldmljZVxyXG4gIC8vIGRyaXZpbmcgaXQuXHJcbiBcclxuICByZXR1cm4gc3RhdGUucG9ydDtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RmxvYXRpbmdWYWx1ZSgpIHtcclxuICAvLyBkYXRhc2V0dGUgYnV0dG9uczogcG9ydCBzaG93cyAxIGlmIG5vdGhpbmcgcHJlc3NlZFxyXG4gIGNvbnN0IHQgPSBjNjQudGFwZS5pc0FueUJ1dHRvblByZXNzZWQoKSA/IDAgOiAxO1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgKDAgPDwgNykgfCAgICAvLyBOb3QgcGFydCBvZiBwb3J0LiBUT0RPOiBjaGVjayB2YWx1ZSBvbiByZWFsIGhhcmR3YXJlXHJcbiAgICAoMCA8PCA2KSB8ICAgIC8vIE5vdCBwYXJ0IG9mIHBvcnQuIFRPRE86IGNoZWNrIHZhbHVlIG9uIHJlYWwgaGFyZHdhcmVcclxuICAgICgxIDw8IDUpIHwgICAgLy8gRGF0YXNldHRlIG1vdG9yIG9mZlxyXG4gICAgKHQgPDwgNCkgfCAgICAvLyBEYXRhc2V0dGUgYnV0dG9ucyAoMCA9IHNvbWV0aGluZydzIHByZXNzZWQpXHJcbiAgICAoMCA8PCAzKSB8ICAgIC8vIERhdGFzZXR0ZSBvdXRwdXRcclxuICAgICgxIDw8IDIpIHwgICAgLy8gTWVtb3J5IGNvbmZpZy5cclxuICAgICgxIDw8IDEpIHwgICAgLy8gTWVtb3J5IGNvbmZpZy5cclxuICAgICgxIDw8IDApICAgICAgLy8gTWVtb3J5IGNvbmZpZy5cclxuICApO1xyXG59XHJcblxyXG5mdW5jdGlvbiB3cml0ZVBvcnREaXJlY3Rpb24oYnl0ZSkge1xyXG4gIHN0YXRlLnBvcnREaXJlY3Rpb24gPSBieXRlO1xyXG5cclxuICAvLyBQb3J0IGxpbmVzIHRoYXQgd2VyZSByZWFkL3dyaXRlIGFuZCBhcmUgbm93IHJlYWQgd2lsbCBub3cgZmxvYXQgdG9cclxuICAvLyB3aGVyZXZlciB0aGV5J3JlIHRpZWQuXHJcblxyXG4gIHN0YXRlLnBvcnQgPSAoXHJcbiAgICAoc3RhdGUucG9ydExhc3RXcml0ZSAmIHN0YXRlLnBvcnREaXJlY3Rpb24pIHxcclxuICAgIChnZXRGbG9hdGluZ1ZhbHVlKCkgJiB+c3RhdGUucG9ydERpcmVjdGlvbilcclxuICApO1xyXG5cclxuICBtYXBNZW1vcnlGcm9tUG9ydE91dHB1dCgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB3cml0ZVBvcnQoYnl0ZSkge1xyXG4gIHN0YXRlLnBvcnRMYXN0V3JpdGUgPSBieXRlO1xyXG5cclxuICAvLyBXaGljaCBsaW5lcyBhcmUgdGllZCBsb3cvaGlnaC4gVE9ETzogcmVzZWFyY2ggdGhpcy4gVGhlIGJhbmsgbGluZXMgc2VlbVxyXG4gIC8vIHRvIGJlIHRpZWQgaGlnaCAob3IgQnVnZ3kgQm95IGFuZCBIZXJvIG9mIHRoZSBHb2xkZW4gVGFsaXNtYW4gZmFpbCksXHJcblxyXG4gIC8vIGEgMSBpbiBhIGJpdCBvZiBwb3J0RGlyZWN0aW9uIG1lYW5zIHRoYXQgYml0IGNhbiBiZSB3cml0dGVuIHRvXHJcbiAgc3RhdGUucG9ydCA9IChcclxuICAgIChieXRlICAgICAgICAgICAgICAgJiAgc3RhdGUucG9ydERpcmVjdGlvbikgfFxyXG4gICAgKGdldEZsb2F0aW5nVmFsdWUoKSAmIH5zdGF0ZS5wb3J0RGlyZWN0aW9uKVxyXG4gICk7XHJcblxyXG4gIGNvbnN0IHRhcGVNb3RvciA9ICEoc3RhdGUucG9ydCAmIDBiMDAxMDAwMDApO1xyXG4gIGlmICh0YXBlTW90b3IgIT09IHN0YXRlLmxhc3RUYXBlTW90b3IpIHtcclxuICAgIHN0YXRlLmxhc3RUYXBlTW90b3IgPSB0YXBlTW90b3I7XHJcbiAgICBjNjQudGFwZS5zZXRUYXBlTW90b3IodGFwZU1vdG9yKTtcclxuICB9XHJcblxyXG4gIG1hcE1lbW9yeUZyb21Qb3J0T3V0cHV0KCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1hcE1lbW9yeUZyb21Qb3J0T3V0cHV0KCkge1xyXG4gIC8vIFRoZSBvdXRnb2luZyBwb3J0IHZhbHVlIGhhdmluZyBjaGFuZ2VkLCByZWNvbmZpZ3VyZSB0aGUgbWFwcGluZ3MgYWNjb3JkaW5nbHlcclxuXHJcbiAgY29uc3QgYmFuayA9IHN0YXRlLnBvcnQgJiAwYjExMTtcclxuXHJcbiAgLy8gVE9ETzogSSdtIG5vdCBfYXQgYWxsXyBjb25maWRlbnQgYWJvdXQgdGhlc2UuXHJcbiAgLy8gZnJvbSBodHRwczovL3N0YS5jNjQub3JnL2NibTY0bWVtLmh0bWxcclxuICAoe1xyXG4gICAgMGIwMDA6ICgpID0+IHsgIHN0YXRlIC5yZWFkQXh4eCA9IHJlYWRSYW07XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgLnJlYWREeHh4ID0gcmVhZFJhbTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSAucmVhZEV4eHggPSByZWFkUmFtO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLndyaXRlQXh4eCA9IHdyaXRlUmFtO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLndyaXRlRHh4eCA9IHdyaXRlUmFtO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLndyaXRlRXh4eCA9IHdyaXRlUmFtO1xyXG4gICAgfSxcclxuICAgIDBiMDAxOiAoKSA9PiB7ICBzdGF0ZSAucmVhZEF4eHggPSByZWFkUmFtO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlIC5yZWFkRHh4eCA9IHJlYWREeHh4Q2hhcmFjdGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlIC5yZWFkRXh4eCA9IHJlYWRSYW07XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUud3JpdGVBeHh4ID0gd3JpdGVSYW07XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUud3JpdGVEeHh4ID0gd3JpdGVSYW07XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUud3JpdGVFeHh4ID0gd3JpdGVSYW07XHJcbiAgICB9LFxyXG4gICAgMGIwMTA6ICgpID0+IHsgIHN0YXRlIC5yZWFkQXh4eCA9IHJlYWRSYW07XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgLnJlYWREeHh4ID0gcmVhZER4eHhDaGFyYWN0ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgLnJlYWRFeHh4ID0gcmVhZEV4eHhLZXJuYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUud3JpdGVBeHh4ID0gd3JpdGVSYW07XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUud3JpdGVEeHh4ID0gd3JpdGVSYW07XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUud3JpdGVFeHh4ID0gd3JpdGVSYW07XHJcbiAgICB9LFxyXG4gICAgMGIwMTE6ICgpID0+IHsgIHN0YXRlIC5yZWFkQXh4eCA9IHJlYWRBeHh4QmFzaWM7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgLnJlYWREeHh4ID0gcmVhZER4eHhDaGFyYWN0ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgLnJlYWRFeHh4ID0gcmVhZEV4eHhLZXJuYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUud3JpdGVBeHh4ID0gd3JpdGVSYW07XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUud3JpdGVEeHh4ID0gd3JpdGVSYW07XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUud3JpdGVFeHh4ID0gd3JpdGVSYW07XHJcbiAgICB9LFxyXG4gICAgMGIxMDA6ICgpID0+IHsgIHN0YXRlIC5yZWFkQXh4eCA9IHJlYWRSYW07XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgLnJlYWREeHh4ID0gcmVhZFJhbTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSAucmVhZEV4eHggPSByZWFkUmFtO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLndyaXRlQXh4eCA9IHdyaXRlUmFtO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLndyaXRlRHh4eCA9IHdyaXRlUmFtO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLndyaXRlRXh4eCA9IHdyaXRlUmFtO1xyXG4gICAgfSxcclxuICAgIDBiMTAxOiAoKSA9PiB7ICBzdGF0ZSAucmVhZEF4eHggPSByZWFkUmFtO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlIC5yZWFkRHh4eCA9IHJlYWREeHh4SW87XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgLnJlYWRFeHh4ID0gcmVhZFJhbTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS53cml0ZUF4eHggPSB3cml0ZVJhbTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS53cml0ZUR4eHggPSB3cml0ZUR4eHhJbztcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS53cml0ZUV4eHggPSB3cml0ZVJhbTtcclxuICAgIH0sXHJcbiAgICAwYjExMDogKCkgPT4geyAgc3RhdGUgLnJlYWRBeHh4ID0gcmVhZFJhbTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSAucmVhZER4eHggPSByZWFkRHh4eElvO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlIC5yZWFkRXh4eCA9IHJlYWRFeHh4S2VybmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLndyaXRlQXh4eCA9IHdyaXRlUmFtO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLndyaXRlRHh4eCA9IHdyaXRlRHh4eElvO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLndyaXRlRXh4eCA9IHdyaXRlUmFtO1xyXG4gICAgfSxcclxuICAgIDBiMTExOiAoKSA9PiB7ICBzdGF0ZSAucmVhZEF4eHggPSByZWFkQXh4eEJhc2ljO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlIC5yZWFkRHh4eCA9IHJlYWREeHh4SW87XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgLnJlYWRFeHh4ID0gcmVhZEV4eHhLZXJuYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUud3JpdGVBeHh4ID0gd3JpdGVSYW07XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUud3JpdGVEeHh4ID0gd3JpdGVEeHh4SW87XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUud3JpdGVFeHh4ID0gd3JpdGVSYW07XHJcbiAgICB9LFxyXG4gIH0pW2JhbmtdKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNwdVdyaXRlKGFkZHIsIGJ5dGUpIHtcclxuICB2ZXRBZGRyZXNzKGFkZHIpO1xyXG5cclxuICBpZiAoKGFkZHIgPT09IDApKSAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JpdGVQb3J0RGlyZWN0aW9uKGJ5dGUpO1xyXG4gIGlmICgoYWRkciA9PT0gMSkpICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3cml0ZVBvcnQoYnl0ZSk7XHJcblxyXG4gIGlmICgoYWRkciA+PSAweGEwMDApICYmIChhZGRyIDw9IDB4YmZmZikpIHJldHVybiBzdGF0ZS53cml0ZUF4eHgoYWRkciwgYnl0ZSk7XHJcbiAgaWYgKChhZGRyID49IDB4ZDAwMCkgJiYgKGFkZHIgPD0gMHhkZmZmKSkgcmV0dXJuIHN0YXRlLndyaXRlRHh4eChhZGRyLCBieXRlKTtcclxuICBpZiAoKGFkZHIgPj0gMHhlMDAwKSAmJiAoYWRkciA8PSAweGZmZmYpKSByZXR1cm4gc3RhdGUud3JpdGVFeHh4KGFkZHIsIGJ5dGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JpdGVSYW0oYWRkciwgYnl0ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWREeHh4SW8oYWRkcikge1xyXG5cclxuICAvLyBWSUMgcmVnaXN0ZXJzXHJcbiAgaWYgKChhZGRyID49IDB4ZDAwMCkgJiYgKGFkZHIgPD0gMHhkM2ZmKSkgcmV0dXJuIGM2NC52aWMucmVhZF9kMDAwX2QzZmYoYWRkcik7XHJcbiAgLy8gU0lEXHJcbiAgaWYgKChhZGRyID49IDB4ZDQwMCkgJiYgKGFkZHIgPD0gMHhkN2ZmKSkgcmV0dXJuIGM2NC5zaWQucmVhZF9kNDAwX2Q3ZmYoYWRkcik7XHJcbiAgLy8gQ29sb3IgUkFNXHJcbiAgaWYgKChhZGRyID49IDB4ZDgwMCkgJiYgKGFkZHIgPD0gMHhkYmZmKSkgcmV0dXJuIGM2NC52aWMucmVhZF9kODAwX2RiZmYoYWRkcik7XHJcbiAgLy8gQ0lBMVxyXG4gIGlmICgoYWRkciA+PSAweGRjMDApICYmIChhZGRyIDw9IDB4ZGNmZikpIHJldHVybiBjNjQuY2lhcy5yZWFkX2RjMDBfZGNmZihhZGRyKTtcclxuICAvLyBDSUEyXHJcbiAgaWYgKChhZGRyID49IDB4ZGQwMCkgJiYgKGFkZHIgPD0gMHhkZGZmKSkgcmV0dXJuIGM2NC5jaWFzLnJlYWRfZGQwMF9kZGZmKGFkZHIpO1xyXG5cclxuICAvLyAkZGUwMCAtICRkZmZmIGFyZSBmb3IgbWVtb3J5LW1hcHBlZCBJTyBvZiBhbnkgb3RoZXIgZGV2aWNlcyB5b3UndmUgcGx1Z2dlZFxyXG4gIC8vIGludG8gdGhlIGJ1cy4gQ29uc2lkZXIgdGhlbSB1bm1hcHBlZDsgYSB2YW5pbGxhIEM2NCBqdXN0IHNob3dzIG5vaXNlIGhlcmUuXHJcbiAgcmV0dXJuIDB4ZmY7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdyaXRlRHh4eElvKGFkZHIsIGJ5dGUpIHtcclxuXHJcbiAgLy8gVklDIHJlZ2lzdGVyc1xyXG4gIGlmICgoYWRkciA+PSAweGQwMDApICYmIChhZGRyIDw9IDB4ZDNmZikpIHJldHVybiBjNjQudmljLndyaXRlX2QwMDBfZDNmZihhZGRyLCBieXRlKTtcclxuICAvLyBTSURcclxuICBpZiAoKGFkZHIgPj0gMHhkNDAwKSAmJiAoYWRkciA8PSAweGQ3ZmYpKSByZXR1cm4gYzY0LnNpZC53cml0ZV9kNDAwX2Q3ZmYoYWRkciwgYnl0ZSk7XHJcbiAgLy8gQ29sb3IgUkFNXHJcbiAgaWYgKChhZGRyID49IDB4ZDgwMCkgJiYgKGFkZHIgPD0gMHhkYmZmKSkgcmV0dXJuIGM2NC52aWMud3JpdGVfZDgwMF9kYmZmKGFkZHIsIGJ5dGUpO1xyXG4gIC8vIENJQTFcclxuICBpZiAoKGFkZHIgPj0gMHhkYzAwKSAmJiAoYWRkciA8PSAweGRjZmYpKSByZXR1cm4gYzY0LmNpYXMud3JpdGVfZGMwMF9kY2ZmKGFkZHIsIGJ5dGUpO1xyXG4gIC8vIENJQTJcclxuICBpZiAoKGFkZHIgPj0gMHhkZDAwKSAmJiAoYWRkciA8PSAweGRkZmYpKSByZXR1cm4gYzY0LmNpYXMud3JpdGVfZGQwMF9kZGZmKGFkZHIsIGJ5dGUpO1xyXG5cclxuICAvLyAkZGUwMCAtICRkZmZmIGFyZSBmb3IgbWVtb3J5LW1hcHBlZCBJTyBvZiBhbnkgb3RoZXIgZGV2aWNlcyB5b3UndmUgcGx1Z2dlZFxyXG4gIC8vIGludG8gdGhlIGJ1cy4gQ29uc2lkZXIgdGhlbSB1bm1hcHBlZC5cclxuICByZXR1cm47XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcclxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgLi4uc3RhdGUsXHJcbiAgICByZWFkQXh4eDogIGZ1bmN0aW9uVG9SZWZlcmVuY2Uoc3RhdGUucmVhZEF4eHgpLFxyXG4gICAgcmVhZER4eHg6ICBmdW5jdGlvblRvUmVmZXJlbmNlKHN0YXRlLnJlYWREeHh4KSxcclxuICAgIHJlYWRFeHh4OiAgZnVuY3Rpb25Ub1JlZmVyZW5jZShzdGF0ZS5yZWFkRXh4eCksXHJcbiAgICB3cml0ZUF4eHg6IGZ1bmN0aW9uVG9SZWZlcmVuY2Uoc3RhdGUud3JpdGVBeHh4KSxcclxuICAgIHdyaXRlRHh4eDogZnVuY3Rpb25Ub1JlZmVyZW5jZShzdGF0ZS53cml0ZUR4eHgpLFxyXG4gICAgd3JpdGVFeHh4OiBmdW5jdGlvblRvUmVmZXJlbmNlKHN0YXRlLndyaXRlRXh4eCksXHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlc2VyaWFsaXplKGpzb24pIHtcclxuICBzdGF0ZSA9IEpTT04ucGFyc2UoanNvbik7XHJcblxyXG4gIHN0YXRlLnJlYWRBeHh4ICA9IHJlZmVyZW5jZVRvRnVuY3Rpb24oc3RhdGUucmVhZEF4eHgpO1xyXG4gIHN0YXRlLnJlYWREeHh4ICA9IHJlZmVyZW5jZVRvRnVuY3Rpb24oc3RhdGUucmVhZER4eHgpO1xyXG4gIHN0YXRlLnJlYWRFeHh4ICA9IHJlZmVyZW5jZVRvRnVuY3Rpb24oc3RhdGUucmVhZEV4eHgpO1xyXG4gIHN0YXRlLndyaXRlQXh4eCA9IHJlZmVyZW5jZVRvRnVuY3Rpb24oc3RhdGUud3JpdGVBeHh4KTtcclxuICBzdGF0ZS53cml0ZUR4eHggPSByZWZlcmVuY2VUb0Z1bmN0aW9uKHN0YXRlLndyaXRlRHh4eCk7XHJcbiAgc3RhdGUud3JpdGVFeHh4ID0gcmVmZXJlbmNlVG9GdW5jdGlvbihzdGF0ZS53cml0ZUV4eHgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByYWlzZVRhcGVJbnRlcnJ1cHQoKSB7XHJcbiAgYzY0LmNpYXMucmFpc2VUYXBlSW50ZXJydXB0KCk7XHJcbn1cclxuXHJcbmFkZFRvU2VyaWFsaXplclJlZ2lzdHJ5KHtcclxuICByZWFkQXh4eEJhc2ljLFxyXG4gIHJlYWREeHh4Q2hhcmFjdGVyLFxyXG4gIHJlYWRFeHh4S2VybmFsLFxyXG4gIHJlYWREeHh4SW8sXHJcbiAgd3JpdGVEeHh4SW8sXHJcbn0pO1xyXG4iLCIvKlxyXG4gIFRoaXMgaXMgYSBoYWxmLWFzc2VtYmxlci4gUmF0aGVyIHRoYW4gdGFraW5nIGEgdGV4dCBmaWxlIGFzIGlucHV0LCBpdFxyXG4gIGNvbnZlcnRzIDY1MDItZXNxdWUgSmF2YVNjcmlwdCBmdW5jdGlvbnMgaW50byBvYmplY3QgY29kZSwgYW5kIGxpbmtzIGl0LFxyXG4gIHJldHVybmluZyBhIGJ5dGUgYXJyYXkuXHJcblxyXG4gIFVzZSBsaWtlIHRoaXM6XHJcblxyXG4gIHwgICBjb25zdCBiaW4gPSBhc3NlbWJsZShcclxuICB8ICAgICAweDQwMDAsICAgICAgICAgICAgICAgICAgIC8vIHRhcmdldCBhZGRyZXNzXHJcbiAgfCAgICAgKHtcclxuICB8ICAgICAgIE5PUCwgTERBLCBMRFgsIExEWSwgU1RBLCBTVFgsIFNUWSwgQ0xDLCBDTEQsIENMSSwgQ0xWLCBTRUMsIFNFRCwgU0VJLFxyXG4gIHwgICAgICAgVEFYLCBUQVksIFRTWCwgVFhBLCBUWFMsIFRZQSwgQ01QLCBDUFgsIENQWSwgQkNTLCBCQ0MsIEJFUSwgQk5FLCBCTUksXHJcbiAgfCAgICAgICBCUEwsIEJWUywgQlZDLCBCSVQsIEpTUiwgUlRTLCBSVEksIEJSSywgSk1QLCBJTkMsIERFQywgREVYLCBERVksIElOWCxcclxuICB8ICAgICAgIElOWSwgQURDLCBTQkMsIEFORCwgRU9SLCBPUkEsIEFTTCwgUk9MLCBMU1IsIFJPUiwgUEhBLCBQSFAsIFBMQSwgUExQLFxyXG4gIHwgICAgICAgX1xyXG4gIHwgICAgIH0pID0+IHtcclxuICB8XHJcbiAgfCAgICAgICBMRFguaW1tICg3KTtcclxuICB8ICAgICAgIFNUWC5hYnMgKDB4ZDAyMCk7ICAgICAgIC8vIHNldCBib3JkZXIgY29sb3JcclxuICB8XHJcbiAgfCAgICAgX2Bsb29wYDtcclxuICB8ICAgICAgIFNUWC5hYnMgKDB4ZDAyMSk7ICAgICAgIC8vIHNldCBiYWNrZ3JvdW5kIGNvbG9yXHJcbiAgfCAgICAgICBERVguaW1wICgpO1xyXG4gIHwgICAgICAgQk5FLnJlbCBgbG9vcGA7XHJcbiAgfFxyXG4gIHwgICAgICAgUlRTLmltcCAoKTtcclxuICB8ICAgfSk7XHJcblxyXG5cclxuICBUaGUgZm9ybWF0IG9mIHRoZSBvcGNvZGVzIGxvb2tzIGxpa2UgdGhpczpcclxuXHJcbiAgfCAgICAgICBBZGRyZXNzaW5nIG1vZGUgICBBc3NlbWJsZXIgICAgICBKYXZhU2NyaXB0XHJcbiAgfCAgICAgICAtLS0tLS0tLS0tLS0tLS0gICAtLS0tLS0tLS0gICAgICAtLS0tLS0tLS0tXHJcbiAgfCAgICAgICBJbXBsaWNpdCAgICAgICAgICBSVEkgICAgICAgICAgICBSVEkuaW1wICgpXHJcbiAgfCAgICAgICBJbW1lZGlhdGUgICAgICAgICBMREEgIyQxMCAgICAgICBMREEuaW1tICgweDEwKVxyXG4gIHwgICAgICAgQWNjdW11bGF0b3IgICAgICAgTFNSIEEgICAgICAgICAgTFNSLmFjYyAoKVxyXG4gIHwgICAgICAgQWJzb2x1dGUgICAgICAgICAgSk1QICQxMDAwICAgICAgSk1QLmFicyAoMHgxMDAwKVxyXG4gIHwgICAgICAgQWJzb2x1dGUsWCAgICAgICAgU1RBICQzMDAwLFggICAgU1RBLmFieCAoMHgzMDAwKVxyXG4gIHwgICAgICAgQWJzb2x1dGUsWSAgICAgICAgQU5EICQ0MDAwLFkgICAgQU5ELmFieSAoMHg0MDAwKVxyXG4gIHwgICAgICAgSW5kaXJlY3QgICAgICAgICAgSk1QICgkRkZGQykgICAgSk1QLmluZCAoMHhmZmZjKVxyXG4gIHwgICAgICAgSW5kaXJlY3QsWCAgICAgICAgTERBICgkNDAsWCkgICAgTERBLmlueCAoMHg0MClcclxuICB8ICAgICAgIEluZGlyZWN0LFkgICAgICAgIExEQSAoJDQwKSxZICAgIExEQS5pbnkgKDB4NDApXHJcbiAgfCAgICAgICBaZXJvIFBhZ2UgICAgICAgICBMREEgJDIwICAgICAgICBMREEuenBnICgweDIwKVxyXG4gIHwgICAgICAgWmVybyBQYWdlLFggICAgICAgU1RZICQxMCxYICAgICAgU1RZLnpweCAoMHgxMClcclxuICB8ICAgICAgIFplcm8gUGFnZSxZICAgICAgIFNUWCAkMTAsWSAgICAgIFNUWC56cHkgKDB4MTApXHJcbiAgfCAgICAgICBSZWxhdGl2ZSAgICAgICAgICBCTkUgbGFiZWwgICAgICBCTkUucmVsIGBsYWJlbGBcclxuXHJcblxyXG4gIExhYmVscyBjYW4gYmUgZGVmaW5lZCBhczpcclxuXHJcbiAgfCAgICAgICBfYGxvb3BgO1xyXG5cclxuICBPciwgZm9yIGxvY2F0aW9ucyBleHRlcm5hbCB0byB0aGUgcHJvZ3JhbTpcclxuXHJcbiAgfCAgICAgICBfLmxhYmVsKDB4ZDAyMCwgXCJleHRjb2xcIik7XHJcblxyXG4gIC4uLmFuZCBjYW4gdGhlbiBiZSByZWZlcmVuY2VkIGxpa2U6XHJcblxyXG4gIHwgICAgICAgQk5FLnJlbCBgbGFiZWxgOyAgICAgICAgICAgICAgICAgICAgLy8gbGFiZWwgYXMgYnJhbmNoIHRhcmdldFxyXG4gIHwgICAgICAgTERYLmltbSBfLmxgbGFiZWxgOyAgICAgICAgICAgICAgICAgLy8gbG93IGJ5dGUgb2YgbGFiZWxcclxuICB8ICAgICAgIExEWS5pbW0gXy5oYGxhYmVsYDsgICAgICAgICAgICAgICAgIC8vIGhpZ2ggYnl0ZSBvZiBsYWJlbFxyXG4gIHwgICAgICAgU1RBLmFicyAoKHtsYWJlbH0pID0+IGxhYmVsICsgMSk7ICAgLy8gcGVyZm9ybSBtYXRoIG9uIGxhYmVsXHJcblxyXG4gIEluIHRoYXQgbGFzdCBjYXNlLCB0aGUgZnVuY3Rpb24gdGhhdCdzIHBhc3NlZCB0byB0aGF0IFNUQSBpbnN0cnVjdGlvbiBpc1xyXG4gIGNhbGxlZCBkdXJpbmcgdGhlIGxpbmtpbmcgcGhhc2UsIG9uY2UgYWxsIHRoZSBsYWJlbHMgaGF2ZSBiZWVuIGFzc2lnbmVkXHJcbiAgbG9jYXRpb25zLiBJdCdzIHBhc3NlZCBpbiBhbiBvYmplY3Qgd2hvc2Uga2V5cyBhcmUgYWxsIHRoZSBsYWJlbHMnIG5hbWVzLCBhbmRcclxuICB3aG9zZSB2YWx1ZXMgYXJlIHRoZSBsb2NhdGlvbnMgb2YgdGhvc2UgbGFiZWxzLiBUaGUgdmFsdWUgaXQgcmV0dXJucyB3aWxsXHJcbiAgYmVjb21lIHRoZSBvcGVyYW5kIHRvIHRoZSBTVEEgaW5zdHJ1Y3Rpb24sIGNvbnZlcnRlZCBhdXRvbWF0aWNhbGx5IGludG9cclxuICBsb3dieXRlL2hpZ2hieXRlLlxyXG5cclxuXHJcbiAgQXJiaXRyYXJ5IGJ5dGVzIGNhbiBiZSBpbmplY3RlZCBpbnRvIHRoZSBjb2RlIGxpa2UgdGhpczpcclxuXHJcbiAgfCAgICAgICBfLmJ5dGVzKDB4NGMsIDB4MTYsIDB4MDgsIDB4MDAsIDB4OTcsIDB4MzIpO1xyXG5cclxuXHJcbiAgVGhlIGhhbGYtYXNzZW1ibGVyIGFsc28gY29udGFpbnMgYSBCYXNpYyBoYWxmLXRva2VuaXplciwgd2hpY2ggcHJvdmlkZXNcclxuICBvbmx5IGp1c3QgZW5vdWdoIGNvbW1hbmRzIHRvIGJvb3RzdHJhcCBhIG1hY2hpbmUgbGFuZ3VhZ2Ugcm91dGluZS4gQ2FsbCBpdFxyXG4gIGxpa2UgdGhpczpcclxuXHJcbiAgfCAgICAgICBfLmJhc2ljKFxyXG4gIHwgICAgICAgICAoe1JFTSwgUE9LRSwgU1lTfSkgPT4gKHtcclxuICB8ICAgICAgICAgICAxMDogUkVNIChcIlNJTVBMRSBCQVNJQyBCT09UU1RSQVBcIiksXHJcbiAgfCAgICAgICAgICAgMjA6IFBPS0UgKDUzMjgxLCAwKSxcclxuICB8ICAgICAgICAgICAzMDogU1lTIChcInN0YXJ0XCIpLFxyXG4gIHwgICAgICAgICB9KVxyXG4gIHwgICAgICAgKTtcclxuICB8XHJcbiAgfCAgICAgICBfYHN0YXJ0YDtcclxuICB8ICAgICAgICAgLy8gKDY1MDIgYXNzZW1ibHkgc3RhcnRzIGhlcmUpXHJcblxyXG4qL1xyXG5cclxuLy8gVE9ETzogdGhlIHF1YXNpLW9wcyBhcmVuJ3QgaGVyZSB5ZXQsIGV2ZW4gdGhvdWdoIHRoZSByZXN0IG9mIHRoZSBlbXVsYXRvclxyXG4vLyBub3cgc3VwcG9ydHMgdGhlbS5cclxuY29uc3Qgb3Bjb2RlcyA9IHtcclxuICBBREM6IHsgYWJzOiAweDZkLCBhYng6IDB4N2QsIGFieTogMHg3OSwgaW54OiAweDYxLCBpbnk6IDB4NzEsIGltbTogMHg2OSwgenBnOiAweDY1LCB6cHg6IDB4NzUgfSxcclxuICBBTkQ6IHsgYWJzOiAweDJkLCBhYng6IDB4M2QsIGFieTogMHgzOSwgaW54OiAweDIxLCBpbnk6IDB4MzEsIGltbTogMHgyOSwgenBnOiAweDI1LCB6cHg6IDB4MzUgfSxcclxuICBBU0w6IHsgYWJzOiAweDBlLCBhYng6IDB4MWUsIGFjYzogMHgwYSwgenBnOiAweDA2LCB6cHg6IDB4MTYgfSxcclxuICBCQ0M6IHsgcmVsOiAweDkwIH0sXHJcbiAgQkNTOiB7IHJlbDogMHhiMCB9LFxyXG4gIEJFUTogeyByZWw6IDB4ZjAgfSxcclxuICBCSVQ6IHsgYWJzOiAweDJjLCB6cGc6IDB4MjQgfSxcclxuICBCTUk6IHsgcmVsOiAweDMwIH0sXHJcbiAgQk5FOiB7IHJlbDogMHhkMCB9LFxyXG4gIEJQTDogeyByZWw6IDB4MTAgfSxcclxuICBCUks6IHsgaW1wOiAweDAwIH0sXHJcbiAgQlZDOiB7IHJlbDogMHg1MCB9LFxyXG4gIEJWUzogeyByZWw6IDB4NzAgfSxcclxuICBDTEM6IHsgaW1wOiAweDE4IH0sXHJcbiAgQ0xEOiB7IGltcDogMHhkOCB9LFxyXG4gIENMSTogeyBpbXA6IDB4NTggfSxcclxuICBDTFY6IHsgaW1wOiAweGI4IH0sXHJcbiAgQ01QOiB7IGFiczogMHhjZCwgYWJ4OiAweGRkLCBhYnk6IDB4ZDksIGlueDogMHhjMSwgaW55OiAweGQxLCBpbW06IDB4YzksIHpwZzogMHhjNSwgenB4OiAweGQ1IH0sXHJcbiAgQ1BYOiB7IGFiczogMHhlYywgaW1tOiAweGUwLCB6cGc6IDB4ZTQgfSxcclxuICBDUFk6IHsgYWJzOiAweGNjLCBpbW06IDB4YzAsIHpwZzogMHhjNCB9LFxyXG4gIERFQzogeyBhYnM6IDB4Y2UsIGFieDogMHhkZSwgenBnOiAweGM2LCB6cHg6IDB4ZDYgfSxcclxuICBERVg6IHsgaW1wOiAweGNhIH0sXHJcbiAgREVZOiB7IGltcDogMHg4OCB9LFxyXG4gIEVPUjogeyBhYnM6IDB4NGQsIGFieDogMHg1ZCwgYWJ5OiAweDU5LCBpbng6IDB4NDEsIGlueTogMHg1MSwgaW1tOiAweDQ5LCB6cGc6IDB4NDUsIHpweDogMHg1NSB9LFxyXG4gIElOQzogeyBhYnM6IDB4ZWUsIGFieDogMHhmZSwgenBnOiAweGU2LCB6cHg6IDB4ZjYgfSxcclxuICBJTlg6IHsgaW1wOiAweGU4IH0sXHJcbiAgSU5ZOiB7IGltcDogMHhjOCB9LFxyXG4gIEpNUDogeyBhYnM6IDB4NGMsIGluZDogMHg2YyB9LFxyXG4gIEpTUjogeyBhYnM6IDB4MjAgfSxcclxuICBMREE6IHsgYWJzOiAweGFkLCBhYng6IDB4YmQsIGFieTogMHhiOSwgaW54OiAweGExLCBpbnk6IDB4YjEsIGltbTogMHhhOSwgenBnOiAweGE1LCB6cHg6IDB4YjUgfSxcclxuICBMRFg6IHsgYWJzOiAweGFlLCBhYnk6IDB4YmUsIGltbTogMHhhMiwgenBnOiAweGE2LCB6cHk6IDB4YjYgfSxcclxuICBMRFk6IHsgYWJzOiAweGFjLCBhYng6IDB4YmMsIGltbTogMHhhMCwgenBnOiAweGE0LCB6cHg6IDB4YjQgfSxcclxuICBMU1I6IHsgYWJzOiAweDRlLCBhYng6IDB4NWUsIGFjYzogMHg0YSwgenBnOiAweDQ2LCB6cHg6IDB4NTYgfSxcclxuICBOT1A6IHsgaW1wOiAweGVhIH0sXHJcbiAgT1JBOiB7IGFiczogMHgwZCwgYWJ4OiAweDFkLCBhYnk6IDB4MTksIGlueDogMHgwMSwgaW55OiAweDExLCBpbW06IDB4MDksIHpwZzogMHgwNSwgenB4OiAweDE1IH0sXHJcbiAgUEhBOiB7IGltcDogMHg0OCB9LFxyXG4gIFBIUDogeyBpbXA6IDB4MDggfSxcclxuICBQTEE6IHsgaW1wOiAweDY4IH0sXHJcbiAgUExQOiB7IGltcDogMHgyOCB9LFxyXG4gIFJPTDogeyBhYnM6IDB4MmUsIGFieDogMHgzZSwgYWNjOiAweDJhLCB6cGc6IDB4MjYsIHpweDogMHgzNiB9LFxyXG4gIFJPUjogeyBhYnM6IDB4NmUsIGFieDogMHg3ZSwgYWNjOiAweDZhLCB6cGc6IDB4NjYsIHpweDogMHg3NiB9LFxyXG4gIFJUSTogeyBpbXA6IDB4NDAgfSxcclxuICBSVFM6IHsgaW1wOiAweDYwIH0sXHJcbiAgU0JDOiB7IGFiczogMHhlZCwgYWJ4OiAweGZkLCBhYnk6IDB4ZjksIGlueDogMHhlMSwgaW55OiAweGYxLCBpbW06IDB4ZTksIHpwZzogMHhlNSwgenB4OiAweGY1IH0sXHJcbiAgU0VDOiB7IGltcDogMHgzOCB9LFxyXG4gIFNFRDogeyBpbXA6IDB4ZjggfSxcclxuICBTRUk6IHsgaW1wOiAweDc4IH0sXHJcbiAgU1RBOiB7IGFiczogMHg4ZCwgYWJ4OiAweDlkLCBhYnk6IDB4OTksIGlueDogMHg4MSwgaW55OiAweDkxLCB6cGc6IDB4ODUsIHpweDogMHg5NSB9LFxyXG4gIFNUWDogeyBhYnM6IDB4OGUsIHpwZzogMHg4NiwgenB5OiAweDk2IH0sXHJcbiAgU1RZOiB7IGFiczogMHg4YywgenBnOiAweDg0LCB6cHg6IDB4OTQgfSxcclxuICBUQVg6IHsgaW1wOiAweGFhIH0sXHJcbiAgVEFZOiB7IGltcDogMHhhOCB9LFxyXG4gIFRTWDogeyBpbXA6IDB4YmEgfSxcclxuICBUWEE6IHsgaW1wOiAweDhhIH0sXHJcbiAgVFhTOiB7IGltcDogMHg5YSB9LFxyXG4gIFRZQTogeyBpbXA6IDB4OTggfSxcclxufTtcclxuXHJcbmNvbnN0IGJhc2ljVG9rZW5zID0ge1xyXG4gIFJFTTogIDB4OGYsXHJcbiAgUE9LRTogMHg5NyxcclxuICBTWVM6ICAweDllLFxyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gdmFsaWRhdGVCeXRlKGJ5dGUpIHtcclxuICBpZiAodHlwZW9mIGJ5dGUgIT09IFwibnVtYmVyXCIpIHRocm93IG5ldyBFcnJvcihcIk5vdCBhIG51bWJlclwiKTtcclxuICBpZiAoYnl0ZSAlIDEpICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYW4gaW50ZWdlclwiKTtcclxuICBpZiAoYnl0ZSA8IDApICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBiZSBuZWdhdGl2ZVwiKTtcclxuICBpZiAoYnl0ZSA+IDB4ZmYpICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb28gYmlnXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB2YWxpZGF0ZUFkZHIoYWRkcikge1xyXG4gIGlmICh0eXBlb2YgYWRkciAhPT0gXCJudW1iZXJcIikgdGhyb3cgbmV3IEVycm9yKFwiTm90IGEgbnVtYmVyXCIpO1xyXG4gIGlmIChhZGRyICUgMSkgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBhbiBpbnRlZ2VyXCIpO1xyXG4gIGlmIChhZGRyIDwgMCkgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGJlIG5lZ2F0aXZlXCIpO1xyXG4gIGlmIChhZGRyID4gMHhmZmZmKSAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRvbyBiaWdcIik7XHJcbn1cclxuXHJcbi8vIE9wZXJhbmQgaGFuZGxlcnNcclxuXHJcbmZ1bmN0aW9uIGJ5dGVPcGVyYW5kKGNodW5rLCBsaW5rZXJUYXNrcywgYXJnKSB7XHJcbiAgbGV0IGJ5dGUgPSBcIlhYXCI7XHJcblxyXG4gIGlmICh0eXBlb2YgYXJnID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAvLyBpdCdzIGEgcmVmZXJlbmNlLCBsZWZ0IGJ5LCBzYXksIGEgXy5sYGBcclxuICAgIC8vIChTbyBzaG91bGRuJ3QgaGF2ZSBjYWxsZWQgaXQgYSBieXRlKVxyXG4gICAgbGlua2VyVGFza3MucHVzaCh7XHJcbiAgICAgIC4uLmFyZyxcclxuICAgICAgYXQ6IGNodW5rLmxlbmd0aCxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgbGlua2VyVGFza3MucHVzaCh7XHJcbiAgICAgIGF0OiBjaHVuay5sZW5ndGgsXHJcbiAgICAgIGZvcm1hdDogXCJsb1wiLFxyXG4gICAgICBsYWJlbDogYXJnLFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBlbHNlIHtcclxuICAgIHZhbGlkYXRlQnl0ZShhcmcpO1xyXG4gICAgYnl0ZSA9IGFyZztcclxuICB9XHJcblxyXG4gIGNodW5rLnB1c2goYnl0ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZHJPcGVyYW5kKGNodW5rLCBsaW5rZXJUYXNrcywgYXJnKSB7XHJcbiAgaWYgKHR5cGVvZiBhcmcgPT09IFwiZnVuY3Rpb25cIikge1xyXG5cclxuICAgIGxpbmtlclRhc2tzLnB1c2goe1xyXG4gICAgICBhdDogY2h1bmsubGVuZ3RoLFxyXG4gICAgICBmb3JtYXQ6IFwibG9oaUZuXCIsXHJcbiAgICAgIGZuOiBhcmcsXHJcbiAgICB9KTtcclxuXHJcbiAgICBjaHVuay5wdXNoKFwiWFhcIik7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIGFyZyA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgdmFsaWRhdGVBZGRyKGFyZyk7XHJcbiAgICBjaHVuay5wdXNoKGFyZyAmIDB4ZmYpO1xyXG4gICAgY2h1bmsucHVzaChhcmcgPj4gOCk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBlbHNlIGlmICh0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICBsaW5rZXJUYXNrcy5wdXNoKHtcclxuICAgICAgYXQ6IGNodW5rLmxlbmd0aCxcclxuICAgICAgZm9ybWF0OiBcImxvXCIsXHJcbiAgICAgIGxhYmVsOiBhcmcsXHJcbiAgICB9KTtcclxuXHJcbiAgICBjaHVuay5wdXNoKFwiWFhcIik7XHJcblxyXG4gICAgbGlua2VyVGFza3MucHVzaCh7XHJcbiAgICAgIGF0OiBjaHVuay5sZW5ndGgsXHJcbiAgICAgIGZvcm1hdDogXCJoaVwiLFxyXG4gICAgICBsYWJlbDogYXJnLFxyXG4gICAgfSk7XHJcblxyXG4gICAgY2h1bmsucHVzaChcIlhYXCIpO1xyXG4gIH1cclxuXHJcbiAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XHJcbiAgICAgXHJcbiAgICAvLyBXYXMgY2FsbGVkIGFzLCBlZy4gXCJMREEgYGxhYmVsYFwiXHJcblxyXG4gICAgbGlua2VyVGFza3MucHVzaCh7XHJcbiAgICAgIGF0OiBjaHVuay5sZW5ndGgsXHJcbiAgICAgIGZvcm1hdDogXCJsb1wiLFxyXG4gICAgICBsYWJlbDogYXJnWzBdLFxyXG4gICAgfSk7XHJcblxyXG4gICAgY2h1bmsucHVzaChcIlhYXCIpO1xyXG5cclxuICAgIGxpbmtlclRhc2tzLnB1c2goe1xyXG4gICAgICBhdDogY2h1bmsubGVuZ3RoLFxyXG4gICAgICBmb3JtYXQ6IFwiaGlcIixcclxuICAgICAgbGFiZWw6IGFyZ1swXSxcclxuICAgIH0pO1xyXG5cclxuICAgIGNodW5rLnB1c2goXCJYWFwiKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5vT3BlcmFuZChjaHVuaywgbGlua2VyVGFza3MsIGFyZykge1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWxPcGVyYW5kKGNodW5rLCBsaW5rZXJUYXNrcywgYXJnKSB7XHJcblxyXG4gIC8vIFRPRE8gd2Ugc2hvdWxkIGFsbG93IHJlbCB3aXRoIGEgZnVuY3Rpb24gYXJnXHJcbiAgaWYgKHR5cGVvZiBhcmcgPT09IFwibnVtYmVyXCIpIHtcclxuXHJcbiAgICAvLyBiYWNrIHdoZW4gd2UgcHVzaGVkIHRoZSByZWxhdGl2ZSBhcmdcclxuICAgIC8vIGNodW5rLnB1c2goYXJnKTtcclxuXHJcbiAgICBsaW5rZXJUYXNrcy5wdXNoKHtcclxuICAgICAgYXQ6IGNodW5rLmxlbmd0aCxcclxuICAgICAgZm9ybWF0OiBcInJlbEZyb21BYnNvbHV0ZVwiLFxyXG4gICAgICB0YXJnZXQ6IGFyZyxcclxuICAgIH0pO1xyXG5cclxuICAgIGNodW5rLnB1c2goXCJYWFwiKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGxldCBsYWJlbDtcclxuXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xyXG4gICAgbGFiZWwgPSBhcmdbMF07XHJcbiAgfVxyXG4gIGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCIpIHtcclxuICAgIGxhYmVsID0gYXJnO1xyXG4gIH1cclxuXHJcbiAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHR5cGUgZm9yIHJlbGF0aXZlIG1vZGU6XCIgKyBhcmcpO1xyXG5cclxuICBsaW5rZXJUYXNrcy5wdXNoKHtcclxuICAgIGF0OiBjaHVuay5sZW5ndGgsXHJcbiAgICBmb3JtYXQ6IFwicmVsRnJvbUxhYmVsXCIsXHJcbiAgICBsYWJlbCxcclxuICB9KTtcclxuXHJcbiAgY2h1bmsucHVzaChcIlhYXCIpO1xyXG59XHJcblxyXG5jb25zdCBvcGVyYW5kSGFuZGxlciA9IHtcclxuICBpbW06IGJ5dGVPcGVyYW5kLFxyXG4gIGFjYzogICBub09wZXJhbmQsXHJcbiAgYWJzOiBhZGRyT3BlcmFuZCxcclxuICBhYng6IGFkZHJPcGVyYW5kLFxyXG4gIGFieTogYWRkck9wZXJhbmQsXHJcbiAgaW1wOiAgIG5vT3BlcmFuZCxcclxuICBpbmQ6IGFkZHJPcGVyYW5kLFxyXG4gIGlueDogYnl0ZU9wZXJhbmQsXHJcbiAgaW55OiBieXRlT3BlcmFuZCxcclxuICByZWw6ICByZWxPcGVyYW5kLFxyXG4gIHpwZzogYnl0ZU9wZXJhbmQsXHJcbiAgenB4OiBieXRlT3BlcmFuZCxcclxuICB6cHk6IGJ5dGVPcGVyYW5kLFxyXG59O1xyXG5cclxuZnVuY3Rpb24gbGluayhjaHVuaywgb3JnLCBsaW5rZXJUYXNrcywgbGFiZWxzKSB7XHJcblxyXG4gIGNvbnN0IGdldExhYmVsID0gbGFiZWwgPT4ge1xyXG4gICAgY29uc3QgYWRkciA9IGxhYmVsc1tsYWJlbF07XHJcbiAgICBpZiAoYWRkciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZGVmaW5lZCBsYWJlbDogXCIgKyBsYWJlbCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYWRkcjtcclxuICB9O1xyXG5cclxuICBsaW5rZXJUYXNrcy5mb3JFYWNoKFxyXG4gICAgKHsgYXQsIGZvcm1hdCwgbGFiZWwsIGZuLCBkaWdpdHMsIHRhcmdldCB9KSA9PiB7XHJcblxyXG4gICAgICBzd2l0Y2ggKGZvcm1hdCkge1xyXG5cclxuICAgICAgICBjYXNlIFwibG9oaUZuXCI6XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgLy8gQSBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkLCBhbmQgaXRzIHJldHVybiB2YWx1ZSBjb25zaWRlcmVkXHJcbiAgICAgICAgICAvLyBhbiBhZGRyZXNzLCB3aGljaCB3ZSBuZWVkIHRvIHN0b3JlIGluIGxvd2J5dGUvaGlnaGJ5dGUgZm9ybS5cclxuICAgICAgICAgIGNvbnN0IGFkZHIgPSBmbihsYWJlbHMpO1xyXG5cclxuICAgICAgICAgIHZhbGlkYXRlQWRkcihhZGRyKTtcclxuXHJcbiAgICAgICAgICBjaHVua1thdCArIDBdID0gYWRkciAmIDB4ZmY7XHJcbiAgICAgICAgICBjaHVua1thdCArIDFdID0gYWRkciA+PiA4O1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjYXNlIFwicGV0c2NpaUZuXCI6XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgLy8gQSBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkLCBhbmQgaXRzIHJldHVybiB2YWx1ZSBjb25zaWRlcmVkXHJcbiAgICAgICAgICAvLyBhbiBhZGRyZXNzLCB3aGljaCB3ZSBuZWVkIHRvIHN0b3JlIGluIFBldHNjaWkgY2hhcmFjdGVycyBpblxyXG4gICAgICAgICAgLy8gYGRpZ2l0c2AgbnVtYmVyIG9mIGRpZ2l0cy5cclxuICAgICAgICAgIGNvbnN0IGFkZHIgPSBmbihsYWJlbHMpO1xyXG5cclxuICAgICAgICAgIHZhbGlkYXRlQWRkcihhZGRyKTtcclxuXHJcbiAgICAgICAgICBjb25zdCBhZGRyQXNTdHJpbmcgPSBTdHJpbmcoYWRkcik7XHJcblxyXG4gICAgICAgICAgaWYgKGFkZHJBc1N0cmluZy5sZW5ndGggPiBkaWdpdHMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgZml0IGFkZHJlc3MgaW50byByZXF1ZXN0ZWQgbnVtYmVyIG9mIGRpZ2l0c1wiKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjb25zdCBhZGRyQXNQYWRkZWRTdHJpbmcgPSBTdHJpbmcoYWRkcikucGFkU3RhcnQoZGlnaXRzLCBcIjBcIik7XHJcblxyXG4gICAgICAgICAgQXJyYXkuZnJvbShhZGRyQXNQYWRkZWRTdHJpbmcpLmZvckVhY2goXHJcbiAgICAgICAgICAgIChsZXR0ZXIsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgY2h1bmtbYXQgKyBpbmRleF0gPSBsZXR0ZXIuY2hhckNvZGVBdCgwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgKVxyXG5cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2FzZSBcImxvXCI6XHJcbiAgICAgICAgICBjaHVua1thdF0gPSBnZXRMYWJlbChsYWJlbCkgJiAweGZmO1xyXG4gICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgXCJoaVwiOlxyXG4gICAgICAgICAgY2h1bmtbYXRdID0gZ2V0TGFiZWwobGFiZWwpID4+IDg7XHJcbiAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSBcInJlbEZyb21BYnNvbHV0ZVwiOlxyXG4gICAgICAgIHtcclxuICAgICAgICAgIC8vIC0xIGluc3RlYWQgb2YgLTIgYmVjYXVzZSB0aGUgJ2F0JyBpbiB0aGlzIGNhc2UgaXMgdGhlIG9wZXJhbmQsXHJcbiAgICAgICAgICAvLyBub3QgdGhlIG9wY29kZVxyXG4gICAgICAgICAgY29uc3QgdmFsID0gdGFyZ2V0IC0gKGF0ICsgb3JnKSAtIDE7XHJcblxyXG4gICAgICAgICAgaWYgKCh2YWwgPiAxMjcpIHx8ICh2YWwgPCAtMTI4KSkgXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYnJhbmNoIHRhcmdldCAke2xhYmVsfSB0b28gZmFyICgke3ZhbH0pIGF0IG9mZnNldCAke2F0fWApO1xyXG5cclxuICAgICAgICAgIGNodW5rW2F0XSA9IHZhbCAmIDB4ZmY7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNhc2UgXCJyZWxGcm9tTGFiZWxcIjpcclxuICAgICAgICB7XHJcbiAgICAgICAgICBjb25zdCBhZGRyID0gZ2V0TGFiZWwobGFiZWwpO1xyXG4gICAgICAgICAgY29uc3QgdmFsID0gYWRkciAtIChhdCArIG9yZykgLSAxO1xyXG5cclxuICAgICAgICAgIGlmICgodmFsID4gMTI3KSB8fCAodmFsIDwgLTEyOCkpIFxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJyYW5jaCB0YXJnZXQgJHtsYWJlbH0gdG9vIGZhciAoJHt2YWx9KWApO1xyXG5cclxuICAgICAgICAgIGNodW5rW2F0XSA9IHZhbCAmIDB4ZmY7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdHJpbmdUb1BldHNjaWlDb2RlcyhudW0pIHtcclxuICByZXR1cm4gQXJyYXkuZnJvbShudW0pLm1hcChjaGFyID0+IGNoYXIuY2hhckNvZGVBdCgwKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG51bWJlclRvUGV0c2NpaUNvZGVzKG51bSkge1xyXG4gIHJldHVybiBBcnJheS5mcm9tKFN0cmluZyhudW0pKS5tYXAoY2hhciA9PiBjaGFyLmNoYXJDb2RlQXQoMCkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBiYXNpYyhmbiwgY2h1bmssIG9yZywgbGlua2VyVGFza3MpIHtcclxuXHJcbiAgY29uc3QgY29tbWFuZHMgPSB7XHJcblxyXG4gICAgUkVNOiAoc3RyKSA9PiAoKSA9PiB7XHJcbiAgICAgIGNodW5rLnB1c2goYmFzaWNUb2tlbnMuUkVNKTtcclxuICAgICAgY2h1bmsucHVzaCguLi5zdHJpbmdUb1BldHNjaWlDb2RlcyhcIiBcIikpO1xyXG4gICAgICBjaHVuay5wdXNoKC4uLnN0cmluZ1RvUGV0c2NpaUNvZGVzKHN0cikpO1xyXG4gICAgfSxcclxuXHJcbiAgICBQT0tFOiAoYWRkciwgYnl0ZSkgPT4gKCkgPT4ge1xyXG4gICAgICAvLyBUaGUgYWRkcmVzcywgYW5kIHRoZSBieXRlIHRvIHN0b3JlIGF0IHRoYXQgYWRkcmVzcywgbXVzdCBib3RoIGJlXHJcbiAgICAgIC8vIHNpbXBsZSBudW1iZXJzLiAoV291bGQgYmUgbmljZSB0byBjaGFuZ2UgdGhpcyBpbiBmdXR1cmUpLlxyXG4gICAgICBjaHVuay5wdXNoKGJhc2ljVG9rZW5zLlBPS0UpO1xyXG4gICAgICBjaHVuay5wdXNoKC4uLnN0cmluZ1RvUGV0c2NpaUNvZGVzKFwiIFwiKSk7XHJcbiAgICAgIGNodW5rLnB1c2goLi4ubnVtYmVyVG9QZXRzY2lpQ29kZXMoYWRkcikpO1xyXG4gICAgICBjaHVuay5wdXNoKC4uLnN0cmluZ1RvUGV0c2NpaUNvZGVzKFwiLFwiKSk7XHJcbiAgICAgIGNodW5rLnB1c2goLi4ubnVtYmVyVG9QZXRzY2lpQ29kZXMoYnl0ZSkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBTWVM6IChhZGRyLCBkaWdpdHM9NSkgPT4gKCkgPT4ge1xyXG4gICAgICAvLyBUaGUgYWRkcmVzcyBjYW4gYmUgYSBudW1iZXIsIGEgc3RyaW5nICh0aGUgbmFtZSBvZiBhIGxhYmVsKSwgb3IgYVxyXG4gICAgICAvLyBmdW5jdGlvbiAod2hpY2gsIGdpdmVuIGFsbCB0aGUgbGFiZWxzLCByZXR1cm5zIGEgbnVtYmVyKVxyXG4gICAgICBjaHVuay5wdXNoKGJhc2ljVG9rZW5zLlNZUyk7XHJcbiAgICAgIGNodW5rLnB1c2goLi4uc3RyaW5nVG9QZXRzY2lpQ29kZXMoXCIgXCIpKTtcclxuXHJcbiAgICAgIGlmICh0eXBlb2YgYWRkciA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIGNvbnN0IGxhYmVsID0gYWRkcjtcclxuICAgICAgICBhZGRyID0gKGxhYmVscykgPT4gbGFiZWxzW2xhYmVsXTtcclxuICAgICAgICAvLyAuLi5hbmQgZmFsbCB0aHJvdWdoIHRvIGZ1bmN0aW9uXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0eXBlb2YgYWRkciA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgbGlua2VyVGFza3MucHVzaCh7XHJcbiAgICAgICAgICBhdDogY2h1bmsubGVuZ3RoLFxyXG4gICAgICAgICAgZm9ybWF0OiBcInBldHNjaWlGblwiLFxyXG4gICAgICAgICAgZm46IGFkZHIsXHJcbiAgICAgICAgICBkaWdpdHNcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaWdpdHM7IGkrKykge1xyXG4gICAgICAgICAgY2h1bmsucHVzaChcIlhYXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgY2h1bmsucHVzaCguLi5udW1iZXJUb1BldHNjaWlDb2RlcyhhZGRyKSk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgfTtcclxuXHJcbiAgLy8gQ2FsbCB0aGUgdXNlci1zdXBwbGllZCBmdW5jdGlvbiwgd2hpY2ggd2lsbCByZXR1cm4gYW4gb2JqZWN0IHRoYXQgbWFwc1xyXG4gIC8vIGxpbmUgbnVtYmVycyB0byBmdW5jdGlvbnMgd2hpY2gsIHdoZW4gY2FsbGVkLCBwbGFjZSB0aGUgdG9rZW5pemVkIEJhc2ljXHJcbiAgLy8gY29tbWFuZHMgaW50byB0aGUgY2h1bmsuXHJcbiAgY29uc3QgbnVtYmVyc1RvTGluZXMgPSBmbihjb21tYW5kcyk7XHJcblxyXG4gIE9iamVjdFxyXG4gICAgLy8gQ29udmVydCB0aGUgb2JqZWN0IGludG8gYSBsaXN0IG9mIFtsaW5lIG51bWJlciwgY29tbWFuZF0gZW50cmllc1xyXG4gICAgLmVudHJpZXMobnVtYmVyc1RvTGluZXMpXHJcblxyXG4gICAgLy8gU29ydCB0aGUgbGluZSBudW1iZXJzIG51bWVyaWNhbGx5XHJcbiAgICAuc29ydChcclxuICAgICAgKFtudW1iZXJBLCBjb21tYW5kQV0sIFtudW1iZXJCLCBjb21tYW5kQl0pID0+IChcclxuICAgICAgICBOdW1iZXIobnVtYmVyQSkgPiBOdW1iZXIobnVtYmVyQikgPyAxIDogLTFcclxuICAgICAgKVxyXG4gICAgKVxyXG5cclxuICAgIC8vIExheSBkb3duIGVhY2ggb25lXHJcbiAgICAuZm9yRWFjaChcclxuICAgICAgKFtsaW5lTnVtLCBsaW5lRm5dKSA9PiB7XHJcblxyXG4gICAgICAgIC8vIEFkZCBhIHBsYWNlaG9sZGVyIGZvciB0aGUgYWRkcmVzcyBmb3IgdGhlIG5leHQgbGluZSwgd2hpbGUgd2UncmUgc3RpbGxcclxuICAgICAgICAvLyBmaWd1cmluZyBvdXQgdGhlIGxlbmd0aCBvZiB0aGlzIG9uZS5cclxuICAgICAgICBjb25zdCBwb3NPZk5leHRMaW5lUHRyID0gY2h1bmsubGVuZ3RoO1xyXG4gICAgICAgIGNodW5rLnB1c2goXCJYWFwiLCBcIlhYXCIpO1xyXG5cclxuICAgICAgICAvLyBEZWNsYXJlIHRoZSBsaW5lIG51bWJlciwgaW4gbG93Ynl0ZS9oaWdoYnl0ZSBmb3JtLlxyXG4gICAgICAgIC8vIEl0IGNhbWUgZnJvbSBhIG9iamVjdCBrZXksIHdoaWNoIGlzIGEgc3RyaW5nXHJcbiAgICAgICAgbGluZU51bSA9IE51bWJlcihsaW5lTnVtKTtcclxuICAgICAgICBjaHVuay5wdXNoKGxpbmVOdW0gJiAweGZmKTtcclxuICAgICAgICBjaHVuay5wdXNoKGxpbmVOdW0gPj4gOCk7XHJcblxyXG4gICAgICAgIC8vIExheSBkb3duIHRoZSBsaW5lICh3aGljaCBtYXkgY29udGFpbiBwbGFjZWhvbGRlcnMgYW5kIGdlbmVyYXRlXHJcbiAgICAgICAgLy8gbGlua2VyIHRhc2tzKVxyXG4gICAgICAgIGxpbmVGbigpO1xyXG5cclxuICAgICAgICAvLyBOdWxsLXRlcm1pbmF0ZSB0aGUgQmFzaWMgbGluZVxyXG4gICAgICAgIGNodW5rLnB1c2goMCk7XHJcblxyXG4gICAgICAgIC8vIE5vdyBnbyBiYWNrIGFuZCBzZXQgdGhlICduZXh0IGxpbmUgYWRkcmVzcycgb2YgdGhlIGN1cnJlbnQgbGluZSB0b1xyXG4gICAgICAgIC8vIHRoZSBhZGRyZXNzIHRoYXQgdGhlIG5leHQgbGluZSBpcyBhYm91dCB0byB1c2UuXHJcbiAgICAgICAgY29uc3QgYWRkck9mTmV4dExpbmUgPSBvcmcgKyBjaHVuay5sZW5ndGg7XHJcblxyXG4gICAgICAgIGNodW5rW3Bvc09mTmV4dExpbmVQdHIgKyAwXSA9IGFkZHJPZk5leHRMaW5lICYgMHhmZjtcclxuICAgICAgICBjaHVua1twb3NPZk5leHRMaW5lUHRyICsgMV0gPSBhZGRyT2ZOZXh0TGluZSA+PiA4O1xyXG4gICAgICB9XHJcbiAgICApXHJcbiAgO1xyXG5cclxuICAvLyBUd28gemVybyBieXRlcyBpbnN0ZWFkIG9mIGFuIGFkZHJlc3Mgc2lnbmlmaWVzIHRoZSBlbmQgb2YgdGhlIEJhc2ljIHByb2dyYW1cclxuICBjaHVuay5wdXNoKDAsIDApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYXNzZW1ibGUob3JnLCBmbikge1xyXG5cclxuICBsZXQgY2h1bmsgPSBbXTtcclxuICBjb25zdCBsaW5rZXJUYXNrcyA9IFtdO1xyXG4gIGNvbnN0IGxhYmVscyA9IHt9O1xyXG5cclxuICAvLyAtLS0gbGFiZWwgdG9vbHMgLS0tXHJcblxyXG4gIGNvbnN0IHRvb2xzID0ge307XHJcblxyXG4gIHRvb2xzLl8gPSAoYXJnKSA9PiB7XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJnKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJfIHNob3VsZCBiZSBjYWxsZWQgYXMgX2BgXCIpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbmFtZSA9IGFyZ1swXTtcclxuICAgIGxhYmVsc1tuYW1lXSA9IG9yZyArIGNodW5rLmxlbmd0aDtcclxuICB9XHJcblxyXG4gIHRvb2xzLl8uYmFzaWMgPSAocHJvZ3JhbSkgPT4gYmFzaWMocHJvZ3JhbSwgY2h1bmssIG9yZywgbGlua2VyVGFza3MpO1xyXG5cclxuICB0b29scy5fLmJ5dGVzID0gKC4uLmJ5dGVzKSA9PiB7XHJcbiAgICBieXRlcy5mb3JFYWNoKFxyXG4gICAgICBieXRlID0+IHtcclxuICAgICAgICB2YWxpZGF0ZUJ5dGUoYnl0ZSk7XHJcbiAgICAgICAgY2h1bmsucHVzaChieXRlKTtcclxuICAgICAgfVxyXG4gICAgKTtcclxuICB9O1xyXG5cclxuICB0b29scy5fLmwgPSAoYXJnKSA9PiAoXHJcbiAgICB7XHJcbiAgICAgIC8vIENhbGxpbmcgZnVuY3Rpb24gd2lsbCBhZGQgdGhlIGBhdGBcclxuICAgICAgZm9ybWF0OiBcImxvXCIsXHJcbiAgICAgIGxhYmVsOiBhcmdbMF0sXHJcbiAgICB9XHJcbiAgKTtcclxuXHJcbiAgdG9vbHMuXy5oID0gKGFyZykgPT4gKFxyXG4gICAge1xyXG4gICAgICAvLyBDYWxsaW5nIGZ1bmN0aW9uIHdpbGwgYWRkIHRoZSBgYXRgXHJcbiAgICAgIGZvcm1hdDogXCJoaVwiLFxyXG4gICAgICBsYWJlbDogYXJnWzBdLFxyXG4gICAgfVxyXG4gICk7XHJcblxyXG4gIHRvb2xzLl8ubGFiZWwgPSAoYWRkciwgbmFtZSkgPT4ge1xyXG4gICAgbGFiZWxzW25hbWVdID0gYWRkcjtcclxuICB9O1xyXG5cclxuICAvLyAtLS0gb3BzIC0tLVxyXG5cclxuICBmb3IgKGxldCBpbnNuIGluIG9wY29kZXMpIHtcclxuICAgIHRvb2xzW2luc25dID0ge307XHJcblxyXG4gICAgZm9yIChsZXQgbW9kZSBpbiBvcGNvZGVzW2luc25dKSB7XHJcbiAgICAgIGNvbnN0IG9wY29kZSA9IG9wY29kZXNbaW5zbl1bbW9kZV07XHJcblxyXG4gICAgICB0b29sc1tpbnNuXVttb2RlXSA9IChhcmcpID0+IHtcclxuICAgICAgICBjaHVuay5wdXNoKG9wY29kZSk7XHJcbiAgICAgICAgb3BlcmFuZEhhbmRsZXJbbW9kZV0oY2h1bmssIGxpbmtlclRhc2tzLCBhcmcpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gXCJBc3NlbWJsZVwiXHJcbiAgZm4odG9vbHMpO1xyXG5cclxuICAvLyBMaW5rXHJcbiAgbGluayhjaHVuaywgb3JnLCBsaW5rZXJUYXNrcywgbGFiZWxzKTtcclxuXHJcbiAgcmV0dXJuIGNodW5rO1xyXG59XHJcbiIsIi8qXHJcbiAgU2ltcGxlLCBiYXNpYyBCYXNlNjQgZW5jb2RpbmcvZGVjb2RpbmdcclxuKi9cclxuXHJcbmNvbnN0IHRva2VucyA9XHJcbiAgXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZlwiICsgXHJcbiAgXCJnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NEVuY29kZShxKSB7XHJcbiAgbGV0IG91dCA9IFwiXCI7XHJcblxyXG4gIHdoaWxlIChxLmxlbmd0aCkge1xyXG5cclxuICAgIGxldCAgICAgICAgICAgICAgIHcgID0gcVswXSA8PCAxNjtcclxuICAgIGlmIChxLmxlbmd0aCA+IDEpIHcgfD0gcVsxXSA8PCA4O1xyXG4gICAgaWYgKHEubGVuZ3RoID4gMikgdyB8PSBxWzJdIDw8IDA7XHJcblxyXG4gICAgLy8gICAgICAgICAgICAgICAgPC0tcTAtLT48LS1xMS0tPjwtLXEyLS0+XHJcbiAgICBjb25zdCBvMCA9ICh3ICYgMGIxMTExMTEwMDAwMDAwMDAwMDAwMDAwMDApID4+IDE4O1xyXG4gICAgY29uc3QgbzEgPSAodyAmIDBiMDAwMDAwMTExMTExMDAwMDAwMDAwMDAwKSA+PiAxMjtcclxuICAgIGNvbnN0IG8yID0gKHcgJiAwYjAwMDAwMDAwMDAwMDExMTExMTAwMDAwMCkgPj4gNjtcclxuICAgIGNvbnN0IG8zID0gKHcgJiAwYjAwMDAwMDAwMDAwMDAwMDAwMDExMTExMSkgPj4gMDtcclxuXHJcbiAgICBvdXQgKz0gICAgICAgICAgICAgICAgICB0b2tlbnNbbzBdICAgICAgO1xyXG4gICAgb3V0ICs9ICAgICAgICAgICAgICAgICAgdG9rZW5zW28xXSAgICAgIDtcclxuICAgIG91dCArPSAocS5sZW5ndGggPiAxKSA/IHRva2Vuc1tvMl0gOiBcIj1cIjtcclxuICAgIG91dCArPSAocS5sZW5ndGggPiAyKSA/IHRva2Vuc1tvM10gOiBcIj1cIjtcclxuXHJcbiAgICBxID0gcS5zbGljZSgzLCBxLmxlbmd0aCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gb3V0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYmFzZTY0RGVjb2RlKHEpIHtcclxuICBsZXQgb3V0ID0gW107XHJcblxyXG4gIHdoaWxlIChxLmxlbmd0aCkge1xyXG5cclxuICAgIGNvbnN0IGkwID0gICAgICAgICAgICAgICAgdG9rZW5zLmluZGV4T2YocVswXSkgICAgO1xyXG4gICAgY29uc3QgaTEgPSAgICAgICAgICAgICAgICB0b2tlbnMuaW5kZXhPZihxWzFdKSAgICA7XHJcbiAgICBjb25zdCBpMiA9IHFbMl0gIT09IFwiPVwiID8gdG9rZW5zLmluZGV4T2YocVsyXSkgOiAwO1xyXG4gICAgY29uc3QgaTMgPSBxWzNdICE9PSBcIj1cIiA/IHRva2Vucy5pbmRleE9mKHFbM10pIDogMDtcclxuXHJcbiAgICBjb25zdCB3ID0gKGkwIDw8IDE4KSB8IChpMSA8PCAxMikgfCAoaTIgPDwgNikgfCAoaTMgPDwgMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goKHcgPj4gMTYpICYgMHhmZik7XHJcbiAgICBpZiAocVsyXSAhPT0gXCI9XCIpIG91dC5wdXNoKCh3ID4+ICA4KSAmIDB4ZmYpO1xyXG4gICAgaWYgKHFbM10gIT09IFwiPVwiKSBvdXQucHVzaCgodyA+PiAgMCkgJiAweGZmKTtcclxuXHJcbiAgICBxID0gcS5zdWJzdHIoNCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gb3V0O1xyXG59XHJcbiIsIi8qXHJcbiAgIFRvb2xzIGZvciB0cmFuc2xhdGluZyBpbiBhbmQgb3V0IG9mIEM2NCBmb250IGNvZGVwb2ludHMuXHJcblxyXG4gICBOb3RlIHRoYXQgQzY0IGZvbnQgY29kZXBvaW50cyBhcmVuJ3QgUEVUU0NJSS4gVGhleSdyZSBob3cgUEVUU0NJSSBpc1xyXG4gICBkZWxpdmVyZWQsIGJ1dCB0YWtlIGEgZGlmZmVyZW50IGxheW91dC4gQS1aLCBmb3IgaW5zdGFuY2UsIGFyZSA2NS05MCBpblxyXG4gICBQRVRTQ0lJIChhbmQgQVNDSUkgZm9yIHRoYXQgbWF0dGVyKSwgYnV0IG9jY3VweSBwb3NpdGlvbnMgMS0yNiBvZiB0aGUgZm9udC5cclxuXHJcbiAgIFJlZmVyZW5jZTogaHR0cHM6Ly9zdHlsZTY0Lm9yZy9wZXRzY2lpL1xyXG4qL1xyXG5cclxuY29uc3QgQU5TSV9TR1JfUkVWRVJTRV9PTiAgPSBcIlxceDFiWzdtXCI7XHJcbmNvbnN0IEFOU0lfU0dSX1JFVkVSU0VfT0ZGID0gXCJcXHgxYlsyN21cIjtcclxuXHJcbi8vIFRoZSByaWdodCBwYWlyIGlzIHRoZSAnd2lkZScgdmVyc2lvbiwgY29tcHJpc2luZyAnZnVsbC13aWR0aCcgY2hhcmFjdGVycyxcclxuLy8gYW5kIHBhaXJzIG9mIHJlZ3VsYXIgY2hhcmFjdGVycy4gT24gbXkgdGV4dCBlZGl0b3IsIHRoZSB0d28gZG9uJ3QgcXVpdGVcclxuLy8gbWF0Y2ggaW4gbGVuZ3RoLCBidXQgb24gbXkgdGVybWluYWwgKG1hY09TIFRlcm1pbmFsKSB0aGV5IGRvLiBJdCdzIGFcclxuLy8gcHJldHR5IHRlbnVvdXMgbW9kZS5cclxuY29uc3QgQ0xPU0VTVF9VTklDT0RFUyA9IFtcclxuICAvLyB1bnNoaWZ0ZWQgICB1bnNoaWZ0ZWRcclxuICAvLyAgICAgc2hpZnRlZCAgICAgIHNoaWZ0ZWRcclxuICBbW1wiQFwiLCBcIkBcIl0sIFtcIu+8oFwiLCBcIu+8oFwiXV0sIC8vIDB4MDAgKDApXHJcbiAgW1tcIkFcIiwgXCJhXCJdLCBbXCLvvKFcIiwgXCLvvYFcIl1dLCAvLyAweDAxICgxKVxyXG4gIFtbXCJCXCIsIFwiYlwiXSwgW1wi77yiXCIsIFwi772CXCJdXSwgLy8gMHgwMiAoMilcclxuICBbW1wiQ1wiLCBcImNcIl0sIFtcIu+8o1wiLCBcIu+9g1wiXV0sIC8vIDB4MDMgKDMpXHJcbiAgW1tcIkRcIiwgXCJkXCJdLCBbXCLvvKRcIiwgXCLvvYRcIl1dLCAvLyAweDA0ICg0KVxyXG4gIFtbXCJFXCIsIFwiZVwiXSwgW1wi77ylXCIsIFwi772FXCJdXSwgLy8gMHgwNSAoNSlcclxuICBbW1wiRlwiLCBcImZcIl0sIFtcIu+8plwiLCBcIu+9hlwiXV0sIC8vIDB4MDYgKDYpXHJcbiAgW1tcIkdcIiwgXCJnXCJdLCBbXCLvvKdcIiwgXCLvvYdcIl1dLCAvLyAweDA3ICg3KVxyXG4gIFtbXCJIXCIsIFwiaFwiXSwgW1wi77yoXCIsIFwi772IXCJdXSwgLy8gMHgwOCAoOClcclxuICBbW1wiSVwiLCBcImlcIl0sIFtcIu+8qVwiLCBcIu+9iVwiXV0sIC8vIDB4MDkgKDkpXHJcbiAgW1tcIkpcIiwgXCJqXCJdLCBbXCLvvKpcIiwgXCLvvYpcIl1dLCAvLyAweDBhICgxMClcclxuICBbW1wiS1wiLCBcImtcIl0sIFtcIu+8q1wiLCBcIu+9i1wiXV0sIC8vIDB4MGIgKDExKVxyXG4gIFtbXCJMXCIsIFwibFwiXSwgW1wi77ysXCIsIFwi772MXCJdXSwgLy8gMHgwYyAoMTIpXHJcbiAgW1tcIk1cIiwgXCJtXCJdLCBbXCLvvK1cIiwgXCLvvY1cIl1dLCAvLyAweDBkICgxMylcclxuICBbW1wiTlwiLCBcIm5cIl0sIFtcIu+8rlwiLCBcIu+9jlwiXV0sIC8vIDB4MGUgKDE0KVxyXG4gIFtbXCJPXCIsIFwib1wiXSwgW1wi77yvXCIsIFwi772PXCJdXSwgLy8gMHgwZiAoMTUpXHJcbiAgW1tcIlBcIiwgXCJwXCJdLCBbXCLvvLBcIiwgXCLvvZBcIl1dLCAvLyAweDEwICgxNilcclxuICBbW1wiUVwiLCBcInFcIl0sIFtcIu+8sVwiLCBcIu+9kVwiXV0sIC8vIDB4MTEgKDE3KVxyXG4gIFtbXCJSXCIsIFwiclwiXSwgW1wi77yyXCIsIFwi772SXCJdXSwgLy8gMHgxMiAoMTgpXHJcbiAgW1tcIlNcIiwgXCJzXCJdLCBbXCLvvLNcIiwgXCLvvZNcIl1dLCAvLyAweDEzICgxOSlcclxuICBbW1wiVFwiLCBcInRcIl0sIFtcIu+8tFwiLCBcIu+9lFwiXV0sIC8vIDB4MTQgKDIwKVxyXG4gIFtbXCJVXCIsIFwidVwiXSwgW1wi77y1XCIsIFwi772VXCJdXSwgLy8gMHgxNSAoMjEpXHJcbiAgW1tcIlZcIiwgXCJ2XCJdLCBbXCLvvLZcIiwgXCLvvZZcIl1dLCAvLyAweDE2ICgyMilcclxuICBbW1wiV1wiLCBcIndcIl0sIFtcIu+8t1wiLCBcIu+9l1wiXV0sIC8vIDB4MTcgKDIzKVxyXG4gIFtbXCJYXCIsIFwieFwiXSwgW1wi77y4XCIsIFwi772YXCJdXSwgLy8gMHgxOCAoMjQpXHJcbiAgW1tcIllcIiwgXCJ5XCJdLCBbXCLvvLlcIiwgXCLvvZlcIl1dLCAvLyAweDE5ICgyNSlcclxuICBbW1wiWlwiLCBcInpcIl0sIFtcIu+8ulwiLCBcIu+9mlwiXV0sIC8vIDB4MWEgKDI2KVxyXG4gIFtbXCJbXCIsIFwiW1wiXSwgW1wi77y7XCIsIFwi77y7XCJdXSwgLy8gMHgxYiAoMjcpXHJcbiAgW1tcIsKjXCIsIFwiwqNcIl0sIFtcIu+/oVwiLCBcIu+/oVwiXV0sIC8vIDB4MWMgKDI4KVxyXG4gIFtbXCJdXCIsIFwiXVwiXSwgW1wi77y9XCIsIFwi77y9XCJdXSwgLy8gMHgxZCAoMjkpXHJcbiAgW1tcIuKGkVwiLCBcIuKGkVwiXSwgW1wiIOKGkVwiLCBcIiDihpFcIl1dLCAvLyAweDFlICgzMClcclxuICBbW1wi4oaQXCIsIFwi4oaQXCJdLCBbXCIg4oaQXCIsIFwiIOKGkFwiXV0sIC8vIDB4MWYgKDMxKVxyXG4gIFtbXCIgXCIsIFwiIFwiXSwgW1wi44CAXCIsIFwi44CAXCJdXSwgLy8gMHgyMCAoMzIpXHJcbiAgW1tcIiFcIiwgXCIhXCJdLCBbXCLvvIFcIiwgXCLvvIFcIl1dLCAvLyAweDIxICgzMylcclxuICBbWydcIicsICdcIiddLCBbXCLvvIJcIiwgJ++8giddXSwgLy8gMHgyMiAoMzQpXHJcbiAgW1tcIiNcIiwgXCIjXCJdLCBbXCLvvINcIiwgXCLvvINcIl1dLCAvLyAweDIzICgzNSlcclxuICBbW1wiJFwiLCBcIiRcIl0sIFtcIu+8hFwiLCBcIu+8hFwiXV0sIC8vIDB4MjQgKDM2KVxyXG4gIFtbXCIlXCIsIFwiJVwiXSwgW1wi77yFXCIsIFwi77yFXCJdXSwgLy8gMHgyNSAoMzcpXHJcbiAgW1tcIiZcIiwgXCImXCJdLCBbXCLvvIZcIiwgXCLvvIZcIl1dLCAvLyAweDI2ICgzOClcclxuICBbW1wiJ1wiLCBcIidcIl0sIFtcIu+8h1wiLCBcIu+8h1wiXV0sIC8vIDB4MjcgKDM5KVxyXG4gIFtbXCIoXCIsIFwiKFwiXSwgW1wi77yIXCIsIFwi77yIXCJdXSwgLy8gMHgyOCAoNDApXHJcbiAgW1tcIilcIiwgXCIpXCJdLCBbXCLvvIlcIiwgXCLvvIlcIl1dLCAvLyAweDI5ICg0MSlcclxuICBbW1wiKlwiLCBcIipcIl0sIFtcIu+8ilwiLCBcIu+8ilwiXV0sIC8vIDB4MmEgKDQyKVxyXG4gIFtbXCIrXCIsIFwiK1wiXSwgW1wi77yLXCIsIFwi77yLXCJdXSwgLy8gMHgyYiAoNDMpXHJcbiAgW1tcIixcIiwgXCIsXCJdLCBbXCLvvIxcIiwgXCLvvIxcIl1dLCAvLyAweDJjICg0NClcclxuICBbW1wiLVwiLCBcIi1cIl0sIFtcIu+8jVwiLCBcIu+8jVwiXV0sIC8vIDB4MmQgKDQ1KVxyXG4gIFtbXCIuXCIsIFwiLlwiXSwgW1wi77yOXCIsIFwi77yOXCJdXSwgLy8gMHgyZSAoNDYpXHJcbiAgW1tcIi9cIiwgXCIvXCJdLCBbXCLvvI9cIiwgXCLvvI9cIl1dLCAvLyAweDJmICg0NylcclxuICBbW1wiMFwiLCBcIjBcIl0sIFtcIu+8kFwiLCBcIu+8kFwiXV0sIC8vIDB4MzAgKDQ4KVxyXG4gIFtbXCIxXCIsIFwiMVwiXSwgW1wi77yRXCIsIFwi77yRXCJdXSwgLy8gMHgzMSAoNDkpXHJcbiAgW1tcIjJcIiwgXCIyXCJdLCBbXCLvvJJcIiwgXCLvvJJcIl1dLCAvLyAweDMyICg1MClcclxuICBbW1wiM1wiLCBcIjNcIl0sIFtcIu+8k1wiLCBcIu+8k1wiXV0sIC8vIDB4MzMgKDUxKVxyXG4gIFtbXCI0XCIsIFwiNFwiXSwgW1wi77yUXCIsIFwi77yUXCJdXSwgLy8gMHgzNCAoNTIpXHJcbiAgW1tcIjVcIiwgXCI1XCJdLCBbXCLvvJVcIiwgXCLvvJVcIl1dLCAvLyAweDM1ICg1MylcclxuICBbW1wiNlwiLCBcIjZcIl0sIFtcIu+8llwiLCBcIu+8llwiXV0sIC8vIDB4MzYgKDU0KVxyXG4gIFtbXCI3XCIsIFwiN1wiXSwgW1wi77yXXCIsIFwi77yXXCJdXSwgLy8gMHgzNyAoNTUpXHJcbiAgW1tcIjhcIiwgXCI4XCJdLCBbXCLvvJhcIiwgXCLvvJhcIl1dLCAvLyAweDM4ICg1NilcclxuICBbW1wiOVwiLCBcIjlcIl0sIFtcIu+8mVwiLCBcIu+8mVwiXV0sIC8vIDB4MzkgKDU3KVxyXG4gIFtbXCI6XCIsIFwiOlwiXSwgW1wi77yaXCIsIFwi77yaXCJdXSwgLy8gMHgzYSAoNTgpXHJcbiAgW1tcIjtcIiwgXCI7XCJdLCBbXCLvvJtcIiwgXCLvvJtcIl1dLCAvLyAweDNiICg1OSlcclxuICBbW1wiPFwiLCBcIjxcIl0sIFtcIu+8nFwiLCBcIu+8nFwiXV0sIC8vIDB4M2MgKDYwKVxyXG4gIFtbXCI9XCIsIFwiPVwiXSwgW1wi77ydXCIsIFwi77ydXCJdXSwgLy8gMHgzZCAoNjEpXHJcbiAgW1tcIj5cIiwgXCI+XCJdLCBbXCLvvJ5cIiwgXCLvvJ5cIl1dLCAvLyAweDNlICg2MilcclxuICBbW1wiP1wiLCBcIj9cIl0sIFtcIu+8n1wiLCBcIu+8n1wiXV0sIC8vIDB4M2YgKDYzKVxyXG4gIFtbXCLilIBcIiwgXCLilIBcIl0sIFtcIu+8jVwiLCBcIuKUgOKUgFwiXV0sIC8vIDB4NDAgKDY0KVxyXG4gIFtbXCLimaBcIiwgXCJBXCJdLCBbXCIg4pmgXCIsIFwi77yhXCJdXSwgLy8gMHg0MSAoNjUpXHJcbiAgW1tcIuKUglwiLCBcIkJcIl0sIFtcIu+9nFwiLCBcIu+8olwiXV0sIC8vIDB4NDIgKDY2KVxyXG4gIFtbXCLilIBcIiwgXCJDXCJdLCBbXCLilIDilIBcIiwgXCLvvKNcIl1dLCAvLyAweDQzICg2NylcclxuICBbW1wi4pSAXCIsIFwiRFwiXSwgW1wi4pSA4pSAXCIsIFwi77ykXCJdXSwgLy8gMHg0NCAoNjgpXHJcbiAgW1tcIuKWlFwiLCBcIkVcIl0sIFtcIu+/o1wiLCBcIu+8pVwiXV0sIC8vIDB4NDUgKDY5KVxyXG4gIFtbXCLilIBcIiwgXCJGXCJdLCBbXCLilIDilIBcIiwgXCLvvKZcIl1dLCAvLyAweDQ2ICg3MClcclxuICBbW1wi4pSCXCIsIFwiR1wiXSwgW1wi772cXCIsIFwi77ynXCJdXSwgLy8gMHg0NyAoNzEpXHJcbiAgW1tcIuKUglwiLCBcIkhcIl0sIFtcIu+9nFwiLCBcIu+8qFwiXV0sIC8vIDB4NDggKDcyKVxyXG4gIFtbXCLila5cIiwgXCJJXCJdLCBbXCLilIDila5cIiwgXCLvvKlcIl1dLCAvLyAweDQ5ICg3MylcclxuICBbW1wi4pWwXCIsIFwiSlwiXSwgW1wiIOKVsFwiLCBcIu+8qlwiXV0sIC8vIDB4NGEgKDc0KVxyXG4gIFtbXCLila9cIiwgXCJLXCJdLCBbXCLilIDila9cIiwgXCLvvKtcIl1dLCAvLyAweDRiICg3NSlcclxuICBbW1wi4oyeXCIsIFwiTFwiXSwgW1wiIOKMnlwiLCBcIu+8rFwiXV0sIC8vIDB4NGMgKDc2KVxyXG4gIFtbXCLilbJcIiwgXCJNXCJdLCBbXCIg4pWyXCIsIFwi77ytXCJdXSwgLy8gMHg0ZCAoNzcpXHJcbiAgW1tcIuKVsVwiLCBcIk5cIl0sIFtcIiDilbFcIiwgXCLvvK5cIl1dLCAvLyAweDRlICg3OClcclxuICBbW1wi4oycXCIsIFwiT1wiXSwgW1wiIOKMnFwiLCBcIu+8r1wiXV0sIC8vIDB4NGYgKDc5KVxyXG4gIFtbXCLijJ1cIiwgXCJQXCJdLCBbXCLilpTijJ1cIiwgXCLvvLBcIl1dLCAvLyAweDUwICg4MClcclxuICBbW1wi4pePXCIsIFwiUVwiXSwgW1wiIOKXj1wiLCBcIu+8sVwiXV0sIC8vIDB4NTEgKDgxKVxyXG4gIFtbXCJfXCIsIFwiUlwiXSwgW1wi77y/XCIsIFwi77yyXCJdXSwgLy8gMHg1MiAoODIpXHJcbiAgW1tcIuKZpVwiLCBcIlNcIl0sIFtcIiDimaVcIiwgXCLvvLNcIl1dLCAvLyAweDUzICg4MylcclxuICBbW1wi4paOXCIsIFwiVFwiXSwgW1wi4pSCIFwiLCBcIu+8tFwiXV0sIC8vIDB4NTQgKDg0KVxyXG4gIFtbXCLila1cIiwgXCJVXCJdLCBbXCIg4pWtXCIsIFwi77y1XCJdXSwgLy8gMHg1NSAoODUpXHJcbiAgW1tcIuKVs1wiLCBcIlZcIl0sIFtcIj48XCIsIFwi77y2XCJdXSwgLy8gMHg1NiAoODYpXHJcbiAgW1tcIuKXi1wiLCBcIldcIl0sIFtcIiDil4tcIiwgXCLvvLdcIl1dLCAvLyAweDU3ICg4NylcclxuICBbW1wi4pmjXCIsIFwiWFwiXSwgW1wiIOKZo1wiLCBcIu+8uFwiXV0sIC8vIDB4NTggKDg4KVxyXG4gIFtbXCLilpVcIiwgXCJZXCJdLCBbXCIg4paVXCIsIFwi77y5XCJdXSwgLy8gMHg1OSAoODkpXHJcbiAgW1tcIuKZplwiLCBcIlpcIl0sIFtcIiDimaZcIiwgXCLvvLpcIl1dLCAvLyAweDVhICg5MClcclxuICBbW1wi4pS8XCIsIFwi4pS8XCJdLCBbXCLilIDilLxcIiwgXCLilIDilLxcIl1dLCAvLyAweDViICg5MSlcclxuICBbW1wi4paSXCIsIFwi4paSXCJdLCBbXCLilpIgXCIsIFwi4paSIFwiXV0sIC8vIDB4NWMgKDkyKVxyXG4gIFtbXCLilIJcIiwgXCLilIJcIl0sIFtcIiDilIJcIiwgXCIg4pSCXCJdXSwgLy8gMHg1ZCAoOTMpXHJcbiAgW1tcIs+AXCIsIFwi4paSXCJdLCBbXCIgz4BcIiwgXCLilpLilpJcIl1dLCAvLyAweDVlICg5NClcclxuICBbW1wi4pelXCIsIFwi4paSXCJdLCBbXCIg4pelXCIsIFwi4paS4paSXCJdXSwgLy8gMHg1ZiAoOTUpXHJcbiAgW1tcIiBcIiwgXCIgXCJdLCBbXCIgIFwiLCBcIiAgXCJdXSwgLy8gMHg2MCAoOTYpXHJcbiAgW1tcIuKWjFwiLCBcIuKWjFwiXSwgW1wi4paMIFwiLCBcIuKWjCBcIl1dLCAvLyAweDYxICg5NylcclxuICBbW1wi4paEXCIsIFwi4paEXCJdLCBbXCLiloTiloRcIiwgXCLiloTiloRcIl1dLCAvLyAweDYyICg5OClcclxuICBbW1wi4paUXCIsIFwi4paUXCJdLCBbXCLilpTilpRcIiwgXCLilpTilpRcIl1dLCAvLyAweDYzICg5OSlcclxuICBbW1wi4paBXCIsIFwi4paBXCJdLCBbXCLiloHiloFcIiwgXCLiloHiloFcIl1dLCAvLyAweDY0ICgxMDApXHJcbiAgW1tcIuKWjlwiLCBcIuKWjlwiXSwgW1wi4paOIFwiLCBcIuKWjiBcIl1dLCAvLyAweDY1ICgxMDEpXHJcbiAgW1tcIuKWklwiLCBcIuKWklwiXSwgW1wi4paS4paSXCIsIFwi4paS4paSXCJdXSwgLy8gMHg2NiAoMTAyKVxyXG4gIFtbXCLilpVcIiwgXCLilpVcIl0sIFtcIiDilpVcIiwgXCIg4paVXCJdXSwgLy8gMHg2NyAoMTAzKVxyXG4gIFtbXCLilpJcIiwgXCLilpJcIl0sIFtcIuKWkuKWklwiLCBcIuKWkuKWklwiXV0sIC8vIDB4NjggKDEwNClcclxuICBbW1wi4pekXCIsIFwi4paSXCJdLCBbXCIg4pekXCIsIFwi4paS4paSXCJdXSwgLy8gMHg2OSAoMTA1KVxyXG4gIFtbXCLilpVcIiwgXCLilpVcIl0sIFtcIiDilpVcIiwgXCIg4paVXCJdXSwgLy8gMHg2YSAoMTA2KVxyXG4gIFtbXCLilJxcIiwgXCLilJxcIl0sIFtcIiDilJxcIiwgXCIg4pScXCJdXSwgLy8gMHg2YiAoMTA3KVxyXG4gIFtbXCLilpdcIiwgXCLilpdcIl0sIFtcIiDiloRcIiwgXCIg4paEXCJdXSwgLy8gMHg2YyAoMTA4KVxyXG4gIFtbXCLilJRcIiwgXCLilJRcIl0sIFtcIiDilJRcIiwgXCIg4pSUXCJdXSwgLy8gMHg2ZCAoMTA5KVxyXG4gIFtbXCLilJBcIiwgXCLilJBcIl0sIFtcIuKUgOKUkFwiLCBcIuKUgOKUkFwiXV0sIC8vIDB4NmUgKDExMClcclxuICBbW1wi4paCXCIsIFwi4paCXCJdLCBbXCLiloLiloJcIiwgXCLiloLiloJcIl1dLCAvLyAweDZmICgxMTEpXHJcbiAgW1tcIuKUjFwiLCBcIuKUjFwiXSwgW1wiIOKUjFwiLCBcIiDilIxcIl1dLCAvLyAweDcwICgxMTIpXHJcbiAgW1tcIuKUtFwiLCBcIuKUtFwiXSwgW1wi4pSA4pS0XCIsIFwi4pSA4pS0XCJdXSwgLy8gMHg3MSAoMTEzKVxyXG4gIFtbXCLilKxcIiwgXCLilKxcIl0sIFtcIuKUgOKUrFwiLCBcIuKUgOKUrFwiXV0sIC8vIDB4NzIgKDExNClcclxuICBbW1wi4pSkXCIsIFwi4pSkXCJdLCBbXCLilIDilKRcIiwgXCLilIDilKRcIl1dLCAvLyAweDczICgxMTUpXHJcbiAgW1tcIuKWjlwiLCBcIuKWjlwiXSwgW1wi4paOIFwiLCBcIuKWjiBcIl1dLCAvLyAweDc0ICgxMTYpXHJcbiAgW1tcIuKWjVwiLCBcIuKWjVwiXSwgW1wi4paNIFwiLCBcIuKWjSBcIl1dLCAvLyAweDc1ICgxMTcpXHJcbiAgW1tcIuKWlVwiLCBcIuKWlVwiXSwgW1wiIOKWlVwiLCBcIuKWlSBcIl1dLCAvLyAweDc2ICgxMTgpXHJcbiAgW1tcIuKWlFwiLCBcIuKWlFwiXSwgW1wi4paU4paUXCIsIFwi4paU4paUXCJdXSwgLy8gMHg3NyAoMTE5KVxyXG4gIFtbXCLilpRcIiwgXCLilpRcIl0sIFtcIuKWlOKWlFwiLCBcIuKWlOKWlFwiXV0sIC8vIDB4NzggKDEyMClcclxuICBbW1wi4paDXCIsIFwi4paDXCJdLCBbXCLiloPiloNcIiwgXCLiloPiloNcIl1dLCAvLyAweDc5ICgxMjEpXHJcbiAgW1tcIuKMn1wiLCBcIuKck1wiXSwgW1wi4paB4oyfXCIsIFwiIOKck1wiXV0sIC8vIDB4N2EgKDEyMilcclxuICBbW1wi4paWXCIsIFwi4paWXCJdLCBbXCLiloMgXCIsIFwi4paDIFwiXV0sIC8vIDB4N2IgKDEyMylcclxuICBbW1wi4padXCIsIFwi4padXCJdLCBbXCIg4padXCIsIFwiIOKWnVwiXV0sIC8vIDB4N2MgKDEyNClcclxuICBbW1wi4pSYXCIsIFwi4pSYXCJdLCBbXCLilIDilJhcIiwgXCLilIDilJhcIl1dLCAvLyAweDdkICgxMjUpXHJcbiAgW1tcIuKWmFwiLCBcIuKWmFwiXSwgW1wi4paYIFwiLCBcIuKWmCBcIl1dLCAvLyAweDdlICgxMjYpXHJcbiAgW1tcIuKWmlwiLCBcIuKWmlwiXSwgW1wi4paa4paEXCIsIFwi4paa4paEXCJdXSwgLy8gMHg3ZiAoMTI3KVxyXG5dO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGM2NEZvbnRDb2RlUG9pbnRUb0NoYXIoYnl0ZSwgc2hpZnRlZCwgd2lkZSkge1xyXG4gIGlmIChieXRlID49IDB4ODApIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIEFOU0lfU0dSX1JFVkVSU0VfT04gK1xyXG4gICAgICBjNjRGb250Q29kZVBvaW50VG9DaGFyKGJ5dGUgJiAweDdmLCBzaGlmdGVkLCB3aWRlKSArXHJcbiAgICAgIEFOU0lfU0dSX1JFVkVSU0VfT0ZGXHJcbiAgICApO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBDTE9TRVNUX1VOSUNPREVTW2J5dGVdW3dpZGUgPyAxIDogMF1bc2hpZnRlZCA/IDEgOiAwXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNoYXJUb0M2NEZvbnRDb2RlUG9pbnQoY2hhciwgc2hpZnRlZCkge1xyXG4gIGlmICghc2hpZnRlZCkge1xyXG4gICAgLy8gUXVpY2sgY2FzZXNcclxuICAgIGlmICgoY2hhciA+PSBcIjBcIikgJiYgKGNoYXIgPD0gXCI5XCIpKSByZXR1cm4gY2hhci5jaGFyQ29kZUF0KDApO1xyXG4gICAgaWYgKChjaGFyID49IFwiQVwiKSAmJiAoY2hhciA8PSBcIlpcIikpIHJldHVybiBjaGFyLmNoYXJDb2RlQXQoMCkgLSAweDQwO1xyXG4gICAgaWYgKChjaGFyID49IFwiYVwiKSAmJiAoY2hhciA8PSBcInpcIikpIHJldHVybiBjaGFyLmNoYXJDb2RlQXQoMCkgLSAweDYwO1xyXG4gICAgaWYgKGNoYXIgPT09IFwiIFwiKSAgICAgICAgICAgICAgICAgICByZXR1cm4gMHgyMDtcclxuICB9XHJcblxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTI4OyBpKyspIHtcclxuICAgIGlmIChDTE9TRVNUX1VOSUNPREVTW2ldWzBdW3NoaWZ0ZWQgPyAxIDogMF0gPT09IGNoYXIpIHJldHVybiBpOyBcclxuICB9XHJcblxyXG4gIHJldHVybiAweDIwO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgaGV4RGlnaXRUb0M2NEZvbnRDb2RlUG9pbnQgPSBbXHJcbiAgMHgzMCwgMHgzMSwgMHgzMiwgMHgzMyxcclxuICAweDM0LCAweDM1LCAweDM2LCAweDM3LFxyXG4gIDB4MzgsIDB4MzksIDB4MDEsIDB4MDIsXHJcbiAgMHgwMywgMHgwNCwgMHgwNSwgMHgwNixcclxuXTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBwZXRzY2lpVG9Gb250Q29kZVBvaW50KG51bSkge1xyXG4gIC8vIFNlZSBLZXJuYWwgYXJvdW5kICRlNzM3XHJcbiAgaWYgKG51bSA8ICAweDIwKSByZXR1cm4gMHgyMDtcclxuICBpZiAobnVtID49IDB4NjApIHJldHVybiBudW0gJiAweGRmO1xyXG4gIGVsc2UgICAgICAgICAgICAgcmV0dXJuIG51bSAmIDB4M2Y7XHJcbn1cclxuIiwiLypcclxuICAgQSBkaXNhc3NlbWJsZXIgZm9yIGxpdmUgbWVtb3J5XHJcbiovXHJcblxyXG5pbXBvcnQgeyB4eCwgJHh4LCAkeHh4eCB9IGZyb20gXCIuLi9kZWJ1Z1wiO1xyXG5cclxuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vd3d3Lm1hc3N3ZXJrLmF0LzY1MDIvNjUwMl9pbnN0cnVjdGlvbl9zZXQuaHRtbFxyXG4vLyBUT0RPOiBUaGlzIGRvZXNuJ3QgaW5jbHVkZSB0aGUgcXVhc2ktb3BzXHJcbmNvbnN0IG9wY29kZXMgPSBbXHJcbi8qICAgICAgIHgwICAgICAgICAgICB4MSAgICAgICAgICAgeDIgICAgICAgeDMgICAgIHg0ICAgICAgICAgICB4NSAgICAgICAgICAgeDYgICAgICAgICAgIHg3ICAgICB4OCAgICAgICAgICB4OSAgICAgICAgICAgeEEgICAgICAgICAgeEIgICAgIHhDICAgICAgICAgICB4RCAgICAgICAgICAgeEUgICAgICAgICAgIHhGICAqL1xyXG4vKiAweCAqLyBcIkJSSyBpbXBsXCIsICBcIk9SQSBYLGluZFwiLCBcIi0tLVwiLCAgIFwiLS0tXCIsIFwiLS0tXCIsICAgICAgIFwiT1JBIHpwZ1wiLCAgIFwiQVNMIHpwZ1wiLCAgIFwiLS0tXCIsIFwiUEhQIGltcGxcIiwgXCJPUkEgI1wiLCAgICAgXCJBU0wgQVwiLCAgICBcIi0tLVwiLCBcIi0tLVwiLCAgICAgICBcIk9SQSBhYnNcIiwgICBcIkFTTCBhYnNcIiwgICBcIi0tLVwiLFxyXG4vKiAxeCAqLyBcIkJQTCByZWxcIiwgICBcIk9SQSBpbmQsWVwiLCBcIi0tLVwiLCAgIFwiLS0tXCIsIFwiLS0tXCIsICAgICAgIFwiT1JBIHpwZyxYXCIsIFwiQVNMIHpwZyxYXCIsIFwiLS0tXCIsIFwiQ0xDIGltcGxcIiwgXCJPUkEgYWJzLFlcIiwgXCItLS1cIiwgICAgICBcIi0tLVwiLCBcIi0tLVwiLCAgICAgICBcIk9SQSBhYnMsWFwiLCBcIkFTTCBhYnMsWFwiLCBcIi0tLVwiLFxyXG4vKiAyeCAqLyBcIkpTUiBhYnNcIiwgICBcIkFORCBYLGluZFwiLCBcIi0tLVwiLCAgIFwiLS0tXCIsIFwiQklUIHpwZ1wiLCAgIFwiQU5EIHpwZ1wiLCAgIFwiUk9MIHpwZ1wiLCAgIFwiLS0tXCIsIFwiUExQIGltcGxcIiwgXCJBTkQgI1wiLCAgICAgXCJST0wgQVwiLCAgICBcIi0tLVwiLCBcIkJJVCBhYnNcIiwgICBcIkFORCBhYnNcIiwgICBcIlJPTCBhYnNcIiwgICBcIi0tLVwiLFxyXG4vKiAzeCAqLyBcIkJNSSByZWxcIiwgICBcIkFORCBpbmQsWVwiLCBcIi0tLVwiLCAgIFwiLS0tXCIsIFwiLS0tXCIsICAgICAgIFwiQU5EIHpwZyxYXCIsIFwiUk9MIHpwZyxYXCIsIFwiLS0tXCIsIFwiU0VDIGltcGxcIiwgXCJBTkQgYWJzLFlcIiwgXCItLS1cIiwgICAgICBcIi0tLVwiLCBcIi0tLVwiLCAgICAgICBcIkFORCBhYnMsWFwiLCBcIlJPTCBhYnMsWFwiLCBcIi0tLVwiLFxyXG4vKiA0eCAqLyBcIlJUSSBpbXBsXCIsICBcIkVPUiBYLGluZFwiLCBcIi0tLVwiLCAgIFwiLS0tXCIsIFwiLS0tXCIsICAgICAgIFwiRU9SIHpwZ1wiLCAgIFwiTFNSIHpwZ1wiLCAgIFwiLS0tXCIsIFwiUEhBIGltcGxcIiwgXCJFT1IgI1wiLCAgICAgXCJMU1IgQVwiLCAgICBcIi0tLVwiLCBcIkpNUCBhYnNcIiwgICBcIkVPUiBhYnNcIiwgICBcIkxTUiBhYnNcIiwgICBcIi0tLVwiLFxyXG4vKiA1eCAqLyBcIkJWQyByZWxcIiwgICBcIkVPUiBpbmQsWVwiLCBcIi0tLVwiLCAgIFwiLS0tXCIsIFwiLS0tXCIsICAgICAgIFwiRU9SIHpwZyxYXCIsIFwiTFNSIHpwZyxYXCIsIFwiLS0tXCIsIFwiQ0xJIGltcGxcIiwgXCJFT1IgYWJzLFlcIiwgXCItLS1cIiwgICAgICBcIi0tLVwiLCBcIi0tLVwiLCAgICAgICBcIkVPUiBhYnMsWFwiLCBcIkxTUiBhYnMsWFwiLCBcIi0tLVwiLFxyXG4vKiA2eCAqLyBcIlJUUyBpbXBsXCIsICBcIkFEQyBYLGluZFwiLCBcIi0tLVwiLCAgIFwiLS0tXCIsIFwiLS0tXCIsICAgICAgIFwiQURDIHpwZ1wiLCAgIFwiUk9SIHpwZ1wiLCAgIFwiLS0tXCIsIFwiUExBIGltcGxcIiwgXCJBREMgI1wiLCAgICAgXCJST1IgQVwiLCAgICBcIi0tLVwiLCBcIkpNUCBpbmRcIiwgICBcIkFEQyBhYnNcIiwgICBcIlJPUiBhYnNcIiwgICBcIi0tLVwiLFxyXG4vKiA3eCAqLyBcIkJWUyByZWxcIiwgICBcIkFEQyBpbmQsWVwiLCBcIi0tLVwiLCAgIFwiLS0tXCIsIFwiLS0tXCIsICAgICAgIFwiQURDIHpwZyxYXCIsIFwiUk9SIHpwZyxYXCIsIFwiLS0tXCIsIFwiU0VJIGltcGxcIiwgXCJBREMgYWJzLFlcIiwgXCItLS1cIiwgICAgICBcIi0tLVwiLCBcIi0tLVwiLCAgICAgICBcIkFEQyBhYnMsWFwiLCBcIlJPUiBhYnMsWFwiLCBcIi0tLVwiLFxyXG4vKiA4eCAqLyBcIi0tLVwiLCAgICAgICBcIlNUQSBYLGluZFwiLCBcIi0tLVwiLCAgIFwiLS0tXCIsIFwiU1RZIHpwZ1wiLCAgIFwiU1RBIHpwZ1wiLCAgIFwiU1RYIHpwZ1wiLCAgIFwiLS0tXCIsIFwiREVZIGltcGxcIiwgXCItLS1cIiwgICAgICAgXCJUWEEgaW1wbFwiLCBcIi0tLVwiLCBcIlNUWSBhYnNcIiwgICBcIlNUQSBhYnNcIiwgICBcIlNUWCBhYnNcIiwgICBcIi0tLVwiLFxyXG4vKiA5eCAqLyBcIkJDQyByZWxcIiwgICBcIlNUQSBpbmQsWVwiLCBcIi0tLVwiLCAgIFwiLS0tXCIsIFwiU1RZIHpwZyxYXCIsIFwiU1RBIHpwZyxYXCIsIFwiU1RYIHpwZyxZXCIsIFwiLS0tXCIsIFwiVFlBIGltcGxcIiwgXCJTVEEgYWJzLFlcIiwgXCJUWFMgaW1wbFwiLCBcIi0tLVwiLCBcIi0tLVwiLCAgICAgICBcIlNUQSBhYnMsWFwiLCBcIi0tLVwiLCAgICAgICBcIi0tLVwiLFxyXG4vKiBBeCAqLyBcIkxEWSAjXCIsICAgICBcIkxEQSBYLGluZFwiLCBcIkxEWCAjXCIsIFwiLS0tXCIsIFwiTERZIHpwZ1wiLCAgIFwiTERBIHpwZ1wiLCAgIFwiTERYIHpwZ1wiLCAgIFwiLS0tXCIsIFwiVEFZIGltcGxcIiwgXCJMREEgI1wiLCAgICAgXCJUQVggaW1wbFwiLCBcIi0tLVwiLCBcIkxEWSBhYnNcIiwgICBcIkxEQSBhYnNcIiwgICBcIkxEWCBhYnNcIiwgICBcIi0tLVwiLFxyXG4vKiBCeCAqLyBcIkJDUyByZWxcIiwgICBcIkxEQSBpbmQsWVwiLCBcIi0tLVwiLCAgIFwiLS0tXCIsIFwiTERZIHpwZyxYXCIsIFwiTERBIHpwZyxYXCIsIFwiTERYIHpwZyxZXCIsIFwiLS0tXCIsIFwiQ0xWIGltcGxcIiwgXCJMREEgYWJzLFlcIiwgXCJUU1ggaW1wbFwiLCBcIi0tLVwiLCBcIkxEWSBhYnMsWFwiLCBcIkxEQSBhYnMsWFwiLCBcIkxEWCBhYnMsWVwiLCBcIi0tLVwiLFxyXG4vKiBDeCAqLyBcIkNQWSAjXCIsICAgICBcIkNNUCBYLGluZFwiLCBcIi0tLVwiLCAgIFwiLS0tXCIsIFwiQ1BZIHpwZ1wiLCAgIFwiQ01QIHpwZ1wiLCAgIFwiREVDIHpwZ1wiLCAgIFwiLS0tXCIsIFwiSU5ZIGltcGxcIiwgXCJDTVAgI1wiLCAgICAgXCJERVggaW1wbFwiLCBcIi0tLVwiLCBcIkNQWSBhYnNcIiwgICBcIkNNUCBhYnNcIiwgICBcIkRFQyBhYnNcIiwgICBcIi0tLVwiLFxyXG4vKiBEeCAqLyBcIkJORSByZWxcIiwgICBcIkNNUCBpbmQsWVwiLCBcIi0tLVwiLCAgIFwiLS0tXCIsIFwiLS0tXCIsICAgICAgIFwiQ01QIHpwZyxYXCIsIFwiREVDIHpwZyxYXCIsIFwiLS0tXCIsIFwiQ0xEIGltcGxcIiwgXCJDTVAgYWJzLFlcIiwgXCItLS1cIiwgICAgICBcIi0tLVwiLCBcIi0tLVwiLCAgICAgICBcIkNNUCBhYnMsWFwiLCBcIkRFQyBhYnMsWFwiLCBcIi0tLVwiLFxyXG4vKiBFeCAqLyBcIkNQWCAjXCIsICAgICBcIlNCQyBYLGluZFwiLCBcIi0tLVwiLCAgIFwiLS0tXCIsIFwiQ1BYIHpwZ1wiLCAgIFwiU0JDIHpwZ1wiLCAgIFwiSU5DIHpwZ1wiLCAgIFwiLS0tXCIsIFwiSU5YIGltcGxcIiwgXCJTQkMgI1wiLCAgICAgXCJOT1AgaW1wbFwiLCBcIi0tLVwiLCBcIkNQWCBhYnNcIiwgICBcIlNCQyBhYnNcIiwgICBcIklOQyBhYnNcIiwgICBcIi0tLVwiLFxyXG4vKiBGeCAqLyBcIkJFUSByZWxcIiwgICBcIlNCQyBpbmQsWVwiLCBcIi0tLVwiLCAgIFwiLS0tXCIsIFwiLS0tXCIsICAgICAgIFwiU0JDIHpwZyxYXCIsIFwiSU5DIHpwZyxYXCIsIFwiLS0tXCIsIFwiU0VEIGltcGxcIiwgXCJTQkMgYWJzLFlcIiwgXCItLS1cIiwgICAgICBcIi0tLVwiLCBcIi0tLVwiLCAgICAgICBcIlNCQyBhYnMsWFwiLCBcIklOQyBhYnMsWFwiLCBcIi0tLVwiLFxyXG5dO1xyXG5cclxuLy8gTnVtYmVyIG9mIGJ5dGVzIHRoYXQgbmVlZCB0byBiZSByZWFkIGZvciBvcGNvZGVzIG9mIGVhY2ggYWRkcmVzc2luZyBtb2RlLFxyXG4vLyBpbmNsdWRpbmcgdGhlIG9wY29kZSBpdHNlbGZcclxuY29uc3QgYnl0ZXNGb3JPcGNvZGUgPSBvcGNvZGVzLm1hcChcclxuICBvcGNvZGUgPT4gKHtcclxuICAgICAgXCJhYnNcIjogICAzLFxyXG4gICAgICBcImFicyxYXCI6IDMsXHJcbiAgICAgIFwiYWJzLFlcIjogMyxcclxuICAgICAgXCJpbmRcIjogICAzLFxyXG4gICAgICBcInpwZ1wiOiAgIDIsXHJcbiAgICAgIFwienBnLFhcIjogMixcclxuICAgICAgXCJ6cGcsWVwiOiAyLFxyXG4gICAgICBcInJlbFwiOiAgIDIsXHJcbiAgICAgIFwiWCxpbmRcIjogMixcclxuICAgICAgXCJpbmQsWVwiOiAyLFxyXG4gICAgICBcIiNcIjogICAgIDIsXHJcbiAgICAgIFwiQVwiOiAgICAgMSxcclxuICAgICAgXCJpbXBsXCI6ICAxLFxyXG4gICAgICBcIlwiOiAgICAgIDFcclxuICAgIH0pW29wY29kZS5zdWJzdHJpbmcoNCldXHJcbik7XHJcblxyXG5mdW5jdGlvbiB1aW50OFRvTnVtKGIpIHtcclxuICByZXR1cm4gYiA8IDB4ODAgPyBiIDogLSgyNTYgLSBiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRpc2FzbShjcHVSZWFkLCBhZGRyLCB0bykge1xyXG5cclxuICBjb25zdCBsaW5lcyA9IFtdO1xyXG5cclxuICB3aGlsZSAoYWRkciA8IHRvKSB7XHJcblxyXG4gICAgLy8gRGlzcGxheSB0aGUgYWRkcmVzc1xyXG4gICAgbGV0IGxpbmUgPSBgJHskeHh4eChhZGRyKX06IGA7XHJcblxyXG4gICAgLy8gRGlzcGxheSB0aGUgaW5zdHJ1Y3Rpb24ncyByYXcgYnl0ZXMsIGhvd2V2ZXIgbWFueSB0aGVyZSBtaWdodCBiZVxyXG4gICAgY29uc3QgYjAgPSBjcHVSZWFkKChhZGRyICsgMCkgJiAweGZmZmYpO1xyXG4gICAgY29uc3QgYjEgPSBjcHVSZWFkKChhZGRyICsgMSkgJiAweGZmZmYpO1xyXG4gICAgY29uc3QgYjIgPSBjcHVSZWFkKChhZGRyICsgMikgJiAweGZmZmYpO1xyXG5cclxuICAgIGNvbnN0IGxlbmd0aCA9IGJ5dGVzRm9yT3Bjb2RlW2IwXTtcclxuXHJcbiAgICBsaW5lICs9ICggICAgICAgICAgICAgICB4eChiMCkgICAgICAgKSArIFwiIFwiO1xyXG4gICAgbGluZSArPSAoKGxlbmd0aCA+IDEpID8geHgoYjEpIDogXCIgIFwiKSArIFwiIFwiO1xyXG4gICAgbGluZSArPSAoKGxlbmd0aCA+IDIpID8geHgoYjIpIDogXCIgIFwiKSArIFwiIFwiO1xyXG4gICAgbGluZSArPSBcIiAgXCI7XHJcblxyXG4gICAgLy8gRGlzcGxheSB0aGUgb3Bjb2RlXHJcbiAgICBjb25zdCBvcCAgID0gb3Bjb2Rlc1tiMF0uc3Vic3RyaW5nKDAsIDMpO1xyXG4gICAgY29uc3QgbW9kZSA9IG9wY29kZXNbYjBdLnN1YnN0cmluZyg0KTtcclxuICAgIGxpbmUgKz0gb3A7XHJcblxyXG4gICAgLy8gRGlzcGxheSB0aGUgcGFyYW1ldGVyc1xyXG4gICAgY29uc3QgdGFibGUgPSB7XHJcbiAgICAgIFwiQVwiOiAgICAgKCkgPT4gYGAsXHJcbiAgICAgIFwiaW1wbFwiOiAgKCkgPT4gYGAsXHJcbiAgICAgIFwienBnXCI6ICAgKCkgPT4gYCAkeyR4eChiMSl9YCxcclxuICAgICAgXCJ6cGcsWFwiOiAoKSA9PiBgICR7JHh4KGIxKX0sWGAsXHJcbiAgICAgIFwienBnLFlcIjogKCkgPT4gYCAkeyR4eChiMSl9LFlgLFxyXG4gICAgICBcImFic1wiOiAgICgpID0+IGAgJHskeHgoYjIsIDIpfSR7eHgoYjEsIDIpfWAsXHJcbiAgICAgIFwiYWJzLFhcIjogKCkgPT4gYCAkeyR4eChiMiwgMil9JHt4eChiMSwgMil9LFhgLFxyXG4gICAgICBcImFicyxZXCI6ICgpID0+IGAgJHskeHgoYjIsIDIpfSR7eHgoYjEsIDIpfSxZYCxcclxuICAgICAgXCJpbmRcIjogICAoKSA9PiBgICgkeyR4eChiMiwgMil9JHt4eChiMSwgMil9KWAsXHJcbiAgICAgIFwiWCxpbmRcIjogKCkgPT4gYCAoJHskeHgoYjEpfSxYKWAsXHJcbiAgICAgIFwiaW5kLFlcIjogKCkgPT4gYCAoJHskeHgoYjEsIDIpfSksWWAsXHJcbiAgICAgIFwiI1wiOiAgICAgKCkgPT4gYCAjJHskeHgoYjEsIDIpfWAsXHJcbiAgICAgIFwicmVsXCI6ICAgKCkgPT4gYCAkeyR4eHh4KGFkZHIgKyB1aW50OFRvTnVtKGIxKSArIDIpfWAsXHJcbiAgICAgIFwiXCI6ICAgICAgKCkgPT4gYGAsXHJcbiAgICB9O1xyXG5cclxuICAgIGxpbmUgKz0gdGFibGVbbW9kZV0oKTtcclxuICAgIGFkZHIgKz0gbGVuZ3RoO1xyXG5cclxuICAgIGxpbmVzLnB1c2gobGluZSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbGluZXMuam9pbihcIlxcblwiKTtcclxufVxyXG4iLCIvKlxyXG4gICBBIHRvb2wgZm9yIGluamVjdGluZyBQUkcgZmlsZXMgKEM2NCBwcm9ncmFtcykgaW50byBtZW1vcnkuXHJcblxyXG4gICBUaGUgZmlsZSBmb3JtYXQgaXMgc3VwZXItc2ltcGxlOiBpdCdzIGp1c3QgdGhlIGxvYWQgYWRkcmVzcyAoaW4gbG93Ynl0ZS9cclxuICAgaGlnaGJ5dGUgZm9ybSkgZm9sbG93ZWQgYnkgYW4gYXJiaXRyYXJ5IHNlcXVlbmNlIG9mIGJ5dGVzIHRvIHN0b3JlIHRoZXJlLlxyXG4gICBCdXQgdGhlcmUncyBhIGxpdHRsZSBtb3JlIG1hbmlwdWxhdGlvbiByZXF1aXJlZCB0aGFuIGp1c3QgYmxhc3RpbmcgdGhlbSBpbi5cclxuICAgKFRPRE86IC4uLnRoYXQncyBiYXNlZCBvbiBndWVzc3dvcmssIGxvb2tpbmcgYXQgb2J2aW91cyBwb2ludGVycyBpbiB0aGVcclxuICAgbWVtb3J5IG1hcCBhbmQgc2VlaW5nIHdoYXQgd29ya3MuIEkgc2hvdWxkIHN0dWZ5IHRoZSBLZXJuYWwncyBmaWxlIGxvYWRlciBhdFxyXG4gICBzb21lIHBvaW50IHRvIHNlZSBpZiB0aGVyZSdzIGFueXRoaW5nIGVsc2UuKVxyXG4qL1xyXG5cclxuaW1wb3J0IHsgbWFrZVBhcnNlciB9IGZyb20gXCIuLi90b29scy9wYXJzZXJcIjtcclxuXHJcbmNvbnN0IHBhcnNlUHJnID0gbWFrZVBhcnNlcigoXykgPT4gKHtcclxuICBvcmc6ICAgICBfLndvcmRfbGUoKSxcclxuICBwcm9ncmFtOiBfLnJlbWFpbmRlcigpLFxyXG59KSk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbG9hZFByZyhjNjQsIGJ5dGVzKSB7XHJcbiAgY29uc3Qge3dpcmVzOiB7Y3B1UmVhZCwgY3B1V3JpdGV9fSA9IGM2NDtcclxuXHJcbiAgY29uc3QgeyBvcmcsIHByb2dyYW0gfSA9IHBhcnNlUHJnKGJ5dGVzKTtcclxuXHJcbiAgaWYgKG9yZyAhPT0gMHgwODAxKSB7XHJcbiAgICBjb25zb2xlLndhcm4oXCJFeHBlY3RpbmcgUFJHcyB0byBiZSBsb2FkZWQgdG8gJDA4MDFcIik7XHJcbiAgfVxyXG5cclxuICAvLyBNYWtlIGEgcmVjb3JkIG9mIHRoZSBjdXJyZW50IG1lbW9yeSBtYXAgY29uZmlndWF0aW9uXHJcbiAgY29uc3QgZGlyICA9IGNwdVJlYWQoMCk7XHJcbiAgY29uc3QgcG9ydCA9IGNwdVJlYWQoMSk7XHJcblxyXG4gIC8vIFNldCB0aGUgbWVtb3J5IG1hcCB0byBhbGwtUkFNLiBJbiBvdGhlciB3b3JkcywgcGFnZSBvdXQgdGhlIE1NSU8sIGluIGNhc2VcclxuICAvLyB0aGUgUFJHJ3MgcmVhbGx5IGJpZy5cclxuICBjcHVXcml0ZSgwLCAwYjExMSk7XHJcbiAgY3B1V3JpdGUoMSwgMCk7XHJcblxyXG4gIC8vIFBlcmZvcm0gdGhlIG1haW4gd3JpdGVcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHByb2dyYW0ubGVuZ3RoOyBpKyspIGNwdVdyaXRlKG9yZyArIGksIHByb2dyYW1baV0pO1xyXG5cclxuICAvLyBIYXZpbmcgbG9hZGVkIHRoZSBwcm9ncmFtIGludG8gbWVtb3J5LCB3ZSBuZWVkIHRvIG1vdmUgdGhlIHBvaW50ZXJzIHRvXHJcbiAgLy8gQmFzaWMncyB2YXJpYWJsZSByZWdpb25zIHRvIHJpZ2h0IGFmdGVyIHRoZSBwcm9ncmFtLiBOb3JtYWxseSB0aGUgS2VybmFsJ3NcclxuICAvLyBsb2FkZXIgd291bGQgZG8gdGhpcyAoYW5kIG1heWJlIHdlIHNob3VsZCBiZSByZWx5aW5nIG9uIHRoYXQgdG8gbG9hZCBpblxyXG4gIC8vIFBSR3MgaW5zdGVhZCkuIElmIGl0J3Mgbm90IGRvbmUsIEJhc2ljIHByb2dyYW1zIHdvbid0IHdvcmssIGFzIHRoZSBzcGFjZVxyXG4gIC8vIHRoZXknbGwgYWxsb2NhdGUgZm9yIHRoZSB2YXJpYWJsZXMgd2lsbCBvdmVyd3JpdGUgdGhlIHN0YXJ0IG9mIHRoZSBwcm9ncmFtXHJcbiAgLy8gaXRzZWxmLlxyXG4gIGNvbnN0IGVuZE9mQmFzaWNQcmcgPSAweDA4MDEgKyBwcm9ncmFtLmxlbmd0aDtcclxuXHJcbiAgY29uc3QgaGkgPSBlbmRPZkJhc2ljUHJnID4+IDg7XHJcbiAgY29uc3QgbG8gPSBlbmRPZkJhc2ljUHJnICYgMHhmZjtcclxuXHJcbiAgY3B1V3JpdGUoMHgyZCwgbG8pOyAvLyBwb2ludGVyIHRvIGJlZ2lubmluZyBvZiB2YXJpYWJsZSBhcmVhLCBsb3ctYnl0ZVxyXG4gIGNwdVdyaXRlKDB4MmUsIGhpKTsgLy8gcG9pbnRlciB0byBiZWdpbm5pbmcgb2YgdmFyaWFibGUgYXJlYSwgaGlnaC1ieXRlXHJcblxyXG4gIGNwdVdyaXRlKDB4MmYsIGxvKTsgLy8gcG9pbnRlciB0byBiZWdpbm5pbmcgb2YgYXJyYXkgdmFyaWFibGUgYXJlYSwgbG93LWJ5dGVcclxuICBjcHVXcml0ZSgweDMwLCBoaSk7IC8vIHBvaW50ZXIgdG8gYmVnaW5uaW5nIG9mIGFycmF5IHZhcmlhYmxlIGFyZWEsIGhpZ2gtYnl0ZVxyXG5cclxuICBjcHVXcml0ZSgweDMxLCBsbyk7IC8vIHBvaW50ZXIgdG8gZW5kIG9mIGFycmF5IHZhcmlhYmxlIGFyZWEsIGxvdy1ieXRlXHJcbiAgY3B1V3JpdGUoMHgzMiwgaGkpOyAvLyBwb2ludGVyIHRvIGVuZCBvZiBhcnJheSB2YXJpYWJsZSBhcmVhLCBoaWdoLWJ5dGVcclxuXHJcbiAgLy8gUmVzdG9yZSB0aGUgQ1BVIHBvcnQsIHRvIHJldHVybiB0aGUgbWVtb3J5IG1hcHBpbmcgdG8gd2hhdCBpdCB3YXNcclxuICBjcHVXcml0ZSgwLCBkaXIpO1xyXG4gIGNwdVdyaXRlKDEsIHBvcnQpO1xyXG59XHJcbiIsImV4cG9ydCBjb25zdCBzeXN0ZW1QYWxldHRlID0gW1xyXG4gIDB4MDAwMDAwLCAgLy8gYmxhY2tcclxuICAweGZmZmZmZiwgIC8vIHdoaXRlXHJcbiAgMHg5OTQ0NDQsICAvLyByZWRcclxuICAweDg4Y2NjYywgIC8vIGN5YW5cclxuICAweDk5NTViYiwgIC8vIHB1cnBsZVxyXG4gIDB4NzdiYjQ0LCAgLy8gZ3JlZW5cclxuICAweDQ0MzNhYSwgIC8vIGJsdWVcclxuICAweGRkZGQ3NywgIC8vIHllbGxvd1xyXG4gIDB4OTk2NjIyLCAgLy8gb3JhbmdlXHJcbiAgMHg2NjQ0MDAsICAvLyBicm93blxyXG4gIDB4Y2M4ODg4LCAgLy8gcGlua1xyXG4gIDB4NjY2NjY2LCAgLy8gZGFyayBncmF5XHJcbiAgMHg4ODg4ODgsICAvLyBtaWQgZ3JheVxyXG4gIDB4YmJlZTk5LCAgLy8gbGlnaHQgZ3JlZW5cclxuICAweDg4NzdkZCwgIC8vIGxpZ2h0IGJsdWVcclxuICAweGJiYmJiYiwgIC8vIGxpZ2h0IGdyYXlcclxuXTtcclxuXHJcbi8vIEEgcmVhc3NpZ25tZW50IG9mIGx1bWluYW5jZSB2YWx1ZXMgdG8gdGhlIGRlZmF1bHQgcGFsZXR0ZSBmb3Igd2hlbiBpdCdzXHJcbi8vIHJlZHVjZWQgdG8gZ3JheXNjYWxlLiBNYW55IGNvbG9ycyB3b3VsZCBtYXAgdG8gdGhlIHNhbWUgdmFsdWVzIHVuZGVyIHRoZVxyXG4vLyB1c3VhbCBIU0wgZm9ybXVsYTsgdGhpcyBkaXN0cmlidXRlcyB0aGVtIGVub3VnaCB0aGF0IHRoZXkncmUgYWxsXHJcbi8vIGRpc3Rpbmd1aXNoYWJsZSBhZ2FpbnN0IGVhY2ggb3RoZXIuXHJcbmNvbnN0IGFkanVzdGVkTCA9IFtcclxuICAgIDAsICAgICAgIC8vIGJsYWNrXHJcbiAgMTAwLCAgICAgICAvLyB3aGl0ZVxyXG4gICA0MCwgICAgICAgLy8gcmVkXHJcbiAgIDY0LCAgICAgICAvLyBjeWFuXHJcbiAgIDQ2LCAgICAgICAvLyBwdXJwbGVcclxuICAgNTIsICAgICAgIC8vIGdyZWVuXHJcbiAgIDM0LCAgICAgICAvLyBibHVlXHJcbiAgIDgyLCAgICAgICAvLyB5ZWxsb3dcclxuICAgMjIsICAgICAgIC8vIG9yYW5nZVxyXG4gICAxNiwgICAgICAgLy8gYnJvd25cclxuICAgNzAsICAgICAgIC8vIHBpbmtcclxuICAgMjgsICAgICAgIC8vIGRhcmsgZ3JheVxyXG4gICA1OCwgICAgICAgLy8gbWlkIGdyYXlcclxuICAgOTQsICAgICAgIC8vIGxpZ2h0IGdyZWVuXHJcbiAgIDc2LCAgICAgICAvLyBsaWdodCBibHVlXHJcbiAgIDg4LCAgICAgICAvLyBsaWdodCBncmF5XHJcbl07XHJcblxyXG5leHBvcnQgY29uc3QgZ3JheXNjYWxlUGFsZXR0ZSA9IHN5c3RlbVBhbGV0dGUubWFwKFxyXG4gIChyZ2IsIGluZGV4KSA9PiB7XHJcblxyXG4gICAgY29uc3QgciA9IChyZ2IgJiAweGZmMDAwMCkgPj4gMTY7XHJcbiAgICBjb25zdCBnID0gKHJnYiAmIDB4MDBmZjAwKSA+PiAgODtcclxuICAgIGNvbnN0IGIgPSAocmdiICYgMHgwMDAwZmYpID4+ICAwO1xyXG5cclxuICAgIC8vIENvbnZlcnQgdG8gSFNMXHJcbiAgICBjb25zdCBbaCwgcywgbF0gPSByZ2JUb0hzbChyLCBnLCBiKTtcclxuXHJcbiAgICAvLyAuLi5hbmQgdGhlbiBiYWNrIHRvIFJHQiwgd2l0aCBubyBzYXR1cmF0aW9uLCBhbmQgc2NhbGVkLCBudWRnZWQgbHVtaW5hbmNlXHJcbiAgICB7XHJcbiAgICAgIGNvbnN0IFtyLCBnLCBiXSA9IGhzbFRvUmdiKFxyXG4gICAgICAgIGgsXHJcbiAgICAgICAgMCxcclxuICAgICAgICBsZXJwKGFkanVzdGVkTFtpbmRleF0sIDAsIDEwMCwgMjAsIDYwKVxyXG4gICAgICApO1xyXG5cclxuICAgICAgcmV0dXJuIHJnYlRvSW50KHIsIGcsIGIpO1xyXG4gICAgfVxyXG4gIH1cclxuKTtcclxuXHJcblxyXG4vLyBoaWdobGlnaHRQYWxldHRlczogYW4gYXJyYXkgb2YgOCBwYWxldHRlcy5cclxuLy8gaGlnaGxpZ2h0UGFsZXR0ZXNbMF1bY29sb3JDb2RlXSB3b3VsZCBnaXZlIGEgcmVkLWlzaCBoaWdobGlnaHQgZm9yIGNvbG9yQ29kZS5cclxuLy8gaGlnaGxpZ2h0UGFsZXR0ZXNbMV1bY29sb3JDb2RlXSB3b3VsZCBiZSBtb3JlIG9yYW5nZSwgZXRjLlxyXG5leHBvcnQgY29uc3QgaGlnaGxpZ2h0UGFsZXR0ZXMgPSBbXTtcclxuXHJcbmZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XHJcblxyXG4gIGhpZ2hsaWdodFBhbGV0dGVzW2ldID0gbmV3IEFycmF5KDE2KTtcclxuXHJcbiAgZm9yIChsZXQgY2MgPSAwOyBjYyA8IDE2OyBjYysrKSB7XHJcblxyXG4gICAgY29uc3QgW3IsIGcsIGJdID0gaHNsVG9SZ2IoXHJcbiAgICAgIC8vIE1ha2UgZWFjaCBpbmRleCA0NcKwIGFyb3VuZCB0aGUgY29sb3Igd2hlZWxcclxuICAgICAgaSAqICgzNjAgLyA4KSxcclxuICAgICAgLy8gLi4ud2l0aCBhIGZpeGVkIHNhdHVyYXRpb24gdGhhdCdzIG5vdCBleGNlc3NpdmVcclxuICAgICAgNTAsXHJcbiAgICAgIC8vIC4uLmFuZCBhIGx1bWluYW5jZSB0aGF0J3MgcHJvcG9ydGlvbmFsIHRvIHRoZSAobnVkZ2VkKSBvcmlnaW5hbCxcclxuICAgICAgLy8gc2NhbGVkIHRvIGF2b2lkIGl0IGJlaW5nIG92ZXItYnJpZ2h0LCBvciB0b28gZGFyayB0byBjbGVhcmx5IHNlZSB0aGVcclxuICAgICAgLy8gaHVlLlxyXG4gICAgICBsZXJwKGFkanVzdGVkTFtjY10sIDAsIDEwMCwgNDUsIDcwKVxyXG4gICAgKTtcclxuXHJcbiAgICBoaWdobGlnaHRQYWxldHRlc1tpXVtjY10gPSByZ2JUb0ludChyLCBnLCBiKTtcclxuICB9XHJcbn1cclxuXHJcblxyXG4vLyBjb2xvckNvbG9yUGFsZXR0ZXM6IGFuIGFycmF5IG9mIDE2IHBhbGV0dGVzLlxyXG4vLyBjb2xvckNvbG9yUGFsZXR0ZXNbMl1bM10gd291bGQgZ2l2ZSBjb2xvciBjb2RlIDIgKHJlZCksIHdpdGggYSBoaW50IG9mIHRoZVxyXG4vLyAobnVkZ2VkKSBncmF5c2NhbGUgYnJpZ2h0bmVzcyBvZiBjb2xvciBjb2RlIDMgKGN5YW4pXHJcbmV4cG9ydCBjb25zdCBjb2xvckNvbG9yUGFsZXR0ZXMgPSBbXTtcclxuXHJcbmZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xyXG5cclxuICBjb2xvckNvbG9yUGFsZXR0ZXNbaV0gPSBuZXcgQXJyYXkoMTYpO1xyXG4gIGNvbnN0IFtoLCBzLCBsXSA9IHJnYlRvSHNsKC4uLmludFRvUmdiKHN5c3RlbVBhbGV0dGVbaV0pKTtcclxuXHJcbiAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgaisrKSB7XHJcblxyXG4gICAgY29uc3QgbW9kdWxhdGVkTCA9IGxlcnAoXHJcbiAgICAgIGwgKyAoKChhZGp1c3RlZExbal0gLSA1MCkgLyAxMDApICogMTApLFxyXG4gICAgICAtNSxcclxuICAgICAgMTA1LFxyXG4gICAgICAwLFxyXG4gICAgICAxMDBcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgW3IsIGcsIGJdID0gaHNsVG9SZ2IoaCwgcywgbW9kdWxhdGVkTCk7XHJcblxyXG4gICAgY29sb3JDb2xvclBhbGV0dGVzW2ldW2pdID0gcmdiVG9JbnQociwgZywgYik7XHJcbiAgfVxyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gbGVycCh2YWwsIHNyY01pbiwgc3JjTWF4LCBkZXN0TWluLCBkZXN0TWF4KSB7XHJcbiAgcmV0dXJuIGRlc3RNaW4gKyAoKCh2YWwgLSBzcmNNaW4pIC8gKHNyY01heCAtIHNyY01pbikpICogKGRlc3RNYXggLSBkZXN0TWluKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJnYlRvSHNsKHIsZyxiKSB7XHJcbiAgLy8gU291cmNlOiBodHRwczovL2Nzcy10cmlja3MuY29tL2NvbnZlcnRpbmctY29sb3Itc3BhY2VzLWluLWphdmFzY3JpcHQvXHJcblxyXG4gIC8vIE1ha2UgciwgZywgYW5kIGIgZnJhY3Rpb25zIG9mIDFcclxuICByIC89IDI1NTtcclxuICBnIC89IDI1NTtcclxuICBiIC89IDI1NTtcclxuXHJcbiAgLy8gRmluZCBncmVhdGVzdCBhbmQgc21hbGxlc3QgY2hhbm5lbCB2YWx1ZXNcclxuICBsZXQgY21pbiA9IE1hdGgubWluKHIsZyxiKTtcclxuICBsZXQgY21heCA9IE1hdGgubWF4KHIsZyxiKTtcclxuICBsZXQgZGVsdGEgPSBjbWF4IC0gY21pbjtcclxuICBsZXQgaCA9IDA7XHJcbiAgbGV0IHMgPSAwO1xyXG4gIGxldCBsID0gMDtcclxuXHJcbiAgLy8gQ2FsY3VsYXRlIGh1ZVxyXG4gIC8vIE5vIGRpZmZlcmVuY2VcclxuICBpZiAgICAgIChkZWx0YSA9PT0gMCkgaCA9IDA7XHJcbiAgZWxzZSBpZiAoY21heCA9PT0gcikgIGggPSAoKGcgLSBiKSAvIGRlbHRhKSAlIDY7XHJcbiAgZWxzZSBpZiAoY21heCA9PT0gZykgIGggPSAgKGIgLSByKSAvIGRlbHRhICsgMjtcclxuICBlbHNlICAgICAgICAgICAgICAgICAgaCA9ICAociAtIGcpIC8gZGVsdGEgKyA0O1xyXG5cclxuICBoID0gTWF0aC5yb3VuZChoICogNjApO1xyXG4gICAgXHJcbiAgLy8gTWFrZSBuZWdhdGl2ZSBodWVzIHBvc2l0aXZlIGJlaGluZCAzNjDCsFxyXG4gIGlmIChoIDwgMCkgaCArPSAzNjA7XHJcblxyXG4gICAvLyBDYWxjdWxhdGUgbGlnaHRuZXNzXHJcbiAgbCA9IChjbWF4ICsgY21pbikgLyAyO1xyXG5cclxuICAvLyBDYWxjdWxhdGUgc2F0dXJhdGlvblxyXG4gIHMgPSBkZWx0YSA9PT0gMCA/IDAgOiBkZWx0YSAvICgxIC0gTWF0aC5hYnMoMiAqIGwgLSAxKSk7XHJcbiAgICBcclxuICAvLyBNdWx0aXBseSBsIGFuZCBzIGJ5IDEwMFxyXG4gIHMgPSArKHMgKiAxMDApLnRvRml4ZWQoMSk7XHJcbiAgbCA9ICsobCAqIDEwMCkudG9GaXhlZCgxKTtcclxuXHJcbiAgcmV0dXJuIFtoLCBzLCBsXTtcclxufVxyXG5cclxuZnVuY3Rpb24gaHNsVG9SZ2IoaCxzLGwpIHtcclxuICAvLyBTb3VyY2U6IGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vY29udmVydGluZy1jb2xvci1zcGFjZXMtaW4tamF2YXNjcmlwdC9cclxuXHJcbiAgLy8gTXVzdCBiZSBmcmFjdGlvbnMgb2YgMVxyXG4gIHMgLz0gMTAwO1xyXG4gIGwgLz0gMTAwO1xyXG5cclxuICBsZXQgYyA9ICgxIC0gTWF0aC5hYnMoMiAqIGwgLSAxKSkgKiBzO1xyXG4gIGxldCB4ID0gYyAqICgxIC0gTWF0aC5hYnMoKGggLyA2MCkgJSAyIC0gMSkpO1xyXG4gIGxldCBtID0gbCAtIGMvMjtcclxuICBsZXQgciA9IDA7XHJcbiAgbGV0IGcgPSAwO1xyXG4gIGxldCBiID0gMDtcclxuXHJcbiAgaWYgICAgICAoICAwIDw9IGggJiYgaCA8IDYwICkgeyByID0gYzsgZyA9IHg7IGIgPSAwOyB9XHJcbiAgZWxzZSBpZiAoIDYwIDw9IGggJiYgaCA8IDEyMCkgeyByID0geDsgZyA9IGM7IGIgPSAwOyB9XHJcbiAgZWxzZSBpZiAoMTIwIDw9IGggJiYgaCA8IDE4MCkgeyByID0gMDsgZyA9IGM7IGIgPSB4OyB9XHJcbiAgZWxzZSBpZiAoMTgwIDw9IGggJiYgaCA8IDI0MCkgeyByID0gMDsgZyA9IHg7IGIgPSBjOyB9XHJcbiAgZWxzZSBpZiAoMjQwIDw9IGggJiYgaCA8IDMwMCkgeyByID0geDsgZyA9IDA7IGIgPSBjOyB9XHJcbiAgZWxzZSBpZiAoMzAwIDw9IGggJiYgaCA8IDM2MCkgeyByID0gYzsgZyA9IDA7IGIgPSB4OyB9XHJcbiAgXHJcbiAgciA9IE1hdGgucm91bmQoKHIgKyBtKSAqIDI1NSk7XHJcbiAgZyA9IE1hdGgucm91bmQoKGcgKyBtKSAqIDI1NSk7XHJcbiAgYiA9IE1hdGgucm91bmQoKGIgKyBtKSAqIDI1NSk7XHJcblxyXG4gIHJldHVybiBbciwgZywgYl07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGludFRvUmdiKGkpIHtcclxuICByZXR1cm4gW1xyXG4gICAgKGkgPj4gMTYpICYgMHhmZixcclxuICAgIChpID4+ICA4KSAmIDB4ZmYsXHJcbiAgICAoaSA+PiAgMCkgJiAweGZmLFxyXG4gIF07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJnYlRvSW50KHIsIGcsIGIpIHtcclxuICByZXR1cm4gKFxyXG4gICAgKE1hdGguZmxvb3IocikgPDwgMTYpIHxcclxuICAgIChNYXRoLmZsb29yKGcpIDw8ICA4KSB8XHJcbiAgICAoTWF0aC5mbG9vcihiKSA8PCAgMClcclxuICApO1xyXG59XHJcbiIsIi8qXHJcbiAgbWFrZVBhcnNlciB0dXJucyBzY2hlbWEgZnVuY3Rpb25zIGludG8gcGFyc2VycyB0aGF0IGNhbiB0dXJuIGJ5dGUgYXJyYXlzIHRvXHJcbiAgc3RydWN0dXJlcy5cclxuXHJcbiAgLi4ubWVhbmluZyB0aGF0IHlvdSBjYW4gY3JlYXRlIGEgcGFyc2VyIHdpdGg6XHJcblxyXG4gICAgICAgICAgICBjb25zdCBteVBhcnNlciA9IG1ha2VQYXJzZXIoKF8pID0+ICh7XHJcbiAgICAgICAgICAgICAgZGVzYzogICAgXy5zdHJpbmcoMzIpLFxyXG4gICAgICAgICAgICAgIHZlcnNpb246IF8uYnl0ZSgpLFxyXG4gICAgICAgICAgICAgIF86ICAgICAgIF8uc2tpcCgyKSxcclxuICAgICAgICAgICAgICBzdGFydDogICBfLndvcmRfbGUoKSxcclxuICAgICAgICAgICAgICBsZW5ndGg6ICBfLmxvbmdfbGUoKSxcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgLi4udGhlbiBjYWxsIGl0IHdpdGg6XHJcblxyXG4gICAgICAgICAgICBjb25zdCBteVN0cnVjdCA9IG15UGFyc2VyKFsuLiwgLi4sIC4uXSk7XHJcblxyXG4gIC4uLnRvIGdldDpcclxuXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBkZXNjOiAgICBcIi4uLlwiLFxyXG4gICAgICAgICAgICAgIHZlcnNpb246IDQsXHJcbiAgICAgICAgICAgICAgc3RhcnQ6ICAgMTIsXHJcbiAgICAgICAgICAgICAgbGVuZ3RoOiAgMTA0ODU3NixcclxuICAgICAgICAgICAgfVxyXG5cclxuICAuLi5vciBhbiBleGNlcHRpb24gaWYgZGF0YSBvdmVyZmxvd3MuXHJcblxyXG4gIE5vdGUgdGhhdCB5b3UnbGwgaGF2ZSB0byBiZSBleHBsaWNpdCBhYm91dCB0aGUgYnl0ZSBvcmRlcmluZyBvZiB3b3Jkc1xyXG4gICgxNi1iaXQpIGFuZCBsb25ncyAoMzItYml0KTogdXNlIHN1ZmZpeCBfYmUgZm9yIGJpZyBlbmRpYW4gYW5kIF9sZSBmb3JcclxuICBsaXR0bGUtZW5kaWFuLlxyXG4qL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VQYXJzZXIoZm4pIHtcclxuICByZXR1cm4gKGJ5dGVzKSA9PiB7XHJcblxyXG4gICAgbGV0IG9mZnNldCA9IDA7XHJcbiAgICBmdW5jdGlvbiBuZXh0Qnl0ZSgpIHtcclxuICAgICAgaWYgKG9mZnNldCA+PSBieXRlcy5sZW5ndGgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFkaW5nIHBhc3QgdGhlIGVuZCBvZiBkYXRhXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBieXRlc1tvZmZzZXQrK107XHJcbiAgICB9IFxyXG5cclxuICAgIGZ1bmN0aW9uIHJlbWFpbmRlcigpIHtcclxuICAgICAgY29uc3QgcmV0ID0gYnl0ZXMuc2xpY2Uob2Zmc2V0KTtcclxuICAgICAgb2Zmc2V0ID0gYnl0ZXMubGVuZ3RoIC0gMTtcclxuICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZm4oe1xyXG4gICAgICBieXRlOiAgICAgICgpID0+IGJ5dGUobmV4dEJ5dGUpLFxyXG4gICAgICB3b3JkX2JlOiAgICgpID0+IHdvcmRfYmUobmV4dEJ5dGUpLFxyXG4gICAgICB3b3JkX2xlOiAgICgpID0+IHdvcmRfbGUobmV4dEJ5dGUpLFxyXG4gICAgICBsb25nX2JlOiAgICgpID0+IGxvbmdfYmUobmV4dEJ5dGUpLFxyXG4gICAgICBsb25nX2xlOiAgICgpID0+IGxvbmdfbGUobmV4dEJ5dGUpLFxyXG4gICAgICBza2lwOiAgICAgIChsZW5ndGgpID0+IHNraXAobmV4dEJ5dGUsIGxlbmd0aCksXHJcbiAgICAgIHN0cmluZzogICAgKGxlbmd0aCkgPT4gc3RyaW5nKG5leHRCeXRlLCBsZW5ndGgpLFxyXG4gICAgICByZW1haW5kZXIsXHJcbiAgICB9KTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBieXRlKG5leHRCeXRlKSB7XHJcbiAgcmV0dXJuIG5leHRCeXRlKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdvcmRfbGUobmV4dEJ5dGUpIHtcclxuICByZXR1cm4gbmV4dEJ5dGUoKSB8IChuZXh0Qnl0ZSgpIDw8IDgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB3b3JkX2JlKG5leHRCeXRlKSB7XHJcbiAgcmV0dXJuIChuZXh0Qnl0ZSgpIDw8IDgpIHwgbmV4dEJ5dGUoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbG9uZ19sZShuZXh0Qnl0ZSkge1xyXG4gIHJldHVybiAoXHJcbiAgICAobmV4dEJ5dGUoKSA8PCAwKSAgfHxcclxuICAgIChuZXh0Qnl0ZSgpIDw8IDgpICB8fFxyXG4gICAgKG5leHRCeXRlKCkgPDwgMTYpIHx8XHJcbiAgICAobmV4dEJ5dGUoKSA8PCAyNClcclxuICApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsb25nX2JlKG5leHRCeXRlKSB7XHJcbiAgcmV0dXJuIChcclxuICAgIChuZXh0Qnl0ZSgpIDw8IDI0KSAgfHxcclxuICAgIChuZXh0Qnl0ZSgpIDw8IDE2KSAgfHxcclxuICAgIChuZXh0Qnl0ZSgpIDw8IDgpICAgfHxcclxuICAgIChuZXh0Qnl0ZSgpIDw8IDApXHJcbiAgKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2tpcChuZXh0Qnl0ZSwgbGVuZ3RoKSB7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgbmV4dEJ5dGUoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc3RyaW5nKG5leHRCeXRlLCBsZW5ndGgpIHtcclxuICBsZXQgcmV0ID0gXCJcIjtcclxuICBsZXQgZW5kZWQgPSBmYWxzZTtcclxuXHJcbiAgZm9yIChsZXQgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgbGVuZ3RoOyBvZmZzZXQrKykge1xyXG4gICAgY29uc3QgYnl0ZSA9IG5leHRCeXRlKCk7XHJcbiAgICBpZiAoZW5kZWQpIGNvbnRpbnVlO1xyXG4gICAgaWYgKCFieXRlKSBlbmRlZCA9IHRydWU7XHJcbiAgICBlbHNlIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJldC50cmltKCk7XHJcbn1cclxuIiwiLy8gQWRkcmVzc2VzIG9mIG5vdGFibGUgcm91dGluZXMgYW5kIGJ1ZmZlcnMgaW4gQmFzaWMgb3IgS2VybmFsLiBcclxuLy8gSGFuZHkgZm9yIHVzZSBhcyBicmVha3BvaW50cyB3aGVuIGNvbnRyb2xsaW5nIHRoZSBydW5sb29wIGZyb20gYSBzY3JpcHQuXHJcblxyXG4vLyBXYXJtIHN0YXJ0IChwcmludHMgdGhlIFJFQURZLiBwcm9tcHQpXHJcbmV4cG9ydCBjb25zdCBSRUFEWV9QQyA9IDB4YTQ3NDtcclxuXHJcbi8vIEEgbG9vcCB0aGF0IHdhaXRzIGZvciBhIGtleSB0byBiZSB0eXBlZFxyXG5leHBvcnQgY29uc3QgQVdBSVRfS0VZQk9BUkRfUEMgPSAweGU1Y2Q7XHJcblxyXG4vLyBDbGVhciBzY3JlZW5cclxuZXhwb3J0IGNvbnN0IENMRUFSX1NDUkVFTl9QQyA9IDB4ZTU0NDtcclxuXHJcblxyXG4vLyBCZWxvdyBhcmUgYWRkcmVzcyB0aGF0IGFyZW4ndCBST00gbG9jYXRpb25zLCBidXQgbWFnaWMgbnVtYmVycyBoYXJkY29kZWRcclxuLy8gaW50byB0aGUgUk9NIHJvdXRpbmVzLlxyXG5cclxuLy8gQ3Vyc29yIGNvbG9yIGNvZGVcclxuZXhwb3J0IGNvbnN0IENVUlNPUl9DT0xfQUREUiA9IDB4MDI4NjtcclxuXHJcbi8vIFRoZSBrZXlib2FyZCBidWZmZXJcclxuZXhwb3J0IGNvbnN0IEtFWUJPQVJEX0JVRkZFUl9BRERSICAgPSAweDAyNzc7IC8vICdrZXlkJ1xyXG5leHBvcnQgY29uc3QgS0VZQk9BUkRfQlVGRkVSX0lOREVYICA9IDB4MDBjNjsgLy8gJ25keCdcclxuZXhwb3J0IGNvbnN0IEtFWUJPQVJEX0JVRkZFUl9MRU5HVEggPSAxMDtcclxuIiwiY29uc3QgcmVnaXN0cnkgPSB7fTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGRUb1NlcmlhbGl6ZXJSZWdpc3RyeShvYmopIHtcclxuICBmb3IgKGxldCBmbk5hbWUgaW4gb2JqKSB7XHJcblxyXG4gICAgaWYgKHJlZ2lzdHJ5W2ZuTmFtZV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE11bHRpcGxlIGZ1bmN0aW9ucyBuYW1lZCAke25hbWV9IGFkZGVkIHRvIHNlcmlhbGl6ZXIgcmVnaXN0cnlgKTtcclxuICAgIH1cclxuXHJcbiAgICByZWdpc3RyeVtmbk5hbWVdID0gb2JqW2ZuTmFtZV07XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZnVuY3Rpb25Ub1JlZmVyZW5jZShmbikge1xyXG4gIGlmIChmbiA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XHJcblxyXG4gIC8vIFRoaXMgY291bGQgYWx0ZXJuYXRpdmVseSBiZSBkb25lIHdpdGggYSBNYXAgd2hlcmUgdGhlIGtleXMgYXJlIGZ1bmN0aW9ucyxcclxuICAvLyBidXQgaXQncyBzdWNoIGFuIGluZnJlcXVlbnRseS1jYWxsZWQgaGVscGVyLCB3aHkgc3BlbmQgdGhlIGV4dHJhIG1lbW9yeT9cclxuICBmb3IgKGxldCBpIGluIHJlZ2lzdHJ5KSB7XHJcbiAgICBpZiAocmVnaXN0cnlbaV0gPT09IGZuKSByZXR1cm4gaTtcclxuICB9XHJcblxyXG4gIGNvbnNvbGUuZXJyb3IoXCJTZXJpYWxpemVyIHJlZ2lzdHJ5IGhhcyBubyBlbnRyeSBmb3IgZnVuY3Rpb246XCIsIGZuKTtcclxuICB0aHJvdyBuZXcgRXJyb3IoYFNlcmlhbGl6ZXIgcmVnaXN0cnkgaGFzIG5vIGVudHJ5IGZvciBmdW5jdGlvbmApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVmZXJlbmNlVG9GdW5jdGlvbihuYW1lKSB7XHJcbiAgaWYgKG5hbWUgPT09IG51bGwpIHJldHVybiBudWxsO1xyXG5cclxuICBpZiAocmVnaXN0cnlbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBTZXJpYWxpemVyIHJlZ2lzdHJ5IGhhcyBubyBlbnRyeSBmb3IgYSBmdW5jdGlvbiBuYW1lZCAke25hbWV9YCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVnaXN0cnlbbmFtZV07XHJcbn1cclxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCIvLyBIb3N0IGludGVyZmFjZXNcclxuaW1wb3J0IHsgYXR0YWNoIGFzIHZpZGVvICAgIH0gZnJvbSBcIi4uL2hvc3QvdmlkZW8tY2FudmFzXCI7XHJcbmltcG9ydCB7IGF0dGFjaCBhcyBhdWRpbyAgICB9IGZyb20gXCIuLi9ob3N0L2F1ZGlvLU9zY2lsbGF0b3JOb2RlXCI7XHJcbmltcG9ydCB7IGF0dGFjaCBhcyBqb3lzdGljayB9IGZyb20gXCIuLi9ob3N0L2pveXN0aWNrLUtleWJvYXJkRXZlbnRcIjtcclxuaW1wb3J0IHsgYXR0YWNoIGFzIGtleWJvYXJkIH0gZnJvbSBcIi4uL2hvc3Qva2V5Ym9hcmQtS2V5Ym9hcmRFdmVudFwiO1xyXG5cclxuLy8gVGFyZ2V0IGRldmljZXNcclxuaW1wb3J0IHsgYXR0YWNoIGFzIHdpcmVzIH0gZnJvbSBcIi4uL3RhcmdldC93aXJlc1wiO1xyXG5pbXBvcnQgeyBhdHRhY2ggYXMgcmFtICAgfSBmcm9tIFwiLi4vdGFyZ2V0L3JhbVwiO1xyXG5pbXBvcnQgeyBhdHRhY2ggYXMgdmljICAgfSBmcm9tIFwiLi4vdGFyZ2V0L3ZpY1wiO1xyXG5pbXBvcnQgeyBhdHRhY2ggYXMgc2lkICAgfSBmcm9tIFwiLi4vdGFyZ2V0L3NpZFwiO1xyXG5pbXBvcnQgeyBhdHRhY2ggYXMgY2lhcyAgfSBmcm9tIFwiLi4vdGFyZ2V0L2NpYXNcIjtcclxuaW1wb3J0IHsgYXR0YWNoIGFzIGNwdSAgIH0gZnJvbSBcIi4uL3RhcmdldC9jcHVcIjtcclxuaW1wb3J0IHsgYXR0YWNoIGFzIHRhcGUgIH0gZnJvbSBcIi4uL3RhcmdldC90YXBlXCI7XHJcblxyXG4vLyBST01zXHJcbmltcG9ydCBiYXNpYyAgICAgZnJvbSBcIi4uL3RhcmdldC9yb20vYmFzaWNcIjtcclxuaW1wb3J0IGtlcm5hbCAgICBmcm9tIFwiLi4vdGFyZ2V0L3JvbS9za2lwUmFtVGVzdFwiO1xyXG5pbXBvcnQgY2hhcmFjdGVyIGZyb20gXCIuLi90YXJnZXQvcm9tL2NoYXJhY3RlclwiO1xyXG5cclxuLy8gQnJpbmd1cFxyXG5pbXBvcnQgeyBicmluZ3VwIH0gZnJvbSBcIi4uL3RhcmdldC9icmluZ3VwXCI7XHJcblxyXG4vLyBFdmVyeXRoaW5nIGVsc2VcclxuaW1wb3J0IHsgYXR0YWNoIGFzIG1vbml0b3IgfSAgICAgZnJvbSBcIi4uL21vbml0b3JcIjtcclxuaW1wb3J0IHsgYXR0YWNoIGFzIHdlYkZyb250RW5kIH0gZnJvbSBcIi4uL2hvc3Qvd2ViRnJvbnRFbmRcIjtcclxuaW1wb3J0IHsgYXR0YWNoIGFzIGRyYWdBbmREcm9wIH0gZnJvbSBcIi4uL2hvc3QvZHJhZ0FuZERyb3BcIjtcclxuXHJcblxyXG5jb25zdCBjNjQgPSBicmluZ3VwKHtcclxuICBob3N0OiAgIHsgYXVkaW8sIHZpZGVvLCBrZXlib2FyZCwgam95c3RpY2sgfSxcclxuICB0YXJnZXQ6IHsgd2lyZXMsIHJhbSwgdmljLCBzaWQsIGNwdSwgY2lhcywgdGFwZSwgYmFzaWMsIGtlcm5hbCwgY2hhcmFjdGVyIH0sXHJcbiAgYXR0YWNobWVudHM6IFtcclxuICAgIG1vbml0b3IsXHJcbiAgICBkcmFnQW5kRHJvcCxcclxuICAgIHdlYkZyb250RW5kLFxyXG4gIF0sXHJcbn0pO1xyXG5cclxuYzY0LnJ1bmxvb3AucnVuKCk7XHJcblxyXG5cclxuLy8gVG8gcnVuIGEgdGVzdCBwcm9ncmFtIG9uIGxvYWQsIHVuY29tbWVudCB0aGUgYmVsb3c6XHJcbi8qXHJcbmltcG9ydCB7IGluZ2VzdCB9IGZyb20gXCIuLi9ob3N0L2luZ2VzdFwiO1xyXG5pbXBvcnQgcHJnIGZyb20gXCIuLi90ZXN0cy90b2QtcHJnLmpzXCI7XHJcblxyXG5pbmdlc3QoYzY0LCBcIi5wcmdcIiwgcHJnKTtcclxuKi9cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9